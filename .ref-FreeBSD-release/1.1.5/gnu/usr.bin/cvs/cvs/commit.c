begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * Commit Files  *   * "commit" commits the present version to the RCS repository, AFTER  * having done a test on conflicts.  *  * The call is: cvs commit [options] files...  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)commit.c 1.84 92/03/31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|Dtype
name|check_direntproc
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|repos
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|,
name|List
modifier|*
name|srcfiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|repos
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkaddfile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Dtype
name|commit_direntproc
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|repos
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|commit_dirleaveproc
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|commit_fileproc
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|,
name|List
modifier|*
name|srcfiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|commit_filesdoneproc
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finaladd
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|revision
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findmaxrev
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fsortcmp
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|,
name|Node
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lock_RCS
parameter_list|(
name|char
modifier|*
name|user
parameter_list|,
name|char
modifier|*
name|rcs
parameter_list|,
name|char
modifier|*
name|rev
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lock_filesdoneproc
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lockrcsfile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|rev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|precommit_list_proc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|precommit_proc
parameter_list|(
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remove_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_rcs_modes
parameter_list|(
name|char
modifier|*
name|rcs
parameter_list|,
name|char
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixaddfile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixbranch
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|branch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unlockrcs
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ci_delproc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|locate_rcs
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|rcs
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|fsortcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lock_filesdoneproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_fileproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Dtype
name|check_direntproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|precommit_list_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|precommit_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_filesdoneproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|commit_fileproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|commit_filesdoneproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Dtype
name|commit_direntproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|commit_dirleaveproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findmaxrev
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remove_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finaladd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unlockrcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixaddfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixbranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkaddfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lockrcsfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lock_RCS
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_rcs_modes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ci_delproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|locate_rcs
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_struct
struct|struct
name|commit_info
block|{
name|Ctype
name|status
decl_stmt|;
comment|/* as returned from Classify_File() */
name|char
modifier|*
name|rev
decl_stmt|;
comment|/* a numeric rev, if we know it */
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* any sticky tag, or -r option */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|master_lists
block|{
name|List
modifier|*
name|ulist
decl_stmt|;
comment|/* list for Update_Logfile */
name|List
modifier|*
name|cilist
decl_stmt|;
comment|/* list with commit_info structs */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|got_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|write_dirtag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|mulist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|locklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|commit_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-nRl] [-m msg | -f logfile] [-r rev] files...\n"
block|,
literal|"\t-n\tDo not run the module program (if any).\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-l\tLocal directory only (not recursive).\n"
block|,
literal|"\t-f file\tRead the log message from file.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
literal|"\t-r rev\tCommit to this branch or trunk revision.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|commit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVS_BADROOT
comment|/*      * For log purposes, do not allow "root" to commit files.  If you look      * like root, but are really logged in as a non-root user, it's OK.      */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|getcaller
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"you are unknown to this system"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot commit files as 'root'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CVS_BADROOT */
name|message
operator|=
name|xmalloc
argument_list|(
name|MAXMESGLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|message
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null message by default */
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gnu_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"nlRm:f:r:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|>=
operator|(
name|size_t
operator|)
name|MAXMESGLEN
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: message too long; truncated!"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|message
argument_list|,
name|optarg
argument_list|,
name|MAXMESGLEN
argument_list|)
expr_stmt|;
name|message
index|[
name|MAXMESGLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|message
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tag
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|logfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* numeric specified revision means we ignore sticky tags... */
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
name|aflag
operator|=
literal|1
expr_stmt|;
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* some checks related to the "-f logfile" option */
if|if
condition|(
name|logfile
condition|)
block|{
name|int
name|n
decl_stmt|,
name|logfd
decl_stmt|;
if|if
condition|(
operator|*
name|message
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot specify both a message and a log file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|logfd
operator|=
name|open
argument_list|(
name|logfile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|n
operator|=
name|read
argument_list|(
name|logfd
argument_list|,
name|message
argument_list|,
name|MAXMESGLEN
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read log message from %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|logfd
argument_list|)
expr_stmt|;
name|message
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* XXX - this is not the perfect check for this */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|write_dirtag
operator|=
name|tag
expr_stmt|;
comment|/*      * Run the recursion processor to find all the dirs to lock and lock all      * the dirs      */
name|locklist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
argument_list|,
name|lock_filesdoneproc
argument_list|,
operator|(
name|Dtype
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sortlist
argument_list|(
name|locklist
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Writer_Lock
argument_list|(
name|locklist
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"lock failed - giving up"
argument_list|)
expr_stmt|;
comment|/*      * Set up the master update list      */
name|mulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * Run the recursion processor to verify the files are all up-to-date      */
name|err
operator|=
name|start_recursion
argument_list|(
name|check_fileproc
argument_list|,
name|check_filesdoneproc
argument_list|,
name|check_direntproc
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct above errors first!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Run the recursion processor to commit the files      */
if|if
condition|(
name|noexec
operator|==
literal|0
condition|)
name|err
operator|=
name|start_recursion
argument_list|(
name|commit_fileproc
argument_list|,
name|commit_filesdoneproc
argument_list|,
name|commit_direntproc
argument_list|,
name|commit_dirleaveproc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Unlock all the dirs and clean up      */
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|mulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|locklist
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two lock list nodes (for sort)  */
end_comment

begin_function
specifier|static
name|int
name|fsortcmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create a list of repositories to lock  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|lock_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|LOCK
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|key
operator|==
name|NULL
operator|||
name|addnode
argument_list|(
name|locklist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a file is ok to commit and make sure all files are  * up-to-date  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|int
name|save_noexec
decl_stmt|,
name|save_quiet
decl_stmt|,
name|save_really_quiet
decl_stmt|;
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|save_quiet
operator|=
name|quiet
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|noexec
operator|=
name|quiet
operator|=
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* handle specified numeric revision specially */
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
comment|/* If the tag is for the trunk, make sure we're at the head */
if|if
condition|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|<
literal|2
condition|)
block|{
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|xtag
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* 	     * The revision is off the main trunk; make sure we're 	     * up-to-date with the head of the specified branch. 	     */
name|xtag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|xtag
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|=
name|rindex
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|T_REMOVE_ENTRY
operator|||
name|status
operator|==
name|T_CONFLICT
operator|)
operator|&&
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* pluck one more dot off the revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
block|}
comment|/* now, muck with vers to make the tag correct */
name|free
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|vers
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
name|quiet
operator|=
name|save_quiet
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_CHECKOUT
case|:
case|case
name|T_NEEDS_MERGE
case|:
case|case
name|T_CONFLICT
case|:
case|case
name|T_REMOVE_ENTRY
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Up-to-date check failed for `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MODIFIED
case|:
case|case
name|T_ADDED
case|:
case|case
name|T_REMOVED
case|:
comment|/* 	     * some quick sanity checks; if no numeric -r option specified: 	     *	- can't have a sticky date 	     *	- can't have a sticky tag that is not a branch 	     * Also, 	     *	- if status is T_REMOVED, can't have a numeric tag 	     *	- if status is T_ADDED, rcs file must not exist 	     *	- if status is T_ADDED, can't have a non-trunk numeric rev 	     */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|date
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot commit with sticky date for file `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|vers
operator|->
name|tag
operator|&&
operator|!
name|RCS_isbranch
argument_list|(
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|srcfiles
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sticky tag `%s' for file `%s' is not a branch"
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_REMOVED
operator|&&
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot remove file `%s' which has a numeric sticky tag of `%s'"
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' when RCS file `%s' already exists"
argument_list|,
name|file
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
operator|&&
name|numdots
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' with revision `%s'; must be on trunk"
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* done with consistency checks; now, to get on with the commit */
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xdir
operator|=
literal|"."
expr_stmt|;
else|else
name|xdir
operator|=
name|update_dir
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|xdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
block|}
else|else
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|cilist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|xdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|master_lists
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ulist
operator|=
name|ulist
expr_stmt|;
name|ml
operator|->
name|cilist
operator|=
name|cilist
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ml
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|mulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* first do ulist, then cilist */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|status
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|ci_delproc
expr_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_info
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|tag
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
name|ci
operator|->
name|rev
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|ci
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ci
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|cilist
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UNKNOWN
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_UPTODATE
case|:
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Unknown status 0x%x for `%s'"
argument_list|,
name|status
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print warm fuzzies while examining the dirs  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|check_direntproc
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Examining %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walklist proc to run pre-commit checks  */
end_comment

begin_function
specifier|static
name|int
name|precommit_list_proc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_ADDED
operator|||
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_MODIFIED
condition|)
name|run_arg
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback proc for pre-commit checking  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ulist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|precommit_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
comment|/* see if the filter is there, only if it's a full path */
if|if
condition|(
name|filter
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|isfile
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot find pre-commit filter `%s'"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* so it fails! */
block|}
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|filter
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|ulist
argument_list|,
name|precommit_list_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the pre-commit checks for the dir  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the checks if there's nothing to do */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* run any pre-commit checks */
if|if
condition|(
operator|(
name|n
operator|=
name|Parse_Info
argument_list|(
name|CVSROOTADM_COMMITINFO
argument_list|,
name|repos
argument_list|,
name|precommit_proc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pre-commit check failed"
argument_list|)
expr_stmt|;
name|err
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the work of committing a file  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sbranch
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_fileproc
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/*      * if p is null, there were file type command line args which were      * all up-to-date so nothing really needs to be done      */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
comment|/*      * At this point, we should have the commit message unless we were called      * with files as args from the command line.  In that latter case, we      * need to get the commit message ourselves      */
if|if
condition|(
name|use_editor
operator|&&
operator|!
name|got_message
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
name|do_editor
argument_list|(
name|update_dir
argument_list|,
name|message
argument_list|,
name|repository
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|cilist
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
if|if
condition|(
name|lockrcsfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|ci
operator|->
name|rev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
if|if
condition|(
name|checkaddfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fixaddfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/*      * Add the file for real      */
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
modifier|*
name|xrev
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
operator|==
name|NULL
condition|)
block|{
comment|/* find the max major rev number in this directory */
name|maxrev
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|entries
argument_list|,
name|findmaxrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxrev
operator|==
literal|0
condition|)
name|maxrev
operator|=
literal|1
expr_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%d"
argument_list|,
name|maxrev
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - an added file with symbolic -r should add tag as well */
name|err
operator|=
name|finaladd
argument_list|(
name|file
argument_list|,
name|ci
operator|->
name|rev
condition|?
name|ci
operator|->
name|rev
else|:
name|xrev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrev
condition|)
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|=
name|Checkin
argument_list|(
literal|'M'
argument_list|,
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|message
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_REMOVED
condition|)
name|err
operator|=
name|remove_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log the commit and clean up the update list  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|char
modifier|*
name|xtag
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
block|}
else|else
return|return
operator|(
name|err
operator|)
return|;
name|got_message
operator|=
literal|0
expr_stmt|;
comment|/* see if we need to specify a per-directory or -r option tag */
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
name|ParseTag
argument_list|(
operator|&
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|message
argument_list|,
name|tag
condition|?
name|tag
else|:
name|xtag
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|cilist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtag
condition|)
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|run_module_prog
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
comment|/* It is not an error if Checkin.prog does not exist.  */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|line
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s: Executing '"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the log message for a dir and print a warm fuzzy  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|commit_direntproc
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|char
modifier|*
name|real_repos
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the files as an optimization */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|R_SKIP_FILES
operator|)
return|;
comment|/* print the warm fuzzy */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Committing %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* get commit message */
if|if
condition|(
name|use_editor
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
name|real_repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|do_editor
argument_list|(
name|update_dir
argument_list|,
name|message
argument_list|,
name|real_repos
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_repos
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the post-commit proc if necessary  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_dirleaveproc
parameter_list|(
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
comment|/* update the per-directory tag info */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|write_dirtag
operator|!=
name|NULL
condition|)
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|write_dirtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find the maximum major rev number in an entries file  */
end_comment

begin_function
specifier|static
name|int
name|findmaxrev
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|thisrev
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|entdata
operator|->
name|version
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|thisrev
operator|=
name|atoi
argument_list|(
name|entdata
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|thisrev
operator|>
name|maxrev
condition|)
name|maxrev
operator|=
name|thisrev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually remove a file by moving it to the attic  * XXX - if removing a ,v file that is a relative symbolic link to  * another ,v file, we probably should add a ".." component to the  * link to keep it relative after we move it into the attic.  */
end_comment

begin_function
specifier|static
name|int
name|remove_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|omask
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
comment|/* a symbolic tag is specified; just remove the tag from the file */
name|run_setup
argument_list|(
literal|"%s%s -q -N%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|DEVNULL
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag `%s' from `%s'"
argument_list|,
name|tag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* no symbolic tag specified; really move it into the Attic */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
name|omask
operator|=
name|umask
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|tmp
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|rcs
argument_list|,
name|tmp
argument_list|)
operator|==
literal|0
operator|||
name|rename
argument_list|(
name|rcs
argument_list|,
name|tmp
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
operator|&&
name|isreadable
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|Scratch_Entry
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the actual checkin for added files  */
end_comment

begin_function
specifier|static
name|int
name|finaladd
parameter_list|(
name|file
parameter_list|,
name|rev
parameter_list|,
name|tag
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|Checkin
argument_list|(
literal|'A'
argument_list|,
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|,
name|rev
argument_list|,
name|tag
argument_list|,
name|message
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_OPT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|fixaddfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock an rcs file  */
end_comment

begin_function
specifier|static
name|void
name|unlockrcs
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s%s -q -u"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not unlock %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a partially added file.  if we can parse it, leave it alone.  */
end_comment

begin_function
specifier|static
name|void
name|fixaddfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|save_really_quiet
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|really_quiet
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
else|else
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put the branch back on an rcs file  */
end_comment

begin_function
specifier|static
name|void
name|fixbranch
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|branch
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
operator|&&
name|branch
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s%s -q -b%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"cannot restore branch to %s for %s"
argument_list|,
name|branch
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * do the initial part of a file add for the named file.  if adding  * with a tag, put the file in the Attic and point the symbolic tag  * at the committed revision.  */
end_comment

begin_function
specifier|static
name|int
name|checkaddfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
name|omask
operator|=
name|umask
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|rcs
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
else|else
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s%s -i"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|)
expr_stmt|;
name|run_args
argument_list|(
literal|"-t%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_OPT
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|fname
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|fname
condition|)
name|run_arg
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not create %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fix_rcs_modes
argument_list|(
name|rcs
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the rcs file ``file''  */
end_comment

begin_function
specifier|static
name|int
name|lockrcsfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|rev
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcs
argument_list|,
name|rev
argument_list|,
name|repository
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to place a lock on the RCS file; returns 0 if it could and 1 if it  * couldn't.  If the RCS file currently has a branch as the head, we must  * move the head back to the trunk before locking the file, and be sure to  * put the branch back as the head if there are any errors.  */
end_comment

begin_function
specifier|static
name|int
name|lock_RCS
parameter_list|(
name|user
parameter_list|,
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/*      * For a specified, numeric revision of the form "1" or "1.1", (or when      * no revision is specified ""), definitely move the branch to the trunk      * before locking the RCS file.      *       * The assumption is that if there is more than one revision on the trunk,      * the head points to the trunk, not a branch... and as such, it's not      * necessary to move the head in this case.      */
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
operator|(
name|rev
operator|&&
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
operator|&&
name|numdots
argument_list|(
name|rev
argument_list|)
operator|<
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* invalid rcs file? */
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* rcsfile is valid */
name|branch
operator|=
name|xstrdup
argument_list|(
name|rcsfile
operator|->
name|branch
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s%s -q -b"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot change branch to default for %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|run_setup
argument_list|(
literal|"%s%s -q -l"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|run_setup
argument_list|(
literal|"%s%s -q -l%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|rev
condition|?
name|rev
else|:
literal|""
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|DEVNULL
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|branch
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sbranch
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
else|else
name|sbranch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* try to restore the branch if we can on error */
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
name|fixbranch
argument_list|(
name|user
argument_list|,
name|repository
argument_list|,
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when "add"ing files to the RCS respository, as it is necessary to  * preserve the file modes in the same fashion that RCS does.  This would be  * automatic except that we are placing the RCS ,v file very far away from  * the user file, and I can't seem to convince RCS of the location of the  * user file.  So we munge it here, after the ,v file has been successfully  * initialized with "rcs -i".  */
end_comment

begin_function
specifier|static
name|void
name|fix_rcs_modes
parameter_list|(
name|rcs
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|user
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|rcs
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_mode
operator|&
operator|~
literal|0222
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free an UPDATE node's data (really nothing to do)  */
end_comment

begin_function
name|void
name|update_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the commit_info structure in p.  */
end_comment

begin_function
specifier|static
name|void
name|ci_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
condition|)
name|free
argument_list|(
name|ci
operator|->
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|tag
condition|)
name|free
argument_list|(
name|ci
operator|->
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an RCS file in the repository.  */
end_comment

begin_function
specifier|static
name|void
name|locate_rcs
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|rcs
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

