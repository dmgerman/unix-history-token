begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sort - sort lines of text (with all kinds of options).    Copyright (C) 1988, 1991 Free Software Foundation     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written December 1988 by Mike Haertel.    The author may be reached (Email) at the address mike@gnu.ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_BROKETS
argument_list|)
end_if

begin_comment
comment|/* We use<config.h> instead of "config.h" so that a compilation    using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h    (which it would do because it found this file in $srcdir).  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get isblank from GNU libc.  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"long-options.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_VERSION
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|UCHAR_LIM
value|(UCHAR_MAX + 1)
end_define

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c))
end_define

begin_comment
comment|/* The kind of blanks for '-b' to skip in various options. */
end_comment

begin_enum
enum|enum
name|blanktype
block|{
name|bl_start
block|,
name|bl_end
block|,
name|bl_both
block|}
enum|;
end_enum

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of digits. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|digits
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of white space. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blanks
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of non-printing characters. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nonprinting
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of non-dictionary characters (not letters, digits, or blanks). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nondictionary
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table folding lower case to upper. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fold_toupper
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table mapping 3-letter month names to integers.    Alphabetic order allows binary search. */
end_comment

begin_struct
specifier|static
struct|struct
name|month
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
decl|const
name|monthtab
index|[]
init|=
block|{
block|{
literal|"APR"
block|,
literal|4
block|}
block|,
block|{
literal|"AUG"
block|,
literal|8
block|}
block|,
block|{
literal|"DEC"
block|,
literal|12
block|}
block|,
block|{
literal|"FEB"
block|,
literal|2
block|}
block|,
block|{
literal|"JAN"
block|,
literal|1
block|}
block|,
block|{
literal|"JUL"
block|,
literal|7
block|}
block|,
block|{
literal|"JUN"
block|,
literal|6
block|}
block|,
block|{
literal|"MAR"
block|,
literal|3
block|}
block|,
block|{
literal|"MAY"
block|,
literal|5
block|}
block|,
block|{
literal|"NOV"
block|,
literal|11
block|}
block|,
block|{
literal|"OCT"
block|,
literal|10
block|}
block|,
block|{
literal|"SEP"
block|,
literal|9
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* During the merge phase, the number of files to merge at once. */
end_comment

begin_define
define|#
directive|define
name|NMERGE
value|16
end_define

begin_comment
comment|/* Initial buffer size for in core sorting.  Will not grow unless a    line longer than this is seen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sortalloc
init|=
literal|524288
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial buffer size for in core merge buffers.  Bear in mind that    up to NMERGE * mergealloc bytes may be allocated for merge buffers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mergealloc
init|=
literal|16384
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Guess of average line length. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linelength
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of elements for the array(s) of struct line's, in bytes.  */
end_comment

begin_define
define|#
directive|define
name|LINEALLOC
value|262144
end_define

begin_comment
comment|/* Prefix for temporary file names. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_file_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to reverse the order of all comparisons. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for stable sort.  This turns off the last ditch bytewise    comparison of lines, and instead leaves lines in the same order    they were read if all keys compare equal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tab character separating fields.  If NUL, then fields are separated    by the empty string between a non-whitespace character and a whitespace    character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to remove consecutive duplicate lines from the output.    Only the last of a sequence of equal lines will be output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unique
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any of the input files are the standard input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_read_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines are held in core as counted strings. */
end_comment

begin_struct
struct|struct
name|line
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Text of the line. */
name|int
name|length
decl_stmt|;
comment|/* Length not including final newline. */
name|char
modifier|*
name|keybeg
decl_stmt|;
comment|/* Start of first key. */
name|char
modifier|*
name|keylim
decl_stmt|;
comment|/* Limit of first key. */
block|}
struct|;
end_struct

begin_comment
comment|/* Arrays of lines. */
end_comment

begin_struct
struct|struct
name|lines
block|{
name|struct
name|line
modifier|*
name|lines
decl_stmt|;
comment|/* Dynamically allocated array of lines. */
name|int
name|used
decl_stmt|;
comment|/* Number of slots used. */
name|int
name|alloc
decl_stmt|;
comment|/* Number of slots allocated. */
name|int
name|limit
decl_stmt|;
comment|/* Max number of slots to allocate.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Input buffers. */
end_comment

begin_struct
struct|struct
name|buffer
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Dynamically allocated buffer. */
name|int
name|used
decl_stmt|;
comment|/* Number of bytes used. */
name|int
name|alloc
decl_stmt|;
comment|/* Number of bytes allocated. */
name|int
name|left
decl_stmt|;
comment|/* Number of bytes left after line parsing. */
block|}
struct|;
end_struct

begin_comment
comment|/* Lists of key field comparisons to be tried. */
end_comment

begin_struct
specifier|static
struct|struct
name|keyfield
block|{
name|int
name|sword
decl_stmt|;
comment|/* Zero-origin 'word' to start at. */
name|int
name|schar
decl_stmt|;
comment|/* Additional characters to skip. */
name|int
name|skipsblanks
decl_stmt|;
comment|/* Skip leading white space at start. */
name|int
name|eword
decl_stmt|;
comment|/* Zero-origin first word after field. */
name|int
name|echar
decl_stmt|;
comment|/* Additional characters in field. */
name|int
name|skipeblanks
decl_stmt|;
comment|/* Skip trailing white space at finish. */
name|int
modifier|*
name|ignore
decl_stmt|;
comment|/* Boolean array of characters to ignore. */
name|char
modifier|*
name|translate
decl_stmt|;
comment|/* Translation applied to characters. */
name|int
name|numeric
decl_stmt|;
comment|/* Flag for numeric comparison. */
name|int
name|month
decl_stmt|;
comment|/* Flag for comparison by month name. */
name|int
name|reverse
decl_stmt|;
comment|/* Reverse the sense of comparison. */
name|struct
name|keyfield
modifier|*
name|next
decl_stmt|;
comment|/* Next keyfield to try. */
block|}
name|keyhead
struct|;
end_struct

begin_comment
comment|/* The list of temporary files. */
end_comment

begin_struct
specifier|static
struct|struct
name|tempnode
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|next
decl_stmt|;
block|}
name|temphead
struct|;
end_struct

begin_comment
comment|/* Clean up any remaining temporary files. */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|temphead
operator|.
name|next
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|unlink
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate N bytes of memory dynamically, with error checking.  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Change the size of an allocated block of memory P to N bytes,    with error checking.    If P is NULL, run xmalloc.    If N is 0, run free and return NULL.  */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
name|xmalloc
argument_list|(
name|n
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|xfopen
parameter_list|(
name|file
parameter_list|,
name|how
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|how
decl_stmt|;
end_function

begin_block
block|{
name|FILE
modifier|*
name|fp
init|=
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|?
name|fopen
argument_list|(
name|file
argument_list|,
name|how
argument_list|)
else|:
name|stdin
decl_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
return|return
name|fp
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|xfclose
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|stdin
operator|&&
name|fp
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error closing file"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Allow reading stdin from tty more than once. */
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xfwrite
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|nelem
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|,
name|nelem
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|nelem
argument_list|,
name|fp
argument_list|)
operator|!=
name|nelem
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a name for a temporary file. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tempname
parameter_list|()
block|{
specifier|static
name|int
name|seq
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|temp_file_prefix
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|16
argument_list|)
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
init|=
operator|(
expr|struct
name|tempnode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tempnode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|&&
name|temp_file_prefix
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/sort%5.5d%5.5d"
argument_list|,
name|temp_file_prefix
argument_list|,
name|getpid
argument_list|()
argument_list|,
operator|++
name|seq
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%ssort%5.5d%5.5d"
argument_list|,
name|temp_file_prefix
argument_list|,
name|getpid
argument_list|()
argument_list|,
operator|++
name|seq
argument_list|)
expr_stmt|;
name|node
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|temphead
operator|.
name|next
expr_stmt|;
name|temphead
operator|.
name|next
operator|=
name|node
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Search through the list of temporary files for NAME;    remove it if it is found on the list. */
end_comment

begin_function
specifier|static
name|void
name|zaptemp
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|node
operator|=
operator|&
name|temphead
init|;
name|node
operator|->
name|next
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|node
operator|->
name|next
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|next
condition|)
block|{
name|temp
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|unlink
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the character class tables. */
end_comment

begin_function
specifier|static
name|void
name|inittables
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UCHAR_LIM
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ISBLANK
argument_list|(
name|i
argument_list|)
condition|)
name|blanks
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|i
argument_list|)
condition|)
name|digits
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|i
argument_list|)
condition|)
name|nonprinting
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|ISBLANK
argument_list|(
name|i
argument_list|)
condition|)
name|nondictionary
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISLOWER
argument_list|(
name|i
argument_list|)
condition|)
name|fold_toupper
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|fold_toupper
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize BUF, allocating ALLOC bytes initially. */
end_comment

begin_function
specifier|static
name|void
name|initbuf
parameter_list|(
name|buf
parameter_list|,
name|alloc
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|alloc
decl_stmt|;
block|{
name|buf
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|buf
operator|->
name|left
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill BUF reading from FP, moving buf->left bytes from the end    of buf->buf to the beginning first.	If EOF is reached and the    file wasn't terminated by a newline, supply one.  Return a count    of bytes buffered. */
end_comment

begin_function
specifier|static
name|int
name|fillbuf
parameter_list|(
name|buf
parameter_list|,
name|fp
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
name|bcopy
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
operator|-
name|buf
operator|->
name|left
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|left
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|buf
operator|->
name|left
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|buf
operator|->
name|used
operator|==
literal|0
operator|||
operator|!
name|memchr
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|,
name|buf
operator|->
name|used
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|used
operator|==
name|buf
operator|->
name|alloc
condition|)
block|{
name|buf
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|fread
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
argument_list|,
literal|1
argument_list|,
name|buf
operator|->
name|alloc
operator|-
name|buf
operator|->
name|used
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|used
operator|+=
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
name|buf
operator|->
name|used
operator|&&
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|used
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|used
operator|==
name|buf
operator|->
name|alloc
condition|)
block|{
name|buf
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|used
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
return|return
name|buf
operator|->
name|used
return|;
block|}
end_function

begin_comment
comment|/* Initialize LINES, allocating space for ALLOC lines initially.    LIMIT is the maximum possible number of lines to allocate space    for, ever.  */
end_comment

begin_function
specifier|static
name|void
name|initlines
parameter_list|(
name|lines
parameter_list|,
name|alloc
parameter_list|,
name|limit
parameter_list|)
name|struct
name|lines
modifier|*
name|lines
decl_stmt|;
name|int
name|alloc
decl_stmt|;
name|int
name|limit
decl_stmt|;
block|{
name|lines
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|lines
operator|->
name|lines
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
name|lines
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|lines
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|lines
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the first character of the field specified    by KEY in LINE. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|begfield
parameter_list|(
name|line
parameter_list|,
name|key
parameter_list|)
name|struct
name|line
modifier|*
name|line
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|line
operator|->
name|text
decl_stmt|,
modifier|*
name|lim
init|=
name|ptr
operator|+
name|line
operator|->
name|length
decl_stmt|;
specifier|register
name|int
name|sword
init|=
name|key
operator|->
name|sword
decl_stmt|,
name|schar
init|=
name|key
operator|->
name|schar
decl_stmt|;
if|if
condition|(
name|tab
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|sword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|sword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|schar
operator|--
condition|)
operator|++
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Return the limit of (a pointer to the first character after) the field    in LINE specified by KEY. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|limfield
parameter_list|(
name|line
parameter_list|,
name|key
parameter_list|)
name|struct
name|line
modifier|*
name|line
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|line
operator|->
name|text
decl_stmt|,
modifier|*
name|lim
init|=
name|ptr
operator|+
name|line
operator|->
name|length
decl_stmt|;
specifier|register
name|int
name|eword
init|=
name|key
operator|->
name|eword
decl_stmt|,
name|echar
init|=
name|key
operator|->
name|echar
decl_stmt|;
if|if
condition|(
name|tab
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|eword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|(
name|eword
operator|||
name|key
operator|->
name|skipeblanks
operator|)
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|eword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|skipeblanks
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|echar
operator|--
condition|)
operator|++
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Find the lines in BUF, storing pointers and lengths in LINES.    Also replace newlines with NULs. */
end_comment

begin_function
specifier|static
name|void
name|findlines
parameter_list|(
name|buf
parameter_list|,
name|lines
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|lines
modifier|*
name|lines
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|beg
init|=
name|buf
operator|->
name|buf
decl_stmt|,
modifier|*
name|lim
init|=
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
init|=
name|keyhead
operator|.
name|next
decl_stmt|;
name|lines
operator|->
name|used
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|beg
operator|<
name|lim
operator|&&
operator|(
name|ptr
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
literal|'\n'
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|)
operator|&&
name|lines
operator|->
name|used
operator|<
name|lines
operator|->
name|limit
condition|)
block|{
comment|/* There are various places in the code that rely on a NUL 	 being at the end of in-core lines; NULs inside the lines 	 will not cause trouble, though. */
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lines
operator|->
name|used
operator|==
name|lines
operator|->
name|alloc
condition|)
block|{
name|lines
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|lines
operator|->
name|lines
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
operator|->
name|lines
argument_list|,
name|lines
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|text
operator|=
name|beg
expr_stmt|;
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|length
operator|=
name|ptr
operator|-
name|beg
expr_stmt|;
comment|/* Precompute the position of the first key for efficiency. */
if|if
condition|(
name|key
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|eword
operator|>=
literal|0
condition|)
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
operator|=
name|limfield
argument_list|(
operator|&
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sword
operator|>=
literal|0
condition|)
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
operator|=
name|begfield
argument_list|(
operator|&
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|beg
argument_list|)
index|]
condition|)
operator|++
name|beg
expr_stmt|;
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
operator|=
name|beg
expr_stmt|;
block|}
block|}
else|else
block|{
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
operator|=
literal|0
expr_stmt|;
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|lines
operator|->
name|used
expr_stmt|;
name|beg
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
name|buf
operator|->
name|left
operator|=
name|lim
operator|-
name|beg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare strings A and B containing decimal fractions< 1.  Each string    should begin with a decimal point followed immediately by the digits    of the fraction.  Strings not of this form are considered to be zero. */
end_comment

begin_function
specifier|static
name|int
name|fraccompare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpa
operator|==
literal|'.'
operator|&&
name|tmpb
operator|==
literal|'.'
condition|)
block|{
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|digits
index|[
name|tmpa
index|]
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
operator|&&
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
name|tmpa
operator|-
name|tmpb
return|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
block|{
while|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
block|{
while|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|tmpa
operator|==
literal|'.'
condition|)
block|{
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|tmpb
operator|==
literal|'.'
condition|)
block|{
do|do
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Compare strings A and B as numbers without explicitly converting them to    machine numbers.  Comparatively slow for short strings, but asymptotically    hideously fast. */
end_comment

begin_function
specifier|static
name|int
name|numcompare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|tmpa
decl_stmt|,
name|tmpb
decl_stmt|,
name|loga
decl_stmt|,
name|logb
decl_stmt|,
name|tmp
decl_stmt|;
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|tmpa
index|]
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|tmpb
index|]
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpa
operator|==
literal|'-'
condition|)
block|{
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpb
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
operator|&&
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|digits
index|[
name|tmpa
index|]
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpa
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpb
index|]
operator|)
operator|||
operator|(
name|tmpb
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpa
index|]
operator|)
condition|)
return|return
operator|-
name|fraccompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
for|for
control|(
name|loga
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
index|]
condition|;
operator|++
name|loga
control|)
empty_stmt|;
else|else
name|loga
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
for|for
control|(
name|logb
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
index|]
condition|;
operator|++
name|logb
control|)
empty_stmt|;
else|else
name|logb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|logb
operator|-
name|loga
operator|)
operator|!=
literal|0
condition|)
return|return
name|tmp
return|;
if|if
condition|(
operator|!
name|loga
condition|)
return|return
literal|0
return|;
return|return
name|tmpb
operator|-
name|tmpa
return|;
block|}
elseif|else
if|if
condition|(
name|tmpb
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|digits
index|[
name|UCHAR
argument_list|(
name|tmpa
argument_list|)
index|]
operator|&&
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|digits
index|[
name|tmpa
index|]
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpa
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpb
index|]
operator|)
operator|||
operator|(
name|tmpb
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpa
index|]
operator|)
condition|)
return|return
name|fraccompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
for|for
control|(
name|loga
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
index|]
condition|;
operator|++
name|loga
control|)
empty_stmt|;
else|else
name|loga
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
for|for
control|(
name|logb
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
index|]
condition|;
operator|++
name|logb
control|)
empty_stmt|;
else|else
name|logb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|loga
operator|-
name|logb
operator|)
operator|!=
literal|0
condition|)
return|return
name|tmp
return|;
if|if
condition|(
operator|!
name|loga
condition|)
return|return
literal|0
return|;
return|return
name|tmpa
operator|-
name|tmpb
return|;
block|}
block|}
end_block

begin_comment
comment|/* Return an integer<= 12 associated with month name S with length LEN,    0 if the name in S is not recognized. */
end_comment

begin_function
specifier|static
name|int
name|getmonth
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|month
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
literal|12
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
operator|++
name|s
operator|,
operator|--
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|month
index|[
name|i
index|]
operator|=
name|fold_toupper
index|[
name|UCHAR
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
name|month
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|hi
operator|-
name|lo
operator|>
literal|1
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|month
argument_list|,
name|monthtab
index|[
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
index|]
operator|.
name|name
argument_list|)
operator|<
literal|0
condition|)
name|hi
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|lo
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|month
argument_list|,
name|monthtab
index|[
name|lo
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|monthtab
index|[
name|lo
index|]
operator|.
name|val
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare two lines A and B trying every key in sequence until there    are no more keys or a difference is found. */
end_comment

begin_function
specifier|static
name|int
name|keycompare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|line
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|texta
decl_stmt|,
modifier|*
name|textb
decl_stmt|,
modifier|*
name|lima
decl_stmt|,
modifier|*
name|limb
decl_stmt|,
modifier|*
name|translate
decl_stmt|;
specifier|register
name|int
modifier|*
name|ignore
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
name|int
name|diff
init|=
literal|0
decl_stmt|,
name|iter
init|=
literal|0
decl_stmt|,
name|lena
decl_stmt|,
name|lenb
decl_stmt|;
for|for
control|(
name|key
operator|=
name|keyhead
operator|.
name|next
init|;
name|key
condition|;
name|key
operator|=
name|key
operator|->
name|next
operator|,
operator|++
name|iter
control|)
block|{
name|ignore
operator|=
name|key
operator|->
name|ignore
expr_stmt|;
name|translate
operator|=
name|key
operator|->
name|translate
expr_stmt|;
comment|/* Find the beginning and limit of each field. */
if|if
condition|(
name|iter
operator|||
name|a
operator|->
name|keybeg
operator|==
name|NULL
operator|||
name|b
operator|->
name|keybeg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|eword
operator|>=
literal|0
condition|)
name|lima
operator|=
name|limfield
argument_list|(
name|a
argument_list|,
name|key
argument_list|)
operator|,
name|limb
operator|=
name|limfield
argument_list|(
name|b
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|lima
operator|=
name|a
operator|->
name|text
operator|+
name|a
operator|->
name|length
operator|,
name|limb
operator|=
name|b
operator|->
name|text
operator|+
name|b
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sword
operator|>=
literal|0
condition|)
name|texta
operator|=
name|begfield
argument_list|(
name|a
argument_list|,
name|key
argument_list|)
operator|,
name|textb
operator|=
name|begfield
argument_list|(
name|b
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|texta
operator|=
name|a
operator|->
name|text
operator|,
name|textb
operator|=
name|b
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
block|{
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
condition|)
operator|++
name|texta
expr_stmt|;
while|while
condition|(
name|textb
operator|<
name|limb
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
condition|)
operator|++
name|textb
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the first iteration only, the key positions have 	     been precomputed for us. */
name|texta
operator|=
name|a
operator|->
name|keybeg
operator|,
name|lima
operator|=
name|a
operator|->
name|keylim
expr_stmt|;
name|textb
operator|=
name|b
operator|->
name|keybeg
operator|,
name|limb
operator|=
name|b
operator|->
name|keylim
expr_stmt|;
block|}
comment|/* Find the lengths. */
name|lena
operator|=
name|lima
operator|-
name|texta
operator|,
name|lenb
operator|=
name|limb
operator|-
name|textb
expr_stmt|;
if|if
condition|(
name|lena
operator|<
literal|0
condition|)
name|lena
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lenb
operator|<
literal|0
condition|)
name|lenb
operator|=
literal|0
expr_stmt|;
comment|/* Actually compare the fields. */
if|if
condition|(
name|key
operator|->
name|numeric
condition|)
block|{
if|if
condition|(
operator|*
name|lima
operator|||
operator|*
name|limb
condition|)
block|{
name|char
name|savea
init|=
operator|*
name|lima
decl_stmt|,
name|saveb
init|=
operator|*
name|limb
decl_stmt|;
operator|*
name|lima
operator|=
operator|*
name|limb
operator|=
literal|'\0'
expr_stmt|;
name|diff
operator|=
name|numcompare
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|)
expr_stmt|;
operator|*
name|lima
operator|=
name|savea
operator|,
operator|*
name|limb
operator|=
name|saveb
expr_stmt|;
block|}
else|else
name|diff
operator|=
name|numcompare
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|key
operator|->
name|month
condition|)
block|{
name|diff
operator|=
name|getmonth
argument_list|(
name|texta
argument_list|,
name|lena
argument_list|)
operator|-
name|getmonth
argument_list|(
name|textb
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ignore
operator|&&
name|translate
condition|)
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
condition|)
block|{
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|ignore
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
condition|)
operator|++
name|texta
expr_stmt|;
while|while
condition|(
name|textb
operator|<
name|limb
operator|&&
name|ignore
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
condition|)
operator|++
name|textb
expr_stmt|;
if|if
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
operator|&&
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
operator|++
argument_list|)
index|]
operator|!=
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
operator|++
argument_list|)
index|]
condition|)
block|{
name|diff
operator|=
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|texta
argument_list|)
index|]
operator|-
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|textb
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ignore
condition|)
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
condition|)
block|{
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|ignore
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
condition|)
operator|++
name|texta
expr_stmt|;
while|while
condition|(
name|textb
operator|<
name|limb
operator|&&
name|ignore
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
condition|)
operator|++
name|textb
expr_stmt|;
if|if
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
operator|&&
operator|*
name|texta
operator|++
operator|!=
operator|*
name|textb
operator|++
condition|)
block|{
name|diff
operator|=
operator|*
operator|--
name|texta
operator|-
operator|*
operator|--
name|textb
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|translate
condition|)
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
condition|)
block|{
if|if
condition|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
operator|++
argument_list|)
index|]
operator|!=
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
operator|++
argument_list|)
index|]
condition|)
block|{
name|diff
operator|=
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|texta
argument_list|)
index|]
operator|-
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|textb
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
block|}
else|else
name|diff
operator|=
name|memcmp
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|,
name|min
argument_list|(
name|lena
argument_list|,
name|lenb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
if|if
condition|(
operator|(
name|diff
operator|=
name|lena
operator|-
name|lenb
operator|)
operator|!=
literal|0
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Compare two lines A and B, returning negative, zero, or positive    depending on whether A compares less than, equal to, or greater than B. */
end_comment

begin_function
specifier|static
name|int
name|compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|struct
name|line
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|diff
decl_stmt|,
name|tmpa
decl_stmt|,
name|tmpb
decl_stmt|,
name|mini
decl_stmt|;
comment|/* First try to compare on the specified keys (if any).      The only two cases with no key at all are unadorned sort,      and unadorned sort -r. */
if|if
condition|(
name|keyhead
operator|.
name|next
condition|)
block|{
name|diff
operator|=
name|keycompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
if|if
condition|(
name|unique
operator|||
name|stable
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the keys all compare equal (or no keys were specified)      fall through to the default byte-by-byte comparison. */
name|tmpa
operator|=
name|a
operator|->
name|length
operator|,
name|tmpb
operator|=
name|b
operator|->
name|length
expr_stmt|;
name|mini
operator|=
name|min
argument_list|(
name|tmpa
argument_list|,
name|tmpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mini
operator|==
literal|0
condition|)
name|diff
operator|=
name|tmpa
operator|-
name|tmpb
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|ap
init|=
name|a
operator|->
name|text
decl_stmt|,
modifier|*
name|bp
init|=
name|b
operator|->
name|text
decl_stmt|;
name|diff
operator|=
name|UCHAR
argument_list|(
operator|*
name|ap
argument_list|)
operator|-
name|UCHAR
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
name|diff
operator|=
name|memcmp
argument_list|(
name|ap
argument_list|,
name|bp
argument_list|,
name|mini
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
name|diff
operator|=
name|tmpa
operator|-
name|tmpb
expr_stmt|;
block|}
block|}
return|return
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
block|}
end_block

begin_comment
comment|/* Check that the lines read from the given FP come in order.  Return    1 if they do and 0 if there is a disorder. */
end_comment

begin_function
specifier|static
name|int
name|checkfp
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|buffer
name|buf
decl_stmt|;
comment|/* Input buffer. */
name|struct
name|lines
name|lines
decl_stmt|;
comment|/* Lines scanned from the buffer. */
name|struct
name|line
name|temp
decl_stmt|;
comment|/* Copy of previous line. */
name|int
name|cc
decl_stmt|;
comment|/* Character count. */
name|int
name|cmp
decl_stmt|;
comment|/* Result of calling compare. */
name|int
name|alloc
decl_stmt|,
name|i
decl_stmt|,
name|success
init|=
literal|1
decl_stmt|;
name|initbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|mergealloc
argument_list|)
expr_stmt|;
name|initlines
argument_list|(
operator|&
name|lines
argument_list|,
name|mergealloc
operator|/
name|linelength
operator|+
literal|1
argument_list|,
name|LINEALLOC
operator|/
operator|(
operator|(
name|NMERGE
operator|+
name|NMERGE
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|linelength
expr_stmt|;
name|temp
operator|.
name|text
operator|=
name|xmalloc
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|findlines
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
condition|)
do|do
block|{
comment|/* Compare each line in the buffer with its successor. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|.
name|used
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|cmp
operator|=
name|compare
argument_list|(
operator|&
name|lines
operator|.
name|lines
index|[
name|i
index|]
argument_list|,
operator|&
name|lines
operator|.
name|lines
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unique
operator|&&
name|cmp
operator|>=
literal|0
operator|)
operator|||
operator|(
name|cmp
operator|>
literal|0
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
comment|/* Save the last line of the buffer and refill the buffer. */
if|if
condition|(
name|lines
operator|.
name|lines
index|[
name|lines
operator|.
name|used
operator|-
literal|1
index|]
operator|.
name|length
operator|>
name|alloc
condition|)
block|{
while|while
condition|(
name|lines
operator|.
name|lines
index|[
name|lines
operator|.
name|used
operator|-
literal|1
index|]
operator|.
name|length
operator|+
literal|1
operator|>
name|alloc
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
name|temp
operator|.
name|text
operator|=
name|xrealloc
argument_list|(
name|temp
operator|.
name|text
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|lines
operator|.
name|lines
index|[
name|lines
operator|.
name|used
operator|-
literal|1
index|]
operator|.
name|text
argument_list|,
name|temp
operator|.
name|text
argument_list|,
name|lines
operator|.
name|lines
index|[
name|lines
operator|.
name|used
operator|-
literal|1
index|]
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|.
name|length
operator|=
name|lines
operator|.
name|lines
index|[
name|lines
operator|.
name|used
operator|-
literal|1
index|]
operator|.
name|length
expr_stmt|;
name|cc
operator|=
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
condition|)
block|{
name|findlines
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
comment|/* Make sure the line saved from the old buffer contents is 	       less than or equal to the first line of the new buffer. */
name|cmp
operator|=
name|compare
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|lines
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unique
operator|&&
name|cmp
operator|>=
literal|0
operator|)
operator|||
operator|(
name|cmp
operator|>
literal|0
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|cc
condition|)
do|;
name|finish
label|:
name|xfclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
operator|.
name|lines
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Merge lines from FPS onto OFP.  NFPS cannot be greater than NMERGE.    Close FPS before returning. */
end_comment

begin_function
specifier|static
name|void
name|mergefps
parameter_list|(
name|fps
parameter_list|,
name|nfps
parameter_list|,
name|ofp
parameter_list|)
name|FILE
modifier|*
name|fps
index|[]
decl_stmt|,
decl|*
name|ofp
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|nfps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
name|buffer
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Input buffers for each file. */
name|struct
name|lines
name|lines
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Line tables for each buffer. */
name|struct
name|line
name|saved
decl_stmt|;
comment|/* Saved line for unique check. */
name|int
name|savedflag
init|=
literal|0
decl_stmt|;
comment|/* True if there is a saved line. */
name|int
name|savealloc
decl_stmt|;
comment|/* Size allocated for the saved line. */
name|int
name|cur
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Current line in each line table. */
name|int
name|ord
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Table representing a permutation of fps, 				   such that lines[ord[0]].lines[cur[ord[0]]] 				   is the smallest line and will be next 				   output. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|;
comment|/* Allocate space for a saved line if necessary. */
if|if
condition|(
name|unique
condition|)
block|{
name|savealloc
operator|=
name|linelength
expr_stmt|;
name|saved
operator|.
name|text
operator|=
name|xmalloc
argument_list|(
name|savealloc
argument_list|)
expr_stmt|;
block|}
comment|/* Read initial lines from each input file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
block|{
name|initbuf
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|mergealloc
argument_list|)
expr_stmt|;
comment|/* If a file is empty, eliminate it from future consideration. */
while|while
condition|(
name|i
operator|<
name|nfps
operator|&&
operator|!
name|fillbuf
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|fps
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|xfclose
argument_list|(
name|fps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|--
name|nfps
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nfps
condition|;
operator|++
name|j
control|)
name|fps
index|[
name|j
index|]
operator|=
name|fps
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|nfps
condition|)
name|free
argument_list|(
name|buffer
index|[
name|i
index|]
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|initlines
argument_list|(
operator|&
name|lines
index|[
name|i
index|]
argument_list|,
name|mergealloc
operator|/
name|linelength
operator|+
literal|1
argument_list|,
name|LINEALLOC
operator|/
operator|(
operator|(
name|NMERGE
operator|+
name|NMERGE
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|findlines
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
operator|&
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cur
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set up the ord table according to comparisons among input lines.      Since this only reorders two items if one is strictly greater than      the other, it is stable. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
name|ord
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|compare
argument_list|(
operator|&
name|lines
index|[
name|ord
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
name|i
operator|-
literal|1
index|]
index|]
index|]
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
name|i
index|]
index|]
index|]
argument_list|)
operator|>
literal|0
condition|)
name|t
operator|=
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|,
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|ord
index|[
name|i
index|]
operator|,
name|ord
index|[
name|i
index|]
operator|=
name|t
operator|,
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Repeatedly output the smallest line until no input remains. */
while|while
condition|(
name|nfps
condition|)
block|{
comment|/* If uniqified output is turned out, output only the first of 	 an identical series of lines. */
if|if
condition|(
name|unique
condition|)
block|{
if|if
condition|(
name|savedflag
operator|&&
name|compare
argument_list|(
operator|&
name|saved
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
argument_list|)
condition|)
block|{
name|xfwrite
argument_list|(
name|saved
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|saved
operator|.
name|length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|savedflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|savedflag
condition|)
block|{
if|if
condition|(
name|savealloc
operator|<
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
operator|+
literal|1
condition|)
block|{
while|while
condition|(
name|savealloc
operator|<
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
operator|+
literal|1
condition|)
name|savealloc
operator|*=
literal|2
expr_stmt|;
name|saved
operator|.
name|text
operator|=
name|xrealloc
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|savealloc
argument_list|)
expr_stmt|;
block|}
name|saved
operator|.
name|length
operator|=
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
argument_list|,
name|saved
operator|.
name|text
argument_list|,
name|saved
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keybeg
operator|!=
name|NULL
condition|)
block|{
name|saved
operator|.
name|keybeg
operator|=
name|saved
operator|.
name|text
operator|+
operator|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keybeg
operator|-
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keylim
operator|!=
name|NULL
condition|)
block|{
name|saved
operator|.
name|keylim
operator|=
name|saved
operator|.
name|text
operator|+
operator|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keylim
operator|-
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
operator|)
expr_stmt|;
block|}
name|savedflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|xfwrite
argument_list|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
comment|/* Check if we need to read more lines into core. */
if|if
condition|(
operator|++
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|==
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|used
condition|)
if|if
condition|(
name|fillbuf
argument_list|(
operator|&
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
name|fps
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
condition|)
block|{
name|findlines
argument_list|(
operator|&
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We reached EOF on fps[ord[0]]. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ord
index|[
name|i
index|]
operator|>
name|ord
index|[
literal|0
index|]
condition|)
operator|--
name|ord
index|[
name|i
index|]
expr_stmt|;
operator|--
name|nfps
expr_stmt|;
name|xfclose
argument_list|(
name|fps
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ord
index|[
literal|0
index|]
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
block|{
name|fps
index|[
name|i
index|]
operator|=
name|fps
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|buffer
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|lines
index|[
name|i
index|]
operator|=
name|lines
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|cur
index|[
name|i
index|]
operator|=
name|cur
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* The new line just read in may be larger than other lines 	 already in core; push it back in the queue until we encounter 	 a line larger than it. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|=
name|compare
argument_list|(
operator|&
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
name|i
index|]
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|ord
index|[
literal|0
index|]
operator|-
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
break|break;
block|}
name|t
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|ord
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|unique
operator|&&
name|savedflag
condition|)
block|{
name|xfwrite
argument_list|(
name|saved
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|saved
operator|.
name|length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Sort the array LINES with NLINES members, using TEMP for temporary space. */
end_comment

begin_function
specifier|static
name|void
name|sortlines
parameter_list|(
name|lines
parameter_list|,
name|nlines
parameter_list|,
name|temp
parameter_list|)
name|struct
name|line
modifier|*
name|lines
decl_stmt|,
decl|*
name|temp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|line
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|nlo
decl_stmt|,
name|nhi
decl_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|compare
argument_list|(
operator|&
name|lines
index|[
literal|0
index|]
argument_list|,
operator|&
name|lines
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
condition|)
operator|*
name|temp
operator|=
name|lines
index|[
literal|0
index|]
operator|,
name|lines
index|[
literal|0
index|]
operator|=
name|lines
index|[
literal|1
index|]
operator|,
name|lines
index|[
literal|1
index|]
operator|=
operator|*
name|temp
expr_stmt|;
return|return;
block|}
name|nlo
operator|=
name|nlines
operator|/
literal|2
expr_stmt|;
name|lo
operator|=
name|lines
expr_stmt|;
name|nhi
operator|=
name|nlines
operator|-
name|nlo
expr_stmt|;
name|hi
operator|=
name|lines
operator|+
name|nlo
expr_stmt|;
if|if
condition|(
name|nlo
operator|>
literal|1
condition|)
name|sortlines
argument_list|(
name|lo
argument_list|,
name|nlo
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhi
operator|>
literal|1
condition|)
name|sortlines
argument_list|(
name|hi
argument_list|,
name|nhi
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|t
operator|=
name|temp
expr_stmt|;
while|while
condition|(
name|nlo
operator|&&
name|nhi
condition|)
if|if
condition|(
name|compare
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
operator|<=
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|lo
operator|++
operator|,
operator|--
name|nlo
expr_stmt|;
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|hi
operator|++
operator|,
operator|--
name|nhi
expr_stmt|;
while|while
condition|(
name|nlo
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|lo
operator|++
expr_stmt|;
for|for
control|(
name|lo
operator|=
name|lines
operator|,
name|nlo
operator|=
name|nlines
operator|-
name|nhi
operator|,
name|t
operator|=
name|temp
init|;
name|nlo
condition|;
operator|--
name|nlo
control|)
operator|*
name|lo
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Check that each of the NFILES FILES is ordered.    Return a count of disordered files. */
end_comment

begin_function
specifier|static
name|int
name|check
parameter_list|(
name|files
parameter_list|,
name|nfiles
parameter_list|)
name|char
modifier|*
name|files
index|[]
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|disorders
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
block|{
name|fp
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkfp
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: disorder on %s\n"
argument_list|,
name|program_name
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|disorders
expr_stmt|;
block|}
block|}
return|return
name|disorders
return|;
block|}
end_function

begin_comment
comment|/* Merge NFILES FILES onto OFP. */
end_comment

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|files
parameter_list|,
name|nfiles
parameter_list|,
name|ofp
parameter_list|)
name|char
modifier|*
name|files
index|[]
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|FILE
modifier|*
name|fps
index|[
name|NMERGE
index|]
decl_stmt|,
modifier|*
name|tfp
decl_stmt|;
while|while
condition|(
name|nfiles
operator|>
name|NMERGE
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
operator|/
name|NMERGE
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMERGE
condition|;
operator|++
name|j
control|)
name|fps
index|[
name|j
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xfopen
argument_list|(
name|temp
operator|=
name|tempname
argument_list|()
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
name|fps
argument_list|,
name|NMERGE
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMERGE
condition|;
operator|++
name|j
control|)
name|zaptemp
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|files
index|[
name|t
operator|++
index|]
operator|=
name|temp
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nfiles
operator|%
name|NMERGE
condition|;
operator|++
name|j
control|)
name|fps
index|[
name|j
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xfopen
argument_list|(
name|temp
operator|=
name|tempname
argument_list|()
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
name|fps
argument_list|,
name|nfiles
operator|%
name|NMERGE
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nfiles
operator|%
name|NMERGE
condition|;
operator|++
name|j
control|)
name|zaptemp
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|files
index|[
name|t
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|nfiles
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
name|fps
index|[
name|i
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
name|fps
argument_list|,
name|i
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
name|zaptemp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort NFILES FILES onto OFP. */
end_comment

begin_function
specifier|static
name|void
name|sort
parameter_list|(
name|files
parameter_list|,
name|nfiles
parameter_list|,
name|ofp
parameter_list|)
name|char
modifier|*
modifier|*
name|files
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
block|{
name|struct
name|buffer
name|buf
decl_stmt|;
name|struct
name|lines
name|lines
decl_stmt|;
name|struct
name|line
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ntmp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|tfp
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
name|int
name|ntemp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempfiles
decl_stmt|;
name|initbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|sortalloc
argument_list|)
expr_stmt|;
name|initlines
argument_list|(
operator|&
name|lines
argument_list|,
name|sortalloc
operator|/
name|linelength
operator|+
literal|1
argument_list|,
name|LINEALLOC
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|lines
operator|.
name|alloc
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntmp
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfiles
operator|--
condition|)
block|{
name|fp
operator|=
name|xfopen
argument_list|(
operator|*
name|files
operator|++
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|findlines
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|.
name|used
operator|>
name|ntmp
condition|)
block|{
while|while
condition|(
name|lines
operator|.
name|used
operator|>
name|ntmp
condition|)
name|ntmp
operator|*=
literal|2
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
name|ntmp
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sortlines
argument_list|(
name|lines
operator|.
name|lines
argument_list|,
name|lines
operator|.
name|used
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|nfiles
operator|&&
operator|!
name|ntemp
operator|&&
operator|!
name|buf
operator|.
name|left
condition|)
name|tfp
operator|=
name|ofp
expr_stmt|;
else|else
block|{
operator|++
name|ntemp
expr_stmt|;
name|tfp
operator|=
name|xfopen
argument_list|(
name|tempname
argument_list|()
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|.
name|used
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|unique
operator|||
name|i
operator|==
literal|0
operator|||
name|compare
argument_list|(
operator|&
name|lines
operator|.
name|lines
index|[
name|i
index|]
argument_list|,
operator|&
name|lines
operator|.
name|lines
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|xfwrite
argument_list|(
name|lines
operator|.
name|lines
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|lines
operator|.
name|lines
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfp
operator|!=
name|ofp
condition|)
name|xfclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
name|xfclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
operator|.
name|lines
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntemp
condition|)
block|{
name|tempfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntemp
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|ntemp
expr_stmt|;
for|for
control|(
name|node
operator|=
name|temphead
operator|.
name|next
init|;
name|i
operator|>
literal|0
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|tempfiles
index|[
operator|--
name|i
index|]
operator|=
name|node
operator|->
name|name
expr_stmt|;
name|merge
argument_list|(
name|tempfiles
argument_list|,
name|ntemp
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tempfiles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert key KEY at the end of the list (`keyhead'). */
end_comment

begin_function
specifier|static
name|void
name|insertkey
parameter_list|(
name|key
parameter_list|)
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
block|{
name|struct
name|keyfield
modifier|*
name|k
init|=
operator|&
name|keyhead
decl_stmt|;
while|while
condition|(
name|k
operator|->
name|next
condition|)
name|k
operator|=
name|k
operator|->
name|next
expr_stmt|;
name|k
operator|->
name|next
operator|=
name|key
expr_stmt|;
name|key
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badfieldspec
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid field specification `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle interrupts and hangups. */
end_comment

begin_function
specifier|static
name|void
name|sighandler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|struct
name|sigaction
name|sigact
decl_stmt|;
name|sigact
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|sigact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_POSIX_VERSION */
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
name|cleanup
argument_list|()
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the ordering options for KEY specified in S.    Return the address of the first character in S that    is not a valid ordering option.    BLANKTYPE is the kind of blanks that 'b' should skip. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|set_ordering
parameter_list|(
name|s
parameter_list|,
name|key
parameter_list|,
name|blanktype
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
name|enum
name|blanktype
name|blanktype
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|blanktype
operator|==
name|bl_start
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipsblanks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|blanktype
operator|==
name|bl_end
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipeblanks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|key
operator|->
name|ignore
operator|=
name|nondictionary
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|key
operator|->
name|translate
operator|=
name|fold_toupper
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 'g':
comment|/* Reserved for comparing floating-point numbers. */
block|break;
endif|#
directive|endif
case|case
literal|'i'
case|:
name|key
operator|->
name|ignore
operator|=
name|nonprinting
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|key
operator|->
name|month
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|key
operator|->
name|numeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|key
operator|->
name|reverse
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|s
return|;
block|}
operator|++
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|keyfield
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
name|gkey
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|checkonly
init|=
literal|0
decl_stmt|,
name|mergeonly
init|=
literal|0
decl_stmt|,
name|nfiles
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|minus
init|=
literal|"-"
decl_stmt|,
modifier|*
name|outfile
init|=
name|minus
decl_stmt|,
modifier|*
modifier|*
name|files
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|struct
name|sigaction
name|oldact
decl_stmt|,
name|newact
decl_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|parse_long_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|have_read_stdin
operator|=
literal|0
expr_stmt|;
name|inittables
argument_list|()
expr_stmt|;
name|temp_file_prefix
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_file_prefix
operator|==
name|NULL
condition|)
name|temp_file_prefix
operator|=
literal|"/tmp"
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|newact
operator|.
name|sa_handler
operator|=
name|sighandler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|newact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_POSIX_VERSION */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !_POSIX_VERSION */
name|gkey
operator|.
name|sword
operator|=
name|gkey
operator|.
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|gkey
operator|.
name|ignore
operator|=
name|NULL
expr_stmt|;
name|gkey
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
name|gkey
operator|.
name|numeric
operator|=
name|gkey
operator|.
name|month
operator|=
name|gkey
operator|.
name|reverse
operator|=
literal|0
expr_stmt|;
name|gkey
operator|.
name|skipsblanks
operator|=
name|gkey
operator|.
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|key
condition|)
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
expr|struct
name|keyfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keyfield
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|key
operator|->
name|ignore
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|key
operator|->
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|key
operator|->
name|month
operator|=
name|key
operator|->
name|reverse
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
literal|10
operator|*
name|t
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
literal|10
operator|*
name|t2
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t2
operator|||
name|t
condition|)
block|{
name|key
operator|->
name|sword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|schar
operator|=
name|t2
expr_stmt|;
block|}
else|else
name|key
operator|->
name|sword
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
name|s
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|key
condition|)
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
name|t
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
name|t2
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|key
operator|->
name|eword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|echar
operator|=
name|t2
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
operator|&
name|gkey
argument_list|,
name|bl_both
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'c'
case|:
name|checkonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
operator|++
name|s
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"option `-k' requires an argument"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|key
condition|)
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
expr|struct
name|keyfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keyfield
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|key
operator|->
name|ignore
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|key
operator|->
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|key
operator|->
name|month
operator|=
name|key
operator|->
name|reverse
operator|=
literal|0
expr_stmt|;
comment|/* Get POS1. */
if|if
condition|(
operator|!
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
literal|10
operator|*
name|t
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|--
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
literal|10
operator|*
name|t2
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|t2
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|t2
operator|||
name|t
condition|)
block|{
name|key
operator|->
name|sword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|schar
operator|=
name|t2
expr_stmt|;
block|}
else|else
name|key
operator|->
name|sword
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|++
condition|)
block|{
comment|/* Get POS2. */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
name|t
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
name|t2
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|t
operator|--
expr_stmt|;
block|}
name|key
operator|->
name|eword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|echar
operator|=
name|t2
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
goto|goto
name|outer
goto|;
case|case
literal|'m'
case|:
name|mergeonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|outfile
operator|=
name|s
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"option `-o' requires an argument"
argument_list|)
expr_stmt|;
else|else
name|outfile
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
goto|goto
name|outer
goto|;
case|case
literal|'s'
case|:
name|stable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|tab
operator|=
operator|*
operator|++
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|tab
operator|=
operator|*
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
goto|goto
name|outer
goto|;
block|}
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"option `-t' requires an argument"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|temp_file_prefix
operator|=
operator|++
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|temp_file_prefix
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
goto|goto
name|outer
goto|;
block|}
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"option `-T' requires an argument"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unique
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Accept and ignore e.g. -y0 for compatibility with 		       Solaris 2.  */
goto|goto
name|outer
goto|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option `-%c'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
condition|)
operator|++
name|s
expr_stmt|;
block|}
block|}
else|else
comment|/* Not an option. */
block|{
name|files
index|[
name|nfiles
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|outer
label|:
empty_stmt|;
block|}
if|if
condition|(
name|key
condition|)
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Inheritance of global options to individual keys. */
for|for
control|(
name|key
operator|=
name|keyhead
operator|.
name|next
init|;
name|key
condition|;
name|key
operator|=
name|key
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|key
operator|->
name|ignore
operator|&&
operator|!
name|key
operator|->
name|translate
operator|&&
operator|!
name|key
operator|->
name|skipsblanks
operator|&&
operator|!
name|key
operator|->
name|reverse
operator|&&
operator|!
name|key
operator|->
name|skipeblanks
operator|&&
operator|!
name|key
operator|->
name|month
operator|&&
operator|!
name|key
operator|->
name|numeric
condition|)
block|{
name|key
operator|->
name|ignore
operator|=
name|gkey
operator|.
name|ignore
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|gkey
operator|.
name|translate
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|gkey
operator|.
name|skipsblanks
expr_stmt|;
name|key
operator|->
name|skipeblanks
operator|=
name|gkey
operator|.
name|skipeblanks
expr_stmt|;
name|key
operator|->
name|month
operator|=
name|gkey
operator|.
name|month
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|gkey
operator|.
name|numeric
expr_stmt|;
name|key
operator|->
name|reverse
operator|=
name|gkey
operator|.
name|reverse
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keyhead
operator|.
name|next
operator|&&
operator|(
name|gkey
operator|.
name|ignore
operator|||
name|gkey
operator|.
name|translate
operator|||
name|gkey
operator|.
name|skipsblanks
operator|||
name|gkey
operator|.
name|skipeblanks
operator|||
name|gkey
operator|.
name|month
operator|||
name|gkey
operator|.
name|numeric
operator|)
condition|)
name|insertkey
argument_list|(
operator|&
name|gkey
argument_list|)
expr_stmt|;
name|reverse
operator|=
name|gkey
operator|.
name|reverse
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
block|{
name|nfiles
operator|=
literal|1
expr_stmt|;
name|files
operator|=
operator|&
name|minus
expr_stmt|;
block|}
if|if
condition|(
name|checkonly
condition|)
name|exit
argument_list|(
name|check
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|outfile
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nfiles
condition|)
name|ofp
operator|=
name|xfopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|xfopen
argument_list|(
name|outfile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|tmp
operator|=
name|tempname
argument_list|()
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|tmp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|xfwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|cc
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|xfclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ofp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|mergeonly
condition|)
name|merge
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
else|else
name|sort
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
comment|/* If we wait for the implicit flush on exit, and the parent process      has closed stdout (e.g., exec>&- in a shell), then the output file      winds up empty.  I don't understand why.  This is under SunOS,      Solaris, Ultrix, and Irix.  This premature fflush makes the output      reappear. --karl@cs.umb.edu  */
if|if
condition|(
name|fflush
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fflush"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Try `%s --help' for more information.\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\ Usage: %s [OPTION]... [FILE]...\n\ "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n\   +POS1 [-POS2]    start a key at POS1, end it before POS2\n\   -M               compare (unknown)< `JAN'< ...< `DEC', imply -b\n\   -T DIRECT        use DIRECTfor temporary files, not $TEMPDIR nor /tmp\n\   -b               ignore leading blanks in sort fields or keys\n\   -c               check if given files already sorted, do not sort\n\   -d               consider only [a-zA-Z0-9 ] characters in keys\n\   -f               fold lower case to upper case characters in keys\n\   -i               consider only [\\040-\\0176] characters in keys\n\   -k POS1[,POS2]   same as +POS1 [-POS2], but all positions counted from 1\n\   -m               merge already sorted files, do not sort\n\   -n               compare according to string numerical value, imply -b\n\   -o FILE          write result on FILE instead of standard output\n\   -r               reverse the result of comparisons\n\   -s               stabilize sort by disabling last resort comparison\n\   -t SEP           use SEParator instead of non- to whitespace transition\n\   -u               with -c, check for strict ordering\n\   -u               with -m, only output the first of an equal sequence\n\       --help       display this help and exit\n\       --version    output version information and exit\n\ \n\ POS is F[.C][OPTS], where F is the field number and C the character\n\ position in the field, both counted from zero.  OPTS is made up of one\n\ or more of Mbdfinr, this effectively disable global -Mbdfinr settings\n\ for that key.  If no key given, use the entire line as key.  With no\n\ FILE, or when FILE is -, read standard input.\n\ "
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

