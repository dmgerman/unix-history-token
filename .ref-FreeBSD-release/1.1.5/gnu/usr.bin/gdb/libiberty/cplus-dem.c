begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for GNU C++     Copyright 1989, 1991 Free Software Foundation, Inc.    Written by James Clark (jjc@jclark.uucp)    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling     This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file exports two functions; cplus_mangle_opname and cplus_demangle.     This file imports xmalloc and xrealloc, which are like malloc and    realloc except that they generate a fatal error if there is no    available memory. */
end_comment

begin_include
include|#
directive|include
file|<demangle.h>
end_include

begin_undef
undef|#
directive|undef
name|CURRENT_DEMANGLING_STYLE
end_undef

begin_define
define|#
directive|define
name|CURRENT_DEMANGLING_STYLE
value|work->options
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xrealloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strstr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In order to allow a single demangler executable to demangle strings    using various common values of CPLUS_MARKER, as well as any specific    one set at compile time, we maintain a string containing all the    commonly used ones, and check to see if the marker we are looking for    is in that string.  CPLUS_MARKER is usually '$' on systems where the    assembler can deal with that.  Where the assembler can't, it's usually    '.' (but on many systems '.' is used for other things).  We put the    current defined CPLUS_MARKER first (which defaults to '$'), followed    by the next most common value, followed by an explicit '$' in case    the value of CPLUS_MARKER is not '$'.     We could avoid this if we could just get g++ to tell us what the actual    cplus marker character is as part of the debug information, perhaps by    ensuring that it is the character that terminates the gcc<n>_compiled    marker symbol (FIXME). */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CPLUS_MARKER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CPLUS_MARKER
value|'$'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|enum
name|demangling_styles
name|current_demangling_style
init|=
name|gnu_demangling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cplus_markers
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'.'
block|,
literal|'$'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_cplus_marker_for_demangling
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|cplus_markers
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stuff that is shared between sub-routines.  * Using a shared structure allows cplus_demangle to be reentrant. */
end_comment

begin_struct
struct|struct
name|work_stuff
block|{
name|int
name|options
decl_stmt|;
name|char
modifier|*
modifier|*
name|typevec
decl_stmt|;
name|int
name|ntypes
decl_stmt|;
name|int
name|typevec_size
decl_stmt|;
name|int
name|constructor
decl_stmt|;
name|int
name|destructor
decl_stmt|;
name|int
name|static_type
decl_stmt|;
comment|/* A static member function */
name|int
name|const_type
decl_stmt|;
comment|/* A const member function */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PRINT_ANSI_QUALIFIERS
value|(work -> options& DMGL_ANSI)
end_define

begin_define
define|#
directive|define
name|PRINT_ARG_TYPES
value|(work -> options& DMGL_PARAMS)
end_define

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|optable
block|{
name|CONST
name|char
operator|*
name|in
block|;
name|CONST
name|char
operator|*
name|out
block|;
name|int
name|flags
block|; }
name|optable
index|[]
operator|=
block|{
block|{
literal|"nw"
block|,
literal|" new"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* new (1.92,	 ansi) */
block|{
literal|"dl"
block|,
literal|" delete"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* new (1.92,	 ansi) */
block|{
literal|"new"
block|,
literal|" new"
block|,
literal|0
block|}
block|,
comment|/* old (1.91,	 and 1.x) */
block|{
literal|"delete"
block|,
literal|" delete"
block|,
literal|0
block|}
block|,
comment|/* old (1.91,	 and 1.x) */
block|{
literal|"as"
block|,
literal|"="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ne"
block|,
literal|"!="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old, ansi */
block|{
literal|"eq"
block|,
literal|"=="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"ge"
block|,
literal|">="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"gt"
block|,
literal|">"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"le"
block|,
literal|"<="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"lt"
block|,
literal|"<"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"plus"
block|,
literal|"+"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pl"
block|,
literal|"+"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"apl"
block|,
literal|"+="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"minus"
block|,
literal|"-"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mi"
block|,
literal|"-"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ami"
block|,
literal|"-="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"mult"
block|,
literal|"*"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ml"
block|,
literal|"*"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"amu"
block|,
literal|"*="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi (ARM/Lucid) */
block|{
literal|"aml"
block|,
literal|"*="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi (GNU/g++) */
block|{
literal|"convert"
block|,
literal|"+"
block|,
literal|0
block|}
block|,
comment|/* old (unary +) */
block|{
literal|"negate"
block|,
literal|"-"
block|,
literal|0
block|}
block|,
comment|/* old (unary -) */
block|{
literal|"trunc_mod"
block|,
literal|"%"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"md"
block|,
literal|"%"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"amd"
block|,
literal|"%="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"trunc_div"
block|,
literal|"/"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"dv"
block|,
literal|"/"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"adv"
block|,
literal|"/="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_andif"
block|,
literal|"&&"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"aa"
block|,
literal|"&&"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_orif"
block|,
literal|"||"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"oo"
block|,
literal|"||"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_not"
block|,
literal|"!"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"nt"
block|,
literal|"!"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"postincrement"
block|,
literal|"++"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pp"
block|,
literal|"++"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"postdecrement"
block|,
literal|"--"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mm"
block|,
literal|"--"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_ior"
block|,
literal|"|"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"or"
block|,
literal|"|"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aor"
block|,
literal|"|="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_xor"
block|,
literal|"^"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"er"
block|,
literal|"^"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aer"
block|,
literal|"^="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_and"
block|,
literal|"&"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ad"
block|,
literal|"&"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aad"
block|,
literal|"&="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_not"
block|,
literal|"~"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"co"
block|,
literal|"~"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"call"
block|,
literal|"()"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cl"
block|,
literal|"()"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"alshift"
block|,
literal|"<<"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ls"
block|,
literal|"<<"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"als"
block|,
literal|"<<="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"arshift"
block|,
literal|">>"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"rs"
block|,
literal|">>"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ars"
block|,
literal|">>="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"component"
block|,
literal|"->"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pt"
block|,
literal|"->"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi; Lucid C++ form */
block|{
literal|"rf"
block|,
literal|"->"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi; ARM/GNU form */
block|{
literal|"indirect"
block|,
literal|"*"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"method_call"
block|,
literal|"->()"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"addr"
block|,
literal|"&"
block|,
literal|0
block|}
block|,
comment|/* old (unary&) */
block|{
literal|"array"
block|,
literal|"[]"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"vc"
block|,
literal|"[]"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"compound"
block|,
literal|", "
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cm"
block|,
literal|", "
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"cond"
block|,
literal|"?:"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cn"
block|,
literal|"?:"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* psuedo-ansi */
block|{
literal|"max"
block|,
literal|">?"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mx"
block|,
literal|">?"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* psuedo-ansi */
block|{
literal|"min"
block|,
literal|"<?"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mn"
block|,
literal|"<?"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* psuedo-ansi */
block|{
literal|"nop"
block|,
literal|""
block|,
literal|0
block|}
block|,
comment|/* old (for operator=) */
block|{
literal|"rm"
block|,
literal|"->*"
block|,
name|DMGL_ANSI
block|}
comment|/* ansi */
block|}
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
struct|struct
name|string
comment|/* Beware: these aren't required to be */
block|{
comment|/*  '\0' terminated. */
name|char
modifier|*
name|b
decl_stmt|;
comment|/* pointer to start of string */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer after last character */
name|char
modifier|*
name|e
decl_stmt|;
comment|/* pointer after end of allocated space */
block|}
name|string
typedef|;
end_typedef

begin_define
define|#
directive|define
name|STRING_EMPTY
parameter_list|(
name|str
parameter_list|)
value|((str) -> b == (str) -> p)
end_define

begin_define
define|#
directive|define
name|PREPEND_BLANK
parameter_list|(
name|str
parameter_list|)
value|{if (!STRING_EMPTY(str)) \ 				   string_prepend(str, " ");}
end_define

begin_define
define|#
directive|define
name|APPEND_BLANK
parameter_list|(
name|str
parameter_list|)
value|{if (!STRING_EMPTY(str)) \ 				   string_append(str, " ");}
end_define

begin_define
define|#
directive|define
name|ARM_VTABLE_STRING
value|"__vtbl__"
end_define

begin_comment
comment|/* Lucid/ARM virtual table prefix */
end_comment

begin_define
define|#
directive|define
name|ARM_VTABLE_STRLEN
value|8
end_define

begin_comment
comment|/* strlen (ARM_VTABLE_STRING) */
end_comment

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mop_up
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int demangle_method_args PARAMS ((struct work_stuff *work, CONST char **, string *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|demangle_template
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
name|work
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_qualified
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_class
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_fund_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_signature
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gnu_special
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_special
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_need
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_delete
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_init
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_clear
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int string_empty PARAMS ((string *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|string_append
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|CONST
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_appends
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_appendn
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|CONST
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prepend
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|CONST
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prependn
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|CONST
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_count
name|PARAMS
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consume_count
name|PARAMS
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_arg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_function_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|CONST
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|CONST
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prepends
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Translate count to integer, consuming tokens in the process.     Conversion terminates on the first non-digit character.     Trying to consume something that isn't a count results in     no consumption of input and a return of 0. */
end_comment

begin_function
specifier|static
name|int
name|consume_count
parameter_list|(
name|type
parameter_list|)
name|CONST
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|10
expr_stmt|;
name|count
operator|+=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Takes operator name as e.g. "++" and returns mangled    operator name (e.g. "postincrement_expr"), or NULL if not found.     If OPTIONS& DMGL_ANSI == 1, return the ANSI name;    if OPTIONS& DMGL_ANSI == 0, return the old GNU name.  */
end_comment

begin_function
name|char
modifier|*
name|cplus_mangle_opname
parameter_list|(
name|opname
parameter_list|,
name|options
parameter_list|)
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
operator|==
name|len
operator|&&
operator|(
name|options
operator|&
name|DMGL_ANSI
operator|)
operator|==
operator|(
name|optable
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|DMGL_ANSI
operator|)
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|,
name|opname
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|optable
index|[
name|i
index|]
operator|.
name|in
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check to see whether MANGLED can match TEXT in the first TEXT_LEN    characters. */
end_comment

begin_function
name|int
name|cplus_match
parameter_list|(
name|mangled
parameter_list|,
name|text
parameter_list|,
name|text_len
parameter_list|)
name|CONST
name|char
modifier|*
name|mangled
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|text_len
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|mangled
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* cannot match either */
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* matches mangled, may match demangled */
block|}
block|}
end_function

begin_comment
comment|/* char *cplus_demangle (const char *name, int options)     If NAME is a mangled function name produced by GNU C++, then    a pointer to a malloced string giving a C++ representation    of the name will be returned; otherwise NULL will be returned.    It is the caller's responsibility to free the string which    is returned.     The OPTIONS arg may contain one or more of the following bits:     	DMGL_ANSI	ANSI qualifiers such as `const' and `void' are 			included. 	DMGL_PARAMS	Function parameters are included.     For example,        cplus_demangle ("foo__1Ai", DMGL_PARAMS)		=> "A::foo(int)"    cplus_demangle ("foo__1Ai", DMGL_PARAMS | DMGL_ANSI)	=> "A::foo(int)"    cplus_demangle ("foo__1Ai", 0)			=> "A::foo"     cplus_demangle ("foo__1Afe", DMGL_PARAMS)		=> "A::foo(float,...)"    cplus_demangle ("foo__1Afe", DMGL_PARAMS | DMGL_ANSI)=> "A::foo(float,...)"    cplus_demangle ("foo__1Afe", 0)			=> "A::foo"     Note that any leading underscores, or other such characters prepended by    the compilation system, are presumed to have already been stripped from    TYPE.  */
end_comment

begin_function
name|char
modifier|*
name|cplus_demangle
parameter_list|(
name|mangled
parameter_list|,
name|options
parameter_list|)
name|CONST
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|string
name|decl
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|struct
name|work_stuff
name|work
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|mangled
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|options
operator|=
name|options
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|->
name|options
operator|&
name|DMGL_STYLE_MASK
operator|)
operator|==
literal|0
condition|)
name|work
operator|->
name|options
operator||=
operator|(
name|int
operator|)
name|current_demangling_style
operator|&
name|DMGL_STYLE_MASK
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
comment|/* First check to see if gnu style demangling is active and if the 	 string to be demangled contains a CPLUS_MARKER.  If so, attempt to 	 recognize one of the gnu special forms rather than looking for a 	 standard prefix.  In particular, don't worry about whether there 	 is a "__" string in the mangled string.  Consider "_$_5__foo" for 	 example. */
if|if
condition|(
operator|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
operator|)
condition|)
block|{
name|success
operator|=
name|gnu_special
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|success
operator|=
name|demangle_prefix
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|success
operator|=
name|demangle_signature
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|constructor
operator|==
literal|2
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"global constructors keyed to "
argument_list|)
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|destructor
operator|==
literal|2
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"global destructors keyed to "
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|0
expr_stmt|;
block|}
name|demangled
operator|=
name|mop_up
argument_list|(
name|work
argument_list|,
operator|&
name|decl
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mop_up
parameter_list|(
name|work
parameter_list|,
name|declp
parameter_list|,
name|success
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
name|int
name|success
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
comment|/* Discard the remembered types, if any. */
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|typevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|typevec
argument_list|)
expr_stmt|;
block|}
comment|/* If demangling was successful, ensure that the demangled string is null      terminated and return it.  Otherwise, free the demangling decl. */
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|string_delete
argument_list|(
name|declp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|declp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|declp
operator|->
name|b
expr_stmt|;
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_signature -- demangle the signature part of a mangled name  SYNOPSIS  	static int 	demangle_signature (struct work_stuff *work, const char **mangled, 			    string *declp);  DESCRIPTION  	Consume and demangle the signature portion of the mangled name.  	DECLP is the string where demangled output is being built.  At 	entry it contains the demangled root name from the mangled name 	prefix.  I.E. either a demangled operator name or the root function 	name.  In some special cases, it may contain nothing.  	*MANGLED points to the current unconsumed location in the mangled 	name.  As tokens are consumed and demangling is performed, the 	pointer is updated to continuously point at the next token to 	be consumed.  	Demangling GNU style mangled names is nasty because there is no 	explicit token that marks the start of the outermost function 	argument list. */
end_comment

begin_function
specifier|static
name|int
name|demangle_signature
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
name|int
name|func_done
init|=
literal|0
decl_stmt|;
name|int
name|expect_func
init|=
literal|0
decl_stmt|;
name|CONST
name|char
modifier|*
name|oldmangled
init|=
name|NULL
decl_stmt|;
name|string
name|trawname
decl_stmt|;
name|string
name|tname
decl_stmt|;
while|while
condition|(
name|success
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static member function */
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|work
operator|->
name|static_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* a const member function */
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|work
operator|->
name|const_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
name|success
operator|=
name|demangle_class
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Function */
comment|/* ARM style demangling includes a specific 'F' character after 	     the class name.  For GNU style, it is just implied.  So we can 	     safely just consume any 'F' at this point and be compatible 	     with either style. */
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|func_done
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* For lucid/ARM style we have to forget any types we might 	       have remembered up to this point, since they were not argument 	       types.  GNU style considers all types seen as available for 	       back references.  See comment in demangle_args() */
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
condition|)
block|{
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* G++ Template */
name|string_init
argument_list|(
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|tname
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|tname
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|trawname
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|work
operator|->
name|constructor
operator|-=
literal|1
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
name|expect_func
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* At the outermost level, we cannot have a return type specified, 	       so if we run into another '_' at this point we are dealing with 	       a mangled name that is either bogus, or has been mangled by 	       some algorithm we don't know how to deal with.  So just 	       reject the entire demangling. */
name|success
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* Assume we have stumbled onto the first outermost function 		   argument token, and start processing args. */
name|func_done
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-GNU demanglers use a specific token to mark the start 		   of the outermost function argument tokens.  Typically 'F', 		   for ARM-demangling, for example.  So if we find something 		   we are not prepared for, it must be an error. */
name|success
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
if|if
condition|(
name|success
operator|&&
name|expect_func
condition|)
block|{
name|func_done
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|success
operator|&&
operator|!
name|func_done
condition|)
block|{
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* With GNU style demangling, bar__3foo is 'foo::bar(void)', and 	     bar__3fooi is 'foo::bar(int)'.  We get here when we find the 	     first case, and need to ensure that the '(void)' gets added to 	     the current declp.  Note that with ARM, the first case 	     represents the name of a static data member 'foo::bar', 	     which is in the current declp, so we leave it alone. */
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
operator|&&
name|work
operator|->
name|static_type
operator|&&
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" static"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
name|work
operator|->
name|const_type
operator|&&
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" const"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int demangle_method_args (work, mangled, declp)      struct work_stuff *work;      CONST char **mangled;      string *declp; {   int success = 0;    if (work -> static_type)     {       string_append (declp, *mangled + 1);       *mangled += strlen (*mangled);       success = 1;     }   else     {       success = demangle_args (work, mangled, declp);     }   return (success); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|demangle_template
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|tname
parameter_list|,
name|trawname
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|tname
decl_stmt|;
name|string
modifier|*
name|trawname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|is_pointer
decl_stmt|;
name|int
name|is_real
decl_stmt|;
name|int
name|is_integral
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|done
decl_stmt|;
name|CONST
name|char
modifier|*
name|old_p
decl_stmt|;
name|CONST
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|symbol_len
decl_stmt|;
name|string
name|temp
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|start
operator|=
operator|*
name|mangled
expr_stmt|;
comment|/* get template name */
if|if
condition|(
operator|(
name|r
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|trawname
condition|)
name|string_appendn
argument_list|(
name|trawname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|r
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
comment|/* get size of template parameter list */
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|/* Z for type parameters */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_appends
argument_list|(
name|tname
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
comment|/* otherwise, value parameter */
name|old_p
operator|=
operator|*
name|mangled
expr_stmt|;
name|is_pointer
operator|=
literal|0
expr_stmt|;
name|is_real
operator|=
literal|0
expr_stmt|;
name|is_integral
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_appends
argument_list|(
name|tname
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|old_p
operator|&&
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
name|old_p
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'R'
case|:
name|done
operator|=
name|is_pointer
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* const */
case|case
literal|'S'
case|:
comment|/* explicitly signed [char] */
case|case
literal|'U'
case|:
comment|/* unsigned */
case|case
literal|'V'
case|:
comment|/* volatile */
case|case
literal|'F'
case|:
comment|/* function */
case|case
literal|'M'
case|:
comment|/* member function */
case|case
literal|'O'
case|:
comment|/* ??? */
name|old_p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/* repetition of following */
case|case
literal|'T'
case|:
comment|/* remembered type */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* void */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* long long */
case|case
literal|'l'
case|:
comment|/* long */
case|case
literal|'i'
case|:
comment|/* int */
case|case
literal|'s'
case|:
comment|/* short */
case|case
literal|'c'
case|:
comment|/* char */
case|case
literal|'w'
case|:
comment|/* wchar_t */
name|done
operator|=
name|is_integral
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* long double */
case|case
literal|'d'
case|:
comment|/* double */
case|case
literal|'f'
case|:
comment|/* float */
name|done
operator|=
name|is_real
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_integral
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_real
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'.'
condition|)
comment|/* fraction */
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'e'
condition|)
comment|/* exponent */
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
literal|"e"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|is_pointer
condition|)
block|{
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|symbol_len
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
name|symbol_len
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|symbol_len
expr_stmt|;
block|}
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|string_append
argument_list|(
name|tname
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
comment|/*       if (work -> static_type) 	{ 	  string_append (declp, *mangled + 1); 	  *mangled += strlen (*mangled); 	  success = 1; 	}       else 	{ 	  success = demangle_args (work, mangled, declp); 	}     } */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_pt
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|n
parameter_list|,
name|anchor
parameter_list|,
name|args
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|n
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|anchor
decl_stmt|,
decl|*
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
comment|/* ARM template? */
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
operator|(
operator|*
name|anchor
operator|=
name|strstr
argument_list|(
name|mangled
argument_list|,
literal|"__pt__"
argument_list|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|args
operator|=
operator|*
name|anchor
operator|+
literal|6
expr_stmt|;
name|len
operator|=
name|consume_count
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|+
name|len
operator|==
name|mangled
operator|+
name|n
operator|&&
operator|*
operator|*
name|args
operator|==
literal|'_'
condition|)
block|{
operator|++
operator|*
name|args
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|demangle_class_name
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
name|n
condition|)
block|{
name|CONST
name|char
modifier|*
name|p
decl_stmt|;
name|CONST
name|char
modifier|*
name|args
decl_stmt|;
name|CONST
name|char
modifier|*
name|e
init|=
operator|*
name|mangled
operator|+
name|n
decl_stmt|;
comment|/* ARM template? */
if|if
condition|(
name|arm_pt
argument_list|(
name|work
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|args
argument_list|)
condition|)
block|{
name|string
name|arg
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|p
operator|-
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
comment|/* should do error checking here */
while|while
condition|(
name|args
operator|<
name|e
condition|)
block|{
name|string_clear
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
operator|--
name|declp
operator|->
name|p
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|n
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_class -- demangle a mangled class sequence  SYNOPSIS  	static int 	demangle_class (struct work_stuff *work, const char **mangled, 			strint *declp)  DESCRIPTION  	DECLP points to the buffer into which demangling is being done.  	*MANGLED points to the current token to be demangled.  On input, 	it points to a mangled class (I.E. "3foo", "13verylongclass", etc.) 	On exit, it points to the next token after the mangled class on 	success, or the first unconsumed token on failure.  	If the CONSTRUCTOR or DESTRUCTOR flags are set in WORK, then 	we are demangling a constructor or destructor.  In this case 	we prepend "class::class" or "class::~class" to DECLP.  	Otherwise, we prepend "class::" to the current DECLP.  	Reset the constructor/destructor flags once they have been 	"consumed".  This allows demangle_class to be called later during 	the same demangling, to do normal class demangling.  	Returns 1 if demangling is successful, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_class
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|string
name|class_name
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|class_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangle_class_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|class_name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|class_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|constructor
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|class_name
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|class_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_prefix -- consume the mangled name prefix and find signature  SYNOPSIS  	static int 	demangle_prefix (struct work_stuff *work, const char **mangled, 			 string *declp);  DESCRIPTION  	Consume and demangle the prefix of the mangled name.  	DECLP points to the string buffer into which demangled output is 	placed.  On entry, the buffer is empty.  On exit it contains 	the root function name, the demangled operator name, or in some 	special cases either nothing or the completely demangled result.  	MANGLED points to the current pointer into the mangled name.  As each 	token of the mangled name is consumed, it is updated.  Upon entry 	the current mangled name pointer points to the first character of 	the mangled name.  Upon exit, it should point to the first character 	of the signature if demangling was successful, or to the first 	unconsumed character if demangling of the prefix was unsuccessful. 	 	Returns 1 on success, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_prefix
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
name|CONST
name|char
modifier|*
name|scan
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_GLOBAL_$D$"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a GNU global destructor to be executed at program exit */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|11
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_GLOBAL_$I$"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a GNU global constructor to be executed at program initial */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|11
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__std__"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a ARM global destructor to be executed at program exit */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|7
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__sti__"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a ARM global constructor to be executed at program initial */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|7
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|2
expr_stmt|;
block|}
comment|/*  This block of code is a reduction in strength time optimization     of:     	scan = strstr (*mangled, "__"); */
block|{
name|scan
operator|=
operator|*
name|mangled
expr_stmt|;
do|do
block|{
name|scan
operator|=
name|strchr
argument_list|(
name|scan
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|scan
operator|!=
literal|'_'
condition|)
do|;
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
operator|--
name|scan
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
comment|/* We found a sequence of two or more '_', ensure that we start at 	 the last pair in the sequence. */
name|i
operator|=
name|strspn
argument_list|(
name|scan
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|scan
operator|+=
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scan
operator|==
name|NULL
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|static_type
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|scan
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|scan
index|[
literal|0
index|]
operator|!=
literal|'t'
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scan
operator|==
operator|*
name|mangled
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|scan
index|[
literal|2
index|]
argument_list|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|)
condition|)
block|{
comment|/* The ARM says nothing about the mangling of local variables. 	 But cfront mangles local variables by prepending __<nesting_level> 	 to them. As an extension to ARM demangling we handle this case.  */
if|if
condition|(
operator|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|)
operator|&&
name|isdigit
argument_list|(
name|scan
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mangled
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A GNU style constructor starts with "__[0-9Qt]. */
name|work
operator|->
name|constructor
operator|+=
literal|1
expr_stmt|;
operator|*
name|mangled
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scan
operator|==
operator|*
name|mangled
operator|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|scan
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|scan
index|[
literal|2
index|]
operator|!=
literal|'t'
operator|)
condition|)
block|{
comment|/* Mangled name starts with "__".  Skip over any leading '_' characters, 	 then find the next "__" that separates the prefix from the signature. 	 */
if|if
condition|(
operator|!
operator|(
name|ARM_DEMANGLING
operator|||
name|LUCID_DEMANGLING
operator|)
operator|||
operator|(
name|arm_special
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|scan
operator|==
literal|'_'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scan
operator|=
name|strstr
argument_list|(
name|scan
argument_list|,
literal|"__"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* No separator (I.E. "__not_mangled"), or empty signature 		 (I.E. "__not_mangled_either__") */
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|demangle_function_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Mangled name does not start with "__" but does have one somewhere 	 in there with non empty stuff after it.  Looks like a global 	 function name. */
name|demangle_function_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Doesn't look like a mangled name */
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
operator|&&
operator|(
name|work
operator|->
name|constructor
operator|==
literal|2
operator|||
name|work
operator|->
name|destructor
operator|==
literal|2
operator|)
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	gnu_special -- special handling of gnu mangled strings  SYNOPSIS  	static int 	gnu_special (struct work_stuff *work, const char **mangled, 		     string *declp);   DESCRIPTION  	Process some special GNU style mangling forms that don't fit 	the normal pattern.  For example:  		_$_3foo		(destructor for class foo) 		_vt$foo		(foo virtual table) 		_vt$foo$bar	(foo::bar virtual table) 		_3foo$varname	(static data member) 		_Q22rs2tu$vw	(static data member) 		__t6vector1Zii	(constructor with template)  */
end_comment

begin_function
specifier|static
name|int
name|gnu_special
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|CONST
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
comment|/* Found a GNU style destructor, get past "_<CPLUS_MARKER>_" */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|3
expr_stmt|;
name|work
operator|->
name|destructor
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a GNU style virtual table, get past "_vt<CPLUS_MARKER>"          and create the decl.  Note that we consume the entire mangled 	 input string, which means that demangle_signature has no work 	 to do. */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|mangled
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|strcspn
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
expr_stmt|;
block|}
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|strchr
argument_list|(
literal|"0123456789Qt"
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* static data member, "_3foo$varname" for example */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
name|p
operator|==
operator|*
name|mangled
operator|)
condition|)
block|{
comment|/* Consumed everything up to the cplus_marker, append the 	     variable name. */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	arm_special -- special handling of ARM/lucid mangled strings  SYNOPSIS  	static int 	arm_special (struct work_stuff *work, const char **mangled, 			string *declp);   DESCRIPTION  	Process some special ARM style mangling forms that don't fit 	the normal pattern.  For example:  		__vtbl__3foo		(foo virtual table) 		__vtbl__3foo__3bar	(bar::foo virtual table)   */
end_comment

begin_function
specifier|static
name|int
name|arm_special
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|CONST
name|char
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
name|ARM_VTABLE_STRING
argument_list|,
name|ARM_VTABLE_STRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found a ARM style virtual table, get past ARM_VTABLE_STRING          and create the decl.  Note that we consume the entire mangled 	 input string, which means that demangle_signature has no work 	 to do. */
name|scan
operator|=
operator|*
name|mangled
operator|+
name|ARM_VTABLE_STRLEN
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|!=
literal|'\0'
condition|)
comment|/* first check it can be demangled */
block|{
name|n
operator|=
name|consume_count
argument_list|(
operator|&
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no good */
block|}
name|scan
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|scan
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|scan
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|scan
operator|+=
literal|2
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|ARM_VTABLE_STRLEN
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_prependn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_qualified -- demangle 'Q' qualified name strings  SYNOPSIS  	static int 	demangle_qualified (struct work_stuff *, const char *mangled, 			    string *result, int isfuncname, int append);  DESCRIPTION  	Demangle a qualified name, such as "Q25Outer5Inner" which is 	the mangled form of "Outer::Inner".  The demangled output is 	prepended or appended to the result string according to the 	state of the append flag.  	If isfuncname is nonzero, then the qualified name we are building 	is going to be used as a member function name, so if it is a 	constructor or destructor function, append an appropriate 	constructor or destructor name.  I.E. for the above example, 	the result for use as a constructor is "Outer::Inner::Inner" 	and the result for use as a destructor is "Outer::Inner::~Inner".  BUGS  	Numeric conversion is ASCII dependent (FIXME).   */
end_comment

begin_function
specifier|static
name|int
name|demangle_qualified
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|,
name|isfuncname
parameter_list|,
name|append
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
name|int
name|isfuncname
decl_stmt|;
name|int
name|append
decl_stmt|;
block|{
name|int
name|qualifiers
decl_stmt|;
name|int
name|namelength
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|CONST
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|num
index|[
literal|2
index|]
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'_'
case|:
comment|/* GNU mangled name with more than 9 classes.  The count is preceded 	 by an underscore (to distinguish it from the<= 9 case) and followed 	 by an underscore.  */
name|p
operator|=
operator|*
name|mangled
operator|+
literal|2
expr_stmt|;
name|qualifiers
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'0'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
comment|/* Skip the digits.  */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'_'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
operator|*
name|mangled
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* The count is in a single digit.  */
name|num
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|num
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qualifiers
operator|=
name|atoi
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* If there is an underscore after the digit, skip it.  This is 	 said to be for ARM-qualified names, but the ARM makes no 	 mention of such an underscore.  Perhaps cfront uses one.  */
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
default|default:
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
return|return
name|success
return|;
comment|/* Pick off the names and collect them in the temp buffer in the order      in which they are found, separated by '::'. */
while|while
condition|(
name|qualifiers
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'t'
condition|)
block|{
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
else|else
block|{
name|namelength
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|<
name|namelength
condition|)
block|{
comment|/* Simple sanity check failed */
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_appendn
argument_list|(
operator|&
name|temp
argument_list|,
operator|*
name|mangled
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|namelength
expr_stmt|;
block|}
if|if
condition|(
name|qualifiers
operator|>
literal|0
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|temp
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are using the result as a function name, we need to append      the appropriate '::' separated constructor or destructor name.      We do this here because this is the most convenient place, where      we already have a pointer to the name and the length of the name. */
if|if
condition|(
name|isfuncname
operator|&&
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|||
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|temp
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
block|}
name|string_appendn
argument_list|(
operator|&
name|temp
argument_list|,
operator|(
operator|*
name|mangled
operator|)
operator|-
name|namelength
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
block|}
comment|/* Now either prepend the temp buffer to the result, or append it,       depending upon the state of the append flag. */
if|if
condition|(
name|append
condition|)
block|{
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|temp
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|string_prepends
argument_list|(
name|result
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	get_count -- convert an ascii count to integer, consuming tokens  SYNOPSIS  	static int 	get_count (const char **type, int *count)  DESCRIPTION  	Return 0 if no conversion is performed, 1 if a string is converted. */
end_comment

begin_function
specifier|static
name|int
name|get_count
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
name|CONST
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
block|{
name|CONST
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
operator|*
name|count
operator|=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|p
operator|=
operator|*
name|type
expr_stmt|;
name|n
operator|=
operator|*
name|count
expr_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
operator|*
name|type
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|count
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* result will be initialised here; it will be freed on failure */
end_comment

begin_function
specifier|static
name|int
name|do_type
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|success
decl_stmt|;
name|string
name|decl
decl_stmt|;
name|CONST
name|char
modifier|*
name|remembered_type
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|!
name|done
condition|)
block|{
name|int
name|member
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
comment|/* A pointer type */
case|case
literal|'P'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
comment|/* A reference type */
case|case
literal|'R'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
comment|/* An array */
case|case
literal|'A'
case|:
block|{
name|CONST
name|char
modifier|*
name|p
init|=
operator|++
operator|(
operator|*
name|mangled
operator|)
decl_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")["
argument_list|)
expr_stmt|;
comment|/* Copy anything up until the next underscore (the size of the 	       array).  */
while|while
condition|(
operator|*
operator|*
name|mangled
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
operator|++
operator|(
operator|*
name|mangled
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|decl
argument_list|,
name|p
argument_list|,
operator|*
name|mangled
operator|-
name|p
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* A back reference to a previously seen type */
case|case
literal|'T'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|n
argument_list|)
operator|||
name|n
operator|>=
name|work
operator|->
name|ntypes
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|remembered_type
operator|=
name|work
operator|->
name|typevec
index|[
name|n
index|]
expr_stmt|;
name|mangled
operator|=
operator|&
name|remembered_type
expr_stmt|;
block|}
break|break;
comment|/* A function */
case|case
literal|'F'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
operator|&&
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* After picking off the function args, we expect to either find the 	     function return type (preceded by an '_') or the end of the 	     string. */
if|if
condition|(
operator|!
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
operator|)
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
case|case
literal|'O'
case|:
block|{
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|member
operator|=
operator|*
operator|*
name|mangled
operator|==
literal|'M'
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|<
name|n
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'C'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|constp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'V'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|volatilep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
operator|*
name|mangled
operator|)
operator|++
operator|!=
literal|'F'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|member
operator|&&
operator|!
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
operator|)
operator|||
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|constp
condition|)
block|{
name|APPEND_BLANK
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|volatilep
condition|)
block|{
name|APPEND_BLANK
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'G'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* 	  if ((*mangled)[1] == 'P') 	    { */
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	    } */
comment|/* fall through */
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
comment|/* A qualified name, such as "Outer::Inner". */
case|case
literal|'Q'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|demangle_fund_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
block|{
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|string_delete
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a type string that represents a fundamental type    argument (int, long, unsigned int, etc) in TYPE, a pointer to the    string in which the demangled output is being built in RESULT, and    the WORK structure, decode the types and add them to the result.     For example:     	"Ci"	=>	"const int" 	"Sl"	=>	"signed long" 	"CUs"	=>	"const unsigned short"     */
end_comment

begin_function
specifier|static
name|int
name|demangle_fund_type
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
comment|/* First pick off any type qualifiers.  There can be more than one. */
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'C'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"unsigned"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* signed char only */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"signed"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now pick off the fundamental type.  There can be only one. */
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'_'
case|:
break|break;
case|case
literal|'v'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"wchar_t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long double"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* fall through */
comment|/* An explicit type, such as "6mytype" or "7integer" */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|demangle_class_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
condition|)
block|{
operator|--
name|result
operator|->
name|p
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/* `result' will be initialized in do_type; it will be freed on failure */
end_comment

begin_function
specifier|static
name|int
name|do_arg
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|CONST
name|char
modifier|*
name|start
init|=
operator|*
name|mangled
decl_stmt|;
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|start
argument_list|,
operator|*
name|mangled
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remember_type
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|ntypes
operator|>=
name|work
operator|->
name|typevec_size
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|typevec_size
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|typevec_size
operator|=
literal|3
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|typevec_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|typevec_size
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|typevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|typevec_size
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|typevec
index|[
name|work
operator|->
name|ntypes
operator|++
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget the remembered types, but not the type vector itself. */
end_comment

begin_function
specifier|static
name|void
name|forget_types
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|work
operator|->
name|ntypes
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|ntypes
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|typevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|typevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|typevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process the argument list part of the signature, after any class spec    has been consumed, as well as the first 'F' character (if any).  For    example:     "__als__3fooRT0"		=>	process "RT0"    "complexfunc5__FPFPc_PFl_i"	=>	process "PFPc_PFl_i"     DECLP must be already initialised, usually non-empty.  It won't be freed    on failure.     Note that g++ differs significantly from ARM and lucid style mangling    with regards to references to previously seen types.  For example, given    the source fragment:       class foo {        public:        foo::foo (int, foo&ia, int, foo&ib, int, foo&ic);      };       foo::foo (int, foo&ia, int, foo&ib, int, foo&ic) { ia = ib = ic; }      void foo (int, foo&ia, int, foo&ib, int, foo&ic) { ia = ib = ic; }     g++ produces the names:       __3fooiRT0iT2iT2      foo__FiR3fooiT1iT1     while lcc (and presumably other ARM style compilers as well) produces:       foo__FiR3fooT1T2T1T2      __ct__3fooFiR3fooT1T2T1T2     Note that g++ bases it's type numbers starting at zero and counts all    previously seen types, while lucid/ARM bases it's type numbers starting    at one and only considers types after it has seen the 'F' character    indicating the start of the function args.  For lucid/ARM style, we    account for this difference by discarding any previously seen types when    we see the 'F' character, and subtracting one from the type number    reference.   */
end_comment

begin_function
specifier|static
name|int
name|demangle_args
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|string
name|arg
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|t
decl_stmt|;
name|CONST
name|char
modifier|*
name|tem
decl_stmt|;
name|char
name|temptype
decl_stmt|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'\0'
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'e'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'N'
operator|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'T'
operator|)
condition|)
block|{
name|temptype
operator|=
operator|*
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|temptype
operator|==
literal|'N'
condition|)
block|{
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
condition|)
block|{
name|t
operator|--
expr_stmt|;
block|}
comment|/* Validate the type index.  Protect against illegal indices from 	     malformed type strings. */
if|if
condition|(
operator|(
name|t
operator|<
literal|0
operator|)
operator|||
operator|(
name|t
operator|>=
name|work
operator|->
name|ntypes
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|--
name|r
operator|>=
literal|0
condition|)
block|{
name|tem
operator|=
name|work
operator|->
name|typevec
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
name|need_comma
operator|&&
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|need_comma
operator|&
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'e'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|demangle_function_name
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|,
name|scan
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
name|CONST
name|char
modifier|*
name|scan
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|string
name|type
decl_stmt|;
name|CONST
name|char
modifier|*
name|tem
decl_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|(
operator|*
name|mangled
operator|)
argument_list|,
name|scan
operator|-
operator|(
operator|*
name|mangled
operator|)
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|declp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|declp
operator|->
name|p
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Consume the function name, including the "__" separating the name      from the signature.  We are guaranteed that SCAN points to the      separator. */
operator|(
operator|*
name|mangled
operator|)
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
condition|)
block|{
comment|/* See if we have an ARM style constructor or destructor operator. 	 If so, then just record it, clear the decl, and return. 	 We can't build the actual constructor/destructor decl until later, 	 when we recover the class name from the signature. */
if|if
condition|(
name|strcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"__ct"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|constructor
operator|+=
literal|1
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"__dt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|destructor
operator|+=
literal|1
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|3
operator|&&
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|declp
operator|->
name|b
index|[
literal|2
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* see if it's an assignment expression */
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|10
comment|/* op$assign_ */
operator|&&
name|memcmp
argument_list|(
name|declp
operator|->
name|b
operator|+
literal|3
argument_list|,
literal|"assign_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|-
literal|10
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|10
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|-
literal|3
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|3
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"type$"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* type conversion operator */
name|tem
operator|=
name|declp
operator|->
name|b
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
comment|/* ANSI.  */
comment|/* type conversion operator.  */
name|tem
operator|=
name|declp
operator|->
name|b
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|>=
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|<=
literal|'z'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|>=
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|<=
literal|'z'
condition|)
block|{
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Operator.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Assignment. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* a mini string-handling package */
end_comment

begin_function
specifier|static
name|void
name|string_need
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|32
condition|)
block|{
name|n
operator|=
literal|32
expr_stmt|;
block|}
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|e
operator|-
name|s
operator|->
name|p
operator|<
name|n
condition|)
block|{
name|tem
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|n
operator|+=
name|tem
expr_stmt|;
name|n
operator|*=
literal|2
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|xrealloc
argument_list|(
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|+
name|tem
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_delete
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_init
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_clear
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int string_empty (s)      string *s; {   return (s->b == s->p); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|string_append
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_appends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|s
operator|->
name|p
condition|)
block|{
name|n
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|string_appendn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepend
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|s
operator|->
name|p
condition|)
block|{
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|string_prependn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|p
operator|-
literal|1
init|;
name|q
operator|>=
name|p
operator|->
name|b
condition|;
name|q
operator|--
control|)
block|{
name|q
index|[
name|n
index|]
operator|=
name|q
index|[
literal|0
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
operator|->
name|b
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* To generate a standalone demangler program for testing purposes, just    compile and link this file with -DMAIN.   When run, it demangles each    command line arg, or each stdin string, and prints the result on stdout. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_function
specifier|static
name|void
name|demangle_it
parameter_list|(
name|mangled_name
parameter_list|)
name|char
modifier|*
name|mangled_name
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|newmem
decl_stmt|;
if|if
condition|(
operator|(
name|newmem
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nCan't allocate %u bytes\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|newmem
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|oldmem
parameter_list|,
name|size
parameter_list|)
name|PTR
name|oldmem
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|newmem
decl_stmt|;
if|if
condition|(
operator|(
name|newmem
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldmem
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nCan't reallocate %u bytes\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|newmem
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_version
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [-_] [-s {gnu,lucid,arm}] [--strip-underscores]\n\        [--format={gnu,lucid,arm}] [--help] [--version] [arg...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MBUF_SIZE
value|512
end_define

begin_decl_stmt
name|char
name|mbuffer
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in the automatically-generated ../binutils/underscore.c. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strip_underscore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'_'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|c
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|strip_underscore
operator|=
name|prepends_underscore
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"_s:"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"GNU %s version %s\n"
argument_list|,
name|program_name
argument_list|,
name|program_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'_'
case|:
name|strip_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_demangling_style
operator|=
name|gnu_demangling
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"lucid"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_demangling_style
operator|=
name|lucid_demangling
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"arm"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_demangling_style
operator|=
name|arm_demangling
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown demangling style `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|demangle_it
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Try to read a label. */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|MBUF_SIZE
operator|-
literal|1
condition|)
break|break;
name|mbuffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|skip_first
init|=
name|strip_underscore
operator|&&
name|i
operator|>
literal|1
operator|&&
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'_'
decl_stmt|;
name|mbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mbuffer
operator|+
name|skip_first
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|fputs
argument_list|(
name|result
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|mbuffer
operator|+
name|skip_first
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* main */
end_comment

end_unit

