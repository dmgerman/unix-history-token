begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB routines for manipulating objfiles.    Copyright 1992 Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains support routines for creating, manipulating, and    destroying objfile structures. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|open_existing_mapped_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_mapped_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|filename
operator|,
name|long
name|mtime
operator|,
name|int
name|mapped
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|map_to_address
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NO_MMALLOC)&& defined(HAVE_MMAP) */
end_comment

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Externally visible variables that are owned by this module.    See declarations in objfile.h for more info. */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|object_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all objfiles */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|current_objfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For symbol file being read in */
end_comment

begin_decl_stmt
name|struct
name|objfile
modifier|*
name|symfile_objfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main symbol table loaded from */
end_comment

begin_decl_stmt
name|int
name|mapped_symbol_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Try to use mapped symbol files */
end_comment

begin_comment
comment|/* Locate all mappable sections of a BFD file.     objfile_p_char is a char * to get it through    bfd_map_over_sections; we cast it back to its proper type.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_objfile_sections
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|objfile_p_char
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|objfile_p_char
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|objfile_p_char
decl_stmt|;
name|struct
name|obj_section
name|section
decl_stmt|;
name|flagword
name|aflag
decl_stmt|;
name|aflag
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
comment|/* FIXME, we need to handle BSS segment here...it alloc's but doesn't load */
if|if
condition|(
operator|!
operator|(
name|aflag
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
condition|)
return|return;
name|section
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|section
operator|.
name|objfile
operator|=
name|objfile
expr_stmt|;
name|section
operator|.
name|sec_ptr
operator|=
name|asect
expr_stmt|;
name|section
operator|.
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|section
operator|.
name|endaddr
operator|=
name|section
operator|.
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
operator|&
name|section
argument_list|,
sizeof|sizeof
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections_end
operator|=
operator|(
expr|struct
name|obj_section
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|objfile
operator|->
name|sections_end
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Builds a section table for OBJFILE.    Returns 0 if OK, 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|build_objfile_section_table
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sections
condition|)
name|abort
argument_list|()
expr_stmt|;
name|objfile
operator|->
name|sections_end
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|add_to_objfile_sections
argument_list|,
operator|(
name|char
operator|*
operator|)
name|objfile
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections
operator|=
operator|(
expr|struct
name|obj_section
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections_end
operator|=
name|objfile
operator|->
name|sections
operator|+
operator|(
name|unsigned
name|long
operator|)
name|objfile
operator|->
name|sections_end
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an initialized bfd (ABFD) and a flag that indicates    whether or not an objfile is to be mapped (MAPPED), allocate a new objfile    struct, fill it in as best we can, link it into the list of all known    objfiles, and return a pointer to the new objfile struct. */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|allocate_objfile
parameter_list|(
name|abfd
parameter_list|,
name|mapped
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|mapped
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|PTR
name|md
decl_stmt|;
name|CORE_ADDR
name|mapto
decl_stmt|;
name|mapped
operator||=
name|mapped_symbol_files
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
comment|/* If we can support mapped symbol files, try to open/reopen the mapped file      that corresponds to the file from which we wish to read symbols.  If the      objfile is to be mapped, we must malloc the structure itself using the      mmap version, and arrange that all memory allocation for the objfile uses      the mmap routines.  If we are reusing an existing mapped file, from which      we get our objfile pointer, we have to make sure that we update the      pointers to the alloc/free functions in the obstack, in case these      functions have moved within the current gdb. */
name|fd
operator|=
name|open_mapped_file
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_mtime
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mapto
operator|=
name|map_to_address
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|md
operator|=
name|mmalloc_attach
argument_list|(
name|fd
argument_list|,
operator|(
name|PTR
operator|)
name|mapto
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|objfile
operator|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|mmalloc_getkey
argument_list|(
name|md
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Update memory corruption handler function addresses. */
name|init_malloc
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|md
operator|=
name|md
expr_stmt|;
name|objfile
operator|->
name|mmfd
operator|=
name|fd
expr_stmt|;
comment|/* Update pointers to functions to *our* copies */
name|obstack_chunkfun
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|xmmalloc
argument_list|)
expr_stmt|;
name|obstack_freefun
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|mfree
argument_list|)
expr_stmt|;
name|obstack_chunkfun
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|xmmalloc
argument_list|)
expr_stmt|;
name|obstack_freefun
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|mfree
argument_list|)
expr_stmt|;
name|obstack_chunkfun
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|xmmalloc
argument_list|)
expr_stmt|;
name|obstack_freefun
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|mfree
argument_list|)
expr_stmt|;
comment|/* If already in objfile list, unlink it. */
name|unlink_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Forget things specific to a particular gdb, may have changed. */
name|objfile
operator|->
name|sf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Set up to detect internal memory corruption.  MUST be done before 	     the first malloc.  See comments in init_malloc() and mmcheck(). */
name|init_malloc
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|objfile
operator|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|xmmalloc
argument_list|(
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|md
operator|=
name|md
expr_stmt|;
name|objfile
operator|->
name|mmfd
operator|=
name|fd
expr_stmt|;
name|objfile
operator|->
name|flags
operator||=
name|OBJF_MAPPED
expr_stmt|;
name|mmalloc_setkey
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|obstack_specify_allocation_with_arg
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmmalloc
argument_list|,
name|mfree
argument_list|,
name|objfile
operator|->
name|md
argument_list|)
expr_stmt|;
name|obstack_specify_allocation_with_arg
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmmalloc
argument_list|,
name|mfree
argument_list|,
name|objfile
operator|->
name|md
argument_list|)
expr_stmt|;
name|obstack_specify_allocation_with_arg
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmmalloc
argument_list|,
name|mfree
argument_list|,
name|objfile
operator|->
name|md
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapped
operator|&&
operator|(
name|objfile
operator|==
name|NULL
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"symbol table for '%s' will not be mapped"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* defined(NO_MMALLOC) || !defined(HAVE_MMAP) */
if|if
condition|(
name|mapped
condition|)
block|{
name|warning
argument_list|(
literal|"this version of gdb does not support mapped symbol tables."
argument_list|)
expr_stmt|;
comment|/* Turn off the global flag so we don't try to do mapped symbol tables 	 any more, which shuts up gdb unless the user specifically gives the 	 "mapped" keyword again. */
name|mapped_symbol_files
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(NO_MMALLOC)&& defined(HAVE_MMAP) */
comment|/* If we don't support mapped symbol files, didn't ask for the file to be      mapped, or failed to open the mapped file for some reason, then revert      back to an unmapped objfile. */
if|if
condition|(
name|objfile
operator|==
name|NULL
condition|)
block|{
name|objfile
operator|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
comment|/* Update the per-objfile information that comes from the bfd, ensuring      that any data that is reference is saved in the per-objfile data      region. */
name|objfile
operator|->
name|obfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|name
operator|=
name|mstrsave
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Build section table.  */
if|if
condition|(
name|build_objfile_section_table
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Push this file onto the head of the linked list of other such files. */
name|objfile
operator|->
name|next
operator|=
name|object_files
expr_stmt|;
name|object_files
operator|=
name|objfile
expr_stmt|;
return|return
operator|(
name|objfile
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Unlink OBJFILE from the list of known objfiles, if it is found in the    list.     It is not a bug, or error, to call this function if OBJFILE is not known    to be in the current list.  This is done in the case of mapped objfiles,    for example, just to ensure that the mapped objfile doesn't appear twice    in the list.  Since the list is threaded, linking in a mapped objfile    twice would create a circular list.     If OBJFILE turns out to be in the list, we zap it's NEXT pointer after    unlinking it, just to ensure that we have completely severed any linkages    between the OBJFILE and the list. */
end_comment

begin_function
name|void
name|unlink_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
modifier|*
name|objpp
decl_stmt|;
for|for
control|(
name|objpp
operator|=
operator|&
name|object_files
init|;
operator|*
name|objpp
operator|!=
name|NULL
condition|;
name|objpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|objpp
operator|)
operator|->
name|next
operator|)
control|)
block|{
if|if
condition|(
operator|*
name|objpp
operator|==
name|objfile
condition|)
block|{
operator|*
name|objpp
operator|=
operator|(
operator|*
name|objpp
operator|)
operator|->
name|next
expr_stmt|;
name|objfile
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Destroy an objfile and all the symtabs and psymtabs under it.  Note    that as much as possible is allocated on the symbol_obstack and    psymbol_obstack, so that the memory can be efficiently freed.     Things which we do NOT free because they are not in malloc'd memory    or not in memory specific to the objfile include:     	objfile -> sf     FIXME:  If the objfile is using reusable symbol information (via mmalloc),    then we need to take into account the fact that more than one process    may be using the symbol information at the same time (when mmalloc is    extended to support cooperative locking).  When more than one process    is using the mapped symbol info, we need to be more careful about when    we free objects in the reusable area. */
end_comment

begin_function
name|void
name|free_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|mmfd
decl_stmt|;
comment|/* First do any symbol file specific actions required when we are      finished with a particular symbol file.  Note that if the objfile      is using reusable symbol information (via mmalloc) then each of      these routines is responsible for doing the correct thing, either      freeing things which are valid only during this particular gdb      execution, or leaving them to be reused during the next one. */
if|if
condition|(
name|objfile
operator|->
name|sf
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_finish
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We always close the bfd. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
name|bfd_close
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Remove it from the chain of all objfiles. */
name|unlink_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Before the symbol table code was redone to make it easier to      selectively load and remove information particular to a specific      linkage unit, gdb used to do these things whenever the monolithic      symbol table was blown away.  How much still needs to be done      is unknown, but we play it safe for now and keep each action until      it is shown to be no longer needed. */
if|#
directive|if
name|defined
argument_list|(
name|CLEAR_SOLIB
argument_list|)
name|CLEAR_SOLIB
argument_list|()
expr_stmt|;
comment|/* CLEAR_SOLIB closes the bfd's for any shared libraries.  But      the to_sections for a core file might refer to those bfd's.  So      detach any core file.  */
block|{
name|struct
name|target_ops
modifier|*
name|t
init|=
name|find_core_target
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
call|(
name|t
operator|->
name|to_detach
call|)
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|clear_pc_function_cache
argument_list|()
expr_stmt|;
comment|/* The last thing we do is free the objfile struct itself for the      non-reusable case, or detach from the mapped file for the reusable      case.  Note that the mmalloc_detach or the mfree is the last thing      we can do with this objfile. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
if|if
condition|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_MAPPED
condition|)
block|{
comment|/* Remember the fd so we can close it.  We can't close it before 	 doing the detach, and after the detach the objfile is gone. */
name|mmfd
operator|=
name|objfile
operator|->
name|mmfd
expr_stmt|;
name|mmalloc_detach
argument_list|(
name|objfile
operator|->
name|md
argument_list|)
expr_stmt|;
name|objfile
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|mmfd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(NO_MMALLOC)&& defined(HAVE_MMAP) */
comment|/* If we still have an objfile, then either we don't support reusable      objfiles or this one was not reusable.  So free it normally. */
if|if
condition|(
name|objfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|objfile
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* Free the obstacks for non-reusable objfiles */
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|objfile
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all the object files at once and clean up their users.  */
end_comment

begin_function
name|void
name|free_all_objfiles
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ALL_OBJFILES_SAFE
argument_list|(
argument|objfile
argument_list|,
argument|temp
argument_list|)
block|{
name|free_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate OBJFILE to NEW_OFFSETS.  There should be OBJFILE->NUM_SECTIONS    entries in new_offsets.  */
end_comment

begin_function
name|void
name|objfile_relocate
parameter_list|(
name|objfile
parameter_list|,
name|new_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|new_offsets
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|delta
init|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|delta
operator|->
name|offsets
argument_list|)
argument_list|)
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
block|{
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|i
argument_list|)
operator|=
name|ANOFFSET
argument_list|(
name|new_offsets
argument_list|,
name|i
argument_list|)
operator|-
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|something_changed
condition|)
return|return;
block|}
comment|/* OK, get all the symtabs.  */
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First the line table.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|nitems
condition|;
operator|++
name|i
control|)
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
block|}
comment|/* Don't relocate a shared blockvector more than once.  */
if|if
condition|(
operator|!
name|s
operator|->
name|primary
condition|)
continue|continue;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|j
decl_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|s
operator|->
name|block_line_section
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
decl_stmt|;
comment|/* The RS6000 code from which this was taken skipped 		   any symbols in STRUCT_NAMESPACE or UNDEF_NAMESPACE. 		   But I'm leaving out that test, on the theory that 		   they can't possibly pass the tests below.  */
if|if
condition|(
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_STATIC
operator|)
operator|&&
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|{
name|struct
name|partial_symtab
modifier|*
name|p
decl_stmt|;
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|p
argument_list|)
block|{
comment|/* FIXME: specific to symbol readers which use gdb-stabs.h. 	   We can only get away with it since objfile_relocate is only 	   used on XCOFF, which lacks psymtabs, and for gdb-stabs.h 	   targets.  */
name|p
operator|->
name|textlow
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|p
operator|->
name|texthigh
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
init|;
name|psym
operator|<
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
condition|;
name|psym
operator|++
control|)
if|if
condition|(
name|SYMBOL_SECTION
argument_list|(
name|psym
argument_list|)
operator|>=
literal|0
condition|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
init|;
name|psym
operator|<
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
condition|;
name|psym
operator|++
control|)
if|if
condition|(
name|SYMBOL_SECTION
argument_list|(
name|psym
argument_list|)
operator|>=
literal|0
condition|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|ALL_OBJFILE_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msym
argument_list|)
if|if
condition|(
name|SYMBOL_SECTION
argument_list|(
name|msym
argument_list|)
operator|>=
literal|0
condition|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|delta
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|ANOFFSET
argument_list|(
name|new_offsets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Many places in gdb want to test just to see if we have any partial    symbols available.  This function returns zero if none are currently    available, nonzero otherwise. */
end_comment

begin_function
name|int
name|have_partial_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofp
argument_list|)
block|{
if|if
condition|(
name|ofp
operator|->
name|psymtabs
operator|!=
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Many places in gdb want to test just to see if we have any full    symbols available.  This function returns zero if none are currently    available, nonzero otherwise. */
end_comment

begin_function
name|int
name|have_full_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofp
argument_list|)
block|{
if|if
condition|(
name|ofp
operator|->
name|symtabs
operator|!=
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Many places in gdb want to test just to see if we have any minimal    symbols available.  This function returns zero if none are currently    available, nonzero otherwise. */
end_comment

begin_function
name|int
name|have_minimal_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofp
argument_list|)
block|{
if|if
condition|(
name|ofp
operator|->
name|msymbols
operator|!=
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_comment
comment|/* Given the name of a mapped symbol file in SYMSFILENAME, and the timestamp    of the corresponding symbol file in MTIME, try to open an existing file    with the name SYMSFILENAME and verify it is more recent than the base    file by checking it's timestamp against MTIME.     If SYMSFILENAME does not exist (or can't be stat'd), simply returns -1.     If SYMSFILENAME does exist, but is out of date, we check to see if the    user has specified creation of a mapped file.  If so, we don't issue    any warning message because we will be creating a new mapped file anyway,    overwriting the old one.  If not, then we issue a warning message so that    the user will know why we aren't using this existing mapped symbol file.    In either case, we return -1.     If SYMSFILENAME does exist and is not out of date, but can't be opened for    some reason, then prints an appropriate system error message and returns -1.     Otherwise, returns the open file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|open_existing_mapped_file
parameter_list|(
name|symsfilename
parameter_list|,
name|mtime
parameter_list|,
name|mapped
parameter_list|)
name|char
modifier|*
name|symsfilename
decl_stmt|;
name|long
name|mtime
decl_stmt|;
name|int
name|mapped
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|symsfilename
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sbuf
operator|.
name|st_mtime
operator|<
name|mtime
condition|)
block|{
if|if
condition|(
operator|!
name|mapped
condition|)
block|{
name|warning
argument_list|(
literal|"mapped symbol file `%s' is out of date, ignored it"
argument_list|,
name|symsfilename
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|symsfilename
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|error_pre_print
condition|)
block|{
name|printf
argument_list|(
name|error_pre_print
argument_list|)
expr_stmt|;
block|}
name|print_sys_errmsg
argument_list|(
name|symsfilename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look for a mapped symbol file that corresponds to FILENAME and is more    recent than MTIME.  If MAPPED is nonzero, the user has asked that gdb    use a mapped symbol file for this file, so create a new one if one does    not currently exist.     If found, then return an open file descriptor for the file, otherwise    return -1.     This routine is responsible for implementing the policy that generates    the name of the mapped symbol file from the name of a file containing    symbols that gdb would like to read.  Currently this policy is to append    ".syms" to the name of the file.     This routine is also responsible for implementing the policy that    determines where the mapped symbol file is found (the search path).    This policy is that when reading an existing mapped file, a file of    the correct name in the current directory takes precedence over a    file of the correct name in the same directory as the symbol file.    When creating a new mapped file, it is always created in the current    directory.  This helps to minimize the chances of a user unknowingly    creating big mapped files in places like /bin and /usr/local/bin, and    allows a local copy to override a manually installed global copy (in    /bin for example).  */
end_comment

begin_function
specifier|static
name|int
name|open_mapped_file
parameter_list|(
name|filename
parameter_list|,
name|mtime
parameter_list|,
name|mapped
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|long
name|mtime
decl_stmt|;
name|int
name|mapped
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|symsfilename
decl_stmt|;
comment|/* First try to open an existing file in the current directory, and      then try the directory where the symbol file is located. */
name|symsfilename
operator|=
name|concat
argument_list|(
literal|"./"
argument_list|,
name|basename
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|".syms"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open_existing_mapped_file
argument_list|(
name|symsfilename
argument_list|,
name|mtime
argument_list|,
name|mapped
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|symsfilename
argument_list|)
expr_stmt|;
name|symsfilename
operator|=
name|concat
argument_list|(
name|filename
argument_list|,
literal|".syms"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open_existing_mapped_file
argument_list|(
name|symsfilename
argument_list|,
name|mtime
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have an open file by now, then either the file does not      already exist, or the base file has changed since it was created.  In      either case, if the user has specified use of a mapped file, then      create a new mapped file, truncating any existing one.  If we can't      create one, print a system error message saying why we can't.       By default the file is rw for everyone, with the user's umask taking      care of turning off the permissions the user wants off. */
if|if
condition|(
operator|(
name|fd
operator|<
literal|0
operator|)
operator|&&
name|mapped
condition|)
block|{
name|free
argument_list|(
name|symsfilename
argument_list|)
expr_stmt|;
name|symsfilename
operator|=
name|concat
argument_list|(
literal|"./"
argument_list|,
name|basename
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|".syms"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|symsfilename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|error_pre_print
condition|)
block|{
name|printf
argument_list|(
name|error_pre_print
argument_list|)
expr_stmt|;
block|}
name|print_sys_errmsg
argument_list|(
name|symsfilename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|symsfilename
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the base address at which we would like the next objfile's    mapped data to start.     For now, we use the kludge that the configuration specifies a base    address to which it is safe to map the first mmalloc heap, and an    increment to add to this address for each successive heap.  There are    a lot of issues to deal with here to make this work reasonably, including:       Avoid memory collisions with existing mapped address spaces       Reclaim address spaces when their mmalloc heaps are unmapped       When mmalloc heaps are shared between processes they have to be      mapped at the same addresses in each       Once created, a mmalloc heap that is to be mapped back in must be      mapped at the original address.  I.E. each objfile will expect to      be remapped at it's original address.  This becomes a problem if      the desired address is already in use.       etc, etc, etc.   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|map_to_address
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|MMAP_BASE_ADDRESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MMAP_INCREMENT
argument_list|)
specifier|static
name|CORE_ADDR
name|next
init|=
name|MMAP_BASE_ADDRESS
decl_stmt|;
name|CORE_ADDR
name|mapto
init|=
name|next
decl_stmt|;
name|next
operator|+=
name|MMAP_INCREMENT
expr_stmt|;
return|return
operator|(
name|mapto
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NO_MMALLOC)&& defined(HAVE_MMAP) */
end_comment

begin_comment
comment|/* Returns a section whose range includes PC or NULL if none found. */
end_comment

begin_function
name|struct
name|obj_section
modifier|*
name|find_pc_section
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|sections
init|;
name|s
operator|<
name|objfile
operator|->
name|sections_end
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|s
operator|->
name|addr
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|s
operator|->
name|endaddr
condition|)
return|return
operator|(
name|s
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

