begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions above target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*exec_file_display_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Binary file diddling handle for the core file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|core_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Backward compatability with old way of specifying core files.  */
end_comment

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Either way, seems bogus. */
name|t
operator|=
name|find_core_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|filename
condition|)
call|(
name|t
operator|->
name|to_detach
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
call|(
name|t
operator|->
name|to_open
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"GDB can't read core files on this machine."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call this to specify the hook for exec_file_command to call back.    This is called from the x-window display code.  */
end_comment

begin_function_decl
name|void
name|specify_exec_file_hook
parameter_list|(
name|hook
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*hook
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|exec_file_display_hook
operator|=
name|hook
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The exec file must be closed before running an inferior.    If it is needed again after the inferior dies, it must    be reopened.  */
end_comment

begin_function
name|void
name|close_exec_file
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FIXME
if|if
condition|(
name|exec_bfd
condition|)
name|bfd_tempclose
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|reopen_exec_file
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FIXME
if|if
condition|(
name|exec_bfd
condition|)
name|bfd_reopen
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have both a core file and an exec file,    print a warning if they don't go together.  */
end_comment

begin_function
name|void
name|validate_files
parameter_list|()
block|{
if|if
condition|(
name|exec_bfd
operator|&&
name|core_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|core_file_matches_executable_p
argument_list|(
name|core_bfd
argument_list|,
name|exec_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"core file may not match specified executable file."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
operator|>
name|bfd_get_mtime
argument_list|(
name|core_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"exec file is newer than core file."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the name of the executable file as a string.    ERR nonzero means get error if there is none specified;    otherwise return 0 in that case.  */
end_comment

begin_function
name|char
modifier|*
name|get_exec_file
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
if|if
condition|(
name|exec_bfd
condition|)
return|return
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
return|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|NULL
return|;
name|error
argument_list|(
literal|"No executable file specified.\n\ Use the \"file\" or \"exec-file\" command."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report a memory error with error().  */
end_comment

begin_function
name|void
name|memory_error
parameter_list|(
name|status
parameter_list|,
name|memaddr
parameter_list|)
name|int
name|status
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
block|{
if|if
condition|(
name|status
operator|==
name|EIO
condition|)
block|{
comment|/* Actually, address between memaddr and memaddr + len 	 was out of bounds. */
name|error
argument_list|(
literal|"Cannot access memory at address %s."
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|memaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Error accessing memory address %s: %s."
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|memaddr
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Same as target_read_memory, but report an error if can't read.  */
end_comment

begin_function
name|void
name|read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like target_read_memory, but slightly different parameters.  */
end_comment

begin_function
name|int
name|dis_asm_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|bfd_byte
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like memory_error with slightly different parameters.  */
end_comment

begin_function
name|void
name|dis_asm_memory_error
parameter_list|(
name|status
parameter_list|,
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|int
name|status
decl_stmt|;
name|bfd_vma
name|memaddr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like print_address with slightly different parameters.  */
end_comment

begin_function
name|void
name|dis_asm_print_address
parameter_list|(
name|addr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|addr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|print_address
argument_list|(
name|addr
argument_list|,
name|info
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as target_write_memory, but report an error if can't write.  */
end_comment

begin_function
name|void
name|write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read an integer from debugged memory, given address and number of bytes.  */
end_comment

begin_function
name|LONGEST
name|read_memory_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|LONGEST
name|read_memory_unsigned_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
expr|]
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The current default bfd target.  Points to storage allocated for    gnutarget_string.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gnutarget
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same thing, except it is "auto" not NULL for the default case.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gnutarget_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_gnutarget_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_gnutarget_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|gnutarget_string
argument_list|,
literal|"auto"
argument_list|)
condition|)
name|gnutarget
operator|=
name|NULL
expr_stmt|;
else|else
name|gnutarget
operator|=
name|gnutarget_string
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the gnutarget.  */
end_comment

begin_function
name|void
name|set_gnutarget
parameter_list|(
name|newtarget
parameter_list|)
name|char
modifier|*
name|newtarget
decl_stmt|;
block|{
if|if
condition|(
name|gnutarget_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|gnutarget_string
argument_list|)
expr_stmt|;
name|gnutarget_string
operator|=
name|savestring
argument_list|(
name|newtarget
argument_list|,
name|strlen
argument_list|(
name|newtarget
argument_list|)
argument_list|)
expr_stmt|;
name|set_gnutarget_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_core
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"core-file"
argument_list|,
name|class_files
argument_list|,
name|core_file_command
argument_list|,
literal|"Use FILE as core dump for examining memory and registers.\n\ No arg means have no core file.  This command has been superseded by the\n\ `target core' and `detach' commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"gnutarget"
argument_list|,
name|class_files
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gnutarget_string
argument_list|,
literal|"Set the current BFD target.\n\ Use `set gnutarget auto' to specify automatic detection."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_gnutarget_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
condition|)
name|set_gnutarget
argument_list|(
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_gnutarget
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

