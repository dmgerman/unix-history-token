begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read a symbol table in MIPS' format (Third-Eye).    Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993 Free Software    Foundation, Inc.    Contributed by Alessandro Forin (af@cs.cmu.edu) at CMU.  Major work    by Per Bothner, John Gilmore and Ian Lance Taylor at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module provides three functions: mipscoff_symfile_init,    which initializes to read a symbol file; mipscoff_new_init, which    discards existing cached information when all symbols are being    discarded; and mipscoff_symfile_read, which reads a symbol table    from a file.     mipscoff_symfile_read only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.  mipscoff_psymtab_to_symtab() is called indirectly through    a pointer in the psymtab to do this.     ECOFF symbol tables are mostly written in the byte order of the    target machine.  However, one section of the table (the auxiliary    symbol information) is written in the host byte order.  There is a    bit in the other symbol info which describes which host byte order    was used.  ECOFF thereby takes the trophy from Intel `b.out' for    the most brain-dead adaptation of a file format to byte order.     This module can read all four of the known byte-order combinations,    on any type of host.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_comment
comment|/* These are needed if the tm.h file does not contain the necessary    mips specific definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_EFI_SYMBOL_NAME
end_ifndef

begin_define
define|#
directive|define
name|MIPS_EFI_SYMBOL_NAME
value|"__GDB_EFI_INFO__"
end_define

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|mips_extra_func_info
block|{
name|long
name|numargs
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
block|}
typedef|*
name|mips_extra_func_info_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|RA_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|RA_REGNUM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_comment
comment|/* COFF-like aspects of ecoff files */
end_comment

begin_comment
comment|/* FIXME: coff/internal.h and aout/aout64.h both define N_ABS.  We    want the definition from aout/aout64.h.  */
end_comment

begin_undef
undef|#
directive|undef
name|N_ABS
end_undef

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* Private BFD a.out information.  */
end_comment

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* STABS information */
end_comment

begin_comment
comment|/* FIXME: libcoff.h and libaout.h both define a couple of macros.  We    don't use them.  */
end_comment

begin_undef
undef|#
directive|undef
name|exec_hdr
end_undef

begin_undef
undef|#
directive|undef
name|obj_sym_filepos
end_undef

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* Private BFD COFF information.  */
end_comment

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_comment
comment|/* Private BFD ECOFF information.  */
end_comment

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* Needed inside partial-stab.h */
end_comment

begin_comment
comment|/* Provide a default mapping from a ecoff register number to a gdb REGNUM.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|ECOFF_REG_TO_REGNUM
parameter_list|(
name|num
parameter_list|)
value|(num)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Information is passed among various mipsread routines for accessing    symbol files.  A pointer to this structure is kept in the sym_private    field of the objfile struct.  */
end_comment

begin_struct
struct|struct
name|ecoff_symfile_info
block|{
name|struct
name|mips_pending
modifier|*
modifier|*
name|pending_list
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ECOFF_SYMFILE_INFO
parameter_list|(
name|o
parameter_list|)
value|((struct ecoff_symfile_info *)((o)->sym_private))
end_define

begin_define
define|#
directive|define
name|ECOFF_PENDING_LIST
parameter_list|(
name|o
parameter_list|)
value|(ECOFF_SYMFILE_INFO(o)->pending_list)
end_define

begin_comment
comment|/* Each partial symbol table entry contains a pointer to private data    for the read_symtab() function to use when expanding a partial    symbol table entry to a full symbol table entry.     For mipsread this structure contains the index of the FDR that this    psymtab represents and a pointer to the BFD that the psymtab was    created from.  */
end_comment

begin_define
define|#
directive|define
name|PST_PRIVATE
parameter_list|(
name|p
parameter_list|)
value|((struct symloc *)(p)->read_symtab_private)
end_define

begin_define
define|#
directive|define
name|FDR_IDX
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->fdr_idx)
end_define

begin_define
define|#
directive|define
name|CUR_BFD
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->cur_bfd)
end_define

begin_struct
struct|struct
name|symloc
block|{
name|int
name|fdr_idx
decl_stmt|;
name|bfd
modifier|*
name|cur_bfd
decl_stmt|;
name|EXTR
modifier|*
name|extern_tab
decl_stmt|;
comment|/* Pointer to external symbols for this file. */
name|int
name|extern_count
decl_stmt|;
comment|/* Size of extern_tab. */
name|enum
name|language
name|pst_language
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Things we import explicitly from other modules */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various complaints about symbol reading that don't abort the process */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|bad_file_number_complaint
init|=
block|{
literal|"bad file number %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|index_complaint
init|=
block|{
literal|"bad aux index at symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|aux_index_complaint
init|=
block|{
literal|"bad proc end in aux found from symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|block_index_complaint
init|=
block|{
literal|"bad aux index at block symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_ext_complaint
init|=
block|{
literal|"unknown external symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_sym_complaint
init|=
block|{
literal|"unknown local symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_st_complaint
init|=
block|{
literal|"with type %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|block_overflow_complaint
init|=
block|{
literal|"block containing %s overfilled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|basic_type_complaint
init|=
block|{
literal|"cannot map MIPS basic type 0x%x for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_type_qual_complaint
init|=
block|{
literal|"unknown type qualifier 0x%x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|array_index_type_complaint
init|=
block|{
literal|"illegal array index type for %s, assuming int"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_tag_guess_complaint
init|=
block|{
literal|"guessed tag type of %s incorrectly"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|block_member_complaint
init|=
block|{
literal|"declaration block contains unhandled symbol type %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|stEnd_complaint
init|=
block|{
literal|"stEnd with storage class %d not handled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_mips_symtype_complaint
init|=
block|{
literal|"unknown symbol type 0x%x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|stab_unknown_complaint
init|=
block|{
literal|"unknown stabs symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|pdr_for_nonsymbol_complaint
init|=
block|{
literal|"PDR for %s, but no symbol"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|pdr_static_symbol_complaint
init|=
block|{
literal|"can't handle PDR for static proc at 0x%lx"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_setjmp_pdr_complaint
init|=
block|{
literal|"fixing bad setjmp PDR from libc"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_fbitfield_complaint
init|=
block|{
literal|"can't handle TIR fBitfield for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_continued_complaint
init|=
block|{
literal|"illegal TIR continued for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_rfd_entry_complaint
init|=
block|{
literal|"bad rfd entry for %s: file %d, index %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unexpected_type_code_complaint
init|=
block|{
literal|"unexpected type code for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unable_to_cross_ref_complaint
init|=
block|{
literal|"unable to cross ref btTypedef for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|illegal_forward_tq0_complaint
init|=
block|{
literal|"illegal tq0 in forward typedef for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|illegal_forward_bt_complaint
init|=
block|{
literal|"illegal bt %d in forward typedef for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_linetable_guess_complaint
init|=
block|{
literal|"guessed size of linetable for %s incorrectly"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros and extra defs */
end_comment

begin_comment
comment|/* Puns: hard to find whether -g was used and how */
end_comment

begin_define
define|#
directive|define
name|MIN_GLEVEL
value|GLEVEL_0
end_define

begin_define
define|#
directive|define
name|compare_glevel
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|(((a) == GLEVEL_3) ? ((b)< GLEVEL_3) :			\ 	 ((b) == GLEVEL_3) ? -1 : (int)((b) - (a)))
end_define

begin_escape
end_escape

begin_comment
comment|/* Things that really are local to this module */
end_comment

begin_comment
comment|/* Remember what we deduced to be the source language of this psymtab. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|psymtab_language
init|=
name|language_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current BFD.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|cur_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to current file decriptor record, and its index */
end_comment

begin_decl_stmt
specifier|static
name|FDR
modifier|*
name|cur_fdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cur_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of current symbol */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_sdx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note how much "debuggable" this image is.  We would like    to see at least one FDR with full symbols */
end_comment

begin_expr_stmt
specifier|static
name|max_gdbinfo
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|max_glevel
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* When examining .o files, report on undefined symbols */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_undef_symbols
decl_stmt|,
name|n_undef_labels
decl_stmt|,
name|n_undef_vars
decl_stmt|,
name|n_undef_procs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo symbol to use when putting stabs into the symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stabs_symbol
index|[]
init|=
name|STABS_SYMBOL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extra builtin types */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_complex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_double_complex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_fixed_dec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_float_dec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_mips_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_the_mips_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|upgrade_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|type
operator|*
operator|*
operator|,
name|int
operator|,
expr|union
name|aux_ext
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_partial_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cross_ref
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|union
name|aux_ext
operator|*
operator|,
expr|struct
name|type
operator|*
operator|*
operator|,
expr|enum
name|type_code
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_sigtramp
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|new_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block
modifier|*
name|new_block
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|new_symtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|new_linetable
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|blockvector
modifier|*
name|new_bvect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_symbol
name|PARAMS
argument_list|(
operator|(
name|SYMR
operator|*
operator|,
expr|union
name|aux_ext
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|parse_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|union
name|aux_ext
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|mylookup_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|block
operator|*
operator|,
expr|enum
name|namespace
operator|,
expr|enum
name|address_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block
modifier|*
name|shrink_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|xzalloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_blocks
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_blocks
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|new_psymtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
operator|,
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_line
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|shrink_linetable
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mips_next_symbol_text
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Things we export to other modules */
end_comment

begin_comment
comment|/* Address bounds for the signal trampoline in inferior, if any */
end_comment

begin_comment
comment|/* FIXME:  Nothing really seems to use this.  Why is it here? */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|sigtramp_address
decl_stmt|,
name|sigtramp_end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mipscoff_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|sigtramp_address
operator|=
literal|0
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipscoff_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|sym_private
operator|=
operator|(
name|PTR
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipscoff_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly.  */
name|read_mips_symtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|mipscoff_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
name|cur_bfd
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate zeroed memory */
end_comment

begin_function
specifier|static
name|PTR
name|xzalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|PTR
name|p
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Exported procedure: Builds a symtab from the PST partial one.    Restores the environment in effect when PST was created, delegates    most of the work to an ancillary procedure, and sorts    and reorders the symtab list at the end */
end_comment

begin_function
specifier|static
name|void
name|mipscoff_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|next_symbol_text_func
operator|=
name|mips_next_symbol_text
expr_stmt|;
name|psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,      after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exported procedure: Is PC in the signal trampoline code */
end_comment

begin_function
name|int
name|in_sigtramp
parameter_list|(
name|pc
parameter_list|,
name|ignore
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
name|ignore
decl_stmt|;
comment|/* function name */
block|{
if|if
condition|(
name|sigtramp_address
operator|==
literal|0
condition|)
name|fixup_sigtramp
argument_list|()
expr_stmt|;
return|return
operator|(
name|pc
operator|>=
name|sigtramp_address
operator|&&
name|pc
operator|<
name|sigtramp_end
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File-level interface functions */
end_comment

begin_comment
comment|/* Read the symtab information from file ABFD into memory.  */
end_comment

begin_function
specifier|static
name|void
name|read_the_mips_symtab
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
name|error
argument_list|(
literal|"Error reading symbol table: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a file descriptor given its index RF relative to a file CF */
end_comment

begin_function
specifier|static
name|FDR
modifier|*
name|get_rfd
parameter_list|(
name|cf
parameter_list|,
name|rf
parameter_list|)
name|int
name|cf
decl_stmt|,
name|rf
decl_stmt|;
block|{
name|FDR
modifier|*
name|fdrs
decl_stmt|;
specifier|register
name|FDR
modifier|*
name|f
decl_stmt|;
name|RFDT
name|rfd
decl_stmt|;
name|fdrs
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|f
operator|=
name|fdrs
operator|+
name|cf
expr_stmt|;
comment|/* Object files do not have the RFD table, all refs are absolute */
if|if
condition|(
name|f
operator|->
name|rfdBase
operator|==
literal|0
condition|)
return|return
name|fdrs
operator|+
name|rf
return|;
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_rfd_in
operator|)
operator|(
name|cur_bfd
operator|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_rfd
operator|+
operator|(
name|f
operator|->
name|rfdBase
operator|+
name|rf
operator|)
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_rfd_size
operator|)
operator|,
operator|&
name|rfd
operator|)
expr_stmt|;
return|return
name|fdrs
operator|+
name|rfd
return|;
block|}
end_function

begin_comment
comment|/* Return a safer print NAME for a file descriptor */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fdr_name
parameter_list|(
name|f
parameter_list|)
name|FDR
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|rss
operator|==
operator|-
literal|1
condition|)
return|return
literal|"<stripped file>"
return|;
if|if
condition|(
name|f
operator|->
name|rss
operator|==
literal|0
condition|)
return|return
literal|"<NFY>"
return|;
return|return
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|f
operator|->
name|issBase
operator|+
name|f
operator|->
name|rss
return|;
block|}
end_function

begin_comment
comment|/* Read in and parse the symtab of the file OBJFILE.  Symbols from    different sections are relocated via the SECTION_OFFSETS.  */
end_comment

begin_function
specifier|static
name|void
name|read_mips_symtab
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|cur_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|read_the_mips_symtab
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|parse_partial_symbols
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Check to make sure file was compiled with -g.  If not, warn the      user of this limitation.  */
block|if (compare_glevel (max_glevel, GLEVEL_2)< 0)     {       if (max_gdbinfo == 0) 	printf ("\n%s not compiled with -g, debugging support is limited.\n", 		 objfile->name);       printf ("You should compile with -g2 or -g3 for best debugging support.\n");       fflush (stdout);     }
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local utilities */
end_comment

begin_comment
comment|/* Map of FDR indexes to partial symtabs */
end_comment

begin_struct
struct|struct
name|pst_map
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* the psymtab proper */
name|long
name|n_globals
decl_stmt|;
comment|/* exported globals (external symbols) */
name|long
name|globals_offset
decl_stmt|;
comment|/* cumulative */
block|}
struct|;
end_struct

begin_comment
comment|/* Utility stack, used to nest procedures and blocks properly.    It is a doubly linked list, to avoid too many alloc/free.    Since we might need it quite a few times it is NOT deallocated    after use. */
end_comment

begin_struct
specifier|static
struct|struct
name|parse_stack
block|{
name|struct
name|parse_stack
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|symtab
modifier|*
name|cur_st
decl_stmt|;
comment|/* Current symtab. */
name|struct
name|block
modifier|*
name|cur_block
decl_stmt|;
comment|/* Block in it. */
name|int
name|blocktype
decl_stmt|;
comment|/* What are we parsing. */
name|int
name|maxsyms
decl_stmt|;
comment|/* Max symbols in this block. */
name|struct
name|type
modifier|*
name|cur_type
decl_stmt|;
comment|/* Type we parse fields for. */
name|int
name|cur_field
decl_stmt|;
comment|/* Field number in cur_type. */
name|CORE_ADDR
name|procadr
decl_stmt|;
comment|/* Start addres of this procedure */
name|int
name|numargs
decl_stmt|;
comment|/* Its argument count */
block|}
modifier|*
name|top_stack
struct|;
end_struct

begin_comment
comment|/* Top stack ptr */
end_comment

begin_comment
comment|/* Enter a new lexical context */
end_comment

begin_function
specifier|static
name|void
name|push_parse_stack
parameter_list|()
block|{
name|struct
name|parse_stack
modifier|*
name|new
decl_stmt|;
comment|/* Reuse frames if possible */
if|if
condition|(
name|top_stack
operator|&&
name|top_stack
operator|->
name|prev
condition|)
name|new
operator|=
name|top_stack
operator|->
name|prev
expr_stmt|;
else|else
name|new
operator|=
operator|(
expr|struct
name|parse_stack
operator|*
operator|)
name|xzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|parse_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize new frame with previous content */
if|if
condition|(
name|top_stack
condition|)
block|{
specifier|register
name|struct
name|parse_stack
modifier|*
name|prev
init|=
name|new
operator|->
name|prev
decl_stmt|;
operator|*
name|new
operator|=
operator|*
name|top_stack
expr_stmt|;
name|top_stack
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|top_stack
expr_stmt|;
block|}
name|top_stack
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a lexical context */
end_comment

begin_function
specifier|static
name|void
name|pop_parse_stack
parameter_list|()
block|{
if|if
condition|(
operator|!
name|top_stack
condition|)
return|return;
if|if
condition|(
name|top_stack
operator|->
name|next
condition|)
name|top_stack
operator|=
name|top_stack
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cross-references might be to things we haven't looked at    yet, e.g. type references.  To avoid too many type    duplications we keep a quick fixup table, an array    of lists of references indexed by file descriptor */
end_comment

begin_struct
struct|struct
name|mips_pending
block|{
name|struct
name|mips_pending
modifier|*
name|next
decl_stmt|;
comment|/* link */
name|char
modifier|*
name|s
decl_stmt|;
comment|/* the unswapped symbol */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
comment|/* its partial type descriptor */
block|}
struct|;
end_struct

begin_comment
comment|/* Check whether we already saw symbol SH in file FH */
end_comment

begin_function
specifier|static
name|struct
name|mips_pending
modifier|*
name|is_pending_symbol
parameter_list|(
name|fh
parameter_list|,
name|sh
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|sh
decl_stmt|;
block|{
name|int
name|f_idx
init|=
name|fh
operator|-
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
decl_stmt|;
specifier|register
name|struct
name|mips_pending
modifier|*
name|p
decl_stmt|;
name|struct
name|mips_pending
modifier|*
modifier|*
name|pending_list
init|=
name|ECOFF_PENDING_LIST
argument_list|(
name|current_objfile
argument_list|)
decl_stmt|;
comment|/* Linear search is ok, list is typically no more than 10 deep */
for|for
control|(
name|p
operator|=
name|pending_list
index|[
name|f_idx
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|s
operator|==
name|sh
condition|)
break|break;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new symbol SH of type T */
end_comment

begin_function
specifier|static
name|void
name|add_pending
parameter_list|(
name|fh
parameter_list|,
name|sh
parameter_list|,
name|t
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|sh
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|f_idx
init|=
name|fh
operator|-
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
decl_stmt|;
name|struct
name|mips_pending
modifier|*
name|p
init|=
name|is_pending_symbol
argument_list|(
name|fh
argument_list|,
name|sh
argument_list|)
decl_stmt|;
comment|/* Make sure we do not make duplicates */
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|struct
name|mips_pending
modifier|*
modifier|*
name|pending_list
init|=
name|ECOFF_PENDING_LIST
argument_list|(
name|current_objfile
argument_list|)
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|mips_pending
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_pending
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|s
operator|=
name|sh
expr_stmt|;
name|p
operator|->
name|t
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|pending_list
index|[
name|f_idx
index|]
expr_stmt|;
name|pending_list
index|[
name|f_idx
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parsing Routines proper. */
end_comment

begin_comment
comment|/* Parse a single symbol. Mostly just make up a GDB symbol for it.    For blocks, procedures and types we open a new lexical context.    This is basically just a big switch on the symbol's type.  Argument    AX is the base pointer of aux symbols for this file (fh->iauxBase).    EXT_SH points to the unswapped symbol, which is needed for struct,    union, etc., types; it is NULL for an EXTR.  BIGEND says whether    aux symbols are big-endian or little-endian.  Return count of    SYMR's handled (normally one).  */
end_comment

begin_function
specifier|static
name|int
name|parse_symbol
parameter_list|(
name|sh
parameter_list|,
name|ax
parameter_list|,
name|ext_sh
parameter_list|,
name|bigend
parameter_list|)
name|SYMR
modifier|*
name|sh
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|char
modifier|*
name|ext_sh
decl_stmt|;
name|int
name|bigend
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_sym_in
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|mips_pending
modifier|*
name|pend
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|struct
name|field
modifier|*
name|f
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|TIR
name|tir
decl_stmt|;
name|long
name|svalue
init|=
name|sh
operator|->
name|value
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
if|if
condition|(
name|ext_sh
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|sh
operator|->
name|iss
expr_stmt|;
else|else
name|name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|->
name|iss
expr_stmt|;
switch|switch
condition|(
name|sh
operator|->
name|st
condition|)
block|{
case|case
name|stNil
case|:
break|break;
case|case
name|stGlobal
case|:
comment|/* external symbol, goes into global block */
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|sh
operator|->
name|value
expr_stmt|;
goto|goto
name|data
goto|;
case|case
name|stStatic
case|:
comment|/* static data, goes into current block. */
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
name|b
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scCommon
condition|)
block|{
comment|/* It is a FORTRAN common block.  At least for SGI Fortran the 	     address is not in the symbol; we need to fix it later in 	     scan_file_globals.  */
name|int
name|bucket
init|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|global_sym_chain
index|[
name|bucket
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|bucket
index|]
operator|=
name|s
expr_stmt|;
block|}
else|else
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|sh
operator|->
name|value
expr_stmt|;
goto|goto
name|data
goto|;
case|case
name|stLocal
case|:
comment|/* local variable, goes into current block */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scRegister
condition|)
block|{
name|class
operator|=
name|LOC_REGISTER
expr_stmt|;
name|svalue
operator|=
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
block|}
else|else
name|class
operator|=
name|LOC_LOCAL
expr_stmt|;
name|b
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|svalue
expr_stmt|;
name|data
label|:
comment|/* Common code for symbols describing data */
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|class
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Type could be missing in a number of cases */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scUndefined
operator|||
name|sh
operator|->
name|sc
operator|==
name|scNil
operator|||
name|sh
operator|->
name|index
operator|==
literal|0xfffff
condition|)
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
comment|/* undefined? */
else|else
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
literal|0
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Value of a data symbol is its memory address */
break|break;
case|case
name|stParam
case|:
comment|/* arg to procedure, goes into current block */
name|max_gdbinfo
operator|++
expr_stmt|;
name|top_stack
operator|->
name|numargs
operator|++
expr_stmt|;
comment|/* Special GNU C++ name.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|CPLUS_MARKER
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|name
operator|=
literal|"this"
expr_stmt|;
comment|/* FIXME, not alloc'd in obstack */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
switch|switch
condition|(
name|sh
operator|->
name|sc
condition|)
block|{
case|case
name|scRegister
case|:
comment|/* Pass by value in register.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|svalue
operator|=
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|scVar
case|:
comment|/* Pass by reference on stack.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
break|break;
case|case
name|scVarRegister
case|:
comment|/* Pass by reference in register.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_REGPARM_ADDR
expr_stmt|;
name|svalue
operator|=
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Pass by value on stack.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
break|break;
block|}
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|svalue
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
literal|0
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME:  This has not been tested.  See dbxread.c */
comment|/* Add the type of this parameter to the function/procedure 		   type of this block. */
block|add_param_to_type (&top_stack->cur_block->function->type, s);
endif|#
directive|endif
break|break;
case|case
name|stLabel
case|:
comment|/* label, goes into current block */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* so that it can be used */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
comment|/* but not misused */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|sh
operator|->
name|value
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|stProc
case|:
comment|/* Procedure, usually goes into global block */
case|case
name|stStaticProc
case|:
comment|/* Static procedure, goes into current block */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
comment|/* Type of the return value */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scUndefined
operator|||
name|sh
operator|->
name|sc
operator|==
name|scNil
condition|)
name|t
operator|=
name|builtin_type_int
expr_stmt|;
else|else
name|t
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|b
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
if|if
condition|(
name|sh
operator|->
name|st
operator|==
name|stProc
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
decl_stmt|;
comment|/* The next test should normally be true, 		       but provides a hook for nested functions 		       (which we don't want to make global). */
if|if
condition|(
name|b
operator|==
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
condition|)
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
block|}
name|add_symbol
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Make a type for the procedure itself */
if|#
directive|if
literal|0
comment|/* FIXME:  This has not been tested yet!  See dbxread.c */
comment|/* Generate a template for the type of this function.  The 	 types of the arguments will be added as we read the symbol 	 table. */
block|memcpy (lookup_function_type (t), SYMBOL_TYPE (s), sizeof (struct type));
else|#
directive|else
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create and enter a new lexical context */
name|b
operator|=
name|new_block
argument_list|(
name|top_stack
operator|->
name|maxsyms
argument_list|)
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|b
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|=
name|s
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
comment|/* Not if we only have partial info */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scUndefined
operator|||
name|sh
operator|->
name|sc
operator|==
name|scNil
condition|)
break|break;
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|b
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|sh
operator|->
name|st
expr_stmt|;
name|top_stack
operator|->
name|cur_type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|top_stack
operator|->
name|cur_field
operator|=
operator|-
literal|1
expr_stmt|;
name|top_stack
operator|->
name|procadr
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|top_stack
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Beginning of code for structure, union, and enum definitions. 	       They all share a common set of local variables, defined here.  */
block|{
name|enum
name|type_code
name|type_code
decl_stmt|;
name|char
modifier|*
name|ext_tsym
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|long
name|max_value
decl_stmt|;
name|struct
name|field
modifier|*
name|f
decl_stmt|;
case|case
name|stStruct
case|:
comment|/* Start a block defining a struct type */
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
goto|goto
name|structured_common
goto|;
case|case
name|stUnion
case|:
comment|/* Start a block defining a union type */
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
goto|goto
name|structured_common
goto|;
case|case
name|stEnum
case|:
comment|/* Start a block defining an enum type */
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
goto|goto
name|structured_common
goto|;
case|case
name|stBlock
case|:
comment|/* Either a lexical block, or some type */
if|if
condition|(
name|sh
operator|->
name|sc
operator|!=
name|scInfo
operator|&&
name|sh
operator|->
name|sc
operator|!=
name|scCommon
condition|)
goto|goto
name|case_stBlock_code
goto|;
comment|/* Lexical block */
name|type_code
operator|=
name|TYPE_CODE_UNDEF
expr_stmt|;
comment|/* We have a type.  */
comment|/* Common code for handling struct, union, enum, and/or as-yet- 	   unknown-type blocks of info about structured data.  `type_code' 	   has been set to the proper TYPE_CODE, if we know it.  */
name|structured_common
label|:
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stBlock
expr_stmt|;
comment|/* First count the number of fields and the highest value. */
name|nfields
operator|=
literal|0
expr_stmt|;
name|max_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ext_tsym
operator|=
name|ext_sh
operator|+
name|external_sym_size
init|;
condition|;
name|ext_tsym
operator|+=
name|external_sym_size
control|)
block|{
name|SYMR
name|tsym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_tsym
argument_list|,
operator|&
name|tsym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tsym
operator|.
name|st
condition|)
block|{
case|case
name|stEnd
case|:
goto|goto
name|end_of_fields
goto|;
case|case
name|stMember
case|:
if|if
condition|(
name|nfields
operator|==
literal|0
operator|&&
name|type_code
operator|==
name|TYPE_CODE_UNDEF
condition|)
comment|/* If the type of the member is Nil (or Void), 		     without qualifiers, assume the tag is an 		     enumeration. */
if|if
condition|(
name|tsym
operator|.
name|index
operator|==
name|indexNil
condition|)
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
else|else
block|{
name|ecoff_swap_tir_in
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
index|[
name|tsym
operator|.
name|index
index|]
operator|.
name|a_ti
argument_list|,
operator|&
name|tir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tir
operator|.
name|bt
operator|==
name|btNil
operator|||
name|tir
operator|.
name|bt
operator|==
name|btVoid
operator|)
operator|&&
name|tir
operator|.
name|tq0
operator|==
name|tqNil
condition|)
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
block|}
name|nfields
operator|++
expr_stmt|;
if|if
condition|(
name|tsym
operator|.
name|value
operator|>
name|max_value
condition|)
name|max_value
operator|=
name|tsym
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|stBlock
case|:
case|case
name|stUnion
case|:
case|case
name|stEnum
case|:
case|case
name|stStruct
case|:
block|{
if|#
directive|if
literal|0
comment|/* This is a no-op; is it trying to tell us something 		     we should be checking?  */
block|if (tsym.sc == scVariant);
comment|/*UNIMPLEMENTED*/
endif|#
directive|endif
if|if
condition|(
name|tsym
operator|.
name|index
operator|!=
literal|0
condition|)
block|{
comment|/* This is something like a struct within a 			 struct.  Skip over the fields of the inner 			 struct.  The -1 is because the for loop will 			 increment ext_tsym.  */
name|ext_tsym
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|cur_fdr
operator|->
name|isymBase
operator|+
name|tsym
operator|.
name|index
operator|-
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|stTypedef
case|:
comment|/* mips cc puts out a typedef for struct x if it is not yet 		   defined when it encounters 		   struct y { struct x *xp; }; 		   Just ignore it. */
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|block_member_complaint
argument_list|,
name|tsym
operator|.
name|st
argument_list|)
expr_stmt|;
block|}
block|}
name|end_of_fields
label|:
empty_stmt|;
comment|/* In an stBlock, there is no way to distinguish structs, 	   unions, and enums at this point.  This is a bug in the 	   original design (that has been fixed with the recent 	   addition of the stStruct, stUnion, and stEnum symbol 	   types.)  The way you can tell is if/when you see a variable 	   or field of that type.  In that case the variable's type 	   (in the AUX table) says if the type is struct, union, or 	   enum, and points back to the stBlock here.  So you can 	   patch the tag kind up later - but only if there actually is 	   a variable or field of that type.  	   So until we know for sure, we will guess at this point. 	   The heuristic is: 	   If the first member has index==indexNil or a void type, 	   assume we have an enumeration. 	   Otherwise, if there is more than one member, and all 	   the members have offset 0, assume we have a union. 	   Otherwise, assume we have a struct.  	   The heuristic could guess wrong in the case of of an 	   enumeration with no members or a union with one (or zero) 	   members, or when all except the last field of a struct have 	   width zero.  These are uncommon and/or illegal situations, 	   and in any case guessing wrong probably doesn't matter 	   much.  	   But if we later do find out we were wrong, we fixup the tag 	   kind.  Members of an enumeration must be handled 	   differently from struct/union fields, and that is harder to 	   patch up, but luckily we shouldn't need to.  (If there are 	   any enumeration members, we can tell for sure it's an enum 	   here.) */
if|if
condition|(
name|type_code
operator|==
name|TYPE_CODE_UNDEF
condition|)
if|if
condition|(
name|nfields
operator|>
literal|1
operator|&&
name|max_value
operator|==
literal|0
condition|)
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
else|else
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
comment|/* Create a new type or use the pending type.  */
name|pend
operator|=
name|is_pending_symbol
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|==
operator|(
expr|struct
name|mips_pending
operator|*
operator|)
name|NULL
condition|)
block|{
name|t
operator|=
name|new_type
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_pending
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|pend
operator|->
name|t
expr_stmt|;
comment|/* Alpha cc unnamed structs do not get a tag name.  */
if|if
condition|(
name|sh
operator|->
name|iss
operator|==
literal|0
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
else|else
name|TYPE_TAG_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|=
name|type_code
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|f
operator|=
operator|(
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|t
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|type_code
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
comment|/* This is a non-empty enum. */
for|for
control|(
name|ext_tsym
operator|=
name|ext_sh
operator|+
name|external_sym_size
init|;
condition|;
name|ext_tsym
operator|+=
name|external_sym_size
control|)
block|{
name|SYMR
name|tsym
decl_stmt|;
name|struct
name|symbol
modifier|*
name|enum_sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_tsym
argument_list|,
operator|&
name|tsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsym
operator|.
name|st
operator|!=
name|stMember
condition|)
break|break;
name|f
operator|->
name|bitpos
operator|=
name|tsym
operator|.
name|value
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|f
operator|->
name|name
operator|=
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|tsym
operator|.
name|iss
operator|)
expr_stmt|;
name|f
operator|->
name|bitsize
operator|=
literal|0
expr_stmt|;
name|enum_sym
operator|=
operator|(
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|enum_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|f
operator|->
name|name
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|t
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|tsym
operator|.
name|value
expr_stmt|;
name|add_symbol
argument_list|(
name|enum_sym
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Skip the stMembers that we've handled. */
name|count
operator|++
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
block|}
comment|/* make this the current type */
name|top_stack
operator|->
name|cur_type
operator|=
name|t
expr_stmt|;
name|top_stack
operator|->
name|cur_field
operator|=
literal|0
expr_stmt|;
comment|/* Do not create a symbol for alpha cc unnamed structs.  */
if|if
condition|(
name|sh
operator|->
name|iss
operator|==
literal|0
condition|)
break|break;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* gcc puts out an empty struct for an opaque struct definitions.  */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
block|}
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
break|break;
comment|/* End of local variables shared by struct, union, enum, and 	   block (as yet unknown struct/union/enum) processing.  */
block|}
name|case_stBlock_code
label|:
comment|/* beginnning of (code) block. Value of symbol 	 is the displacement from procedure start */
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stBlock
expr_stmt|;
name|b
operator|=
name|new_block
argument_list|(
name|top_stack
operator|->
name|maxsyms
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|sh
operator|->
name|value
operator|+
name|top_stack
operator|->
name|procadr
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|b
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
break|break;
case|case
name|stEnd
case|:
comment|/* end (of anything) */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scInfo
operator|||
name|sh
operator|->
name|sc
operator|==
name|scCommon
condition|)
block|{
comment|/* Finished with type */
name|top_stack
operator|->
name|cur_type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
operator|(
name|top_stack
operator|->
name|blocktype
operator|==
name|stProc
operator|||
name|top_stack
operator|->
name|blocktype
operator|==
name|stStaticProc
operator|)
condition|)
block|{
comment|/* Finished with procedure */
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
decl_stmt|;
name|struct
name|mips_extra_func_info
modifier|*
name|e
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BLOCK_END
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|+=
name|sh
operator|->
name|value
expr_stmt|;
comment|/* size */
comment|/* Make up special symbol to contain procedure specific info */
name|s
operator|=
name|new_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|builtin_type_void
expr_stmt|;
name|e
operator|=
operator|(
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|long
operator|)
name|e
expr_stmt|;
name|e
operator|->
name|numargs
operator|=
name|top_stack
operator|->
name|numargs
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Reallocate symbols, saving memory */
name|b
operator|=
name|shrink_block
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
comment|/* f77 emits proc-level with address bounds==[0,0], 	     So look for such child blocks, and patch them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|block
modifier|*
name|b_bad
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|b_bad
argument_list|)
operator|==
name|b
operator|&&
name|BLOCK_START
argument_list|(
name|b_bad
argument_list|)
operator|==
name|top_stack
operator|->
name|procadr
operator|&&
name|BLOCK_END
argument_list|(
name|b_bad
argument_list|)
operator|==
name|top_stack
operator|->
name|procadr
condition|)
block|{
name|BLOCK_START
argument_list|(
name|b_bad
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b_bad
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
name|top_stack
operator|->
name|blocktype
operator|==
name|stBlock
condition|)
block|{
comment|/* End of (code) block. The value of the symbol is the 	     displacement from the procedure`s start address of the 	     end of this block. */
name|BLOCK_END
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|=
name|sh
operator|->
name|value
operator|+
name|top_stack
operator|->
name|procadr
expr_stmt|;
name|shrink_block
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
name|top_stack
operator|->
name|blocktype
operator|==
name|stFile
condition|)
block|{
comment|/* End of file.  Pop parse stack and ignore.  Higher 	     level code deals with this.  */
empty_stmt|;
block|}
else|else
name|complain
argument_list|(
operator|&
name|stEnd_complaint
argument_list|,
name|sh
operator|->
name|sc
argument_list|)
expr_stmt|;
name|pop_parse_stack
argument_list|()
expr_stmt|;
comment|/* restore previous lexical context */
break|break;
case|case
name|stMember
case|:
comment|/* member of struct or union */
name|f
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|top_stack
operator|->
name|cur_type
argument_list|)
index|[
name|top_stack
operator|->
name|cur_field
operator|++
index|]
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|f
operator|->
name|bitpos
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|bitsize
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
operator|&
name|bitsize
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|f
operator|->
name|bitsize
operator|=
name|bitsize
expr_stmt|;
break|break;
case|case
name|stTypedef
case|:
comment|/* type definition */
comment|/* Typedefs for forward declarations and opaque structs from alpha cc 	 are handled by cross_ref, skip them.  */
if|if
condition|(
name|sh
operator|->
name|iss
operator|==
literal|0
condition|)
break|break;
comment|/* Parse the type or use the pending type.  */
name|pend
operator|=
name|is_pending_symbol
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|==
operator|(
expr|struct
name|mips_pending
operator|*
operator|)
name|NULL
condition|)
block|{
name|t
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_pending
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|pend
operator|->
name|t
expr_stmt|;
comment|/* mips cc puts out a typedef with the name of the struct for forward 	 declarations. These should not go into the symbol table and 	 TYPE_NAME should not be set for them. 	 They can't be distinguished from an intentional typedef to 	 the same name however: 	 x.h: 		struct x { int ix; int jx; }; 		struct xx; 	 x.c: 		typedef struct x x; 		struct xx {int ixx; int jxx; }; 	 generates a cross referencing stTypedef for x and xx. 	 The user visible effect of this is that the type of a pointer 	 to struct foo sometimes is given as `foo *' instead of `struct foo *'. 	 The problem is fixed with alpha cc.  */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Incomplete definitions of structs should not get a name.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|TYPE_NFIELDS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNION
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* If we are giving a name to a type such as "pointer to 		 foo" or "function returning foo", we better not set 		 the TYPE_NAME.  If the program contains "typedef char 		 *caddr_t;", we don't want all variables of type char 		 * to print as caddr_t.  This is not just a 		 consequence of GDB's type management; CC and GCC (at 		 least through version 2.4) both output variables of 		 either type char * or caddr_t with the type 		 refering to the stTypedef symbol for caddr_t.  If a future 		 compiler cleans this up it GDB is not ready for it 		 yet, but if it becomes ready we somehow need to 		 disable this check (without breaking the PCC/GCC2.4 		 case).  		 Sigh.  		 Fortunately, this check seems not to be necessary 		 for anything except pointers or functions.  */
block|}
else|else
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|stFile
case|:
comment|/* file name */
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|sh
operator|->
name|st
expr_stmt|;
break|break;
comment|/* I`ve never seen these for C */
case|case
name|stRegReloc
case|:
break|break;
comment|/* register relocation */
case|case
name|stForward
case|:
break|break;
comment|/* forwarding address */
case|case
name|stConstant
case|:
break|break;
comment|/* constant */
default|default:
name|complain
argument_list|(
operator|&
name|unknown_mips_symtype_complaint
argument_list|,
name|sh
operator|->
name|st
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Parse the type information provided in the raw AX entries for    the symbol SH. Return the bitfield size in BS, in case.    We must byte-swap the AX entries before we use them; BIGEND says whether    they are big-endian or little-endian (from fh->fBigendian).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|parse_type
parameter_list|(
name|fd
parameter_list|,
name|ax
parameter_list|,
name|aux_index
parameter_list|,
name|bs
parameter_list|,
name|bigend
parameter_list|,
name|sym_name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|unsigned
name|int
name|aux_index
decl_stmt|;
name|int
modifier|*
name|bs
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
comment|/* Null entries in this map are treated specially */
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|map_bt
index|[]
init|=
block|{
operator|&
name|builtin_type_void
block|,
comment|/* btNil */
literal|0
block|,
comment|/* btAdr */
operator|&
name|builtin_type_char
block|,
comment|/* btChar */
operator|&
name|builtin_type_unsigned_char
block|,
comment|/* btUChar */
operator|&
name|builtin_type_short
block|,
comment|/* btShort */
operator|&
name|builtin_type_unsigned_short
block|,
comment|/* btUShort */
operator|&
name|builtin_type_int
block|,
comment|/* btInt */
operator|&
name|builtin_type_unsigned_int
block|,
comment|/* btUInt */
operator|&
name|builtin_type_long
block|,
comment|/* btLong */
operator|&
name|builtin_type_unsigned_long
block|,
comment|/* btULong */
operator|&
name|builtin_type_float
block|,
comment|/* btFloat */
operator|&
name|builtin_type_double
block|,
comment|/* btDouble */
literal|0
block|,
comment|/* btStruct */
literal|0
block|,
comment|/* btUnion */
literal|0
block|,
comment|/* btEnum */
literal|0
block|,
comment|/* btTypedef */
literal|0
block|,
comment|/* btRange */
literal|0
block|,
comment|/* btSet */
operator|&
name|builtin_type_complex
block|,
comment|/* btComplex */
operator|&
name|builtin_type_double_complex
block|,
comment|/* btDComplex */
literal|0
block|,
comment|/* btIndirect */
operator|&
name|builtin_type_fixed_dec
block|,
comment|/* btFixedDec */
operator|&
name|builtin_type_float_dec
block|,
comment|/* btFloatDec */
operator|&
name|builtin_type_string
block|,
comment|/* btString */
literal|0
block|,
comment|/* btBit */
literal|0
block|,
comment|/* btPicture */
operator|&
name|builtin_type_void
block|,
comment|/* btVoid */
literal|0
block|,
comment|/* DEC C++:  Pointer to member */
literal|0
block|,
comment|/* DEC C++:  Virtual function table */
literal|0
block|,
comment|/* DEC C++:  Class (Record) */
operator|&
name|builtin_type_long
block|,
comment|/* btLong64  */
operator|&
name|builtin_type_unsigned_long
block|,
comment|/* btULong64 */
operator|&
name|builtin_type_long_long
block|,
comment|/* btLongLong64  */
operator|&
name|builtin_type_unsigned_long_long
block|,
comment|/* btULongLong64 */
operator|&
name|builtin_type_unsigned_long
block|,
comment|/* btAdr64 */
operator|&
name|builtin_type_long
block|,
comment|/* btInt64  */
operator|&
name|builtin_type_unsigned_long
block|,
comment|/* btUInt64 */
block|}
decl_stmt|;
name|TIR
name|t
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|tp
init|=
literal|0
decl_stmt|;
name|enum
name|type_code
name|type_code
init|=
name|TYPE_CODE_UNDEF
decl_stmt|;
comment|/* Handle corrupt aux indices.  */
if|if
condition|(
name|aux_index
operator|>=
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
operator|+
name|fd
operator|)
operator|->
name|caux
condition|)
block|{
name|complain
argument_list|(
operator|&
name|index_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|builtin_type_int
return|;
block|}
name|ax
operator|+=
name|aux_index
expr_stmt|;
comment|/* Use aux as a type information record, map its basic type.  */
name|ecoff_swap_tir_in
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_ti
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|map_bt
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|map_bt
argument_list|)
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|basic_type_complaint
argument_list|,
name|t
operator|->
name|bt
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|builtin_type_int
return|;
block|}
if|if
condition|(
name|map_bt
index|[
name|t
operator|->
name|bt
index|]
condition|)
block|{
name|tp
operator|=
operator|*
name|map_bt
index|[
name|t
operator|->
name|bt
index|]
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|NULL
expr_stmt|;
comment|/* Cannot use builtin types -- build our own */
switch|switch
condition|(
name|t
operator|->
name|bt
condition|)
block|{
case|case
name|btAdr
case|:
name|tp
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
break|break;
case|case
name|btStruct
case|:
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
name|btUnion
case|:
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
name|btEnum
case|:
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
break|break;
case|case
name|btRange
case|:
name|type_code
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
break|break;
case|case
name|btSet
case|:
name|type_code
operator|=
name|TYPE_CODE_SET
expr_stmt|;
break|break;
case|case
name|btTypedef
case|:
comment|/* alpha cc uses this for typedefs. The true type will be 	     obtained by crossreferencing below.  */
name|type_code
operator|=
name|TYPE_CODE_ERROR
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|basic_type_complaint
argument_list|,
name|t
operator|->
name|bt
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|builtin_type_int
return|;
block|}
block|}
comment|/* Move on to next aux */
name|ax
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fBitfield
condition|)
block|{
comment|/* Inhibit core dumps with some cfront generated objects that 	 corrupt the TIR.  */
if|if
condition|(
name|bs
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_fbitfield_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|builtin_type_int
return|;
block|}
operator|*
name|bs
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
comment|/* All these types really point to some (common) MIPS type      definition, and only the type-qualifiers fully identify      them.  We'll make the same effort at sharing. */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btStruct
operator|||
name|t
operator|->
name|bt
operator|==
name|btUnion
operator|||
name|t
operator|->
name|bt
operator|==
name|btEnum
operator|||
comment|/* btSet (I think) implies that the name is a tag name, not a typedef 	 name.  This apparently is a MIPS extension for C sets.  */
name|t
operator|->
name|bt
operator|==
name|btSet
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to cross reference this type, build new type on failure.  */
name|ax
operator|+=
name|cross_ref
argument_list|(
name|fd
argument_list|,
name|ax
argument_list|,
operator|&
name|tp
argument_list|,
name|type_code
argument_list|,
operator|&
name|name
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
name|tp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
comment|/* Make sure that TYPE_CODE(tp) has an expected type code. 	 Any type may be returned from cross_ref if file indirect entries 	 are corrupted.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_UNION
operator|&&
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unexpected_type_code_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Usually, TYPE_CODE(tp) is already type_code.  The main 	     exception is if we guessed wrong re struct/union/enum. 	     But for struct vs. union a wrong guess is harmless, so 	     don't complain().  */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
name|type_code
operator|!=
name|TYPE_CODE_ENUM
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
operator|&&
name|type_code
operator|==
name|TYPE_CODE_ENUM
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_tag_guess_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|type_code
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|=
name|type_code
expr_stmt|;
block|}
comment|/* Do not set the tag name if it is a compiler generated tag name 	      (.Fxx or .xxfake or empty) for unnamed struct/union/enums.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All these types really point to some (common) MIPS type      definition, and only the type-qualifiers fully identify      them.  We'll make the same effort at sharing.      FIXME: btIndirect cannot happen here as it is handled by the      switch t->bt above.  And we are not doing any guessing on range types.  */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btIndirect
operator|||
name|t
operator|->
name|bt
operator|==
name|btRange
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to cross reference this type, build new type on failure.  */
name|ax
operator|+=
name|cross_ref
argument_list|(
name|fd
argument_list|,
name|ax
argument_list|,
operator|&
name|tp
argument_list|,
name|type_code
argument_list|,
operator|&
name|name
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
name|tp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
comment|/* Make sure that TYPE_CODE(tp) has an expected type code. 	 Any type may be returned from cross_ref if file indirect entries 	 are corrupted.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unexpected_type_code_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Usually, TYPE_CODE(tp) is already type_code.  The main 	     exception is if we guessed wrong re struct/union/enum. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|type_code
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_tag_guess_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|=
name|type_code
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btTypedef
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to cross reference this type, it should succeed.  */
name|ax
operator|+=
name|cross_ref
argument_list|(
name|fd
argument_list|,
name|ax
argument_list|,
operator|&
name|tp
argument_list|,
name|type_code
argument_list|,
operator|&
name|name
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unable_to_cross_ref_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|tp
operator|=
name|builtin_type_int
expr_stmt|;
block|}
block|}
comment|/* Deal with range types */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btRange
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|tp
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|tp
argument_list|)
operator|=
operator|(
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|tp
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"Low"
argument_list|,
name|strlen
argument_list|(
literal|"Low"
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
operator|=
name|AUX_GET_DNLOW
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"High"
argument_list|,
name|strlen
argument_list|(
literal|"High"
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|AUX_GET_DNHIGH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
comment|/* Parse all the type qualifiers now. If there are more      than 6 the game will continue in the next aux */
while|while
condition|(
literal|1
condition|)
block|{
define|#
directive|define
name|PARSE_TQ
parameter_list|(
name|tq
parameter_list|)
define|\
value|if (t->tq != tqNil) \ 	ax += upgrade_type(fd,&tp, t->tq, ax, bigend, sym_name); \       else \ 	break;
name|PARSE_TQ
argument_list|(
name|tq0
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq1
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq2
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq3
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq4
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq5
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PARSE_TQ
comment|/* mips cc 2.x and gcc never put out continued aux entries.  */
if|if
condition|(
operator|!
name|t
operator|->
name|continued
condition|)
break|break;
name|ecoff_swap_tir_in
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_ti
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
comment|/* Complain for illegal continuations due to corrupt aux entries.  */
if|if
condition|(
name|t
operator|->
name|continued
condition|)
name|complain
argument_list|(
operator|&
name|bad_continued_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* Make up a complex type from a basic one.  Type is passed by    reference in TPP and side-effected as necessary. The type    qualifier TQ says how to handle the aux symbols at AX for    the symbol SX we are currently analyzing.  BIGEND says whether    aux symbols are big-endian or little-endian.    Returns the number of aux symbols we parsed. */
end_comment

begin_function
specifier|static
name|int
name|upgrade_type
parameter_list|(
name|fd
parameter_list|,
name|tpp
parameter_list|,
name|tq
parameter_list|,
name|ax
parameter_list|,
name|bigend
parameter_list|,
name|sym_name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|tpp
decl_stmt|;
name|int
name|tq
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
name|int
name|off
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
comment|/* Used in array processing */
name|int
name|rf
decl_stmt|,
name|id
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|struct
name|type
modifier|*
name|range
decl_stmt|;
name|struct
name|type
modifier|*
name|indx
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|RNDXR
name|rndx
decl_stmt|;
switch|switch
condition|(
name|tq
condition|)
block|{
case|case
name|tqPtr
case|:
name|t
operator|=
name|lookup_pointer_type
argument_list|(
operator|*
name|tpp
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|t
expr_stmt|;
return|return
literal|0
return|;
case|case
name|tqProc
case|:
name|t
operator|=
name|lookup_function_type
argument_list|(
operator|*
name|tpp
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|t
expr_stmt|;
return|return
literal|0
return|;
case|case
name|tqArray
case|:
name|off
operator|=
literal|0
expr_stmt|;
comment|/* Determine and record the domain type (type of index) */
name|ecoff_swap_rndx_in
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|id
operator|=
name|rndx
operator|.
name|index
expr_stmt|;
name|rf
operator|=
name|rndx
operator|.
name|rfd
expr_stmt|;
if|if
condition|(
name|rf
operator|==
literal|0xfff
condition|)
block|{
name|ax
operator|++
expr_stmt|;
name|rf
operator|=
name|AUX_GET_ISYM
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
name|fh
operator|=
name|get_rfd
argument_list|(
name|fd
argument_list|,
name|rf
argument_list|)
expr_stmt|;
name|indx
operator|=
name|parse_type
argument_list|(
name|fd
argument_list|,
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
argument_list|,
name|id
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
comment|/* The bounds type should be an integer type, but might be anything 	 else due to corrupt aux entries.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
block|{
name|complain
argument_list|(
operator|&
name|array_index_type_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|indx
operator|=
name|builtin_type_int
expr_stmt|;
block|}
comment|/* Get the bounds, and create the array type.  */
name|ax
operator|++
expr_stmt|;
name|lower
operator|=
name|AUX_GET_DNLOW
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
name|upper
operator|=
name|AUX_GET_DNHIGH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
name|rf
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
comment|/* bit size of array element */
name|range
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|indx
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|t
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
operator|*
name|tpp
argument_list|,
name|range
argument_list|)
expr_stmt|;
comment|/* We used to fill in the supplied array element bitsize 	 here if the TYPE_LENGTH of the target type was zero. 	 This happens for a `pointer to an array of anonymous structs', 	 but in this case the array element bitsize is also zero, 	 so nothing is gained. 	 And we used to check the TYPE_LENGTH of the target type against 	 the supplied array element bitsize. 	 gcc causes a mismatch for `pointer to array of object', 	 since the sdb directives it uses do not have a way of 	 specifying the bitsize, but it does no harm (the 	 TYPE_LENGTH should be correct) and we should be able to 	 ignore the erroneous bitsize from the auxiliary entry safely. 	 dbx seems to ignore it too.  */
operator|*
name|tpp
operator|=
name|t
expr_stmt|;
return|return
literal|4
operator|+
name|off
return|;
case|case
name|tqVol
case|:
comment|/* Volatile -- currently ignored */
return|return
literal|0
return|;
case|case
name|tqConst
case|:
comment|/* Const -- currently ignored */
return|return
literal|0
return|;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_type_qual_complaint
argument_list|,
name|tq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a procedure descriptor record PR.  Note that the procedure is    parsed _after_ the local symbols, now we just insert the extra    information we need into a MIPS_EFI_SYMBOL_NAME symbol that has    already been placed in the procedure's main block.  Note also that    images that have been partially stripped (ld -x) have been deprived    of local symbols, and we have to cope with them here.  FIRST_OFF is    the offset of the first procedure for this FDR; we adjust the    address by this amount, but I don't know why.  SEARCH_SYMTAB is the symtab    to look for the function which contains the MIPS_EFI_SYMBOL_NAME symbol    in question, or NULL to use top_stack->cur_block.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_procedure
name|PARAMS
argument_list|(
operator|(
name|PDR
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_procedure
parameter_list|(
name|pr
parameter_list|,
name|search_symtab
parameter_list|,
name|first_off
parameter_list|)
name|PDR
modifier|*
name|pr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|search_symtab
decl_stmt|;
name|unsigned
name|long
name|first_off
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|s
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|mips_extra_func_info
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|sh_name
decl_stmt|;
comment|/* Simple rule to find files linked "-x" */
if|if
condition|(
name|cur_fdr
operator|->
name|rss
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pr
operator|->
name|isym
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Static procedure at address pr->adr.  Sigh. */
name|complain
argument_list|(
operator|&
name|pdr_static_symbol_complaint
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pr
operator|->
name|adr
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* external */
name|EXTR
name|she
decl_stmt|;
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_ext_in
operator|)
operator|(
name|cur_bfd
operator|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_ext
operator|+
name|pr
operator|->
name|isym
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_ext_size
operator|)
operator|,
operator|&
name|she
operator|)
expr_stmt|;
name|sh_name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|she
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Full symbols */
name|SYMR
name|sh
decl_stmt|;
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_sym_in
operator|)
operator|(
name|cur_bfd
operator|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|cur_fdr
operator|->
name|isymBase
operator|+
name|pr
operator|->
name|isym
operator|)
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym_size
operator|)
operator|)
operator|,
operator|&
name|sh
operator|)
expr_stmt|;
name|sh_name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
block|}
if|if
condition|(
name|search_symtab
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This loses both in the case mentioned (want a static, find a global), 	 but also if we are looking up a non-mangled name which happens to 	 match the name of a mangled function.  */
comment|/* We have to save the cur_fdr across the call to lookup_symbol. 	 If the pdr is for a static function and if a global function with 	 the same name exists, lookup_symbol will eventually read in the symtab 	 for the global function and clobber cur_fdr.  */
block|FDR *save_cur_fdr = cur_fdr;       s = lookup_symbol (sh_name, NULL, VAR_NAMESPACE, 0, NULL);       cur_fdr = save_cur_fdr;
else|#
directive|else
name|s
operator|=
name|mylookup_symbol
argument_list|(
name|sh_name
argument_list|,
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|search_symtab
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|s
operator|=
name|mylookup_symbol
argument_list|(
name|sh_name
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|pdr_for_nonsymbol_complaint
argument_list|,
name|sh_name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return;
else|#
directive|else
comment|/* FIXME -- delete.  We can't do symbol allocation now; it's all done.  */
name|s
operator|=
name|new_symbol
argument_list|(
name|sh_name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
comment|/* Donno its type, hope int is ok */
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Wont have symbols for this one */
name|b
operator|=
name|new_block
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|b
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|=
name|s
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|pr
operator|->
name|adr
expr_stmt|;
comment|/* BOUND used to be the end of procedure's text, but the 	 argument is no longer passed in.  */
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|bound
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|i
operator|=
name|mylookup_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|,
name|b
argument_list|,
name|LABEL_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|e
operator|=
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|=
operator|*
name|pr
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|isym
operator|=
operator|(
name|long
operator|)
name|s
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|adr
operator|+=
name|cur_fdr
operator|->
name|adr
operator|-
name|first_off
expr_stmt|;
comment|/* Correct incorrect setjmp procedure descriptor from the library 	 to make backtrace through setjmp work.  */
if|if
condition|(
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|==
literal|0
operator|&&
name|STREQ
argument_list|(
name|sh_name
argument_list|,
literal|"setjmp"
argument_list|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_setjmp_pdr_complaint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|=
name|RA_REGNUM
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regmask
operator|=
literal|0x80000000
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regoffset
operator|=
operator|-
literal|4
expr_stmt|;
block|}
comment|/* Fake PC_REGNUM for alpha __sigtramp so that read_next_frame_reg 	 will use the saved user pc from the sigcontext.  */
if|if
condition|(
name|STREQ
argument_list|(
name|sh_name
argument_list|,
literal|"__sigtramp"
argument_list|)
condition|)
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|=
name|PC_REGNUM
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the external symbol ES. Just call parse_symbol() after    making sure we know where the aux are for it. For procedures,    parsing of the PDRs has already provided all the needed    information, we only parse them if SKIP_PROCEDURES is false,    and only if this causes no symbol duplication.    BIGEND says whether aux entries are big-endian or little-endian.     This routine clobbers top_stack->cur_block and ->cur_st. */
end_comment

begin_function
specifier|static
name|void
name|parse_external
parameter_list|(
name|es
parameter_list|,
name|skip_procedures
parameter_list|,
name|bigend
parameter_list|)
name|EXTR
modifier|*
name|es
decl_stmt|;
name|int
name|skip_procedures
decl_stmt|;
name|int
name|bigend
decl_stmt|;
block|{
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
if|if
condition|(
name|es
operator|->
name|ifd
operator|!=
name|ifdNil
condition|)
block|{
name|cur_fd
operator|=
name|es
operator|->
name|ifd
expr_stmt|;
name|cur_fdr
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
operator|+
name|cur_fd
expr_stmt|;
name|ax
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|cur_fdr
operator|->
name|iauxBase
expr_stmt|;
block|}
else|else
block|{
name|cur_fdr
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|ax
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Reading .o files */
if|if
condition|(
name|es
operator|->
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|es
operator|->
name|asym
operator|.
name|sc
operator|==
name|scNil
condition|)
block|{
name|char
modifier|*
name|what
decl_stmt|;
switch|switch
condition|(
name|es
operator|->
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stNil
case|:
comment|/* These are generated for static symbols in .o files, 	     ignore them.  */
return|return;
case|case
name|stStaticProc
case|:
case|case
name|stProc
case|:
name|what
operator|=
literal|"procedure"
expr_stmt|;
name|n_undef_procs
operator|++
expr_stmt|;
break|break;
case|case
name|stGlobal
case|:
name|what
operator|=
literal|"variable"
expr_stmt|;
name|n_undef_vars
operator|++
expr_stmt|;
break|break;
case|case
name|stLabel
case|:
name|what
operator|=
literal|"label"
expr_stmt|;
name|n_undef_labels
operator|++
expr_stmt|;
break|break;
default|default:
name|what
operator|=
literal|"symbol"
expr_stmt|;
break|break;
block|}
name|n_undef_symbols
operator|++
expr_stmt|;
comment|/* FIXME:  Turn this into a complaint? */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Warning: %s `%s' is undefined (in %s)\n"
argument_list|,
name|what
argument_list|,
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|es
operator|->
name|asym
operator|.
name|iss
argument_list|,
name|fdr_name
argument_list|(
name|cur_fdr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|es
operator|->
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stProc
case|:
comment|/* If we have full symbols we do not need more */
if|if
condition|(
name|skip_procedures
condition|)
return|return;
if|if
condition|(
name|mylookup_symbol
argument_list|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|es
operator|->
name|asym
operator|.
name|iss
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|)
condition|)
break|break;
comment|/* fall through */
case|case
name|stGlobal
case|:
case|case
name|stLabel
case|:
comment|/* Note that the case of a symbol with indexNil must be handled 	 anyways by parse_symbol().  */
name|parse_symbol
argument_list|(
operator|&
name|es
operator|->
name|asym
argument_list|,
name|ax
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|bigend
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse the line number info for file descriptor FH into    GDB's linetable LT.  MIPS' encoding requires a little bit    of magic to get things out.  Note also that MIPS' line    numbers can go back and forth, apparently we can live    with that and do not need to reorder our linetables */
end_comment

begin_function
specifier|static
name|void
name|parse_lines
parameter_list|(
name|fh
parameter_list|,
name|pr
parameter_list|,
name|lt
parameter_list|,
name|maxlines
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|PDR
modifier|*
name|pr
decl_stmt|;
name|struct
name|linetable
modifier|*
name|lt
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|count
decl_stmt|,
name|lineno
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|first_off
init|=
name|pr
operator|->
name|adr
decl_stmt|;
if|if
condition|(
name|fh
operator|->
name|cbLine
operator|==
literal|0
condition|)
return|return;
name|base
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|line
operator|+
name|fh
operator|->
name|cbLineOffset
expr_stmt|;
comment|/* Scan by procedure descriptors */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fh
operator|->
name|cpd
condition|;
name|j
operator|++
operator|,
name|pr
operator|++
control|)
block|{
name|long
name|l
decl_stmt|;
name|unsigned
name|long
name|adr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|halt
decl_stmt|;
comment|/* No code for this one */
if|if
condition|(
name|pr
operator|->
name|iline
operator|==
name|ilineNil
operator|||
name|pr
operator|->
name|lnLow
operator|==
operator|-
literal|1
operator|||
name|pr
operator|->
name|lnHigh
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Determine start and end address of compressed line bytes for 	 this procedure.  */
name|base
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|line
operator|+
name|fh
operator|->
name|cbLineOffset
expr_stmt|;
if|if
condition|(
name|j
operator|!=
operator|(
name|fh
operator|->
name|cpd
operator|-
literal|1
operator|)
condition|)
name|halt
operator|=
name|base
operator|+
name|pr
index|[
literal|1
index|]
operator|.
name|cbLineOffset
expr_stmt|;
else|else
name|halt
operator|=
name|base
operator|+
name|fh
operator|->
name|cbLine
expr_stmt|;
name|base
operator|+=
name|pr
operator|->
name|cbLineOffset
expr_stmt|;
name|adr
operator|=
name|fh
operator|->
name|adr
operator|+
name|pr
operator|->
name|adr
operator|-
name|first_off
expr_stmt|;
name|l
operator|=
name|adr
operator|>>
literal|2
expr_stmt|;
comment|/* in words */
for|for
control|(
name|lineno
operator|=
name|pr
operator|->
name|lnLow
init|;
name|base
operator|<
name|halt
condition|;
control|)
block|{
name|count
operator|=
operator|*
name|base
operator|&
literal|0x0f
expr_stmt|;
name|delta
operator|=
operator|*
name|base
operator|++
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|8
condition|)
name|delta
operator|-=
literal|16
expr_stmt|;
if|if
condition|(
name|delta
operator|==
operator|-
literal|8
condition|)
block|{
name|delta
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|base
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0x8000
condition|)
name|delta
operator|-=
literal|0x10000
expr_stmt|;
name|base
operator|+=
literal|2
expr_stmt|;
block|}
name|lineno
operator|+=
name|delta
expr_stmt|;
comment|/* first delta is 0 */
comment|/* Complain if the line table overflows. Could happen 	     with corrupt binaries.  */
if|if
condition|(
name|lt
operator|->
name|nitems
operator|>=
name|maxlines
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_linetable_guess_complaint
argument_list|,
name|fdr_name
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|add_line
argument_list|(
name|lt
argument_list|,
name|lineno
argument_list|,
name|l
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|l
operator|+=
name|count
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Master parsing procedure for first-pass reading of file symbols    into a partial_symtab.  */
end_comment

begin_function
specifier|static
name|void
name|parse_partial_symbols
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|backend
operator|->
name|external_sym_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_rfd_size
init|=
name|backend
operator|->
name|external_rfd_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|backend
operator|->
name|external_ext_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_ext_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_sym_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|RFDT
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_rfd_in
expr_stmt|;
name|int
name|f_idx
decl_stmt|,
name|s_idx
decl_stmt|;
name|HDRR
modifier|*
name|hdr
init|=
operator|&
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|symbolic_header
decl_stmt|;
comment|/* Running pointers */
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|ext_out
decl_stmt|;
name|char
modifier|*
name|ext_out_end
decl_stmt|;
name|EXTR
modifier|*
name|ext_block
decl_stmt|;
specifier|register
name|EXTR
modifier|*
name|ext_in
decl_stmt|;
name|EXTR
modifier|*
name|ext_in_end
decl_stmt|;
name|SYMR
name|sh
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
name|EXTR
modifier|*
name|extern_tab
decl_stmt|;
name|struct
name|pst_map
modifier|*
name|fdr_to_pst
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|language
name|prev_language
decl_stmt|;
name|extern_tab
operator|=
operator|(
name|EXTR
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
operator|*
name|hdr
operator|->
name|iextMax
argument_list|)
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|next_symbol_text_func
operator|=
name|mips_next_symbol_text
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
comment|/*    * Big plan:    *    * Only parse the Local and External symbols, and the Relative FDR.    * Fixup enough of the loader symtab to be able to use it.    * Allocate space only for the file's portions we need to    * look at. (XXX)    */
name|max_gdbinfo
operator|=
literal|0
expr_stmt|;
name|max_glevel
operator|=
name|MIN_GLEVEL
expr_stmt|;
comment|/* Allocate the map FDR -> PST.      Minor hack: -O3 images might claim some global data belongs      to FDR -1. We`ll go along with that */
name|fdr_to_pst
operator|=
operator|(
expr|struct
name|pst_map
operator|*
operator|)
name|xzalloc
argument_list|(
operator|(
name|hdr
operator|->
name|ifdMax
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|fdr_to_pst
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|fdr_to_pst
argument_list|)
expr_stmt|;
name|fdr_to_pst
operator|++
expr_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
init|=
name|new_psymtab
argument_list|(
literal|""
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|fdr_to_pst
index|[
operator|-
literal|1
index|]
operator|.
name|pst
operator|=
name|pst
expr_stmt|;
name|FDR_IDX
argument_list|(
name|pst
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Allocate the global pending list.  */
name|ECOFF_PENDING_LIST
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
operator|(
expr|struct
name|mips_pending
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|hdr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mips_pending
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|ECOFF_PENDING_LIST
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|hdr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mips_pending
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass 0 over external syms: swap them in.  */
name|ext_block
operator|=
operator|(
name|EXTR
operator|*
operator|)
name|xmalloc
argument_list|(
name|hdr
operator|->
name|iextMax
operator|*
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|ext_block
argument_list|)
expr_stmt|;
name|ext_out
operator|=
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_ext
expr_stmt|;
name|ext_out_end
operator|=
name|ext_out
operator|+
name|hdr
operator|->
name|iextMax
operator|*
name|external_ext_size
expr_stmt|;
name|ext_in
operator|=
name|ext_block
expr_stmt|;
for|for
control|(
init|;
name|ext_out
operator|<
name|ext_out_end
condition|;
name|ext_out
operator|+=
name|external_ext_size
operator|,
name|ext_in
operator|++
control|)
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_out
argument_list|,
name|ext_in
argument_list|)
expr_stmt|;
comment|/* Pass 1 over external syms: Presize and partition the list */
name|ext_in
operator|=
name|ext_block
expr_stmt|;
name|ext_in_end
operator|=
name|ext_in
operator|+
name|hdr
operator|->
name|iextMax
expr_stmt|;
for|for
control|(
init|;
name|ext_in
operator|<
name|ext_in_end
condition|;
name|ext_in
operator|++
control|)
name|fdr_to_pst
index|[
name|ext_in
operator|->
name|ifd
index|]
operator|.
name|n_globals
operator|++
expr_stmt|;
comment|/* Pass 1.5 over files:  partition out global symbol space */
name|s_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f_idx
operator|=
operator|-
literal|1
init|;
name|f_idx
operator|<
name|hdr
operator|->
name|ifdMax
condition|;
name|f_idx
operator|++
control|)
block|{
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|globals_offset
operator|=
name|s_idx
expr_stmt|;
name|s_idx
operator|+=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|n_globals
expr_stmt|;
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|n_globals
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pass 2 over external syms: fill in external symbols */
name|ext_in
operator|=
name|ext_block
expr_stmt|;
name|ext_in_end
operator|=
name|ext_in
operator|+
name|hdr
operator|->
name|iextMax
expr_stmt|;
for|for
control|(
init|;
name|ext_in
operator|<
name|ext_in_end
condition|;
name|ext_in
operator|++
control|)
block|{
name|enum
name|minimal_symbol_type
name|ms_type
init|=
name|mst_text
decl_stmt|;
name|extern_tab
index|[
name|fdr_to_pst
index|[
name|ext_in
operator|->
name|ifd
index|]
operator|.
name|globals_offset
operator|+
name|fdr_to_pst
index|[
name|ext_in
operator|->
name|ifd
index|]
operator|.
name|n_globals
operator|++
index|]
operator|=
operator|*
name|ext_in
expr_stmt|;
if|if
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scNil
condition|)
continue|continue;
name|name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|ext_in
operator|->
name|asym
operator|.
name|iss
expr_stmt|;
switch|switch
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stProc
case|:
break|break;
case|case
name|stStaticProc
case|:
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
break|break;
case|case
name|stGlobal
case|:
if|if
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scData
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scSData
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scRData
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
break|break;
case|case
name|stLabel
case|:
if|if
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scAbs
condition|)
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
elseif|else
if|if
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scText
condition|)
name|ms_type
operator|=
name|mst_text
expr_stmt|;
elseif|else
if|if
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scData
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scSData
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scRData
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
break|break;
case|case
name|stLocal
case|:
comment|/* The alpha has the section start addresses in stLocal symbols 	     whose name starts with a `.'. Skip those but complain for all 	     other stLocal symbols.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
comment|/* Fall through.  */
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
name|complain
argument_list|(
operator|&
name|unknown_ext_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|ext_in
operator|->
name|asym
operator|.
name|value
argument_list|,
name|ms_type
argument_list|)
expr_stmt|;
block|}
comment|/* Pass 3 over files, over local syms: fill in static symbols */
for|for
control|(
name|f_idx
operator|=
literal|0
init|;
name|f_idx
operator|<
name|hdr
operator|->
name|ifdMax
condition|;
name|f_idx
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|save_pst
decl_stmt|;
name|EXTR
modifier|*
name|ext_ptr
decl_stmt|;
name|cur_fdr
operator|=
name|fh
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
operator|+
name|f_idx
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|csym
operator|==
literal|0
condition|)
block|{
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|pst
operator|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|fdr_name
argument_list|(
name|fh
argument_list|)
argument_list|,
name|fh
operator|->
name|cpd
condition|?
name|fh
operator|->
name|adr
else|:
literal|0
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|->
name|read_symtab_private
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|pst
operator|->
name|read_symtab_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|save_pst
operator|=
name|pst
expr_stmt|;
name|FDR_IDX
argument_list|(
name|pst
argument_list|)
operator|=
name|f_idx
expr_stmt|;
name|CUR_BFD
argument_list|(
name|pst
argument_list|)
operator|=
name|cur_bfd
expr_stmt|;
comment|/* The way to turn this into a symtab is to call... */
name|pst
operator|->
name|read_symtab
operator|=
name|mipscoff_psymtab_to_symtab
expr_stmt|;
comment|/* Set up language for the pst.          The language from the FDR is used if it is unambigious (e.g. cfront 	 with native cc and g++ will set the language to C). 	 Otherwise we have to deduce the language from the filename. 	 Native ecoff has every header file in a separate FDR, so 	 deduce_language_from_filename will return language_unknown for 	 a header file, which is not what we want. 	 But the FDRs for the header files are after the FDR for the source 	 file, so we can assign the language of the source file to the 	 following header files. Then we save the language in the private 	 pst data so that we can reuse it when building symtabs.  */
name|prev_language
operator|=
name|psymtab_language
expr_stmt|;
switch|switch
condition|(
name|fh
operator|->
name|lang
condition|)
block|{
case|case
name|langCplusplusV2
case|:
name|psymtab_language
operator|=
name|language_cplus
expr_stmt|;
break|break;
default|default:
name|psymtab_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|fdr_name
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|psymtab_language
operator|==
name|language_unknown
condition|)
name|psymtab_language
operator|=
name|prev_language
expr_stmt|;
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|pst_language
operator|=
name|psymtab_language
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* For stabs-in-ecoff files, the second symbol must be @stab. 	 This symbol is emitted by mips-tfile to signal that the 	 current object file uses encapsulated stabs instead of mips 	 ecoff for local symbols.  (It is the second symbol because 	 the first symbol is the stFile used to signal the start of a 	 file). */
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|csym
operator|>=
literal|2
condition|)
block|{
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
argument_list|,
name|stabs_symbol
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|processing_gcc_compilation
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cur_sdx
operator|=
literal|2
init|;
name|cur_sdx
operator|<
name|fh
operator|->
name|csym
condition|;
name|cur_sdx
operator|++
control|)
block|{
name|int
name|type_code
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|type_code
operator|=
name|ECOFF_UNMARK_STAB
argument_list|(
name|sh
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stProc
operator|||
name|sh
operator|.
name|st
operator|==
name|stStaticProc
condition|)
block|{
name|long
name|procaddr
init|=
name|sh
operator|.
name|value
decl_stmt|;
name|long
name|isym
decl_stmt|;
name|isym
operator|=
name|AUX_GET_ISYM
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|)
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|isym
operator|-
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stEnd
condition|)
block|{
name|long
name|high
init|=
name|procaddr
operator|+
name|sh
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|high
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|high
expr_stmt|;
block|}
block|}
continue|continue;
block|}
define|#
directive|define
name|SET_NAMESTRING
parameter_list|()
define|\
value|namestring = ecoff_data (cur_bfd)->ss + fh->issBase + sh.iss
define|#
directive|define
name|CUR_SYMBOL_TYPE
value|type_code
define|#
directive|define
name|CUR_SYMBOL_VALUE
value|sh.value
define|#
directive|define
name|START_PSYMTAB
parameter_list|(
name|ofile
parameter_list|,
name|secoff
parameter_list|,
name|fname
parameter_list|,
name|low
parameter_list|,
name|symoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
define|\
value|pst = save_pst
define|#
directive|define
name|END_PSYMTAB
parameter_list|(
name|pst
parameter_list|,
name|ilist
parameter_list|,
name|ninc
parameter_list|,
name|c_off
parameter_list|,
name|c_text
parameter_list|,
name|dep_list
parameter_list|,
name|n_deps
parameter_list|)
value|(void)0
define|#
directive|define
name|HANDLE_RBRAC
parameter_list|(
name|val
parameter_list|)
define|\
value|if ((val)> save_pst->texthigh) save_pst->texthigh = (val);
include|#
directive|include
file|"partial-stab.h"
block|}
block|}
else|else
block|{
for|for
control|(
name|cur_sdx
operator|=
literal|0
init|;
name|cur_sdx
operator|<
name|fh
operator|->
name|csym
condition|;
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sh
argument_list|)
condition|)
block|{
name|cur_sdx
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Non absolute static symbols go into the minimal table.  */
if|if
condition|(
name|sh
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|sh
operator|.
name|sc
operator|==
name|scNil
operator|||
operator|(
name|sh
operator|.
name|index
operator|==
name|indexNil
operator|&&
operator|(
name|sh
operator|.
name|st
operator|!=
name|stStatic
operator|||
name|sh
operator|.
name|sc
operator|==
name|scAbs
operator|)
operator|)
condition|)
block|{
comment|/* FIXME, premature? */
name|cur_sdx
operator|++
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
switch|switch
condition|(
name|sh
operator|.
name|st
condition|)
block|{
name|long
name|high
decl_stmt|;
name|long
name|procaddr
decl_stmt|;
name|int
name|new_sdx
decl_stmt|;
case|case
name|stStaticProc
case|:
comment|/* Function */
comment|/* I believe this is used only for file-local functions. 		     The comment in symconst.h ("load time only static procs") 		     isn't particularly clear on this point.  */
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_text
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|stProc
case|:
comment|/* Asm labels apparently */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Skip over procedure to next one. */
if|if
condition|(
name|sh
operator|.
name|index
operator|>=
name|hdr
operator|->
name|iauxMax
condition|)
block|{
comment|/* Should not happen, but does when cross-compiling 			   with the MIPS compiler.  FIXME -- pull later.  */
name|complain
argument_list|(
operator|&
name|index_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_sdx
operator|=
name|cur_sdx
operator|+
literal|1
expr_stmt|;
comment|/* Don't skip at all */
block|}
else|else
name|new_sdx
operator|=
name|AUX_GET_ISYM
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
argument_list|)
expr_stmt|;
name|procaddr
operator|=
name|sh
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|new_sdx
operator|<=
name|cur_sdx
condition|)
block|{
comment|/* This should not happen either... FIXME.  */
name|complain
argument_list|(
operator|&
name|aux_index_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_sdx
operator|=
name|cur_sdx
operator|+
literal|1
expr_stmt|;
comment|/* Don't skip backward */
block|}
name|cur_sdx
operator|=
name|new_sdx
expr_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|-
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|!=
name|stEnd
condition|)
continue|continue;
name|high
operator|=
name|procaddr
operator|+
name|sh
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|high
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|high
expr_stmt|;
continue|continue;
case|case
name|stStatic
case|:
comment|/* Variable */
if|if
condition|(
name|sh
operator|.
name|sc
operator|==
name|scData
operator|||
name|sh
operator|.
name|sc
operator|==
name|scSData
operator|||
name|sh
operator|.
name|sc
operator|==
name|scRData
condition|)
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_data
argument_list|)
expr_stmt|;
else|else
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_bss
argument_list|)
expr_stmt|;
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
break|break;
case|case
name|stTypedef
case|:
comment|/* Typedef */
name|class
operator|=
name|LOC_TYPEDEF
expr_stmt|;
break|break;
case|case
name|stConstant
case|:
comment|/* Constant decl */
name|class
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
case|case
name|stUnion
case|:
case|case
name|stStruct
case|:
case|case
name|stEnum
case|:
case|case
name|stBlock
case|:
comment|/* { }, str, un, enum*/
if|if
condition|(
name|sh
operator|.
name|sc
operator|==
name|scInfo
operator|||
name|sh
operator|.
name|sc
operator|==
name|scCommon
condition|)
block|{
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Skip over the block */
name|new_sdx
operator|=
name|sh
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|new_sdx
operator|<=
name|cur_sdx
condition|)
block|{
comment|/* This happens with the Ultrix kernel. */
name|complain
argument_list|(
operator|&
name|block_index_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_sdx
operator|=
name|cur_sdx
operator|+
literal|1
expr_stmt|;
comment|/* Don't skip backward */
block|}
name|cur_sdx
operator|=
name|new_sdx
expr_stmt|;
continue|continue;
case|case
name|stFile
case|:
comment|/* File headers */
case|case
name|stLabel
case|:
comment|/* Labels */
case|case
name|stEnd
case|:
comment|/* Ends of files */
goto|goto
name|skip
goto|;
case|case
name|stLocal
case|:
comment|/* Local variables */
comment|/* Normally these are skipped because we skip over 		     all blocks we see.  However, these can occur 		     as visible symbols in a .h file that contains code. */
goto|goto
name|skip
goto|;
default|default:
comment|/* Both complaints are valid:  one gives symbol name, 		     the other the offending symbol type.  */
name|complain
argument_list|(
operator|&
name|unknown_sym_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|complain
argument_list|(
operator|&
name|unknown_st_complaint
argument_list|,
name|sh
operator|.
name|st
argument_list|)
expr_stmt|;
name|cur_sdx
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Use this gdb symbol */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|class
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|skip
label|:
name|cur_sdx
operator|++
expr_stmt|;
comment|/* Go to next file symbol */
block|}
comment|/* Now do enter the external symbols. */
name|ext_ptr
operator|=
operator|&
name|extern_tab
index|[
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|globals_offset
index|]
expr_stmt|;
name|cur_sdx
operator|=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|n_globals
expr_stmt|;
name|PST_PRIVATE
argument_list|(
name|save_pst
argument_list|)
operator|->
name|extern_count
operator|=
name|cur_sdx
expr_stmt|;
name|PST_PRIVATE
argument_list|(
name|save_pst
argument_list|)
operator|->
name|extern_tab
operator|=
name|ext_ptr
expr_stmt|;
for|for
control|(
init|;
operator|--
name|cur_sdx
operator|>=
literal|0
condition|;
name|ext_ptr
operator|++
control|)
block|{
name|enum
name|address_class
name|class
decl_stmt|;
name|SYMR
modifier|*
name|psh
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|ext_ptr
operator|->
name|ifd
operator|!=
name|f_idx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|psh
operator|=
operator|&
name|ext_ptr
operator|->
name|asym
expr_stmt|;
comment|/* Do not add undefined symbols to the partial symbol table.  */
if|if
condition|(
name|psh
operator|->
name|sc
operator|==
name|scUndefined
operator|||
name|psh
operator|->
name|sc
operator|==
name|scNil
condition|)
continue|continue;
switch|switch
condition|(
name|psh
operator|->
name|st
condition|)
block|{
case|case
name|stNil
case|:
comment|/* These are generated for static symbols in .o files, 		     ignore them.  */
continue|continue;
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
name|class
operator|=
name|LOC_BLOCK
expr_stmt|;
break|break;
case|case
name|stLabel
case|:
name|class
operator|=
name|LOC_LABEL
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_ext_complaint
argument_list|,
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|psh
operator|->
name|iss
argument_list|)
expr_stmt|;
comment|/* Fall through, pretend it's global.  */
case|case
name|stGlobal
case|:
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
break|break;
block|}
name|name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|psh
operator|->
name|iss
expr_stmt|;
name|ADD_PSYMBOL_ADDR_TO_LIST
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|class
argument_list|,
name|objfile
operator|->
name|global_psymbols
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|psh
operator|->
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Link pst to FDR. end_psymtab returns NULL if the psymtab was 	 empty and put on the free list.  */
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
operator|=
name|end_psymtab
argument_list|(
name|save_pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
operator|-
literal|1
argument_list|,
name|save_pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|save_pst
operator|->
name|textlow
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|save_pst
operator|->
name|texthigh
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|save_pst
operator|->
name|textlow
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|save_pst
operator|->
name|texthigh
expr_stmt|;
block|}
block|}
comment|/* Now scan the FDRs for dependencies */
for|for
control|(
name|f_idx
operator|=
literal|0
init|;
name|f_idx
operator|<
name|hdr
operator|->
name|ifdMax
condition|;
name|f_idx
operator|++
control|)
block|{
name|fh
operator|=
name|f_idx
operator|+
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|pst
operator|=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
expr_stmt|;
if|if
condition|(
name|pst
operator|==
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* This should catch stabs-in-ecoff. */
if|if
condition|(
name|fh
operator|->
name|crfd
operator|<=
literal|1
condition|)
continue|continue;
comment|/* Skip the first file indirect entry as it is a self dependency 	 for source files or a reverse .h -> .c dependency for header files.  */
name|pst
operator|->
name|number_of_dependencies
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|dependencies
operator|=
operator|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
operator|(
operator|(
name|fh
operator|->
name|crfd
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|s_idx
operator|=
literal|1
init|;
name|s_idx
operator|<
name|fh
operator|->
name|crfd
condition|;
name|s_idx
operator|++
control|)
block|{
name|RFDT
name|rh
decl_stmt|;
call|(
modifier|*
name|swap_rfd_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_rfd
operator|+
operator|(
name|fh
operator|->
name|rfdBase
operator|+
name|s_idx
operator|)
operator|*
name|external_rfd_size
operator|)
argument_list|,
operator|&
name|rh
argument_list|)
expr_stmt|;
if|if
condition|(
name|rh
operator|<
literal|0
operator|||
name|rh
operator|>=
name|hdr
operator|->
name|ifdMax
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_file_number_complaint
argument_list|,
name|rh
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip self dependencies of header files.  */
if|if
condition|(
name|rh
operator|==
name|f_idx
condition|)
continue|continue;
comment|/* Do not add to dependeny list if psymtab was empty.  */
if|if
condition|(
name|fdr_to_pst
index|[
name|rh
index|]
operator|.
name|pst
operator|==
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|pst
operator|->
name|dependencies
index|[
name|pst
operator|->
name|number_of_dependencies
operator|++
index|]
operator|=
name|fdr_to_pst
index|[
name|rh
index|]
operator|.
name|pst
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mips_next_symbol_text
parameter_list|()
block|{
name|SYMR
name|sh
decl_stmt|;
name|cur_sdx
operator|++
expr_stmt|;
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_sym_in
operator|)
operator|(
name|cur_bfd
operator|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|cur_fdr
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym_size
operator|)
operator|)
operator|,
operator|&
name|sh
operator|)
expr_stmt|;
return|return
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
return|;
block|}
end_function

begin_comment
comment|/* Ancillary function to psymtab_to_symtab().  Does all the work    for turning the partial symtab PST into a symtab, recurring    first on all dependent psymtabs.  The argument FILENAME is    only passed so we can see in debug stack traces what file    is being read.     This function has a split personality, based on whether the    symbol table contains ordinary ecoff symbols, or stabs-in-ecoff.    The flow of control and even the memory allocation differs.  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|,
name|filename
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_pdr_size
init|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_pdr_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_sym_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_pdr_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PDR
operator|*
operator|)
argument_list|)
operator|=
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_pdr_in
expr_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtab
modifier|*
name|st
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|struct
name|linetable
modifier|*
name|lines
decl_stmt|;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
return|return;
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
comment|/* Read in all partial symbtabs on which this one is dependent.      NOTE that we do have circular dependencies, sigh.  We solved      that by setting pst->readin before this point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* We only pass the filename for debug purposes */
name|psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Do nothing if this is a dummy psymtab.  */
if|if
condition|(
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|pst
operator|->
name|texthigh
operator|==
literal|0
condition|)
return|return;
comment|/* Now read the symbols for this symtab */
name|cur_bfd
operator|=
name|CUR_BFD
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|pst
operator|->
name|objfile
expr_stmt|;
name|cur_fd
operator|=
name|FDR_IDX
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|fh
operator|=
operator|(
name|cur_fd
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|FDR
operator|*
operator|)
name|NULL
else|:
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
operator|+
name|cur_fd
expr_stmt|;
name|cur_fdr
operator|=
name|fh
expr_stmt|;
comment|/* See comment in parse_partial_symbols about the @stabs sentinel. */
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fh
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
operator|&&
name|fh
operator|->
name|csym
operator|>=
literal|2
condition|)
block|{
name|SYMR
name|sh
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
argument_list|,
name|stabs_symbol
argument_list|)
condition|)
block|{
comment|/* We indicate that this is a GCC compilation so that certain 	     features will be enabled in stabsread/dbxread.  */
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|processing_gcc_compilation
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|pdr_ptr
decl_stmt|;
name|char
modifier|*
name|pdr_end
decl_stmt|;
name|int
name|first_pdr
decl_stmt|;
name|unsigned
name|long
name|first_off
init|=
literal|0
decl_stmt|;
comment|/* This symbol table contains stabs-in-ecoff entries.  */
comment|/* Parse local symbols first */
if|if
condition|(
name|fh
operator|->
name|csym
operator|<=
literal|2
condition|)
comment|/* FIXME, this blows psymtab->symtab ptr */
block|{
name|current_objfile
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
for|for
control|(
name|cur_sdx
operator|=
literal|2
init|;
name|cur_sdx
operator|<
name|fh
operator|->
name|csym
condition|;
name|cur_sdx
operator|++
control|)
block|{
name|SYMR
name|sh
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|name
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|valu
operator|=
name|sh
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sh
argument_list|)
condition|)
block|{
name|int
name|type_code
init|=
name|ECOFF_UNMARK_STAB
argument_list|(
name|sh
operator|.
name|index
argument_list|)
decl_stmt|;
name|process_one_symbol
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
name|valu
argument_list|,
name|name
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_code
operator|==
name|N_FUN
condition|)
block|{
comment|/* Make up special symbol to contain 		     procedure specific info */
name|struct
name|mips_extra_func_info
modifier|*
name|e
init|=
operator|(
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|s
init|=
name|new_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
decl_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|builtin_type_void
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|long
operator|)
name|e
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|s
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stLabel
operator|&&
name|sh
operator|.
name|index
operator|!=
name|indexNil
condition|)
block|{
comment|/* Handle encoded stab line number. */
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|sh
operator|.
name|index
argument_list|,
name|valu
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stProc
operator|||
name|sh
operator|.
name|st
operator|==
name|stStaticProc
operator|||
name|sh
operator|.
name|st
operator|==
name|stEnd
condition|)
comment|/* These are generated by gcc-2.x, do not complain */
empty_stmt|;
else|else
name|complain
argument_list|(
operator|&
name|stab_unknown_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|end_symtab
argument_list|(
name|pst
operator|->
name|texthigh
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pst
operator|->
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
comment|/* Sort the symbol table now, we are done adding symbols to it. 	 We must do this before parse_procedure calls lookup_symbol.  */
name|sort_symtab_syms
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* This may not be necessary for stabs symtabs.  FIXME.  */
name|sort_blocks
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Fill in procedure info next.  */
name|first_pdr
operator|=
literal|1
expr_stmt|;
name|pdr_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_pdr
operator|+
name|fh
operator|->
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
expr_stmt|;
name|pdr_end
operator|=
name|pdr_ptr
operator|+
name|fh
operator|->
name|cpd
operator|*
name|external_pdr_size
expr_stmt|;
for|for
control|(
init|;
name|pdr_ptr
operator|<
name|pdr_end
condition|;
name|pdr_ptr
operator|+=
name|external_pdr_size
control|)
block|{
name|PDR
name|pr
decl_stmt|;
call|(
modifier|*
name|swap_pdr_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|pdr_ptr
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_pdr
condition|)
block|{
name|first_off
operator|=
name|pr
operator|.
name|adr
expr_stmt|;
name|first_pdr
operator|=
literal|0
expr_stmt|;
block|}
name|parse_procedure
argument_list|(
operator|&
name|pr
argument_list|,
name|st
argument_list|,
name|first_off
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This symbol table contains ordinary ecoff entries.  */
comment|/* FIXME:  doesn't use pst->section_offsets.  */
name|int
name|f_max
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
name|EXTR
modifier|*
name|ext_ptr
decl_stmt|;
comment|/* How many symbols will we need */
comment|/* FIXME, this does not count enum values. */
name|f_max
operator|=
name|pst
operator|->
name|n_global_syms
operator|+
name|pst
operator|->
name|n_static_syms
expr_stmt|;
if|if
condition|(
name|fh
operator|==
literal|0
condition|)
block|{
name|maxlines
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|new_symtab
argument_list|(
literal|"unknown"
argument_list|,
name|f_max
argument_list|,
literal|0
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_max
operator|+=
name|fh
operator|->
name|csym
operator|+
name|fh
operator|->
name|cpd
expr_stmt|;
name|maxlines
operator|=
literal|2
operator|*
name|fh
operator|->
name|cline
expr_stmt|;
name|st
operator|=
name|new_symtab
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
literal|2
operator|*
name|f_max
argument_list|,
name|maxlines
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* The proper language was already determined when building 	     the psymtab, use it.  */
name|st
operator|->
name|language
operator|=
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|pst_language
expr_stmt|;
block|}
name|psymtab_language
operator|=
name|st
operator|->
name|language
expr_stmt|;
name|lines
operator|=
name|LINETABLE
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Get a new lexical context */
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|cur_st
operator|=
name|st
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|st
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|=
name|fh
condition|?
name|fh
operator|->
name|adr
else|:
literal|0
expr_stmt|;
name|BLOCK_END
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stFile
expr_stmt|;
name|top_stack
operator|->
name|maxsyms
operator|=
literal|2
operator|*
name|f_max
expr_stmt|;
name|top_stack
operator|->
name|cur_type
operator|=
literal|0
expr_stmt|;
name|top_stack
operator|->
name|procadr
operator|=
literal|0
expr_stmt|;
name|top_stack
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fh
condition|)
block|{
name|char
modifier|*
name|sym_ptr
decl_stmt|;
name|char
modifier|*
name|sym_end
decl_stmt|;
comment|/* Parse local symbols first */
name|sym_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
name|fh
operator|->
name|isymBase
operator|*
name|external_sym_size
operator|)
expr_stmt|;
name|sym_end
operator|=
name|sym_ptr
operator|+
name|fh
operator|->
name|csym
operator|*
name|external_sym_size
expr_stmt|;
while|while
condition|(
name|sym_ptr
operator|<
name|sym_end
condition|)
block|{
name|SYMR
name|sh
decl_stmt|;
name|int
name|c
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|sym_ptr
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|c
operator|=
name|parse_symbol
argument_list|(
operator|&
name|sh
argument_list|,
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|)
argument_list|,
name|sym_ptr
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|)
expr_stmt|;
name|sym_ptr
operator|+=
name|c
operator|*
name|external_sym_size
expr_stmt|;
block|}
comment|/* Linenumbers.  At the end, check if we can save memory. 	     parse_lines has to look ahead an arbitrary number of PDR 	     structures, so we swap them all first.  */
if|if
condition|(
name|fh
operator|->
name|cpd
operator|>
literal|0
condition|)
block|{
name|PDR
modifier|*
name|pr_block
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|pdr_ptr
decl_stmt|;
name|char
modifier|*
name|pdr_end
decl_stmt|;
name|PDR
modifier|*
name|pdr_in
decl_stmt|;
name|PDR
modifier|*
name|pdr_in_end
decl_stmt|;
name|pr_block
operator|=
operator|(
name|PDR
operator|*
operator|)
name|xmalloc
argument_list|(
name|fh
operator|->
name|cpd
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|pr_block
argument_list|)
expr_stmt|;
name|pdr_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_pdr
operator|+
name|fh
operator|->
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
expr_stmt|;
name|pdr_end
operator|=
name|pdr_ptr
operator|+
name|fh
operator|->
name|cpd
operator|*
name|external_pdr_size
expr_stmt|;
name|pdr_in
operator|=
name|pr_block
expr_stmt|;
for|for
control|(
init|;
name|pdr_ptr
operator|<
name|pdr_end
condition|;
name|pdr_ptr
operator|+=
name|external_pdr_size
operator|,
name|pdr_in
operator|++
control|)
call|(
modifier|*
name|swap_pdr_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|pdr_ptr
argument_list|,
name|pdr_in
argument_list|)
expr_stmt|;
name|parse_lines
argument_list|(
name|fh
argument_list|,
name|pr_block
argument_list|,
name|lines
argument_list|,
name|maxlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|->
name|nitems
operator|<
name|fh
operator|->
name|cline
condition|)
name|lines
operator|=
name|shrink_linetable
argument_list|(
name|lines
argument_list|)
expr_stmt|;
comment|/* Fill in procedure info next.  */
name|pdr_in
operator|=
name|pr_block
expr_stmt|;
name|pdr_in_end
operator|=
name|pdr_in
operator|+
name|fh
operator|->
name|cpd
expr_stmt|;
for|for
control|(
init|;
name|pdr_in
operator|<
name|pdr_in_end
condition|;
name|pdr_in
operator|++
control|)
name|parse_procedure
argument_list|(
name|pdr_in
argument_list|,
literal|0
argument_list|,
name|pr_block
operator|->
name|adr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
name|LINETABLE
argument_list|(
name|st
argument_list|)
operator|=
name|lines
expr_stmt|;
comment|/* .. and our share of externals. 	 XXX use the global list to speed up things here. how? 	 FIXME, Maybe quit once we have found the right number of ext's? */
name|top_stack
operator|->
name|cur_st
operator|=
name|st
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stFile
expr_stmt|;
name|top_stack
operator|->
name|maxsyms
operator|=
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|isymMax
operator|+
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|ipdMax
operator|+
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|)
expr_stmt|;
name|ext_ptr
operator|=
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|extern_tab
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|extern_count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ext_ptr
operator|++
control|)
name|parse_external
argument_list|(
name|ext_ptr
argument_list|,
literal|1
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|)
expr_stmt|;
comment|/* If there are undefined symbols, tell the user. 	 The alpha has an undefined symbol for every symbol that is 	 from a shared library, so tell the user only if verbose is on.  */
if|if
condition|(
name|info_verbose
operator|&&
name|n_undef_symbols
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File %s contains %d unresolved references:"
argument_list|,
name|st
operator|->
name|filename
argument_list|,
name|n_undef_symbols
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n\t%4d variables\n\t%4d procedures\n\t%4d labels\n"
argument_list|,
name|n_undef_vars
argument_list|,
name|n_undef_procs
argument_list|,
name|n_undef_labels
argument_list|)
expr_stmt|;
name|n_undef_symbols
operator|=
name|n_undef_labels
operator|=
name|n_undef_vars
operator|=
name|n_undef_procs
operator|=
literal|0
expr_stmt|;
block|}
name|pop_parse_stack
argument_list|()
expr_stmt|;
comment|/* Sort the symbol table now, we are done adding symbols to it.*/
name|sort_symtab_syms
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|sort_blocks
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
comment|/* Now link the psymtab and the symtab.  */
name|pst
operator|->
name|symtab
operator|=
name|st
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ancillary parsing procedures. */
end_comment

begin_comment
comment|/* Lookup the type at relative index RN.  Return it in TPP    if found and in any event come up with its name PNAME.    BIGEND says whether aux symbols are big-endian or not (from fh->fBigendian).    Return value says how many aux symbols we ate. */
end_comment

begin_function
specifier|static
name|int
name|cross_ref
parameter_list|(
name|fd
parameter_list|,
name|ax
parameter_list|,
name|tpp
parameter_list|,
name|type_code
parameter_list|,
name|pname
parameter_list|,
name|bigend
parameter_list|,
name|sym_name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|tpp
decl_stmt|;
name|enum
name|type_code
name|type_code
decl_stmt|;
comment|/* Use to alloc new type if none is found. */
name|char
modifier|*
modifier|*
name|pname
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
name|RNDXR
name|rn
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|rf
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|esh
decl_stmt|;
name|SYMR
name|sh
decl_stmt|;
name|int
name|xref_fd
decl_stmt|;
name|struct
name|mips_pending
modifier|*
name|pend
decl_stmt|;
operator|*
name|tpp
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
expr_stmt|;
name|ecoff_swap_rndx_in
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_rndx
argument_list|,
name|rn
argument_list|)
expr_stmt|;
comment|/* Escape index means 'the next one' */
if|if
condition|(
name|rn
operator|->
name|rfd
operator|==
literal|0xfff
condition|)
block|{
name|result
operator|++
expr_stmt|;
name|rf
operator|=
name|AUX_GET_ISYM
argument_list|(
name|bigend
argument_list|,
name|ax
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf
operator|=
name|rn
operator|->
name|rfd
expr_stmt|;
block|}
comment|/* mips cc uses a rf of -1 for opaque struct definitions.      Set TYPE_FLAG_STUB for these types so that check_stub_type will      resolve them if the struct gets defined in another compilation unit.  */
if|if
condition|(
name|rf
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|pname
operator|=
literal|"<undefined>"
expr_stmt|;
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
operator|*
name|tpp
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* mips cc uses an escaped rn->index of 0 for struct return types      of procedures that were compiled without -g. These will always remain      undefined.  */
if|if
condition|(
name|rn
operator|->
name|rfd
operator|==
literal|0xfff
operator|&&
name|rn
operator|->
name|index
operator|==
literal|0
condition|)
block|{
operator|*
name|pname
operator|=
literal|"<undefined>"
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Find the relative file descriptor and the symbol in it.  */
name|fh
operator|=
name|get_rfd
argument_list|(
name|fd
argument_list|,
name|rf
argument_list|)
expr_stmt|;
name|xref_fd
operator|=
name|fh
operator|-
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|index
operator|>=
name|fh
operator|->
name|csym
condition|)
block|{
comment|/* File indirect entry is corrupt.  */
operator|*
name|pname
operator|=
literal|"<illegal>"
expr_stmt|;
name|complain
argument_list|(
operator|&
name|bad_rfd_entry_complaint
argument_list|,
name|sym_name
argument_list|,
name|xref_fd
argument_list|,
name|rn
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* If we have processed this symbol then we left a forwarding      pointer to the type in the pending list.  If not, we`ll put      it in a list of pending types, to be processed later when      the file will be.  In any event, we collect the name for the      type here.  */
name|esh
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|rn
operator|->
name|index
operator|)
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_sym_size
operator|)
operator|)
expr_stmt|;
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|swap_sym_in
operator|)
operator|(
name|cur_bfd
operator|,
name|esh
operator|,
operator|&
name|sh
operator|)
expr_stmt|;
comment|/* Make sure that this type of cross reference can be handled.  */
if|if
condition|(
name|sh
operator|.
name|sc
operator|!=
name|scInfo
operator|||
operator|(
name|sh
operator|.
name|st
operator|!=
name|stBlock
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stTypedef
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stStruct
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stUnion
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stEnum
operator|)
condition|)
block|{
comment|/* File indirect entry is corrupt.  */
operator|*
name|pname
operator|=
literal|"<illegal>"
expr_stmt|;
name|complain
argument_list|(
operator|&
name|bad_rfd_entry_complaint
argument_list|,
name|sym_name
argument_list|,
name|xref_fd
argument_list|,
name|rn
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
operator|*
name|pname
operator|=
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|pend
operator|=
name|is_pending_symbol
argument_list|(
name|fh
argument_list|,
name|esh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
condition|)
operator|*
name|tpp
operator|=
name|pend
operator|->
name|t
expr_stmt|;
else|else
block|{
comment|/* We have not yet seen this type.  */
if|if
condition|(
name|sh
operator|.
name|iss
operator|==
literal|0
operator|&&
name|sh
operator|.
name|st
operator|==
name|stTypedef
condition|)
block|{
name|TIR
name|tir
decl_stmt|;
comment|/* alpha cc puts out a stTypedef with a sh.iss of zero for 	     two cases: 	     a) forward declarations of structs/unions/enums which are not 		defined in this compilation unit. 		For these the type will be void. This is a bad design decision 		as cross referencing across compilation units is impossible 		due to the missing name. 	     b) forward declarations of structs/unions/enums which are defined 		later in this file or in another file in the same compilation 		unit.  Simply cross reference those again to get the 		true type. 	     The forward references are not entered in the pending list and 	     in the symbol table.  */
name|ecoff_swap_tir_in
argument_list|(
name|bigend
argument_list|,
operator|&
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
operator|->
name|a_ti
argument_list|,
operator|&
name|tir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tir
operator|.
name|tq0
operator|!=
name|tqNil
condition|)
name|complain
argument_list|(
operator|&
name|illegal_forward_tq0_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tir
operator|.
name|bt
condition|)
block|{
case|case
name|btVoid
case|:
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
operator|*
name|pname
operator|=
literal|"<undefined>"
expr_stmt|;
break|break;
case|case
name|btStruct
case|:
case|case
name|btUnion
case|:
case|case
name|btEnum
case|:
name|cross_ref
argument_list|(
name|xref_fd
argument_list|,
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|+
literal|1
operator|)
argument_list|,
name|tpp
argument_list|,
name|type_code
argument_list|,
name|pname
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|illegal_forward_bt_complaint
argument_list|,
name|tir
operator|.
name|bt
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stTypedef
condition|)
block|{
comment|/* Parse the type for a normal typedef. This might recursively call 	     cross_ref till we get a non typedef'ed type. 	     FIXME: This is not correct behaviour, but gdb currently 	     cannot handle typedefs without type copying. But type copying is 	     impossible as we might have mutual forward references between 	     two files and the copied type would not get filled in when 	     we later parse its definition.   */
operator|*
name|tpp
operator|=
name|parse_type
argument_list|(
name|xref_fd
argument_list|,
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
argument_list|,
name|sh
operator|.
name|index
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
operator|(
name|ecoff_data
argument_list|(
name|cur_bfd
argument_list|)
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Cross reference to a struct/union/enum which is defined 	     in another file in the same compilation unit but that file 	     has not been parsed yet. 	     Initialize the type only, it will be filled in when 	     it's definition is parsed.  */
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
block|}
name|add_pending
argument_list|(
name|fh
argument_list|,
name|esh
argument_list|,
operator|*
name|tpp
argument_list|)
expr_stmt|;
block|}
comment|/* We used one auxent normally, two if we got a "next one" rf. */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Quick&dirty lookup procedure, to avoid the MI ones that require    keeping the symtab sorted */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|mylookup_symbol
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|inc
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|inc
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|class
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sym
return|;
name|bot
operator|++
expr_stmt|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
return|return
name|mylookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|class
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new symbol S to a block B.    Infrequently, we will need to reallocate the block to make it bigger.    We only detect this case when adding to top_stack->cur_block, since    that's the only time we know how big the block is.  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|add_symbol
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|)
name|struct
name|symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|nsyms
init|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|++
decl_stmt|;
name|struct
name|block
modifier|*
name|origb
decl_stmt|;
name|struct
name|parse_stack
modifier|*
name|stackp
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|top_stack
operator|->
name|cur_block
operator|&&
name|nsyms
operator|>=
name|top_stack
operator|->
name|maxsyms
condition|)
block|{
name|complain
argument_list|(
operator|&
name|block_overflow_complaint
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In this case shrink_block is actually grow_block, since 		   BLOCK_NSYMS(b) is larger than its current size.  */
name|origb
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|shrink_block
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
comment|/* Now run through the stack replacing pointers to the 	 original block.  shrink_block has already done this 	 for the blockvector and BLOCK_FUNCTION.  */
for|for
control|(
name|stackp
operator|=
name|top_stack
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|stackp
operator|->
name|cur_block
operator|==
name|origb
condition|)
block|{
name|stackp
operator|->
name|cur_block
operator|=
name|b
expr_stmt|;
name|stackp
operator|->
name|maxsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|nsyms
argument_list|)
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new block B to a symtab S */
end_comment

begin_function
specifier|static
name|void
name|add_block
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|bv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|bv
operator|->
name|block
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bv
operator|!=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
condition|)
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|=
name|bv
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|++
argument_list|)
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new linenumber entry (LINENO,ADR) to a linevector LT.    MIPS' linenumber encoding might need more than one byte    to describe it, LAST is used to detect these continuation lines.     Combining lines with the same line number seems like a bad idea.    E.g: There could be a line number entry with the same line number after the    prologue and GDB should not ignore it (this is a better way to find    a prologue than mips_skip_prologue).    But due to the compressed line table format there are line number entries    for the same line which are needed to bridge the gap to the next    line number entry. These entries have a bogus address info with them    and we are unable to tell them from intended duplicate line number    entries.    This is another reason why -ggdb debugging format is preferable.  */
end_comment

begin_function
specifier|static
name|int
name|add_line
parameter_list|(
name|lt
parameter_list|,
name|lineno
parameter_list|,
name|adr
parameter_list|,
name|last
parameter_list|)
name|struct
name|linetable
modifier|*
name|lt
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|last
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* make sure we record first line */
if|if
condition|(
name|last
operator|==
name|lineno
condition|)
comment|/* skip continuation lines */
return|return
name|lineno
return|;
name|lt
operator|->
name|item
index|[
name|lt
operator|->
name|nitems
index|]
operator|.
name|line
operator|=
name|lineno
expr_stmt|;
name|lt
operator|->
name|item
index|[
name|lt
operator|->
name|nitems
operator|++
index|]
operator|.
name|pc
operator|=
name|adr
operator|<<
literal|2
expr_stmt|;
return|return
name|lineno
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sorting and reordering procedures */
end_comment

begin_comment
comment|/* Blocks with a smaller low bound should come first */
end_comment

begin_function
specifier|static
name|int
name|compare_blocks
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|register
name|int
name|addr_diff
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|b1
init|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|b2
init|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|addr_diff
operator|=
operator|(
name|BLOCK_START
argument_list|(
operator|(
operator|*
name|b1
operator|)
argument_list|)
operator|)
operator|-
operator|(
name|BLOCK_START
argument_list|(
operator|(
operator|*
name|b2
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|addr_diff
operator|==
literal|0
condition|)
return|return
operator|(
name|BLOCK_END
argument_list|(
operator|(
operator|*
name|b2
operator|)
argument_list|)
operator|)
operator|-
operator|(
name|BLOCK_END
argument_list|(
operator|(
operator|*
name|b1
operator|)
argument_list|)
operator|)
return|;
return|return
name|addr_diff
return|;
block|}
end_function

begin_comment
comment|/* Sort the blocks of a symtab S.    Reorder the blocks in the blockvector by code-address,    as required by some MI search routines */
end_comment

begin_function
specifier|static
name|void
name|sort_blocks
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|<=
literal|2
condition|)
block|{
comment|/* Cosmetic */
if|if
condition|(
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*    * This is very unfortunate: normally all functions are compiled in    * the order they are found, but if the file is compiled -O3 things    * are very different.  It would be nice to find a reliable test    * to detect -O3 images in advance.    */
if|if
condition|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|>
literal|3
condition|)
name|qsort
argument_list|(
operator|&
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|-
name|FIRST_LOCAL_BLOCK
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
argument_list|,
name|compare_blocks
argument_list|)
expr_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|high
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
init|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_LOCAL_BLOCK
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|high
operator|<
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|high
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|=
name|high
expr_stmt|;
block|}
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructor/restructor/destructor procedures */
end_comment

begin_comment
comment|/* Allocate a new symtab for NAME.  Needs an estimate of how many symbols    MAXSYMS and linenumbers MAXLINES we'll put in it */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|new_symtab
parameter_list|(
name|name
parameter_list|,
name|maxsyms
parameter_list|,
name|maxlines
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|maxsyms
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|allocate_symtab
argument_list|(
name|name
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|LINETABLE
argument_list|(
name|s
argument_list|)
operator|=
name|new_linetable
argument_list|(
name|maxlines
argument_list|)
expr_stmt|;
comment|/* All symtabs must have at least two blocks */
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|=
name|new_bvect
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
operator|=
name|new_block
argument_list|(
name|maxsyms
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
operator|=
name|new_block
argument_list|(
name|maxsyms
argument_list|)
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|s
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new partial_symtab NAME */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|new_psymtab
parameter_list|(
name|name
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|psymtab
operator|=
name|allocate_psymtab
argument_list|(
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Keep a backpointer to the file's symbols */
name|psymtab
operator|->
name|read_symtab_private
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab
operator|->
name|read_symtab_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|CUR_BFD
argument_list|(
name|psymtab
argument_list|)
operator|=
name|cur_bfd
expr_stmt|;
comment|/* The way to turn this into a symtab is to call... */
name|psymtab
operator|->
name|read_symtab
operator|=
name|mipscoff_psymtab_to_symtab
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a linetable array of the given SIZE.  Since the struct    already includes one item, we subtract one when calculating the    proper size to allocate.  */
end_comment

begin_function
specifier|static
name|struct
name|linetable
modifier|*
name|new_linetable
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|l
operator|->
name|item
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|l
operator|->
name|nitems
operator|=
literal|0
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Oops, too big. Shrink it.  This was important with the 2.4 linetables,    I am not so sure about the 3.4 ones.     Since the struct linetable already includes one item, we subtract one when    calculating the proper size to allocate.  */
end_comment

begin_function
specifier|static
name|struct
name|linetable
modifier|*
name|shrink_linetable
parameter_list|(
name|lt
parameter_list|)
name|struct
name|linetable
modifier|*
name|lt
decl_stmt|;
block|{
return|return
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|lt
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
operator|(
name|lt
operator|->
name|nitems
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|lt
operator|->
name|item
argument_list|)
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate and zero a new blockvector of NBLOCKS blocks. */
end_comment

begin_function
specifier|static
name|struct
name|blockvector
modifier|*
name|new_bvect
parameter_list|(
name|nblocks
parameter_list|)
name|int
name|nblocks
decl_stmt|;
block|{
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
expr_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|xzalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|=
name|nblocks
expr_stmt|;
return|return
name|bv
return|;
block|}
end_function

begin_comment
comment|/* Allocate and zero a new block of MAXSYMS symbols */
end_comment

begin_function
specifier|static
name|struct
name|block
modifier|*
name|new_block
parameter_list|(
name|maxsyms
parameter_list|)
name|int
name|maxsyms
decl_stmt|;
block|{
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
name|maxsyms
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
decl_stmt|;
return|return
operator|(
expr|struct
name|block
operator|*
operator|)
name|xzalloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ooops, too big. Shrink block B in symtab S to its minimal size.    Shrink_block can also be used by add_symbol to grow a block.  */
end_comment

begin_function
specifier|static
name|struct
name|block
modifier|*
name|shrink_block
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|new
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Just reallocate it and fix references to the old one */
name|new
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|b
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Should chase pointers to old one.  Fortunately, that`s just 	   the block`s function and inferior blocks */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|new
argument_list|)
operator|&&
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|new
argument_list|)
argument_list|)
operator|==
name|b
condition|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|new
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
operator|==
name|b
condition|)
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|b
condition|)
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Create a new symbol with printname NAME */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|s
init|=
operator|(
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|s
argument_list|)
operator|=
name|psymtab_language
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|s
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Create a new type with printname NAME */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|new_type
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|alloc_type
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|cplus_struct_type
operator|*
operator|)
operator|&
name|cplus_struct_default
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Things used for calling functions in the inferior.    These functions are exported to our companion    mips-tdep.c file and are here because they play    with the symbol-table explicitly. */
end_comment

begin_comment
comment|/* Sigtramp: make sure we have all the necessary information    about the signal trampoline code. Since the official code    from MIPS does not do so, we make up that information ourselves.    If they fix the library (unlikely) this code will neutralize itself. */
end_comment

begin_function
specifier|static
name|void
name|fixup_sigtramp
parameter_list|()
block|{
name|struct
name|symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|symtab
modifier|*
name|st
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|b0
init|=
name|NULL
decl_stmt|;
name|sigtramp_address
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We have to handle the following cases here:      a) The Mips library has a sigtramp label within sigvec.      b) Irix has a _sigtramp which we want to use, but it also has sigvec.  */
name|s
operator|=
name|lookup_symbol
argument_list|(
literal|"sigvec"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|b0
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|lookup_symbol
argument_list|(
literal|"sigtramp"
argument_list|,
name|b0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* No sigvec or no sigtramp inside sigvec, try _sigtramp.  */
name|s
operator|=
name|lookup_symbol
argument_list|(
literal|"_sigtramp"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* But maybe this program uses its own version of sigvec */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
comment|/* Did we or MIPSco fix the library ? */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|sigtramp_address
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|sigtramp_end
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sigtramp_address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sigtramp_end
operator|=
name|sigtramp_address
operator|+
literal|0x88
expr_stmt|;
comment|/* black magic */
comment|/* But what symtab does it live in ? */
name|st
operator|=
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Ok, there goes the fix: turn it into a procedure, with all the    * needed info.  Note we make it a nested procedure of sigvec,    * which is the way the (assembly) code is actually written.    */
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FUNC
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|=
name|builtin_type_void
expr_stmt|;
comment|/* Need a block to allocate MIPS_EFI_SYMBOL_NAME in */
name|b
operator|=
name|new_block
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|b
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|sigtramp_address
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|sigtramp_end
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|=
name|s
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b0
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|sort_blocks
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Make a MIPS_EFI_SYMBOL_NAME entry for it */
block|{
name|struct
name|mips_extra_func_info
modifier|*
name|e
init|=
operator|(
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|xzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|e
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
comment|/* the kernel thinks otherwise */
comment|/* align_longword(sigcontext + SIGFRAME) */
name|e
operator|->
name|pdr
operator|.
name|frameoffset
operator|=
literal|0x150
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|framereg
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* read_next_frame_reg provides the true pc at the time of signal */
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|=
name|PC_REGNUM
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regmask
operator|=
operator|-
literal|2
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regoffset
operator|=
operator|-
operator|(
literal|41
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|fregmask
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|fregoffset
operator|=
operator|-
operator|(
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|isym
operator|=
operator|(
name|long
operator|)
name|s
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|adr
operator|=
name|sigtramp_address
expr_stmt|;
name|current_objfile
operator|=
name|st
operator|->
name|objfile
expr_stmt|;
comment|/* Keep new_symbol happy */
name|s
operator|=
name|new_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|long
operator|)
name|e
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|builtin_type_void
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|++
argument_list|)
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fake up identical offsets for all sections.  */
end_comment

begin_function
name|struct
name|section_offsets
modifier|*
name|mipscoff_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|section_offsets
operator|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|ecoff_sym_fns
init|=
block|{
literal|"ecoff"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|5
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|mipscoff_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|mipscoff_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|mipscoff_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|mipscoff_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|mipscoff_symfile_offsets
block|,
comment|/* sym_offsets: dummy FIXME til implem sym reloc */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_mipsread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|ecoff_sym_fns
argument_list|)
expr_stmt|;
comment|/* Missing basic types */
name|builtin_type_string
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"string"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_complex
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_COMPLEX_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_double_complex
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_COMPLEX_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double complex"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_fixed_dec
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"fixed decimal"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_float_dec
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"floating decimal"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

