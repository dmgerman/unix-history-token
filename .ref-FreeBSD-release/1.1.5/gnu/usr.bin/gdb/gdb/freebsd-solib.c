begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle SunOS and SVR4 shared libraries for GDB, the GNU Debugger.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* modified for FreeBSD, since the names in link.h are totally different!    6.1.94 */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_comment
comment|/* SunOS shared libs need the nlist structure.  */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_define
define|#
directive|define
name|MAX_PATH_SIZE
value|256
end_define

begin_comment
comment|/* FIXME: Should be dynamic */
end_comment

begin_comment
comment|/* On SVR4 systems, for the initial implementation, use some runtime startup    symbol as the "startup mapping complete" breakpoint address.  The models    for SunOS and SVR4 dynamic linking debugger support are different in that    SunOS hits one breakpoint when all mapping is complete while using the SVR4    debugger support takes two breakpoint hits for each file mapped, and    there is no way to know when the "last" one is hit.  Both these    mechanisms should be tied to a "breakpoint service routine" that    gets automatically executed whenever one of the breakpoints indicating    a change in mapping is hit.  This is a future enhancement.  (FIXME) */
end_comment

begin_define
define|#
directive|define
name|BKPT_AT_SYMBOL
value|1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BKPT_AT_SYMBOL
argument_list|)
operator|&&
name|defined
argument_list|(
name|SVR4_SHARED_LIBS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bkpt_names
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SOLIB_BKPT_NAME
name|SOLIB_BKPT_NAME
block|,
comment|/* Prefer configured name if it exists. */
endif|#
directive|endif
literal|"_start"
block|,
literal|"main"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local data declarations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_BASE
value|"_DYNAMIC"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
end_ifdef

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.lm_addr)
end_define

begin_define
define|#
directive|define
name|LM_NEXT
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.lm_next)
end_define

begin_define
define|#
directive|define
name|LM_NAME
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.lm_name)
end_define

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic
name|dynamic_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic_2
name|ld_2_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_debug
name|debug_copy
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.som_addr)
end_define

begin_define
define|#
directive|define
name|LM_NEXT
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.som_next)
end_define

begin_define
define|#
directive|define
name|LM_NAME
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.som_path)
end_define

begin_decl_stmt
specifier|static
name|struct
name|_dynamic
name|dynamic_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_dispatch_table
name|ld_2_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_debug
name|debug_copy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|flag_addr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SVR4_SHARED_LIBS */
end_comment

begin_define
define|#
directive|define
name|DEBUG_BASE
value|"_r_debug"
end_define

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_addr)
end_define

begin_define
define|#
directive|define
name|LM_NEXT
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_next)
end_define

begin_define
define|#
directive|define
name|LM_NAME
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_name)
end_define

begin_decl_stmt
specifier|static
name|struct
name|r_debug
name|debug_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shadow_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stash old bkpt addr contents */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SVR4_SHARED_LIBS */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
comment|/* next structure in linked list */
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
name|struct
name|link_map
name|lm
decl_stmt|;
comment|/* copy of link map from inferior */
name|struct
name|link_map
modifier|*
name|lmaddr
decl_stmt|;
comment|/* addr in inferior lm was read from */
else|#
directive|else
name|struct
name|so_map
name|lm
decl_stmt|;
comment|/* copy of link map from inferior */
name|struct
name|so_map
modifier|*
name|lmaddr
decl_stmt|;
comment|/* addr in inferior lm was read from */
endif|#
directive|endif
name|CORE_ADDR
name|lmend
decl_stmt|;
comment|/* upper addr bound of mapped object */
name|char
name|so_name
index|[
name|MAX_PATH_SIZE
index|]
decl_stmt|;
comment|/* shared object lib name (FIXME) */
name|char
name|symbols_loaded
decl_stmt|;
comment|/* flag: symbols read in yet? */
name|char
name|from_tty
decl_stmt|;
comment|/* flag: print msgs? */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* objfile for loaded lib */
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|struct
name|section_table
modifier|*
name|textsection
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of known shared objects */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of dynamic linker structures */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakpoint_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where end bkpt is set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdmatch
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In libiberty */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|special_symbol_handling
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbol_add_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
end_ifdef

begin_expr_stmt
specifier|static
expr|struct
name|link_map
operator|*
else|#
directive|else
specifier|static
expr|struct
name|so_map
operator|*
endif|#
directive|endif
name|first_link_map_member
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|locate_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|solib_map_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|look_for_base
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|solib_add_common_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rt_symbol
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  LOCAL FUNCTION  	solib_map_sections -- open bfd and build sections for shared lib  SYNOPSIS  	static void solib_map_sections (struct so_list *so)  DESCRIPTION  	Given a pointer to one of the shared objects in our list 	of mapped objects, use the recorded name to open a bfd 	descriptor for the object, build a section table, and then 	relocate all the section addresses by the base address at 	which the shared object was mapped.  FIXMES  	In most (all?) cases the shared object file name recorded in the 	dynamic linkage tables will be a fully qualified pathname.  For 	cases where it isn't, do we really mimic the systems search 	mechanism correctly in the below code (particularly the tilde 	expansion stuff?).  */
end_comment

begin_function
specifier|static
name|void
name|solib_map_sections
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Leave scratch_pathname allocated.  abfd->name will point to it.  */
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|scratch_chan
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Leave bfd open, core_xfer_memory and "info files" need it.  */
name|so
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* Relocate the section binding addresses as recorded in the shared 	 object's file by the base address to which the object was actually 	 mapped. */
name|p
operator|->
name|addr
operator|+=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|lmend
operator|=
operator|(
name|CORE_ADDR
operator|)
name|max
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
name|so
operator|->
name|lmend
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|sec_ptr
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|so
operator|->
name|textsection
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Free the file names, close the file now.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read all dynamically loaded common symbol definitions from the inferior    and add them to the minimal symbol table for the shared library objfile.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_comment
comment|/* In GDB 4.9 this routine was a real performance hog.  According to    some gprof data which mtranle@paris.IntelliCorp.COM (Minh Tran-Le)    sent, almost all the time spend in solib_add (up to 20 minutes with    35 shared libraries) was spent here, with 5/6 in    lookup_minimal_symbol and 1/6 in read_memory.     To fix this, we moved the call to special_symbol_handling out of the    loop in solib_add, so this only gets called once, rather than once    for every shared library, and also removed the call to lookup_minimal_symbol    in this routine.  */
end_comment

begin_function
specifier|static
name|void
name|solib_add_common_symbols
parameter_list|(
name|rtc_symp
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|rt_symbol
modifier|*
name|rtc_symp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|rt_symbol
name|inferior_rtc_symb
decl_stmt|;
name|struct
name|nzlist
name|inferior_rtc_nzlist
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|origname
decl_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|rtc_symp
condition|)
block|{
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|rtc_symp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_rtc_symb
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_rtc_symb
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|inferior_rtc_symb
operator|.
name|rt_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_rtc_nzlist
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_rtc_nzlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_rtc_nzlist
operator|.
name|nz_type
operator|==
name|N_COMM
condition|)
block|{
comment|/* FIXME: The length of the symbol name is not available, but in the 	     current implementation the common symbol is allocated immediately 	     behind the name of the symbol. */
name|len
operator|=
name|inferior_rtc_nzlist
operator|.
name|nz_value
operator|-
name|inferior_rtc_nzlist
operator|.
name|nz_strx
expr_stmt|;
name|origname
operator|=
name|name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|inferior_rtc_nzlist
operator|.
name|nz_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Don't enter the symbol twice if the target is re-run. */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
block|{
name|name
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* I think this is unnecessary, GDB can probably deal with 	     duplicate minimal symbols, more or less.  And the duplication 	     which used to happen because this was called for each shared 	     library is gone now that we are just called once.  */
comment|/* FIXME:  Do we really want to exclude symbols which happen 	     to match symbols for other locations in the inferior's 	     address space, even when they are in different linkage units? */
block|if (lookup_minimal_symbol (name, (struct objfile *) NULL) == NULL)
endif|#
directive|endif
block|{
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|inferior_rtc_nzlist
operator|.
name|nz_value
argument_list|,
name|mst_bss
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|origname
argument_list|)
expr_stmt|;
block|}
name|rtc_symp
operator|=
name|inferior_rtc_symb
operator|.
name|rt_next
expr_stmt|;
block|}
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4_SHARED_LIBS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
end_ifdef

begin_comment
comment|/*  LOCAL FUNCTION  	bfd_lookup_symbol -- lookup the value for a specific symbol  SYNOPSIS  	CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)  DESCRIPTION  	An expensive way to lookup the value of a single symbol for 	bfd's that are only temporary anyway.  This is used by the 	shared library support to find the address of the debugger 	interface structures in the shared library.  	Note that 0 is specifically allowed as an error return (no 	such symbol).  	FIXME:  See if there is a less "expensive" way of doing this. 	Also see if there is already another bfd or gdb function 	that specifically does this, and if so, use it. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symname
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
block|{
name|unsigned
name|int
name|storage_needed
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_table
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|symaddr
init|=
literal|0
decl_stmt|;
name|storage_needed
operator|=
name|get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
operator|(
name|PTR
operator|)
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|*
name|symbol_table
operator|++
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|symname
argument_list|)
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|symaddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	look_for_base -- examine file for each mapped address segment  SYNOPSYS  	static int look_for_base (int fd, CORE_ADDR baseaddr)  DESCRIPTION  	This function is passed to proc_iterate_over_mappings, which 	causes it to get called once for each mapped address space, with 	an open file descriptor for the file mapped to that space, and the 	base address of that mapped space.  	Our job is to find the symbol DEBUG_BASE in the file that this 	fd is open on, if it exists, and if so, initialize the dynamic 	linker structure base address debug_base.  	Note that this is a computationally expensive proposition, since 	we basically have to open a bfd on every call, so we specifically 	avoid opening the exec file.  */
end_comment

begin_function
specifier|static
name|int
name|look_for_base
parameter_list|(
name|fd
parameter_list|,
name|baseaddr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
block|{
name|bfd
modifier|*
name|interp_bfd
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
comment|/* If the fd is -1, then there is no file that corresponds to this      mapped memory segment, so skip it.  Also, if the fd corresponds      to the exec file, skip it as well. */
if|if
condition|(
operator|(
name|fd
operator|==
operator|-
literal|1
operator|)
operator|||
name|fdmatch
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|exec_bfd
operator|->
name|iostream
operator|)
argument_list|)
argument_list|,
name|fd
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try to open whatever random file this fd corresponds to.  Note that      we have no way currently to find the filename.  Don't gripe about      any problems we might have, just fail. */
if|if
condition|(
operator|(
name|interp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
literal|"unnamed"
argument_list|,
name|gnutarget
argument_list|,
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|interp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Now try to find our DEBUG_BASE symbol in this file, which we at      least know to be a valid ELF executable or shared library. */
if|if
condition|(
operator|(
name|address
operator|=
name|bfd_lookup_symbol
argument_list|(
name|interp_bfd
argument_list|,
name|DEBUG_BASE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Eureka!  We found the symbol.  But now we may need to relocate it      by the base address.  If the symbol's value is less than the base      address of the shared library, then it hasn't yet been relocated      by the dynamic linker, and we have to do it ourself.  FIXME: Note      that we make the assumption that the first segment that corresponds      to the shared library has the base address to which the library      was relocated. */
if|if
condition|(
name|address
operator|<
name|baseaddr
condition|)
block|{
name|address
operator|+=
name|baseaddr
expr_stmt|;
block|}
name|debug_base
operator|=
name|address
expr_stmt|;
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  LOCAL FUNCTION  	locate_base -- locate the base address of dynamic linker structs  SYNOPSIS  	CORE_ADDR locate_base (void)  DESCRIPTION  	For both the SunOS and SVR4 shared library implementations, if the 	inferior executable has been linked dynamically, there is a single 	address somewhere in the inferior's data space which is the key to 	locating all of the dynamic linker's runtime structures.  This 	address is the value of the symbol defined by the macro DEBUG_BASE. 	The job of this function is to find and return that address, or to 	return 0 if there is no such address (the executable is statically 	linked for example).  	For SunOS, the job is almost trivial, since the dynamic linker and 	all of it's structures are statically linked to the executable at 	link time.  Thus the symbol for the address we are looking for has 	already been added to the minimal symbol table for the executable's 	objfile at the time the symbol file's symbols were read, and all we 	have to do is look it up there.  Note that we explicitly do NOT want 	to find the copies in the shared library.  	The SVR4 version is much more complicated because the dynamic linker 	and it's structures are located in the shared C library, which gets 	run as the executable's "interpreter" by the kernel.  We have to go 	to a lot more work to discover the address of DEBUG_BASE.  Because 	of this complexity, we cache the value we find and return that value 	on subsequent invocations.  Note there is no copy in the executable 	symbol tables.  	Note that we can assume nothing about the process state at the time 	we need to find this address.  We may be stopped on the first instruc- 	tion of the interpreter (C shared library), the first instruction of 	the executable itself, or somewhere else entirely (if we attached 	to the process for example).   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|locate_base
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
comment|/* For SunOS, we want to limit the search for DEBUG_BASE to the executable      being debugged, since there is a duplicate named symbol in the shared      library.  We don't want the shared library versions. */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEBUG_BASE
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|address
operator|)
return|;
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
comment|/* Check to see if we have a currently valid address, and if so, avoid      doing all this work again and just return the cached address.  If      we have no cached address, ask the /proc support interface to iterate      over the list of mapped address segments, calling look_for_base() for      each segment.  When we are done, we will have either found the base      address or not. */
if|if
condition|(
name|debug_base
operator|==
literal|0
condition|)
block|{
name|proc_iterate_over_mappings
argument_list|(
name|look_for_base
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|debug_base
operator|)
return|;
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	first_link_map_member -- locate first member in dynamic linker's map  SYNOPSIS  	static struct link_map *first_link_map_member (void)  DESCRIPTION  	Read in a copy of the first member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and return 	a pointer to the copy in our address space. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
end_ifdef

begin_expr_stmt
specifier|static
expr|struct
name|link_map
operator|*
else|#
directive|else
specifier|static
expr|struct
name|so_map
operator|*
endif|#
directive|endif
name|first_link_map_member
argument_list|()
block|{
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
block|struct
name|link_map
operator|*
name|lm
operator|=
name|NULL
block|;
else|#
directive|else
block|struct
name|so_map
operator|*
name|lm
operator|=
name|NULL
block|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
block|;
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
if|if
condition|(
name|dynamic_copy
operator|.
name|ld_version
operator|>=
literal|2
condition|)
block|{
comment|/* It is a version that we can deal with, so read in the secondary 	 structure and find the address of the link map list from it. */
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|ld_un
operator|.
name|ld_2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ld_2_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic_2
argument_list|)
argument_list|)
expr_stmt|;
name|lm
operator|=
name|ld_2_copy
operator|.
name|ld_loaded
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|dynamic_copy
operator|.
name|d_version
operator|>=
literal|2
condition|)
block|{
comment|/* It is a version that we can deal with, so read in the secondary 	 structure and find the address of the link map list from it. */
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|d_un
operator|.
name|d_sdt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ld_2_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_dispatch_table
argument_list|)
argument_list|)
expr_stmt|;
name|lm
operator|=
name|ld_2_copy
operator|.
name|sdt_loaded
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SVR4_SHARED_LIBS */
end_comment

begin_expr_stmt
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|r_debug
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FIXME:  Perhaps we should validate the info somehow, perhaps by      checking r_version for a known version number, or r_state for      RT_CONSISTENT. */
end_comment

begin_expr_stmt
name|lm
operator|=
name|debug_copy
operator|.
name|r_map
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SVR4_SHARED_LIBS */
end_comment

begin_return
return|return
operator|(
name|lm
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  LOCAL FUNCTION  	find_solib -- step through list of shared objects  SYNOPSIS  	struct so_list *find_solib (struct so_list *so_list_ptr)  DESCRIPTION  	This module contains the routine which finds the names of any 	loaded "images" in the current process. The argument in must be 	NULL on the first call, and then the returned value must be passed 	in on subsequent calls. This provides the capability to "step" down 	the list of loaded objects. On the last object, a NULL value is 	returned.  	The arg and return value are "struct link_map" pointers, as defined 	in<link.h>.  */
end_comment

begin_function
unit|static
name|struct
name|so_list
modifier|*
name|find_solib
parameter_list|(
name|so_list_ptr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
comment|/* Last lm or NULL for first one */
block|{
name|struct
name|so_list
modifier|*
name|so_list_next
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
else|#
directive|else
name|struct
name|so_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|so_list_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* We are setting up for a new scan through the loaded images. */
if|if
condition|(
operator|(
name|so_list_next
operator|=
name|so_list_head
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* We have not already read in the dynamic linking structures 	     from the inferior, lookup the address of the base structure. */
name|debug_base
operator|=
name|locate_base
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_base
operator|!=
literal|0
condition|)
block|{
comment|/* Read the base structure in and find the address of the first 		 link map list member. */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We have been called before, and are in the process of walking 	 the shared library list.  Advance to the next shared object. */
if|if
condition|(
operator|(
name|lm
operator|=
name|LM_NEXT
argument_list|(
name|so_list_ptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* We have hit the end of the list, so check to see if any were 	     added, but be quiet if we can't read from the target any more. */
name|int
name|status
init|=
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|so_list_ptr
operator|->
name|lmaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|so_list_ptr
operator|->
name|lm
operator|)
argument_list|,
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
sizeof|sizeof
argument_list|(
expr|struct
name|so_map
argument_list|)
block|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|lm
operator|=
name|LM_NEXT
argument_list|(
name|so_list_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|so_list_next
operator|=
name|so_list_ptr
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_if
if|if
condition|(
operator|(
name|so_list_next
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lm
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Get next link map structure from inferior image and build a local 	 abbreviated load_map structure */
name|new
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lmaddr
operator|=
name|lm
expr_stmt|;
comment|/* Add the new node as the next node in the list, or as the root 	 node if this is the first one. */
if|if
condition|(
name|so_list_ptr
operator|!=
name|NULL
condition|)
block|{
name|so_list_ptr
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|so_list_head
operator|=
name|new
expr_stmt|;
block|}
name|so_list_next
operator|=
name|new
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|lm
operator|)
argument_list|,
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
sizeof|sizeof
argument_list|(
expr|struct
name|so_map
argument_list|)
block|)
empty_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For the SVR4 version, there is one entry that has no name 	 (for the inferior executable) since it is not a shared object. */
end_comment

begin_if
if|if
condition|(
name|LM_NAME
argument_list|(
name|new
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|LM_NAME
argument_list|(
name|new
argument_list|)
argument_list|,
name|new
operator|->
name|so_name
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"find_solib: Can't read pathname for load map\n"
argument_list|)
expr_stmt|;
name|new
operator|->
name|so_name
index|[
name|MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|solib_map_sections
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}   return
operator|(
name|so_list_next
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* A small stub to get us past the arg-passing pinhole of catch_errors.  */
end_comment

begin_function
unit|static
name|int
name|symbol_add_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errs bogon */
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|so
operator|->
name|from_tty
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|so
operator|->
name|textsection
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_add -- add a shared library file to the symtab and section list  SYNOPSIS  	void solib_add (char *arg_string, int from_tty, 			struct target_ops *target)  DESCRIPTION  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
comment|/* Last shared library that we read.  */
name|struct
name|so_list
modifier|*
name|so_last
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|re_err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
operator|&&
name|re_exec
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
condition|)
block|{
name|so
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|symbols_loaded
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Symbols already loaded for %s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_add_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|so
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|so_last
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|symbols_loaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now add the shared library sections to the section table of the      specified target, if any.  */
if|if
condition|(
name|target
condition|)
block|{
comment|/* Count how many new section_table entries there are.  */
name|so
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|+=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
comment|/* Reallocate the target's section table including the new size.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|count
operator|+
name|old
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
name|count
operator|+
name|old
operator|)
expr_stmt|;
comment|/* Add these section table entries to the target's table.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|old
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Calling this once at the end means that we put all the minimal      symbols for commons into the objfile for the last shared library.      Since they are in common, this should not be a problem.  If we      delete the objfile with the minimal symbols, we can put all the      symbols into a new objfile (and will on the next call to solib_add).       An alternate approach would be to create an objfile just for      common minsyms, thus not needing any objfile argument to      solib_add_common_symbols.  */
if|if
condition|(
name|so_last
condition|)
name|special_symbol_handling
argument_list|(
name|so_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	info_sharedlibrary_command -- code for "info sharedlibrary"  SYNOPSIS  	static void info_sharedlibrary_command ()  DESCRIPTION  	Walk through the shared library list and print information 	about each attached library. */
end_comment

begin_function
specifier|static
name|void
name|info_sharedlibrary_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
name|int
name|header_done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|header_done
condition|)
block|{
name|printf
argument_list|(
literal|"%-12s%-12s%-12s%s\n"
argument_list|,
literal|"From"
argument_list|,
literal|"To"
argument_list|,
literal|"Syms Read"
argument_list|,
literal|"Shared Object Library"
argument_list|)
expr_stmt|;
name|header_done
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|so
operator|->
name|lmend
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
name|so
operator|->
name|symbols_loaded
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_address -- check to see if an address is in a shared lib  SYNOPSIS  	int solib_address (CORE_ADDR address)  DESCRIPTION  	Provides a hook for other gdb routines to discover whether or 	not a particular address is within the mapped address space of 	a shared library.  Any address between the base mapping address 	and the first address beyond the end of the last mapping, is 	considered to be within the shared library address space, for 	our purposes.  	For example, this routine is called at one point to disable 	breakpoints which are in shared libraries that are not currently 	mapped in.  */
end_comment

begin_function
name|int
name|solib_address
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
literal|0
decl_stmt|;
comment|/* link map state variable */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|>=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|)
operator|&&
operator|(
name|address
operator|<
operator|(
name|CORE_ADDR
operator|)
name|so
operator|->
name|lmend
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called by free_all_symtabs */
end_comment

begin_function
name|void
name|clear_solib
parameter_list|()
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|bfd_filename
decl_stmt|;
while|while
condition|(
name|so_list_head
condition|)
block|{
if|if
condition|(
name|so_list_head
operator|->
name|sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
operator|->
name|sections
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so_list_head
operator|->
name|abfd
condition|)
block|{
name|bfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This happens for the executable on SVR4.  */
name|bfd_filename
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|so_list_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bfd_filename
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|next
expr_stmt|;
block|}
name|debug_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	disable_break -- remove the "mapping changed" breakpoint  SYNOPSIS  	static int disable_break ()  DESCRIPTION  	Removes the breakpoint that gets hit when the dynamic linker 	completes a mapping change.  */
end_comment

begin_function
specifier|static
name|int
name|disable_break
parameter_list|()
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|int
name|in_debugger
init|=
literal|0
decl_stmt|;
comment|/* Read the debugger structure from the inferior to retrieve the      address of the breakpoint and the original contents of the      breakpoint address.  Remove the breakpoint by writing the original      contents back. */
name|read_memory
argument_list|(
name|debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set `in_debugger' to zero now. */
name|write_memory
argument_list|(
name|flag_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_debugger
argument_list|,
sizeof|sizeof
argument_list|(
name|in_debugger
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
name|breakpoint_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|debug_copy
operator|.
name|ldd_bp_addr
expr_stmt|;
name|write_memory
argument_list|(
name|breakpoint_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|ldd_bp_inst
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
operator|.
name|ldd_bp_inst
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|breakpoint_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|debug_copy
operator|.
name|dd_bpt_addr
expr_stmt|;
name|write_memory
argument_list|(
name|breakpoint_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|dd_bpt_shadow
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
operator|.
name|dd_bpt_shadow
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
comment|/* Note that breakpoint address and original contents are in our address      space, so we just need to write the original contents back. */
if|if
condition|(
name|memory_remove_breakpoint
argument_list|(
name|breakpoint_addr
argument_list|,
name|shadow_contents
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
comment|/* For the SVR4 version, we always know the breakpoint address.  For the      SunOS version we don't know it until the above code is executed.      Grumble if we are stopped anywhere besides the breakpoint address. */
if|if
condition|(
name|stop_pc
operator|!=
name|breakpoint_addr
condition|)
block|{
name|warning
argument_list|(
literal|"stopped at unknown breakpoint while handling shared libraries"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	enable_break -- arrange for dynamic linker to hit breakpoint  SYNOPSIS  	int enable_break (void)  DESCRIPTION  	Both the SunOS and the SVR4 dynamic linkers have, as part of their 	debugger interface, support for arranging for the inferior to hit 	a breakpoint after mapping in the shared libraries.  This function 	enables that breakpoint.  	For SunOS, there is a special flag location (in_debugger) which we 	set to 1.  When the dynamic linker sees this flag set, it will set 	a breakpoint at a location known only to itself, after saving the 	original contents of that place and the breakpoint address itself, 	in it's own internal structures.  When we resume the inferior, it 	will eventually take a SIGTRAP when it runs into the breakpoint. 	We handle this (in a different place) by restoring the contents of 	the breakpointed location (which is only known after it stops), 	chasing around to locate the shared libraries that have been 	loaded, then resuming.  	For SVR4, the debugger interface structure contains a member (r_brk) 	which is statically initialized at the time the shared library is 	built, to the offset of a function (_r_debug_state) which is guaran- 	teed to be called once before mapping in a library, and again when 	the mapping is complete.  At the time we are examining this member, 	it contains only the unrelocated offset of the function, so we have 	to do our own relocation.  Later, when the dynamic linker actually 	runs, it relocates r_brk to be the actual address of _r_debug_state().  	The debugger interface structure also contains an enumeration which 	is set to either RT_ADD or RT_DELETE prior to changing the mapping, 	depending upon whether or not the library is being mapped or unmapped, 	and then set to RT_CONSISTENT after the library is mapped/unmapped. */
end_comment

begin_function
specifier|static
name|int
name|enable_break
parameter_list|()
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|int
name|j
decl_stmt|;
name|int
name|in_debugger
decl_stmt|;
comment|/* Get link_dynamic structure */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* unreadable */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Calc address of debugger interface structure */
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
name|debug_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|ldd
expr_stmt|;
else|#
directive|else
name|debug_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|d_debug
expr_stmt|;
endif|#
directive|endif
comment|/* Calc address of `in_debugger' member of debugger interface structure */
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
name|flag_addr
operator|=
name|debug_addr
operator|+
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|ldd_in_debugger
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|)
expr_stmt|;
else|#
directive|else
name|flag_addr
operator|=
name|debug_addr
operator|+
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|dd_in_debugger
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write a value of 1 to this member.  */
name|in_debugger
operator|=
literal|1
expr_stmt|;
name|write_memory
argument_list|(
name|flag_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_debugger
argument_list|,
sizeof|sizeof
argument_list|(
name|in_debugger
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
ifdef|#
directive|ifdef
name|BKPT_AT_SYMBOL
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
modifier|*
name|bkpt_namep
decl_stmt|;
name|CORE_ADDR
name|bkpt_addr
decl_stmt|;
comment|/* Scan through the list of symbols, trying to look up the symbol and      set a breakpoint there.  Terminate loop when we/if we succeed. */
name|breakpoint_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bkpt_namep
operator|=
name|bkpt_names
init|;
operator|*
name|bkpt_namep
operator|!=
name|NULL
condition|;
name|bkpt_namep
operator|++
control|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
operator|*
name|bkpt_namep
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|bkpt_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_insert_breakpoint
argument_list|(
name|bkpt_addr
argument_list|,
name|shadow_contents
argument_list|)
operator|==
literal|0
condition|)
block|{
name|breakpoint_addr
operator|=
name|bkpt_addr
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|#
directive|else
comment|/* !BKPT_AT_SYMBOL */
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
comment|/* Read the debugger interface structure directly. */
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set breakpoint at the debugger interface stub routine that will      be called just prior to each mapping change and again after the      mapping change is complete.  Set up the (nonexistent) handler to      deal with hitting these breakpoints.  (FIXME). */
name|warning
argument_list|(
literal|"'%s': line %d: missing SVR4 support code"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* BKPT_AT_SYMBOL */
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    GLOBAL FUNCTION    	solib_create_inferior_hook -- shared library startup support    SYNOPSIS    	void solib_create_inferior_hook()    DESCRIPTION    	When gdb starts up the inferior, it nurses it along (through the 	shell) until it is ready to execute it's first instruction.  At this 	point, this function gets called via expansion of the macro 	SOLIB_CREATE_INFERIOR_HOOK.  	For SunOS executables, this first instruction is typically the 	one at "_start", or a similar text label, regardless of whether 	the executable is statically or dynamically linked.  The runtime 	startup code takes care of dynamically linking in any shared 	libraries, once gdb allows the inferior to continue.  	For SVR4 executables, this first instruction is either the first 	instruction in the dynamic linker (for dynamically linked 	executables) or the instruction at "start" for statically linked 	executables.  For dynamically linked executables, the system 	first exec's /lib/libc.so.N, which contains the dynamic linker, 	and starts it running.  The dynamic linker maps in any needed 	shared libraries, maps in the actual user executable, and then 	jumps to "start" in the user executable.  	For both SunOS shared libraries, and SVR4 shared libraries, we 	can arrange to cooperate with the dynamic linker to discover the 	names of shared libraries that are dynamically linked, and the 	base addresses to which they are linked.  	This function is responsible for discovering those names and 	addresses, and saving sufficient information about them to allow 	their symbols to be read at a later time.  FIXME  	Between enable_break() and disable_break(), this code does not 	properly handle hitting breakpoints which the user might have 	set in the startup code or in the dynamic linker itself.  Proper 	handling will probably have to wait until the implementation is 	changed to use the "breakpoint handler function" method.  	Also, what if child has exit()ed?  Must exit loop somehow.   */
end_comment

begin_function
name|void
name|solib_create_inferior_hook
parameter_list|()
block|{
comment|/* If we are using the BKPT_AT_SYMBOL code, then we don't need the base      yet.  In fact, in the case of a SunOS4 executable being run on      Solaris, we can't get it yet.  find_solib will get it when it needs      it.  */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|SVR4_SHARED_LIBS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BKPT_AT_SYMBOL
argument_list|)
operator|)
if|if
condition|(
operator|(
name|debug_base
operator|=
name|locate_base
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't find the symbol or the executable is statically linked. */
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|enable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to enable breakpoint"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now run the target.  It will eventually hit the breakpoint, at      which point all of the libraries will have been mapped in and we      can go groveling around in the dynamic linker structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|SIGTRAP
condition|)
do|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
comment|/* We are now either at the "mapping complete" breakpoint (or somewhere      else, a condition we aren't prepared to deal with anyway), so adjust      the PC as necessary after a breakpoint, disable the breakpoint, and      add any shared libraries that were mapped in. */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|disable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to disable breakpoint"
argument_list|)
expr_stmt|;
block|}
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	special_symbol_handling -- additional shared library symbol handling  SYNOPSIS  	void special_symbol_handling (struct so_list *so)  DESCRIPTION  	Once the symbols from a shared object have been loaded in the usual 	way, we are called to do any system specific symbol handling that  	is needed.  	For Suns, this consists of grunging around in the dynamic linkers 	structures to find symbol definitions for "common" symbols and  	adding them to the minimal symbol table for the corresponding 	objfile.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol_handling
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|int
name|j
decl_stmt|;
if|if
condition|(
name|debug_addr
operator|==
literal|0
condition|)
block|{
comment|/* Get link_dynamic structure */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* unreadable */
return|return;
block|}
comment|/* Calc address of debugger interface structure */
comment|/* FIXME, this needs work for cross-debugging of core files 	 (byteorder, size, alignment, etc).  */
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
name|debug_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|ldd
expr_stmt|;
else|#
directive|else
name|debug_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|d_debug
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Read the debugger structure from the inferior, just to make sure      we have a current copy. */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
return|return;
comment|/* unreadable */
comment|/* Get common symbol definitions for the loaded object. */
ifdef|#
directive|ifdef
name|OLD_FreeBSD_LD
if|if
condition|(
name|debug_copy
operator|.
name|ldd_cp
condition|)
block|{
name|solib_add_common_symbols
argument_list|(
name|debug_copy
operator|.
name|ldd_cp
argument_list|,
name|so
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|debug_copy
operator|.
name|dd_cc
condition|)
block|{
name|solib_add_common_symbols
argument_list|(
name|debug_copy
operator|.
name|dd_cc
argument_list|,
name|so
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	sharedlibrary_command -- handle command to explicitly add library  SYNOPSIS  	static void sharedlibrary_command (char *args, int from_tty)  DESCRIPTION  */
end_comment

begin_function
specifier|static
name|void
name|sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|info_sharedlibrary_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

