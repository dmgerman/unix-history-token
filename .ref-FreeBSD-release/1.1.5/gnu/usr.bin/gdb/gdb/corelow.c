begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions below target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|core_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|solib_add_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|core_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_core_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Discard all vestiges of any previous core file    and mark data and stack spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|core_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* Avoid confusion from thread stuff */
if|if
condition|(
name|core_bfd
condition|)
block|{
name|free
argument_list|(
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
name|core_bfd
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR_SOLIB
name|CLEAR_SOLIB
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|core_ops
operator|.
name|to_sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|core_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|core_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_comment
comment|/* Stub function for catch_errors around shared library hacking. */
end_comment

begin_function
specifier|static
name|int
name|solib_add_stub
parameter_list|(
name|from_tty
parameter_list|)
name|char
modifier|*
name|from_tty
decl_stmt|;
block|{
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
operator|(
name|int
operator|)
name|from_tty
argument_list|,
operator|&
name|core_ops
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_ADD */
end_comment

begin_comment
comment|/* Look for sections whose names start with `.reg/' so that we can extract the    list of threads in a core file.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_thread_list
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|reg_sect_arg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|PTR
name|reg_sect_arg
decl_stmt|;
block|{
name|int
name|thread_id
decl_stmt|;
name|asection
modifier|*
name|reg_sect
init|=
operator|(
name|asection
operator|*
operator|)
name|reg_sect_arg
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
argument_list|,
literal|".reg/"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|thread_id
operator|=
name|atoi
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|thread_id
argument_list|)
expr_stmt|;
comment|/* Warning, Will Robinson, looking at BFD private data! */
if|if
condition|(
name|asect
operator|->
name|filepos
operator|==
name|reg_sect
operator|->
name|filepos
condition|)
comment|/* Did we find .reg? */
name|inferior_pid
operator|=
name|thread_id
expr_stmt|;
comment|/* Yes, make it current */
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd */
end_comment

begin_function
name|void
name|core_open
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|siggy
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|bfd
modifier|*
name|temp_bfd
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|error
argument_list|(
name|core_bfd
condition|?
literal|"No core file specified.  (Use `detach' to stop debugging a core file.)"
else|:
literal|"No core file specified."
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|temp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|write_files
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|temp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_bfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|temp_bfd
argument_list|,
name|bfd_core
argument_list|)
condition|)
block|{
comment|/* Do it after the err msg */
name|make_cleanup
argument_list|(
name|bfd_close
argument_list|,
name|temp_bfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" is not a core dump: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Looks semi-reasonable.  Toss the old core file and work on the new.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more */
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|core_bfd
operator|=
name|temp_bfd
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|core_close
argument_list|,
name|core_bfd
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
comment|/* Find the data section */
if|if
condition|(
name|build_section_table
argument_list|(
name|core_bfd
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't find sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|p
operator|=
name|bfd_core_file_failing_command
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|printf_filtered
argument_list|(
literal|"Core was generated by `%s'.\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|siggy
operator|=
name|bfd_core_file_failing_signal
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|siggy
operator|>
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Program terminated with signal %d, %s.\n"
argument_list|,
name|siggy
argument_list|,
name|safe_strsignal
argument_list|(
name|siggy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up thread list from BFD sections. */
name|init_thread_list
argument_list|()
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
name|add_to_thread_list
argument_list|,
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".reg"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontop
condition|)
block|{
comment|/* Fetch all registers from core file */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Add symbols and section mappings for any shared libraries */
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|catch_errors
argument_list|(
name|solib_add_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|from_tty
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now, set up the frame cache, and print the top of stack */
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n\ your %s; do ``info files''"
argument_list|,
name|current_target
operator|->
name|to_longname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|core_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_core_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|sec_ptr
name|reg_sec
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|char
modifier|*
name|the_regs
decl_stmt|;
name|char
name|secname
index|[
literal|10
index|]
decl_stmt|;
comment|/* Thread support.  If inferior_pid is non-zero, then we have found a core      file with threads (or multiple processes).  In that case, we need to      use the appropriate register section, else we just use `.reg'. */
comment|/* XXX - same thing needs to be done for floating-point (.reg2) sections. */
if|if
condition|(
name|inferior_pid
condition|)
name|sprintf
argument_list|(
name|secname
argument_list|,
literal|".reg/%d"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|secname
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
name|reg_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_sec
condition|)
goto|goto
name|cant
goto|;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|)
expr_stmt|;
name|the_regs
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|,
name|the_regs
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|fetch_core_registers
argument_list|(
name|the_regs
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|reg_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cant
label|:
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't fetch registers from core file: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now do it again for the float registers, if they exist.  */
name|reg_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_sec
condition|)
block|{
name|size
operator|=
name|bfd_section_size
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|)
expr_stmt|;
name|the_regs
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|,
name|the_regs
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|fetch_core_registers
argument_list|(
name|the_regs
argument_list|,
name|size
argument_list|,
literal|2
argument_list|,
operator|(
name|unsigned
operator|)
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|reg_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't fetch register set 2 from core file: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|core_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|print_section_info
argument_list|(
name|t
argument_list|,
name|core_bfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|addr
parameter_list|,
name|contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|{ }
end_function

begin_decl_stmt
name|struct
name|target_ops
name|core_ops
init|=
block|{
literal|"core"
block|,
literal|"Local core dump file"
block|,
literal|"Use a core file as a target.  Specify the filename of the core file."
block|,
name|core_open
block|,
name|core_close
block|,
name|find_default_attach
block|,
name|core_detach
block|,
literal|0
block|,
literal|0
block|,
comment|/* resume, wait */
name|get_core_registers
block|,
literal|0
block|,
literal|0
block|,
comment|/* store_regs, prepare_to_store */
name|xfer_memory
block|,
name|core_files_info
block|,
name|ignore
block|,
name|ignore
block|,
comment|/* core_insert_breakpoint, core_remove_breakpoint, */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal stuff */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* kill, load, lookup sym */
name|find_default_create_inferior
block|,
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|core_stratum
block|,
literal|0
block|,
comment|/* next */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_corelow
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

