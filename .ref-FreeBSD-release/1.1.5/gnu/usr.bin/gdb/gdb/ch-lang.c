begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Chill language support routines for GDB, the GNU debugger.    Copyright 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"ch-lang.h"
end_include

begin_comment
comment|/* For now, Chill uses a simple mangling algorithm whereby you simply    discard everything after the occurance of two successive CPLUS_MARKER    characters to derive the demangled form. */
end_comment

begin_function
name|char
modifier|*
name|chill_demangle
parameter_list|(
name|mangled
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|{
name|char
modifier|*
name|joiner
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
name|joiner
operator|=
name|strchr
argument_list|(
name|mangled
argument_list|,
name|CPLUS_MARKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|joiner
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|joiner
operator|+
literal|1
operator|)
operator|==
name|CPLUS_MARKER
condition|)
block|{
name|demangled
operator|=
name|savestring
argument_list|(
name|mangled
argument_list|,
name|joiner
operator|-
name|mangled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|demangled
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chill_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"C'%.2x'"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.    Note that gdb maintains the length of strings without counting the    terminating null byte, while chill strings are typically written with    an explicit null byte.  So we always assume an implied null byte    until gdb is able to maintain non-null terminated strings as well    as null terminated strings (FIXME).   */
end_comment

begin_function
specifier|static
name|void
name|chill_printstr
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|force_ellipses
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_literal_form
init|=
literal|0
decl_stmt|;
name|int
name|in_control_form
init|=
literal|0
decl_stmt|;
name|int
name|need_slashslash
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
specifier|extern
name|int
name|repeat_count_threshold
decl_stmt|;
specifier|extern
name|int
name|print_max
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|chill_printchar
argument_list|(
literal|'\0'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_slashslash
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"//"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_slashslash
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
name|c
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_control_form
operator|||
name|in_literal_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"'//"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_control_form
operator|=
name|in_literal_form
operator|=
literal|0
expr_stmt|;
block|}
name|chill_printchar
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_slashslash
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|in_literal_form
condition|)
block|{
if|if
condition|(
name|in_control_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"'//"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_control_form
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_literal_form
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_control_form
condition|)
block|{
if|if
condition|(
name|in_literal_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"'//"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_literal_form
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"c'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_control_form
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.2x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_literal_form
operator|||
name|in_control_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
operator|(
name|i
operator|<
name|length
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|chill_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this 	   language, create the equivalent of a C integer type with the 	   name "<?type?>".  When all the dust settles from the type 	   reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no chill fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
comment|/* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for 	   typedefs, unrelated to anything directly in the code being compiled, 	   that have some FT_VOID types.  Just fake it for now. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<?VOID?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"BOOL"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"CHAR"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_SIGNED
argument_list|,
literal|"BYTE"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"UBYTE"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
comment|/* Chill ints are 2 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_SIGNED
argument_list|,
literal|"INT"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
comment|/* Chill ints are 2 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"UINT"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
comment|/* FIXME? */
case|case
name|FT_SIGNED_INTEGER
case|:
comment|/* FIXME? */
case|case
name|FT_LONG
case|:
comment|/* Chill longs are 4 bytes */
case|case
name|FT_SIGNED_LONG
case|:
comment|/* Chill longs are 4 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_SIGNED
argument_list|,
literal|"LONG"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
comment|/* FIXME? */
case|case
name|FT_UNSIGNED_LONG
case|:
comment|/* Chill longs are 4 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"ULONG"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"REAL"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"LONG_REAL"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of operators and their precedences for printing expressions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|chill_op_print_tab
index|[]
init|=
block|{
block|{
literal|"AND"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"OR"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"NOT"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"MOD"
block|,
name|BINOP_MOD
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"REM"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|":="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"/="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"//"
block|,
name|BINOP_CONCAT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
comment|/* FIXME: precedence? */
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The built-in types of Chill.  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_bool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_ulong
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_real
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|chill_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_chill_bool
block|,
operator|&
name|builtin_type_chill_char
block|,
operator|&
name|builtin_type_chill_long
block|,
operator|&
name|builtin_type_chill_ulong
block|,
operator|&
name|builtin_type_chill_real
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|chill_language_defn
init|=
block|{
literal|"chill"
block|,
name|language_chill
block|,
name|chill_builtin_types
block|,
name|range_check_on
block|,
name|type_check_on
block|,
name|chill_parse
block|,
comment|/* parser */
name|chill_error
block|,
comment|/* parser error function */
name|chill_printchar
block|,
comment|/* print a character constant */
name|chill_printstr
block|,
comment|/* function to print a string constant */
name|chill_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|chill_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|chill_val_print
block|,
comment|/* Print a value using appropriate syntax */
operator|&
name|BUILTIN_TYPE_LONGEST
block|,
comment|/* longest signed   integral type */
operator|&
name|BUILTIN_TYPE_UNSIGNED_LONGEST
block|,
comment|/* longest unsigned integral type */
operator|&
name|builtin_type_chill_real
block|,
comment|/* longest floating point type */
block|{
literal|""
block|,
literal|"B'"
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"O'%lo"
block|,
literal|"O'"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"D'%ld"
block|,
literal|"D'"
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"H'%lx"
block|,
literal|"H'"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|chill_op_print_tab
block|,
comment|/* expression operators for printing */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization for Chill */
end_comment

begin_function
name|void
name|_initialize_chill_language
parameter_list|()
block|{
name|builtin_type_chill_bool
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"BOOL"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"CHAR"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"LONG"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_ulong
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"ULONG"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_real
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"LONG_REAL"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|chill_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

