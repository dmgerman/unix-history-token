begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library.    Copyright (C) 1985, 1989 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* To test, compile with -Dtest.  This Dtestable feature turns this into a self-contained program  which reads a pattern, describes how it compiles,  then reads a string and searches for it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_comment
comment|/* The `emacs' switch turns on certain special matching commands  that make sense only in emacs. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* Make alloca work the best possible way.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define the syntax stuff, so we can do the \<...\> things.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Sword
end_ifndef

begin_comment
comment|/* must be non-zero in some of the tests below... */
end_comment

begin_define
define|#
directive|define
name|Sword
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYNTAX
parameter_list|(
name|c
parameter_list|)
value|re_syntax_table[c]
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTAX_TABLE
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|re_syntax_table
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|re_syntax_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_syntax_once
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|memset
argument_list|(
name|re_syntax_table
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|re_syntax_table
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'A'
init|;
name|c
operator|<=
literal|'Z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYNTAX_TABLE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_comment
comment|/* Number of failure points to allocate space for initially,  when matching.  If this number is exceeded, more space is allocated,  so it is not a hard limit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NFAILURES
end_ifndef

begin_define
define|#
directive|define
name|NFAILURES
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFAILURES */
end_comment

begin_comment
comment|/* width of a byte in bits */
end_comment

begin_define
define|#
directive|define
name|BYTEWIDTH
value|8
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SIGN_EXTEND_CHAR
end_ifndef

begin_define
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|obscure_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the precise syntax of regexp for compilation.    This provides for compatibility for various utilities    which historically have different, incompatible syntaxes.     The argument SYNTAX is a bit-mask containing the two bits    RE_NO_BK_PARENS and RE_NO_BK_VBAR.  */
end_comment

begin_function
name|int
name|re_set_syntax
parameter_list|(
name|syntax
parameter_list|)
name|int
name|syntax
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|obscure_syntax
expr_stmt|;
name|obscure_syntax
operator|=
name|syntax
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* re_compile_pattern takes a regular-expression string    and converts it into a buffer full of byte commands for matching.    PATTERN   is the address of the pattern string   SIZE      is the length of it.   BUFP	    is a  struct re_pattern_buffer *  which points to the info 	    on where to store the byte commands. 	    This structure contains a  char *  which points to the 	    actual space, which should have been obtained with malloc. 	    re_compile_pattern may use  realloc  to grow the buffer space.    The number of bytes of commands can be found out by looking in   the  struct re_pattern_buffer  that bufp pointed to,   after re_compile_pattern returns. */
end_comment

begin_define
define|#
directive|define
name|PATPUSH
parameter_list|(
name|ch
parameter_list|)
value|(*b++ = (char) (ch))
end_define

begin_define
define|#
directive|define
name|PATFETCH
parameter_list|(
name|c
parameter_list|)
define|\
value|{if (p == pend) goto end_of_pattern; \   c = * (unsigned char *) p++; \   if (translate) c = translate[c]; }
end_define

begin_define
define|#
directive|define
name|PATFETCH_RAW
parameter_list|(
name|c
parameter_list|)
define|\
value|{if (p == pend) goto end_of_pattern; \   c = * (unsigned char *) p++; }
end_define

begin_define
define|#
directive|define
name|PATUNFETCH
value|p--
end_define

begin_define
define|#
directive|define
name|EXTEND_BUFFER
define|\
value|{ char *old_buffer = bufp->buffer; \     if (bufp->allocated == (1<<16)) goto too_big; \     bufp->allocated *= 2; \     if (bufp->allocated> (1<<16)) bufp->allocated = (1<<16); \     if (!(bufp->buffer = (char *) realloc (bufp->buffer, bufp->allocated))) \       goto memory_exhausted; \     c = bufp->buffer - old_buffer; \     b += c; \     if (fixup_jump) \       fixup_jump += c; \     if (laststart) \       laststart += c; \     begalt += c; \     if (pending_exact) \       pending_exact += c; \   }
end_define

begin_decl_stmt
specifier|static
name|void
name|store_jump
argument_list|()
decl_stmt|,
name|insert_jump
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|re_compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|size
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|b
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
specifier|register
name|unsigned
name|c
decl_stmt|,
name|c1
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bufp
operator|->
name|translate
decl_stmt|;
comment|/* address of the count-byte of the most recently inserted "exactn" command.     This makes it possible to tell whether a new exact-match character     can be added to that command or requires a new "exactn" command. */
name|char
modifier|*
name|pending_exact
init|=
literal|0
decl_stmt|;
comment|/* address of the place where a forward-jump should go     to the end of the containing expression.     Each alternative of an "or", except the last, ends with a forward-jump     of this sort. */
name|char
modifier|*
name|fixup_jump
init|=
literal|0
decl_stmt|;
comment|/* address of start of the most recently finished expression.     This tells postfix * where to find the start of its operand. */
name|char
modifier|*
name|laststart
init|=
literal|0
decl_stmt|;
comment|/* In processing a repeat, 1 means zero matches is allowed */
name|char
name|zero_times_ok
decl_stmt|;
comment|/* In processing a repeat, 1 means many matches is allowed */
name|char
name|many_times_ok
decl_stmt|;
comment|/* address of beginning of regexp, or inside of last \( */
name|char
modifier|*
name|begalt
init|=
name|b
decl_stmt|;
comment|/* Stack of information saved by \( and restored by \).      Four stack elements are pushed by each \(:        First, the value of b.        Second, the value of fixup_jump.        Third, the value of regnum.        Fourth, the value of begalt.  */
name|int
name|stackb
index|[
literal|40
index|]
decl_stmt|;
name|int
modifier|*
name|stackp
init|=
name|stackb
decl_stmt|;
name|int
modifier|*
name|stacke
init|=
name|stackb
operator|+
literal|40
decl_stmt|;
name|int
modifier|*
name|stackt
decl_stmt|;
comment|/* Counts \('s as they are encountered.  Remembered for the matching \),      where it becomes the "register number" to put in the stop_memory command */
name|int
name|regnum
init|=
literal|1
decl_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|emacs
ifndef|#
directive|ifndef
name|SYNTAX_TABLE
comment|/*    * Initialize the syntax table.    */
name|init_syntax_once
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|bufp
operator|->
name|allocated
operator|==
literal|0
condition|)
block|{
name|bufp
operator|->
name|allocated
operator|=
literal|28
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|buffer
condition|)
comment|/* EXTEND_BUFFER loses when bufp->allocated is 0 */
name|bufp
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|bufp
operator|->
name|buffer
argument_list|,
literal|28
argument_list|)
expr_stmt|;
else|else
comment|/* Caller did not allocate a buffer.  Do it for him */
name|bufp
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|28
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
operator|->
name|buffer
condition|)
goto|goto
name|memory_exhausted
goto|;
name|begalt
operator|=
name|b
operator|=
name|bufp
operator|->
name|buffer
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
if|if
condition|(
name|b
operator|-
name|bufp
operator|->
name|buffer
operator|>
name|bufp
operator|->
name|allocated
operator|-
literal|10
condition|)
comment|/* Note that EXTEND_BUFFER clobbers c */
name|EXTEND_BUFFER
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_TIGHT_VBAR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|p
operator|!=
name|pend
condition|)
goto|goto
name|normal_char
goto|;
comment|/* Make operand of last vbar end before this `$'.  */
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|fixup_jump
operator|=
literal|0
expr_stmt|;
name|PATPUSH
argument_list|(
name|endline
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* $ means succeed if at end of line, but only in special contexts. 	    If randomly in the middle of a pattern, it is a normal character. */
if|if
condition|(
name|p
operator|==
name|pend
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
condition|?
operator|*
name|p
operator|==
literal|')'
else|:
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|')'
operator|)
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_VBAR
condition|?
operator|*
name|p
operator|==
literal|'|'
else|:
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'|'
operator|)
condition|)
block|{
name|PATPUSH
argument_list|(
name|endline
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal_char
goto|;
case|case
literal|'^'
case|:
comment|/* ^ means succeed if at beg of line, but only if no preceding pattern. */
if|if
condition|(
name|laststart
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'\n'
operator|&&
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_TIGHT_VBAR
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|pattern
operator|+
literal|1
operator|&&
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|PATPUSH
argument_list|(
name|begline
argument_list|)
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
block|}
else|else
name|PATPUSH
argument_list|(
name|begline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|normal_char
goto|;
name|handle_plus
label|:
case|case
literal|'*'
case|:
comment|/* If there is no previous pattern, char not special. */
if|if
condition|(
operator|!
name|laststart
operator|&&
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
comment|/* If there is a sequence of repetition chars, 	     collapse it down to equivalent to just one.  */
name|zero_times_ok
operator|=
literal|0
expr_stmt|;
name|many_times_ok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|zero_times_ok
operator||=
name|c
operator|!=
literal|'+'
expr_stmt|;
name|many_times_ok
operator||=
name|c
operator|!=
literal|'?'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|c1
decl_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|==
literal|'+'
operator|||
name|c1
operator|==
literal|'?'
operator|)
condition|)
block|{
name|PATUNFETCH
expr_stmt|;
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
block|}
comment|/* Star, etc. applied to an empty pattern is equivalent 	     to an empty pattern.  */
if|if
condition|(
operator|!
name|laststart
condition|)
break|break;
comment|/* Now we know whether 0 matches is allowed, 	     and whether 2 or more matches is allowed.  */
if|if
condition|(
name|many_times_ok
condition|)
block|{
comment|/* If more than one repetition is allowed, 		 put in a backward jump at the end.  */
name|store_jump
argument_list|(
name|b
argument_list|,
name|maybe_finalize_jump
argument_list|,
name|laststart
operator|-
literal|3
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
name|insert_jump
argument_list|(
name|on_failure_jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|3
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|zero_times_ok
condition|)
block|{
comment|/* At least one repetition required: insert before the loop 		 a skip over the initial on-failure-jump instruction */
name|insert_jump
argument_list|(
name|dummy_failure_jump
argument_list|,
name|laststart
argument_list|,
name|laststart
operator|+
literal|6
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|anychar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
while|while
condition|(
name|b
operator|-
name|bufp
operator|->
name|buffer
operator|>
name|bufp
operator|->
name|allocated
operator|-
literal|3
operator|-
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
condition|)
comment|/* Note that EXTEND_BUFFER clobbers c */
name|EXTEND_BUFFER
expr_stmt|;
name|laststart
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
name|PATPUSH
argument_list|(
name|charset_not
argument_list|)
operator|,
name|p
operator|++
expr_stmt|;
else|else
name|PATPUSH
argument_list|(
name|charset
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|PATPUSH
argument_list|(
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Clear the whole map */
name|memset
argument_list|(
name|b
argument_list|,
literal|'\0'
argument_list|,
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Read in characters and ranges, setting map bits */
while|while
condition|(
literal|1
condition|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|p
operator|!=
name|p1
operator|+
literal|1
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|<=
name|c1
condition|)
name|b
index|[
name|c
operator|/
name|BYTEWIDTH
index|]
operator||=
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|,
name|c
operator|++
expr_stmt|;
block|}
else|else
block|{
name|b
index|[
name|c
operator|/
name|BYTEWIDTH
index|]
operator||=
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
expr_stmt|;
block|}
block|}
comment|/* Discard any bitmap bytes that are all 0 at the end of the map. 	     Decrement the map-length byte too. */
while|while
condition|(
operator|(
name|int
operator|)
name|b
index|[
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|b
index|[
name|b
index|[
operator|-
literal|1
index|]
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|b
index|[
operator|-
literal|1
index|]
operator|--
expr_stmt|;
name|b
operator|+=
name|b
index|[
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_open
goto|;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_close
goto|;
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NEWLINE_OR
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_bar
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_bar
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_pattern
goto|;
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_open
label|:
if|if
condition|(
name|stackp
operator|==
name|stacke
condition|)
goto|goto
name|nesting_too_deep
goto|;
if|if
condition|(
name|regnum
operator|<
name|RE_NREGS
condition|)
block|{
name|PATPUSH
argument_list|(
name|start_memory
argument_list|)
expr_stmt|;
name|PATPUSH
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
operator|*
name|stackp
operator|++
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|fixup_jump
condition|?
name|fixup_jump
operator|-
name|bufp
operator|->
name|buffer
operator|+
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|regnum
operator|++
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|begalt
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
name|fixup_jump
operator|=
literal|0
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_close
label|:
if|if
condition|(
name|stackp
operator|==
name|stackb
condition|)
goto|goto
name|unmatched_close
goto|;
name|begalt
operator|=
operator|*
operator|--
name|stackp
operator|+
name|bufp
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackp
index|[
operator|-
literal|1
index|]
operator|<
name|RE_NREGS
condition|)
block|{
name|PATPUSH
argument_list|(
name|stop_memory
argument_list|)
expr_stmt|;
name|PATPUSH
argument_list|(
name|stackp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|stackp
operator|-=
literal|2
expr_stmt|;
name|fixup_jump
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|stackp
condition|)
name|fixup_jump
operator|=
operator|*
name|stackp
operator|+
name|bufp
operator|->
name|buffer
operator|-
literal|1
expr_stmt|;
name|laststart
operator|=
operator|*
operator|--
name|stackp
operator|+
name|bufp
operator|->
name|buffer
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_VBAR
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_bar
label|:
name|insert_jump
argument_list|(
name|on_failure_jump
argument_list|,
name|begalt
argument_list|,
name|b
operator|+
literal|6
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|fixup_jump
operator|=
name|b
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|emacs
case|case
literal|'='
case|:
name|PATPUSH
argument_list|(
name|at_dot
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|syntaxspec
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|PATPUSH
argument_list|(
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|notsyntaxspec
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|PATPUSH
argument_list|(
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
literal|'w'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|wordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|notwordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|PATPUSH
argument_list|(
name|wordbeg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|PATPUSH
argument_list|(
name|wordend
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|PATPUSH
argument_list|(
name|wordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|PATPUSH
argument_list|(
name|notwordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
name|PATPUSH
argument_list|(
name|begbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|PATPUSH
argument_list|(
name|endbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|c1
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c1
operator|>=
name|regnum
condition|)
goto|goto
name|normal_char
goto|;
for|for
control|(
name|stackt
operator|=
name|stackp
operator|-
literal|2
init|;
name|stackt
operator|>
name|stackb
condition|;
name|stackt
operator|-=
literal|4
control|)
if|if
condition|(
operator|*
name|stackt
operator|==
name|c1
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|PATPUSH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|handle_plus
goto|;
default|default:
name|normal_backsl
label|:
comment|/* You might think it would be useful for \ to mean 		 not to translate; but if we don't translate it 		 it will never match anything.  */
if|if
condition|(
name|translate
condition|)
name|c
operator|=
name|translate
index|[
name|c
index|]
expr_stmt|;
goto|goto
name|normal_char
goto|;
block|}
break|break;
default|default:
name|normal_char
label|:
if|if
condition|(
operator|!
name|pending_exact
operator|||
name|pending_exact
operator|+
operator|*
name|pending_exact
operator|+
literal|1
operator|!=
name|b
operator|||
operator|*
name|pending_exact
operator|==
literal|0177
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'^'
operator|||
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|?
operator|*
name|p
operator|==
literal|'\\'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
else|:
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
condition|)
block|{
name|laststart
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
name|exactn
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
name|b
expr_stmt|;
name|PATPUSH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|PATPUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pending_exact
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
goto|goto
name|unmatched_open
goto|;
name|bufp
operator|->
name|used
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
return|return
literal|0
return|;
name|invalid_pattern
label|:
return|return
literal|"Invalid regular expression"
return|;
name|unmatched_open
label|:
return|return
literal|"Unmatched \\("
return|;
name|unmatched_close
label|:
return|return
literal|"Unmatched \\)"
return|;
name|end_of_pattern
label|:
return|return
literal|"Premature end of regular expression"
return|;
name|nesting_too_deep
label|:
return|return
literal|"Nesting too deep"
return|;
name|too_big
label|:
return|return
literal|"Regular expression too big"
return|;
name|memory_exhausted
label|:
return|return
literal|"Memory exhausted"
return|;
block|}
end_function

begin_comment
comment|/* Store where `from' points a jump operation to jump to where `to' points.   `opcode' is the opcode to store. */
end_comment

begin_function
specifier|static
name|void
name|store_jump
parameter_list|(
name|from
parameter_list|,
name|opcode
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|char
name|opcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|from
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|from
index|[
literal|1
index|]
operator|=
operator|(
name|to
operator|-
operator|(
name|from
operator|+
literal|3
operator|)
operator|)
operator|&
literal|0377
expr_stmt|;
name|from
index|[
literal|2
index|]
operator|=
operator|(
name|to
operator|-
operator|(
name|from
operator|+
literal|3
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Open up space at char FROM, and insert there a jump to TO.    CURRENT_END gives te end of the storage no in use,    so we know how much data to copy up.    OP is the opcode of the jump to insert.     If you call this function, you must zero out pending_exact.  */
end_comment

begin_function
specifier|static
name|void
name|insert_jump
parameter_list|(
name|op
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|current_end
parameter_list|)
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|,
modifier|*
name|current_end
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|pto
init|=
name|current_end
operator|+
literal|3
decl_stmt|;
specifier|register
name|char
modifier|*
name|pfrom
init|=
name|current_end
decl_stmt|;
while|while
condition|(
name|pfrom
operator|!=
name|from
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|store_jump
argument_list|(
name|from
argument_list|,
name|op
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a pattern, compute a fastmap from it.  The fastmap records which of the (1<< BYTEWIDTH) possible characters  can start a string that matches the pattern.  This fastmap is used by re_search to skip quickly over totally implausible text.   The caller must supply the address of a (1<< BYTEWIDTH)-byte data area  as bufp->fastmap.  The other components of bufp describe the pattern to be used.  */
end_comment

begin_function
name|void
name|re_compile_fastmap
parameter_list|(
name|bufp
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|pattern
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bufp
operator|->
name|buffer
decl_stmt|;
name|int
name|size
init|=
name|bufp
operator|->
name|used
decl_stmt|;
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bufp
operator|->
name|translate
decl_stmt|;
name|unsigned
name|char
modifier|*
name|stackb
index|[
name|NFAILURES
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stackp
init|=
name|stackb
decl_stmt|;
name|memset
argument_list|(
name|fastmap
argument_list|,
literal|'\0'
argument_list|,
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
argument_list|)
expr_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|1
expr_stmt|;
name|bufp
operator|->
name|can_be_null
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
condition|)
endif|#
directive|endif
block|{
case|case
name|exactn
case|:
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|p
index|[
literal|1
index|]
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|p
index|[
literal|1
index|]
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|begline
case|:
case|case
name|before_dot
case|:
case|case
name|at_dot
case|:
case|case
name|after_dot
case|:
case|case
name|begbuf
case|:
case|case
name|endbuf
case|:
case|case
name|wordbound
case|:
case|case
name|notwordbound
case|:
case|case
name|wordbeg
case|:
case|case
name|wordend
case|:
continue|continue;
case|case
name|endline
case|:
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
literal|'\n'
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|can_be_null
operator|!=
literal|1
condition|)
name|bufp
operator|->
name|can_be_null
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|finalize_jump
case|:
case|case
name|maybe_finalize_jump
case|:
case|case
name|jump
case|:
case|case
name|dummy_failure_jump
case|:
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
name|j
operator|=
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|j
operator|+=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|+=
name|j
operator|+
literal|1
expr_stmt|;
comment|/* The 1 compensates for missing ++ above */
if|if
condition|(
name|j
operator|>
literal|0
condition|)
continue|continue;
comment|/* Jump backward reached implies we just went through 	     the body of a loop and matched nothing. 	     Opcode jumped to should be an on_failure_jump. 	     Just treat it like an ordinary jump. 	     For a * loop, it has pushed its failure point already; 	     if so, discard that as redundant.  */
if|if
condition|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|!=
name|on_failure_jump
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
name|j
operator|=
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|j
operator|+=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|+=
name|j
operator|+
literal|1
expr_stmt|;
comment|/* The 1 compensates for missing ++ above */
if|if
condition|(
name|stackp
operator|!=
name|stackb
operator|&&
operator|*
name|stackp
operator|==
name|p
condition|)
name|stackp
operator|--
expr_stmt|;
continue|continue;
case|case
name|on_failure_jump
case|:
name|j
operator|=
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|j
operator|+=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
operator|++
name|stackp
operator|=
name|p
operator|+
name|j
expr_stmt|;
continue|continue;
case|case
name|start_memory
case|:
case|case
name|stop_memory
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|duplicate
case|:
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
name|fastmap
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
case|case
name|anychar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
literal|'\n'
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|can_be_null
condition|)
return|return;
comment|/* Don't return; check the alternative paths 	     so we can set can_be_null if appropriate.  */
break|break;
case|case
name|wordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|emacs
case|case
name|syntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
name|charset
case|:
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|charset_not
case|:
comment|/* Chars beyond end of map must be allowed */
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|*
name|BYTEWIDTH
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* Get here means we have successfully found the possible starting characters 	 of one path of the pattern.  We need not follow this path any farther. 	 Instead, look at the next alternative remembered in the stack. */
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
name|p
operator|=
operator|*
name|stackp
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like re_search_2, below, but only one string is specified. */
end_comment

begin_function
name|int
name|re_search
parameter_list|(
name|pbufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|,
name|startpos
decl_stmt|,
name|range
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_search_2
argument_list|(
name|pbufp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like re_match_2 but tries first a match starting at index STARTPOS,    then at STARTPOS + 1, and so on.    RANGE is the number of places to try before giving up.    If RANGE is negative, the starting positions tried are     STARTPOS, STARTPOS - 1, etc.    It is up to the caller to make sure that range is not so large    as to take the starting position outside of the input strings.  The value returned is the position at which the match was found,  or -1 if no match was found,  or -2 if error (such as failure stack overflow).  */
end_comment

begin_function
name|int
name|re_search_2
parameter_list|(
name|pbufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|,
name|mstop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mstop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|pbufp
operator|->
name|fastmap
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pbufp
operator|->
name|translate
decl_stmt|;
name|int
name|total
init|=
name|size1
operator|+
name|size2
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* Update the fastmap now if not correct already */
if|if
condition|(
name|fastmap
operator|&&
operator|!
name|pbufp
operator|->
name|fastmap_accurate
condition|)
name|re_compile_fastmap
argument_list|(
name|pbufp
argument_list|)
expr_stmt|;
comment|/* Don't waste time in a long search for a pattern      that says it is anchored.  */
if|if
condition|(
name|pbufp
operator|->
name|used
operator|>
literal|0
operator|&&
operator|(
expr|enum
name|regexpcode
operator|)
name|pbufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|begbuf
operator|&&
name|range
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|startpos
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|range
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If a fastmap is supplied, skip quickly over characters 	 that cannot possibly be the start of a match. 	 Note, however, that if the pattern can possibly match 	 the null string, we must test it at each starting point 	 so that we take the first null string we get.  */
if|if
condition|(
name|fastmap
operator|&&
name|startpos
operator|<
name|total
operator|&&
name|pbufp
operator|->
name|can_be_null
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|range
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|lim
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|irange
init|=
name|range
decl_stmt|;
if|if
condition|(
name|startpos
operator|<
name|size1
operator|&&
name|startpos
operator|+
name|range
operator|>=
name|size1
condition|)
name|lim
operator|=
name|range
operator|-
operator|(
name|size1
operator|-
name|startpos
operator|)
expr_stmt|;
name|p
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|startpos
operator|>=
name|size1
condition|?
name|string2
operator|-
name|size1
else|:
name|string1
operator|)
index|[
name|startpos
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|translate
condition|)
block|{
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
name|translate
index|[
operator|*
name|p
operator|++
index|]
index|]
condition|)
name|range
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
operator|*
name|p
operator|++
index|]
condition|)
name|range
operator|--
expr_stmt|;
block|}
name|startpos
operator|+=
name|irange
operator|-
name|range
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|startpos
operator|>=
name|size1
condition|)
name|c
operator|=
name|string2
index|[
name|startpos
operator|-
name|size1
index|]
expr_stmt|;
else|else
name|c
operator|=
name|string1
index|[
name|startpos
index|]
expr_stmt|;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|translate
condition|?
operator|!
name|fastmap
index|[
name|translate
index|[
name|c
index|]
index|]
else|:
operator|!
name|fastmap
index|[
name|c
index|]
condition|)
goto|goto
name|advance
goto|;
block|}
block|}
if|if
condition|(
name|range
operator|>=
literal|0
operator|&&
name|startpos
operator|==
name|total
operator|&&
name|fastmap
operator|&&
name|pbufp
operator|->
name|can_be_null
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|re_match_2
argument_list|(
name|pbufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|regs
argument_list|,
name|mstop
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|val
condition|)
block|{
if|if
condition|(
name|val
operator|==
operator|-
literal|2
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|startpos
return|;
block|}
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* C_ALLOCA */
name|advance
label|:
if|if
condition|(
operator|!
name|range
condition|)
break|break;
if|if
condition|(
name|range
operator|>
literal|0
condition|)
name|range
operator|--
operator|,
name|startpos
operator|++
expr_stmt|;
else|else
name|range
operator|++
operator|,
name|startpos
operator|--
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* emacs never uses this */
end_comment

begin_function
name|int
name|re_match
parameter_list|(
name|pbufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|,
name|pos
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_match_2
argument_list|(
name|pbufp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_comment
comment|/* Maximum size of failure stack.  Beyond this, overflow is an error.  */
end_comment

begin_decl_stmt
name|int
name|re_max_failures
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|memcmp_translate
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Match the pattern described by PBUFP    against data which is the virtual concatenation of STRING1 and STRING2.    SIZE1 and SIZE2 are the sizes of the two data strings.    Start the match at position POS.    Do not consider matching past the position MSTOP.     If pbufp->fastmap is nonzero, then it had better be up to date.     The reason that the data to match are specified as two components    which are to be regarded as concatenated    is so this function can be used directly on the contents of an Emacs buffer.     -1 is returned if there is no match.  -2 is returned if there is    an error (such as match stack overflow).  Otherwise the value is the length    of the substring which was matched.  */
end_comment

begin_function
name|int
name|re_match_2
parameter_list|(
name|pbufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|,
name|mstop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mstop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pbufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pend
init|=
name|p
operator|+
name|pbufp
operator|->
name|used
decl_stmt|;
comment|/* End of first string */
name|unsigned
name|char
modifier|*
name|end1
decl_stmt|;
comment|/* End of second string */
name|unsigned
name|char
modifier|*
name|end2
decl_stmt|;
comment|/* Pointer just past last char to consider matching */
name|unsigned
name|char
modifier|*
name|end_match_1
decl_stmt|,
modifier|*
name|end_match_2
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|dend
decl_stmt|;
specifier|register
name|int
name|mcnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pbufp
operator|->
name|translate
decl_stmt|;
comment|/* Failure point stack.  Each place that can handle a failure further down the line     pushes a failure point on this stack.  It consists of two char *'s.     The first one pushed is where to resume scanning the pattern;     the second pushed is where to resume scanning the strings.     If the latter is zero, the failure point is a "dummy".     If a failure happens and the innermost failure point is dormant,     it discards that failure point and tries the next one. */
name|unsigned
name|char
modifier|*
name|initial_stack
index|[
literal|2
operator|*
name|NFAILURES
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stackb
init|=
name|initial_stack
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stackp
init|=
name|stackb
decl_stmt|,
modifier|*
modifier|*
name|stacke
init|=
operator|&
name|stackb
index|[
literal|2
operator|*
name|NFAILURES
index|]
decl_stmt|;
comment|/* Information on the "contents" of registers.      These are pointers into the input strings; they record      just what was matched (on this attempt) by some part of the pattern.      The start_memory command stores the start of a register's contents      and the stop_memory command stores the end.       At that point, regstart[regnum] points to the first character in the register,      regend[regnum] points to the first character beyond the end of the register,      regstart_seg1[regnum] is true iff regstart[regnum] points into string1,      and regend_seg1[regnum] is true iff regend[regnum] points into string1.  */
name|unsigned
name|char
modifier|*
name|regstart
index|[
name|RE_NREGS
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|regend
index|[
name|RE_NREGS
index|]
decl_stmt|;
name|unsigned
name|char
name|regstart_seg1
index|[
name|RE_NREGS
index|]
decl_stmt|,
name|regend_seg1
index|[
name|RE_NREGS
index|]
decl_stmt|;
comment|/* Set up pointers to ends of strings.      Don't allow the second string to be empty unless both are empty.  */
if|if
condition|(
operator|!
name|size2
condition|)
block|{
name|string2
operator|=
name|string1
expr_stmt|;
name|size2
operator|=
name|size1
expr_stmt|;
name|string1
operator|=
literal|0
expr_stmt|;
name|size1
operator|=
literal|0
expr_stmt|;
block|}
name|end1
operator|=
name|string1
operator|+
name|size1
expr_stmt|;
name|end2
operator|=
name|string2
operator|+
name|size2
expr_stmt|;
comment|/* Compute where to stop matching, within the two strings */
if|if
condition|(
name|mstop
operator|<=
name|size1
condition|)
block|{
name|end_match_1
operator|=
name|string1
operator|+
name|mstop
expr_stmt|;
name|end_match_2
operator|=
name|string2
expr_stmt|;
block|}
else|else
block|{
name|end_match_1
operator|=
name|end1
expr_stmt|;
name|end_match_2
operator|=
name|string2
operator|+
name|mstop
operator|-
name|size1
expr_stmt|;
block|}
comment|/* Initialize \) text positions to -1      to mark ones that no \( or \) has been seen for.  */
for|for
control|(
name|mcnt
operator|=
literal|0
init|;
name|mcnt
operator|<
sizeof|sizeof
argument_list|(
name|regend
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|regend
argument_list|)
condition|;
name|mcnt
operator|++
control|)
name|regend
index|[
name|mcnt
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* `p' scans through the pattern as `d' scans through the data.      `dend' is the end of the input string that `d' points within.      `d' is advanced into the following input string whenever necessary,      but this happens before fetching;      therefore, at the beginning of the loop,      `d' can be pointing at the end of a string,      but it cannot equal string2.  */
if|if
condition|(
name|pos
operator|<=
name|size1
condition|)
name|d
operator|=
name|string1
operator|+
name|pos
operator|,
name|dend
operator|=
name|end_match_1
expr_stmt|;
else|else
name|d
operator|=
name|string2
operator|+
name|pos
operator|-
name|size1
operator|,
name|dend
operator|=
name|end_match_2
expr_stmt|;
comment|/* Write PREFETCH; just before fetching a character with *d.  */
define|#
directive|define
name|PREFETCH
define|\
value|while (d == dend)						    \   { if (dend == end_match_2) goto fail;
comment|/* end of string2 => failure */
value|\     d = string2;
comment|/* end of string1 => advance to string2. */
value|\     dend = end_match_2; }
comment|/* This loop loops over pattern commands.      It exits by returning from the function if match is complete,      or it drops through if match fails at this starting point in the input data. */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
comment|/* End of pattern means we have succeeded! */
block|{
comment|/* If caller wants register contents data back, convert it to indices */
if|if
condition|(
name|regs
condition|)
block|{
name|regs
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|dend
operator|==
name|end_match_1
condition|)
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|d
operator|-
name|string1
expr_stmt|;
else|else
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|d
operator|-
name|string2
operator|+
name|size1
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
name|mcnt
operator|<
name|RE_NREGS
condition|;
name|mcnt
operator|++
control|)
block|{
if|if
condition|(
name|regend
index|[
name|mcnt
index|]
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|regstart_seg1
index|[
name|mcnt
index|]
condition|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
operator|-
name|string1
expr_stmt|;
else|else
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
operator|-
name|string2
operator|+
name|size1
expr_stmt|;
if|if
condition|(
name|regend_seg1
index|[
name|mcnt
index|]
condition|)
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|-
name|string1
expr_stmt|;
else|else
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|-
name|string2
operator|+
name|size1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dend
operator|==
name|end_match_1
condition|)
return|return
operator|(
name|d
operator|-
name|string1
operator|-
name|pos
operator|)
return|;
else|else
return|return
name|d
operator|-
name|string2
operator|+
name|size1
operator|-
name|pos
return|;
block|}
comment|/* Otherwise match next pattern command */
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
condition|)
endif|#
directive|endif
block|{
comment|/* \( is represented by a start_memory, \) by a stop_memory. 	    Both of those commands contain a "register number" argument. 	    The text matched within the \( and \) is recorded under that number. 	    Then, \<digit> turns into a `duplicate' command which 	    is followed by the numeric value of<digit> as the register number. */
case|case
name|start_memory
case|:
name|regstart
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|regstart_seg1
index|[
operator|*
name|p
operator|++
index|]
operator|=
operator|(
name|dend
operator|==
name|end_match_1
operator|)
expr_stmt|;
break|break;
case|case
name|stop_memory
case|:
name|regend
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|regend_seg1
index|[
operator|*
name|p
operator|++
index|]
operator|=
operator|(
name|dend
operator|==
name|end_match_1
operator|)
expr_stmt|;
break|break;
case|case
name|duplicate
case|:
block|{
name|int
name|regno
init|=
operator|*
name|p
operator|++
decl_stmt|;
comment|/* Get which register to match against */
specifier|register
name|unsigned
name|char
modifier|*
name|d2
decl_stmt|,
modifier|*
name|dend2
decl_stmt|;
name|d2
operator|=
name|regstart
index|[
name|regno
index|]
expr_stmt|;
name|dend2
operator|=
operator|(
operator|(
name|regstart_seg1
index|[
name|regno
index|]
operator|==
name|regend_seg1
index|[
name|regno
index|]
operator|)
condition|?
name|regend
index|[
name|regno
index|]
else|:
name|end_match_1
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Advance to next segment in register contents, if necessary */
while|while
condition|(
name|d2
operator|==
name|dend2
condition|)
block|{
if|if
condition|(
name|dend2
operator|==
name|end_match_2
condition|)
break|break;
if|if
condition|(
name|dend2
operator|==
name|regend
index|[
name|regno
index|]
condition|)
break|break;
name|d2
operator|=
name|string2
operator|,
name|dend2
operator|=
name|regend
index|[
name|regno
index|]
expr_stmt|;
comment|/* end of string1 => advance to string2. */
block|}
comment|/* At end of register contents => success */
if|if
condition|(
name|d2
operator|==
name|dend2
condition|)
break|break;
comment|/* Advance to next segment in data being matched, if necessary */
name|PREFETCH
expr_stmt|;
comment|/* mcnt gets # consecutive chars to compare */
name|mcnt
operator|=
name|dend
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
name|dend2
operator|-
name|d2
condition|)
name|mcnt
operator|=
name|dend2
operator|-
name|d2
expr_stmt|;
comment|/* Compare that many; failure if mismatch, else skip them. */
if|if
condition|(
name|translate
condition|?
name|memcmp_translate
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|,
name|translate
argument_list|)
else|:
name|memcmp
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|d
operator|+=
name|mcnt
operator|,
name|d2
operator|+=
name|mcnt
expr_stmt|;
block|}
block|}
break|break;
case|case
name|anychar
case|:
comment|/* fetch a data character */
name|PREFETCH
expr_stmt|;
comment|/* Match anything but a newline.  */
if|if
condition|(
operator|(
name|translate
condition|?
name|translate
index|[
operator|*
name|d
operator|++
index|]
else|:
operator|*
name|d
operator|++
operator|)
operator|==
literal|'\n'
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|charset
case|:
case|case
name|charset_not
case|:
block|{
comment|/* Nonzero for charset_not */
name|int
name|not
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset_not
condition|)
name|not
operator|=
literal|1
expr_stmt|;
comment|/* fetch a data character */
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|translate
condition|)
name|c
operator|=
name|translate
index|[
operator|*
name|d
index|]
expr_stmt|;
else|else
name|c
operator|=
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|c
operator|<
operator|*
name|p
operator|*
name|BYTEWIDTH
operator|&&
name|p
index|[
literal|1
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
name|p
operator|+=
literal|1
operator|+
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|not
condition|)
goto|goto
name|fail
goto|;
name|d
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|begline
case|:
if|if
condition|(
name|d
operator|==
name|string1
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|endline
case|:
if|if
condition|(
name|d
operator|==
name|end2
operator|||
operator|(
name|d
operator|==
name|end1
condition|?
operator|(
name|size2
operator|==
literal|0
operator|||
operator|*
name|string2
operator|==
literal|'\n'
operator|)
else|:
operator|*
name|d
operator|==
literal|'\n'
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
comment|/* "or" constructs ("|") are handled by starting each alternative 	    with an on_failure_jump that points to the start of the next alternative. 	    Each alternative except the last ends with a jump to the joining point. 	    (Actually, each jump except for the last one really jumps 	     to the following jump, because tensioning the jumps is a hassle.) */
comment|/* The start of a stupid repeat has an on_failure_jump that points 	   past the end of the repeat text. 	   This makes a failure point so that, on failure to match a repetition, 	   matching restarts past as many repetitions have been found 	   with no way to fail and look for another one.  */
comment|/* A smart repeat is similar but loops back to the on_failure_jump 	   so that each repetition makes another failure point. */
case|case
name|on_failure_jump
case|:
if|if
condition|(
name|stackp
operator|==
name|stacke
condition|)
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|stackx
decl_stmt|;
if|if
condition|(
name|stacke
operator|-
name|stackb
operator|>
name|re_max_failures
operator|*
literal|2
condition|)
return|return
operator|-
literal|2
return|;
name|stackx
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
operator|(
name|stacke
operator|-
name|stackb
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stackx
argument_list|,
name|stackb
argument_list|,
operator|(
name|stacke
operator|-
name|stackb
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|stackp
operator|=
name|stackx
operator|+
operator|(
name|stackp
operator|-
name|stackb
operator|)
expr_stmt|;
name|stacke
operator|=
name|stackx
operator|+
literal|2
operator|*
operator|(
name|stacke
operator|-
name|stackb
operator|)
expr_stmt|;
name|stackb
operator|=
name|stackx
expr_stmt|;
block|}
name|mcnt
operator|=
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|mcnt
operator|+=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|mcnt
operator|+
name|p
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|d
expr_stmt|;
break|break;
comment|/* The end of a smart repeat has an maybe_finalize_jump back. 	   Change it either to a finalize_jump or an ordinary jump. */
case|case
name|maybe_finalize_jump
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|mcnt
operator|+=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
comment|/* Compare what follows with the begining of the repeat. 	       If we can establish that there is nothing that they would 	       both match, we can change to finalize_jump */
while|while
condition|(
name|p2
operator|!=
name|pend
operator|&&
operator|(
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|stop_memory
operator|||
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|start_memory
operator|)
condition|)
name|p2
operator|++
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|pend
condition|)
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|exactn
operator|||
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|endline
condition|)
block|{
specifier|register
name|int
name|c
init|=
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|endline
condition|?
literal|'\n'
else|:
name|p2
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
init|=
name|p
operator|+
name|mcnt
decl_stmt|;
comment|/* p1[0] ... p1[2] are an on_failure_jump. 		   Examine what follows that */
if|if
condition|(
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|exactn
operator|&&
name|p1
index|[
literal|5
index|]
operator|!=
name|c
condition|)
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset
operator|||
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset_not
condition|)
block|{
name|int
name|not
init|=
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset_not
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|p1
index|[
literal|4
index|]
operator|*
name|BYTEWIDTH
operator|&&
name|p1
index|[
literal|5
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
comment|/* not is 1 if c would match */
comment|/* That means it is not safe to finalize */
if|if
condition|(
operator|!
name|not
condition|)
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
expr_stmt|;
block|}
block|}
block|}
name|p
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|jump
expr_stmt|;
goto|goto
name|nofinalize
goto|;
block|}
comment|/* The end of a stupid repeat has a finalize-jump 	   back to the start, where another failure point will be made 	   which will point after all the repetitions found so far. */
case|case
name|finalize_jump
case|:
name|stackp
operator|-=
literal|2
expr_stmt|;
case|case
name|jump
case|:
name|nofinalize
label|:
name|mcnt
operator|=
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
name|mcnt
operator|+=
name|SIGN_EXTEND_CHAR
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|+=
name|mcnt
operator|+
literal|1
expr_stmt|;
comment|/* The 1 compensates for missing ++ above */
break|break;
case|case
name|dummy_failure_jump
case|:
if|if
condition|(
name|stackp
operator|==
name|stacke
condition|)
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|stackx
init|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
operator|(
name|stacke
operator|-
name|stackb
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|stackx
argument_list|,
name|stackb
argument_list|,
operator|(
name|stacke
operator|-
name|stackb
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|stackp
operator|=
name|stackx
operator|+
operator|(
name|stackp
operator|-
name|stackb
operator|)
expr_stmt|;
name|stacke
operator|=
name|stackx
operator|+
literal|2
operator|*
operator|(
name|stacke
operator|-
name|stackb
operator|)
expr_stmt|;
name|stackb
operator|=
name|stackx
expr_stmt|;
block|}
operator|*
name|stackp
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
literal|0
expr_stmt|;
goto|goto
name|nofinalize
goto|;
case|case
name|wordbound
case|:
if|if
condition|(
name|d
operator|==
name|string1
comment|/* Points to first char */
operator|||
name|d
operator|==
name|end2
comment|/* Points to end */
operator|||
operator|(
name|d
operator|==
name|end1
operator|&&
name|size2
operator|==
literal|0
operator|)
condition|)
comment|/* Points to end */
break|break;
if|if
condition|(
operator|(
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
operator|)
operator|!=
operator|(
name|SYNTAX
argument_list|(
name|d
operator|==
name|end1
condition|?
operator|*
name|string2
else|:
operator|*
name|d
argument_list|)
operator|==
name|Sword
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|notwordbound
case|:
if|if
condition|(
name|d
operator|==
name|string1
comment|/* Points to first char */
operator|||
name|d
operator|==
name|end2
comment|/* Points to end */
operator|||
operator|(
name|d
operator|==
name|end1
operator|&&
name|size2
operator|==
literal|0
operator|)
condition|)
comment|/* Points to end */
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
operator|)
operator|!=
operator|(
name|SYNTAX
argument_list|(
name|d
operator|==
name|end1
condition|?
operator|*
name|string2
else|:
operator|*
name|d
argument_list|)
operator|==
name|Sword
operator|)
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|wordbeg
case|:
if|if
condition|(
name|d
operator|==
name|end2
comment|/* Points to end */
operator|||
operator|(
name|d
operator|==
name|end1
operator|&&
name|size2
operator|==
literal|0
operator|)
comment|/* Points to end */
operator|||
name|SYNTAX
argument_list|(
operator|*
operator|(
name|d
operator|==
name|end1
condition|?
name|string2
else|:
name|d
operator|)
argument_list|)
operator|!=
name|Sword
condition|)
comment|/* Next char not a letter */
goto|goto
name|fail
goto|;
if|if
condition|(
name|d
operator|==
name|string1
comment|/* Points to first char */
operator|||
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|Sword
condition|)
comment|/* prev char not letter */
break|break;
goto|goto
name|fail
goto|;
case|case
name|wordend
case|:
if|if
condition|(
name|d
operator|==
name|string1
comment|/* Points to first char */
operator|||
name|SYNTAX
argument_list|(
name|d
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|Sword
condition|)
comment|/* prev char not letter */
goto|goto
name|fail
goto|;
if|if
condition|(
name|d
operator|==
name|end2
comment|/* Points to end */
operator|||
operator|(
name|d
operator|==
name|end1
operator|&&
name|size2
operator|==
literal|0
operator|)
comment|/* Points to end */
operator|||
name|SYNTAX
argument_list|(
name|d
operator|==
name|end1
condition|?
operator|*
name|string2
else|:
operator|*
name|d
argument_list|)
operator|!=
name|Sword
condition|)
comment|/* Next char not a letter */
break|break;
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
if|if
condition|(
operator|(
operator|(
name|d
operator|-
name|string2
operator|<=
operator|(
name|unsigned
operator|)
name|size2
operator|)
condition|?
name|d
operator|-
name|bf_p2
else|:
name|d
operator|-
name|bf_p1
operator|)
operator|<=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|at_dot
case|:
if|if
condition|(
operator|(
operator|(
name|d
operator|-
name|string2
operator|<=
operator|(
name|unsigned
operator|)
name|size2
operator|)
condition|?
name|d
operator|-
name|bf_p2
else|:
name|d
operator|-
name|bf_p1
operator|)
operator|==
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|after_dot
case|:
if|if
condition|(
operator|(
operator|(
name|d
operator|-
name|string2
operator|<=
operator|(
name|unsigned
operator|)
name|size2
operator|)
condition|?
name|d
operator|-
name|bf_p2
else|:
name|d
operator|-
name|bf_p1
operator|)
operator|>=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|wordchar
case|:
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
goto|goto
name|matchsyntax
goto|;
case|case
name|syntaxspec
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|matchsyntax
label|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
operator|*
name|d
operator|++
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|notwordchar
case|:
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
goto|goto
name|matchnotsyntax
goto|;
case|case
name|notsyntaxspec
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|matchnotsyntax
label|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
operator|*
name|d
operator|++
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
break|break;
else|#
directive|else
case|case
name|wordchar
case|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
operator|*
name|d
operator|++
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|notwordchar
case|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
operator|*
name|d
operator|++
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
endif|#
directive|endif
comment|/* not emacs */
case|case
name|begbuf
case|:
if|if
condition|(
name|d
operator|==
name|string1
condition|)
comment|/* Note, d cannot equal string2 */
break|break;
comment|/* unless string1 == string2.  */
goto|goto
name|fail
goto|;
case|case
name|endbuf
case|:
if|if
condition|(
name|d
operator|==
name|end2
operator|||
operator|(
name|d
operator|==
name|end1
operator|&&
name|size2
operator|==
literal|0
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|exactn
case|:
comment|/* Match the next few pattern characters exactly. 	     mcnt is how many characters to match. */
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|translate
condition|)
block|{
do|do
block|{
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|translate
index|[
operator|*
name|d
operator|++
index|]
operator|!=
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|PREFETCH
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|++
operator|!=
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
break|break;
block|}
continue|continue;
comment|/* Successfully matched one pattern command; keep matching */
comment|/* Jump here if any matching operation fails. */
name|fail
label|:
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
comment|/* A restart point is known.  Restart there and pop it. */
block|{
if|if
condition|(
operator|!
name|stackp
index|[
operator|-
literal|2
index|]
condition|)
block|{
comment|/* If innermost failure point is dormant, flush it and keep looking */
name|stackp
operator|-=
literal|2
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|d
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
name|p
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|string1
operator|&&
name|d
operator|<=
name|end1
condition|)
name|dend
operator|=
name|end_match_1
expr_stmt|;
block|}
else|else
break|break;
comment|/* Matching at this starting point really fails! */
block|}
return|return
operator|-
literal|1
return|;
comment|/* Failure to match */
block|}
end_block

begin_function
specifier|static
name|int
name|memcmp_translate
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|,
name|translate
parameter_list|)
name|unsigned
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p1
init|=
name|s1
decl_stmt|,
modifier|*
name|p2
init|=
name|s2
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|translate
index|[
operator|*
name|p1
operator|++
index|]
operator|!=
name|translate
index|[
operator|*
name|p2
operator|++
index|]
condition|)
return|return
literal|1
return|;
name|len
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with bsd4.2 regex library */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|re_comp_buf
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|re_comp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
return|return
literal|"No previous regular expression"
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|re_comp_buf
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|200
argument_list|)
operator|)
condition|)
return|return
literal|"Memory exhausted"
return|;
name|re_comp_buf
operator|.
name|allocated
operator|=
literal|200
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|re_comp_buf
operator|.
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
operator|)
condition|)
return|return
literal|"Memory exhausted"
return|;
block|}
return|return
name|re_compile_pattern
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|re_comp_buf
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|re_exec
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
name|s
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|test
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Indexed by a character, gives the upper case equivalent of the character */
end_comment

begin_decl_stmt
specifier|static
name|char
name|upcase
index|[
literal|0400
index|]
init|=
block|{
literal|000
block|,
literal|001
block|,
literal|002
block|,
literal|003
block|,
literal|004
block|,
literal|005
block|,
literal|006
block|,
literal|007
block|,
literal|010
block|,
literal|011
block|,
literal|012
block|,
literal|013
block|,
literal|014
block|,
literal|015
block|,
literal|016
block|,
literal|017
block|,
literal|020
block|,
literal|021
block|,
literal|022
block|,
literal|023
block|,
literal|024
block|,
literal|025
block|,
literal|026
block|,
literal|027
block|,
literal|030
block|,
literal|031
block|,
literal|032
block|,
literal|033
block|,
literal|034
block|,
literal|035
block|,
literal|036
block|,
literal|037
block|,
literal|040
block|,
literal|041
block|,
literal|042
block|,
literal|043
block|,
literal|044
block|,
literal|045
block|,
literal|046
block|,
literal|047
block|,
literal|050
block|,
literal|051
block|,
literal|052
block|,
literal|053
block|,
literal|054
block|,
literal|055
block|,
literal|056
block|,
literal|057
block|,
literal|060
block|,
literal|061
block|,
literal|062
block|,
literal|063
block|,
literal|064
block|,
literal|065
block|,
literal|066
block|,
literal|067
block|,
literal|070
block|,
literal|071
block|,
literal|072
block|,
literal|073
block|,
literal|074
block|,
literal|075
block|,
literal|076
block|,
literal|077
block|,
literal|0100
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0133
block|,
literal|0134
block|,
literal|0135
block|,
literal|0136
block|,
literal|0137
block|,
literal|0140
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0173
block|,
literal|0174
block|,
literal|0175
block|,
literal|0176
block|,
literal|0177
block|,
literal|0200
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|0205
block|,
literal|0206
block|,
literal|0207
block|,
literal|0210
block|,
literal|0211
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|0215
block|,
literal|0216
block|,
literal|0217
block|,
literal|0220
block|,
literal|0221
block|,
literal|0222
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|0227
block|,
literal|0230
block|,
literal|0231
block|,
literal|0232
block|,
literal|0233
block|,
literal|0234
block|,
literal|0235
block|,
literal|0236
block|,
literal|0237
block|,
literal|0240
block|,
literal|0241
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0251
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0300
block|,
literal|0301
block|,
literal|0302
block|,
literal|0303
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0312
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0320
block|,
literal|0321
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0340
block|,
literal|0341
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0350
block|,
literal|0351
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0356
block|,
literal|0357
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|pat
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|fastmap
index|[
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
index|]
decl_stmt|;
comment|/* Allow a command argument to specify the style of syntax.  */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|obscure_syntax
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|40
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|buf
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|gets
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pat
condition|)
block|{
name|re_compile_pattern
argument_list|(
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|.
name|used
condition|;
name|i
operator|++
control|)
name|printchar
argument_list|(
name|buf
operator|.
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d allocated, %d used.\n"
argument_list|,
name|buf
operator|.
name|allocated
argument_list|,
name|buf
operator|.
name|used
argument_list|)
expr_stmt|;
name|re_compile_fastmap
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Allowed by fastmap: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fastmap
index|[
name|i
index|]
condition|)
name|printchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|gets
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Now read the string to match against */
name|i
operator|=
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Match value %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_macro
name|print_buf
argument_list|(
argument|bufp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"buf is :\n----------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufp
operator|->
name|used
condition|;
name|i
operator|++
control|)
name|printchar
argument_list|(
name|bufp
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%d allocated, %d used.\n"
argument_list|,
name|bufp
operator|->
name|allocated
argument_list|,
name|bufp
operator|->
name|used
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Allowed by fastmap: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bufp
operator|->
name|fastmap
index|[
name|i
index|]
condition|)
name|printchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAllowed by translate: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|translate
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bufp
operator|->
name|translate
index|[
name|i
index|]
condition|)
name|printchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nfastmap is%s accurate\n"
argument_list|,
name|bufp
operator|->
name|fastmap_accurate
condition|?
literal|""
else|:
literal|"n't"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can %s be null\n----------"
argument_list|,
name|bufp
operator|->
name|can_be_null
condition|?
literal|""
else|:
literal|"not"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|printchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|<
literal|041
operator|||
name|c
operator|>=
literal|0177
condition|)
block|{
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|puts
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* test */
end_comment

end_unit

