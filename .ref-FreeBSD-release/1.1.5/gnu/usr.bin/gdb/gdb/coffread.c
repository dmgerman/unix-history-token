begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read coff symbol tables and convert to internal format, for GDB.    Contributed by David D. Johnson, Brown University (ddj@cs.brown.edu).    Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1993    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* For time_t in libbfd.h.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* For time_t, if not in time.h.  */
end_comment

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* FIXME secret internal data from BFD */
end_comment

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* Internal format of COFF symbols in BFD */
end_comment

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* FIXME secret internal data from BFD */
end_comment

begin_struct
struct|struct
name|coff_symfile_info
block|{
name|file_ptr
name|min_lineno_offset
decl_stmt|;
comment|/* Where in file lowest line#s are */
name|file_ptr
name|max_lineno_offset
decl_stmt|;
comment|/* 1+last byte of line#s in file */
name|asection
modifier|*
name|stabsect
decl_stmt|;
comment|/* Section pointer for .stab section */
name|asection
modifier|*
name|stabstrsect
decl_stmt|;
comment|/* Section pointer for .stab section */
name|asection
modifier|*
name|stabindexsect
decl_stmt|;
comment|/* Section pointer for .stab.index section */
name|char
modifier|*
name|stabstrdata
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Translate an external name string into a user-visible name.  */
end_comment

begin_define
define|#
directive|define
name|EXTERNAL_NAME
parameter_list|(
name|string
parameter_list|,
name|abfd
parameter_list|)
define|\
value|(string[0] == bfd_get_symbol_leading_char(abfd)? string+1: string)
end_define

begin_comment
comment|/* To be an sdb debug type, type must have at least a basic or primary    derived type.  Using this rather than checking against T_NULL is    said to prevent core dumps if we try to operate on Michael Bloom    dbx-in-coff file.  */
end_comment

begin_define
define|#
directive|define
name|SDB_TYPE
parameter_list|(
name|type
parameter_list|)
value|(BTYPE(type) | (type& N_TMASK))
end_define

begin_comment
comment|/*  * Convert from an sdb register number to an internal gdb register number.  * This should be defined in tm.h, if REGISTER_NAMES is not set up  * to map one to one onto the sdb register numbers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|SDB_REG_TO_REGNUM
parameter_list|(
name|value
parameter_list|)
value|(value)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Core address of start and end of text of current source file.    This comes from a ".text" symbol where x_nlinno> 0.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cur_src_start_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cur_src_end_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of the end of the first object file.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|first_object_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The addresses of the symbol table stream and number of symbols    of the object file we are reading (as copied into core).  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|nlist_stream_global
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlist_nsyms_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|line_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of next entry to go in line_vector_index.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line number recorded in the line vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for line_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to scratch storage, used for reading raw symbols and auxents.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_aux
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables that hold the shift and mask values for the    COFF file that we are currently reading.  These come back to us    from BFD, and are referenced by their macro names, as well as    internally to the BTYPE, ISPTR, ISFCN, ISARY, ISTAG, and DECREF    macros from ../internalcoff.h .  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_btmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_btshft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_tmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_tshift
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_BTMASK
value|local_n_btmask
end_define

begin_define
define|#
directive|define
name|N_BTSHFT
value|local_n_btshft
end_define

begin_define
define|#
directive|define
name|N_TMASK
value|local_n_tmask
end_define

begin_define
define|#
directive|define
name|N_TSHIFT
value|local_n_tshift
end_define

begin_comment
comment|/* Local variables that hold the sizes in the file of various COFF structures.    (We only need to know this to read them from the file -- BFD will then    translate the data in them, into `internal_xxx' structs in the right    byte order, alignment, etc.)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_linesz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_symesz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_auxesz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of typedefs of pointers to empty struct/union types.    They are chained thru the SYMBOL_VALUE_CHAIN.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|opaque_type_chain
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The type of the function we are currently reading in.  This is    used by define_symbol to record the type of arguments to a function. */
end_comment

begin_endif
unit|struct type *in_function_type;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|pending_block
modifier|*
name|pending_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complaints about various problems in the file being read  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|ef_complaint
init|=
block|{
literal|"Unmatched .ef symbol(s) ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bf_no_aux_complaint
init|=
block|{
literal|"`.bf' symbol %d has no aux entry"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|ef_no_aux_complaint
init|=
block|{
literal|"`.ef' symbol %d has no aux entry"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lineno_complaint
init|=
block|{
literal|"Line number pointer %d lower than start of line numbers"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unexpected_type_complaint
init|=
block|{
literal|"Unexpected type for symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_sclass_complaint
init|=
block|{
literal|"Bad n_sclass for symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|misordered_blocks_complaint
init|=
block|{
literal|"Blocks out of order at address %x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|tagndx_bad_complaint
init|=
block|{
literal|"Symbol table entry for %s has bad tagndx value"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|eb_complaint
init|=
block|{
literal|"Mismatched .eb symbol ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simplified internal version of coff symbol table information */
end_comment

begin_struct
struct|struct
name|coff_symbol
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
name|int
name|c_symnum
decl_stmt|;
comment|/* symbol number of this entry */
name|int
name|c_naux
decl_stmt|;
comment|/* 0 if syment only, 1 if syment + auxent, etc */
name|long
name|c_value
decl_stmt|;
name|int
name|c_sclass
decl_stmt|;
name|int
name|c_secnum
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|coff_read_struct_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_base_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_function_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|coff_read_enum_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|process_coff_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_opaque_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enter_linenos
name|PARAMS
argument_list|(
operator|(
name|long
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_linetab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_lineno
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getfilename
name|PARAMS
argument_list|(
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getsymname
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_stringtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_stringtab
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_one_sym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_coff_symtab
name|PARAMS
argument_list|(
operator|(
name|long
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_linenos
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|enum
name|minimal_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_end_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|complete_symtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_start_symtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_record_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|coff_alloc_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|coff_lookup_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|coff_locate_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We are called once per section from coff_symfile_read.  We    need to examine each section we are passed, check to see    if it is something we are interested in processing, and    if so, stash away some access information for the section.     FIXME: The section names should not be hardwired strings (what    should they be?  I don't think most object file formats have enough    section flags to specify what kind of debug section it is    -kingdon).  */
end_comment

begin_function
specifier|static
name|void
name|coff_locate_sections
parameter_list|(
name|ignore_abfd
parameter_list|,
name|sectp
parameter_list|,
name|csip
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asection
modifier|*
name|sectp
decl_stmt|;
name|PTR
name|csip
decl_stmt|;
block|{
specifier|register
name|struct
name|coff_symfile_info
modifier|*
name|csi
decl_stmt|;
name|csi
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|csip
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|)
condition|)
block|{
name|csi
operator|->
name|stabsect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".stabstr"
argument_list|)
condition|)
block|{
name|csi
operator|->
name|stabstrsect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".stab.index"
argument_list|)
condition|)
block|{
name|csi
operator|->
name|stabindexsect
operator|=
name|sectp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up a coff type-number index.  Return the address of the slot    where the type for that index is stored.    The type-number is in INDEX.      This can be used for finding the type associated with that index    or for associating a new type with the index.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|coff_lookup_type
parameter_list|(
name|index
parameter_list|)
specifier|register
name|int
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|int
name|old_vector_length
init|=
name|type_vector_length
decl_stmt|;
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|index
comment|/* is still */
operator|>=
name|type_vector_length
condition|)
block|{
name|type_vector_length
operator|=
name|index
operator|*
literal|2
expr_stmt|;
block|}
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_vector
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|type_vector
index|[
name|old_vector_length
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|type_vector_length
operator|-
name|old_vector_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|type_vector
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type number index    and return the type object.    This can create an empty (zeroed) type object.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_alloc_type
parameter_list|(
name|index
parameter_list|)
name|int
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
modifier|*
name|type_addr
init|=
name|coff_lookup_type
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
operator|*
name|type_addr
decl_stmt|;
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|type
operator|=
name|alloc_type
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
operator|*
name|type_addr
operator|=
name|type
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a line number entry for line LINE at address PC.    FIXME:  Use record_line instead.  */
end_comment

begin_function
specifier|static
name|void
name|coff_record_line
parameter_list|(
name|line
parameter_list|,
name|pc
parameter_list|)
name|int
name|line
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Make sure line vector is big enough.  */
if|if
condition|(
name|line_vector_index
operator|+
literal|2
operator|>=
name|line_vector_length
condition|)
block|{
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_vector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|line_vector
operator|->
name|item
operator|+
name|line_vector_index
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.    This is called when a COFF ".file" symbol is seen;    it indicates the start of data for one original source file.  */
end_comment

begin_function
specifier|static
name|void
name|coff_start_symtab
parameter_list|()
block|{
name|start_symtab
argument_list|(
comment|/* We fill in the filename later.  start_symtab 		   puts this pointer into last_source file and in 		   coff_end_symtab we assume we can free() it. 		   FIXME: leaks memory.  */
name|savestring
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|,
comment|/* We never know the directory name for COFF.  */
name|NULL
argument_list|,
comment|/* The start address is irrelevant, since we set 		   last_source_start_addr in coff_end_symtab.  */
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the source file line number information for this file.  */
if|if
condition|(
name|line_vector
condition|)
comment|/* Unlikely, but maybe possible? */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|line_vector
argument_list|)
expr_stmt|;
name|line_vector_index
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
literal|1000
expr_stmt|;
name|prev_line_number
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Force first line number to be explicit */
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the vital information from when starting to read a file,    for use when closing off the current file.    NAME is the file name the symbols came from, START_ADDR is the first    text address for the file, and SIZE is the number of bytes of text.  */
end_comment

begin_function
specifier|static
name|void
name|complete_symtab
parameter_list|(
name|name
parameter_list|,
name|start_addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|last_source_file
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|cur_src_start_addr
operator|=
name|start_addr
expr_stmt|;
name|cur_src_end_addr
operator|=
name|start_addr
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|current_objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|cur_src_start_addr
operator|&&
name|current_objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|cur_src_end_addr
condition|)
block|{
name|current_objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|cur_src_start_addr
expr_stmt|;
name|current_objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|cur_src_end_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file,    close off all the lexical contexts for that file    (creating struct block's for them), then make the    struct symtab for that file and put it in the list of all such. */
end_comment

begin_function
specifier|static
name|void
name|coff_end_symtab
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|last_source_start_addr
operator|=
name|cur_src_start_addr
expr_stmt|;
comment|/* For no good reason, this file stores the number of entries in a      separate variable instead of in line_vector->nitems.  Fix it.  */
if|if
condition|(
name|line_vector
condition|)
name|line_vector
operator|->
name|nitems
operator|=
name|line_vector_index
expr_stmt|;
comment|/* For COFF, we only have one subfile, so we can just look at      subfiles and not worry about there being other elements in the      chain.  We fill in various fields now because we didn't know them      before (or because doing it now is simply an artifact of how this      file used to be written).  */
name|subfiles
operator|->
name|line_vector
operator|=
name|line_vector
expr_stmt|;
name|subfiles
operator|->
name|name
operator|=
name|last_source_file
expr_stmt|;
comment|/* sort_pending is needed for amdcoff, at least.      sort_linevec is needed for the SCO compiler.  */
name|symtab
operator|=
name|end_symtab
argument_list|(
name|cur_src_end_addr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|free_named_symtabs
argument_list|(
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Reinitialize for beginning of new file. */
name|line_vector
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|type
decl_stmt|;
block|{
comment|/* We don't want TDESC entry points in the minimal symbol table */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
return|return;
name|prim_record_minimal_symbol
argument_list|(
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|address
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* coff_symfile_init ()    is the coff-specific initialization routine for reading symbols.    It is passed a struct objfile which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for    a pointer to "private data" which we fill with cookies and other    treats for coff_symfile_read ().     We will only be called if this is a COFF or COFF-like file.    BFD handles figuring out the format of the file, and code in symtab.c    uses BFD's determination to vector to us.     The ultimate result is a new symtab (or, FIXME, eventually a psymtab).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|text_bfd_scnum
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|,
modifier|*
name|strsection
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
comment|/* Allocate struct to keep track of stab reading. */
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
name|PTR
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|sym_stab_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|sym_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Save the section number for the text section */
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
condition|)
name|text_bfd_scnum
operator|=
name|section
operator|->
name|index
expr_stmt|;
else|else
name|text_bfd_scnum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called for every section; it finds the outer limits    of the line table (minimum and maximum file offset) so that the    mainline code can read the whole thing for efficiency.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|find_linenos
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|vpinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|vpinfo
decl_stmt|;
block|{
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|,
name|count
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|,
name|maxoff
decl_stmt|;
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|count
operator|=
name|asect
operator|->
name|lineno_count
expr_stmt|;
comment|/* End of warning */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
name|count
operator|*
name|local_linesz
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|vpinfo
expr_stmt|;
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|offset
operator|=
name|asect
operator|->
name|line_filepos
expr_stmt|;
comment|/* End of warning */
if|if
condition|(
name|offset
operator|<
name|info
operator|->
name|min_lineno_offset
operator|||
name|info
operator|->
name|min_lineno_offset
operator|==
literal|0
condition|)
name|info
operator|->
name|min_lineno_offset
operator|=
name|offset
expr_stmt|;
name|maxoff
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|maxoff
operator|>
name|info
operator|->
name|max_lineno_offset
condition|)
name|info
operator|->
name|max_lineno_offset
operator|=
name|maxoff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The BFD for this file -- only good while we're actively reading    symbols into a psymtab or a symtab.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read a symbol file, after initialization by coff_symfile_init.  */
end_comment

begin_comment
comment|/* FIXME!  Addr and Mainline are not used yet -- this will not work for    shared libraries or add_file!  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|coff_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|dbxinfo
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|coff_data_type
modifier|*
name|cdata
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|desc
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|num_symbols
decl_stmt|;
name|int
name|symtab_offset
decl_stmt|;
name|int
name|stringtab_offset
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|int
name|stabsize
decl_stmt|,
name|stabstrsize
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
expr_stmt|;
name|dbxinfo
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_stab_info
expr_stmt|;
name|symfile_bfd
operator|=
name|abfd
expr_stmt|;
comment|/* Kludge for swap routines */
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|desc
operator|=
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
argument_list|)
expr_stmt|;
comment|/* File descriptor */
name|num_symbols
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* How many syms */
name|symtab_offset
operator|=
name|cdata
operator|->
name|sym_filepos
expr_stmt|;
comment|/* Symbol table file offset */
name|stringtab_offset
operator|=
name|symtab_offset
operator|+
comment|/* String table file offset */
name|num_symbols
operator|*
name|cdata
operator|->
name|local_symesz
expr_stmt|;
comment|/* Set a few file-statics that give us specific information about      the particular COFF file format we're reading.  */
name|local_linesz
operator|=
name|cdata
operator|->
name|local_linesz
expr_stmt|;
name|local_n_btmask
operator|=
name|cdata
operator|->
name|local_n_btmask
expr_stmt|;
name|local_n_btshft
operator|=
name|cdata
operator|->
name|local_n_btshft
expr_stmt|;
name|local_n_tmask
operator|=
name|cdata
operator|->
name|local_n_tmask
expr_stmt|;
name|local_n_tshift
operator|=
name|cdata
operator|->
name|local_n_tshift
expr_stmt|;
name|local_linesz
operator|=
name|cdata
operator|->
name|local_linesz
expr_stmt|;
name|local_symesz
operator|=
name|cdata
operator|->
name|local_symesz
expr_stmt|;
name|local_auxesz
operator|=
name|cdata
operator|->
name|local_auxesz
expr_stmt|;
comment|/* Allocate space for raw symbol and aux entries, based on their      space requirements as reported by BFD.  */
name|temp_sym
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|cdata
operator|->
name|local_symesz
operator|+
name|cdata
operator|->
name|local_auxesz
argument_list|)
expr_stmt|;
name|temp_aux
operator|=
name|temp_sym
operator|+
name|cdata
operator|->
name|local_symesz
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|temp_sym
argument_list|)
expr_stmt|;
comment|/* End of warning */
comment|/* Read the line number table, all at once.  */
name|info
operator|->
name|min_lineno_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|max_lineno_offset
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_linenos
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_linetab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|init_lineno
argument_list|(
name|desc
argument_list|,
name|info
operator|->
name|min_lineno_offset
argument_list|,
name|info
operator|->
name|max_lineno_offset
operator|-
name|info
operator|->
name|min_lineno_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": error reading line numbers\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Now read the string table, all at once.  */
name|make_cleanup
argument_list|(
name|free_stringtab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|init_stringtab
argument_list|(
name|desc
argument_list|,
name|stringtab_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't get string table"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly.  */
name|read_coff_symtab
argument_list|(
operator|(
name|long
operator|)
name|symtab_offset
argument_list|,
name|num_symbols
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Sort symbols alphabetically within each block.  */
name|sort_all_symtab_syms
argument_list|()
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|coff_locate_sections
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|stabsect
condition|)
block|{
comment|/* FIXME: dubious.  Why can't we use something normal like 	 bfd_get_section_contents?  */
name|fseek
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|,
name|abfd
operator|->
name|where
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabsize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabsect
argument_list|)
expr_stmt|;
name|stabstrsize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabstrsect
argument_list|)
expr_stmt|;
name|coffstab_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|,
name|info
operator|->
name|stabsect
operator|->
name|filepos
argument_list|,
name|stabsize
argument_list|,
name|info
operator|->
name|stabstrsect
operator|->
name|filepos
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|coff_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|coff_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given pointers to a symbol table in coff style exec file,    analyze them and create struct symtab's describing the symbols.    NSYMS is the number of symbols in the symbol table.    We read them one at a time using read_one_sym ().  */
end_comment

begin_function
specifier|static
name|void
name|read_coff_symtab
parameter_list|(
name|symtab_offset
parameter_list|,
name|nsyms
parameter_list|,
name|objfile
parameter_list|)
name|long
name|symtab_offset
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|struct
name|coff_symbol
name|coff_symbol
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
init|=
operator|&
name|coff_symbol
decl_stmt|;
specifier|static
name|struct
name|internal_syment
name|main_sym
decl_stmt|;
specifier|static
name|union
name|internal_auxent
name|main_aux
decl_stmt|;
name|struct
name|coff_symbol
name|fcn_cs_saved
decl_stmt|;
specifier|static
name|struct
name|internal_syment
name|fcn_sym_saved
decl_stmt|;
specifier|static
name|union
name|internal_auxent
name|fcn_aux_saved
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
comment|/* A .file is open.  */
name|int
name|in_source_file
init|=
literal|0
decl_stmt|;
name|int
name|num_object_files
init|=
literal|0
decl_stmt|;
name|int
name|next_file_symnum
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Name of the current file.  */
name|char
modifier|*
name|filestring
init|=
literal|""
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|fcn_first_line
init|=
literal|0
decl_stmt|;
name|int
name|fcn_last_line
init|=
literal|0
decl_stmt|;
name|int
name|fcn_start_addr
init|=
literal|0
decl_stmt|;
name|long
name|fcn_line_ptr
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
name|stream
operator|=
name|bfd_cache_lookup
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
name|perror_with_name
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Work around a stdio bug in SunOS4.1.1 (this makes me nervous....      it's hard to know I've really worked around it.  The fix should be      harmless, anyway).  The symptom of the bug is that the first      fread (in read_one_sym), will (in my example) actually get data      from file offset 268, when the fseek was to 264 (and ftell shows      264).  This causes all hell to break loose.  I was unable to      reproduce this on a short test program which operated on the same      file, performing (I think) the same sequence of operations.       It stopped happening when I put in this rewind().       FIXME: Find out if this has been reported to Sun, whether it has      been fixed in a later release, etc.  */
name|rewind
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* Position to read the symbol table. */
name|val
operator|=
name|fseek
argument_list|(
name|stream
argument_list|,
operator|(
name|long
operator|)
name|symtab_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|nlist_stream_global
operator|=
name|stream
expr_stmt|;
name|nlist_nsyms_global
operator|=
name|nsyms
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|opaque_type_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opaque_type_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_vector
condition|)
comment|/* Get rid of previous one */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|type_vector
argument_list|)
expr_stmt|;
name|type_vector_length
operator|=
literal|160
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type_vector
argument_list|,
literal|0
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|coff_start_symtab
argument_list|()
expr_stmt|;
name|symnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|symnum
operator|<
name|nsyms
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* Make this command interruptable.  */
name|read_one_sym
argument_list|(
name|cs
argument_list|,
operator|&
name|main_sym
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM
name|temp_sem_val
operator|=
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|cs
operator|->
name|c_name
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|cs
operator|->
name|c_name
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|cs
operator|->
name|c_name
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|int_sem_val
operator|==
name|temp_sem_val
condition|)
name|last_coffsem
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cs
operator|->
name|c_name
operator|+
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cs
operator|->
name|c_symnum
operator|==
name|next_file_symnum
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_source_file
condition|)
name|coff_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|coff_start_symtab
argument_list|()
expr_stmt|;
name|complete_symtab
argument_list|(
literal|"_globals_"
argument_list|,
literal|0
argument_list|,
name|first_object_file_end
argument_list|)
expr_stmt|;
comment|/* done with all files, everything from here on out is globals */
block|}
comment|/* Special case for file with type declarations only, no text.  */
if|if
condition|(
operator|!
name|last_source_file
operator|&&
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_secnum
operator|==
name|N_DEBUG
condition|)
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Typedefs should not be treated as symbol definitions.  */
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_TPDEF
condition|)
block|{
comment|/* Record all functions -- external and static -- in minsyms. */
name|record_minimal_symbol
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|mst_text
argument_list|)
expr_stmt|;
name|fcn_line_ptr
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
expr_stmt|;
name|fcn_start_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|fcn_cs_saved
operator|=
operator|*
name|cs
expr_stmt|;
name|fcn_sym_saved
operator|=
name|main_sym
expr_stmt|;
name|fcn_aux_saved
operator|=
name|main_aux
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_EFCN
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
case|case
name|C_USTATIC
case|:
case|case
name|C_LINE
case|:
case|case
name|C_ALIAS
case|:
case|case
name|C_HIDDEN
case|:
name|complain
argument_list|(
operator|&
name|bad_sclass_complaint
argument_list|,
name|cs
operator|->
name|c_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_FILE
case|:
comment|/* 	     * c_value field contains symnum of next .file entry in table 	     * or symnum of first global after last .file. 	     */
name|next_file_symnum
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|>
literal|0
condition|)
name|filestring
operator|=
name|getfilename
argument_list|(
operator|&
name|main_aux
argument_list|)
expr_stmt|;
else|else
name|filestring
operator|=
literal|""
expr_stmt|;
comment|/* 	     * Complete symbol table for last object file 	     * containing debugging information. 	     */
if|if
condition|(
name|last_source_file
condition|)
block|{
name|coff_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|coff_start_symtab
argument_list|()
expr_stmt|;
block|}
name|in_source_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
comment|/* FIXME:  don't wire in ".text" as section name 				       or symbol name! */
if|if
condition|(
operator|++
name|num_object_files
operator|==
literal|1
condition|)
block|{
comment|/* last address of startup file */
name|first_object_file_end
operator|=
name|cs
operator|->
name|c_value
operator|+
name|main_aux
operator|.
name|x_scn
operator|.
name|x_scnlen
expr_stmt|;
block|}
comment|/* Check for in_source_file deals with case of 			       a file with debugging symbols 			       followed by a later file with no symbols.  */
if|if
condition|(
name|in_source_file
condition|)
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|main_aux
operator|.
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in_source_file
operator|=
literal|0
expr_stmt|;
block|}
comment|/* flush rest of '.' symbols */
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LI%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LF%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LC%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LP%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LPB%"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LBB%"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LBE%"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LPBX%"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* At least on a 3b1, gcc generates swbeg and string labels 		 that look like this.  Ignore them.  */
break|break;
comment|/* fall in for static symbols that don't start with '.' */
case|case
name|C_EXT
case|:
comment|/* Record external symbols in minsyms if we don't have debug 	       info for them.  FIXME, this is probably the wrong thing 	       to do.  Why don't we record them even if we do have 	       debug symbol info?  What really belongs in the minsyms 	       anyway?  Fred!??  */
if|if
condition|(
operator|!
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
comment|/* FIXME: This is BOGUS Will Robinson!  	 	Coff should provide the SEC_CODE flag for executable sections, 	 	then if we could look up sections by section number we   	 	could see if the flags indicate SEC_CODE.  If so, then 	 	record this symbol as a function in the minimal symbol table. 		But why are absolute syms recorded as functions, anyway?  */
if|if
condition|(
name|cs
operator|->
name|c_secnum
operator|<=
name|text_bfd_scnum
operator|+
literal|1
condition|)
block|{
comment|/* text or abs */
name|record_minimal_symbol
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|mst_text
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|record_minimal_symbol
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|mst_data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|process_coff_symbol
argument_list|(
name|cs
argument_list|,
operator|&
name|main_aux
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bf"
argument_list|)
condition|)
block|{
name|within_function
operator|=
literal|1
expr_stmt|;
comment|/* value contains address of first non-init type code */
comment|/* main_aux.x_sym.x_misc.x_lnsz.x_lnno 			    contains line number of '{' } */
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
name|complain
argument_list|(
operator|&
name|bf_no_aux_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|fcn_first_line
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
comment|/* Might want to check that locals are 0 and 		   context_stack_depth is zero, and complain if not.  */
name|depth
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|depth
argument_list|,
name|fcn_start_addr
argument_list|)
expr_stmt|;
name|fcn_cs_saved
operator|.
name|c_name
operator|=
name|getsymname
argument_list|(
operator|&
name|fcn_sym_saved
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|process_coff_symbol
argument_list|(
operator|&
name|fcn_cs_saved
argument_list|,
operator|&
name|fcn_aux_saved
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".ef"
argument_list|)
condition|)
block|{
comment|/* the value of .ef is the address of epilogue code; 		   not useful for gdb.  */
comment|/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno 			    contains number of lines to '}' */
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
operator|||
name|new
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|ef_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
name|complain
argument_list|(
operator|&
name|ef_no_aux_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|fcn_last_line
operator|=
literal|0x7FFFFFFF
expr_stmt|;
block|}
else|else
block|{
name|fcn_last_line
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
block|}
name|enter_linenos
argument_list|(
name|fcn_line_ptr
argument_list|,
name|fcn_first_line
argument_list|,
name|fcn_last_line
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|FUNCTION_EPILOGUE_SIZE
argument_list|)
comment|/* This macro should be defined only on 				 machines where the 				 fcn_aux_saved.x_sym.x_misc.x_fsize 				 field is always zero. 				 So use the .bf record information that 				 points to the epilogue and add the size 				 of the epilogue.  */
name|cs
operator|->
name|c_value
operator|+
name|FUNCTION_EPILOGUE_SIZE
argument_list|,
else|#
directive|else
name|fcn_cs_saved
operator|.
name|c_value
operator|+
name|fcn_aux_saved
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
endif|#
directive|endif
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|C_BLOCK
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bb"
argument_list|)
condition|)
block|{
name|push_context
argument_list|(
operator|++
name|depth
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".eb"
argument_list|)
condition|)
block|{
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|depth
operator|--
operator|!=
name|new
operator|->
name|depth
condition|)
block|{
name|complain
argument_list|(
operator|&
name|eb_complaint
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|local_symbols
operator|&&
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
break|break;
default|default:
name|process_coff_symbol
argument_list|(
name|cs
argument_list|,
operator|&
name|main_aux
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last_source_file
condition|)
name|coff_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Patch up any opaque types (references to types that are not defined      in the file where they are referenced, e.g. "struct foo *bar").  */
name|ALL_OBJFILE_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
name|patch_opaque_types
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for reading headers and symbols from executable.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FIXME
end_ifdef

begin_comment
comment|/* Move these XXXMAGIC symbol defns into BFD!  */
end_comment

begin_comment
comment|/* Read COFF file header, check magic number,    and return number of symbols. */
end_comment

begin_macro
name|read_file_hdr
argument_list|(
argument|chan
argument_list|,
argument|file_hdr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILHDR
modifier|*
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lseek
argument_list|(
name|chan
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
name|FILHSZ
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|file_hdr
operator|->
name|f_magic
condition|)
block|{
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|MC68MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS32GMAGIC
case|case
name|NS32GMAGIC
case|:
case|case
name|NS32SMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|I386MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLIPPERMAGIC
case|case
name|CLIPPERMAGIC
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|MC68KWRMAGIC
argument_list|)
expr|\
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|MC68MAGIC
argument_list|)
operator|||
name|MC68KWRMAGIC
operator|!=
name|MC68MAGIC
operator|)
case|case
name|MC68KWRMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68KROMAGIC
case|case
name|MC68KROMAGIC
case|:
case|case
name|MC68KPGMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88DGMAGIC
case|case
name|MC88DGMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|MC88MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|I960ROMAGIC
case|:
comment|/* Intel 960 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960RWMAGIC
case|case
name|I960RWMAGIC
case|:
comment|/* Intel 960 */
endif|#
directive|endif
return|return
name|file_hdr
operator|->
name|f_nsyms
return|;
default|default:
ifdef|#
directive|ifdef
name|BADMAG
if|if
condition|(
name|BADMAG
argument_list|(
name|file_hdr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|file_hdr
operator|->
name|f_nsyms
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read the next symbol, swap it, and return it in both internal_syment    form, and coff_symbol form.  Also return its first auxent, if any,    in internal_auxent form, and skip any other auxents.  */
end_comment

begin_function
specifier|static
name|void
name|read_one_sym
parameter_list|(
name|cs
parameter_list|,
name|sym
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|cs
operator|->
name|c_symnum
operator|=
name|symnum
expr_stmt|;
name|fread
argument_list|(
name|temp_sym
argument_list|,
name|local_symesz
argument_list|,
literal|1
argument_list|,
name|nlist_stream_global
argument_list|)
expr_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|symfile_bfd
argument_list|,
name|temp_sym
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_naux
operator|=
name|sym
operator|->
name|n_numaux
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|>=
literal|1
condition|)
block|{
name|fread
argument_list|(
name|temp_aux
argument_list|,
name|local_auxesz
argument_list|,
literal|1
argument_list|,
name|nlist_stream_global
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|symfile_bfd
argument_list|,
name|temp_aux
argument_list|,
name|sym
operator|->
name|n_type
argument_list|,
name|sym
operator|->
name|n_sclass
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aux
argument_list|)
expr_stmt|;
comment|/* If more than one aux entry, read past it (only the first aux        is important). */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cs
operator|->
name|c_naux
condition|;
name|i
operator|++
control|)
name|fread
argument_list|(
name|temp_aux
argument_list|,
name|local_auxesz
argument_list|,
literal|1
argument_list|,
name|nlist_stream_global
argument_list|)
expr_stmt|;
block|}
name|cs
operator|->
name|c_name
operator|=
name|getsymname
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_value
operator|=
name|sym
operator|->
name|n_value
expr_stmt|;
name|cs
operator|->
name|c_sclass
operator|=
operator|(
name|sym
operator|->
name|n_sclass
operator|&
literal|0xff
operator|)
expr_stmt|;
name|cs
operator|->
name|c_secnum
operator|=
name|sym
operator|->
name|n_scnum
expr_stmt|;
name|cs
operator|->
name|c_type
operator|=
operator|(
name|unsigned
operator|)
name|sym
operator|->
name|n_type
expr_stmt|;
if|if
condition|(
operator|!
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
name|cs
operator|->
name|c_type
operator|=
literal|0
expr_stmt|;
name|symnum
operator|+=
literal|1
operator|+
name|cs
operator|->
name|c_naux
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for string table handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_stringtab
parameter_list|(
name|chan
parameter_list|,
name|offset
parameter_list|)
name|int
name|chan
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|long
name|length
decl_stmt|;
name|int
name|val
decl_stmt|;
name|unsigned
name|char
name|lengthbuf
index|[
literal|4
index|]
decl_stmt|;
name|free_stringtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|chan
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|myread
argument_list|(
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lengthbuf
argument_list|,
sizeof|sizeof
name|lengthbuf
argument_list|)
expr_stmt|;
name|length
operator|=
name|bfd_h_get_32
argument_list|(
name|symfile_bfd
argument_list|,
name|lengthbuf
argument_list|)
expr_stmt|;
comment|/* If no string table is needed, then the file may end immediately      after the symbols.  Just return with `stringtab' set to null. */
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|lengthbuf
operator|||
name|length
operator|<
sizeof|sizeof
name|lengthbuf
condition|)
return|return
literal|0
return|;
name|stringtab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stringtab
argument_list|,
operator|&
name|length
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
sizeof|sizeof
name|length
condition|)
comment|/* Empty table -- just the count */
return|return
literal|0
return|;
name|val
operator|=
name|myread
argument_list|(
name|chan
argument_list|,
name|stringtab
operator|+
sizeof|sizeof
name|lengthbuf
argument_list|,
name|length
operator|-
sizeof|sizeof
name|lengthbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|length
operator|-
sizeof|sizeof
name|lengthbuf
operator|||
name|stringtab
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_stringtab
parameter_list|()
block|{
if|if
condition|(
name|stringtab
condition|)
name|free
argument_list|(
name|stringtab
argument_list|)
expr_stmt|;
name|stringtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getsymname
parameter_list|(
name|symbol_entry
parameter_list|)
name|struct
name|internal_syment
modifier|*
name|symbol_entry
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|symbol_entry
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|stringtab
operator|+
name|symbol_entry
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|symbol_entry
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|buffer
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Extract the file name from the aux entry of a C_FILE symbol.  Return    only the last component of the name.  Result is in static storage and    is only good for temporary use.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getfilename
parameter_list|(
name|aux_entry
parameter_list|)
name|union
name|internal_auxent
modifier|*
name|aux_entry
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|aux_entry
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|stringtab
operator|+
name|aux_entry
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|aux_entry
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|result
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|result
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|result
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for line number handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linetab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|linetab_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|linetab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all the line numbers for fast lookups later.  Leave them in    external (unswapped) format in memory; we'll swap them as we enter    them into GDB's data structures.  */
end_comment

begin_function
specifier|static
name|int
name|init_lineno
parameter_list|(
name|chan
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|int
name|chan
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|linetab_offset
operator|=
name|offset
expr_stmt|;
name|linetab_size
operator|=
name|size
expr_stmt|;
name|free_linetab
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lseek
argument_list|(
name|chan
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Allocate the desired table, plus a sentinel */
name|linetab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
name|local_linesz
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|chan
argument_list|,
name|linetab
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|size
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Terminate it with an all-zero sentinel record */
name|memset
argument_list|(
name|linetab
operator|+
name|size
argument_list|,
literal|0
argument_list|,
name|local_linesz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_linetab
parameter_list|()
block|{
if|if
condition|(
name|linetab
condition|)
name|free
argument_list|(
name|linetab
argument_list|)
expr_stmt|;
name|linetab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|L_LNNO32
argument_list|)
end_if

begin_define
define|#
directive|define
name|L_LNNO32
parameter_list|(
name|lp
parameter_list|)
value|((lp)->l_lnno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|enter_linenos
parameter_list|(
name|file_offset
parameter_list|,
name|first_line
parameter_list|,
name|last_line
parameter_list|)
name|long
name|file_offset
decl_stmt|;
specifier|register
name|int
name|first_line
decl_stmt|;
specifier|register
name|int
name|last_line
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|rawptr
decl_stmt|;
name|struct
name|internal_lineno
name|lptr
decl_stmt|;
if|if
condition|(
name|file_offset
operator|<
name|linetab_offset
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lineno_complaint
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|>
name|linetab_size
condition|)
comment|/* Too big to be an offset? */
return|return;
name|file_offset
operator|+=
name|linetab_offset
expr_stmt|;
comment|/* Try reading at that linetab offset */
block|}
name|rawptr
operator|=
operator|&
name|linetab
index|[
name|file_offset
operator|-
name|linetab_offset
index|]
expr_stmt|;
comment|/* skip first line entry for each function */
name|rawptr
operator|+=
name|local_linesz
expr_stmt|;
comment|/* line numbers start at one for the first line of the function */
name|first_line
operator|--
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_coff_swap_lineno_in
argument_list|(
name|symfile_bfd
argument_list|,
name|rawptr
argument_list|,
operator|&
name|lptr
argument_list|)
expr_stmt|;
name|rawptr
operator|+=
name|local_linesz
expr_stmt|;
comment|/* The next function, or the sentinel, will have L_LNNO32 zero; we exit. */
if|if
condition|(
name|L_LNNO32
argument_list|(
operator|&
name|lptr
argument_list|)
operator|&&
name|L_LNNO32
argument_list|(
operator|&
name|lptr
argument_list|)
operator|<=
name|last_line
condition|)
name|coff_record_line
argument_list|(
name|first_line
operator|+
name|L_LNNO32
argument_list|(
operator|&
name|lptr
argument_list|)
argument_list|,
name|lptr
operator|.
name|l_addr
operator|.
name|l_paddr
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|patch_type
parameter_list|(
name|type
parameter_list|,
name|real_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|real_target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|real_type
argument_list|)
decl_stmt|;
name|int
name|field_size
init|=
name|TYPE_NFIELDS
argument_list|(
name|real_target
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
decl_stmt|;
name|TYPE_LENGTH
argument_list|(
name|target
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|real_target
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|target
argument_list|)
operator|=
name|TYPE_NFIELDS
argument_list|(
name|real_target
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|target
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|target
argument_list|,
name|field_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|real_target
argument_list|)
argument_list|,
name|field_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|real_target
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
condition|)
name|free
argument_list|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
operator|=
name|concat
argument_list|(
name|TYPE_NAME
argument_list|(
name|real_target
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Patch up all appropriate typedef symbols in the opaque_type_chains    so that they can be used to print out opaque data structures properly.  */
end_comment

begin_function
specifier|static
name|void
name|patch_opaque_types
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|real_sym
decl_stmt|;
comment|/* Go through the per-file symbols only */
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Find completed typedefs to use to fix opaque ones. 	 Remove syms from the chain when their types are stored, 	 but search the whole chain, as there may be several syms 	 from different files with the same name.  */
name|real_sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|real_sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|real_sym
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|SYMBOL_NAME
argument_list|(
name|real_sym
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hash
init|=
name|hashname
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|opaque_type_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
name|STREQ
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opaque_type_chain
index|[
name|hash
index|]
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|patch_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|opaque_type_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|process_coff_symbol
parameter_list|(
name|cs
parameter_list|,
name|aux
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|type
modifier|*
name|temptype
decl_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
name|EXTERNAL_NAME
argument_list|(
name|name
argument_list|,
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* default assumptions */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  This has NOT been tested.  The DBX version has.. */
comment|/* Generate a template for the type of this function.  The  	  types of the arguments will be added as we read the symbol  	  table. */
block|struct type *new = (struct type *) 		    obstack_alloc (&objfile->symbol_obstack, sizeof (struct type));                memcpy (new, lookup_function_type (decode_function_type (cs, cs->c_type, aux)), 		      sizeof(struct type));        SYMBOL_TYPE (sym) = new;        in_function_type = SYMBOL_TYPE(sym);
else|#
directive|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|decode_function_type
argument_list|(
name|cs
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|aux
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_STAT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_NULL
case|:
break|break;
case|case
name|C_AUTO
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|cs
operator|->
name|c_value
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|cs
operator|->
name|c_value
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
block|{
comment|/* Static symbol of local scope */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Static symbol at top level of file */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|C_GLBLREG
comment|/* AMD coff */
case|case
name|C_GLBLREG
case|:
endif|#
directive|endif
case|case
name|C_REG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SDB_REG_TO_REGNUM
argument_list|(
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
break|break;
case|case
name|C_ARG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME:  This has not been tested. */
comment|/* Add parameter to function.  */
block|add_param_to_type(&in_function_type,sym);
endif|#
directive|endif
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION
argument_list|)
operator|&&
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
comment|/* If PCC says a parameter is a short or a char, 	       aligned on an int boundary, realign it to the "little end" 	       of the int.  */
name|temptype
operator|=
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
literal|0
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|%
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|C_REGPARM
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SDB_REG_TO_REGNUM
argument_list|(
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION
argument_list|)
comment|/* FIXME:  This should retain the current type, since it's just 	   a register value.  gnu@adobe, 26Feb93 */
comment|/* If PCC says a parameter is a short or a char, 	       it is really an int.  */
name|temptype
operator|=
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|?
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
else|:
name|temptype
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|C_TPDEF
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* If type has no name, give it one */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|concat
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Keep track of any type which points to empty structured type, 		so it can be filled from a definition from another file.  A 		simple forward reference (TYPE_CODE_UNDEF) is not an 		empty structured type, though; the forward references 		work themselves out via the magic of coff_lookup_type.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|opaque_type_chain
index|[
name|i
index|]
expr_stmt|;
name|opaque_type_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
comment|/* Some compilers try to be helpful by inventing "fake"                names for anonymous enums, structures, and unions, like                "~0fake" or ".0fake".  Thanks, but no thanks... */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|!=
literal|'~'
operator|&&
operator|*
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|!=
literal|'.'
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|concat
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a coff type specifier;    return the type that is meant.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|new_c_type
decl_stmt|;
if|if
condition|(
name|c_type
operator|&
operator|~
name|N_BTMASK
condition|)
block|{
name|new_c_type
operator|=
name|DECREF
argument_list|(
name|c_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPTR
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFCN
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|dim
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
comment|/* Define an array type.  */
comment|/* auxent refers to array, not base type */
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|==
literal|0
condition|)
name|cs
operator|->
name|c_naux
operator|=
literal|0
expr_stmt|;
comment|/* shift the indices down */
name|dim
operator|=
operator|&
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|dim
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|dim
operator|&&
name|i
operator|<
name|DIMNUM
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|dim
operator|++
control|)
operator|*
name|dim
operator|=
operator|*
operator|(
name|dim
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dim
operator|=
literal|0
expr_stmt|;
name|base_type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
literal|0
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|base_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/* Reference to existing type.  This only occurs with the      struct, union, and enum types.  EPI a29k coff      fakes us out by producing aux entries with a nonzero      x_tagndx for definitions of structs, unions, and enums, so we      have to check the c_sclass field.  SCO 3.2v4 cc gets confused      with pointers to pointers to defined structs, and generates      negative x_tagndx fields.  */
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|>
literal|0
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|!=
name|C_STRTAG
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_UNTAG
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_ENTAG
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|tagndx_bad_complaint
argument_list|,
name|cs
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* And fall through to decode_base_type... */
block|}
block|}
return|return
name|decode_base_type
argument_list|(
name|cs
argument_list|,
name|BTYPE
argument_list|(
name|c_type
argument_list|)
argument_list|,
name|aux
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a coff type specifier for function definition;    return the type that the function returns.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_function_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|==
literal|0
condition|)
name|cs
operator|->
name|c_naux
operator|=
literal|0
expr_stmt|;
comment|/* auxent refers to function, not base type */
return|return
name|decode_type
argument_list|(
name|cs
argument_list|,
name|DECREF
argument_list|(
name|c_type
argument_list|)
argument_list|,
name|aux
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* basic C types */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_base_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|c_type
condition|)
block|{
case|case
name|T_NULL
case|:
comment|/* shows up with "void (*foo)();" structure members */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* DGUX actually defines both T_ARG and T_VOID to the same value.  */
ifdef|#
directive|ifdef
name|T_ARG
block|case T_ARG:
comment|/* Shows up in DGUX, I think.  Not sure where.  */
block|return lookup_fundamental_type (current_objfile, FT_VOID);
comment|/* shouldn't show up here */
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
ifdef|#
directive|ifdef
name|T_VOID
case|case
name|T_VOID
case|:
comment|/* Intel 960 COFF has this symbol and meaning.  */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
endif|#
directive|endif
case|case
name|T_CHAR
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_CHAR
argument_list|)
return|;
case|case
name|T_SHORT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SHORT
argument_list|)
return|;
case|case
name|T_INT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
return|;
case|case
name|T_LONG
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_LONG
argument_list|)
return|;
case|case
name|T_FLOAT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_FLOAT
argument_list|)
return|;
case|case
name|T_DOUBLE
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
return|;
case|case
name|T_STRUCT
case|:
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
comment|/* anonymous structure type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* This used to set the tag to "<opaque>".  But I think setting it 	       to NULL is right, and the printing code can print it as 	       "struct {...}".  */
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|coff_read_struct_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|T_UNION
case|:
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
comment|/* anonymous union type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* This used to set the tag to "<opaque>".  But I think setting it 	       to NULL is right, and the printing code can print it as 	       "union {...}".  */
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|coff_read_struct_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
return|return
name|type
return|;
case|case
name|T_ENUM
case|:
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
comment|/* anonymous enum type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* This used to set the tag to "<opaque>".  But I think setting it 	       to NULL is right, and the printing code can print it as 	       "enum {...}".  */
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|coff_read_enum_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|T_MOE
case|:
comment|/* shouldn't show up here */
break|break;
case|case
name|T_UCHAR
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
return|;
case|case
name|T_USHORT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|)
return|;
case|case
name|T_UINT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
return|;
case|case
name|T_ULONG
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
return|;
block|}
name|complain
argument_list|(
operator|&
name|unexpected_type_complaint
argument_list|,
name|cs
operator|->
name|c_name
argument_list|)
expr_stmt|;
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Read the description of a structure (or union type)    and return an object describing the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_read_struct_type
parameter_list|(
name|index
parameter_list|,
name|length
parameter_list|,
name|lastsym
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|lastsym
decl_stmt|;
block|{
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|coff_symbol
name|member_sym
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|ms
init|=
operator|&
name|member_sym
decl_stmt|;
name|struct
name|internal_syment
name|sub_sym
decl_stmt|;
name|union
name|internal_auxent
name|sub_aux
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symnum
operator|<
name|lastsym
operator|&&
name|symnum
operator|<
name|nlist_nsyms_global
condition|)
block|{
name|read_one_sym
argument_list|(
name|ms
argument_list|,
operator|&
name|sub_sym
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|name
operator|=
name|ms
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
name|EXTERNAL_NAME
argument_list|(
name|name
argument_list|,
name|current_objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|decode_type
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|c_type
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
literal|8
operator|*
name|ms
operator|->
name|c_value
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
break|break;
case|case
name|C_FIELD
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|decode_type
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|c_type
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|ms
operator|->
name|c_value
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
name|sub_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now create the vector of fields, and record how big it is.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
operator|--
name|n
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_read_enum_type
parameter_list|(
name|index
parameter_list|,
name|length
parameter_list|,
name|lastsym
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|lastsym
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|coff_symbol
name|member_sym
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|ms
init|=
operator|&
name|member_sym
decl_stmt|;
name|struct
name|internal_syment
name|sub_sym
decl_stmt|;
name|union
name|internal_auxent
name|sub_aux
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
name|symlist
operator|=
operator|&
name|local_symbols
expr_stmt|;
else|else
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symnum
operator|<
name|lastsym
operator|&&
name|symnum
operator|<
name|nlist_nsyms_global
condition|)
block|{
name|read_one_sym
argument_list|(
name|ms
argument_list|,
operator|&
name|sub_sym
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|name
operator|=
name|ms
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
name|EXTERNAL_NAME
argument_list|(
name|name
argument_list|,
name|current_objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_MOE
case|:
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|ms
operator|->
name|c_value
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
comment|/* Sometimes the linker (on 386/ix 2.0.2 at least) screws 	       up the count of how many symbols to read.  So stop 	       on .eos.  */
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now fill in the fields of the type-structure.  */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
else|else
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
comment|/* Assume ints */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
comment|/* Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
name|j
operator|=
name|o_nsyms
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VALUE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
if|#
directive|if
literal|0
comment|/* This screws up perfectly good C programs with enums.  FIXME.  */
comment|/* Is this Modula-2's BOOLEAN type?  Flag it as such if so. */
block|if(TYPE_NFIELDS(type) == 2&&      ((STREQ(TYPE_FIELD_NAME(type,0),"TRUE")&&        STREQ(TYPE_FIELD_NAME(type,1),"FALSE")) ||       (STREQ(TYPE_FIELD_NAME(type,1),"TRUE")&&        STREQ(TYPE_FIELD_NAME(type,0),"FALSE"))))      TYPE_CODE(type) = TYPE_CODE_BOOL;
endif|#
directive|endif
return|return
name|type
return|;
block|}
end_function

begin_function
name|struct
name|section_offsets
modifier|*
name|coff_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_comment
comment|/* Register our ability to parse symbols for coff BFD files */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|coff_sym_fns
init|=
block|{
literal|"coff"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|4
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|coff_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|coff_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|coff_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|coff_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|coff_symfile_offsets
block|,
comment|/* sym_offsets:  xlate external to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_coffread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|coff_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

