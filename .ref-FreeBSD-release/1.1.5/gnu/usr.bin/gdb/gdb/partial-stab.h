begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Shared code to pre-read a stab (dbx-style), when building a psymtab.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* The following need to be defined:    SET_NAMESTRING() --Set namestring to name of symbol.    CUR_SYMBOL_TYPE --Type code of current symbol.    CUR_SYMBOL_VALUE --Value field of current symbol.  May be adjusted here.  */
end_comment

begin_comment
comment|/* End of macro definitions, now let's handle them symbols!  */
end_comment

begin_switch
switch|switch
condition|(
name|CUR_SYMBOL_TYPE
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	   * Standard, external, non-debugger, symbols 	   */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
case|case
name|N_NBTEXT
operator||
name|N_EXT
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
case|case
name|N_NBDATA
operator||
name|N_EXT
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
case|case
name|N_NBBSS
operator||
name|N_EXT
case|:
case|case
name|N_SETV
operator||
name|N_EXT
case|:
comment|/* FIXME, is this in BSS? */
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|record_it
label|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|bss_ext_symbol
label|:
name|record_minimal_symbol
argument_list|(
name|namestring
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|CUR_SYMBOL_TYPE
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Always */
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
comment|/* Standard, local, non-debugger, symbols */
case|case
name|N_NBTEXT
case|:
comment|/* We need to be able to deal with both N_FN or N_TEXT, 	     because we have no way of knowing whether the sys-supplied ld 	     or GNU ld was used to make the executable.  Sequents throw 	     in another wrinkle -- they renumbered N_FN.  */
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
case|case
name|N_TEXT
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|namestring
index|[
literal|1
index|]
operator|==
literal|'l'
operator|)
operator|||
operator|(
name|namestring
index|[
operator|(
name|nsl
operator|=
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|namestring
index|[
name|nsl
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
comment|/* some cooperation from gcc to get around ld stupidity */
operator|||
operator|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|STREQ
argument_list|(
name|namestring
argument_list|,
literal|"end_file."
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
ifndef|#
directive|ifndef
name|GDB_TARGET_IS_HPPA
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|CUR_SYMBOL_VALUE
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|past_first_source_file
operator|&&
name|pst
comment|/* The gould NP1 uses low values for .o and -l symbols 		     which are not the address.  */
operator|&&
name|CUR_SYMBOL_VALUE
operator|>=
name|pst
operator|->
name|textlow
condition|)
block|{
name|END_PSYMTAB
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|last_o_file_start
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
block|}
else|else
goto|goto
name|record_it
goto|;
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
case|case
name|N_DATA
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
if|if
condition|(
name|CUR_SYMBOL_VALUE
operator|!=
literal|0
condition|)
block|{
comment|/* This is a "Fortran COMMON" symbol.  See if the target 	       environment knows where it has been relocated to.  */
name|CORE_ADDR
name|reladdr
decl_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_lookup_symbol
argument_list|(
name|namestring
argument_list|,
operator|&
name|reladdr
argument_list|)
condition|)
block|{
continue|continue;
comment|/* Error in lookup; ignore symbol for now.  */
block|}
name|CUR_SYMBOL_TYPE
operator|^=
operator|(
name|N_BSS
operator|^
name|N_UNDF
operator|)
expr_stmt|;
comment|/* Define it as a bss-symbol */
name|CUR_SYMBOL_VALUE
operator|=
name|reladdr
expr_stmt|;
goto|goto
name|bss_ext_symbol
goto|;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
comment|/* Just undefined, not COMMON */
case|case
name|N_UNDF
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
if|if
condition|(
name|processing_acc_compilation
operator|&&
name|bufp
operator|->
name|n_strx
operator|==
literal|1
condition|)
block|{
comment|/* Deal with relative offsets in the string table 	       used in ELF+STAB under Solaris.  If we want to use the 	       n_strx field, which contains the name of the file, 	       we must adjust file_string_table_offset *before* calling 	       SET_NAMESTRING().  */
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|file_string_table_offset
operator|=
name|next_file_string_table_offset
expr_stmt|;
name|next_file_string_table_offset
operator|=
name|file_string_table_offset
operator|+
name|bufp
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|next_file_string_table_offset
operator|<
name|file_string_table_offset
condition|)
name|error
argument_list|(
literal|"string table offset backs up at %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
comment|/* FIXME -- replace error() with complaint.  */
continue|continue;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
comment|/* Lots of symbol types we can just ignore.  */
case|case
name|N_ABS
case|:
case|case
name|N_NBDATA
case|:
case|case
name|N_NBBSS
case|:
continue|continue;
comment|/* Keep going . . .*/
comment|/* 	   * Special symbol types for GNU 	   */
case|case
name|N_INDR
case|:
case|case
name|N_INDR
operator||
name|N_EXT
case|:
case|case
name|N_SETA
case|:
case|case
name|N_SETA
operator||
name|N_EXT
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
case|case
name|N_SETB
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
case|case
name|N_SETV
case|:
continue|continue;
comment|/* 	   * Debugger symbols 	   */
case|case
name|N_SO
case|:
block|{
name|unsigned
name|long
name|valu
decl_stmt|;
specifier|static
name|int
name|prev_so_symnum
init|=
operator|-
literal|10
decl_stmt|;
specifier|static
name|int
name|first_so_symnum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|valu
operator|=
name|CUR_SYMBOL_VALUE
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prev_so_symnum
operator|!=
name|symnum
operator|-
literal|1
condition|)
block|{
comment|/* Here if prev stab wasn't N_SO */
name|first_so_symnum
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
name|END_PSYMTAB
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|valu
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|prev_so_symnum
operator|=
name|symnum
expr_stmt|;
comment|/* End the current partial symtab and start a new one */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* Some compilers (including gcc) emit a pair of initial N_SOs. 	     The first one is a directory name; the second the file name. 	     If pst exists, is empty, and has a filename ending in '/', 	     we assume the previous N_SO was a directory name. */
name|p
operator|=
name|strrchr
argument_list|(
name|namestring
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\000'
condition|)
continue|continue;
comment|/* Simply ignore directory name SOs */
comment|/* Some other compilers (C++ ones in particular) emit useless 	     SOs for non-existant .c files.  We ignore all subsequent SOs that 	     immediately follow the first.  */
if|if
condition|(
operator|!
name|pst
condition|)
name|pst
operator|=
name|START_PSYMTAB
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
name|first_so_symnum
operator|*
name|symbol_size
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|N_BINCL
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
comment|/* Add this bincl to the bincl_list for future EXCLs.  No 	     need to save the string; it'll be around until 	     read_dbx_symtab function returns */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|add_bincl_to_list
argument_list|(
name|pst
argument_list|,
name|namestring
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|)
expr_stmt|;
comment|/* Mark down an include file in the current psymtab */
goto|goto
name|record_include_file
goto|;
else|#
directive|else
comment|/* DBXREAD_ONLY */
continue|continue;
endif|#
directive|endif
case|case
name|N_SOL
case|:
comment|/* Mark down an include file in the current psymtab */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* In C++, one may expect the same filename to come round many 	     times, when code is coming alternately from the main file 	     and from inline functions in other files. So I check to see 	     if this is a file we've seen before -- either the main 	     source file, or a previously included file.  	     This seems to be a lot of time to be spending on N_SOL, but 	     things like "break c-exp.y:435" need to work (I 	     suppose the psymtab_include_list could be hashed or put 	     in a binary tree, if profiling shows this is a major hog).  */
if|if
condition|(
name|pst
operator|&&
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|includes_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|psymtab_include_list
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|record_include_file
label|:
endif|#
directive|endif
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab_include_list
argument_list|,
operator|(
name|PTR
operator|)
name|orig
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|N_LSYM
case|:
comment|/* Typedef or automatic variable. */
case|case
name|N_STSYM
case|:
comment|/* Data seg var -- static  */
case|case
name|N_LCSYM
case|:
comment|/* BSS      "  */
case|case
name|N_ROSYM
case|:
comment|/* Read-only data seg var -- static.  */
case|case
name|N_NBSTS
case|:
comment|/* Gould nobase.  */
case|case
name|N_NBLCS
case|:
comment|/* symbols.  */
case|case
name|N_FUN
case|:
case|case
name|N_GSYM
case|:
comment|/* Global (extern) variable; can be 				   data or bss (sigh FIXME).  */
comment|/* Following may probably be ignored; I'll leave them here 	   for now (until I do Pascal and Modula 2 extensions).  */
case|case
name|N_PC
case|:
comment|/* I may or may not need this; I 				   suspect not.  */
case|case
name|N_M2C
case|:
comment|/* I suspect that I can ignore this here. */
case|case
name|N_SCOPE
case|:
comment|/* Same.   */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
comment|/* Not a debugging symbol.   */
comment|/* Main processing section for debugging symbols which 	     the initial read through the symbol tables needs to worry 	     about.  If we reach this point, the symbol which we are 	     considering is definitely one we are interested in. 	     p must also contain the (valid) index into the namestring 	     which indicates the debugging type symbol.  */
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
name|ADD_PSYMBOL_ADDR_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'G'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
comment|/* The addresses in these entries are reported to be 		 wrong.  See the code that reads 'G's for symtabs. */
name|ADD_PSYMBOL_ADDR_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Also a typedef with the same name.  */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
block|}
goto|goto
name|check_enum
goto|;
case|case
literal|'t'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|check_enum
label|:
comment|/* If this is an enumerated type, we need to 		 add all the enum constants to the partial symbol 		 table.  This does not cover enums without names, e.g. 		 "enum {a, b} c;" in C, but fortunately those are 		 rare.  There is no way for GDB to find those from the 		 enum type without spending too much time on it.  Thus 		 to solve this problem, the compiler needs to put out the 		 enum in a nameless type.  GCC2 does this.  */
comment|/* We are looking for something of the form<name> ":" ("t" | "T") [<number> "="] "e" 		 {<constant> ":"<value> ","} ";".  */
comment|/* Skip over the colon and the 't' or 'T'.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* This type may be given a number.  Also, numbers can come 		 in pairs like (0,26).  Skip over it.  */
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|')'
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'e'
condition|)
block|{
comment|/* We have found an enumerated type.  */
comment|/* According to comments in read_enum_type 		     a comma could end it instead of a semicolon. 		     I don't know where that happens. 		     Accept either.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name 			 continuation!  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|p
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
comment|/* Point to the character after the name 			 of the enum constant.  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* Note that the value doesn't matter for 			 enum constants in psymtabs, just in symtabs.  */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Point past the name.  */
name|p
operator|=
name|q
expr_stmt|;
comment|/* Skip over the value.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Advance past the comma.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'c'
case|:
comment|/* Constant, e.g. from "const" in Pascal.  */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
comment|/* Kludges for ELF/STABS with Sun ACC */
name|last_function_name
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|pst
operator|&&
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
name|pst
operator|->
name|textlow
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
if|#
directive|if
literal|0
block|if (startup_file_end == 0) 		startup_file_end = CUR_SYMBOL_VALUE;
endif|#
directive|endif
comment|/* End kludge.  */
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Global functions were ignored here, but now they 	         are put into the global psymtab like one would expect. 		 They're also in the minimal symbol table.  */
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
comment|/* Kludges for ELF/STABS with Sun ACC */
name|last_function_name
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|pst
operator|&&
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
name|pst
operator|->
name|textlow
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
if|#
directive|if
literal|0
block|if (startup_file_end == 0) 		startup_file_end = CUR_SYMBOL_VALUE;
endif|#
directive|endif
comment|/* End kludge.  */
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Two things show up here (hopefully); static symbols of 		 local scope (static used inside braces) or extensions 		 of structure symbols.  We can ignore both.  */
case|case
literal|'V'
case|:
case|case
literal|'('
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
continue|continue;
default|default:
comment|/* Unexpected symbol.  Ignore it; perhaps it is an extension 		 that we don't know about.  		 Someone says sun cc puts out symbols like 		 /foo/baz/maclib::/usr/local/bin/maclib, 		 which would get here with a symbol type of ':'.  */
name|complain
argument_list|(
operator|&
name|unknown_symchar_complaint
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|N_EXCL
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* Find the corresponding bincl and mark that psymtab on the 	     psymtab dependency list */
block|{
name|struct
name|partial_symtab
modifier|*
name|needed_pst
init|=
name|find_corresponding_bincl_psymtab
argument_list|(
name|namestring
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|)
decl_stmt|;
comment|/* If this include file was defined earlier in this file, 	       leave it alone.  */
if|if
condition|(
name|needed_pst
operator|==
name|pst
condition|)
continue|continue;
if|if
condition|(
name|needed_pst
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dependencies_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dependency_list
index|[
name|i
index|]
operator|==
name|needed_pst
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If it's already in the list, skip the rest.  */
if|if
condition|(
name|found
condition|)
continue|continue;
name|dependency_list
index|[
name|dependencies_used
operator|++
index|]
operator|=
name|needed_pst
expr_stmt|;
if|if
condition|(
name|dependencies_used
operator|>=
name|dependencies_allocated
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
modifier|*
name|orig
init|=
name|dependency_list
decl_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|dependencies_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|dependency_list
argument_list|,
operator|(
name|PTR
operator|)
name|orig
argument_list|,
operator|(
name|dependencies_used
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_INFO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Had to reallocate dependency list.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"New dependencies allocated: %d\n"
argument_list|,
name|dependencies_allocated
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
name|error
argument_list|(
literal|"Invalid symbol data: \"repeated\" header file not previously seen, at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
case|case
name|N_RBRAC
case|:
ifdef|#
directive|ifdef
name|HANDLE_RBRAC
name|HANDLE_RBRAC
argument_list|(
name|CUR_SYMBOL_VALUE
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
name|N_EINCL
case|:
case|case
name|N_DSLINE
case|:
case|case
name|N_BSLINE
case|:
case|case
name|N_SSYM
case|:
comment|/* Claim: Structure or union element. 				   Hopefully, I can ignore this.  */
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point; can ignore. */
case|case
name|N_MAIN
case|:
comment|/* Can definitely ignore this.   */
case|case
name|N_CATCH
case|:
comment|/* These are GNU C++ extensions */
case|case
name|N_EHDECL
case|:
comment|/* that can safely be ignored here. */
case|case
name|N_LENG
case|:
case|case
name|N_BCOMM
case|:
case|case
name|N_ECOMM
case|:
case|case
name|N_ECOML
case|:
case|case
name|N_FNAME
case|:
case|case
name|N_SLINE
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_LBRAC
case|:
case|case
name|N_NSYMS
case|:
comment|/* Ultrix 4.0: symbol count */
case|case
name|N_DEFD
case|:
comment|/* GNU Modula-2 */
case|case
name|N_OBJ
case|:
comment|/* useless types from Solaris */
case|case
name|N_OPT
case|:
case|case
name|N_ENDM
case|:
comment|/* These symbols aren't interesting; don't worry about them */
continue|continue;
default|default:
comment|/* If we haven't found it yet, ignore it.  It's probably some 	     new type we don't know about yet.  */
name|complain
argument_list|(
operator|&
name|unknown_symtype_complaint
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|CUR_SYMBOL_TYPE
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_switch

end_unit

