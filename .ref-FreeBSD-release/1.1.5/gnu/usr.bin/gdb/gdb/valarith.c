begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform arithmetic and other operations on values, for GDB.    Copyright 1986, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Define whether or not the C operator '/' truncates towards zero for    differently signed operands (truncation direction is undefined in C). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRUNCATION_TOWARDS_ZERO
end_ifndef

begin_define
define|#
directive|define
name|TRUNCATION_TOWARDS_ZERO
value|((-5 / 2) == -2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|value
name|value_subscripted_rvalue
name|PARAMS
argument_list|(
operator|(
name|value
operator|,
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|value
name|value_add
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|value
name|valint
decl_stmt|,
name|valptr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
comment|/* Exactly one argument is a pointer, and one is an integer.  */
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|valptr
operator|=
name|arg1
expr_stmt|;
name|valint
operator|=
name|arg2
expr_stmt|;
block|}
else|else
block|{
name|valptr
operator|=
name|arg2
expr_stmt|;
name|valint
operator|=
name|arg1
expr_stmt|;
block|}
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* For (void *) */
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valptr
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|valptr
argument_list|)
operator|+
operator|(
name|len
operator|*
name|value_as_long
argument_list|(
name|valint
argument_list|)
operator|)
argument_list|)
return|;
block|}
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_ADD
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|value_sub
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* pointer - integer.  */
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|-
operator|(
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|*
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|==
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
comment|/* pointer to<type x> - pointer to<type x>.  */
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
comment|/* FIXME -- should be ptrdiff_t */
operator|(
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|-
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"\ First argument of `-' is a pointer and second argument is neither\n\ an integer nor a pointer of the same type."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_SUB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of ARRAY[IDX].    See comments in value_coerce_array() for rationale for reason for    doing lower bounds adjustment here rather than there.    FIXME:  Perhaps we should validate that the index is valid and if    verbosity is set, warn about invalid indices (but still use them). */
end_comment

begin_function
name|value
name|value_subscript
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|value
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|int
name|lowerbound
decl_stmt|;
name|value
name|bound
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
name|COERCE_REF
argument_list|(
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|range_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lowerbound
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerbound
operator|!=
literal|0
condition|)
block|{
name|bound
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|lowerbound
argument_list|)
expr_stmt|;
name|idx
operator|=
name|value_sub
argument_list|(
name|idx
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|!=
name|lval_memory
condition|)
block|{
return|return
name|value_subscripted_rvalue
argument_list|(
name|array
argument_list|,
name|idx
argument_list|)
return|;
block|}
block|}
return|return
name|value_ind
argument_list|(
name|value_add
argument_list|(
name|array
argument_list|,
name|idx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of EXPR[IDX], expr an aggregate rvalue    (eg, a vector register).  This routine used to promote floats    to doubles, but no longer does.  */
end_comment

begin_function
specifier|static
name|value
name|value_subscripted_rvalue
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|value
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|elt_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|elt_size
init|=
name|TYPE_LENGTH
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|int
name|elt_offs
init|=
name|elt_size
operator|*
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|value
name|v
decl_stmt|;
if|if
condition|(
name|elt_offs
operator|>=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"no such vector element"
argument_list|)
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|array
argument_list|)
operator|+
name|elt_offs
argument_list|,
name|elt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
else|else
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|array
argument_list|)
operator|+
name|elt_offs
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|elt_size
operator|*
literal|8
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if either argument is a structure.  This is called so    we know whether to go ahead with the normal binop or look for a     user defined function instead.     For now, we do not overload the `=' operator.  */
end_comment

begin_function
name|int
name|binop_user_defined_p
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|BINOP_ASSIGN
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if argument is a structure.  This is called so    we know whether to go ahead with the normal unop or look for a     user defined function instead.     For now, we do not overload the `&' operator.  */
end_comment

begin_function
name|int
name|unop_user_defined_p
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value
name|arg1
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|UNOP_ADDR
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We know either arg1 or arg2 is a structure, so try to find the right    user defined function.  Create an argument vector that calls     arg1.operator @ (arg1,arg2) and return that value (where '@' is any    binary operator which is legal for GNU C++).     OP is the operatore, and if it is BINOP_ASSIGN_MODIFY, then OTHEROP    is the opcode saying how to modify it.  Otherwise, OTHEROP is    unused.  */
end_comment

begin_function
name|value
name|value_x_binop
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|,
name|otherop
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|,
name|otherop
decl_stmt|;
block|{
name|value
modifier|*
name|argvec
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|tstr
index|[
literal|13
index|]
decl_stmt|;
name|int
name|static_memfuncp
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* now we know that what we have to do is construct our      arg vector and find the right function to call it with.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"Can't do that binary op on that type"
argument_list|)
expr_stmt|;
comment|/* FIXME be explicit */
name|argvec
operator|=
operator|(
name|value
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make the right function name up */
name|strcpy
argument_list|(
name|tstr
argument_list|,
literal|"operator__"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tstr
operator|+
literal|8
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LSH
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_OR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
switch|switch
condition|(
name|otherop
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"/="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"%="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"|="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"^="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* invalid */
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_SUBSCRIPT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_EQUAL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"=="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_NOTEQUAL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LESS
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_GTR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_GEQ
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LEQ
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* invalid */
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|arg1
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|2
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"member function %s not found"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|2
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* We know that arg1 is a structure, so try to find a unary user    defined operator that matches the operator in question.      Create an argument vector that calls arg1.operator @ (arg1)    and return that value (where '@' is (almost) any unary operator which    is legal for GNU C++).  */
end_comment

begin_function
name|value
name|value_x_unop
parameter_list|(
name|arg1
parameter_list|,
name|op
parameter_list|)
name|value
name|arg1
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
name|value
modifier|*
name|argvec
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|tstr
index|[
literal|13
index|]
decl_stmt|;
name|int
name|static_memfuncp
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* now we know that what we have to do is construct our      arg vector and find the right function to call it with.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"Can't do that unary op on that type"
argument_list|)
expr_stmt|;
comment|/* FIXME be explicit */
name|argvec
operator|=
operator|(
name|value
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make the right function name up */
name|strcpy
argument_list|(
name|tstr
argument_list|,
literal|"operator__"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tstr
operator|+
literal|8
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_PREINCREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_PREDECREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_POSTINCREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_POSTDECREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_LOGICAL_NOT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_COMPLEMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_NEG
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|arg1
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|1
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"member function %s not found"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Concatenate two values with the following conditions:     (1)	Both values must be either bitstring values or character string 	values and the resulting value consists of the concatenation of 	ARG1 followed by ARG2.  	or  	One value must be an integer value and the other value must be 	either a bitstring value or character string value, which is 	to be repeated by the number of times specified by the integer 	value.       (2)	Boolean values are also allowed and are treated as bit string     	values of length 1.      (3)	Character values are also allowed and are treated as character     	string values of length 1. */
end_comment

begin_function
name|value
name|value_concat
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|value
name|inval1
decl_stmt|,
name|inval2
decl_stmt|,
name|outval
decl_stmt|;
name|int
name|inval1len
decl_stmt|,
name|inval2len
decl_stmt|;
name|int
name|count
decl_stmt|,
name|idx
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|inchar
decl_stmt|;
comment|/* First figure out if we are dealing with two values to be concatenated      or a repeat count and a value to be repeated.  INVAL1 is set to the      first of two concatenated values, or the repeat count.  INVAL2 is set      to the second of the two concatenated values or the value to be       repeated. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|inval1
operator|=
name|arg2
expr_stmt|;
name|inval2
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
name|inval1
operator|=
name|arg1
expr_stmt|;
name|inval2
operator|=
name|arg2
expr_stmt|;
block|}
comment|/* Now process the input values. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* We have a repeat count.  Validate the second value and then 	 construct a value repeated that many times. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
name|count
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|inval1
argument_list|)
argument_list|)
expr_stmt|;
name|inval2len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
name|inval2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
name|inchar
operator|=
operator|(
name|char
operator|)
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
operator|*
operator|(
name|ptr
operator|+
name|idx
operator|)
operator|=
name|inchar
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|ptr
operator|+
operator|(
name|idx
operator|*
name|inval2len
operator|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|,
name|inval2len
argument_list|)
expr_stmt|;
block|}
block|}
name|outval
operator|=
name|value_string
argument_list|(
name|ptr
argument_list|,
name|count
operator|*
name|inval2len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
name|error
argument_list|(
literal|"unimplemented support for bitstring/boolean repeats"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"can't repeat values of that type"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
comment|/* We have two character strings to concatenate. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRING
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
condition|)
block|{
name|error
argument_list|(
literal|"Strings can only be concatenated with other strings."
argument_list|)
expr_stmt|;
block|}
name|inval1len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
expr_stmt|;
name|inval2len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|inval1len
operator|+
name|inval2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|char
operator|)
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval1
argument_list|)
argument_list|,
name|inval1len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
operator|*
operator|(
name|ptr
operator|+
name|inval1len
operator|)
operator|=
operator|(
name|char
operator|)
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ptr
operator|+
name|inval1len
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|,
name|inval2len
argument_list|)
expr_stmt|;
block|}
name|outval
operator|=
name|value_string
argument_list|(
name|ptr
argument_list|,
name|inval1len
operator|+
name|inval2len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
comment|/* We have two bitstrings to concatenate. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_BITSTRING
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|inval2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
condition|)
block|{
name|error
argument_list|(
literal|"Bitstrings or booleans can only be concatenated with other bitstrings or booleans."
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"unimplemented support for bitstring/boolean concatenation."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't know how to concatenate these operands. */
name|error
argument_list|(
literal|"illegal operands for concatenation."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|outval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a binary operation on two operands which have reasonable    representations as integers or floats.  This includes booleans,    characters, integers, or floats.    Does not support addition and subtraction on pointers;    use value_add or value_sub if you want to handle those possibilities.  */
end_comment

begin_function
name|value
name|value_binop
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
operator|)
condition|)
name|error
argument_list|(
literal|"Argument to arithmetic operation not a number or boolean."
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|double
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_double
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_double
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Integer-only operation on floating point number."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|builtin_type_double
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|double
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BOOL
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_BITWISE_AND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid operation on booleans."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|builtin_type_chill_bool
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Integral operations here.  */
comment|/* FIXME:  Also mixed integral/booleans, with result an integer. */
block|{
comment|/* Should we promote to unsigned longest?  */
if|if
condition|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|>=
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
operator|||
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|>=
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
operator|)
condition|)
block|{
name|unsigned
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|v
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* Knuth 1.2.4, integer only.  Note that unlike the C '%' op, 	         v1 mod 0 has a defined value, v1. */
comment|/* Chill specifies that v2 must be> 0, so check for that. */
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_chill
operator|&&
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Second operand of MOD must be greater than zero."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|v1
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
comment|/* Note floor(v1/v2) == v1/v2 for unsigned. */
name|v
operator|=
name|v1
operator|-
operator|(
name|v2
operator|*
name|v
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_LSH
case|:
name|v
operator|=
name|v1
operator|<<
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|v
operator|=
name|v1
operator|>>
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_AND
case|:
name|v
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_OR
case|:
name|v
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|v
operator|=
name|v1
operator|<
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|v
operator|=
name|v1
operator|>
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation on numbers."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|BUILTIN_TYPE_UNSIGNED_LONGEST
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|v
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* Knuth 1.2.4, integer only.  Note that unlike the C '%' op, 	         X mod 0 has a defined value, X. */
comment|/* Chill specifies that v2 must be> 0, so check for that. */
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_chill
operator|&&
name|v2
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Second operand of MOD must be greater than zero."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|v1
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
comment|/* Compute floor. */
if|if
condition|(
name|TRUNCATION_TOWARDS_ZERO
operator|&&
operator|(
name|v
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|v1
operator|%
name|v2
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|v
operator|--
expr_stmt|;
block|}
name|v
operator|=
name|v1
operator|-
operator|(
name|v2
operator|*
name|v
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_LSH
case|:
name|v
operator|=
name|v1
operator|<<
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|v
operator|=
name|v1
operator|>>
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_AND
case|:
name|v
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_OR
case|:
name|v
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|v
operator|=
name|v1
operator|<
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|v
operator|=
name|v1
operator|>
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation on numbers."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|BUILTIN_TYPE_LONGEST
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simulate the C operator ! -- return 1 if ARG1 contains zero.  */
end_comment

begin_function
name|int
name|value_logical_not
parameter_list|(
name|arg1
parameter_list|)
name|value
name|arg1
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
return|return
literal|0
operator|==
name|value_as_double
argument_list|(
name|arg1
argument_list|)
return|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
condition|)
break|break;
block|}
return|return
name|len
operator|<
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simulate the C operator == by returning a 1    iff ARG1 and ARG2 have equal contents.  */
end_comment

begin_function
name|int
name|value_equal
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|enum
name|type_code
name|code1
decl_stmt|;
name|enum
name|type_code
name|code2
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|||
name|code1
operator|==
name|TYPE_CODE_INT
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
return|return
name|value_as_double
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_double
argument_list|(
name|arg2
argument_list|)
return|;
comment|/* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever      is bigger.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code1
operator|==
name|TYPE_CODE_INT
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|code2
operator|&&
operator|(
operator|(
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
break|break;
block|}
return|return
name|len
operator|<
literal|0
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid type combination in equality test."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
block|}
end_function

begin_comment
comment|/* Simulate the C operator< by returning 1    iff ARG1's contents are less than ARG2's.  */
end_comment

begin_function
name|int
name|value_less
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code2
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
return|;
else|else
return|return
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|||
name|code1
operator|==
name|TYPE_CODE_INT
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
return|return
name|value_as_double
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_double
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
comment|/* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever      is bigger.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|<
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code1
operator|==
name|TYPE_CODE_INT
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
else|else
block|{
name|error
argument_list|(
literal|"Invalid type combination in ordering comparison."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The unary operators - and ~.  Both free the argument ARG1.  */
end_comment

begin_function
name|value
name|value_neg
parameter_list|(
name|arg1
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
return|return
name|value_from_double
argument_list|(
name|type
argument_list|,
operator|-
name|value_as_double
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
operator|-
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
block|{
name|error
argument_list|(
literal|"Argument to negate operation not a number."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
block|}
end_function

begin_function
name|value
name|value_complement
parameter_list|(
name|arg1
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
block|{
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Argument to complement operation not an integer."
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|~
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

end_unit

