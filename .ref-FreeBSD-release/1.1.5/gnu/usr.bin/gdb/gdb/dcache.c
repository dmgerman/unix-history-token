begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Caching code.  Typically used by remote back ends for    caching remote memory.     Copyright 1992, 1993 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_function_decl
specifier|extern
name|int
name|insque
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|remque
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|remote_dcache
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The data cache records all the data read from the remote machine    since the last time it stopped.     Each cache block holds LINE_SIZE bytes of data    starting at a multiple-of-LINE_SIZE address.  */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_MASK
value|((LINE_SIZE - 1))
end_define

begin_comment
comment|/* eg 7*2+1= 111*/
end_comment

begin_define
define|#
directive|define
name|XFORM
parameter_list|(
name|x
parameter_list|)
value|(((x)& LINE_SIZE_MASK)>> 2)
end_define

begin_comment
comment|/* Free all the data cache blocks, thus discarding all cached data.  */
end_comment

begin_function
name|void
name|dcache_flush
parameter_list|(
name|dcache
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|remote_dcache
operator|>
literal|0
condition|)
while|while
condition|(
operator|(
name|db
operator|=
name|dcache
operator|->
name|dcache_valid
operator|.
name|next
operator|)
operator|!=
operator|&
name|dcache
operator|->
name|dcache_valid
condition|)
block|{
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache
operator|->
name|dcache_free
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * If addr is present in the dcache, return the address of the block  * containing it.  */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_hit
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|addr
operator|&
literal|3
operator|||
name|remote_dcache
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Search all cache blocks for one that is at this address.  */
name|db
operator|=
name|dcache
operator|->
name|dcache_valid
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|db
operator|!=
operator|&
name|dcache
operator|->
name|dcache_valid
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
operator|)
operator|==
name|db
operator|->
name|addr
condition|)
return|return
name|db
return|;
name|db
operator|=
name|db
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  Return the int data at address ADDR in dcache block DC.  */
end_comment

begin_function
specifier|static
name|int
name|dcache_value
parameter_list|(
name|db
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|&
literal|3
operator|||
name|remote_dcache
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a free cache block, put or keep it on the valid list,    and return its address.  The caller should store into the block    the address and data that it describes, then remque it from the    free list and insert it into the valid list.  This procedure    prevents errors from creeping in if a memory retrieval is    interrupted (which used to put garbage blocks in the valid    list...).  */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_alloc
parameter_list|(
name|dcache
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|remote_dcache
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dcache
operator|->
name|dcache_free
operator|.
name|next
operator|)
operator|==
operator|&
name|dcache
operator|->
name|dcache_free
condition|)
block|{
comment|/* If we can't get one from the free list, take last valid and put 	 it on the free list.  */
name|db
operator|=
name|dcache
operator|->
name|dcache_valid
operator|.
name|last
expr_stmt|;
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache
operator|->
name|dcache_free
argument_list|)
expr_stmt|;
block|}
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache
operator|->
name|dcache_valid
argument_list|)
expr_stmt|;
return|return
operator|(
name|db
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Using the data cache DCACHE return the contents of the word at    address ADDR in the remote machine.  */
end_comment

begin_function
name|int
name|dcache_fetch
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|remote_dcache
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
call|(
modifier|*
name|dcache
operator|->
name|read_memory
call|)
argument_list|(
name|addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|db
operator|=
name|dcache_hit
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
literal|0
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
call|(
modifier|*
name|dcache
operator|->
name|read_memory
call|)
argument_list|(
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|db
operator|->
name|data
argument_list|,
name|LINE_SIZE
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|db
operator|->
name|addr
operator|=
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
expr_stmt|;
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* Off the free list */
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache
operator|->
name|dcache_valid
argument_list|)
expr_stmt|;
comment|/* On the valid list */
block|}
return|return
operator|(
name|dcache_value
argument_list|(
name|db
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write the word at ADDR both in the data cache and in the remote machine.  */
end_comment

begin_function
name|void
name|dcache_poke
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|remote_dcache
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|dcache
operator|->
name|write_memory
call|)
argument_list|(
name|addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First make sure the word is IN the cache.  DB is its cache block.  */
name|db
operator|=
name|dcache_hit
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
literal|0
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
call|(
modifier|*
name|dcache
operator|->
name|write_memory
call|)
argument_list|(
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|db
operator|->
name|data
argument_list|,
name|LINE_SIZE
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|db
operator|->
name|addr
operator|=
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
expr_stmt|;
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* Off the free list */
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache
operator|->
name|dcache_valid
argument_list|)
expr_stmt|;
comment|/* On the valid list */
block|}
comment|/* Modify the word in the cache.  */
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|=
name|data
expr_stmt|;
comment|/* Send the changed word.  */
name|immediate_quit
operator|++
expr_stmt|;
call|(
modifier|*
name|dcache
operator|->
name|write_memory
call|)
argument_list|(
name|addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the data cache.  */
end_comment

begin_function
name|DCACHE
modifier|*
name|dcache_init
parameter_list|(
name|reading
parameter_list|,
name|writing
parameter_list|)
name|memxferfunc
name|reading
decl_stmt|;
name|memxferfunc
name|writing
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|dcache
operator|=
operator|(
name|DCACHE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dcache
argument_list|)
argument_list|)
expr_stmt|;
name|dcache
operator|->
name|read_memory
operator|=
name|reading
expr_stmt|;
name|dcache
operator|->
name|write_memory
operator|=
name|writing
expr_stmt|;
name|dcache
operator|->
name|the_cache
operator|=
operator|(
expr|struct
name|dcache_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dcache
operator|->
name|the_cache
argument_list|)
operator|*
name|DCACHE_SIZE
argument_list|)
expr_stmt|;
name|dcache
operator|->
name|dcache_free
operator|.
name|next
operator|=
name|dcache
operator|->
name|dcache_free
operator|.
name|last
operator|=
operator|&
name|dcache
operator|->
name|dcache_free
expr_stmt|;
name|dcache
operator|->
name|dcache_valid
operator|.
name|next
operator|=
name|dcache
operator|->
name|dcache_valid
operator|.
name|last
operator|=
operator|&
name|dcache
operator|->
name|dcache_valid
expr_stmt|;
for|for
control|(
name|db
operator|=
name|dcache
operator|->
name|the_cache
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCACHE_SIZE
condition|;
name|i
operator|++
operator|,
name|db
operator|++
control|)
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache
operator|->
name|dcache_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|dcache
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_initialitize_dcache
parameter_list|()
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotecache"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_dcache
argument_list|,
literal|"\ Set cache use for remote targets.\n\ When on, use data caching for remote targets.  For many remote targets\n\ this option can offer better throughput for reading target memory.\n\ Unfortunately, gdb does not currently know anything about volatile\n\ registers and thus data caching will produce incorrect results with\n\ volatile registers are in use.  By default, this option is off."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

