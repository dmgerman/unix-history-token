begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic ECOFF (Extended-COFF) routines.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Original version by Per Bothner.    Full support added by Ian Lance Taylor, ian@cygnus.com.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"seclet.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"aout/ranlib.h"
end_include

begin_comment
comment|/* FIXME: We need the definitions of N_SET[ADTB], but aout64.h defines    some other stuff which we don't want and which conflicts with stuff    we do want.  */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_undef
undef|#
directive|undef
name|N_ABS
end_undef

begin_undef
undef|#
directive|undef
name|exec_hdr
end_undef

begin_undef
undef|#
directive|undef
name|obj_sym_filepos
end_undef

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ecoff_get_magic
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_set_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|SYMR
operator|*
name|ecoff_sym
operator|,
name|asymbol
operator|*
name|asym
operator|,
name|int
name|ext
operator|,
name|asymbol
operator|*
operator|*
name|indirect_ptr_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_emit_aggregate
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|char
operator|*
name|string
operator|,
name|RNDXR
operator|*
name|rndx
operator|,
name|long
name|isym
operator|,
name|CONST
name|char
operator|*
name|which
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ecoff_type_to_string
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|union
name|aux_ext
operator|*
name|aux_ptr
operator|,
name|unsigned
name|int
name|indx
operator|,
name|int
name|bigendian
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|section
operator|,
name|asymbol
operator|*
operator|*
name|symbols
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_clear_output_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
name|bfd_seclet_type
operator|*
name|seclet
operator|,
name|asection
operator|*
name|output_section
operator|,
name|PTR
name|data
operator|,
name|boolean
name|relocateable
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_dump_seclet
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_seclet_type
operator|*
name|seclet
operator|,
name|asection
operator|*
name|section
operator|,
name|PTR
name|data
operator|,
name|boolean
name|relocateable
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|ecoff_add_string
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
name|FDR
operator|*
name|fdr
operator|,
name|CONST
name|char
operator|*
name|string
operator|,
name|boolean
name|external
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_get_debug
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
name|bfd_seclet_type
operator|*
name|seclet
operator|,
name|asection
operator|*
name|section
operator|,
name|boolean
name|relocateable
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ecoff_armap_hash
name|PARAMS
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|s
operator|,
name|unsigned
name|int
operator|*
name|rehash
operator|,
name|unsigned
name|int
name|size
operator|,
name|unsigned
name|int
name|hlog
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This stuff is somewhat copied from coffcode.h.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|bfd_debug_section
init|=
block|{
literal|"*DEBUG*"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an ECOFF object.  */
end_comment

begin_function
name|boolean
name|ecoff_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|ecoff_obj_data
operator|=
operator|(
operator|(
expr|struct
name|ecoff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ecoff_data_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|ecoff_obj_data
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Always create a .scommon section for every BFD.  This is a hack so      that the linker has something to attach scSCommon symbols to.  */
if|if
condition|(
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|SCOMMON
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a hook called by coff_real_object_p to create any backend    specific information.  */
end_comment

begin_function
name|PTR
name|ecoff_mkobject_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|,
name|aouthdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|PTR
name|aouthdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|struct
name|internal_aouthdr
modifier|*
name|internal_a
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr
decl_stmt|;
name|ecoff_data_type
modifier|*
name|ecoff
decl_stmt|;
name|asection
modifier|*
name|regsec
decl_stmt|;
if|if
condition|(
name|ecoff_mkobject
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|NULL
return|;
name|ecoff
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ecoff
operator|->
name|gp_size
operator|=
literal|8
expr_stmt|;
name|ecoff
operator|->
name|sym_filepos
operator|=
name|internal_f
operator|->
name|f_symptr
expr_stmt|;
comment|/* Create the .reginfo section to give programs outside BFD a way to      see the information stored in the a.out header.  See the comment      in coff/ecoff.h.  */
name|regsec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|REGINFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|regsec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|internal_a
operator|!=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ecoff
operator|->
name|text_start
operator|=
name|internal_a
operator|->
name|text_start
expr_stmt|;
name|ecoff
operator|->
name|text_end
operator|=
name|internal_a
operator|->
name|text_start
operator|+
name|internal_a
operator|->
name|tsize
expr_stmt|;
name|ecoff
operator|->
name|gp
operator|=
name|internal_a
operator|->
name|gp_value
expr_stmt|;
name|ecoff
operator|->
name|gprmask
operator|=
name|internal_a
operator|->
name|gprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|ecoff
operator|->
name|cprmask
index|[
name|i
index|]
operator|=
name|internal_a
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
name|ecoff
operator|->
name|fprmask
operator|=
name|internal_a
operator|->
name|fprmask
expr_stmt|;
if|if
condition|(
name|internal_a
operator|->
name|magic
operator|==
name|ECOFF_AOUT_ZMAGIC
condition|)
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
block|}
comment|/* It turns out that no special action is required by the MIPS or      Alpha ECOFF backends.  They have different information in the      a.out header, but we just copy it all (e.g., gprmask, cprmask and      fprmask) and let the swapping routines ensure that only relevant      information is written out.  */
return|return
operator|(
name|PTR
operator|)
name|ecoff
return|;
block|}
end_function

begin_comment
comment|/* This is a hook needed by SCO COFF, but we have nothing to do.  */
end_comment

begin_function
name|asection
modifier|*
name|ecoff_make_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|asection
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Initialize a new section.  */
end_comment

begin_function
name|boolean
name|ecoff_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|section
operator|->
name|alignment_power
operator|=
name|abfd
operator|->
name|xvec
operator|->
name|align_power_min
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_SDATA
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIT8
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIT4
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_SBSS
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
operator||
name|SEC_NEVER_LOAD
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_reginfo
argument_list|)
expr_stmt|;
block|}
comment|/* Probably any other section name is SEC_NEVER_LOAD, but I'm      uncertain about .init on some systems and I don't know how shared      libraries work.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine the machine architecture and type.  This is called from    the generic COFF routines.  It is the inverse of ecoff_get_magic,    below.  This could be an ECOFF backend routine, with one version    for each target, but there aren't all that many ECOFF targets.  */
end_comment

begin_function
name|boolean
name|ecoff_set_arch_mach_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
case|case
name|MIPS_MAGIC_1
case|:
case|case
name|MIPS_MAGIC_LITTLE
case|:
case|case
name|MIPS_MAGIC_BIG
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|mach
operator|=
literal|3000
expr_stmt|;
break|break;
case|case
name|MIPS_MAGIC_LITTLE2
case|:
case|case
name|MIPS_MAGIC_BIG2
case|:
comment|/* MIPS ISA level 2: the r6000 */
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|mach
operator|=
literal|6000
expr_stmt|;
break|break;
case|case
name|MIPS_MAGIC_LITTLE3
case|:
case|case
name|MIPS_MAGIC_BIG3
case|:
comment|/* MIPS ISA level 3: the r4000 */
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|mach
operator|=
literal|4000
expr_stmt|;
break|break;
case|case
name|ALPHA_MAGIC
case|:
name|arch
operator|=
name|bfd_arch_alpha
expr_stmt|;
name|mach
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
name|mach
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the magic number to use based on the architecture and machine.    This is the inverse of ecoff_set_arch_mach_hook, above.  */
end_comment

begin_function
specifier|static
name|int
name|ecoff_get_magic
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|big
decl_stmt|,
name|little
decl_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_mips
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
literal|0
case|:
case|case
literal|3000
case|:
name|big
operator|=
name|MIPS_MAGIC_BIG
expr_stmt|;
name|little
operator|=
name|MIPS_MAGIC_LITTLE
expr_stmt|;
break|break;
case|case
literal|6000
case|:
name|big
operator|=
name|MIPS_MAGIC_BIG2
expr_stmt|;
name|little
operator|=
name|MIPS_MAGIC_LITTLE2
expr_stmt|;
break|break;
case|case
literal|4000
case|:
name|big
operator|=
name|MIPS_MAGIC_BIG3
expr_stmt|;
name|little
operator|=
name|MIPS_MAGIC_LITTLE3
expr_stmt|;
break|break;
block|}
return|return
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|?
name|big
else|:
name|little
return|;
case|case
name|bfd_arch_alpha
case|:
return|return
name|ALPHA_MAGIC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the section s_flags to use for a section.  */
end_comment

begin_function
name|long
name|ecoff_sec_to_styp_flags
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|long
name|styp
decl_stmt|;
name|styp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_SDATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIT8
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIT4
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_LIT4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_BSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_SBSS
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_INIT
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_ECOFF_INIT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_FINI
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_ECOFF_FINI
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
name|styp
operator|=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_DATA
condition|)
name|styp
operator|=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_READONLY
condition|)
name|styp
operator|=
name|STYP_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_LOAD
condition|)
name|styp
operator|=
name|STYP_REG
expr_stmt|;
else|else
name|styp
operator|=
name|STYP_BSS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|styp
operator||=
name|STYP_NOLOAD
expr_stmt|;
return|return
name|styp
return|;
block|}
end_function

begin_comment
comment|/* Get the BFD flags to use for a section.  */
end_comment

begin_function
name|flagword
name|ecoff_styp_to_sec_flags
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|internal_s
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|hdr
decl_stmt|;
name|long
name|styp_flags
init|=
name|internal_s
operator|->
name|s_flags
decl_stmt|;
name|flagword
name|sec_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|styp_flags
operator|&
name|STYP_NOLOAD
condition|)
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
comment|/* For 386 COFF, at least, an unloadable text or data section is      actually a shared library section.  */
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_TEXT
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_ECOFF_INIT
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_ECOFF_FINI
operator|)
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_DATA
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_RDATA
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_SDATA
operator|)
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|styp_flags
operator|&
name|STYP_RDATA
condition|)
name|sec_flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_BSS
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_SBSS
operator|)
condition|)
block|{
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_INFO
condition|)
block|{
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_LIT8
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_LIT4
operator|)
condition|)
block|{
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
expr_stmt|;
block|}
else|else
block|{
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
block|}
return|return
name|sec_flags
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to swap auxiliary information in and out.  I am assuming    that the auxiliary information format is always going to be target    independent.  */
end_comment

begin_comment
comment|/* Swap in a type information record.    BIGEND says whether AUX symbols are big-endian or little-endian; this    info comes from the file header record (fh-fBigendian).  */
end_comment

begin_function
name|void
name|ecoff_swap_tir_in
parameter_list|(
name|bigend
parameter_list|,
name|ext_copy
parameter_list|,
name|intern
parameter_list|)
name|int
name|bigend
decl_stmt|;
name|struct
name|tir_ext
modifier|*
name|ext_copy
decl_stmt|;
name|TIR
modifier|*
name|intern
decl_stmt|;
block|{
name|struct
name|tir_ext
name|ext
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|ext
operator|=
operator|*
name|ext_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff... */
if|if
condition|(
name|bigend
condition|)
block|{
name|intern
operator|->
name|fBitfield
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_FBITFIELD_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|continued
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_CONTINUED_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|bt
operator|=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_BT_BIG
operator|)
operator|>>
name|TIR_BITS1_BT_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq4
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ4_BIG
operator|)
operator|>>
name|TIR_BITS_TQ4_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq5
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ5_BIG
operator|)
operator|>>
name|TIR_BITS_TQ5_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq0
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ0_BIG
operator|)
operator|>>
name|TIR_BITS_TQ0_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq1
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ1_BIG
operator|)
operator|>>
name|TIR_BITS_TQ1_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq2
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ2_BIG
operator|)
operator|>>
name|TIR_BITS_TQ2_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq3
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ3_BIG
operator|)
operator|>>
name|TIR_BITS_TQ3_SH_BIG
expr_stmt|;
block|}
else|else
block|{
name|intern
operator|->
name|fBitfield
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_FBITFIELD_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|continued
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_CONTINUED_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|bt
operator|=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_BT_LITTLE
operator|)
operator|>>
name|TIR_BITS1_BT_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq4
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ4_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ4_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq5
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ5_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ5_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq0
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ0_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ0_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq1
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ1_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ1_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq2
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ2_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ2_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq3
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ3_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ3_SH_LITTLE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Swap out a type information record.    BIGEND says whether AUX symbols are big-endian or little-endian; this    info comes from the file header record (fh-fBigendian).  */
end_comment

begin_function
name|void
name|ecoff_swap_tir_out
parameter_list|(
name|bigend
parameter_list|,
name|intern_copy
parameter_list|,
name|ext
parameter_list|)
name|int
name|bigend
decl_stmt|;
name|TIR
modifier|*
name|intern_copy
decl_stmt|;
name|struct
name|tir_ext
modifier|*
name|ext
decl_stmt|;
block|{
name|TIR
name|intern
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|intern
operator|=
operator|*
name|intern_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff... */
if|if
condition|(
name|bigend
condition|)
block|{
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|intern
operator|->
name|fBitfield
condition|?
name|TIR_BITS1_FBITFIELD_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|intern
operator|->
name|continued
condition|?
name|TIR_BITS1_CONTINUED_BIG
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|bt
operator|<<
name|TIR_BITS1_BT_SH_BIG
operator|)
operator|&
name|TIR_BITS1_BT_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq4
operator|<<
name|TIR_BITS_TQ4_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ4_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq5
operator|<<
name|TIR_BITS_TQ5_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ5_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq0
operator|<<
name|TIR_BITS_TQ0_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ0_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq1
operator|<<
name|TIR_BITS_TQ1_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ1_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq2
operator|<<
name|TIR_BITS_TQ2_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ2_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq3
operator|<<
name|TIR_BITS_TQ3_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ3_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|intern
operator|->
name|fBitfield
condition|?
name|TIR_BITS1_FBITFIELD_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|intern
operator|->
name|continued
condition|?
name|TIR_BITS1_CONTINUED_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|bt
operator|<<
name|TIR_BITS1_BT_SH_LITTLE
operator|)
operator|&
name|TIR_BITS1_BT_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq4
operator|<<
name|TIR_BITS_TQ4_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ4_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq5
operator|<<
name|TIR_BITS_TQ5_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ5_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq0
operator|<<
name|TIR_BITS_TQ0_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ0_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq1
operator|<<
name|TIR_BITS_TQ1_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ1_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq2
operator|<<
name|TIR_BITS_TQ2_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ2_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq3
operator|<<
name|TIR_BITS_TQ3_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ3_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Swap in a relative symbol record.  BIGEND says whether it is in    big-endian or little-endian format.*/
end_comment

begin_function
name|void
name|ecoff_swap_rndx_in
parameter_list|(
name|bigend
parameter_list|,
name|ext_copy
parameter_list|,
name|intern
parameter_list|)
name|int
name|bigend
decl_stmt|;
name|struct
name|rndx_ext
modifier|*
name|ext_copy
decl_stmt|;
name|RNDXR
modifier|*
name|intern
decl_stmt|;
block|{
name|struct
name|rndx_ext
name|ext
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|ext
operator|=
operator|*
name|ext_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff... */
if|if
condition|(
name|bigend
condition|)
block|{
name|intern
operator|->
name|rfd
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RNDX_BITS0_RFD_SH_LEFT_BIG
operator|)
operator||
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_RFD_BIG
operator|)
operator|>>
name|RNDX_BITS1_RFD_SH_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|index
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_INDEX_BIG
operator|)
operator|<<
name|RNDX_BITS1_INDEX_SH_LEFT_BIG
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RNDX_BITS2_INDEX_SH_LEFT_BIG
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|<<
name|RNDX_BITS3_INDEX_SH_LEFT_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|intern
operator|->
name|rfd
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RNDX_BITS0_RFD_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_RFD_LITTLE
operator|)
operator|<<
name|RNDX_BITS1_RFD_SH_LEFT_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|index
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_INDEX_LITTLE
operator|)
operator|>>
name|RNDX_BITS1_INDEX_SH_LITTLE
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RNDX_BITS2_INDEX_SH_LEFT_LITTLE
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|<<
name|RNDX_BITS3_INDEX_SH_LEFT_LITTLE
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Swap out a relative symbol record.  BIGEND says whether it is in    big-endian or little-endian format.*/
end_comment

begin_function
name|void
name|ecoff_swap_rndx_out
parameter_list|(
name|bigend
parameter_list|,
name|intern_copy
parameter_list|,
name|ext
parameter_list|)
name|int
name|bigend
decl_stmt|;
name|RNDXR
modifier|*
name|intern_copy
decl_stmt|;
name|struct
name|rndx_ext
modifier|*
name|ext
decl_stmt|;
block|{
name|RNDXR
name|intern
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|intern
operator|=
operator|*
name|intern_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff... */
if|if
condition|(
name|bigend
condition|)
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|intern
operator|->
name|rfd
operator|>>
name|RNDX_BITS0_RFD_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|rfd
operator|<<
name|RNDX_BITS1_RFD_SH_BIG
operator|)
operator|&
name|RNDX_BITS1_RFD_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS1_INDEX_SH_LEFT_BIG
operator|)
operator|&
name|RNDX_BITS1_INDEX_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS2_INDEX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS3_INDEX_SH_LEFT_BIG
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|intern
operator|->
name|rfd
operator|>>
name|RNDX_BITS0_RFD_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|rfd
operator|>>
name|RNDX_BITS1_RFD_SH_LEFT_LITTLE
operator|)
operator|&
name|RNDX_BITS1_RFD_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|index
operator|<<
name|RNDX_BITS1_INDEX_SH_LITTLE
operator|)
operator|&
name|RNDX_BITS1_INDEX_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS2_INDEX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS3_INDEX_SH_LEFT_LITTLE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in and swap the important symbolic information for an ECOFF    object file.  This is called by gdb.  */
end_comment

begin_function
name|boolean
name|ecoff_slurp_symbolic_info
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_size_type
name|external_hdr_size
decl_stmt|;
name|HDRR
modifier|*
name|internal_symhdr
decl_stmt|;
name|bfd_size_type
name|raw_base
decl_stmt|;
name|bfd_size_type
name|raw_size
decl_stmt|;
name|PTR
name|raw
decl_stmt|;
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_size_type
name|raw_end
decl_stmt|;
name|bfd_size_type
name|cb_end
decl_stmt|;
comment|/* Check whether we've already gotten it, and whether there's any to      get.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_syments
operator|!=
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|==
literal|0
condition|)
block|{
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* At this point bfd_get_symcount (abfd) holds the number of symbols      as read from the file header, but on ECOFF this is always the      size of the symbolic information header.  It would be cleaner to      handle this when we first read the file in coffgen.c.  */
name|external_hdr_size
operator|=
name|backend
operator|->
name|external_hdr_size
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
name|external_hdr_size
condition|)
block|{
name|bfd_error
operator|=
name|bad_value
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Read the symbolic information header.  */
name|raw
operator|=
operator|(
name|PTR
operator|)
name|alloca
argument_list|(
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|bfd_read
argument_list|(
name|raw
argument_list|,
name|external_hdr_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|external_hdr_size
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|false
return|;
block|}
name|internal_symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|raw
argument_list|,
name|internal_symhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_symhdr
operator|->
name|magic
operator|!=
name|backend
operator|->
name|sym_magic
condition|)
block|{
name|bfd_error
operator|=
name|bad_value
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Now we can get the correct number of symbols.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|internal_symhdr
operator|->
name|isymMax
operator|+
name|internal_symhdr
operator|->
name|iextMax
operator|)
expr_stmt|;
comment|/* Read all the symbolic information at once.  */
name|raw_base
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|+
name|external_hdr_size
expr_stmt|;
comment|/* Alpha ecoff makes the determination of raw_size difficult. It has      an undocumented debug data section between the symhdr and the first      documented section. And the ordering of the sections varies between      statically and dynamically linked executables.      If bfd supports SEEK_END someday, this code could be simplified.  */
name|raw_end
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|UPDATE_RAW_END
parameter_list|(
name|start
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|)
define|\
value|cb_end = internal_symhdr->start + internal_symhdr->count * (size); \   if (cb_end> raw_end) \     raw_end = cb_end
name|UPDATE_RAW_END
argument_list|(
name|cbLineOffset
argument_list|,
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|backend
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|backend
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|backend
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|backend
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|backend
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|backend
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|backend
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|UPDATE_RAW_END
name|raw_size
operator|=
name|raw_end
operator|-
name|raw_base
expr_stmt|;
if|if
condition|(
name|raw_size
operator|==
literal|0
condition|)
block|{
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
name|raw
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
name|raw
argument_list|,
name|raw_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|raw_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_size
operator|=
name|raw_size
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_syments
operator|=
name|raw
expr_stmt|;
comment|/* Get pointers for the numeric offsets in the HDRR structure.  */
define|#
directive|define
name|FIX
parameter_list|(
name|off1
parameter_list|,
name|off2
parameter_list|,
name|type
parameter_list|)
define|\
value|if (internal_symhdr->off1 == 0) \     ecoff_data (abfd)->off2 = (type) NULL; \   else \     ecoff_data (abfd)->off2 = (type) ((char *) raw \ 				      + internal_symhdr->off1 \ 				      - raw_base)
name|FIX
argument_list|(
argument|cbLineOffset
argument_list|,
argument|line
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|FIX
argument_list|(
name|cbDnOffset
argument_list|,
name|external_dnr
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbPdOffset
argument_list|,
name|external_pdr
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbSymOffset
argument_list|,
name|external_sym
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbOptOffset
argument_list|,
name|external_opt
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbAuxOffset
argument_list|,
name|external_aux
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbSsOffset
argument_list|,
name|ss
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbSsExtOffset
argument_list|,
name|ssext
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbFdOffset
argument_list|,
name|external_fdr
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbRfdOffset
argument_list|,
name|external_rfd
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbExtOffset
argument_list|,
name|external_ext
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIX
comment|/* I don't want to always swap all the data, because it will just      waste time and most programs will never look at it.  The only      time the linker needs most of the debugging information swapped      is when linking big-endian and little-endian MIPS object files      together, which is not a common occurrence.       We need to look at the fdr to deal with a lot of information in      the symbols, so we swap them here.  */
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
operator|=
operator|(
expr|struct
name|fdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|internal_symhdr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|external_fdr_size
operator|=
name|backend
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
name|fraw_src
operator|+
name|internal_symhdr
operator|->
name|ifdMax
operator|*
name|external_fdr_size
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|backend
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ECOFF symbol table routines.  The ECOFF symbol table is described    in gcc/mips-tfile.c.  */
end_comment

begin_comment
comment|/* ECOFF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|ecoff_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|ecoff_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|ecoff_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an empty symbol.  */
end_comment

begin_function
name|asymbol
modifier|*
name|ecoff_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ecoff_symbol_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ecoff_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|asymbol
operator|*
operator|)
name|NULL
return|;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|fdr
operator|=
operator|(
name|FDR
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|local
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|native
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Set the BFD flags and section for an ECOFF symbol.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_set_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|ecoff_sym
parameter_list|,
name|asym
parameter_list|,
name|ext
parameter_list|,
name|indirect_ptr_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|SYMR
modifier|*
name|ecoff_sym
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|indirect_ptr_ptr
decl_stmt|;
block|{
name|asym
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|ecoff_sym
operator|->
name|value
expr_stmt|;
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_debug_section
expr_stmt|;
name|asym
operator|->
name|udata
operator|=
name|NULL
expr_stmt|;
comment|/* An indirect symbol requires two consecutive stabs symbols.  */
if|if
condition|(
operator|*
name|indirect_ptr_ptr
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @@ Stuffing pointers into integers is a no-no. 	 We can usually get away with it if the integer is 	 large enough though.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|asym
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|(
operator|*
name|indirect_ptr_ptr
operator|)
operator|->
name|value
operator|=
operator|(
name|bfd_vma
operator|)
name|asym
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
operator|*
name|indirect_ptr_ptr
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
operator|&&
operator|(
name|ECOFF_UNMARK_STAB
argument_list|(
name|ecoff_sym
operator|->
name|index
argument_list|)
operator||
name|N_EXT
operator|)
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
block|{
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
operator||
name|BSF_INDIRECT
expr_stmt|;
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_ind_section
expr_stmt|;
comment|/* Pass this symbol on to the next call to this function.  */
operator|*
name|indirect_ptr_ptr
operator|=
name|asym
expr_stmt|;
return|return;
block|}
comment|/* Most symbol types are just for debugging.  */
switch|switch
condition|(
name|ecoff_sym
operator|->
name|st
condition|)
block|{
case|case
name|stGlobal
case|:
case|case
name|stStatic
case|:
case|case
name|stLabel
case|:
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
break|break;
case|case
name|stNil
case|:
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
condition|)
block|{
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ext
condition|)
name|asym
operator|->
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
else|else
name|asym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
switch|switch
condition|(
name|ecoff_sym
operator|->
name|sc
condition|)
block|{
case|case
name|scNil
case|:
comment|/* Used for compiler generated labels.  Leave them in the 	 debugging section, and mark them as local.  If BSF_DEBUGGING 	 is set, then nm does not display them for some reason.  If no 	 flags are set then the linker whines about them.  */
name|asym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
break|break;
case|case
name|scText
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scData
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scBss
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRegister
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scAbs
case|:
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
break|break;
case|case
name|scUndefined
case|:
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|asym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|scCdbLocal
case|:
case|case
name|scBits
case|:
case|case
name|scCdbSystem
case|:
case|case
name|scRegImage
case|:
case|case
name|scInfo
case|:
case|case
name|scUserStruct
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scSData
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".sdata"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scSBss
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRData
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".rdata"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scVar
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scCommon
case|:
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp_size
condition|)
block|{
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_com_section
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|scSCommon
case|:
if|if
condition|(
name|ecoff_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|ecoff_scom_section
operator|.
name|name
operator|=
name|SCOMMON
expr_stmt|;
name|ecoff_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|ecoff_scom_section
operator|.
name|output_section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|ecoff_scom_section
operator|.
name|symbol
operator|=
operator|&
name|ecoff_scom_symbol
expr_stmt|;
name|ecoff_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|ecoff_scom_symbol_ptr
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|name
operator|=
name|SCOMMON
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|ecoff_scom_symbol_ptr
operator|=
operator|&
name|ecoff_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|scVarRegister
case|:
case|case
name|scVariant
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scSUndefined
case|:
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|asym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|scInit
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scBasedVar
case|:
case|case
name|scXData
case|:
case|case
name|scPData
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scFini
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Look for special constructors symbols and make relocation entries      in a special construction section.  These are produced by the      -fgnu-linker argument to g++.  */
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ECOFF_UNMARK_STAB
argument_list|(
name|ecoff_sym
operator|->
name|index
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|N_SETA
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETB
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|arelent_chain
modifier|*
name|reloc_chain
decl_stmt|;
name|unsigned
name|int
name|bitsize
decl_stmt|;
comment|/* Get a section with the same name as the symbol (usually 	       __CTOR_LIST__ or __DTOR_LIST__).  FIXME: gcc uses the 	       name ___CTOR_LIST (three underscores).  We need 	       __CTOR_LIST (two underscores), since ECOFF doesn't use 	       a leading underscore.  This should be handled by gcc, 	       but instead we do it here.  Actually, this should all 	       be done differently anyhow.  */
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|asym
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
operator|++
name|name
expr_stmt|;
name|asym
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Build a reloc pointing to this constructor.  */
name|reloc_chain
operator|=
operator|(
name|arelent_chain
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent_chain
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_chain
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|bfd_get_section
argument_list|(
name|asym
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|reloc_chain
operator|->
name|relent
operator|.
name|address
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|reloc_chain
operator|->
name|relent
operator|.
name|addend
operator|=
name|asym
operator|->
name|value
expr_stmt|;
name|reloc_chain
operator|->
name|relent
operator|.
name|howto
operator|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|constructor_reloc
expr_stmt|;
comment|/* Set up the constructor section to hold the reloc.  */
name|section
operator|->
name|flags
operator|=
name|SEC_CONSTRUCTOR
expr_stmt|;
operator|++
name|section
operator|->
name|reloc_count
expr_stmt|;
comment|/* Constructor sections must be rounded to a boundary 	       based on the bitsize.  These are not real sections-- 	       they are handled specially by the linker--so the ECOFF 	       16 byte alignment restriction does not apply.  */
name|bitsize
operator|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|constructor_bitsize
expr_stmt|;
name|section
operator|->
name|alignment_power
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|section
operator|->
name|alignment_power
operator|)
operator|<
name|bitsize
operator|/
literal|8
condition|)
operator|++
name|section
operator|->
name|alignment_power
expr_stmt|;
name|reloc_chain
operator|->
name|next
operator|=
name|section
operator|->
name|constructor_chain
expr_stmt|;
name|section
operator|->
name|constructor_chain
operator|=
name|reloc_chain
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|+=
name|bitsize
operator|/
literal|8
expr_stmt|;
comment|/* Mark the symbol as a constructor.  */
name|asym
operator|->
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read an ECOFF symbol table.  */
end_comment

begin_function
name|boolean
name|ecoff_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|backend
operator|->
name|external_ext_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|backend
operator|->
name|external_sym_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_ext_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_sym_in
expr_stmt|;
name|bfd_size_type
name|internal_size
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|internal
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|internal_ptr
decl_stmt|;
name|asymbol
modifier|*
name|indirect_ptr
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|FDR
modifier|*
name|fdr_end
decl_stmt|;
comment|/* If we've already read in the symbol table, do nothing.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|canonical_symbols
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
comment|/* Get the symbolic information.  */
if|if
condition|(
name|ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|internal_size
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ecoff_symbol_type
argument_list|)
expr_stmt|;
name|internal
operator|=
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|internal_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|internal_ptr
operator|=
name|internal
expr_stmt|;
name|indirect_ptr
operator|=
name|NULL
expr_stmt|;
name|eraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|*
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|external_ext_size
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|EXTR
name|internal_esym
decl_stmt|;
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|internal_esym
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ssext
operator|+
name|internal_esym
operator|.
name|asym
operator|.
name|iss
operator|)
expr_stmt|;
name|ecoff_set_symbol_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_esym
operator|.
name|asym
argument_list|,
operator|&
name|internal_ptr
operator|->
name|symbol
argument_list|,
literal|1
argument_list|,
operator|&
name|indirect_ptr
argument_list|)
expr_stmt|;
comment|/* The alpha uses a negative ifd field for section symbols.  */
if|if
condition|(
name|internal_esym
operator|.
name|ifd
operator|>=
literal|0
condition|)
name|internal_ptr
operator|->
name|fdr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
operator|+
name|internal_esym
operator|.
name|ifd
expr_stmt|;
else|else
name|internal_ptr
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|internal_ptr
operator|->
name|local
operator|=
name|false
expr_stmt|;
name|internal_ptr
operator|->
name|native
operator|=
operator|(
name|PTR
operator|)
name|eraw_src
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|indirect_ptr
operator|==
operator|(
name|asymbol
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* The local symbols must be accessed via the fdr's, because the      string and aux indices are relative to the fdr information.  */
name|fdr_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|fdr_end
operator|=
name|fdr_ptr
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|ifdMax
expr_stmt|;
for|for
control|(
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|++
control|)
block|{
name|char
modifier|*
name|lraw_src
decl_stmt|;
name|char
modifier|*
name|lraw_end
decl_stmt|;
name|lraw_src
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_sym
operator|+
name|fdr_ptr
operator|->
name|isymBase
operator|*
name|external_sym_size
operator|)
expr_stmt|;
name|lraw_end
operator|=
name|lraw_src
operator|+
name|fdr_ptr
operator|->
name|csym
operator|*
name|external_sym_size
expr_stmt|;
for|for
control|(
init|;
name|lraw_src
operator|<
name|lraw_end
condition|;
name|lraw_src
operator|+=
name|external_sym_size
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|lraw_src
argument_list|,
operator|&
name|internal_sym
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|internal_sym
operator|.
name|iss
operator|)
expr_stmt|;
name|ecoff_set_symbol_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
operator|&
name|internal_ptr
operator|->
name|symbol
argument_list|,
literal|0
argument_list|,
operator|&
name|indirect_ptr
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|fdr
operator|=
name|fdr_ptr
expr_stmt|;
name|internal_ptr
operator|->
name|local
operator|=
name|true
expr_stmt|;
name|internal_ptr
operator|->
name|native
operator|=
operator|(
name|PTR
operator|)
name|lraw_src
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|indirect_ptr
operator|==
operator|(
name|asymbol
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|canonical_symbols
operator|=
name|internal
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of space needed for the canonical symbols.  */
end_comment

begin_function
name|unsigned
name|int
name|ecoff_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
operator|||
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ecoff_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the canonicals symbols.  */
end_comment

begin_function
name|unsigned
name|int
name|ecoff_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|symbase
decl_stmt|;
name|ecoff_symbol_type
modifier|*
modifier|*
name|location
init|=
operator|(
name|ecoff_symbol_type
operator|*
operator|*
operator|)
name|alocation
decl_stmt|;
if|if
condition|(
name|ecoff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
operator|||
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|symbase
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|canonical_symbols
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
name|symbase
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
operator|*
name|location
operator|++
operator|=
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Turn ECOFF type information into a printable string.    ecoff_emit_aggregate and ecoff_type_to_string are from    gcc/mips-tdump.c, with swapping added and used_ptr removed.  */
end_comment

begin_comment
comment|/* Write aggregate information to a string.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_emit_aggregate
parameter_list|(
name|abfd
parameter_list|,
name|string
parameter_list|,
name|rndx
parameter_list|,
name|isym
parameter_list|,
name|which
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|RNDXR
modifier|*
name|rndx
decl_stmt|;
name|long
name|isym
decl_stmt|;
name|CONST
name|char
modifier|*
name|which
decl_stmt|;
block|{
name|int
name|ifd
init|=
name|rndx
operator|->
name|rfd
decl_stmt|;
name|int
name|indx
init|=
name|rndx
operator|->
name|index
decl_stmt|;
name|int
name|sym_base
decl_stmt|,
name|ss_base
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|ifd
operator|==
literal|0xfff
condition|)
name|ifd
operator|=
name|isym
expr_stmt|;
name|sym_base
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
index|[
name|ifd
index|]
operator|.
name|isymBase
expr_stmt|;
name|ss_base
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
index|[
name|ifd
index|]
operator|.
name|issBase
expr_stmt|;
if|if
condition|(
name|indx
operator|==
name|indexNil
condition|)
name|name
operator|=
literal|"/* no name */"
expr_stmt|;
else|else
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
name|indx
operator|+=
name|sym_base
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_sym
operator|+
name|indx
operator|*
name|backend
operator|->
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|name
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ss
operator|+
name|ss_base
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s %s { ifd = %d, index = %d }"
argument_list|,
name|which
argument_list|,
name|name
argument_list|,
name|ifd
argument_list|,
name|indx
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the type information to string format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ecoff_type_to_string
parameter_list|(
name|abfd
parameter_list|,
name|aux_ptr
parameter_list|,
name|indx
parameter_list|,
name|bigendian
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|aux_ptr
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|int
name|bigendian
decl_stmt|;
block|{
name|AUXU
name|u
decl_stmt|;
struct|struct
name|qual
block|{
name|unsigned
name|int
name|type
decl_stmt|;
name|int
name|low_bound
decl_stmt|;
name|int
name|high_bound
decl_stmt|;
name|int
name|stride
decl_stmt|;
block|}
name|qualifiers
index|[
literal|7
index|]
struct|;
name|unsigned
name|int
name|basic_type
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buffer1
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
name|buffer2
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|buffer1
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|buffer2
decl_stmt|;
name|RNDXR
name|rndx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|qualifiers
index|[
name|i
index|]
operator|.
name|low_bound
operator|=
literal|0
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|high_bound
operator|=
literal|0
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|stride
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|"-1 (no type)"
return|;
name|ecoff_swap_tir_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|++
index|]
operator|.
name|a_ti
argument_list|,
operator|&
name|u
operator|.
name|ti
argument_list|)
expr_stmt|;
name|basic_type
operator|=
name|u
operator|.
name|ti
operator|.
name|bt
expr_stmt|;
name|qualifiers
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq0
expr_stmt|;
name|qualifiers
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq1
expr_stmt|;
name|qualifiers
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq2
expr_stmt|;
name|qualifiers
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq3
expr_stmt|;
name|qualifiers
index|[
literal|4
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq4
expr_stmt|;
name|qualifiers
index|[
literal|5
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq5
expr_stmt|;
name|qualifiers
index|[
literal|6
index|]
operator|.
name|type
operator|=
name|tqNil
expr_stmt|;
comment|/*    * Go get the basic type.    */
switch|switch
condition|(
name|basic_type
condition|)
block|{
case|case
name|btNil
case|:
comment|/* undefined */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"nil"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btAdr
case|:
comment|/* address - integer same size as pointer */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btChar
case|:
comment|/* character */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btUChar
case|:
comment|/* unsigned character */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btShort
case|:
comment|/* short */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btUShort
case|:
comment|/* unsigned short */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned short"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btInt
case|:
comment|/* int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btUInt
case|:
comment|/* unsigned int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btLong
case|:
comment|/* long */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btULong
case|:
comment|/* unsigned long */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btFloat
case|:
comment|/* float (real) */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btDouble
case|:
comment|/* Double (real) */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
break|break;
comment|/* Structures add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to struct def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|btStruct
case|:
comment|/* Structure (Record) */
name|ecoff_swap_rndx_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
operator|.
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|ecoff_emit_aggregate
argument_list|(
name|abfd
argument_list|,
name|p1
argument_list|,
operator|&
name|rndx
argument_list|,
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|1
index|]
argument_list|)
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
comment|/* Unions add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to union def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|btUnion
case|:
comment|/* Union */
name|ecoff_swap_rndx_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
operator|.
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|ecoff_emit_aggregate
argument_list|(
name|abfd
argument_list|,
name|p1
argument_list|,
operator|&
name|rndx
argument_list|,
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|1
index|]
argument_list|)
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
comment|/* Enumerations add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to enum def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|btEnum
case|:
comment|/* Enumeration */
name|ecoff_swap_rndx_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
operator|.
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|ecoff_emit_aggregate
argument_list|(
name|abfd
argument_list|,
name|p1
argument_list|,
operator|&
name|rndx
argument_list|,
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|1
index|]
argument_list|)
argument_list|,
literal|"enum"
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
case|case
name|btTypedef
case|:
comment|/* defined via a typedef, isymRef points */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btRange
case|:
comment|/* subrange of int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"subrange"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btSet
case|:
comment|/* pascal sets */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btComplex
case|:
comment|/* fortran complex */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btDComplex
case|:
comment|/* fortran double complex */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"double complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btIndirect
case|:
comment|/* forward or unnamed typedef */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"forward/unamed typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btFixedDec
case|:
comment|/* Fixed Decimal */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"fixed decimal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btFloatDec
case|:
comment|/* Float Decimal */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"float decimal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btString
case|:
comment|/* Varying Length Character String */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btBit
case|:
comment|/* Aligned Bit String */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"bit"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btPicture
case|:
comment|/* Picture */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"picture"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btVoid
case|:
comment|/* Void */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|p1
argument_list|,
literal|"Unknown basic type %d"
argument_list|,
operator|(
name|int
operator|)
name|basic_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|p1
operator|+=
name|strlen
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
comment|/*    * If this is a bitfield, get the bitsize.    */
if|if
condition|(
name|u
operator|.
name|ti
operator|.
name|fBitfield
condition|)
block|{
name|int
name|bitsize
decl_stmt|;
name|bitsize
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|++
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p1
argument_list|,
literal|" : %d"
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|strlen
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Deal with any qualifiers.    */
if|if
condition|(
name|qualifiers
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|tqNil
condition|)
block|{
comment|/*        * Snarf up any array bounds in the correct order.  Arrays        * store 5 successive words in the aux. table:        *	word 0	RNDXR to type of the bounds (ie, int)        *	word 1	Current file descriptor index        *	word 2	low bound        *	word 3	high bound (or -1 if [])        *	word 4	stride size in bits        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qualifiers
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tqArray
condition|)
block|{
name|qualifiers
index|[
name|i
index|]
operator|.
name|low_bound
operator|=
name|AUX_GET_DNLOW
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|high_bound
operator|=
name|AUX_GET_DNHIGH
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|indx
operator|+=
literal|5
expr_stmt|;
block|}
block|}
comment|/*        * Now print out the qualifiers.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|qualifiers
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|tqNil
case|:
case|case
name|tqMax
case|:
break|break;
case|case
name|tqPtr
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"ptr to "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"ptr to "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tqVol
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"volatile "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"volatile "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tqFar
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"far "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"far "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tqProc
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"func. ret. "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"func. ret. "
argument_list|)
expr_stmt|;
break|break;
case|case
name|tqArray
case|:
block|{
name|int
name|first_array
init|=
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Print array bounds reversed (ie, in the order the C 		   programmer writes them).  C is such a fun language.... */
while|while
condition|(
name|i
operator|<
literal|5
operator|&&
name|qualifiers
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|type
operator|==
name|tqArray
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>=
name|first_array
condition|;
name|j
operator|--
control|)
block|{
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"array ["
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"array ["
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|low_bound
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%ld:%ld {%ld bits}"
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|low_bound
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
operator|!=
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%ld {%ld bits}"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|" {%ld bits}"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|+=
name|strlen
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"] of "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"] of "
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
name|strcpy
argument_list|(
name|p2
argument_list|,
name|buffer1
argument_list|)
expr_stmt|;
return|return
name|buffer2
return|;
block|}
end_function

begin_comment
comment|/* Return information about ECOFF symbol SYMBOL in RET.  */
end_comment

begin_function
name|void
name|ecoff_get_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Ignored.  */
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print information about an ECOFF symbol.  */
end_comment

begin_function
name|void
name|ecoff_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
block|{
name|SYMR
name|ecoff_sym
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_sym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ecoff local "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ecoff_sym
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %x %x"
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_sym
operator|.
name|st
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_sym
operator|.
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EXTR
name|ecoff_ext
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_ext
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ecoff extern "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %x %x"
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|st
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_print_symbol_all
case|:
comment|/* Print out the symbols in a reasonable way */
block|{
name|char
name|type
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|EXTR
name|ecoff_ext
decl_stmt|;
name|char
name|jmptbl
decl_stmt|;
name|char
name|cobol_main
decl_stmt|;
name|char
name|weakext
decl_stmt|;
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
block|{
call|(
modifier|*
name|backend
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_ext
operator|.
name|asym
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'l'
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|-
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_sym
operator|)
operator|/
name|backend
operator|->
name|external_sym_size
operator|)
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|)
expr_stmt|;
name|jmptbl
operator|=
literal|' '
expr_stmt|;
name|cobol_main
operator|=
literal|' '
expr_stmt|;
name|weakext
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|backend
operator|->
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_ext
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'e'
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|-
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_ext
operator|)
operator|/
name|backend
operator|->
name|external_ext_size
operator|)
expr_stmt|;
name|jmptbl
operator|=
name|ecoff_ext
operator|.
name|jmptbl
condition|?
literal|'j'
else|:
literal|' '
expr_stmt|;
name|cobol_main
operator|=
name|ecoff_ext
operator|.
name|cobol_main
condition|?
literal|'c'
else|:
literal|' '
expr_stmt|;
name|weakext
operator|=
name|ecoff_ext
operator|.
name|weakext
condition|?
literal|'w'
else|:
literal|' '
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%3d] %c "
argument_list|,
name|pos
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" st %x sc %x indx %x %c%c%c %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|st
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
argument_list|,
name|jmptbl
argument_list|,
name|cobol_main
argument_list|,
name|weakext
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|fdr
operator|!=
name|NULL
operator|&&
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
operator|!=
name|indexNil
condition|)
block|{
name|unsigned
name|int
name|indx
decl_stmt|;
name|int
name|bigendian
decl_stmt|;
name|bfd_size_type
name|sym_base
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|aux_base
decl_stmt|;
name|indx
operator|=
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
expr_stmt|;
comment|/* sym_base is used to map the fdr relative indices which 	       appear in the file to the position number which we are 	       using.  */
name|sym_base
operator|=
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|fdr
operator|->
name|isymBase
expr_stmt|;
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
name|sym_base
operator|+=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
expr_stmt|;
comment|/* aux_base is the start of the aux entries for this file; 	       asym.index is an offset from this.  */
name|aux_base
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_aux
operator|+
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|fdr
operator|->
name|iauxBase
operator|)
expr_stmt|;
comment|/* The aux entries are stored in host byte order; the 	       order is indicated by a bit in the fdr.  */
name|bigendian
operator|=
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|fdr
operator|->
name|fBigendian
expr_stmt|;
comment|/* This switch is basically from gcc/mips-tdump.c  */
switch|switch
condition|(
name|ecoff_ext
operator|.
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stNil
case|:
case|case
name|stLabel
case|:
break|break;
case|case
name|stFile
case|:
case|case
name|stBlock
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n      End+1 symbol: %ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stEnd
case|:
if|if
condition|(
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scText
operator|||
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scInfo
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n      First symbol: %ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n      First symbol: %ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_base
index|[
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
index|]
argument_list|)
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|ecoff_ext
operator|.
name|asym
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n      End+1 symbol: %-7ld   Type:  %s"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_base
index|[
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
index|]
argument_list|)
operator|+
name|sym_base
argument_list|)
argument_list|,
name|ecoff_type_to_string
argument_list|(
name|abfd
argument_list|,
name|aux_base
argument_list|,
name|indx
operator|+
literal|1
argument_list|,
name|bigendian
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n      Local symbol: %d"
argument_list|,
operator|(
name|indx
operator|+
name|sym_base
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|ecoff_ext
operator|.
name|asym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n      Type: %s"
argument_list|,
name|ecoff_type_to_string
argument_list|(
name|abfd
argument_list|,
name|aux_base
argument_list|,
name|indx
argument_list|,
name|bigendian
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the relocs for a section.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|arelent
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_size_type
name|external_reloc_size
decl_stmt|;
name|bfd_size_type
name|external_relocs_size
decl_stmt|;
name|char
modifier|*
name|external_relocs
decl_stmt|;
name|arelent
modifier|*
name|rptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|relocation
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ecoff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|internal_relocs
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
operator|*
name|section
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
name|external_reloc_size
operator|=
name|backend
operator|->
name|external_reloc_size
expr_stmt|;
name|external_relocs_size
operator|=
name|external_reloc_size
operator|*
name|section
operator|->
name|reloc_count
expr_stmt|;
name|external_relocs
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|external_relocs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
operator|(
name|arelent
operator|*
operator|)
name|NULL
operator|||
name|external_relocs
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|external_relocs
argument_list|,
literal|1
argument_list|,
name|external_relocs_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|external_relocs_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rptr
operator|=
name|internal_relocs
init|;
name|i
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|rptr
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|intern
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_reloc_in
call|)
argument_list|(
name|abfd
argument_list|,
name|external_relocs
operator|+
name|i
operator|*
name|external_reloc_size
argument_list|,
operator|&
name|intern
argument_list|)
expr_stmt|;
if|if
condition|(
name|intern
operator|.
name|r_extern
condition|)
block|{
comment|/* r_symndx is an index into the external symbols.  */
name|BFD_ASSERT
argument_list|(
name|intern
operator|.
name|r_symndx
operator|>=
literal|0
operator|&&
operator|(
name|intern
operator|.
name|r_symndx
operator|<
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|)
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|intern
operator|.
name|r_symndx
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intern
operator|.
name|r_symndx
operator|==
name|RELOC_SECTION_NONE
operator|||
name|intern
operator|.
name|r_symndx
operator|==
name|RELOC_SECTION_ABS
condition|)
block|{
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section
operator|.
name|symbol_ptr_ptr
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|CONST
name|char
modifier|*
name|sec_name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* r_symndx is a section key.  */
switch|switch
condition|(
name|intern
operator|.
name|r_symndx
condition|)
block|{
case|case
name|RELOC_SECTION_TEXT
case|:
name|sec_name
operator|=
literal|".text"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_RDATA
case|:
name|sec_name
operator|=
literal|".rdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_DATA
case|:
name|sec_name
operator|=
literal|".data"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_SDATA
case|:
name|sec_name
operator|=
literal|".sdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_SBSS
case|:
name|sec_name
operator|=
literal|".sbss"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_BSS
case|:
name|sec_name
operator|=
literal|".bss"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_INIT
case|:
name|sec_name
operator|=
literal|".init"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_LIT8
case|:
name|sec_name
operator|=
literal|".lit8"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_LIT4
case|:
name|sec_name
operator|=
literal|".lit4"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_XDATA
case|:
name|sec_name
operator|=
literal|".xdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_PDATA
case|:
name|sec_name
operator|=
literal|".pdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_LITA
case|:
name|sec_name
operator|=
literal|".lita"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|sec
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
operator|-
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|rptr
operator|->
name|address
operator|=
name|intern
operator|.
name|r_vaddr
operator|-
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
comment|/* Let the backend select the howto field and do any other 	 required processing.  */
call|(
modifier|*
name|backend
operator|->
name|finish_reloc
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|intern
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|external_relocs
argument_list|)
expr_stmt|;
name|section
operator|->
name|relocation
operator|=
name|internal_relocs
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get a canonical list of relocs.  */
end_comment

begin_function
name|unsigned
name|int
name|ecoff_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
decl_stmt|;
comment|/* This section has relocs made up by us, not the file, so take 	 them out of their chain and place them into the data area 	 provided.  */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|chain
operator|=
name|section
operator|->
name|constructor_chain
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
operator|,
name|chain
operator|=
name|chain
operator|->
name|next
control|)
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
block|}
else|else
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
if|if
condition|(
name|ecoff_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|==
name|false
condition|)
return|return
literal|0
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
if|if
condition|(
name|tblptr
operator|==
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provided a BFD, a section and an offset into the section, calculate    and return the name of the source file and the line nearest to the    wanted location.  */
end_comment

begin_function
name|boolean
name|ecoff_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|ignore_symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|retline_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|ignore_symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|retline_ptr
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|FDR
modifier|*
name|fdr_start
decl_stmt|;
name|FDR
modifier|*
name|fdr_end
decl_stmt|;
name|FDR
modifier|*
name|fdr_hold
decl_stmt|;
name|bfd_size_type
name|external_pdr_size
decl_stmt|;
name|char
modifier|*
name|pdr_ptr
decl_stmt|;
name|char
modifier|*
name|pdr_end
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|line_end
decl_stmt|;
name|int
name|lineno
decl_stmt|;
comment|/* If we're not in the .text section, we don't have any line      numbers.  */
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|!=
literal|0
operator|||
name|offset
operator|<
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|text_start
operator|||
name|offset
operator|>=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|text_end
condition|)
return|return
name|false
return|;
comment|/* Make sure we have the FDR's.  */
if|if
condition|(
name|ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
operator|||
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Each file descriptor (FDR) has a memory address.  Here we track      down which FDR we want.  The FDR's are stored in increasing      memory order.  If speed is ever important, this can become a      binary search.  We must ignore FDR's with no PDR entries; they      will have the adr of the FDR before or after them.  */
name|fdr_start
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|fdr_end
operator|=
name|fdr_start
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
operator|.
name|ifdMax
expr_stmt|;
name|fdr_hold
operator|=
operator|(
name|FDR
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|fdr_ptr
operator|=
name|fdr_start
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|++
control|)
block|{
if|if
condition|(
name|fdr_ptr
operator|->
name|cpd
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|offset
operator|<
name|fdr_ptr
operator|->
name|adr
condition|)
break|break;
name|fdr_hold
operator|=
name|fdr_ptr
expr_stmt|;
block|}
if|if
condition|(
name|fdr_hold
operator|==
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|fdr_ptr
operator|=
name|fdr_hold
expr_stmt|;
comment|/* Each FDR has a list of procedure descriptors (PDR).  PDR's also      have an address, which is relative to the FDR address, and are      also stored in increasing memory order.  */
name|offset
operator|-=
name|fdr_ptr
operator|->
name|adr
expr_stmt|;
name|external_pdr_size
operator|=
name|backend
operator|->
name|external_pdr_size
expr_stmt|;
name|pdr_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_pdr
operator|+
name|fdr_ptr
operator|->
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
expr_stmt|;
name|pdr_end
operator|=
name|pdr_ptr
operator|+
name|fdr_ptr
operator|->
name|cpd
operator|*
name|external_pdr_size
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|pdr_ptr
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
comment|/* The address of the first PDR is an offset which applies to the      addresses of all the PDR's.  */
name|offset
operator|+=
name|pdr
operator|.
name|adr
expr_stmt|;
for|for
control|(
name|pdr_ptr
operator|+=
name|external_pdr_size
init|;
name|pdr_ptr
operator|<
name|pdr_end
condition|;
name|pdr_ptr
operator|+=
name|external_pdr_size
control|)
block|{
call|(
modifier|*
name|backend
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|pdr_ptr
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|pdr
operator|.
name|adr
condition|)
break|break;
block|}
comment|/* Now we can look for the actual line number.  The line numbers are      stored in a very funky format, which I won't try to describe.      Note that right here pdr_ptr and pdr hold the PDR *after* the one      we want; we need this to compute line_end.  */
name|line_end
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|line
expr_stmt|;
if|if
condition|(
name|pdr_ptr
operator|==
name|pdr_end
condition|)
name|line_end
operator|+=
name|fdr_ptr
operator|->
name|cbLineOffset
operator|+
name|fdr_ptr
operator|->
name|cbLine
expr_stmt|;
else|else
name|line_end
operator|+=
name|fdr_ptr
operator|->
name|cbLineOffset
operator|+
name|pdr
operator|.
name|cbLineOffset
expr_stmt|;
comment|/* Now change pdr and pdr_ptr to the one we want.  */
name|pdr_ptr
operator|-=
name|external_pdr_size
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|pdr_ptr
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|pdr
operator|.
name|adr
expr_stmt|;
name|lineno
operator|=
name|pdr
operator|.
name|lnLow
expr_stmt|;
name|line_ptr
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|line
operator|+
name|fdr_ptr
operator|->
name|cbLineOffset
operator|+
name|pdr
operator|.
name|cbLineOffset
operator|)
expr_stmt|;
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
name|int
name|delta
decl_stmt|;
name|int
name|count
decl_stmt|;
name|delta
operator|=
operator|*
name|line_ptr
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0x8
condition|)
name|delta
operator|-=
literal|0x10
expr_stmt|;
name|count
operator|=
operator|(
operator|*
name|line_ptr
operator|&
literal|0xf
operator|)
operator|+
literal|1
expr_stmt|;
operator|++
name|line_ptr
expr_stmt|;
if|if
condition|(
name|delta
operator|==
operator|-
literal|8
condition|)
block|{
name|delta
operator|=
operator|(
operator|(
operator|(
name|line_ptr
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|line_ptr
index|[
literal|1
index|]
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0x8000
condition|)
name|delta
operator|-=
literal|0x10000
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
block|}
name|lineno
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|count
operator|*
literal|4
condition|)
break|break;
name|offset
operator|-=
name|count
operator|*
literal|4
expr_stmt|;
block|}
comment|/* If fdr_ptr->rss is -1, then this file does not have full symbols,      at least according to gdb/mipsread.c.  */
if|if
condition|(
name|fdr_ptr
operator|->
name|rss
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pdr
operator|.
name|isym
operator|==
operator|-
literal|1
condition|)
operator|*
name|functionname_ptr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|EXTR
name|proc_ext
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_ext
operator|+
name|pdr
operator|.
name|isym
operator|*
name|backend
operator|->
name|external_ext_size
operator|)
argument_list|,
operator|&
name|proc_ext
argument_list|)
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ssext
operator|+
name|proc_ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
block|}
block|}
else|else
block|{
name|SYMR
name|proc_sym
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|fdr_ptr
operator|->
name|rss
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fdr_ptr
operator|->
name|isymBase
operator|+
name|pdr
operator|.
name|isym
operator|)
operator|*
name|backend
operator|->
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|proc_sym
argument_list|)
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|proc_sym
operator|.
name|iss
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|lineno
operator|==
name|ilineNil
condition|)
name|lineno
operator|=
literal|0
expr_stmt|;
operator|*
name|retline_ptr
operator|=
name|lineno
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We can't use the generic linking routines for ECOFF, because we    have to handle all the debugging information.  The generic link    routine just works out the section contents and attaches a list of    symbols.     We link by looping over all the seclets.  We make two passes.  On    the first we set the actual section contents and determine the size    of the debugging information.  On the second we accumulate the    debugging information and write it out.     This currently always accumulates the debugging information, which    is incorrect, because it ignores the -s and -S options of the    linker.  The linker needs to be modified to give us that    information in a more useful format (currently it just provides a    list of symbols which should appear in the output file).  */
end_comment

begin_comment
comment|/* Clear the output_has_begun flag for all the input BFD's.  We use it    to avoid linking in the debugging information for a BFD more than    once.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_clear_output_flags
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|register
name|asection
modifier|*
name|o
decl_stmt|;
specifier|register
name|bfd_seclet_type
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
for|for
control|(
name|p
operator|=
name|o
operator|->
name|seclets_head
init|;
name|p
operator|!=
operator|(
name|bfd_seclet_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_seclet
condition|)
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an indirect seclet on the first pass.  Set the contents of    the output section, and accumulate the debugging information if    any.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_rel
parameter_list|(
name|output_bfd
parameter_list|,
name|seclet
parameter_list|,
name|output_section
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_seclet_type
modifier|*
name|seclet
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|HDRR
modifier|*
name|output_symhdr
decl_stmt|;
name|HDRR
modifier|*
name|input_symhdr
decl_stmt|;
if|if
condition|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|&&
operator|!
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
operator|&&
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|&&
name|seclet
operator|->
name|size
condition|)
block|{
name|data
operator|=
operator|(
name|PTR
operator|)
name|bfd_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|seclet
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
name|data
argument_list|,
name|seclet
operator|->
name|offset
argument_list|,
name|seclet
operator|->
name|size
argument_list|)
operator|==
name|false
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|input_bfd
operator|=
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
comment|/* We want to figure out how much space will be required to      incorporate all the debugging information from input_bfd.  We use      the output_has_begun field to avoid adding it in more than once.      The actual incorporation is done in the second pass, in      ecoff_get_debug.  The code has to parallel that code in its      manipulations of output_symhdr.  */
if|if
condition|(
name|input_bfd
operator|->
name|output_has_begun
condition|)
return|return
name|true
return|;
name|input_bfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
name|output_symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|symbolic_header
expr_stmt|;
if|if
condition|(
name|input_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_ecoff_flavour
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
comment|/* We just accumulate local symbols from a non-ECOFF BFD.  The 	 external symbols are handled separately.  */
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|get_symtab_upper_bound
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|sym_end
operator|=
name|symbols
operator|+
name|bfd_canonicalize_symtab
argument_list|(
name|input_bfd
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|sym_ptr
operator|=
name|symbols
init|;
name|sym_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr
operator|++
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_EXPORT
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|bfd_release
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|symbols
argument_list|)
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We simply add in the information from another ECOFF BFD.  First      we make sure we have the symbolic information.  */
if|if
condition|(
name|ecoff_slurp_symbol_table
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|input_bfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|input_symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symbolic_header
expr_stmt|;
comment|/* Figure out how much information we are going to be putting in.      The external symbols are handled separately.  */
name|output_symhdr
operator|->
name|ilineMax
operator|+=
name|input_symhdr
operator|->
name|ilineMax
expr_stmt|;
name|output_symhdr
operator|->
name|cbLine
operator|+=
name|input_symhdr
operator|->
name|cbLine
expr_stmt|;
name|output_symhdr
operator|->
name|idnMax
operator|+=
name|input_symhdr
operator|->
name|idnMax
expr_stmt|;
name|output_symhdr
operator|->
name|ipdMax
operator|+=
name|input_symhdr
operator|->
name|ipdMax
expr_stmt|;
name|output_symhdr
operator|->
name|isymMax
operator|+=
name|input_symhdr
operator|->
name|isymMax
expr_stmt|;
name|output_symhdr
operator|->
name|ioptMax
operator|+=
name|input_symhdr
operator|->
name|ioptMax
expr_stmt|;
name|output_symhdr
operator|->
name|iauxMax
operator|+=
name|input_symhdr
operator|->
name|iauxMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|input_symhdr
operator|->
name|issMax
expr_stmt|;
name|output_symhdr
operator|->
name|ifdMax
operator|+=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
comment|/* The RFD's are special, since we create them if needed.  */
if|if
condition|(
name|input_symhdr
operator|->
name|crfd
operator|>
literal|0
condition|)
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|crfd
expr_stmt|;
else|else
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle an arbitrary seclet on the first pass.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_dump_seclet
parameter_list|(
name|abfd
parameter_list|,
name|seclet
parameter_list|,
name|section
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_seclet_type
modifier|*
name|seclet
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
block|{
switch|switch
condition|(
name|seclet
operator|->
name|type
condition|)
block|{
case|case
name|bfd_indirect_seclet
case|:
comment|/* The contents of this section come from another one somewhere 	 else.  */
return|return
name|ecoff_rel
argument_list|(
name|abfd
argument_list|,
name|seclet
argument_list|,
name|section
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|)
return|;
case|case
name|bfd_fill_seclet
case|:
comment|/* Fill in the section with fill.value.  This is used to pad out 	 sections, but we must avoid padding the .bss section.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seclet
operator|->
name|u
operator|.
name|fill
operator|.
name|value
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|d
init|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|seclet
operator|->
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seclet
operator|->
name|size
condition|;
name|i
operator|+=
literal|2
control|)
name|d
index|[
name|i
index|]
operator|=
name|seclet
operator|->
name|u
operator|.
name|fill
operator|.
name|value
operator|>>
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|seclet
operator|->
name|size
condition|;
name|i
operator|+=
literal|2
control|)
name|d
index|[
name|i
index|]
operator|=
name|seclet
operator|->
name|u
operator|.
name|fill
operator|.
name|value
expr_stmt|;
name|ret
operator|=
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|d
argument_list|,
name|seclet
operator|->
name|offset
argument_list|,
name|seclet
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|d
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a string to the debugging information we are accumulating for a    file.  Return the offset from the fdr string base or from the    external string base.  */
end_comment

begin_function
specifier|static
name|long
name|ecoff_add_string
parameter_list|(
name|output_bfd
parameter_list|,
name|fdr
parameter_list|,
name|string
parameter_list|,
name|external
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|FDR
modifier|*
name|fdr
decl_stmt|;
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|external
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|long
name|ret
decl_stmt|;
name|symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|symbolic_header
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|external
condition|)
block|{
name|strcpy
argument_list|(
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|ssext
operator|+
name|symhdr
operator|->
name|issExtMax
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|ret
operator|=
name|symhdr
operator|->
name|issExtMax
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|ss
operator|+
name|symhdr
operator|->
name|issMax
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fdr
operator|->
name|cbSs
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|fdr
operator|->
name|cbSs
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Accumulate the debugging information from an input section.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_get_debug
parameter_list|(
name|output_bfd
parameter_list|,
name|seclet
parameter_list|,
name|section
parameter_list|,
name|relocateable
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_seclet_type
modifier|*
name|seclet
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|backend
operator|->
name|external_sym_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_pdr_size
init|=
name|backend
operator|->
name|external_pdr_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_fdr_size
init|=
name|backend
operator|->
name|external_fdr_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_rfd_size
init|=
name|backend
operator|->
name|external_rfd_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_sym_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|SYMR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_sym_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_pdr_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PDR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_pdr_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_fdr_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|FDR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_fdr_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|RFDT
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_rfd_out
expr_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|HDRR
modifier|*
name|output_symhdr
decl_stmt|;
name|HDRR
modifier|*
name|input_symhdr
decl_stmt|;
name|ecoff_data_type
modifier|*
name|output_ecoff
decl_stmt|;
name|ecoff_data_type
modifier|*
name|input_ecoff
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|sym_out
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|esym_ptr
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|esym_end
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|FDR
modifier|*
name|fdr_end
decl_stmt|;
name|char
modifier|*
name|fdr_out
decl_stmt|;
name|input_bfd
operator|=
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
comment|/* Don't get the information more than once. */
if|if
condition|(
name|input_bfd
operator|->
name|output_has_begun
condition|)
return|return
name|true
return|;
name|input_bfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
name|output_ecoff
operator|=
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|output_symhdr
operator|=
operator|&
name|output_ecoff
operator|->
name|symbolic_header
expr_stmt|;
if|if
condition|(
name|input_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_ecoff_flavour
condition|)
block|{
name|FDR
name|fdr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
comment|/* This is not an ECOFF BFD.  Just gather the symbols.  */
name|memset
argument_list|(
operator|&
name|fdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fdr
argument_list|)
expr_stmt|;
name|fdr
operator|.
name|adr
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|section
argument_list|)
operator|+
name|seclet
operator|->
name|offset
expr_stmt|;
name|fdr
operator|.
name|issBase
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|fdr
operator|.
name|cbSs
operator|=
literal|0
expr_stmt|;
name|fdr
operator|.
name|rss
operator|=
name|ecoff_add_string
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fdr
operator|.
name|isymBase
operator|=
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
comment|/* Get the local symbols from the input BFD.  */
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|get_symtab_upper_bound
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|sym_end
operator|=
name|symbols
operator|+
name|bfd_canonicalize_symtab
argument_list|(
name|input_bfd
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
comment|/* Handle the local symbols.  Any external symbols are handled 	 separately.  */
name|fdr
operator|.
name|csym
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym_ptr
operator|=
name|symbols
init|;
name|sym_ptr
operator|!=
name|sym_end
condition|;
name|sym_ptr
operator|++
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_EXPORT
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|internal_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|internal_sym
argument_list|)
expr_stmt|;
name|internal_sym
operator|.
name|iss
operator|=
name|ecoff_add_string
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
name|internal_sym
operator|.
name|value
operator|=
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|value
expr_stmt|;
else|else
name|internal_sym
operator|.
name|value
operator|=
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|value
operator|+
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|internal_sym
operator|.
name|st
operator|=
name|stNil
expr_stmt|;
name|internal_sym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
name|internal_sym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_sym
operator|+
name|output_symhdr
operator|->
name|isymMax
operator|*
name|external_sym_size
operator|)
argument_list|)
expr_stmt|;
operator|++
name|fdr
operator|.
name|csym
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|symbols
argument_list|)
expr_stmt|;
comment|/* Leave everything else in the FDR zeroed out.  This will cause 	 the lang field to be langC.  The fBigendian field will 	 indicate little endian format, but it doesn't matter because 	 it only applies to aux fields and there are none.  */
call|(
modifier|*
name|swap_fdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_fdr
operator|+
name|output_symhdr
operator|->
name|ifdMax
operator|*
name|external_fdr_size
operator|)
argument_list|)
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is an ECOFF BFD.  We want to grab the information from      input_bfd and attach it to output_bfd.  */
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|input_ecoff
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|input_symhdr
operator|=
operator|&
name|input_ecoff
operator|->
name|symbolic_header
expr_stmt|;
comment|/* I think that it is more efficient to simply copy the debugging      information from the input BFD to the output BFD.  Because ECOFF      uses relative pointers for most of the debugging information,      only a little of it has to be changed at all.  */
comment|/* Swap in the local symbols, adjust their values, and swap them out      again.  The external symbols are handled separately.  */
name|sym_out
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_sym
operator|+
name|output_symhdr
operator|->
name|isymMax
operator|*
name|external_sym_size
operator|)
expr_stmt|;
name|esym_ptr
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|canonical_symbols
expr_stmt|;
name|esym_end
operator|=
name|esym_ptr
operator|+
name|count
expr_stmt|;
for|for
control|(
init|;
name|esym_ptr
operator|<
name|esym_end
condition|;
name|esym_ptr
operator|++
control|)
block|{
if|if
condition|(
name|esym_ptr
operator|->
name|local
condition|)
block|{
name|SYMR
name|sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|esym_ptr
operator|->
name|native
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
comment|/* If we're producing an executable, move common symbols 	     into bss.  */
if|if
condition|(
name|relocateable
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|sym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|sym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|esym_ptr
operator|->
name|symbol
operator|.
name|section
argument_list|)
operator|&&
operator|(
name|esym_ptr
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
operator|&&
name|esym_ptr
operator|->
name|symbol
operator|.
name|section
operator|!=
operator|&
name|bfd_und_section
condition|)
name|sym
operator|.
name|value
operator|=
operator|(
name|esym_ptr
operator|->
name|symbol
operator|.
name|value
operator|+
name|esym_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|esym_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
name|sym_out
argument_list|)
expr_stmt|;
name|sym_out
operator|+=
name|external_sym_size
expr_stmt|;
block|}
block|}
comment|/* That should have accounted for all the local symbols in      input_bfd.  */
comment|/* Copy the information that does not need swapping.  */
name|memcpy
argument_list|(
name|output_ecoff
operator|->
name|line
operator|+
name|output_symhdr
operator|->
name|cbLine
argument_list|,
name|input_ecoff
operator|->
name|line
argument_list|,
name|input_symhdr
operator|->
name|cbLine
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|output_ecoff
operator|->
name|external_aux
operator|+
name|output_symhdr
operator|->
name|iauxMax
argument_list|,
name|input_ecoff
operator|->
name|external_aux
argument_list|,
name|input_symhdr
operator|->
name|iauxMax
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|output_ecoff
operator|->
name|ss
operator|+
name|output_symhdr
operator|->
name|issMax
argument_list|,
name|input_ecoff
operator|->
name|ss
argument_list|,
name|input_symhdr
operator|->
name|issMax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some of the information may need to be swapped.  */
if|if
condition|(
name|output_bfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|==
name|input_bfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
block|{
comment|/* The two BFD's have the same endianness, so memcpy will 	 suffice.  */
if|if
condition|(
name|input_symhdr
operator|->
name|idnMax
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_dnr
operator|+
name|output_symhdr
operator|->
name|idnMax
operator|*
name|backend
operator|->
name|external_dnr_size
operator|)
argument_list|,
name|input_ecoff
operator|->
name|external_dnr
argument_list|,
name|input_symhdr
operator|->
name|idnMax
operator|*
name|backend
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_symhdr
operator|->
name|ipdMax
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_pdr
operator|+
name|output_symhdr
operator|->
name|ipdMax
operator|*
name|external_pdr_size
operator|)
argument_list|,
name|input_ecoff
operator|->
name|external_pdr
argument_list|,
name|input_symhdr
operator|->
name|ipdMax
operator|*
name|external_pdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_symhdr
operator|->
name|ioptMax
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_opt
operator|+
name|output_symhdr
operator|->
name|ioptMax
operator|*
name|backend
operator|->
name|external_opt_size
operator|)
argument_list|,
name|input_ecoff
operator|->
name|external_opt
argument_list|,
name|input_symhdr
operator|->
name|ioptMax
operator|*
name|backend
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_size_type
name|sz
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
comment|/* The two BFD's have different endianness, so we must swap 	 everything in and out.  This code would always work, but it 	 would be slow in the normal case.  */
name|sz
operator|=
name|backend
operator|->
name|external_dnr_size
expr_stmt|;
name|in
operator|=
operator|(
name|char
operator|*
operator|)
name|input_ecoff
operator|->
name|external_dnr
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|input_symhdr
operator|->
name|idnMax
operator|*
name|sz
expr_stmt|;
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_dnr
operator|+
name|output_symhdr
operator|->
name|idnMax
operator|*
name|sz
expr_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|sz
operator|,
name|out
operator|+=
name|sz
control|)
block|{
name|DNR
name|dnr
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_dnr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|in
argument_list|,
operator|&
name|dnr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_dnr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dnr
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|sz
operator|=
name|external_pdr_size
expr_stmt|;
name|in
operator|=
operator|(
name|char
operator|*
operator|)
name|input_ecoff
operator|->
name|external_pdr
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|input_symhdr
operator|->
name|ipdMax
operator|*
name|sz
expr_stmt|;
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_pdr
operator|+
name|output_symhdr
operator|->
name|ipdMax
operator|*
name|sz
expr_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|sz
operator|,
name|out
operator|+=
name|sz
control|)
block|{
name|PDR
name|pdr
decl_stmt|;
call|(
modifier|*
name|swap_pdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|in
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_pdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|pdr
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|sz
operator|=
name|backend
operator|->
name|external_opt_size
expr_stmt|;
name|in
operator|=
operator|(
name|char
operator|*
operator|)
name|input_ecoff
operator|->
name|external_opt
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|input_symhdr
operator|->
name|ioptMax
operator|*
name|sz
expr_stmt|;
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_opt
operator|+
name|output_symhdr
operator|->
name|ioptMax
operator|*
name|sz
expr_stmt|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|sz
operator|,
name|out
operator|+=
name|sz
control|)
block|{
name|OPTR
name|opt
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_opt_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|in
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_opt_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|opt
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set ifdbase so that the external symbols know how to adjust their      ifd values.  */
name|input_ecoff
operator|->
name|ifdbase
operator|=
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
name|fdr_ptr
operator|=
name|input_ecoff
operator|->
name|fdr
expr_stmt|;
name|fdr_end
operator|=
name|fdr_ptr
operator|+
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
name|fdr_out
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_fdr
operator|+
name|output_symhdr
operator|->
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|++
operator|,
name|fdr_out
operator|+=
name|external_fdr_size
control|)
block|{
name|FDR
name|fdr
decl_stmt|;
name|unsigned
name|long
name|pdr_off
decl_stmt|;
name|fdr
operator|=
operator|*
name|fdr_ptr
expr_stmt|;
comment|/* The memory address for this fdr is the address for the seclet 	 plus the offset to this fdr within input_bfd.  For some 	 reason the offset of the first procedure pointer is also 	 added in.  */
if|if
condition|(
name|fdr
operator|.
name|cpd
operator|==
literal|0
condition|)
name|pdr_off
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|PDR
name|pdr
decl_stmt|;
call|(
modifier|*
name|swap_pdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|input_ecoff
operator|->
name|external_pdr
operator|+
name|fdr
operator|.
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
name|pdr_off
operator|=
name|pdr
operator|.
name|adr
expr_stmt|;
block|}
name|fdr
operator|.
name|adr
operator|=
operator|(
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|section
argument_list|)
operator|+
name|seclet
operator|->
name|offset
operator|+
operator|(
name|fdr_ptr
operator|->
name|adr
operator|-
name|input_ecoff
operator|->
name|fdr
operator|->
name|adr
operator|)
operator|+
name|pdr_off
operator|)
expr_stmt|;
name|fdr
operator|.
name|issBase
operator|+=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|fdr
operator|.
name|isymBase
operator|+=
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
name|fdr
operator|.
name|ilineBase
operator|+=
name|output_symhdr
operator|->
name|ilineMax
expr_stmt|;
name|fdr
operator|.
name|ioptBase
operator|+=
name|output_symhdr
operator|->
name|ioptMax
expr_stmt|;
name|fdr
operator|.
name|ipdFirst
operator|+=
name|output_symhdr
operator|->
name|ipdMax
expr_stmt|;
name|fdr
operator|.
name|iauxBase
operator|+=
name|output_symhdr
operator|->
name|iauxMax
expr_stmt|;
name|fdr
operator|.
name|rfdBase
operator|+=
name|output_symhdr
operator|->
name|crfd
expr_stmt|;
comment|/* If there are no RFD's, we are going to add some.  We don't 	 want to adjust irfd for this, so that all the FDR's can share 	 the RFD's.  */
if|if
condition|(
name|input_symhdr
operator|->
name|crfd
operator|==
literal|0
condition|)
name|fdr
operator|.
name|crfd
operator|=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|cbLine
operator|!=
literal|0
condition|)
name|fdr
operator|.
name|cbLineOffset
operator|+=
name|output_symhdr
operator|->
name|cbLine
expr_stmt|;
call|(
modifier|*
name|swap_fdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
name|fdr_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_symhdr
operator|->
name|crfd
operator|>
literal|0
condition|)
block|{
name|void
argument_list|(
argument|* const swap_rfd_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|RFDT
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_rfd_in
expr_stmt|;
name|char
modifier|*
name|rfd_in
decl_stmt|;
name|char
modifier|*
name|rfd_end
decl_stmt|;
name|char
modifier|*
name|rfd_out
decl_stmt|;
comment|/* Swap and adjust the RFD's.  RFD's are only created by the 	 linker, so this will only be necessary if one of the input 	 files is the result of a partial link.  Presumably all 	 necessary RFD's are present.  */
name|rfd_in
operator|=
operator|(
name|char
operator|*
operator|)
name|input_ecoff
operator|->
name|external_rfd
expr_stmt|;
name|rfd_end
operator|=
name|rfd_in
operator|+
name|input_symhdr
operator|->
name|crfd
operator|*
name|external_rfd_size
expr_stmt|;
name|rfd_out
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_rfd
operator|+
name|output_symhdr
operator|->
name|crfd
operator|*
name|external_rfd_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|rfd_in
operator|<
name|rfd_end
condition|;
name|rfd_in
operator|+=
name|external_rfd_size
operator|,
name|rfd_out
operator|+=
name|external_rfd_size
control|)
block|{
name|RFDT
name|rfd
decl_stmt|;
call|(
modifier|*
name|swap_rfd_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|rfd_in
argument_list|,
operator|&
name|rfd
argument_list|)
expr_stmt|;
name|rfd
operator|+=
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rfd
argument_list|,
name|rfd_out
argument_list|)
expr_stmt|;
block|}
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|crfd
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|rfd_out
decl_stmt|;
name|char
modifier|*
name|rfd_end
decl_stmt|;
name|RFDT
name|rfd
decl_stmt|;
comment|/* Create RFD's.  Some of the debugging information includes 	 relative file indices.  These indices are taken as indices to 	 the RFD table if there is one, or to the global table if 	 there is not.  If we did not create RFD's, we would have to 	 parse and adjust all the debugging information which contains 	 file indices.  */
name|rfd
operator|=
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
name|rfd_out
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|output_ecoff
operator|->
name|external_rfd
operator|+
name|output_symhdr
operator|->
name|crfd
operator|*
name|external_rfd_size
operator|)
expr_stmt|;
name|rfd_end
operator|=
name|rfd_out
operator|+
name|input_symhdr
operator|->
name|ifdMax
operator|*
name|external_rfd_size
expr_stmt|;
for|for
control|(
init|;
name|rfd_out
operator|<
name|rfd_end
condition|;
name|rfd_out
operator|+=
name|external_rfd_size
operator|,
name|rfd
operator|++
control|)
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rfd
argument_list|,
name|rfd_out
argument_list|)
expr_stmt|;
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
block|}
comment|/* Combine the register masks.  Not all of these are used on all      targets, but that's OK because only the relevant ones will be      swapped in and out.  */
block|{
name|int
name|i
decl_stmt|;
name|output_ecoff
operator|->
name|gprmask
operator||=
name|input_ecoff
operator|->
name|gprmask
expr_stmt|;
name|output_ecoff
operator|->
name|fprmask
operator||=
name|input_ecoff
operator|->
name|fprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|output_ecoff
operator|->
name|cprmask
index|[
name|i
index|]
operator||=
name|input_ecoff
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Update the counts.  */
name|output_symhdr
operator|->
name|ilineMax
operator|+=
name|input_symhdr
operator|->
name|ilineMax
expr_stmt|;
name|output_symhdr
operator|->
name|cbLine
operator|+=
name|input_symhdr
operator|->
name|cbLine
expr_stmt|;
name|output_symhdr
operator|->
name|idnMax
operator|+=
name|input_symhdr
operator|->
name|idnMax
expr_stmt|;
name|output_symhdr
operator|->
name|ipdMax
operator|+=
name|input_symhdr
operator|->
name|ipdMax
expr_stmt|;
name|output_symhdr
operator|->
name|isymMax
operator|+=
name|input_symhdr
operator|->
name|isymMax
expr_stmt|;
name|output_symhdr
operator|->
name|ioptMax
operator|+=
name|input_symhdr
operator|->
name|ioptMax
expr_stmt|;
name|output_symhdr
operator|->
name|iauxMax
operator|+=
name|input_symhdr
operator|->
name|iauxMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|input_symhdr
operator|->
name|issMax
expr_stmt|;
name|output_symhdr
operator|->
name|ifdMax
operator|+=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the actual link routine.  It makes two passes over all the    seclets.  */
end_comment

begin_function
name|boolean
name|ecoff_bfd_seclet_link
parameter_list|(
name|abfd
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|int
name|ipass
decl_stmt|;
specifier|register
name|asection
modifier|*
name|o
decl_stmt|;
specifier|register
name|bfd_seclet_type
modifier|*
name|p
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
name|bfd_size_type
name|debug_align
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* We accumulate the debugging information counts in the symbolic      header.  */
name|symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
expr_stmt|;
name|symhdr
operator|->
name|magic
operator|=
name|backend
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We need to copy over the debugging symbols from each input BFD.      When we do this copying, we have to adjust the text address in      the FDR structures, so we have to know the text address used for      the input BFD.  Since we only want to copy the symbols once per      input BFD, but we are going to look at each input BFD multiple      times (once for each section it provides), we arrange to always      look at the text section first.  That means that when we copy the      debugging information, we always know the text address.  So we      actually do each pass in two sub passes; first the text sections,      then the non-text sections.  We use the output_has_begun flag to      determine whether we have copied over the debugging information      yet.  */
comment|/* Do the first pass: set the output section contents and count the      debugging information.  */
name|ecoff_clear_output_flags
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|ipass
operator|=
literal|0
init|;
name|ipass
operator|<
literal|2
condition|;
name|ipass
operator|++
control|)
block|{
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* If this is a fake section, just forget it.  The register 	     information is handled in another way.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* For SEC_CODE sections, (flags& SEC_CODE) == 0 is false, 	     so they are done on pass 0.  For other sections the 	     expression is true, so they are done on pass 1.  */
if|if
condition|(
operator|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|)
operator|!=
name|ipass
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|seclets_head
init|;
name|p
operator|!=
operator|(
name|bfd_seclet_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ecoff_dump_seclet
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|o
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* We handle the external symbols differently.  We use the ones      attached to the output_bfd.  The linker will have already      determined which symbols are to be attached.  Here we just      determine how much space we will need for them.  */
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_ptr_ptr
operator|!=
name|NULL
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
name|sym_end
operator|=
name|sym_ptr_ptr
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr_ptr
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|*
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|symhdr
operator|->
name|iextMax
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|strlen
argument_list|(
operator|(
operator|*
name|sym_ptr_ptr
operator|)
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Adjust the counts so that structures are longword aligned.  */
name|debug_align
operator|=
name|backend
operator|->
name|debug_align
expr_stmt|;
operator|--
name|debug_align
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
operator|(
name|symhdr
operator|->
name|cbLine
operator|+
name|debug_align
operator|)
operator|&
operator|~
name|debug_align
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
operator|(
name|symhdr
operator|->
name|issMax
operator|+
name|debug_align
operator|)
operator|&
operator|~
name|debug_align
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
operator|(
name|symhdr
operator|->
name|issExtMax
operator|+
name|debug_align
operator|)
operator|&
operator|~
name|debug_align
expr_stmt|;
comment|/* Now the counts in symhdr are the correct size for the debugging      information.  We allocate the right amount of space, and reset      the counts so that the second pass can use them as indices.  It      would be possible to output the debugging information directly to      the file in pass 2, rather than to build it in memory and then      write it out.  Outputting to the file would require a lot of      seeks and small writes, though, and I think this approach is      faster.  */
name|size
operator|=
operator|(
name|symhdr
operator|->
name|cbLine
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|+
name|symhdr
operator|->
name|idnMax
operator|*
name|backend
operator|->
name|external_dnr_size
operator|+
name|symhdr
operator|->
name|ipdMax
operator|*
name|backend
operator|->
name|external_pdr_size
operator|+
name|symhdr
operator|->
name|isymMax
operator|*
name|backend
operator|->
name|external_sym_size
operator|+
name|symhdr
operator|->
name|ioptMax
operator|*
name|backend
operator|->
name|external_opt_size
operator|+
name|symhdr
operator|->
name|iauxMax
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
operator|+
name|symhdr
operator|->
name|issMax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|+
name|symhdr
operator|->
name|issExtMax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|+
name|symhdr
operator|->
name|ifdMax
operator|*
name|backend
operator|->
name|external_fdr_size
operator|+
name|symhdr
operator|->
name|crfd
operator|*
name|backend
operator|->
name|external_rfd_size
operator|+
name|symhdr
operator|->
name|iextMax
operator|*
name|backend
operator|->
name|external_ext_size
operator|)
expr_stmt|;
name|raw
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_size
operator|=
name|size
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_syments
operator|=
operator|(
name|PTR
operator|)
name|raw
expr_stmt|;
comment|/* Initialize the raw pointers.  */
define|#
directive|define
name|SET
parameter_list|(
name|field
parameter_list|,
name|count
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|ecoff_data (abfd)->field = (type) raw; \   raw += symhdr->count * size
name|SET
argument_list|(
argument|line
argument_list|,
argument|cbLine
argument_list|,
argument|unsigned char *
argument_list|,
argument|sizeof (unsigned char)
argument_list|)
empty_stmt|;
name|SET
argument_list|(
name|external_dnr
argument_list|,
name|idnMax
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_pdr
argument_list|,
name|ipdMax
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_sym
argument_list|,
name|isymMax
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_opt
argument_list|,
name|ioptMax
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_aux
argument_list|,
name|iauxMax
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ss
argument_list|,
name|issMax
argument_list|,
name|char
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ssext
argument_list|,
name|issExtMax
argument_list|,
name|char
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_fdr
argument_list|,
name|ifdMax
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_rfd
argument_list|,
name|crfd
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_ext
argument_list|,
name|iextMax
argument_list|,
name|PTR
argument_list|,
name|backend
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
comment|/* Reset the counts so the second pass can use them to know how far      it has gotten.  */
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* Do the second pass: accumulate the debugging information.  */
name|ecoff_clear_output_flags
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|ipass
operator|=
literal|0
init|;
name|ipass
operator|<
literal|2
condition|;
name|ipass
operator|++
control|)
block|{
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|)
operator|!=
name|ipass
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|seclets_head
init|;
name|p
operator|!=
operator|(
name|bfd_seclet_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_seclet
condition|)
block|{
if|if
condition|(
name|ecoff_get_debug
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|o
argument_list|,
name|relocateable
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
block|}
comment|/* Put in the external symbols.  */
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_ptr_ptr
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|backend
operator|->
name|external_ext_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_ext_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_ext_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|EXTR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_ext_out
expr_stmt|;
name|char
modifier|*
name|ssext
decl_stmt|;
name|char
modifier|*
name|external_ext
decl_stmt|;
name|ssext
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|ssext
expr_stmt|;
name|external_ext
operator|=
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_ext
expr_stmt|;
for|for
control|(
init|;
operator|*
name|sym_ptr_ptr
operator|!=
name|NULL
condition|;
name|sym_ptr_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym_ptr
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|sym_ptr
operator|=
operator|*
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|sym_ptr
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sym_ptr
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* The native pointer can be NULL for a symbol created by 	     the linker via ecoff_make_empty_symbol.  */
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|sym_ptr
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
operator|||
name|ecoffsymbol
argument_list|(
name|sym_ptr
argument_list|)
operator|->
name|native
operator|==
name|NULL
condition|)
block|{
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
comment|/* FIXME: we can do better than this for st and sc.  */
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
else|else
block|{
name|ecoff_symbol_type
modifier|*
name|ecoff_sym_ptr
decl_stmt|;
name|ecoff_sym_ptr
operator|=
name|ecoffsymbol
argument_list|(
name|sym_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoff_sym_ptr
operator|->
name|local
condition|)
name|abort
argument_list|()
expr_stmt|;
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoff_sym_ptr
operator|->
name|native
argument_list|,
operator|&
name|esym
argument_list|)
expr_stmt|;
comment|/* If we're producing an executable, move common symbols 		 into bss.  */
if|if
condition|(
name|relocateable
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
block|}
comment|/* Adjust the FDR index for the symbol by that used for 		 the input BFD.  */
name|esym
operator|.
name|ifd
operator|+=
name|ecoff_data
argument_list|(
name|bfd_asymbol_bfd
argument_list|(
name|sym_ptr
argument_list|)
argument_list|)
operator|->
name|ifdbase
expr_stmt|;
block|}
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|symhdr
operator|->
name|issExtMax
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym_ptr
operator|->
name|section
argument_list|)
operator|||
name|sym_ptr
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|sym_ptr
operator|->
name|value
expr_stmt|;
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|sym_ptr
operator|->
name|value
operator|+
name|sym_ptr
operator|->
name|section
operator|->
name|output_offset
operator|+
name|sym_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
call|(
modifier|*
name|swap_ext_out
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|esym
argument_list|,
name|external_ext
argument_list|)
expr_stmt|;
name|ecoff_set_sym_index
argument_list|(
name|sym_ptr
argument_list|,
name|symhdr
operator|->
name|iextMax
argument_list|)
expr_stmt|;
name|external_ext
operator|+=
name|external_ext_size
expr_stmt|;
operator|++
name|symhdr
operator|->
name|iextMax
expr_stmt|;
name|strcpy
argument_list|(
name|ssext
operator|+
name|symhdr
operator|->
name|issExtMax
argument_list|,
name|sym_ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|strlen
argument_list|(
name|sym_ptr
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Adjust the counts so that structures are longword aligned.  */
name|symhdr
operator|->
name|cbLine
operator|=
operator|(
name|symhdr
operator|->
name|cbLine
operator|+
name|debug_align
operator|)
operator|&
operator|~
name|debug_align
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
operator|(
name|symhdr
operator|->
name|issMax
operator|+
name|debug_align
operator|)
operator|&
operator|~
name|debug_align
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
operator|(
name|symhdr
operator|->
name|issExtMax
operator|+
name|debug_align
operator|)
operator|&
operator|~
name|debug_align
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the architecture.  The supported architecture is stored in the    backend pointer.  We always set the architecture anyhow, since many    callers ignore the return value.  */
end_comment

begin_function
name|boolean
name|ecoff_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
name|arch
operator|==
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
return|;
block|}
end_function

begin_comment
comment|/* Get the size of the section headers.  We do not output the .scommon    section which we created in ecoff_mkobject, nor do we output any    .reginfo section.  */
end_comment

begin_function
name|int
name|ecoff_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|c
expr_stmt|;
return|return
operator|(
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|c
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the contents of a section.  This is where we handle reading the    .reginfo section, which implicitly holds the contents of an    ecoff_reginfo structure.  */
end_comment

begin_function
name|boolean
name|ecoff_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|ecoff_data_type
modifier|*
name|tdata
init|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|ecoff_reginfo
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|bfd_generic_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
name|s
operator|.
name|gp_value
operator|=
name|tdata
operator|->
name|gp
expr_stmt|;
name|s
operator|.
name|gprmask
operator|=
name|tdata
operator|->
name|gprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|s
operator|.
name|cprmask
index|[
name|i
index|]
operator|=
name|tdata
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
name|s
operator|.
name|fprmask
operator|=
name|tdata
operator|->
name|fprmask
expr_stmt|;
comment|/* bfd_get_section_contents has already checked that the offset and      size is reasonable.  We don't have to worry about swapping or any      such thing; the .reginfo section is defined such that the      contents are an ecoff_reginfo structure as seen on the host.  */
name|memcpy
argument_list|(
name|location
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|s
operator|)
operator|+
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Calculate the file position for each section, and set    reloc_filepos.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|file_ptr
name|sofar
decl_stmt|;
name|file_ptr
name|old_sofar
decl_stmt|;
name|boolean
name|first_data
decl_stmt|;
if|if
condition|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
name|sofar
operator|=
name|ecoff_sizeof_headers
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|first_data
operator|=
name|true
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
comment|/* Only deal with sections which have contents */
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* On Ultrix, the data sections in an executable file must be 	 aligned to a page boundary within the file.  This does not 	 affect the section size, though.  FIXME: Does this work for 	 other platforms?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
operator|&&
name|first_data
operator|!=
name|false
operator|&&
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|bfd_vma
name|round
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|round
decl_stmt|;
name|sofar
operator|=
operator|(
name|sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|first_data
operator|=
name|false
expr_stmt|;
block|}
comment|/* Align the sections in the file to the same boundary on 	 which they are aligned in virtual memory.  */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|current
operator|->
name|filepos
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
expr_stmt|;
comment|/* make sure that this section is of the right size too */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_filepos
operator|=
name|sofar
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the contents of a section.  This is where we handle setting the    contents of the .reginfo section, which implicitly holds a    ecoff_reginfo structure.  */
end_comment

begin_function
name|boolean
name|ecoff_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
name|ecoff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ecoff_data_type
modifier|*
name|tdata
init|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|ecoff_reginfo
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the caller is only changing part of the structure, we must 	 retrieve the current information before the memcpy.  */
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|count
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_reginfo
argument_list|)
condition|)
block|{
name|s
operator|.
name|gp_value
operator|=
name|tdata
operator|->
name|gp
expr_stmt|;
name|s
operator|.
name|gprmask
operator|=
name|tdata
operator|->
name|gprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|s
operator|.
name|cprmask
index|[
name|i
index|]
operator|=
name|tdata
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
name|s
operator|.
name|fprmask
operator|=
name|tdata
operator|->
name|fprmask
expr_stmt|;
block|}
comment|/* bfd_set_section_contents has already checked that the offset 	 and size is reasonable.  We don't have to worry about 	 swapping or any such thing; the .reginfo section is defined 	 such that the contents are an ecoff_reginfo structure as seen 	 on the host.  */
name|memcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|s
operator|)
operator|+
name|offset
argument_list|,
name|location
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|gp
operator|=
name|s
operator|.
name|gp_value
expr_stmt|;
name|tdata
operator|->
name|gprmask
operator|=
name|s
operator|.
name|gprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tdata
operator|->
name|cprmask
index|[
name|i
index|]
operator|=
name|s
operator|.
name|cprmask
index|[
name|i
index|]
expr_stmt|;
name|tdata
operator|->
name|fprmask
operator|=
name|s
operator|.
name|fprmask
expr_stmt|;
return|return
name|true
return|;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
operator|(
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
operator|)
condition|?
name|true
else|:
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an ECOFF file.  */
end_comment

begin_function
name|boolean
name|ecoff_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_vma
name|round
init|=
name|backend
operator|->
name|round
decl_stmt|;
specifier|const
name|bfd_size_type
name|filhsz
init|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|aoutsz
init|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|scnhsz
init|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_hdr_size
init|=
name|backend
operator|->
name|external_hdr_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_reloc_size
init|=
name|backend
operator|->
name|external_reloc_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_reloc_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_reloc_out
expr_stmt|;
name|asection
modifier|*
name|current
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|file_ptr
name|scn_base
decl_stmt|;
name|file_ptr
name|reloc_base
decl_stmt|;
name|file_ptr
name|sym_base
decl_stmt|;
name|unsigned
name|long
name|reloc_size
decl_stmt|;
name|unsigned
name|long
name|text_size
decl_stmt|;
name|unsigned
name|long
name|text_start
decl_stmt|;
name|unsigned
name|long
name|data_size
decl_stmt|;
name|unsigned
name|long
name|data_start
decl_stmt|;
name|unsigned
name|long
name|bss_size
decl_stmt|;
name|PTR
name|buff
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
name|ecoff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|sections
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|scn_base
operator|=
name|abfd
operator|->
name|sections
operator|->
name|filepos
expr_stmt|;
else|else
name|scn_base
operator|=
literal|0
expr_stmt|;
name|reloc_base
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_filepos
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|reloc_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|current
operator|->
name|target_index
operator|=
name|count
expr_stmt|;
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|relsize
decl_stmt|;
name|current
operator|->
name|rel_filepos
operator|=
name|reloc_base
expr_stmt|;
name|relsize
operator|=
name|current
operator|->
name|reloc_count
operator|*
name|external_reloc_size
expr_stmt|;
name|reloc_size
operator|+=
name|relsize
expr_stmt|;
name|reloc_base
operator|+=
name|relsize
expr_stmt|;
block|}
else|else
name|current
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
block|}
name|sym_base
operator|=
name|reloc_base
operator|+
name|reloc_size
expr_stmt|;
comment|/* At least on Ultrix, the symbol table of an executable file must      be aligned to a page boundary.  FIXME: Is this true on other      platforms?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|sym_base
operator|=
operator|(
name|sym_base
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|=
name|sym_base
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|text_size
operator|=
name|ecoff_sizeof_headers
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|text_size
operator|=
literal|0
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|data_size
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|bss_size
operator|=
literal|0
expr_stmt|;
comment|/* Write section headers to the file.  */
name|buff
operator|=
operator|(
name|PTR
operator|)
name|alloca
argument_list|(
name|scnhsz
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|filhsz
operator|+
name|aoutsz
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|struct
name|internal_scnhdr
name|section
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
operator|==
literal|0
operator|&&
name|current
operator|->
name|reloc_count
operator|==
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|REGINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|current
operator|->
name|reloc_count
operator|==
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|internal_f
operator|.
name|f_nscns
expr_stmt|;
name|strncpy
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
name|current
operator|->
name|name
argument_list|,
sizeof|sizeof
name|section
operator|.
name|s_name
argument_list|)
expr_stmt|;
comment|/* FIXME: is this correct for shared libraries?  I think it is 	 but I have no platform to check.  Ian Lance Taylor.  */
name|vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|.
name|s_vaddr
operator|=
literal|0
expr_stmt|;
else|else
name|section
operator|.
name|s_vaddr
operator|=
name|vma
expr_stmt|;
name|section
operator|.
name|s_paddr
operator|=
name|vma
expr_stmt|;
name|section
operator|.
name|s_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* If this section is unloadable then the scnptr will be 0.  */
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
literal|0
condition|)
name|section
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
else|else
name|section
operator|.
name|s_scnptr
operator|=
name|current
operator|->
name|filepos
expr_stmt|;
name|section
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
comment|/* FIXME: the lnnoptr of the .sbss or .sdata section of an 	 object file produced by the assembler is supposed to point to 	 information about how much room is required by objects of 	 various different sizes.  I think this only matters if we 	 want the linker to compute the best size to use, or 	 something.  I don't know what happens if the information is 	 not present.  */
name|section
operator|.
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|section
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|section
operator|.
name|s_flags
operator|=
name|ecoff_sec_to_styp_flags
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|current
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|section
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|scnhsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|scnhsz
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_TEXT
operator|)
operator|!=
literal|0
condition|)
block|{
name|text_size
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_start
operator|==
literal|0
operator|||
name|text_start
operator|>
name|vma
condition|)
name|text_start
operator|=
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_RDATA
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_DATA
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_LIT8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_LIT4
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_SDATA
operator|)
operator|!=
literal|0
condition|)
block|{
name|data_size
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_start
operator|==
literal|0
operator|||
name|data_start
operator|>
name|vma
condition|)
name|data_start
operator|=
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_BSS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_SBSS
operator|)
operator|!=
literal|0
condition|)
name|bss_size
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the file header.  */
name|internal_f
operator|.
name|f_magic
operator|=
name|ecoff_get_magic
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We will NOT put a fucking timestamp in the header here. Every      time you put it back, I will come in and take it out again.  I'm      sorry.  This field does not belong here.  We fill it with a 0 so      it compares the same but is not a reasonable time. --      gnu@cygnus.com.  */
name|internal_f
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The ECOFF f_nsyms field is not actually the number of 	 symbols, it's the size of symbolic information header.  */
name|internal_f
operator|.
name|f_nsyms
operator|=
name|external_hdr_size
expr_stmt|;
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
block|}
else|else
block|{
name|internal_f
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
block|}
name|internal_f
operator|.
name|f_opthdr
operator|=
name|aoutsz
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
name|F_LNNO
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|==
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_RELFLG
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_EXEC
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32WR
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32W
expr_stmt|;
comment|/* Set up the ``optional'' header.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|internal_a
operator|.
name|magic
operator|=
name|ECOFF_AOUT_ZMAGIC
expr_stmt|;
else|else
name|internal_a
operator|.
name|magic
operator|=
name|ECOFF_AOUT_OMAGIC
expr_stmt|;
comment|/* FIXME: This is what Ultrix puts in, and it makes the Ultrix      linker happy.  But, is it right?  */
name|internal_a
operator|.
name|vstamp
operator|=
literal|0x20a
expr_stmt|;
comment|/* At least on Ultrix, these have to be rounded to page boundaries.      FIXME: Is this true on other platforms?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|internal_a
operator|.
name|tsize
operator|=
operator|(
name|text_size
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|text_start
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|internal_a
operator|.
name|dsize
operator|=
operator|(
name|data_size
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|data_start
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|tsize
operator|=
name|text_size
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|text_start
expr_stmt|;
name|internal_a
operator|.
name|dsize
operator|=
name|data_size
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|data_start
expr_stmt|;
block|}
comment|/* On Ultrix, the initial portions of the .sbss and .bss segments      are at the end of the data section.  The bsize field in the      optional header records how many bss bytes are required beyond      those in the data section.  The value is not rounded to a page      boundary.  */
if|if
condition|(
name|bss_size
operator|<
name|internal_a
operator|.
name|dsize
operator|-
name|data_size
condition|)
name|bss_size
operator|=
literal|0
expr_stmt|;
else|else
name|bss_size
operator|-=
name|internal_a
operator|.
name|dsize
operator|-
name|data_size
expr_stmt|;
name|internal_a
operator|.
name|bsize
operator|=
name|bss_size
expr_stmt|;
name|internal_a
operator|.
name|bss_start
operator|=
name|internal_a
operator|.
name|data_start
operator|+
name|internal_a
operator|.
name|dsize
expr_stmt|;
name|internal_a
operator|.
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|gp_value
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
name|internal_a
operator|.
name|gprmask
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gprmask
expr_stmt|;
name|internal_a
operator|.
name|fprmask
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|internal_a
operator|.
name|cprmask
index|[
name|i
index|]
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
comment|/* Write out the file header and the optional header.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|buff
operator|=
operator|(
name|PTR
operator|)
name|alloca
argument_list|(
name|filhsz
argument_list|)
expr_stmt|;
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|filhsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|filhsz
condition|)
return|return
name|false
return|;
name|buff
operator|=
operator|(
name|PTR
operator|)
name|alloca
argument_list|(
name|aoutsz
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|aoutsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|aoutsz
condition|)
return|return
name|false
return|;
comment|/* Write out the relocs.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|reloc_ptr_ptr
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_end
decl_stmt|;
name|char
modifier|*
name|out_ptr
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|buff
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|current
operator|->
name|reloc_count
operator|*
name|external_reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|reloc_ptr_ptr
operator|=
name|current
operator|->
name|orelocation
expr_stmt|;
name|reloc_end
operator|=
name|reloc_ptr_ptr
operator|+
name|current
operator|->
name|reloc_count
expr_stmt|;
name|out_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
expr_stmt|;
for|for
control|(
init|;
name|reloc_ptr_ptr
operator|<
name|reloc_end
condition|;
name|reloc_ptr_ptr
operator|++
operator|,
name|out_ptr
operator|+=
name|external_reloc_size
control|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|internal_reloc
name|in
decl_stmt|;
name|memset
argument_list|(
operator|&
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|in
argument_list|)
expr_stmt|;
name|reloc
operator|=
operator|*
name|reloc_ptr_ptr
expr_stmt|;
name|sym
operator|=
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|in
operator|.
name|r_vaddr
operator|=
name|reloc
operator|->
name|address
operator|+
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|in
operator|.
name|r_type
operator|=
name|reloc
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
name|in
operator|.
name|r_symndx
operator|=
name|ecoff_get_sym_index
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|in
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_BSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_INIT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT4
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|in
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
call|(
modifier|*
name|swap_reloc_out
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|in
argument_list|,
operator|(
name|PTR
operator|)
name|out_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
name|external_reloc_size
argument_list|,
name|current
operator|->
name|reloc_count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|external_reloc_size
operator|*
name|current
operator|->
name|reloc_count
condition|)
return|return
name|false
return|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the symbolic debugging information.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|unsigned
name|long
name|sym_offset
decl_stmt|;
comment|/* Set up the offsets in the symbolic header.  */
name|symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
expr_stmt|;
name|sym_offset
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|+
name|external_hdr_size
expr_stmt|;
define|#
directive|define
name|SET
parameter_list|(
name|offset
parameter_list|,
name|size
parameter_list|,
name|ptr
parameter_list|)
define|\
value|if (symhdr->size == 0) \     symhdr->offset = 0; \   else \     symhdr->offset = (((char *) ecoff_data (abfd)->ptr \ 		       - (char *) ecoff_data (abfd)->raw_syments) \ 		      + sym_offset);
name|SET
argument_list|(
name|cbLineOffset
argument_list|,
name|cbLine
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|external_dnr
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|external_pdr
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|external_sym
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|external_opt
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
name|external_aux
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
name|ssext
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|external_fdr
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|external_rfd
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|external_ext
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|buff
operator|=
operator|(
name|PTR
operator|)
name|alloca
argument_list|(
name|external_hdr_size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_hdr_out
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbolic_header
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|external_hdr_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|external_hdr_size
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_syments
argument_list|,
literal|1
argument_list|,
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_size
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
comment|/* A demand paged executable must occupy an even number of 	 pages.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Archive handling.  ECOFF uses what appears to be a unique type of    archive header (which I call an armap).  The byte ordering of the    armap and the contents are encoded in the name of the armap itself.    At least for now, we only support archives with the same byte    ordering in the armap and the contents.     The first four bytes in the armap are the number of symbol    definitions.  This is always a power of two.     This is followed by the symbol definitions.  Each symbol definition    occupies 8 bytes.  The first four bytes are the offset from the    start of the armap strings to the null-terminated string naming    this symbol.  The second four bytes are the file offset to the    archive member which defines this symbol.  If the second four bytes    are 0, then this is not actually a symbol definition, and it should    be ignored.     The symbols are hashed into the armap with a closed hashing scheme.    See the functions below for the details of the algorithm.     We could use the hash table when looking up symbols in a library.    This would require a new BFD target entry point to replace the    bfd_get_next_mapent function used by the linker.     After the symbol definitions comes four bytes holding the size of    the string table, followed by the string table itself.  */
end_comment

begin_comment
comment|/* The name of an archive headers looks like this:    __________E[BL]E[BL]_ (with a trailing space).    The trailing space is changed to an X if the archive is changed to    indicate that the armap is out of date.     The Alpha seems to use ________64E[BL]E[BL]_.  */
end_comment

begin_define
define|#
directive|define
name|ARMAP_BIG_ENDIAN
value|'B'
end_define

begin_define
define|#
directive|define
name|ARMAP_LITTLE_ENDIAN
value|'L'
end_define

begin_define
define|#
directive|define
name|ARMAP_MARKER
value|'E'
end_define

begin_define
define|#
directive|define
name|ARMAP_START_LENGTH
value|10
end_define

begin_define
define|#
directive|define
name|ARMAP_HEADER_MARKER_INDEX
value|10
end_define

begin_define
define|#
directive|define
name|ARMAP_HEADER_ENDIAN_INDEX
value|11
end_define

begin_define
define|#
directive|define
name|ARMAP_OBJECT_MARKER_INDEX
value|12
end_define

begin_define
define|#
directive|define
name|ARMAP_OBJECT_ENDIAN_INDEX
value|13
end_define

begin_define
define|#
directive|define
name|ARMAP_END_INDEX
value|14
end_define

begin_define
define|#
directive|define
name|ARMAP_END
value|"_ "
end_define

begin_comment
comment|/* This is a magic number used in the hashing algorithm.  */
end_comment

begin_define
define|#
directive|define
name|ARMAP_HASH_MAGIC
value|0x9dd68ab5
end_define

begin_comment
comment|/* This returns the hash value to use for a string.  It also sets    *REHASH to the rehash adjustment if the first slot is taken.  SIZE    is the number of entries in the hash table, and HLOG is the log    base 2 of SIZE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ecoff_armap_hash
parameter_list|(
name|s
parameter_list|,
name|rehash
parameter_list|,
name|size
parameter_list|,
name|hlog
parameter_list|)
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rehash
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|hlog
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|hash
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|hash
operator|=
operator|(
operator|(
name|hash
operator|>>
literal|27
operator|)
operator||
operator|(
name|hash
operator|<<
literal|5
operator|)
operator|)
operator|+
operator|*
name|s
operator|++
expr_stmt|;
name|hash
operator|*=
name|ARMAP_HASH_MAGIC
expr_stmt|;
operator|*
name|rehash
operator|=
operator|(
name|hash
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator||
literal|1
expr_stmt|;
return|return
name|hash
operator|>>
operator|(
literal|32
operator|-
name|hlog
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read in the armap.  */
end_comment

begin_function
name|boolean
name|ecoff_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|bfd_size_type
name|parsed_size
decl_stmt|;
name|char
modifier|*
name|raw_armap
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|raw_ptr
decl_stmt|;
name|struct
name|symdef
modifier|*
name|symdef_ptr
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
comment|/* Get the name of the first element.  */
name|i
operator|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* Irix 4.0.5F apparently can use either an ECOFF armap or a      standard COFF armap.  We could move the ECOFF armap stuff into      bfd_slurp_armap, but that seems inappropriate since no other      target uses this format.  Instead, we check directly for a COFF      armap.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bfd_slurp_armap
argument_list|(
name|abfd
argument_list|)
return|;
comment|/* See if the first element is an armap.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_start
argument_list|,
name|ARMAP_START_LENGTH
argument_list|)
operator|!=
literal|0
operator|||
name|nextname
index|[
name|ARMAP_HEADER_MARKER_INDEX
index|]
operator|!=
name|ARMAP_MARKER
operator|||
operator|(
name|nextname
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_BIG_ENDIAN
operator|&&
name|nextname
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_LITTLE_ENDIAN
operator|)
operator|||
name|nextname
index|[
name|ARMAP_OBJECT_MARKER_INDEX
index|]
operator|!=
name|ARMAP_MARKER
operator|||
operator|(
name|nextname
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_BIG_ENDIAN
operator|&&
name|nextname
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_LITTLE_ENDIAN
operator|)
operator|||
name|strncmp
argument_list|(
name|nextname
operator|+
name|ARMAP_END_INDEX
argument_list|,
name|ARMAP_END
argument_list|,
sizeof|sizeof
name|ARMAP_END
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Make sure we have the right byte ordering.  */
if|if
condition|(
operator|(
operator|(
name|nextname
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|==
name|ARMAP_BIG_ENDIAN
operator|)
operator|^
operator|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|!=
name|false
operator|)
operator|)
operator|||
operator|(
operator|(
name|nextname
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|==
name|ARMAP_BIG_ENDIAN
operator|)
operator|^
operator|(
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
operator|!=
name|false
operator|)
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Read in the armap.  */
name|ardata
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|mapdata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
name|raw_armap
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
name|ardata
operator|->
name|symdef_count
operator|=
literal|0
expr_stmt|;
name|ardata
operator|->
name|cache
operator|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* This code used to overlay the symdefs over the raw archive data,      but that doesn't work on a 64 bit host.  */
name|stringbase
operator|=
name|raw_armap
operator|+
name|count
operator|*
literal|8
operator|+
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_ARMAP_HASH
block|{
name|unsigned
name|int
name|hlog
decl_stmt|;
comment|/* Double check that I have the hashing algorithm right by making        sure that every symbol can be looked up successfully.  */
name|hlog
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|<<=
literal|1
control|)
name|hlog
operator|++
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|==
name|count
argument_list|)
expr_stmt|;
name|raw_ptr
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|raw_ptr
operator|+=
literal|8
control|)
block|{
name|unsigned
name|int
name|name_offset
decl_stmt|,
name|file_offset
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|,
name|rehash
decl_stmt|,
name|srch
decl_stmt|;
name|name_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_ptr
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|raw_ptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|==
literal|0
condition|)
continue|continue;
name|hash
operator|=
name|ecoff_armap_hash
argument_list|(
name|stringbase
operator|+
name|name_offset
argument_list|,
operator|&
name|rehash
argument_list|,
name|count
argument_list|,
name|hlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|i
condition|)
continue|continue;
comment|/* See if we can rehash to this location.  */
for|for
control|(
name|srch
operator|=
operator|(
name|hash
operator|+
name|rehash
operator|)
operator|&
operator|(
name|count
operator|-
literal|1
operator|)
init|;
name|srch
operator|!=
name|hash
operator|&&
name|srch
operator|!=
name|i
condition|;
name|srch
operator|=
operator|(
name|srch
operator|+
name|rehash
operator|)
operator|&
operator|(
name|count
operator|-
literal|1
operator|)
control|)
name|BFD_ASSERT
argument_list|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|raw_armap
operator|+
literal|8
operator|+
name|srch
operator|*
literal|8
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srch
operator|==
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CHECK_ARMAP_HASH */
name|raw_ptr
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|raw_ptr
operator|+=
literal|8
control|)
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|raw_ptr
operator|+
literal|4
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|ardata
operator|->
name|symdef_count
expr_stmt|;
name|symdef_ptr
operator|=
operator|(
operator|(
expr|struct
name|symdef
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|ardata
operator|->
name|symdef_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|symdef_ptr
expr_stmt|;
name|raw_ptr
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|raw_ptr
operator|+=
literal|8
control|)
block|{
name|unsigned
name|int
name|name_offset
decl_stmt|,
name|file_offset
decl_stmt|;
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|raw_ptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|==
literal|0
condition|)
continue|continue;
name|name_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_ptr
argument_list|)
expr_stmt|;
name|symdef_ptr
operator|->
name|s
operator|.
name|name
operator|=
name|stringbase
operator|+
name|name_offset
expr_stmt|;
name|symdef_ptr
operator|->
name|file_offset
operator|=
name|file_offset
expr_stmt|;
operator|++
name|symdef_ptr
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary.  */
name|ardata
operator|->
name|first_file_filepos
operator|+=
name|ardata
operator|->
name|first_file_filepos
operator|%
literal|2
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an armap.  */
end_comment

begin_function
name|boolean
name|ecoff_write_armap
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|unsigned
name|int
name|hashsize
decl_stmt|,
name|hashlog
decl_stmt|;
name|unsigned
name|int
name|symdefsize
decl_stmt|;
name|int
name|padit
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|unsigned
name|int
name|mapsize
decl_stmt|;
name|file_ptr
name|firstreal
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|hashtable
decl_stmt|;
name|bfd
modifier|*
name|current
decl_stmt|;
name|bfd
modifier|*
name|last_elt
decl_stmt|;
comment|/* Ultrix appears to use as a hash table size the least power of two      greater than twice the number of entries.  */
for|for
control|(
name|hashlog
operator|=
literal|0
init|;
operator|(
literal|1
operator|<<
name|hashlog
operator|)
operator|<=
literal|2
operator|*
name|orl_count
condition|;
name|hashlog
operator|++
control|)
empty_stmt|;
name|hashsize
operator|=
literal|1
operator|<<
name|hashlog
expr_stmt|;
name|symdefsize
operator|=
name|hashsize
operator|*
literal|8
expr_stmt|;
name|padit
operator|=
name|stridx
operator|%
literal|2
expr_stmt|;
name|stringsize
operator|=
name|stridx
operator|+
name|padit
expr_stmt|;
comment|/* Include 8 bytes to store symdefsize and stringsize in output. */
name|mapsize
operator|=
name|symdefsize
operator|+
name|stringsize
operator|+
literal|8
expr_stmt|;
name|firstreal
operator|=
name|SARMAG
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|mapsize
operator|+
name|elength
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
comment|/* Work out the ECOFF armap name.  */
name|strcpy
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_start
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_HEADER_MARKER_INDEX
index|]
operator|=
name|ARMAP_MARKER
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|=
operator|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|?
name|ARMAP_BIG_ENDIAN
else|:
name|ARMAP_LITTLE_ENDIAN
operator|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_OBJECT_MARKER_INDEX
index|]
operator|=
name|ARMAP_MARKER
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|=
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|?
name|ARMAP_BIG_ENDIAN
else|:
name|ARMAP_LITTLE_ENDIAN
expr_stmt|;
name|memcpy
argument_list|(
name|hdr
operator|.
name|ar_name
operator|+
name|ARMAP_END_INDEX
argument_list|,
name|ARMAP_END
argument_list|,
sizeof|sizeof
name|ARMAP_END
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Write the timestamp of the archive header to be just a little bit      later than the timestamp of the file, otherwise the linker will      complain that the index is out of date.  Actually, the Ultrix      linker just checks the archive name; the GNU linker may check the      date.  */
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|statbuf
operator|.
name|st_mtime
operator|+
literal|60
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The DECstation uses zeroes for the uid, gid and mode of the      armap.  */
name|hdr
operator|.
name|ar_uid
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|hdr
operator|.
name|ar_gid
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|hdr
operator|.
name|ar_mode
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* Turn all null bytes in the header into spaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|hashsize
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|hashtable
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symdefsize
argument_list|)
expr_stmt|;
name|current
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|last_elt
operator|=
name|current
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|,
name|rehash
decl_stmt|;
comment|/* Advance firstreal to the file position of this archive 	 element.  */
if|if
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
name|map
index|[
name|i
index|]
operator|.
name|pos
operator|)
operator|!=
name|last_elt
condition|)
block|{
do|do
block|{
name|firstreal
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|firstreal
operator|+=
name|firstreal
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|map
index|[
name|i
index|]
operator|.
name|pos
condition|)
do|;
block|}
name|last_elt
operator|=
name|current
expr_stmt|;
name|hash
operator|=
name|ecoff_armap_hash
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|rehash
argument_list|,
name|hashsize
argument_list|,
name|hashlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|hashtable
operator|+
operator|(
name|hash
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|srch
decl_stmt|;
comment|/* The desired slot is already taken.  */
for|for
control|(
name|srch
operator|=
operator|(
name|hash
operator|+
name|rehash
operator|)
operator|&
operator|(
name|hashsize
operator|-
literal|1
operator|)
init|;
name|srch
operator|!=
name|hash
condition|;
name|srch
operator|=
operator|(
name|srch
operator|+
name|rehash
operator|)
operator|&
operator|(
name|hashsize
operator|-
literal|1
operator|)
control|)
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|hashtable
operator|+
operator|(
name|srch
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|BFD_ASSERT
argument_list|(
name|srch
operator|!=
name|hash
argument_list|)
expr_stmt|;
name|hash
operator|=
name|srch
expr_stmt|;
block|}
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|namidx
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|hashtable
operator|+
name|hash
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|firstreal
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|hashtable
operator|+
name|hash
operator|*
literal|8
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
name|hashtable
argument_list|,
literal|1
argument_list|,
name|symdefsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symdefsize
condition|)
return|return
name|false
return|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|hashtable
argument_list|)
expr_stmt|;
comment|/* Now write the strings.  */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|stringsize
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd_size_type
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
comment|/* The spec sez this should be a newline.  But in order to be      bug-compatible for DECstation ar we use a null.  */
if|if
condition|(
name|padit
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
literal|"\0"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* See whether this BFD is an archive.  If it is, read in the armap    and the extended name table.  */
end_comment

begin_function
name|bfd_target
modifier|*
name|ecoff_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|armag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|armag
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SARMAG
operator|||
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of      assignment.  */
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|SARMAG
expr_stmt|;
if|if
condition|(
name|ecoff_slurp_armap
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
operator|||
name|ecoff_slurp_extended_name_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

end_unit

