begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of COFF, for BFD.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by  Steve Chamberlain, sac@cygnus.com.    Split out of coffcode.h by Ian Taylor, ian@cygnus.com.  */
end_comment

begin_comment
comment|/* This file contains COFF code that is not dependent on any    particular COFF target.  There is only one version of this file in    libbfd.a, so no target specific code may be put in here.  Or, to    put it another way,     ********** DO NOT PUT TARGET SPECIFIC CODE IN THIS FILE **********     If you need to add some target specific behaviour, add a new hook    function to bfd_coff_backend_data.     Some of these functions are also called by the ECOFF routines.    Those functions may not use any COFF specific information, such as    coff_data (abfd).  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"seclet.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_decl_stmt
specifier|static
name|asection
name|bfd_debug_section
init|=
block|{
literal|"*DEBUG*"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take a section header read from a coff file (in HOST byte order),    and make a BFD "section" out of it.  This is used by ECOFF.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|make_a_section_from_file
argument_list|,
operator|(
name|abfd
operator|,
name|hdr
operator|,
name|target_index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_scnhdr
operator|*
name|hdr
name|AND
name|unsigned
name|int
name|target_index
argument_list|)
block|{
name|asection
modifier|*
name|return_section
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Assorted wastage to null-terminate the name, thanks AT&T! */
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|->
name|s_name
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|name
index|[
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|return_section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_section
operator|==
name|NULL
condition|)
name|return_section
operator|=
name|bfd_coff_make_section_hook
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Handle several sections of the same name.  For example, if an executable      has two .bss sections, GDB better be able to find both of them      (PR 3562).  */
if|if
condition|(
name|return_section
operator|==
name|NULL
condition|)
name|return_section
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_section
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* s_paddr is presumed to be = to s_vaddr */
name|return_section
operator|->
name|vma
operator|=
name|hdr
operator|->
name|s_vaddr
expr_stmt|;
name|return_section
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|s_size
expr_stmt|;
name|return_section
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|s_scnptr
expr_stmt|;
name|return_section
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|s_relptr
expr_stmt|;
name|return_section
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|s_nreloc
expr_stmt|;
name|bfd_coff_set_alignment_hook
argument_list|(
name|abfd
argument_list|,
name|return_section
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|return_section
operator|->
name|line_filepos
operator|=
name|hdr
operator|->
name|s_lnnoptr
expr_stmt|;
name|return_section
operator|->
name|lineno_count
operator|=
name|hdr
operator|->
name|s_nlnno
expr_stmt|;
name|return_section
operator|->
name|userdata
operator|=
name|NULL
expr_stmt|;
name|return_section
operator|->
name|next
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|return_section
operator|->
name|flags
operator|=
name|bfd_coff_styp_to_sec_flags_hook
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|return_section
operator|->
name|target_index
operator|=
name|target_index
expr_stmt|;
comment|/* At least on i386-coff, the line number count for a shared library      section must be ignored.  */
if|if
condition|(
operator|(
name|return_section
operator|->
name|flags
operator|&
name|SEC_SHARED_LIBRARY
operator|)
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|s_nreloc
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
comment|/* FIXME: should this check 'hdr->s_size> 0' */
if|if
condition|(
name|hdr
operator|->
name|s_scnptr
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Read in a COFF object and make it into a BFD.  This is used by    ECOFF as well.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|coff_real_object_p
argument_list|,
operator|(
name|abfd
operator|,
name|nscns
operator|,
name|internal_f
operator|,
name|internal_a
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|nscns
name|AND
expr|struct
name|internal_filehdr
operator|*
name|internal_f
name|AND
expr|struct
name|internal_aouthdr
operator|*
name|internal_a
argument_list|)
block|{
name|PTR
name|tdata
decl_stmt|;
name|size_t
name|readsize
decl_stmt|;
comment|/* length of file_info */
name|unsigned
name|int
name|scnhsz
decl_stmt|;
name|char
modifier|*
name|external_sections
decl_stmt|;
comment|/* Build a play area */
name|tdata
operator|=
name|bfd_coff_mkobject_hook
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|internal_f
argument_list|,
operator|(
name|PTR
operator|)
name|internal_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|scnhsz
operator|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|readsize
operator|=
name|nscns
operator|*
name|scnhsz
expr_stmt|;
name|external_sections
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|external_sections
argument_list|,
literal|1
argument_list|,
name|readsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|readsize
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
comment|/* Now copy data as required; construct all asections etc */
if|if
condition|(
name|nscns
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|internal_scnhdr
name|tmp
decl_stmt|;
name|bfd_coff_swap_scnhdr_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|external_sections
operator|+
name|i
operator|*
name|scnhsz
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|make_a_section_from_file
argument_list|(
name|abfd
argument_list|,
operator|&
name|tmp
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  make_abs_section(abfd);*/
if|if
condition|(
name|bfd_coff_set_arch_mach_hook
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|internal_f
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_RELFLG
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_EXEC
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_LNNO
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_LSYMS
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LOCALS
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_nsyms
expr_stmt|;
if|if
condition|(
name|internal_f
operator|->
name|f_nsyms
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
if|if
condition|(
name|internal_a
operator|!=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|NULL
condition|)
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_a
operator|->
name|entry
expr_stmt|;
else|else
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Turn a COFF file into a BFD, but fail with wrong_format if it is    not a COFF file.  This is also used by ECOFF.  */
end_comment

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|coff_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|filhsz
decl_stmt|;
name|unsigned
name|int
name|aoutsz
decl_stmt|;
name|int
name|nscns
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* figure out how much to read */
name|filhsz
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|aoutsz
operator|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|filehdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|filhsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|filehdr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|filehdr
argument_list|,
literal|1
argument_list|,
name|filhsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|filhsz
condition|)
return|return
literal|0
return|;
name|bfd_coff_swap_filehdr_in
argument_list|(
name|abfd
argument_list|,
name|filehdr
argument_list|,
operator|&
name|internal_f
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|filehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_bad_format_hook
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_f
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nscns
operator|=
name|internal_f
operator|.
name|f_nscns
expr_stmt|;
if|if
condition|(
name|internal_f
operator|.
name|f_opthdr
condition|)
block|{
name|PTR
name|opthdr
decl_stmt|;
name|opthdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|aoutsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|opthdr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
empty_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|opthdr
argument_list|,
literal|1
argument_list|,
name|aoutsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|aoutsz
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bfd_coff_swap_aouthdr_in
argument_list|(
name|abfd
argument_list|,
name|opthdr
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|)
expr_stmt|;
block|}
comment|/* Seek past the opt hdr stuff */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|internal_f
operator|.
name|f_opthdr
operator|+
name|filhsz
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
name|coff_real_object_p
argument_list|(
name|abfd
argument_list|,
name|nscns
argument_list|,
operator|&
name|internal_f
argument_list|,
operator|(
name|internal_f
operator|.
name|f_opthdr
operator|!=
literal|0
condition|?
operator|&
name|internal_a
else|:
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|NULL
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Get the BFD section from a COFF symbol section number.  */
end_comment

begin_decl_stmt
name|struct
name|sec
modifier|*
name|DEFUN
argument_list|(
name|coff_section_from_bfd_index
argument_list|,
operator|(
name|abfd
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|index
argument_list|)
block|{
name|struct
name|sec
modifier|*
name|answer
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|N_ABS
condition|)
block|{
return|return
operator|&
name|bfd_abs_section
return|;
block|}
if|if
condition|(
name|index
operator|==
name|N_UNDEF
condition|)
block|{
return|return
operator|&
name|bfd_und_section
return|;
block|}
if|if
condition|(
name|index
operator|==
name|N_DEBUG
condition|)
block|{
return|return
operator|&
name|bfd_debug_section
return|;
block|}
while|while
condition|(
name|answer
condition|)
block|{
if|if
condition|(
name|answer
operator|->
name|target_index
operator|==
name|index
condition|)
return|return
name|answer
return|;
name|answer
operator|=
name|answer
operator|->
name|next
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|bfd_und_section
return|;
comment|/* For gcc -W and lint.  Never executed. */
block|}
end_decl_stmt

begin_comment
comment|/* Get the upper bound of a COFF symbol table.  */
end_comment

begin_function
name|unsigned
name|int
name|coff_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bfd_coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|coff_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a COFF symbol table.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|alocation
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|alocation
argument_list|)
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|coff_symbol_type
modifier|*
name|symbase
decl_stmt|;
name|coff_symbol_type
modifier|*
modifier|*
name|location
init|=
operator|(
name|coff_symbol_type
operator|*
operator|*
operator|)
operator|(
name|alocation
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
name|symbase
operator|=
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* This nasty code looks at the symbol to decide whether or 	   not it is descibes a constructor/destructor entry point. It 	   is structured this way to (hopefully) speed non matches */
if|#
directive|if
literal|0
block|if (0&& symbase->symbol.name[9] == '$')  	{ 	    bfd_constructor_entry(abfd,  				 (asymbol **)location, 				  symbase->symbol.name[10] == 'I' ? 				  "CTOR" : "DTOR"); 	}
endif|#
directive|endif
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
name|symbase
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
operator|*
name|location
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Set lineno_count for the output sections of a COFF file.  */
end_comment

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|coff_count_linenumbers
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|limit
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|asection
modifier|*
name|s
init|=
name|abfd
operator|->
name|sections
operator|->
name|output_section
decl_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|lineno_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|q_maybe
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|q_maybe
argument_list|)
operator|==
name|bfd_target_coff_flavour
condition|)
block|{
name|coff_symbol_type
modifier|*
name|q
init|=
name|coffsymbol
argument_list|(
name|q_maybe
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|lineno
condition|)
block|{
comment|/* 	  This symbol has a linenumber, increment the owning 	  section's linenumber count 	  */
name|alent
modifier|*
name|l
init|=
name|q
operator|->
name|lineno
decl_stmt|;
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|lineno_count
operator|++
expr_stmt|;
name|total
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|lineno_count
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|total
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Takes a bfd and a symbol, returns a pointer to the coff specific    area of the symbol if there is one.  */
end_comment

begin_decl_stmt
name|coff_symbol_type
modifier|*
name|DEFUN
argument_list|(
name|coff_symbol_from
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
argument_list|)
block|{
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|symbol
argument_list|)
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|bfd_asymbol_bfd
argument_list|(
name|symbol
argument_list|)
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|==
operator|(
name|coff_data_type
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
return|;
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fixup_symbol_value
argument_list|,
operator|(
name|coff_symbol_ptr
operator|,
name|syment
operator|)
argument_list|,
name|coff_symbol_type
operator|*
name|coff_symbol_ptr
name|AND
expr|struct
name|internal_syment
operator|*
name|syment
argument_list|)
block|{
comment|/* Normalize the symbol flags */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
block|{
comment|/* a common symbol is undefined with a value */
name|syment
operator|->
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|syment
operator|->
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
condition|)
block|{
name|syment
operator|->
name|n_scnum
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
operator|+
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen, but I don't know why yet (steve@cygnus.com) */
name|syment
operator|->
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* run through all the symbols in the symbol table and work out what    their indexes into the symbol table will be when output   Coff requires that each C_FILE symbol points to the next one in the  chain, and that the last one points to the first external symbol. We  do that here too.  */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|coff_renumber_symbols
argument_list|,
operator|(
name|bfd_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|bfd_ptr
argument_list|)
block|{
name|unsigned
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|bfd_ptr
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
init|=
name|bfd_ptr
operator|->
name|outsymbols
decl_stmt|;
name|unsigned
name|int
name|native_index
init|=
literal|0
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|last_file
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|NULL
decl_stmt|;
name|unsigned
name|int
name|symbol_index
decl_stmt|;
comment|/* COFF demands that undefined symbols come after all other symbols.      Since we don't need to impose this extra knowledge on all our client      programs, deal with that here.  Sort the symbol table; just move the      undefined symbols to the end, leaving the rest alone.  */
comment|/* @@ Do we have some condition we could test for, so we don't always      have to do this?  I don't think relocatability is quite right, but      I'm not certain.  [raeburn:19920508.1711EST]  */
block|{
name|asymbol
modifier|*
modifier|*
name|newsyms
decl_stmt|;
name|int
name|i
decl_stmt|;
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|bfd_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|*
operator|(
name|symbol_count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bfd_ptr
operator|->
name|outsymbols
operator|=
name|newsyms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
operator|!=
operator|&
name|bfd_und_section
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
operator|*
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
name|symbol_ptr_ptr
operator|=
name|bfd_ptr
operator|->
name|outsymbols
expr_stmt|;
block|}
for|for
control|(
name|symbol_index
operator|=
literal|0
init|;
name|symbol_index
operator|<
name|symbol_count
condition|;
name|symbol_index
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
init|=
name|coff_symbol_from
argument_list|(
name|bfd_ptr
argument_list|,
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|coff_symbol_ptr
operator|&&
name|coff_symbol_ptr
operator|->
name|native
condition|)
block|{
name|combined_entry_type
modifier|*
name|s
init|=
name|coff_symbol_ptr
operator|->
name|native
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_file
operator|!=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|NULL
condition|)
block|{
name|last_file
operator|->
name|n_value
operator|=
name|native_index
expr_stmt|;
block|}
name|last_file
operator|=
operator|&
operator|(
name|s
operator|->
name|u
operator|.
name|syment
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Modify the symbol values according to their section and 	       type */
name|fixup_symbol_value
argument_list|(
name|coff_symbol_ptr
argument_list|,
operator|&
operator|(
name|s
operator|->
name|u
operator|.
name|syment
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|s
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|native_index
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|native_index
operator|++
expr_stmt|;
block|}
block|}
name|obj_conv_table_size
argument_list|(
name|bfd_ptr
argument_list|)
operator|=
name|native_index
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  Run thorough the symbol table again, and fix it so that all pointers to  entries are changed to the entries' index in the output symbol table.  */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|coff_mangle_symbols
argument_list|,
operator|(
name|bfd_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|bfd_ptr
argument_list|)
block|{
name|unsigned
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|bfd_ptr
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
init|=
name|bfd_ptr
operator|->
name|outsymbols
decl_stmt|;
name|unsigned
name|int
name|symbol_index
decl_stmt|;
for|for
control|(
name|symbol_index
operator|=
literal|0
init|;
name|symbol_index
operator|<
name|symbol_count
condition|;
name|symbol_index
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
init|=
name|coff_symbol_from
argument_list|(
name|bfd_ptr
argument_list|,
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|coff_symbol_ptr
operator|&&
name|coff_symbol_ptr
operator|->
name|native
condition|)
block|{
name|int
name|i
decl_stmt|;
name|combined_entry_type
modifier|*
name|s
init|=
name|coff_symbol_ptr
operator|->
name|native
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|combined_entry_type
modifier|*
name|a
init|=
name|s
operator|+
name|i
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|fix_tag
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|fix_end
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|string_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_fix_symbol_name
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|native
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|combined_entry_type
operator|*
name|native
argument_list|)
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|auxent
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|symbol
operator|->
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* coff symbols always have names, so we'll make one up */
name|symbol
operator|->
name|name
operator|=
literal|"strange"
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|symbol
operator|->
name|name
expr_stmt|;
block|}
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
name|strncpy
argument_list|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
literal|".file"
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|auxent
operator|=
operator|&
operator|(
name|native
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
expr_stmt|;
if|if
condition|(
name|bfd_coff_long_filenames
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|name_length
operator|<=
name|FILNMLEN
condition|)
block|{
name|strncpy
argument_list|(
name|auxent
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|name
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auxent
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|string_size
operator|+
literal|4
expr_stmt|;
name|auxent
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|string_size
operator|+=
name|name_length
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|strncpy
argument_list|(
name|auxent
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|name
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|FILNMLEN
condition|)
block|{
name|name
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* NOT A C_FILE SYMBOL */
if|if
condition|(
name|name_length
operator|<=
name|SYMNMLEN
condition|)
block|{
comment|/* This name will fit into the symbol neatly */
name|strncpy
argument_list|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|string_size
operator|+
literal|4
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|string_size
operator|+=
name|name_length
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|set_index
parameter_list|(
name|symbol
parameter_list|,
name|idx
parameter_list|)
value|((symbol)->udata =(PTR) (idx))
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_write_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|native
operator|,
name|written
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|combined_entry_type
operator|*
name|native
name|AND
name|unsigned
name|int
name|written
argument_list|)
block|{
name|unsigned
name|int
name|numaux
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
decl_stmt|;
name|int
name|type
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
decl_stmt|;
name|int
name|class
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
decl_stmt|;
name|PTR
name|buf
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
comment|/* @@ bfd_debug_section isn't accessible outside this file, but we know      that C_FILE symbols belong there.  So move them.  */
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
name|symbol
operator|->
name|section
operator|=
operator|&
name|bfd_debug_section
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_abs_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_debug_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
name|coff_fix_symbol_name
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|native
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symesz
argument_list|)
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|native
operator|->
name|u
operator|.
name|syment
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|symesz
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|auxesz
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|auxesz
operator|=
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|auxesz
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|j
operator|++
control|)
block|{
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
operator|(
name|native
operator|+
name|j
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|auxesz
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/*     Reuse somewhere in the symbol to keep the index     */
name|set_index
argument_list|(
name|symbol
argument_list|,
name|written
argument_list|)
expr_stmt|;
return|return
name|written
operator|+
literal|1
operator|+
name|numaux
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_write_alien_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|written
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|unsigned
name|int
name|written
argument_list|)
block|{
comment|/*     This symbol has been created by the loader, or come from a non     coff format. It  has no native element to inherit, make our     own     */
name|combined_entry_type
modifier|*
name|native
decl_stmt|;
name|combined_entry_type
name|dummy
decl_stmt|;
name|native
operator|=
operator|&
name|dummy
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
comment|/* 	remove name so it doesn't take up any space 	*/
name|symbol
operator|->
name|name
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Copy the any flags from the the file hdr into the symbol  */
block|{
name|coff_symbol_type
modifier|*
name|c
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
name|bfd_asymbol_bfd
argument_list|(
operator|&
name|c
operator|->
name|symbol
argument_list|)
operator|->
name|flags
expr_stmt|;
block|}
block|}
block|}
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
else|else
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|=
literal|0
expr_stmt|;
return|return
name|coff_write_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|native
argument_list|,
name|written
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_write_native_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|written
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|coff_symbol_type
operator|*
name|symbol
name|AND
name|unsigned
name|int
name|written
argument_list|)
block|{
comment|/*     Does this symbol have an ascociated line number - if so then     make it remember this symbol index. Also tag the auxent of     this symbol to point to the right place in the lineno table     */
name|combined_entry_type
modifier|*
name|native
init|=
name|symbol
operator|->
name|native
decl_stmt|;
name|alent
modifier|*
name|lineno
init|=
name|symbol
operator|->
name|lineno
decl_stmt|;
if|if
condition|(
name|lineno
operator|&&
operator|!
name|symbol
operator|->
name|done_lineno
condition|)
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|lineno
index|[
name|count
index|]
operator|.
name|u
operator|.
name|offset
operator|=
name|written
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
name|union
name|internal_auxent
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
name|native
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|a
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|moving_line_filepos
expr_stmt|;
block|}
comment|/*       And count and relocate all other linenumbers       */
name|count
operator|++
expr_stmt|;
while|while
condition|(
name|lineno
index|[
name|count
index|]
operator|.
name|line_number
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 13 april 92. sac  I've been told this, but still need proof:> The second bug is also in `bfd/coffcode.h'.  This bug causes the linker to screw> up the pc-relocations for all the line numbers in COFF code.  This bug isn't> only specific to A29K implementations, but affects all systems using COFF> format binaries.  Note that in COFF object files, the line number core offsets> output by the assembler are relative to the start of each procedure, not> to the start of the .text section.  This patch relocates the line numbers> relative to the `native->u.syment.n_value' instead of the section virtual> address.  modular!olson@cs.arizona.edu (Jon Olson) */
block|lineno[count].u.offset += native->u.syment.n_value;
else|#
directive|else
name|lineno
index|[
name|count
index|]
operator|.
name|u
operator|.
name|offset
operator|+=
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
block|}
name|symbol
operator|->
name|done_lineno
operator|=
name|true
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|moving_line_filepos
operator|+=
name|count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
name|coff_write_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|symbol
operator|->
name|symbol
operator|)
argument_list|,
name|native
argument_list|,
name|written
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|coff_write_symbols
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|limit
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|written
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|string_size
operator|=
literal|0
expr_stmt|;
comment|/* Seek to the right place */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Output all the symbols we have */
name|written
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|symbol
init|=
operator|*
name|p
decl_stmt|;
name|coff_symbol_type
modifier|*
name|c_symbol
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|c_symbol
operator|==
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
operator|||
name|c_symbol
operator|->
name|native
operator|==
operator|(
name|combined_entry_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|written
operator|=
name|coff_write_alien_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|written
operator|=
name|coff_write_native_symbol
argument_list|(
name|abfd
argument_list|,
name|c_symbol
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|written
expr_stmt|;
comment|/* Now write out strings */
if|if
condition|(
name|string_size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|string_size
operator|+
literal|4
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
name|size_t
name|name_length
init|=
name|strlen
argument_list|(
name|q
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|coff_symbol_type
modifier|*
name|c_symbol
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|maxlen
operator|=
operator|(
operator|(
name|c_symbol
operator|!=
name|NULL
operator|&&
name|c_symbol
operator|->
name|native
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|c_symbol
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
operator|)
operator|)
condition|?
name|FILNMLEN
else|:
name|SYMNMLEN
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|maxlen
condition|)
block|{
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|q
operator|->
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name_length
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We would normally not write anything here, but we'll write        out 4 so that any stupid coff reader which tries to read        the string table even when there isn't one won't croak.  */
name|unsigned
name|int
name|size
init|=
literal|4
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|coff_write_linenumbers
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|linesz
decl_stmt|;
name|PTR
name|buff
decl_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buff
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|linesz
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|lineno_count
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|q
init|=
name|abfd
operator|->
name|outsymbols
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Find all the linenumbers in this section */
while|while
condition|(
operator|*
name|q
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|->
name|output_section
operator|==
name|s
condition|)
block|{
name|alent
modifier|*
name|l
init|=
name|BFD_SEND
argument_list|(
name|bfd_asymbol_bfd
argument_list|(
name|p
argument_list|)
argument_list|,
name|_get_lineno
argument_list|,
operator|(
name|bfd_asymbol_bfd
argument_list|(
name|p
argument_list|)
expr|,
name|p
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
comment|/* Found a linenumber entry, output */
name|struct
name|internal_lineno
name|out
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|l_lnno
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|l
operator|->
name|u
operator|.
name|offset
expr_stmt|;
name|bfd_coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|out
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|linesz
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|out
operator|.
name|l_lnno
operator|=
name|l
operator|->
name|line_number
expr_stmt|;
name|out
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|l
operator|->
name|u
operator|.
name|offset
expr_stmt|;
name|bfd_coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|out
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|linesz
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|alent
modifier|*
name|DEFUN
argument_list|(
name|coff_get_lineno
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
argument_list|)
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
return|;
block|}
end_decl_stmt

begin_function
name|asymbol
modifier|*
name|coff_section_symbol
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|combined_entry_type
modifier|*
name|csym
decl_stmt|;
name|sym
operator|=
name|sec
operator|->
name|symbol
expr_stmt|;
name|csym
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|->
name|native
expr_stmt|;
comment|/* Make sure back-end COFF stuff is there.  */
if|if
condition|(
name|csym
operator|==
literal|0
condition|)
block|{
struct|struct
name|foo
block|{
name|coff_symbol_type
name|sym
decl_stmt|;
comment|/* @@FIXME This shouldn't use a fixed size!!  */
name|combined_entry_type
name|e
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|foo
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|foo
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|->
name|native
operator|=
name|csym
operator|=
name|f
operator|->
name|e
expr_stmt|;
block|}
name|csym
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
name|csym
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
comment|/*  SF_SET_STATICS (sym);	@@ ??? */
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_scnlen
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nreloc
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nlinno
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|output_section
operator|=
name|sec
expr_stmt|;
name|sec
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* This function transforms the offsets into the symbol table into    pointers to syments.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_pointerize_aux
argument_list|,
operator|(
name|abfd
operator|,
name|table_base
operator|,
name|type
operator|,
name|class
operator|,
name|auxent
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|combined_entry_type
operator|*
name|table_base
name|AND
name|int
name|type
name|AND
name|int
name|class
name|AND
name|combined_entry_type
operator|*
name|auxent
argument_list|)
block|{
comment|/* Don't bother if this is a file or a section */
if|if
condition|(
name|class
operator|==
name|C_STAT
operator|&&
name|type
operator|==
name|T_NULL
condition|)
return|return;
if|if
condition|(
name|class
operator|==
name|C_FILE
condition|)
return|return;
comment|/* Otherwise patch up */
define|#
directive|define
name|N_TMASK
value|coff_data (abfd)->local_n_tmask
define|#
directive|define
name|N_BTSHFT
value|coff_data (abfd)->local_n_btshft
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
operator|||
name|class
operator|==
name|C_BLOCK
condition|)
block|{
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|=
name|table_base
operator|+
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
name|auxent
operator|->
name|fix_end
operator|=
literal|1
expr_stmt|;
block|}
comment|/* A negative tagndx is meaningless, but the SCO 3.2v4 cc can      generate one, so we must be careful to ignore it.  */
if|if
condition|(
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|>
literal|0
condition|)
block|{
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|=
name|table_base
operator|+
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
name|auxent
operator|->
name|fix_tag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|build_string_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
name|string_table_size_buffer
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|string_table_size
decl_stmt|;
name|char
modifier|*
name|string_table
decl_stmt|;
comment|/* At this point we should be "seek"'d to the end of the      symbols === the symbol table size.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|string_table_size_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|string_table_size_buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|string_table_size
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
name|string_table_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|string_table_size_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|string_table
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|string_table_size
operator|-=
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on mallocation error */
if|if
condition|(
name|bfd_read
argument_list|(
name|string_table
argument_list|,
name|string_table_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|string_table_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
name|string_table
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Allocate space for the ".debug" section, and read it.    We did not read the debug section until now, because    we didn't want to go to the trouble until someone needed it. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|build_debug_section
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
modifier|*
name|debug_section
decl_stmt|;
name|long
name|position
decl_stmt|;
name|asection
modifier|*
name|sect
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sect
condition|)
block|{
name|bfd_error
operator|=
name|no_debug_section
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|debug_section
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_section
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Seek to the beginning of the `.debug' section and read it.       Save the current position first; it is needed by our caller.      Then read debug section and reset the file pointer.  */
name|position
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sect
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|debug_section
argument_list|,
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|position
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
name|debug_section
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return a pointer to a malloc'd copy of 'name'.  'name' may not be  \0-terminated, but will not exceed 'maxlen' characters.  The copy *will*  be \0-terminated.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|copy_name
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|,
name|maxlen
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|name
name|AND
name|int
name|maxlen
argument_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|maxlen
condition|;
operator|++
name|len
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|newname
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|newname
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Read a symbol table into freshly bfd_allocated memory, swap it, and    knit the symbol names into a normalized form.  By normalized here I    mean that all symbols have an n_offset pointer that points to a null-    terminated string.  */
end_comment

begin_decl_stmt
name|combined_entry_type
modifier|*
name|DEFUN
argument_list|(
name|coff_get_normalized_symtab
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|combined_entry_type
modifier|*
name|internal
decl_stmt|;
name|combined_entry_type
modifier|*
name|internal_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|internal_end
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|PTR
name|raw
decl_stmt|;
name|char
modifier|*
name|raw_src
decl_stmt|;
name|char
modifier|*
name|raw_end
decl_stmt|;
name|char
modifier|*
name|string_table
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|debug_section
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
if|if
condition|(
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|combined_entry_type
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|size
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_symbols
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|internal
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|internal_end
operator|=
name|internal
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|raw_size
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
name|raw
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|raw
argument_list|,
name|raw_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|raw_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* mark the end of the symbols */
name|raw_end
operator|=
operator|(
name|char
operator|*
operator|)
name|raw
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
comment|/*     FIXME SOMEDAY.  A string table size of zero is very weird, but     probably possible.  If one shows up, it will probably kill us.     */
comment|/* Swap all the raw entries */
for|for
control|(
name|raw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|raw
operator|,
name|internal_ptr
operator|=
name|internal
init|;
name|raw_src
operator|<
name|raw_end
condition|;
name|raw_src
operator|+=
name|symesz
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_src
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
name|internal_ptr
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
name|symbol_ptr
operator|=
name|internal_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|internal_ptr
operator|++
expr_stmt|;
name|raw_src
operator|+=
name|symesz
expr_stmt|;
name|internal_ptr
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
name|internal_ptr
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_src
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
operator|&
operator|(
name|internal_ptr
operator|->
name|u
operator|.
name|auxent
operator|)
argument_list|)
expr_stmt|;
comment|/* Remember that bal entries arn't pointerized */
if|if
condition|(
name|i
operator|!=
literal|1
operator|||
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|!=
name|C_LEAFPROC
condition|)
block|{
name|coff_pointerize_aux
argument_list|(
name|abfd
argument_list|,
name|internal
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|internal_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Free all the raw stuff */
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|raw
argument_list|)
expr_stmt|;
for|for
control|(
name|internal_ptr
operator|=
name|internal
init|;
name|internal_ptr
operator|<
name|internal_end
condition|;
name|internal_ptr
operator|++
control|)
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
comment|/* make a file symbol point to the name in the auxent, since 	   the text ".file" is redundant */
if|if
condition|(
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
block|{
comment|/* the filename is a long one, point into the string table */
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
block|{
name|string_table
operator|=
name|build_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|long
call|)
argument_list|(
name|string_table
operator|-
literal|4
operator|+
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ordinary short filename, put into memory anyway */
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|long
operator|)
name|copy_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
condition|)
block|{
comment|/* This is a "short" name.  Make it long.  */
name|unsigned
name|long
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|newstring
init|=
name|NULL
decl_stmt|;
comment|/* find the length of this string without walking into memory 	       that isn't ours.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
comment|/* if end of string */
block|}
comment|/* possible lengths of this string. */
if|if
condition|(
operator|(
name|newstring
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|++
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
name|memset
argument_list|(
name|newstring
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newstring
argument_list|,
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|long
name|int
operator|)
name|newstring
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bfd_coff_symname_in_debug
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
comment|/* Long name already.  Point symbol at the string in the table.  */
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
block|{
name|string_table
operator|=
name|build_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|long
name|int
call|)
argument_list|(
name|string_table
operator|-
literal|4
operator|+
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Long name in debug section.  Very similar.  */
if|if
condition|(
name|debug_section
operator|==
name|NULL
condition|)
block|{
name|debug_section
operator|=
name|build_debug_section
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|long
name|int
call|)
argument_list|(
name|debug_section
operator|+
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|)
expr_stmt|;
block|}
block|}
name|internal_ptr
operator|+=
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
block|}
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_ptr
operator|-
name|internal
expr_stmt|;
return|return
operator|(
name|internal
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* coff_get_normalized_symtab() */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_get_reloc_upper_bound
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
argument_list|)
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|coff_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|coff_symbol_type
modifier|*
name|new
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|native
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Make a debugging symbol.  */
end_comment

begin_function
name|asymbol
modifier|*
name|coff_bfd_make_debug_symbol
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|sz
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
block|{
name|coff_symbol_type
modifier|*
name|new
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
comment|/* @@ This shouldn't be using a constant multiplier.  */
name|new
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_debug_section
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_function
name|void
name|coff_get_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out information about COFF symbol.  */
end_comment

begin_function
name|void
name|coff_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"coff %s %s"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|?
literal|"n"
else|:
literal|"g"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
condition|?
literal|"l"
else|:
literal|" "
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
if|if
condition|(
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|)
block|{
name|unsigned
name|int
name|aux
decl_stmt|;
name|combined_entry_type
modifier|*
name|combined
init|=
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
decl_stmt|;
name|combined_entry_type
modifier|*
name|root
init|=
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|lineno_cache_entry
modifier|*
name|l
init|=
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%3d]"
argument_list|,
name|combined
operator|-
name|root
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sc %2d)(fl 0x%02x)(ty %3x)(sc %3d) (nx %d) 0x%08x %s"
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|aux
operator|=
literal|0
init|;
name|aux
operator|<
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|aux
operator|++
control|)
block|{
name|combined_entry_type
modifier|*
name|auxp
init|=
name|combined
operator|+
name|aux
operator|+
literal|1
decl_stmt|;
name|long
name|tagndx
decl_stmt|;
if|if
condition|(
name|auxp
operator|->
name|fix_tag
condition|)
name|tagndx
operator|=
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|-
name|root
expr_stmt|;
else|else
name|tagndx
operator|=
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_FILE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"File "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"AUX lnno %d size 0x%x tagndx %d"
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|auxp
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|tagndx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|l
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%s :"
argument_list|,
name|l
operator|->
name|u
operator|.
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%4d : 0x%x"
argument_list|,
name|l
operator|->
name|line_number
argument_list|,
name|l
operator|->
name|u
operator|.
name|offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s %s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|?
literal|"n"
else|:
literal|"g"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
condition|?
literal|"l"
else|:
literal|" "
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Provided a BFD, a section and an offset into the section, calculate    and return the name of the source file and the line nearest to the    wanted location.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|coff_find_nearest_line
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|ignore_symbols
operator|,
name|offset
operator|,
name|filename_ptr
operator|,
name|functionname_ptr
operator|,
name|line_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|asymbol
operator|*
operator|*
name|ignore_symbols
name|AND
name|bfd_vma
name|offset
name|AND
name|CONST
name|char
operator|*
operator|*
name|filename_ptr
name|AND
name|CONST
name|char
operator|*
operator|*
name|functionname_ptr
name|AND
name|unsigned
name|int
operator|*
name|line_ptr
argument_list|)
block|{
specifier|static
name|bfd
modifier|*
name|cache_abfd
decl_stmt|;
specifier|static
name|asection
modifier|*
name|cache_section
decl_stmt|;
specifier|static
name|bfd_vma
name|cache_offset
decl_stmt|;
specifier|static
name|unsigned
name|int
name|cache_i
decl_stmt|;
specifier|static
name|CONST
name|char
modifier|*
name|cache_function
decl_stmt|;
specifier|static
name|unsigned
name|int
name|line_base
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|coff_data_type
modifier|*
name|cof
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Run through the raw syments if available */
name|combined_entry_type
modifier|*
name|p
decl_stmt|;
name|alent
modifier|*
name|l
decl_stmt|;
operator|*
name|filename_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Don't try and find line numbers in a non coff file */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
name|false
return|;
if|if
condition|(
name|cof
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|=
name|cof
operator|->
name|raw_syments
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cof
operator|->
name|raw_syment_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
comment|/* File name has been moved into symbol */
operator|*
name|filename_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
break|break;
block|}
name|p
operator|+=
literal|1
operator|+
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
block|}
comment|/* Now wander though the raw linenumbers of the section */
comment|/*     If this is the same BFD as we were previously called with and this is     the same section, and the offset we want is further down then we can     prime the lookup loop     */
if|if
condition|(
name|abfd
operator|==
name|cache_abfd
operator|&&
name|section
operator|==
name|cache_section
operator|&&
name|offset
operator|>=
name|cache_offset
condition|)
block|{
name|i
operator|=
name|cache_i
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|cache_function
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|l
operator|=
operator|&
name|section
operator|->
name|lineno
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|section
operator|->
name|lineno_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|->
name|line_number
operator|==
literal|0
condition|)
block|{
comment|/* Get the symbol this line number points at */
name|coff_symbol_type
modifier|*
name|coff
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
name|l
operator|->
name|u
operator|.
name|sym
operator|)
decl_stmt|;
if|if
condition|(
name|coff
operator|->
name|symbol
operator|.
name|value
operator|>
name|offset
condition|)
break|break;
operator|*
name|functionname_ptr
operator|=
name|coff
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|coff
operator|->
name|native
condition|)
block|{
name|combined_entry_type
modifier|*
name|s
init|=
name|coff
operator|->
name|native
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|1
operator|+
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
comment|/* 	  S should now point to the .bf of the function 	  */
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
comment|/* 	    The linenumber is stored in the auxent 	    */
name|union
name|internal_auxent
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|line_base
operator|=
name|a
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
operator|*
name|line_ptr
operator|=
name|line_base
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|l
operator|->
name|u
operator|.
name|offset
operator|>
name|offset
condition|)
break|break;
operator|*
name|line_ptr
operator|=
name|l
operator|->
name|line_number
operator|+
name|line_base
operator|-
literal|1
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
name|cache_abfd
operator|=
name|abfd
expr_stmt|;
name|cache_section
operator|=
name|section
expr_stmt|;
name|cache_offset
operator|=
name|offset
expr_stmt|;
name|cache_i
operator|=
name|i
expr_stmt|;
name|cache_function
operator|=
operator|*
name|functionname_ptr
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|coff_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|reloc
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|reloc
argument_list|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|reloc
operator|==
name|false
condition|)
block|{
name|size
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_decl_stmt

end_unit

