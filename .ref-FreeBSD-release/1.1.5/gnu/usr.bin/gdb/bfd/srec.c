begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for s-record objects.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	S-Record handling  DESCRIPTION 	 	Ordinary S-Records cannot hold anything but addresses and 	data, so that's all that we implement.     	The only interesting thing is that S-Records may come out of 	order and there is no header, so an initial scan is required 	to discover the minimum and maximum addresses used to create 	the vma and size of the only section we create.  We 	arbitrarily call this section ".text".   	When bfd_get_section_contents is called the file is read 	again, and this time the data is placed into a bfd_alloc'd 	area.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.  	An s record looks like: 	 EXAMPLE 	S<type><length><address><data><checksum> 	 DESCRIPTION 	Where 	o length 	is the number of bytes following upto the checksum. Note that 	this is not the number of chars following, since it takes two 	chars to represent a byte. 	o type 	is one of: 	0) header record 	1) two byte address data record 	2) three byte address data record 	3) four byte address data record 	7) four byte address termination record 	8) three byte address termination record 	9) two byte address termination record 	 	o address 	is the start address of the data following, or in the case of 	a termination record, the start address of the image 	o data 	is the data. 	o checksum 	is the sum of all the raw byte data in the record, from the length 	upwards, modulo 256 and subtracted from 255.   SUBSECTION 	Symbol S-Record handling  DESCRIPTION 	Some ICE equipment understands an addition to the standard 	S-Record format; symbols and their addresses can be sent 	before the data.  	The format of this is: 	($$<modulename> 		(<space><symbol><address>)*) 	$$  	so a short symbol table could look like:  EXAMPLE 	$$ flash.x 	$$ flash.c 	  _port6 $0 	  _delay $4 	  _start $14 	  _etext $8036 	  _edata $8036  	  _end $8036 	$$   DESCRIPTION 	We allow symbols to be anywhere in the data stream - the module names 	are always ignored. 		 */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* Macros for converting between hex and binary */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|hex_value
index|[
literal|1
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOT_HEX
value|20
end_define

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value[(unsigned char)(x)]
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|,
name|ch
parameter_list|)
define|\
value|d[1] = digs[(x)& 0xf]; \ 	d[0] = digs[((x)>>4)&0xf]; \ 	ch += ((x)& 0xff);
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|(hex_value[(unsigned char)(x)] != NOT_HEX)
end_define

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|srec_init
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|boolean
name|inited
init|=
name|false
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|false
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hex_value
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
index|]
operator|=
name|NOT_HEX
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'a'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|hex_value
index|[
name|i
operator|+
literal|'A'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of bytes on a line is FF */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* The number of bytes we fit onto a line on output */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|21
end_define

begin_comment
comment|/* We cannot output our srecords as we see them, we have to glue them    together, this is done in this structure : */
end_comment

begin_struct
struct|struct
name|srec_data_list_struct
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|srec_data_list_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|srec_data_list_struct
name|srec_data_list_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|srec_data_struct
block|{
name|srec_data_list_type
modifier|*
name|head
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|int
name|done_symbol_read
decl_stmt|;
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
name|symbols
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|int
name|symbol_idx
decl_stmt|;
name|int
name|string_size
decl_stmt|;
name|int
name|string_idx
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_comment
comment|/*     called once per input S-Record, used to work out vma and size of data.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|size_symbols
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fillup_symbols
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|done_symbol_read
condition|)
block|{
name|asymbol
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|==
literal|0
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbol_idx
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_idx
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|+
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbol_idx
operator|++
expr_stmt|;
name|p
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|strings
operator|+
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_idx
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|name
operator|)
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_idx
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
name|p
operator|->
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
name|p
operator|->
name|udata
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|size_srec
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|address
operator|,
name|raw
operator|,
name|length
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|bfd_vma
name|address
name|AND
name|bfd_byte
operator|*
name|raw
name|AND
name|unsigned
name|int
name|length
argument_list|)
block|{
if|if
condition|(
name|address
operator|<
name|low
condition|)
name|low
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|+
name|length
operator|>
name|high
condition|)
name|high
operator|=
name|address
operator|+
name|length
operator|-
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  called once per input S-Record, copies data from input into bfd_alloc'd area  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fillup
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|address
operator|,
name|raw
operator|,
name|length
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|bfd_vma
name|address
name|AND
name|bfd_byte
operator|*
name|raw
name|AND
name|unsigned
name|int
name|length
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
init|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|section
operator|->
name|used_by_bfd
operator|)
operator|+
name|address
operator|-
name|section
operator|->
name|vma
decl_stmt|;
comment|/* length -1 because we don't read in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|=
name|HEX
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Pass over an S-Record file, calling one of the above functions on each    record.  */
end_comment

begin_function
specifier|static
name|int
name|white
parameter_list|(
name|x
parameter_list|)
name|char
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|==
literal|' '
operator|||
name|x
operator|==
literal|'\t'
operator|||
name|x
operator|==
literal|'\n'
operator|||
name|x
operator|==
literal|'\r'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|skipwhite
parameter_list|(
name|src
parameter_list|,
name|abfd
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|eof
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|white
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|eof
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|==
literal|0
condition|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|pass_over
argument_list|,
operator|(
name|abfd
operator|,
name|func
operator|,
name|symbolfunc
operator|,
name|section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|void
argument_list|(
argument|*func
argument_list|)
operator|(
operator|)
name|AND
name|void
argument_list|(
argument|*symbolfunc
argument_list|)
operator|(
operator|)
name|AND
name|asection
operator|*
name|section
argument_list|)
block|{
name|unsigned
name|int
name|bytes_on_line
decl_stmt|;
name|boolean
name|eof
init|=
name|false
decl_stmt|;
name|srec_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* To the front of the file */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|eof
operator|==
name|false
condition|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
name|type
decl_stmt|;
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
comment|/* Find first 'S' or $ */
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
default|default:
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
return|return;
break|break;
case|case
literal|'$'
case|:
comment|/* Inside a symbol definition - just ignore the module name */
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\n'
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
comment|/* spaces - maybe just before a symbol */
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\n'
operator|&&
name|white
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|eof
operator|=
name|skipwhite
argument_list|(
name|src
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|slen
init|=
literal|0
decl_stmt|;
name|char
name|symbol
index|[
name|MAXCHUNK
index|]
decl_stmt|;
comment|/* get the symbol part */
while|while
condition|(
operator|!
name|eof
operator|&&
operator|!
name|white
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
name|slen
operator|<
name|MAXCHUNK
condition|)
block|{
name|symbol
index|[
name|slen
operator|++
index|]
operator|=
operator|*
name|src
expr_stmt|;
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
name|symbol
index|[
name|slen
index|]
operator|=
literal|0
expr_stmt|;
name|eof
operator|=
name|skipwhite
argument_list|(
name|src
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* skip the $ for the hex value */
if|if
condition|(
operator|*
name|src
operator|==
literal|'$'
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Scan off the hex number */
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|val
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|src
argument_list|)
condition|)
name|val
operator|+=
operator|*
name|src
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|val
operator|+=
operator|*
name|src
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|val
operator|+=
operator|*
name|src
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
name|symbolfunc
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|slen
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'S'
case|:
name|src
operator|++
expr_stmt|;
comment|/* Fetch the type and the length */
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
name|bytes_on_line
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_on_line
operator|>
name|MAXCHUNK
operator|/
literal|2
condition|)
break|break;
name|src
operator|+=
literal|2
expr_stmt|;
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|bytes_on_line
operator|*
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'5'
case|:
comment|/* Prologue - ignore */
break|break;
case|case
literal|'3'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|--
expr_stmt|;
case|case
literal|'2'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|--
expr_stmt|;
case|case
literal|'1'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|-=
literal|2
expr_stmt|;
name|func
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|src
argument_list|,
name|bytes_on_line
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|bfd_target
modifier|*
name|object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* We create one section called .text for all the contents,       and allocate enough room for the entire file.  */
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|vma
operator|=
literal|0xffffffff
expr_stmt|;
name|low
operator|=
literal|0xffffffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|size_srec
argument_list|,
name|size_symbols
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|high
operator|-
name|low
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|low
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|srec_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'S'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
comment|/* We create one section called .text for all the contents,       and allocate enough room for the entire file.  */
return|return
name|object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|symbolsrec_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|b
index|[
literal|1
index|]
operator|!=
literal|'$'
condition|)
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
return|return
name|object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|fillup
argument_list|,
name|fillup_symbols
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|section
operator|->
name|used_by_bfd
operator|)
operator|+
name|offset
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|srec_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* we have to save up all the Srecords for a splurge before output,    also remember   */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|bytes_to_do
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|bytes_to_do
argument_list|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|entry
init|=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|srec_data_list_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bytes_to_do
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|location
argument_list|,
name|bytes_to_do
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|lma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|)
operator|<=
literal|0xffff
condition|)
block|{  	}
elseif|else
if|if
condition|(
operator|(
name|section
operator|->
name|lma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|)
operator|<=
literal|0xffffff
operator|&&
name|tdata
operator|->
name|type
operator|<
literal|2
condition|)
block|{
name|tdata
operator|->
name|type
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|tdata
operator|->
name|type
operator|=
literal|3
expr_stmt|;
block|}
name|entry
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|where
operator|=
name|section
operator|->
name|lma
operator|+
name|offset
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|bytes_to_do
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Write a record of type, of the supplied number of bytes. The    supplied bytes and length don't have a checksum. That's worked out    here */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_record
argument_list|,
operator|(
name|abfd
operator|,
name|type
operator|,
name|address
operator|,
name|data
operator|,
name|end
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
name|type
name|AND
name|bfd_vma
name|address
name|AND
name|CONST
name|unsigned
name|char
operator|*
name|data
name|AND
name|CONST
name|unsigned
name|char
operator|*
name|end
argument_list|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|unsigned
name|int
name|check_sum
init|=
literal|0
decl_stmt|;
name|unsigned
name|CONST
name|char
modifier|*
name|src
init|=
name|data
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|length
decl_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'0'
operator|+
name|type
expr_stmt|;
name|length
operator|=
name|dst
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
comment|/* leave room for dst*/
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|7
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|24
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|8
case|:
case|case
literal|2
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|16
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|9
case|:
case|case
literal|1
case|:
case|case
literal|0
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|8
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|src
operator|=
name|data
init|;
name|src
operator|<
name|end
condition|;
name|src
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|*
name|src
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Fill in the length */
name|TOHEX
argument_list|(
name|length
argument_list|,
operator|(
name|dst
operator|-
name|length
operator|)
operator|/
literal|2
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|check_sum
operator|&=
literal|0xff
expr_stmt|;
name|check_sum
operator|=
literal|255
operator|-
name|check_sum
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|check_sum
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|dst
operator|-
name|buffer
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_header
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* I'll put an arbitary 40 char limit on header size */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
operator|&&
name|abfd
operator|->
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|++
operator|=
name|abfd
operator|->
name|filename
index|[
name|i
index|]
expr_stmt|;
block|}
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_section
argument_list|,
operator|(
name|abfd
operator|,
name|tdata
operator|,
name|list
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|tdata_type
operator|*
name|tdata
name|AND
name|srec_data_list_type
operator|*
name|list
argument_list|)
block|{
name|unsigned
name|int
name|bytes_written
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|location
init|=
name|list
operator|->
name|data
decl_stmt|;
while|while
condition|(
name|bytes_written
operator|<
name|list
operator|->
name|size
condition|)
block|{
name|bfd_vma
name|address
decl_stmt|;
name|unsigned
name|int
name|bytes_this_chunk
init|=
name|list
operator|->
name|size
operator|-
name|bytes_written
decl_stmt|;
if|if
condition|(
name|bytes_this_chunk
operator|>
name|CHUNK
condition|)
block|{
name|bytes_this_chunk
operator|=
name|CHUNK
expr_stmt|;
block|}
name|address
operator|=
name|list
operator|->
name|where
operator|+
name|bytes_written
expr_stmt|;
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
name|tdata
operator|->
name|type
argument_list|,
name|address
argument_list|,
name|location
argument_list|,
name|location
operator|+
name|bytes_this_chunk
argument_list|)
expr_stmt|;
name|bytes_written
operator|+=
name|bytes_this_chunk
expr_stmt|;
name|location
operator|+=
name|bytes_this_chunk
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_terminator
argument_list|,
operator|(
name|abfd
operator|,
name|tdata
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|tdata_type
operator|*
name|tdata
argument_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|10
operator|-
name|tdata
operator|->
name|type
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|buffer
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|srec_write_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
comment|/* Dump out the symbols of a bfd */
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|table
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"$$ %s\r\n"
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|asymbol
modifier|*
name|s
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|int len = strlen(s->name);
comment|/* If this symbol has a .[ocs] in it, it's probably a file name 	 and we'll output that as the module name */
block|if (len> 3&& s->name[len-2] == '.')        { 	int l; 	sprintf(buffer, "$$ %s\r\n", s->name); 	l = strlen(buffer); 	bfd_write(buffer, l, 1, abfd);       }       else
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
operator|&&
name|s
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
name|s
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'t'
condition|)
block|{
comment|/* Just dump out non debug symbols */
name|int
name|l
decl_stmt|;
name|char
name|buf2
index|[
literal|40
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buf2
argument_list|,
name|s
operator|->
name|value
operator|+
name|s
operator|->
name|section
operator|->
name|lma
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf2
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"  %s $%s\r\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|l
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"$$ \r\n"
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|internal_srec_write_object_contents
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|symbols
decl_stmt|;
block|{
name|int
name|bytes_written
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|list
decl_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbols
condition|)
name|srec_write_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|srec_write_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now wander though all the sections provided and output them */
name|list
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|list
operator|!=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|srec_write_section
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|srec_write_terminator
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|internal_srec_write_object_contents
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|symbolsrec_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|internal_srec_write_object_contents
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|srec_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|exec
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|exec
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|srec_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asymbol
modifier|*
name|new
init|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|srec_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Read in all the info */
name|srec_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|sections
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|srec_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|alocation
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|alocation
argument_list|)
block|{
name|int
name|lim
init|=
name|abfd
operator|->
name|symcount
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|alocation
index|[
name|i
index|]
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|+
name|i
expr_stmt|;
block|}
name|alocation
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|lim
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|srec_get_symbol_info
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|,
name|ret
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|symbol_info
operator|*
name|ret
argument_list|)
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|srec_print_symbol
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|afile
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|afile
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|FOO
value|PROTO
end_define

begin_define
define|#
directive|define
name|srec_new_section_hook
value|(FOO(boolean, (*), (bfd *, asection *)))bfd_true
end_define

begin_define
define|#
directive|define
name|srec_get_reloc_upper_bound
value|(FOO(unsigned int, (*),(bfd*, asection *)))bfd_false
end_define

begin_define
define|#
directive|define
name|srec_canonicalize_reloc
value|(FOO(unsigned int, (*),(bfd*,asection *, arelent **, asymbol **))) bfd_0
end_define

begin_define
define|#
directive|define
name|srec_openr_next_archived_file
value|(FOO(bfd *, (*), (bfd*,bfd*))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_find_nearest_line
value|(FOO(boolean, (*),(bfd*,asection*,asymbol**,bfd_vma, CONST char**, CONST char**, unsigned int *))) bfd_false
end_define

begin_define
define|#
directive|define
name|srec_generic_stat_arch_elt
value|(FOO(int, (*), (bfd *,struct stat *))) bfd_0
end_define

begin_define
define|#
directive|define
name|srec_core_file_failing_command
value|(char *(*)())(bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|srec_core_file_failing_signal
value|(int (*)())bfd_0
end_define

begin_define
define|#
directive|define
name|srec_core_file_matches_executable_p
value|(FOO(boolean, (*),(bfd*, bfd*)))bfd_false
end_define

begin_define
define|#
directive|define
name|srec_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|srec_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|srec_truncate_arname
value|(void (*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_write_armap
value|(FOO( boolean, (*),(bfd *, unsigned int, struct orl *, unsigned int, int))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_get_lineno
value|(struct lineno_cache_entry *(*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|srec_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|srec_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|srec_bfd_debug_info_accumulate
value|(FOO(void, (*), (bfd *,	 asection *))) bfd_void
end_define

begin_define
define|#
directive|define
name|srec_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|srec_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|srec_bfd_seclet_link
value|bfd_generic_seclet_link
end_define

begin_define
define|#
directive|define
name|srec_bfd_reloc_type_lookup
define|\
value|((CONST struct reloc_howto_struct *(*) PARAMS ((bfd *, bfd_reloc_code_real_type))) bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|srec_bfd_make_debug_symbol
define|\
value|((asymbol *(*) PARAMS ((bfd *, void *, unsigned long))) bfd_nullvoidptr)
end_define

begin_decl_stmt
name|bfd_target
name|srec_vec
init|=
block|{
literal|"srec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|srec_object_p
block|,
comment|/* bfd_check_format */
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|srec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|JUMP_TABLE
argument_list|(
argument|srec
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_target
name|symbolsrec_vec
init|=
block|{
literal|"symbolsrec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|symbolsrec_object_p
block|,
comment|/* bfd_check_format */
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|symbolsrec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|JUMP_TABLE
argument_list|(
name|srec
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

