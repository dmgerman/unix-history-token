begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1993 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  SECTION 	ELF backends  	BFD support for ELF formats is being worked on. 	Currently, the best supported back ends are for sparc and i386 	(running svr4 or Solaris 2).  	Documentation of the internals of the support code still needs 	to be written.  The code is changing quickly enough that we 	haven't bothered yet.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|0
end_define

begin_include
include|#
directive|include
file|"libelf.h"
end_include

begin_comment
comment|/* Standard ELF hash function.  Do not change this function; you will    cause invalid hash tables to be generated.  (Well, you would if this    were being used yet.)  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|DEFUN
argument_list|(
name|bfd_elf_hash
argument_list|,
operator|(
name|name
operator|)
argument_list|,
name|CONST
name|unsigned
name|char
operator|*
name|name
argument_list|)
block|{
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|g
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Read a specified number of bytes at a specified offset in an ELF    file, into a newly allocated buffer, and return a pointer to the    buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_read
argument_list|,
operator|(
name|abfd
operator|,
name|offset
operator|,
name|size
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|long
name|offset
name|AND
name|int
name|size
argument_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|elf_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
comment|/* this just does initialization */
comment|/* coff_mkobject zalloc's space for tdata.coff_obj_data ... */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* since everything is done at close time, do we need any      initialization? */
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_get_str_section
argument_list|,
operator|(
name|abfd
operator|,
name|shindex
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|int
name|shindex
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|shstrtabsize
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
literal|0
operator|||
name|i_shdrp
index|[
name|shindex
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|shstrtab
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|rawdata
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|==
name|NULL
condition|)
block|{
comment|/* No cached one, attempt to read, and cache what we read. */
name|offset
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_offset
expr_stmt|;
name|shstrtabsize
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_size
expr_stmt|;
name|shstrtab
operator|=
name|elf_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|shstrtabsize
argument_list|)
expr_stmt|;
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
name|shstrtab
expr_stmt|;
block|}
return|return
name|shstrtab
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_string_from_elf_section
argument_list|,
operator|(
name|abfd
operator|,
name|shindex
operator|,
name|strindex
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|int
name|shindex
name|AND
name|unsigned
name|int
name|strindex
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|strindex
operator|==
literal|0
condition|)
return|return
literal|""
return|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|rawdata
operator|&&
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|->
name|rawdata
operator|)
operator|+
name|strindex
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_elf_find_section  SYNOPSIS 	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);  DESCRIPTION 	Helper functions for GDB to locate the string tables. 	Since BFD hides string tables from callers, GDB needs to use an 	internal hook to find them.  Sun's .stabstr, in particular, 	isn't even pointed to by the .stab section, so ordinary 	mechanisms wouldn't work to find it, even if we had some. */
end_comment

begin_decl_stmt
name|struct
name|elf_internal_shdr
modifier|*
name|DEFUN
argument_list|(
name|bfd_elf_find_section
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|name
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|!=
name|NULL
condition|)
block|{
name|shstrtab
operator|=
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|!=
name|NULL
condition|)
block|{
name|max
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|shstrtab
index|[
name|i_shdrp
index|[
name|i
index|]
operator|->
name|sh_name
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|i_shdrp
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|bfd_elf_arch_map
name|bfd_elf_arch_map
index|[]
init|=
block|{
block|{
name|bfd_arch_sparc
block|,
name|EM_SPARC
block|}
block|,
block|{
name|bfd_arch_i386
block|,
name|EM_386
block|}
block|,
block|{
name|bfd_arch_m68k
block|,
name|EM_68K
block|}
block|,
block|{
name|bfd_arch_m88k
block|,
name|EM_88K
block|}
block|,
block|{
name|bfd_arch_i860
block|,
name|EM_860
block|}
block|,
block|{
name|bfd_arch_mips
block|,
name|EM_MIPS
block|}
block|,
block|{
name|bfd_arch_hppa
block|,
name|EM_HPPA
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|bfd_elf_arch_map_size
init|=
sizeof|sizeof
argument_list|(
name|bfd_elf_arch_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bfd_elf_arch_map
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|bfd_elf_section_type_names
index|[]
init|=
block|{
literal|"SHT_NULL"
block|,
literal|"SHT_PROGBITS"
block|,
literal|"SHT_SYMTAB"
block|,
literal|"SHT_STRTAB"
block|,
literal|"SHT_RELA"
block|,
literal|"SHT_HASH"
block|,
literal|"SHT_DYNAMIC"
block|,
literal|"SHT_NOTE"
block|,
literal|"SHT_NOBITS"
block|,
literal|"SHT_REL"
block|,
literal|"SHT_SHLIB"
block|,
literal|"SHT_DYNSYM"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ELF relocs are against symbols.  If we are producing relocateable    output, and the reloc is against an external symbol, and nothing    has given us any additional addend, the resulting reloc will also    be against the same symbol.  In such a case, we don't want to    change anything about the way the reloc is handled, since it will    all be done at final link time.  Rather than put special case code    into bfd_perform_relocation, all the reloc types use this howto    function.  It just short circuits the reloc if producing    relocateable output against an external symbol.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

end_unit

