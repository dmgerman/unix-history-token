begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD semi-generic back-end for a.out binaries.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION 	a.out backends   DESCRIPTION  	BFD supports a number of different flavours of a.out format, 	though the major differences are only the sizes of the 	structures on disk, and the shape of the relocation 	information.  	The support is split into a basic support file @code{aoutx.h} 	and other files which derive functions from the base. One 	derivation file is @code{aoutf1.h} (for a.out flavour 1), and 	adds to the basic a.out functions support for sun3, sun4, 386 	and 29k a.out files, to create a target jump vector for a 	specific target.  	This information is further split out into more specific files 	for each machine, including @code{sunos.c} for sun3 and sun4, 	@code{newsos3.c} for the Sony NEWS, and @code{demo64.c} for a 	demonstration of a 64 bit a.out format.  	The base file @code{aoutx.h} defines general mechanisms for 	reading and writing records to and from disk, and various 	other methods which BFD requires. It is included by 	@code{aout32.c} and @code{aout64.c} to form the names 	aout_32_swap_exec_header_in, aout_64_swap_exec_header_in, etc.  	As an example, this is what goes on to make the back end for a 	sun4, from aout32.c  |	#define ARCH_SIZE 32 |	#include "aoutx.h"  	Which exports names:  |	... |	aout_32_canonicalize_reloc |	aout_32_find_nearest_line |	aout_32_get_lineno |	aout_32_get_reloc_upper_bound |	...  	from sunos.c  |	#define ARCH 32 |	#define TARGET_NAME "a.out-sunos-big" |	#define VECNAME    sunos_big_vec |	#include "aoutf1.h"  	requires all the names from aout32.c, and produces the jump vector  |	sunos_big_vec  	The file host-aout.c is a special case.  It is for a large set 	of hosts that use ``more or less standard'' a.out files, and 	for which cross-debugging is not interesting.  It uses the 	standard 32-bit a.out support routines, but determines the 	file offsets and addresses of the text, data, and BSS 	sections, the machine architecture and machine type, and the 	entry point address, in a host-dependent manner.  Once these 	values have been determined, generic code is used to handle 	the  object file.  	When porting it to run on a new system, you must supply:  |        HOST_PAGE_SIZE |        HOST_SEGMENT_SIZE |        HOST_MACHINE_ARCH       (optional) |        HOST_MACHINE_MACHINE    (optional) |        HOST_TEXT_START_ADDR |        HOST_STACK_END_ADDR  	in the file<<../include/sys/h-XXX.h>> (for your host).  These 	values, plus the structures and macros defined in<<a.out.h>> on 	your host system, will produce a BFD target that will access 	ordinary a.out files on your host. To configure a new machine 	to use<<host-aout.c>., specify:  |	TDEFAULTS = -DDEFAULT_VECTOR=host_aout_big_vec |	TDEPFILES= host-aout.o trad-core.o  	in the<<config/mt-XXX>> file, and modify configure.in to use the<<mt-XXX>> file (by setting "<<bfd_target=XXX>>") when your 	configuration is selected.  */
end_comment

begin_comment
comment|/* Some assumptions:    * Any BFD with D_PAGED set is ZMAGIC, and vice versa.      Doesn't matter what the setting of WP_TEXT is on output, but it'll      get set on input.    * Any BFD with D_PAGED clear and WP_TEXT set is NMAGIC.    * Any BFD with both flags clear is OMAGIC.    (Just want to make these explicit, so the conditions tested in this    file make sense if you're more familiar with a.out than with BFD.)  */
end_comment

begin_define
define|#
directive|define
name|KEEPIT
value|flags
end_define

begin_define
define|#
directive|define
name|KEEPITTYPE
value|int
end_define

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For strchr and friends */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<sysdep.h>
end_include

begin_include
include|#
directive|include
file|<ansidecl.h>
end_include

begin_struct_decl
struct_decl|struct
name|external_exec
struct_decl|;
end_struct_decl

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|bfd_error_trap
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* SUBSECTION 	relocations  DESCRIPTION 	The file @code{aoutx.h} caters for both the @emph{standard} 	and @emph{extended} forms of a.out relocation records.  	The standard records are characterised by containing only an 	address, a symbol index and a type field. The extended records 	(used on 29ks and sparcs) also have a full integer for an 	addend.  */
end_comment

begin_define
define|#
directive|define
name|CTOR_TABLE_RELOC_IDX
value|2
end_define

begin_define
define|#
directive|define
name|howto_table_ext
value|NAME(aout,ext_howto_table)
end_define

begin_define
define|#
directive|define
name|howto_table_std
value|NAME(aout,std_howto_table)
end_define

begin_decl_stmt
name|reloc_howto_type
name|howto_table_ext
index|[]
init|=
block|{
comment|/* type           rs   size bsz  pcrel bitpos ovrf sf name    part_inpl   readmask  setmask  pcdone */
name|HOWTO
argument_list|(
name|RELOC_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_WDISP30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"WDISP30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_WDISP22
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"WDISP22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"HI22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"LO10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_SFA_BASE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"SFA_BASE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_SFA_OFF13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"SFA_OFF13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_BASE10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_BASE13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_BASE22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_PC10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"PC10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_PC22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"PC22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_JMP_TBL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"JMP_TBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_SEGOFF16
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"SEGOFF16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|RELOC_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert standard reloc records to "arelent" format (incl byte swap).  */
end_comment

begin_decl_stmt
name|reloc_howto_type
name|howto_table_std
index|[]
init|=
block|{
comment|/* type              rs size bsz  pcrel bitpos ovrf                     sf name    part_inpl  readmask  setmask     pcdone */
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"64"
argument_list|,
name|true
argument_list|,
literal|0xdeaddead
argument_list|,
literal|0xdeaddead
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP64"
argument_list|,
name|true
argument_list|,
literal|0xfeedface
argument_list|,
literal|0xfeedface
argument_list|,
name|false
argument_list|)
block|,
block|{
operator|-
literal|1
block|}
block|,
name|HOWTO
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE16"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"BASE32"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TABLE_SIZE
parameter_list|(
name|TABLE
parameter_list|)
value|(sizeof(TABLE)/sizeof(TABLE[0]))
end_define

begin_decl_stmt
name|CONST
name|struct
name|reloc_howto_struct
modifier|*
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|reloc_type_lookup
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|code
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_reloc_code_real_type
name|code
argument_list|)
block|{
define|#
directive|define
name|EXT
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return&howto_table_ext[j]
define|#
directive|define
name|STD
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return&howto_table_std[j]
name|int
name|ext
init|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|==
name|RELOC_EXT_SIZE
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_CTOR
condition|)
switch|switch
condition|(
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|bits_per_address
condition|)
block|{
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ext
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
name|EXT
argument_list|(
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_HI22
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_LO10
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|EXT
argument_list|(
name|BFD_RELOC_32_PCREL_S2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
default|default:
return|return
operator|(
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
operator|)
literal|0
return|;
block|}
else|else
comment|/* std relocs */
switch|switch
condition|(
name|code
condition|)
block|{
name|STD
argument_list|(
name|BFD_RELOC_16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_8_PCREL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_16_PCREL
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_32_PCREL
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_16_BASEREL
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|STD
argument_list|(
name|BFD_RELOC_32_BASEREL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
default|default:
return|return
operator|(
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
operator|)
literal|0
return|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_error_vector_type
name|bfd_error_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SUBSECTION 	Internal Entry Points  DESCRIPTION 	@code{aoutx.h} exports several routines for accessing the 	contents of an a.out file, which are gathered and exported in 	turn by various format specific files (eg sunos.c).  */
end_comment

begin_comment
comment|/* FUNCTION 	 aout_<size>_swap_exec_header_in  DESCRIPTION 	Swaps the information in an executable header taken from a raw 	byte stream memory image, into the internal exec_header 	structure.  SYNOPSIS 	void aout_<size>_swap_exec_header_in,            (bfd *abfd,             struct external_exec *raw_bytes,             struct internal_exec *execp); */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME_swap_exec_header_in
end_ifndef

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|raw_bytes
operator|,
name|execp
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|external_exec
operator|*
name|raw_bytes
name|AND
expr|struct
name|internal_exec
operator|*
name|execp
argument_list|)
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* The internal_exec structure has some fields that are unused in this      configuration (IE for i960), so ensure that all such uninitialized      fields are zero'd out.  There are places where two of these structs      are memcmp'd, and thus the contents do matter. */
name|memset
argument_list|(
name|execp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|NAME_swap_exec_header_in
value|NAME(aout,swap_exec_header_in)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUNCTION 	aout_<size>_swap_exec_header_out  DESCRIPTION 	Swaps the information in an internal exec header structure 	into the supplied buffer ready for writing to disk.  SYNOPSIS 	void aout_<size>_swap_exec_header_out 	  (bfd *abfd, 	   struct internal_exec *execp, 	   struct external_exec *raw_bytes); */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_out
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|execp
operator|,
name|raw_bytes
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_exec
operator|*
name|execp
name|AND
expr|struct
name|external_exec
operator|*
name|raw_bytes
argument_list|)
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* Now fill in fields in the raw data, from the fields in the exec struct. */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_info
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_text
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_data
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_bss
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_syms
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_entry
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_trsize
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_drsize
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	aout_<size>_some_aout_object_p  DESCRIPTION 	Some A.OUT variant thinks that the file whose format we're 	checking is an a.out file.  Do some more checking, and set up 	for access if it really is.  Call back to the calling 	environments "finish up" function just before returning, to 	handle any last-minute setup.  SYNOPSIS 	bfd_target *aout_<size>_some_aout_object_p 	 (bfd *abfd, 	  bfd_target *(*callback_to_real_object_p)()); */
end_comment

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|some_aout_object_p
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|execp
operator|,
name|callback_to_real_object_p
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_exec
operator|*
name|execp
name|AND
name|bfd_target
operator|*
operator|(
operator|*
name|callback_to_real_object_p
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
argument_list|)
block|{
name|struct
name|aout_data_struct
modifier|*
name|rawptr
decl_stmt|,
modifier|*
name|oldrawptr
decl_stmt|;
name|bfd_target
modifier|*
name|result
decl_stmt|;
name|rawptr
operator|=
operator|(
expr|struct
name|aout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|oldrawptr
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|rawptr
expr_stmt|;
comment|/* Copy the contents of the old tdata struct.      In particular, we want the subformat, since for hpux it was set in      hp300hpux.c:swap_exec_header_in and will be used in      hp300hpux.c:callback.  */
if|if
condition|(
name|oldrawptr
operator|!=
name|NULL
condition|)
operator|*
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
operator|*
name|oldrawptr
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
operator|*
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
operator|)
operator|=
operator|*
name|execp
expr_stmt|;
comment|/* Copy in the internal_exec struct */
name|execp
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
expr_stmt|;
comment|/* Set the file flags */
name|abfd
operator|->
name|flags
operator|=
name|NO_FLAGS
expr_stmt|;
if|if
condition|(
name|execp
operator|->
name|a_drsize
operator|||
name|execp
operator|->
name|a_trsize
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
comment|/* Setting of EXEC_P has been deferred to the bottom of this function */
if|if
condition|(
name|execp
operator|->
name|a_syms
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|ZMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
operator||
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|z_magic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|NMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|n_magic
expr_stmt|;
block|}
else|else
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|o_magic
expr_stmt|;
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_entry
expr_stmt|;
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
comment|/* The default relocation entry size is that of traditional V7 Unix.  */
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
comment|/* The default symbol entry size is that of traditional Unix. */
name|obj_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
comment|/* Create the sections.  This is raunchy, but bfd_close wants to reclaim      them.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|(void)bfd_make_section (abfd, ".text");   (void)bfd_make_section (abfd, ".data");   (void)bfd_make_section (abfd, ".bss");
endif|#
directive|endif
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|execp
operator|->
name|a_data
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|execp
operator|->
name|a_bss
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|execp
operator|->
name|a_trsize
operator|!=
literal|0
condition|?
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
else|:
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|execp
operator|->
name|a_drsize
operator|!=
literal|0
condition|?
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
else|:
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
ifdef|#
directive|ifdef
name|THIS_IS_ONLY_DOCUMENTATION
comment|/* The common code can't fill in these things because they depend      on either the start address of the text segment, the rounding      up of virtual addersses between segments, or the starting file      position of the text segment -- all of which varies among different      versions of a.out.  */
comment|/* Call back to the format-dependent code to fill in the rest of the      fields and do any further cleanup.  Things that should be filled      in by the callback:  */
name|struct
name|exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
name|N_TXTSIZE
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_size
operator|=
name|N_TXTSIZE
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* data and bss are already filled in since they're so standard */
comment|/* The virtual memory addresses of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_TXTADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_DATADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|N_BSSADDR
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_TXTOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_DATOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the relocation info */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_TRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_DRELOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file offsets of the string table and symbol table.  */
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_STROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* Determine the architecture and machine type of the object file.  */
switch|switch
condition|(
name|N_MACHTYPE
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
block|{
default|default:
name|abfd
operator|->
name|obj_arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
break|break;
block|}
name|adata
argument_list|(
name|abfd
argument_list|)
operator|->
name|page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_size
operator|=
name|SEGMENT_SIZE
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
comment|/* The architecture is encoded in various ways in various a.out variants,      or is not encoded at all in some of them.  The relocation size depends      on the architecture and the a.out variant.  Finally, the return value      is the bfd_target vector in use.  If an error occurs, return zero and      set bfd_error to the appropriate error code.       Formats such as b.out, which have additional fields in the a.out      header, should cope with them in this callback as well.  */
endif|#
directive|endif
comment|/* DOCUMENTATION */
name|result
operator|=
call|(
modifier|*
name|callback_to_real_object_p
call|)
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now that the segment addresses have been worked out, take a better      guess at whether the file is executable.  If the entry point      is within the text segment, assume it is.  (This makes files      executable even if their entry point address is 0, as long as      their text starts at zero.)       At some point we should probably break down and stat the file and      declare it executable if (one of) its 'x' bits are on...  */
if|if
condition|(
operator|(
name|execp
operator|->
name|a_entry
operator|>=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|)
operator|&&
operator|(
name|execp
operator|->
name|a_entry
operator|<
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
if|#
directive|if
literal|0
comment|/* These should be set correctly anyways.  */
block|abfd->sections = obj_textsec (abfd);       obj_textsec (abfd)->next = obj_datasec (abfd);       obj_datasec (abfd)->next = obj_bsssec (abfd);
endif|#
directive|endif
block|}
else|else
block|{
name|free
argument_list|(
name|rawptr
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|oldrawptr
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	aout_<size>_mkobject  DESCRIPTION 	This routine initializes a BFD for use with a.out files.  SYNOPSIS 	boolean aout_<size>_mkobject, (bfd *); */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|mkobject
argument_list|)
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|aout_data_struct
modifier|*
name|rawptr
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* Use an intermediate variable for clarity */
name|rawptr
operator|=
operator|(
expr|struct
name|aout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aout_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|rawptr
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
operator|(
name|rawptr
operator|->
name|e
operator|)
expr_stmt|;
comment|/* For simplicity's sake we just make all the sections right here. */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|BFD_ABS_SECTION_NAME
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|BFD_UND_SECTION_NAME
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|BFD_COM_SECTION_NAME
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	aout_<size>_machine_type  DESCRIPTION 	Keep track of machine architecture and machine type for 	a.out's. Return the machine_type for a particular 	arch&machine, or M_UNKNOWN if that exact arch&machine can't be 	represented in a.out format.  	If the architecture is understood, machine type 0 (default) 	should always be understood.  SYNOPSIS 	enum machine_type  aout_<size>_machine_type 	 (enum bfd_architecture arch, 	  unsigned long machine)); */
end_comment

begin_decl_stmt
name|enum
name|machine_type
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|machine_type
argument_list|)
argument_list|,
operator|(
name|arch
operator|,
name|machine
operator|)
argument_list|,
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
name|enum
name|machine_type
name|arch_flags
decl_stmt|;
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|arch_flags
operator|=
name|M_SPARC
expr_stmt|;
break|break;
case|case
name|bfd_arch_m68k
case|:
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
name|arch_flags
operator|=
name|M_68010
expr_stmt|;
break|break;
case|case
literal|68000
case|:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
break|break;
case|case
literal|68010
case|:
name|arch_flags
operator|=
name|M_68010
expr_stmt|;
break|break;
case|case
literal|68020
case|:
name|arch_flags
operator|=
name|M_68020
expr_stmt|;
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_i386
case|:
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|arch_flags
operator|=
name|M_386
expr_stmt|;
break|break;
case|case
name|bfd_arch_a29k
case|:
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|arch_flags
operator|=
name|M_29K
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2000
case|:
case|case
literal|3000
case|:
name|arch_flags
operator|=
name|M_MIPS1
expr_stmt|;
break|break;
case|case
literal|4000
case|:
case|case
literal|4400
case|:
case|case
literal|6000
case|:
name|arch_flags
operator|=
name|M_MIPS2
expr_stmt|;
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|arch_flags
operator|=
name|M_UNKNOWN
expr_stmt|;
block|}
return|return
name|arch_flags
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	aout_<size>_set_arch_mach  DESCRIPTION 	Sets the architecture and the machine of the BFD to those 	values supplied. Verifies that the format can support the 	architecture required.  SYNOPSIS 	boolean aout_<size>_set_arch_mach, 	 (bfd *, 	  enum bfd_architecture, 	  unsigned long machine)); */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|set_arch_mach
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|NAME
argument_list|(
name|aout
argument_list|,
name|machine_type
argument_list|)
argument_list|(
name|arch
argument_list|,
name|machine
argument_list|)
operator|==
name|M_UNKNOWN
condition|)
return|return
name|false
return|;
comment|/* We can't represent this type */
comment|/* Determine the size of a relocation entry */
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
case|case
name|bfd_arch_a29k
case|:
case|case
name|bfd_arch_mips
case|:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_EXT_SIZE
expr_stmt|;
break|break;
default|default:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|*
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|set_sizes
operator|)
operator|(
name|abfd
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|adjust_sizes_and_vmas
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|text_size
operator|,
name|text_end
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_size_type
operator|*
name|text_size
name|AND
name|file_ptr
operator|*
name|text_end
argument_list|)
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|!=
name|undecided_magic
condition|)
return|return
name|true
return|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|align_power
argument_list|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
operator|*
name|text_size
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
comment|/* Rule (heuristic) for when to pad to a new page.  Note that there    * are (at least) two ways demand-paged (ZMAGIC) files have been    * handled.  Most Berkeley-based systems start the text segment at    * (PAGE_SIZE).  However, newer versions of SUNOS start the text    * segment right after the exec header; the latter is counted in the    * text segment size, and is paged in by the kernel with the rest of    * the text. */
comment|/* This perhaps isn't the right way to do this, but made it simpler for me      to understand enough to implement it.  Better would probably be to go      right from BFD flags to alignment/positioning characteristics.  But the      old code was sloppy enough about handling the flags, and had enough      other magic, that it was a little hard for me to understand.  I think      I understand it better now, but I haven't time to do the cleanup this      minute.  */
if|if
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|==
name|undecided_magic
condition|)
block|{
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
condition|)
comment|/* Whether or not WP_TEXT is set -- let D_PAGED override.  */
comment|/* @@ What about QMAGIC?  */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|z_magic
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
condition|)
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|n_magic
expr_stmt|;
else|else
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|o_magic
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD_AOUT_DEBUG
comment|/* requires gcc2 */
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|fprintf
argument_list|(
argument|stderr
argument_list|,
literal|"%s text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x,%x>\n"
argument_list|,
argument|({ char *str; 	      switch (adata(abfd).magic) { 	      case n_magic: str =
literal|"NMAGIC"
argument|; break; 	      case o_magic: str =
literal|"OMAGIC"
argument|; break; 	      case z_magic: str =
literal|"ZMAGIC"
argument|; break; 	      default: abort (); 	      } 	      str; 	    })
argument_list|,
argument|obj_textsec(abfd)->vma
argument_list|,
argument|obj_textsec(abfd)->_raw_size
argument_list|,
argument|obj_textsec(abfd)->alignment_power
argument_list|,
argument|obj_datasec(abfd)->vma
argument_list|,
argument|obj_datasec(abfd)->_raw_size
argument_list|,
argument|obj_datasec(abfd)->alignment_power
argument_list|,
argument|obj_bsssec(abfd)->vma
argument_list|,
argument|obj_bsssec(abfd)->_raw_size
argument_list|,
argument|obj_bsssec(abfd)->alignment_power
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
condition|)
block|{
case|case
name|o_magic
case|:
block|{
name|file_ptr
name|pos
init|=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
decl_stmt|;
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|vma
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|!
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
if|#
directive|if
literal|0
comment|/* ?? Does alignment in the file image really matter? */
block|pad = align_power (vma, obj_datasec(abfd)->alignment_power) - vma;
endif|#
directive|endif
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|pad
expr_stmt|;
name|vma
operator|+=
name|pad
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
block|}
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|vma
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|!
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
if|#
directive|if
literal|0
block|pad = align_power (vma, obj_bsssec(abfd)->alignment_power) - vma;
endif|#
directive|endif
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|pad
expr_stmt|;
name|vma
operator|+=
name|pad
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
block|}
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|OMAGIC
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|z_magic
case|:
block|{
name|bfd_size_type
name|data_pad
decl_stmt|,
name|text_pad
decl_stmt|;
name|file_ptr
name|text_end
decl_stmt|;
name|CONST
name|struct
name|aout_backend_data
modifier|*
name|abdp
decl_stmt|;
name|int
name|ztih
decl_stmt|;
name|bfd_vma
name|data_vma
decl_stmt|;
name|abdp
operator|=
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ztih
operator|=
name|abdp
operator|&&
name|abdp
operator|->
name|text_includes_header
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|ztih
condition|?
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
else|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
comment|/* ?? Do we really need to check for relocs here?  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
condition|?
literal|0
else|:
operator|(
name|ztih
condition|?
operator|(
name|abdp
operator|->
name|default_text_vma
operator|+
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|)
else|:
name|abdp
operator|->
name|default_text_vma
operator|)
operator|)
expr_stmt|;
comment|/* Could take strange alignment of text section into account here?  */
comment|/* Find start of data.  */
name|text_end
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|text_pad
operator|=
name|BFD_ALIGN
argument_list|(
name|text_end
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
argument_list|)
operator|-
name|text_end
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|text_pad
expr_stmt|;
name|text_end
operator|+=
name|text_pad
expr_stmt|;
if|if
condition|(
operator|!
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|vma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|BFD_ALIGN
argument_list|(
name|vma
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
argument_list|)
expr_stmt|;
block|}
name|data_vma
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|abdp
operator|&&
name|abdp
operator|->
name|zmagic_mapped_contiguous
condition|)
block|{
name|text_pad
operator|=
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|text_pad
expr_stmt|;
block|}
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
expr_stmt|;
comment|/* Fix up exec header while we're at it.  */
name|execp
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|ztih
operator|&&
operator|(
operator|!
name|abdp
operator|||
operator|(
name|abdp
operator|&&
operator|!
name|abdp
operator|->
name|exec_header_not_counted
operator|)
operator|)
condition|)
name|execp
operator|->
name|a_text
operator|+=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
expr_stmt|;
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|ZMAGIC
argument_list|)
expr_stmt|;
comment|/* Spec says data section should be rounded up to page boundary.  */
comment|/* If extra space in page is left after data section, fudge data 	   in the header so that the bss section looks smaller by that 	   amount.  We'll start the bss section there, and lie to the OS.  */
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|align_power
argument_list|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|BFD_ALIGN
argument_list|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
argument_list|)
expr_stmt|;
name|data_pad
operator|=
name|execp
operator|->
name|a_data
operator|-
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|!
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|)
expr_stmt|;
if|if
condition|(
name|data_pad
operator|>
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
condition|)
name|execp
operator|->
name|a_bss
operator|=
literal|0
expr_stmt|;
else|else
name|execp
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|-
name|data_pad
expr_stmt|;
block|}
break|break;
case|case
name|n_magic
case|:
block|{
name|file_ptr
name|pos
init|=
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
decl_stmt|;
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
else|else
name|vma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|pos
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|vma
operator|+=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|BFD_ALIGN
argument_list|(
name|vma
argument_list|,
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
argument_list|)
expr_stmt|;
name|vma
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
comment|/* Since BSS follows data immediately, see if it needs alignment.  */
name|vma
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|pad
operator|=
name|align_power
argument_list|(
name|vma
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
argument_list|)
operator|-
name|vma
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|+=
name|pad
expr_stmt|;
name|pos
operator|+=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|!
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_set_vma
condition|)
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
else|else
name|vma
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
block|}
name|execp
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|N_SET_MAGIC
argument_list|(
operator|*
name|execp
argument_list|,
name|NMAGIC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD_AOUT_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x>\n"
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
argument_list|,
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	aout_<size>_new_section_hook  DESCRIPTION 	Called by the BFD in response to a @code{bfd_make_section} 	request.  SYNOPSIS         boolean aout_<size>_new_section_hook, 	   (bfd *abfd, 	    asection *newsect)); */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|new_section_hook
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|newsect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|newsect
argument_list|)
block|{
comment|/* align to double at least */
name|newsect
operator|->
name|alignment_power
operator|=
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|section_align_power
expr_stmt|;
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
block|{
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|target_index
operator|=
name|N_TEXT
operator||
name|N_EXT
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|target_index
operator|=
name|N_DATA
operator||
name|N_EXT
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
condition|)
block|{
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|target_index
operator|=
name|N_BSS
operator||
name|N_EXT
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* We allow more than three sections internally */
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|set_section_contents
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
name|file_ptr
name|text_end
decl_stmt|;
name|bfd_size_type
name|text_size
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|adjust_sizes_and_vmas
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|text_size
argument_list|,
operator|&
name|text_end
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
comment|/* regardless, once we know what we're doing, we might as well get going */
if|if
condition|(
name|section
operator|!=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
return|return
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
return|return
name|true
return|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Classify stabs symbols */
end_comment

begin_define
define|#
directive|define
name|sym_in_text_section
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& (N_ABS | N_TEXT | N_DATA | N_BSS))== N_TEXT)
end_define

begin_define
define|#
directive|define
name|sym_in_data_section
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& (N_ABS | N_TEXT | N_DATA | N_BSS))== N_DATA)
end_define

begin_define
define|#
directive|define
name|sym_in_bss_section
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& (N_ABS | N_TEXT | N_DATA | N_BSS))== N_BSS)
end_define

begin_comment
comment|/* Symbol is undefined if type is N_UNDF|N_EXT and if it has   zero in the "value" field.  Nonzeroes there are fortrancommon   symbols.  */
end_comment

begin_define
define|#
directive|define
name|sym_is_undefined
parameter_list|(
name|sym
parameter_list|)
define|\
value|((sym)->type == (N_UNDF | N_EXT)&& (sym)->symbol.value == 0)
end_define

begin_comment
comment|/* Symbol is a global definition if N_EXT is on and if it has   a nonzero type field.  */
end_comment

begin_define
define|#
directive|define
name|sym_is_global_defn
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& N_EXT)&& (sym)->type& N_TYPE)
end_define

begin_comment
comment|/* Symbol is debugger info if any bits outside N_TYPE or N_EXT   are on.  */
end_comment

begin_define
define|#
directive|define
name|sym_is_debugger_info
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& ~(N_EXT | N_TYPE)) || (sym)->type == N_FN)
end_define

begin_define
define|#
directive|define
name|sym_is_fortrancommon
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type == (N_EXT))&& (sym)->symbol.value != 0)
end_define

begin_comment
comment|/* Symbol is absolute if it has N_ABS set */
end_comment

begin_define
define|#
directive|define
name|sym_is_absolute
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& N_TYPE)== N_ABS)
end_define

begin_define
define|#
directive|define
name|sym_is_indirect
parameter_list|(
name|sym
parameter_list|)
define|\
value|(((sym)->type& N_ABS)== N_ABS)
end_define

begin_comment
comment|/* Only in their own functions for ease of debugging; when sym flags have   stabilised these should be inlined into their (single) caller */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|translate_from_native_sym_flags
argument_list|,
operator|(
name|sym_pointer
operator|,
name|cache_ptr
operator|,
name|abfd
operator|)
argument_list|,
expr|struct
name|external_nlist
operator|*
name|sym_pointer
name|AND
name|aout_symbol_type
operator|*
name|cache_ptr
name|AND
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_SETA
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETB
case|:
block|{
name|char
modifier|*
name|copy
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|cache_ptr
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
name|into_section
decl_stmt|;
name|arelent_chain
modifier|*
name|reloc
init|=
operator|(
name|arelent_chain
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent_chain
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|cache_ptr
operator|->
name|symbol
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Make sure that this bfd has a section with the right contructor 	   name */
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|copy
argument_list|)
expr_stmt|;
comment|/* Build a relocation entry for the constructor */
switch|switch
condition|(
operator|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_TYPE
operator|)
condition|)
block|{
case|case
name|N_SETA
case|:
name|into_section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
name|cache_ptr
operator|->
name|type
operator|=
name|N_ABS
expr_stmt|;
break|break;
case|case
name|N_SETT
case|:
name|into_section
operator|=
operator|(
name|asection
operator|*
operator|)
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|type
operator|=
name|N_TEXT
expr_stmt|;
break|break;
case|case
name|N_SETD
case|:
name|into_section
operator|=
operator|(
name|asection
operator|*
operator|)
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|type
operator|=
name|N_DATA
expr_stmt|;
break|break;
case|case
name|N_SETB
case|:
name|into_section
operator|=
operator|(
name|asection
operator|*
operator|)
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|type
operator|=
name|N_BSS
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Build a relocation pointing into the constuctor section 	   pointing at the symbol in the set vector specified */
name|reloc
operator|->
name|relent
operator|.
name|addend
operator|=
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|into_section
operator|->
name|symbol
operator|->
name|section
expr_stmt|;
name|reloc
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|into_section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
comment|/* We modify the symbol to belong to a section depending upon the 	   name of the symbol - probably __CTOR__ or __DTOR__ but we don't 	   really care, and add to the size of the section to contain a 	   pointer to the symbol. Build a reloc entry to relocate to this 	   symbol attached to this section.  */
name|section
operator|->
name|flags
operator|=
name|SEC_CONSTRUCTOR
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|reloc
operator|->
name|next
operator|=
name|section
operator|->
name|constructor_chain
expr_stmt|;
name|section
operator|->
name|constructor_chain
operator|=
name|reloc
expr_stmt|;
name|reloc
operator|->
name|relent
operator|.
name|address
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|relent
operator|.
name|howto
operator|=
operator|(
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|==
name|RELOC_EXT_SIZE
condition|?
name|howto_table_ext
else|:
name|howto_table_std
operator|)
operator|+
name|CTOR_TABLE_RELOC_IDX
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|cache_ptr
operator|->
name|type
operator|==
name|N_WARNING
condition|)
block|{
comment|/* This symbol is the text of a warning message, the next symbol 	     is the symbol to associate the warning with */
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
operator||
name|BSF_WARNING
expr_stmt|;
comment|/* @@ Stuffing pointers into integers is a no-no. 	     We can usually get away with it if the integer is 	     large enough though.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cache_ptr
operator|+
literal|1
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|cache_ptr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* We furgle with the next symbol in place. 	     We don't want it to be undefined, we'll trample the type */
operator|(
name|sym_pointer
operator|+
literal|1
operator|)
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|cache_ptr
operator|->
name|type
operator||
name|N_EXT
operator|)
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* Two symbols in a row for an INDR message. The first symbol 	     contains the name we will match, the second symbol contains 	     the name the first name is translated into. It is supplied to 	     us undefined. This is good, since we want to pull in any files 	     which define it */
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
operator||
name|BSF_INDIRECT
expr_stmt|;
comment|/* @@ Stuffing pointers into integers is a no-no. 	     We can usually get away with it if the integer is 	     large enough though.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cache_ptr
operator|+
literal|1
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|cache_ptr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_ind_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_is_debugger_info
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* Work out the section correct for this symbol */
switch|switch
condition|(
name|cache_ptr
operator|->
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_FN
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
default|default:
case|case
name|N_ABS
case|:
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sym_is_fortrancommon
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_com_section
expr_stmt|;
block|}
else|else
block|{   	    }
comment|/* In a.out, the value of a symbol is always relative to the 	   * start of the file, if this is a data symbol we'll subtract 	   * the size of the text section to get the section relative 	   * value. If this is a bss symbol (which would be strange) 	   * we'll subtract the size of the previous two sections 	   * to find the section relative address. 	   */
if|if
condition|(
name|sym_in_text_section
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_in_data_section
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_in_bss_section
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|-=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_is_undefined
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_is_absolute
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
block|}
if|if
condition|(
name|sym_is_global_defn
argument_list|(
name|cache_ptr
argument_list|)
condition|)
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cache_ptr
operator|->
name|symbol
operator|.
name|section
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|translate_to_native_sym_flags
argument_list|,
operator|(
name|sym_pointer
operator|,
name|cache_ptr
operator|,
name|abfd
operator|)
argument_list|,
expr|struct
name|external_nlist
operator|*
name|sym_pointer
name|AND
name|asymbol
operator|*
name|cache_ptr
name|AND
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|bfd_vma
name|value
init|=
name|cache_ptr
operator|->
name|value
decl_stmt|;
comment|/* mask out any existing type bits in case copying from one section      to another */
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|&=
operator|~
name|N_TYPE
expr_stmt|;
comment|/* We attempt to order these tests by decreasing frequency of success,      according to tcov when linking the linker.  */
if|if
condition|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|==
operator|&
name|bfd_abs_section
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_BSS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|==
operator|&
name|bfd_ind_section
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|N_INDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
argument_list|)
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cache_ptr
operator|->
name|section
operator|->
name|output_section
condition|)
block|{
name|bfd_error_vector
operator|.
name|nonrepresentable_section
argument_list|(
name|abfd
argument_list|,
name|bfd_get_output_section
argument_list|(
name|cache_ptr
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_error_vector
operator|.
name|nonrepresentable_section
argument_list|(
name|abfd
argument_list|,
name|cache_ptr
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Turn the symbol from section relative to absolute again */
name|value
operator|+=
name|cache_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|cache_ptr
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|cache_ptr
operator|->
name|flags
operator|&
operator|(
name|BSF_WARNING
operator|)
condition|)
block|{
operator|(
name|sym_pointer
operator|+
literal|1
operator|)
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|aout_symbol_type
operator|*
operator|)
name|cache_ptr
operator|)
operator|->
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache_ptr
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
condition|)
block|{
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator||=
name|N_EXT
expr_stmt|;
block|}
if|if
condition|(
name|cache_ptr
operator|->
name|flags
operator|&
name|BSF_CONSTRUCTOR
condition|)
block|{
name|int
name|type
init|=
operator|(
operator|(
name|aout_symbol_type
operator|*
operator|)
name|cache_ptr
operator|)
operator|->
name|type
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_ABS
case|:
name|type
operator|=
name|N_SETA
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|type
operator|=
name|N_SETT
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|type
operator|=
name|N_SETD
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|type
operator|=
name|N_SETB
expr_stmt|;
break|break;
block|}
name|sym_pointer
operator|->
name|e_type
index|[
literal|0
index|]
operator|=
name|type
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|sym_pointer
operator|->
name|e_value
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Native-level interface to symbols. */
end_comment

begin_comment
comment|/* We read the symbols into a buffer, which is discarded when this function exits.  We read the strings into a buffer large enough to hold them all plus all the cached symbol entries. */
end_comment

begin_decl_stmt
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|make_empty_symbol
argument_list|)
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|aout_symbol_type
modifier|*
name|new
init|=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_symbol_table
argument_list|)
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|bfd_size_type
name|symbol_size
decl_stmt|;
name|bfd_size_type
name|string_size
decl_stmt|;
name|unsigned
name|char
name|string_chars
index|[
name|BYTES_IN_WORD
index|]
decl_stmt|;
name|struct
name|external_nlist
modifier|*
name|syms
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|aout_symbol_type
modifier|*
name|cached
decl_stmt|;
comment|/* If there's no work to be done, don't do any */
if|if
condition|(
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|NULL
condition|)
return|return
name|true
return|;
name|symbol_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
expr_stmt|;
if|if
condition|(
name|symbol_size
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_symbols
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|string_chars
argument_list|,
name|BYTES_IN_WORD
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|BYTES_IN_WORD
condition|)
return|return
name|false
return|;
name|string_size
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|string_chars
argument_list|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|string_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cached
operator|=
operator|(
name|aout_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|aout_symbol_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* malloc this, so we can free it if simply. The symbol caching      might want to allocate onto the bfd's obstack  */
name|syms
operator|=
operator|(
expr|struct
name|external_nlist
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
name|symbol_size
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|syms
argument_list|,
literal|1
argument_list|,
name|symbol_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symbol_size
condition|)
block|{
name|bailout
label|:
if|if
condition|(
name|syms
condition|)
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|cached
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|strings
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|strings
argument_list|,
literal|1
argument_list|,
name|string_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|string_size
condition|)
block|{
goto|goto
name|bailout
goto|;
block|}
name|strings
index|[
name|string_size
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Just in case. */
comment|/* OK, now walk the new symtable, cacheing symbol properties */
block|{
specifier|register
name|struct
name|external_nlist
modifier|*
name|sym_pointer
decl_stmt|;
specifier|register
name|struct
name|external_nlist
modifier|*
name|sym_end
init|=
name|syms
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|register
name|aout_symbol_type
modifier|*
name|cache_ptr
init|=
name|cached
decl_stmt|;
comment|/* Run through table and copy values */
for|for
control|(
name|sym_pointer
operator|=
name|syms
operator|,
name|cache_ptr
operator|=
name|cached
init|;
name|sym_pointer
operator|<
name|sym_end
condition|;
name|sym_pointer
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|long
name|x
init|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_strx
argument_list|)
decl_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|cache_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<
name|string_size
condition|)
name|cache_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
name|x
operator|+
name|strings
expr_stmt|;
else|else
goto|goto
name|bailout
goto|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|value
operator|=
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|desc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_desc
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_other
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|sym_pointer
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|symbol
operator|.
name|udata
operator|=
literal|0
expr_stmt|;
name|translate_from_native_sym_flags
argument_list|(
name|sym_pointer
argument_list|,
name|cache_ptr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|cached
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|syms
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Possible improvements:    + look for strings matching trailing substrings of other strings    + better data structures?  balanced trees?    + smaller per-string or per-symbol data?  re-use some of the symbol's      data fields?    + also look at reducing memory use elsewhere -- maybe if we didn't have to      construct the entire symbol table at once, we could get by with smaller      amounts of VM?  (What effect does that have on the string table      reductions?)    + rip this out of here, put it into its own file in bfd or libiberty, so      coff and elf can use it too.  I'll work on this soon, but have more      pressing tasks right now.     A hash table might(?) be more efficient for handling exactly the cases that    are handled now, but for trailing substring matches, I think we want to    examine the `nearest' values (reverse-)lexically, not merely impose a strict    order, nor look only for exact-match or not-match.  I don't think a hash    table would be very useful for that, and I don't feel like fleshing out two    completely different implementations.  [raeburn:930419.0331EDT] */
end_comment

begin_struct
struct|struct
name|stringtab_entry
block|{
comment|/* Hash value for this string.  Only useful so long as we aren't doing      substring matches.  */
name|unsigned
name|int
name|hash
decl_stmt|;
comment|/* Next node to look at, depending on whether the hash value of the string      being searched for is less than or greater than the hash value of the      current node.  For now, `equal to' is lumped in with `greater than', for      space efficiency.  It's not a common enough case to warrant another field      to be used for all nodes.  */
name|struct
name|stringtab_entry
modifier|*
name|less
decl_stmt|;
name|struct
name|stringtab_entry
modifier|*
name|greater
decl_stmt|;
comment|/* The string itself.  */
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The index allocated for this string.  */
name|bfd_size_type
name|index
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* How many references have there been to this string?  (Not currently used;      could be dumped out for anaylsis, if anyone's interested.)  */
name|unsigned
name|long
name|count
decl_stmt|;
endif|#
directive|endif
comment|/* Next node in linked list, in suggested output order.  */
name|struct
name|stringtab_entry
modifier|*
name|next_to_output
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stringtab_data
block|{
comment|/* Tree of string table entries.  */
name|struct
name|stringtab_entry
modifier|*
name|strings
decl_stmt|;
comment|/* Fudge factor used to center top node of tree.  */
name|int
name|hash_zero
decl_stmt|;
comment|/* Next index value to issue.  */
name|bfd_size_type
name|index
decl_stmt|;
comment|/* Index used for empty strings.  Cached here because checking for them      is really easy, and we can avoid searching the tree.  */
name|bfd_size_type
name|empty_string_index
decl_stmt|;
comment|/* These fields indicate the two ends of a singly-linked list that indicates      the order strings should be written out in.  Use this order, and no      seeking will need to be done, so output efficiency should be maximized. */
name|struct
name|stringtab_entry
modifier|*
modifier|*
name|end
decl_stmt|;
name|struct
name|stringtab_entry
modifier|*
name|output_order
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* Number of strings which duplicate strings already in the table.  */
name|unsigned
name|long
name|duplicates
decl_stmt|;
comment|/* Number of bytes saved by not having to write all the duplicate strings. */
name|unsigned
name|long
name|bytes_saved
decl_stmt|;
comment|/* Number of zero-length strings.  Currently, these all turn into      references to the null byte at the end of the first string.  In some      cases (possibly not all?  explore this...), it should be possible to      simply write out a zero index value.  */
name|unsigned
name|long
name|empty_strings
decl_stmt|;
comment|/* Number of times the hash values matched but the strings were different.      Note that this includes the number of times the other string(s) occurs, so      there may only be two strings hashing to the same value, even if this      number is very large.  */
name|unsigned
name|long
name|bad_hash_matches
decl_stmt|;
comment|/* Null strings aren't counted in this one.      This will probably only be nonzero if we've got an input file      which was produced by `ld -r' (i.e., it's already been processed      through this code).  Under some operating systems, native tools      may make all empty strings have the same index; but the pointer      check won't catch those, because to get to that stage we'd already      have to compute the checksum, which requires reading the string,      so we short-circuit that case with empty_string_index above.  */
name|unsigned
name|long
name|pointer_matches
decl_stmt|;
comment|/* Number of comparisons done.  I figure with the algorithms in use below,      the average number of comparisons done (per symbol) should be roughly      log-base-2 of the number of unique strings.  */
name|unsigned
name|long
name|n_compares
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Some utility functions for the string table code.  */
end_comment

begin_comment
comment|/* For speed, only hash on the first this many bytes of strings.    This number was chosen by profiling ld linking itself, with -g.  */
end_comment

begin_define
define|#
directive|define
name|HASHMAXLEN
value|25
end_define

begin_define
define|#
directive|define
name|HASH_CHAR
parameter_list|(
name|c
parameter_list|)
value|(sum ^= sum>> 20, sum ^= sum<< 7, sum += (c))
end_define

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|hash
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|unsigned
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|sum
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|HASHMAXLEN
condition|)
block|{
name|HASH_CHAR
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|HASHMAXLEN
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|HASH_CHAR
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|stringtab_init
parameter_list|(
name|tab
parameter_list|)
name|struct
name|stringtab_data
modifier|*
name|tab
decl_stmt|;
block|{
name|tab
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|output_order
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|end
operator|=
operator|&
name|tab
operator|->
name|output_order
expr_stmt|;
comment|/* Initial string table length includes size of length field.  */
name|tab
operator|->
name|index
operator|=
name|BYTES_IN_WORD
expr_stmt|;
name|tab
operator|->
name|empty_string_index
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tab
operator|->
name|duplicates
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|empty_strings
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|bad_hash_matches
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|pointer_matches
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|bytes_saved
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|n_compares
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|compare
parameter_list|(
name|entry
parameter_list|,
name|str
parameter_list|,
name|hash
parameter_list|)
name|struct
name|stringtab_entry
modifier|*
name|entry
decl_stmt|;
name|CONST
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
block|{
return|return
name|hash
operator|-
name|entry
operator|->
name|hash
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* Don't want to have to link in math library with all bfd applications...  */
end_comment

begin_function
specifier|static
name|INLINE
name|double
name|log2
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|double
name|d
init|=
name|num
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|d
operator|>=
literal|2.0
condition|)
name|n
operator|++
operator|,
name|d
operator|/=
literal|2.0
expr_stmt|;
return|return
operator|(
operator|(
name|d
operator|>
literal|1.41
operator|)
condition|?
literal|0.5
else|:
literal|0
operator|)
operator|+
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Main string table routines.  */
end_comment

begin_comment
comment|/* Returns index in string table.  Whether or not this actually adds an    entry into the string table should be irrelevant -- it just has to    return a valid index.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|add_to_stringtab
parameter_list|(
name|abfd
parameter_list|,
name|str
parameter_list|,
name|tab
parameter_list|,
name|check
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|stringtab_data
modifier|*
name|tab
decl_stmt|;
name|int
name|check
decl_stmt|;
block|{
name|struct
name|stringtab_entry
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|stringtab_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|hashval
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|bfd_size_type
name|index
decl_stmt|;
name|CONST
name|bfd_size_type
name|minus_one
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tab
operator|->
name|empty_strings
operator|++
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|tab
operator|->
name|empty_string_index
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|minus_one
condition|)
block|{
name|got_empty
label|:
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tab
operator|->
name|bytes_saved
operator|++
expr_stmt|;
name|tab
operator|->
name|duplicates
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|index
return|;
block|}
comment|/* Need to find it.  */
name|entry
operator|=
name|tab
operator|->
name|strings
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|index
operator|=
name|entry
operator|->
name|index
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|string
argument_list|)
expr_stmt|;
name|tab
operator|->
name|empty_string_index
operator|=
name|index
expr_stmt|;
goto|goto
name|got_empty
goto|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* The hash_zero value is chosen such that the first symbol gets a value of      zero.  With a balanced tree, this wouldn't be very useful, but without it,      we might get a more even split at the top level, instead of skewing it      badly should hash("/usr/lib/crt0.o") (or whatever) be far from zero. */
name|hashval
operator|=
name|hash
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
operator|^
name|tab
operator|->
name|hash_zero
expr_stmt|;
name|ep
operator|=
operator|&
name|tab
operator|->
name|strings
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ep
condition|)
block|{
name|tab
operator|->
name|hash_zero
operator|=
name|hashval
expr_stmt|;
name|hashval
operator|=
literal|0
expr_stmt|;
goto|goto
name|add_it
goto|;
block|}
while|while
condition|(
operator|*
name|ep
condition|)
block|{
specifier|register
name|int
name|cmp
decl_stmt|;
name|entry
operator|=
operator|*
name|ep
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tab
operator|->
name|n_compares
operator|++
expr_stmt|;
endif|#
directive|endif
name|cmp
operator|=
name|compare
argument_list|(
name|entry
argument_list|,
name|str
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
comment|/* The not-equal cases are more frequent, so check them first.  */
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|ep
operator|=
operator|&
name|entry
operator|->
name|greater
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|ep
operator|=
operator|&
name|entry
operator|->
name|less
expr_stmt|;
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|string
operator|==
name|str
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tab
operator|->
name|pointer_matches
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|match
goto|;
block|}
comment|/* Compare the first bytes to save a function call if they 	     don't match.  */
if|if
condition|(
name|entry
operator|->
name|string
index|[
literal|0
index|]
operator|==
name|str
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|entry
operator|->
name|string
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|match
label|:
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|entry
operator|->
name|count
operator|++
expr_stmt|;
name|tab
operator|->
name|bytes_saved
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|tab
operator|->
name|duplicates
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* If we're in the linker, and the new string is from a new 		 input file which might have already had these reductions 		 run over it, we want to keep the new string pointer.  I 		 don't think we're likely to see any (or nearly as many, 		 at least) cases where a later string is in the same location 		 as an earlier one rather than this one.  */
name|entry
operator|->
name|string
operator|=
name|str
expr_stmt|;
return|return
name|entry
operator|->
name|index
return|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tab
operator|->
name|bad_hash_matches
operator|++
expr_stmt|;
endif|#
directive|endif
name|ep
operator|=
operator|&
name|entry
operator|->
name|greater
expr_stmt|;
block|}
block|}
comment|/* If we get here, nothing that's in the table already matched.      EP points to the `next' field at the end of the chain; stick a      new entry on here.  */
name|add_it
label|:
name|entry
operator|=
operator|(
expr|struct
name|stringtab_entry
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stringtab_entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|less
operator|=
name|entry
operator|->
name|greater
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|hash
operator|=
name|hashval
expr_stmt|;
name|entry
operator|->
name|index
operator|=
name|tab
operator|->
name|index
expr_stmt|;
name|entry
operator|->
name|string
operator|=
name|str
expr_stmt|;
name|entry
operator|->
name|next_to_output
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|entry
operator|->
name|count
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
operator|*
name|tab
operator|->
name|end
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tab
operator|->
name|end
operator|)
operator|=
name|entry
expr_stmt|;
name|tab
operator|->
name|end
operator|=
operator|&
name|entry
operator|->
name|next_to_output
expr_stmt|;
name|assert
argument_list|(
operator|*
name|tab
operator|->
name|end
operator|==
literal|0
argument_list|)
expr_stmt|;
block|{
name|tab
operator|->
name|index
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|tab
operator|->
name|empty_string_index
operator|=
name|entry
operator|->
name|index
expr_stmt|;
block|}
name|assert
argument_list|(
operator|*
name|ep
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
name|entry
expr_stmt|;
return|return
name|entry
operator|->
name|index
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_strtab
parameter_list|(
name|abfd
parameter_list|,
name|tab
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stringtab_data
modifier|*
name|tab
decl_stmt|;
block|{
name|struct
name|stringtab_entry
modifier|*
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|int
name|count
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* Be sure to put string length into correct byte ordering before writing      it out.  */
name|char
name|buffer
index|[
name|BYTES_IN_WORD
index|]
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|tab
operator|->
name|index
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|BYTES_IN_WORD
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|tab
operator|->
name|output_order
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next_to_output
control|)
block|{
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|entry
operator|->
name|string
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|entry
operator|->
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|count
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* Short form only, for now.      To do:  Specify output file.  Conditionalize on environment?  Detailed      analysis if desired.  */
block|{
name|int
name|n_syms
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"String table data for output file:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d symbols output\n"
argument_list|,
name|n_syms
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d duplicate strings\n"
argument_list|,
name|tab
operator|->
name|duplicates
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d empty strings\n"
argument_list|,
name|tab
operator|->
name|empty_strings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d unique strings output\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d pointer matches\n"
argument_list|,
name|tab
operator|->
name|pointer_matches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d bytes saved\n"
argument_list|,
name|tab
operator|->
name|bytes_saved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d bad hash matches\n"
argument_list|,
name|tab
operator|->
name|bad_hash_matches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %8d hash-val comparisons\n"
argument_list|,
name|tab
operator|->
name|n_compares
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_syms
condition|)
block|{
name|double
name|n_compares
init|=
name|tab
operator|->
name|n_compares
decl_stmt|;
name|double
name|avg_compares
init|=
name|n_compares
operator|/
name|n_syms
decl_stmt|;
comment|/* The second value here should usually be near one.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t    average %f comparisons per symbol (%f * log2 nstrings)\n"
argument_list|,
name|avg_compares
argument_list|,
name|avg_compares
operator|/
name|log2
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Old code:   unsigned int count;   generic = bfd_get_outsymbols(abfd);   for (count = 0; count< bfd_get_symcount(abfd); count++)     {       asymbol *g = *(generic++);        if (g->name) 	{ 	  size_t length = strlen(g->name)+1; 	  bfd_write((PTR)g->name, 1, length, abfd); 	}       g->KEEPIT = (KEEPITTYPE) count;     } */
block|}
end_function

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|write_syms
argument_list|)
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|generic
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|stringtab_data
name|strtab
decl_stmt|;
name|stringtab_init
argument_list|(
operator|&
name|strtab
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
name|count
operator|++
control|)
block|{
name|asymbol
modifier|*
name|g
init|=
name|generic
index|[
name|count
index|]
decl_stmt|;
name|struct
name|external_nlist
name|nsp
decl_stmt|;
if|if
condition|(
name|g
operator|->
name|name
condition|)
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|add_to_stringtab
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|name
argument_list|,
operator|&
name|strtab
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|nsp
operator|.
name|e_strx
argument_list|)
expr_stmt|;
else|else
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|nsp
operator|.
name|e_strx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|g
argument_list|)
operator|==
name|abfd
operator|->
name|xvec
operator|->
name|flavour
condition|)
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|aout_symbol
argument_list|(
name|g
argument_list|)
operator|->
name|desc
argument_list|,
name|nsp
operator|.
name|e_desc
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|aout_symbol
argument_list|(
name|g
argument_list|)
operator|->
name|other
argument_list|,
name|nsp
operator|.
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|aout_symbol
argument_list|(
name|g
argument_list|)
operator|->
name|type
argument_list|,
name|nsp
operator|.
name|e_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|nsp
operator|.
name|e_desc
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|nsp
operator|.
name|e_other
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|nsp
operator|.
name|e_type
argument_list|)
expr_stmt|;
block|}
name|translate_to_native_sym_flags
argument_list|(
operator|&
name|nsp
argument_list|,
name|g
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nsp
argument_list|,
literal|1
argument_list|,
name|EXTERNAL_NLIST_SIZE
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* NB: `KEEPIT' currently overlays `flags', so set this only 	 here, at the end.  */
name|g
operator|->
name|KEEPIT
operator|=
name|count
expr_stmt|;
block|}
name|emit_strtab
argument_list|(
name|abfd
argument_list|,
operator|&
name|strtab
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_symtab
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|location
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|location
argument_list|)
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbase
decl_stmt|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|symbase
operator|=
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
init|;
name|counter
operator|++
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
control|)
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|(
name|symbase
operator|++
operator|)
expr_stmt|;
operator|*
name|location
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Standard reloc stuff */
end_comment

begin_comment
comment|/* Output standard relocation information to a file in target byte order. */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_out
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|g
operator|,
name|natptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|arelent
operator|*
name|g
name|AND
expr|struct
name|reloc_std_external
operator|*
name|natptr
argument_list|)
block|{
name|int
name|r_index
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|,
name|r_jmptable
decl_stmt|,
name|r_relative
decl_stmt|;
name|unsigned
name|int
name|r_addend
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_length
operator|=
name|g
operator|->
name|howto
operator|->
name|size
expr_stmt|;
comment|/* Size as a power of two */
name|r_pcrel
operator|=
operator|(
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|pc_relative
expr_stmt|;
comment|/* Relative to PC? */
comment|/* XXX This relies on relocs coming from a.out files.  */
name|r_baserel
operator|=
operator|(
name|g
operator|->
name|howto
operator|->
name|type
operator|&
literal|8
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* r_jmptable, r_relative???  FIXME-soon */
name|r_jmptable
operator|=
literal|0
expr_stmt|;
name|r_relative
operator|=
literal|0
expr_stmt|;
name|r_addend
operator|=
name|g
operator|->
name|addend
operator|+
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* name was clobbered by aout_write_syms to be symbol index */
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here      */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|output_section
operator|==
operator|&
name|bfd_abs_section
operator|||
name|output_section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
if|if
condition|(
name|bfd_abs_section
operator|.
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	   from the abs section */
name|r_index
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in symbol */
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
name|stoi
argument_list|(
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|KEEPIT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* now the fun stuff */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|!=
name|false
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Extended stuff */
end_comment

begin_comment
comment|/* Output extended relocation information to a file in target byte order. */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_out
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|g
operator|,
name|natptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|arelent
operator|*
name|g
name|AND
specifier|register
expr|struct
name|reloc_ext_external
operator|*
name|natptr
argument_list|)
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_addend
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|unsigned
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|type
expr_stmt|;
name|r_addend
operator|=
name|g
operator|->
name|addend
operator|+
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|output_section
operator|==
operator|&
name|bfd_abs_section
operator|||
name|output_section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
if|if
condition|(
name|bfd_abs_section
operator|.
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	 from the abs section */
name|r_index
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
name|stoi
argument_list|(
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|KEEPIT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* now the fun stuff */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|!=
name|false
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|r_addend
argument_list|,
name|natptr
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* BFD deals internally with all things based from the section they're    in. so, something in 10 bytes into a text section  with a base of    50 would have a symbol (.text+10) and know .text vma was 50.     Aout keeps all it's symbols based from zero, so the symbol would    contain 60. This macro subs the base of each section from the value    to give the true offset from the section */
end_comment

begin_define
define|#
directive|define
name|MOVE_ADDRESS
parameter_list|(
name|ad
parameter_list|)
define|\
value|if (r_extern) {							\
comment|/* undefined symbol */
value|\      cache_ptr->sym_ptr_ptr = symbols + r_index;			\      cache_ptr->addend = ad;						\      } else {								\
comment|/* defined, section relative. replace symbol with pointer to    	\        symbol which points to section  */
value|\     switch (r_index) {							\     case N_TEXT:							\     case N_TEXT | N_EXT:						\       cache_ptr->sym_ptr_ptr  = obj_textsec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad  - su->textsec->vma;			\       break;								\     case N_DATA:							\     case N_DATA | N_EXT:						\       cache_ptr->sym_ptr_ptr  = obj_datasec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad - su->datasec->vma;			\       break;								\     case N_BSS:								\     case N_BSS | N_EXT:							\       cache_ptr->sym_ptr_ptr  = obj_bsssec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad - su->bsssec->vma;				\       break;								\     default:								\     case N_ABS:								\     case N_ABS | N_EXT:							\      cache_ptr->sym_ptr_ptr = bfd_abs_section.symbol_ptr_ptr;	\       cache_ptr->addend = ad;						\       break;								\     }									\   }     								\  void
end_define

begin_macro
name|DEFUN
argument_list|(
argument|NAME(aout,swap_ext_reloc_in)
argument_list|,
argument|(abfd, bytes, cache_ptr, symbols)
argument_list|,
argument|bfd *abfd AND       struct reloc_ext_external *bytes AND       arelent *cache_ptr AND       asymbol **symbols
argument_list|)
end_macro

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
operator|(
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
operator|)
expr_stmt|;
comment|/* now the fun stuff */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|!=
name|false
condition|)
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_BIG
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_BIG
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|howto
operator|=
name|howto_table_ext
operator|+
name|r_type
expr_stmt|;
name|MOVE_ADDRESS
argument_list|(
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_addend
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_in
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|bytes
operator|,
name|cache_ptr
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|reloc_std_external
operator|*
name|bytes
name|AND
name|arelent
operator|*
name|cache_ptr
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|,
name|r_jmptable
decl_stmt|,
name|r_relative
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|int
name|howto_idx
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|!=
name|false
condition|)
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_BIG
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_BIG
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_BIG
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_BIG
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_LITTLE
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
name|bytes
operator|->
name|r_type
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_LITTLE
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
expr_stmt|;
block|}
name|howto_idx
operator|=
name|r_length
operator|+
literal|4
operator|*
name|r_pcrel
operator|+
literal|8
operator|*
name|r_baserel
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|howto_idx
operator|<
name|TABLE_SIZE
argument_list|(
name|howto_table_std
argument_list|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|howto_table_std
operator|+
name|howto_idx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|cache_ptr
operator|->
name|howto
operator|->
name|type
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_jmptable
operator|==
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_relative
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME-soon:  Roll jmptable, relative bits into howto setting */
name|MOVE_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Reloc hackery */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
name|doit
label|:
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|count
operator|=
name|reloc_size
operator|/
name|each_size
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_cache
condition|)
block|{
name|nomem
label|:
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_cache
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
name|relocs
argument_list|,
literal|1
argument_list|,
name|reloc_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|reloc_size
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_cache
argument_list|)
expr_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|each_size
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
specifier|register
name|struct
name|reloc_ext_external
modifier|*
name|rptr
init|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
init|=
name|reloc_cache
decl_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|struct
name|reloc_std_external
modifier|*
name|rptr
init|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
init|=
name|reloc_cache
decl_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Write out a relocation section into an object file.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|squirt_out_relocs
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
argument_list|)
block|{
name|arelent
modifier|*
modifier|*
name|generic
decl_stmt|;
name|unsigned
name|char
modifier|*
name|native
decl_stmt|,
modifier|*
name|natptr
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
name|size_t
name|natsize
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|natsize
operator|=
name|each_size
operator|*
name|count
expr_stmt|;
name|native
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|natsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|generic
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
if|if
condition|(
name|each_size
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_ext_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_std_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|native
argument_list|,
literal|1
argument_list|,
name|natsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|natsize
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|canonicalize_reloc
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|relptr
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|arelent
operator|*
operator|*
name|relptr
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tblptr
operator|||
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
if|if
condition|(
operator|!
name|tblptr
condition|)
return|return
literal|0
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_reloc_upper_bound
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
argument_list|)
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|/
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_symtab_upper_bound
argument_list|)
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_symbol_table
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|aout_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|alent
modifier|*
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_lineno
argument_list|)
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|ignore_symbol
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|ignore_symbol
argument_list|)
block|{
return|return
operator|(
name|alent
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|get_symbol_info
argument_list|)
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|,
name|ret
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|symbol_info
operator|*
name|ret
argument_list|)
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|type
operator|==
literal|'?'
condition|)
block|{
name|int
name|type_code
init|=
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|type
operator|&
literal|0xff
decl_stmt|;
name|CONST
name|char
modifier|*
name|stab_name
init|=
name|aout_stab_name
argument_list|(
name|type_code
argument_list|)
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|stab_name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|type_code
argument_list|)
expr_stmt|;
name|stab_name
operator|=
name|buf
expr_stmt|;
block|}
name|ret
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
name|ret
operator|->
name|stab_other
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|other
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ret
operator|->
name|stab_desc
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|desc
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|ret
operator|->
name|stab_name
operator|=
name|stab_name
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|print_symbol
argument_list|)
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|afile
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|afile
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4x %2x %2x"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|desc
operator|&
literal|0xffff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|other
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %04x %02x %02x"
argument_list|,
name|section_name
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|desc
operator|&
literal|0xffff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|other
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|aout_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|type
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  provided a BFD, a section and an offset into the section, calculate  and return the name of the source file and the line nearest to the  wanted location. */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|find_nearest_line
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|symbols
operator|,
name|offset
operator|,
name|filename_ptr
operator|,
name|functionname_ptr
operator|,
name|line_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|bfd_vma
name|offset
name|AND
name|CONST
name|char
operator|*
operator|*
name|filename_ptr
name|AND
name|CONST
name|char
operator|*
operator|*
name|functionname_ptr
name|AND
name|unsigned
name|int
operator|*
name|line_ptr
argument_list|)
block|{
comment|/* Run down the file looking for the filename, function and linenumber */
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|char
name|filename_buffer
index|[
literal|200
index|]
decl_stmt|;
name|CONST
name|char
modifier|*
name|directory_name
init|=
name|NULL
decl_stmt|;
name|CONST
name|char
modifier|*
name|main_file_name
init|=
name|NULL
decl_stmt|;
name|CONST
name|char
modifier|*
name|current_file_name
init|=
name|NULL
decl_stmt|;
name|CONST
name|char
modifier|*
name|line_file_name
init|=
name|NULL
decl_stmt|;
comment|/* Value of current_file_name at line number. */
name|bfd_vma
name|high_line_vma
init|=
operator|~
literal|0
decl_stmt|;
name|bfd_vma
name|low_func_vma
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
name|func
init|=
literal|0
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbols
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|symbols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|aout_symbol_type
modifier|*
name|q
init|=
operator|(
name|aout_symbol_type
operator|*
operator|)
operator|(
operator|*
name|p
operator|)
decl_stmt|;
name|next
label|:
switch|switch
condition|(
name|q
operator|->
name|type
condition|)
block|{
case|case
name|N_SO
case|:
name|main_file_name
operator|=
name|current_file_name
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
comment|/* Look ahead to next symbol to check if that too is an N_SO. */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
break|break;
name|q
operator|=
operator|(
name|aout_symbol_type
operator|*
operator|)
operator|(
operator|*
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|type
operator|!=
operator|(
name|int
operator|)
name|N_SO
condition|)
goto|goto
name|next
goto|;
comment|/* Found a second N_SO  First is directory; second is filename. */
name|directory_name
operator|=
name|current_file_name
expr_stmt|;
name|main_file_name
operator|=
name|current_file_name
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|!=
name|section
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|N_SOL
case|:
name|current_file_name
operator|=
name|q
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
case|case
name|N_DSLINE
case|:
case|case
name|N_BSLINE
case|:
comment|/* We'll keep this if it resolves nearer than the one we have already */
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|offset
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<
name|high_line_vma
condition|)
block|{
operator|*
name|line_ptr
operator|=
name|q
operator|->
name|desc
expr_stmt|;
name|high_line_vma
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
name|line_file_name
operator|=
name|current_file_name
expr_stmt|;
block|}
break|break;
case|case
name|N_FUN
case|:
block|{
comment|/* We'll keep this if it is nearer than the one we have already */
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_func_vma
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
name|low_func_vma
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
name|func
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|line_ptr
operator|&&
name|func
condition|)
block|{
name|CONST
name|char
modifier|*
name|function
init|=
name|func
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|function
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Have to remove : stuff */
name|p
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|functionname_ptr
operator|=
name|buffer
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
break|break;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
operator|*
name|line_ptr
condition|)
name|main_file_name
operator|=
name|line_file_name
expr_stmt|;
if|if
condition|(
name|main_file_name
condition|)
block|{
if|if
condition|(
name|main_file_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|directory_name
operator|==
name|NULL
condition|)
operator|*
name|filename_ptr
operator|=
name|main_file_name
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|filename_buffer
argument_list|,
literal|"%.140s%.50s"
argument_list|,
name|directory_name
argument_list|,
name|main_file_name
argument_list|)
expr_stmt|;
operator|*
name|filename_ptr
operator|=
name|filename_buffer
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|NAME
argument_list|(
name|aout
argument_list|,
name|sizeof_headers
argument_list|)
argument_list|,
operator|(
name|abfd
operator|,
name|execable
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|execable
argument_list|)
block|{
return|return
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
return|;
block|}
end_decl_stmt

end_unit

