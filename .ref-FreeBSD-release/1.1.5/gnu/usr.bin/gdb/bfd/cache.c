begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library -- caching of file descriptors.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Hacked by Steve Chamberlain of Cygnus Support (steve@cygnus.com).  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION 	File Caching  	The file caching mechanism is embedded within BFD and allows 	the application to open as many BFDs as it wants without 	regard to the underlying operating system's file descriptor 	limit (often as low as 20 open files).  The module in<<cache.c>> maintains a least recently used list of<<BFD_CACHE_MAX_OPEN>> files, and exports the name<<bfd_cache_lookup>> which runs around and makes sure that 	the required BFD is open. If not, then it chooses a file to 	close, closes it and opens the one wanted, returning its file 	handle.   */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* INTERNAL_FUNCTION 	BFD_CACHE_MAX_OPEN macro  DESCRIPTION 	The maximum number of files which the cache will keep open at 	one time.  .#define BFD_CACHE_MAX_OPEN 10  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|bfd_cache_delete
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bfds on the chain.  All such bfds have their file open;    if it closed, they get snipd()d from the chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|open_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|cache_sentinel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of BFDs with active fds we've 				   opened */
end_comment

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_last_cache  SYNOPSIS 	extern bfd *bfd_last_cache;  DESCRIPTION 	Zero, or a pointer to the topmost BFD on the chain.  This is 	used by the<<bfd_cache_lookup>> macro in @file{libbfd.h} to 	determine when it can avoid a function call. */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|bfd_last_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * INTERNAL_FUNCTION  * 	bfd_cache_lookup  *  * DESCRIPTION  *	Checks to see if the required BFD is the same as the last one  *	looked up. If so then it can use the iostream in the BFD with  *	impunity, since it can't have changed since the last lookup,  *	otherwise it has to perform the complicated lookup function   *  * .#define bfd_cache_lookup(x) \  * .    ((x)==bfd_last_cache? \  * .      (FILE*)(bfd_last_cache->iostream): \  * .       bfd_cache_lookup_worker(x))  *  *  */
end_comment

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|close_one
parameter_list|)
block|{
name|bfd
modifier|*
name|kill
init|=
name|cache_sentinel
decl_stmt|;
if|if
condition|(
name|kill
operator|==
literal|0
condition|)
comment|/* Nothing in the cache */
return|return ;
comment|/* We can only close files that want to play this game.  */
while|while
condition|(
operator|!
name|kill
operator|->
name|cacheable
condition|)
block|{
name|kill
operator|=
name|kill
operator|->
name|lru_prev
expr_stmt|;
if|if
condition|(
name|kill
operator|==
name|cache_sentinel
condition|)
comment|/* Nobody wants to play */
return|return ;
block|}
name|kill
operator|->
name|where
operator|=
name|ftell
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|kill
operator|->
name|iostream
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_cache_delete
argument_list|(
name|kill
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cuts the BFD abfd out of the chain in the cache */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|snip
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|abfd
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|abfd
operator|->
name|lru_next
expr_stmt|;
name|abfd
operator|->
name|lru_next
operator|->
name|lru_prev
operator|=
name|abfd
operator|->
name|lru_prev
expr_stmt|;
if|if
condition|(
name|cache_sentinel
operator|==
name|abfd
condition|)
name|cache_sentinel
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|bfd_cache_delete
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|boolean
name|ret
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|true
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|false
expr_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
block|}
name|snip
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
name|NULL
expr_stmt|;
name|open_files
operator|--
expr_stmt|;
name|bfd_last_cache
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|insert
argument_list|,
operator|(
name|x
operator|,
name|y
operator|)
argument_list|,
name|bfd
operator|*
name|x
name|AND
name|bfd
operator|*
name|y
argument_list|)
block|{
if|if
condition|(
name|y
condition|)
block|{
name|x
operator|->
name|lru_next
operator|=
name|y
expr_stmt|;
name|x
operator|->
name|lru_prev
operator|=
name|y
operator|->
name|lru_prev
expr_stmt|;
name|y
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|x
expr_stmt|;
name|y
operator|->
name|lru_prev
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|x
operator|->
name|lru_prev
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|lru_next
operator|=
name|x
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize a BFD by putting it on the cache LRU.  */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_cache_init
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
name|close_one
argument_list|()
expr_stmt|;
name|cache_sentinel
operator|=
name|insert
argument_list|(
name|abfd
argument_list|,
name|cache_sentinel
argument_list|)
expr_stmt|;
operator|++
name|open_files
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_close  DESCRIPTION 	Remove the BFD from the cache. If the attached file is open, 	then close it too.  SYNOPSIS 	boolean bfd_cache_close (bfd *);  RETURNS<<false>> is returned if closing the file fails,<<true>> is 	returned if all is well. */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_cache_close
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
comment|/* If this file is open then remove from the chain */
if|if
condition|(
name|abfd
operator|->
name|iostream
condition|)
block|{
return|return
name|bfd_cache_delete
argument_list|(
name|abfd
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|true
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_open_file  DESCRIPTION 	Call the OS to open a file for this BFD.  Returns the FILE * 	(possibly null) that results from this operation.  Sets up the 	BFD so that future accesses know the file is open. If the FILE 	* returned is null, then there is won't have been put in the 	cache, so it won't have to be removed from it.  SYNOPSIS 	FILE* bfd_open_file(bfd *); */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|DEFUN
argument_list|(
name|bfd_open_file
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
comment|/* Allow it to be closed later. */
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
block|{
name|close_one
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|abfd
operator|->
name|direction
condition|)
block|{
case|case
name|read_direction
case|:
case|case
name|no_direction
case|:
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
break|break;
case|case
name|both_direction
case|:
case|case
name|write_direction
case|:
if|if
condition|(
name|abfd
operator|->
name|opened_once
operator|==
name|true
condition|)
block|{
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|iostream
condition|)
block|{
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_WUB
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*open for creat */
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fopen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|opened_once
operator|=
name|true
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|abfd
operator|->
name|iostream
condition|)
block|{
name|bfd_cache_init
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_cache_lookup_worker  DESCRIPTION 	Called when the macro<<bfd_cache_lookup>> fails to find a 	quick answer. Finds a file descriptor for this BFD.  If 	necessary, it open it. If there are already more than 	BFD_CACHE_MAX_OPEN files open, it trys to close one first, to 	avoid running out of file descriptors.    SYNOPSIS 	FILE *bfd_cache_lookup_worker(bfd *);  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|DEFUN
argument_list|(
name|bfd_cache_lookup_worker
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
block|{
name|abfd
operator|=
name|abfd
operator|->
name|my_archive
expr_stmt|;
block|}
comment|/* Is this file already open .. if so then quick exit */
if|if
condition|(
name|abfd
operator|->
name|iostream
condition|)
block|{
if|if
condition|(
name|abfd
operator|!=
name|cache_sentinel
condition|)
block|{
comment|/* Place onto head of lru chain */
name|snip
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cache_sentinel
operator|=
name|insert
argument_list|(
name|abfd
argument_list|,
name|cache_sentinel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This is a BFD without a stream -      so it must have been closed or never opened.      find an empty cache entry and use it.  */
else|else
block|{
if|if
condition|(
name|open_files
operator|>=
name|BFD_CACHE_MAX_OPEN
condition|)
block|{
name|close_one
argument_list|()
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|bfd_open_file
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
argument_list|,
name|abfd
operator|->
name|where
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|bfd_last_cache
operator|=
name|abfd
expr_stmt|;
return|return
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
return|;
block|}
end_decl_stmt

end_unit

