begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  *                     RCS checkout operation  */
end_comment

begin_comment
comment|/*****************************************************************************  *                       check out revisions from RCS files  *****************************************************************************  */
end_comment

begin_comment
comment|/* $Log: co.c,v $  * Revision 1.1.1.1  1993/06/18  04:22:11  jkh  * Updated GNU utilities  *  * Revision 5.9  1991/10/07  17:32:46  eggert  * ci -u src/RCS/co.c,v src/co.c<<\.  * -k affects just working file, not RCS file.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Warn before removing somebody else's file.  * Add -M.  Fix co -j bugs.  Tune.  *  * Revision 5.7  1991/04/21  11:58:15  eggert  * Ensure that working file is newer than RCS file after co -[lu].  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.6  1990/12/04  05:18:38  eggert  * Don't checkaccesslist() unless necessary.  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.5  1990/11/01  05:03:26  eggert  * Fix -j.  Add -I.  *  * Revision 5.4  1990/10/04  06:30:11  eggert  * Accumulate exit status across files.  *  * Revision 5.3  1990/09/11  02:41:09  eggert  * co -kv yields a readonly working file.  *  * Revision 5.2  1990/09/04  08:02:13  eggert  * Standardize yes-or-no procedure.  *  * Revision 5.0  1990/08/22  08:10:02  eggert  * Permit multiple locks by same user.  Add setuid support.  * Remove compile-time limits; use malloc instead.  * Permit dates past 1999/12/31.  Switch to GMT.  * Make lock and temp files faster and safer.  * Ansify and Posixate.  Add -k, -V.  Remove snooping.  Tune.  *  * Revision 4.7  89/05/01  15:11:41  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.6  88/08/09  19:12:15  eggert  * Fix "co -d" core dump; rawdate wasn't always initialized.  * Use execv(), not system(); fix putchar('\0') and diagnose() botches; remove lint  *   * Revision 4.5  87/12/18  11:35:40  narten  * lint cleanups (from Guy Harris)  *   * Revision 4.4  87/10/18  10:20:53  narten  * Updating version numbers changes relative to 1.1, are actually  * relative to 4.2  *   * Revision 1.3  87/09/24  13:58:30  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:21:38  jenkins  * Port to suns  *   * Revision 4.2  83/12/05  13:39:48  wft  * made rewriteflag external.  *   * Revision 4.1  83/05/10  16:52:55  wft  * Added option -u and -f.  * Added handling of default branch.  * Replaced getpwuid() with getcaller().  * Removed calls to stat(); now done by pairfilenames().  * Changed and renamed rmoldfile() to rmworkfile().  * Replaced catchints() calls with restoreints(), unlink()--link() with rename();  *   * Revision 3.7  83/02/15  15:27:07  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.6  83/01/15  14:37:50  wft  * Added ignoring of interrupts while RCS file is renamed; this avoids  * deletion of RCS files during the unlink/link window.  *  * Revision 3.5  82/12/08  21:40:11  wft  * changed processing of -d to use DATEFORM; removed actual from  * call to preparejoin; re-fixed printing of done at the end.  *  * Revision 3.4  82/12/04  18:40:00  wft  * Replaced getdelta() with gettree(), SNOOPDIR with SNOOPFILE.  * Fixed printing of "done".  *  * Revision 3.3  82/11/28  22:23:11  wft  * Replaced getlogin() with getpwuid(), flcose() with ffclose(),  * %02d with %.2d, mode generation for working file with WORKMODE.  * Fixed nil printing. Fixed -j combined with -l and -p, and exit  * for non-existing revisions in preparejoin().  *  * Revision 3.2  82/10/18  20:47:21  wft  * Mode of working file is now maintained even for co -l, but write permission  * is removed.  * The working file inherits its mode from the RCS file, plus write permission  * for the owner. The write permission is not given if locking is strict and  * co does not lock.  * An existing working file without write permission is deleted automatically.  * Otherwise, co asks (empty answer: abort co).  * Call to getfullRCSname() added, check for write error added, call  * for getlogin() fixed.  *  * Revision 3.1  82/10/13  16:01:30  wft  * fixed type of variables receiving from getc() (char -> int).  * removed unused variables.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|getancestor
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buildjoin
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|preparejoin
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rmlock
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rmworkfile
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|quietarg
index|[]
init|=
literal|"-q"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|expandarg
decl_stmt|,
modifier|*
name|join
decl_stmt|,
modifier|*
name|suffixarg
decl_stmt|,
modifier|*
name|versionarg
decl_stmt|,
modifier|*
name|incexcarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|joinlist
index|[
name|joinlength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* revisions to be joined */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|neworkptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forceflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastjoin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of last element in joinlist  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -1 -> unlock, 0 -> do nothing, 1 -> lock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mtimeflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* deltas to be generated	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|targetdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final delta to be generated	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|workstat
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|coId
argument_list|,
literal|"co"
argument_list|,
literal|"$Id: co.c,v 1.1.1.1 1993/06/18 04:22:11 jkh Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nco usage: co -{flpqru}[rev] -ddate -jjoinlist -sstate -w[login] -Vn file ..."
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|char
specifier|const
modifier|*
name|author
decl_stmt|,
modifier|*
name|date
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|state
decl_stmt|;
name|char
specifier|const
modifier|*
name|joinfilename
decl_stmt|,
modifier|*
name|newdate
decl_stmt|,
modifier|*
name|neworkfilename
decl_stmt|;
name|int
name|changelock
decl_stmt|;
comment|/* 1 if a lock has been changed, -1 if error */
name|int
name|expmode
decl_stmt|,
name|r
decl_stmt|,
name|tostdout
decl_stmt|,
name|workstatstat
decl_stmt|;
name|struct
name|buf
name|numericrev
decl_stmt|;
comment|/* expanded revision number	*/
name|char
name|finaldate
index|[
name|datesize
index|]
decl_stmt|;
name|setrid
argument_list|()
expr_stmt|;
name|author
operator|=
name|date
operator|=
name|rev
operator|=
name|state
operator|=
name|nil
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numericrev
argument_list|)
expr_stmt|;
name|expmode
operator|=
operator|-
literal|1
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|tostdout
operator|=
name|false
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
name|revno
label|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|rev
condition|)
name|warn
argument_list|(
literal|"redefinition of revision number"
argument_list|)
expr_stmt|;
name|rev
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|forceflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'l'
case|:
if|if
condition|(
name|lockflag
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"-l overrides -u."
argument_list|)
expr_stmt|;
block|}
name|lockflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'u'
case|:
if|if
condition|(
literal|0
operator|<
name|lockflag
condition|)
block|{
name|warn
argument_list|(
literal|"-l overrides -u."
argument_list|)
expr_stmt|;
block|}
name|lockflag
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'p'
case|:
name|tostdout
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'I'
case|:
name|interactiveflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'d'
case|:
if|if
condition|(
name|date
condition|)
name|redefined
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
name|str2date
argument_list|(
name|a
argument_list|,
name|finaldate
argument_list|)
expr_stmt|;
name|date
operator|=
name|finaldate
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|join
condition|)
name|redefined
argument_list|(
literal|'j'
argument_list|)
expr_stmt|;
name|join
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
name|mtimeflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|state
condition|)
name|redefined
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|state
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|author
condition|)
name|redefined
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
name|author
operator|=
name|a
expr_stmt|;
else|else
name|author
operator|=
name|getcaller
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixarg
operator|=
operator|*
name|argv
expr_stmt|;
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|versionarg
operator|=
operator|*
name|argv
expr_stmt|;
name|setRCSversion
argument_list|(
name|versionarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/*  set keyword inclusions/exclusions  */
name|incexcarg
operator|=
operator|*
name|argv
expr_stmt|;
name|setIncExc
argument_list|(
name|incexcarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/*  set keyword expand mode  */
name|expandarg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|redefined
argument_list|(
literal|'k'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|expmode
operator|=
name|str2expmode
argument_list|(
name|a
argument_list|)
operator|)
condition|)
break|break;
comment|/* fall into */
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end of option processing */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
if|if
condition|(
name|tostdout
condition|)
if|#
directive|if
name|text_equals_binary_stdio
operator|||
name|text_work_stdio
name|workstdout
operator|=
name|stdout
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|workstdout
operator|=
name|fdopen
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|FOPEN_W_WORK
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
literal|"stdout"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* now handle all filenames */
do|do
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|lockflag
condition|?
name|rcswriteopen
else|:
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|/* now RCSfilename contains the name of the RCS file, and finptr 	 * points at it.  workfilename contains the name of the working file. 	 * Also, RCSstat has been set.          */
name|diagnose
argument_list|(
literal|"%s  -->  %s\n"
argument_list|,
name|RCSfilename
argument_list|,
name|tostdout
condition|?
literal|"stdout"
else|:
name|workfilename
argument_list|)
expr_stmt|;
name|workstatstat
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tostdout
condition|)
block|{
name|neworkfilename
operator|=
literal|0
expr_stmt|;
name|neworkptr
operator|=
name|workstdout
expr_stmt|;
block|}
else|else
block|{
name|workstatstat
operator|=
name|stat
argument_list|(
name|workfilename
argument_list|,
operator|&
name|workstat
argument_list|)
expr_stmt|;
name|neworkfilename
operator|=
name|makedirtemp
argument_list|(
name|workfilename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|neworkptr
operator|=
name|fopen
argument_list|(
name|neworkfilename
argument_list|,
name|FOPEN_W_WORK
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
name|error
argument_list|(
literal|"%s: parent directory isn't writable"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
else|else
name|eerror
argument_list|(
name|neworkfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree */
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
block|{
comment|/* no revisions; create empty file */
name|diagnose
argument_list|(
literal|"no revisions present; generating empty revision 0.0\n"
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|workstatstat
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|rmworkfile
argument_list|()
condition|)
continue|continue;
name|changelock
operator|=
literal|0
expr_stmt|;
name|newdate
operator|=
literal|0
expr_stmt|;
comment|/* Can't reserve a delta, so don't call addlock */
block|}
else|else
block|{
if|if
condition|(
name|rev
operator|!=
name|nil
condition|)
block|{
comment|/* expand symbolic revision number */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numericrev
argument_list|)
condition|)
continue|continue;
block|}
else|else
switch|switch
condition|(
name|lockflag
operator|<
literal|0
condition|?
name|findlock
argument_list|(
name|false
argument_list|,
operator|&
name|targetdelta
argument_list|)
else|:
literal|0
condition|)
block|{
default|default:
continue|continue;
case|case
literal|0
case|:
name|bufscpy
argument_list|(
operator|&
name|numericrev
argument_list|,
name|Dbranch
condition|?
name|Dbranch
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bufscpy
argument_list|(
operator|&
name|numericrev
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* get numbers of deltas to be generated */
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* check reservations */
name|changelock
operator|=
name|lockflag
operator|<
literal|0
condition|?
name|rmlock
argument_list|(
name|targetdelta
argument_list|)
else|:
name|lockflag
operator|==
literal|0
condition|?
literal|0
else|:
name|addlock
argument_list|(
name|targetdelta
argument_list|)
expr_stmt|;
if|if
condition|(
name|changelock
operator|<
literal|0
operator|||
name|changelock
operator|&&
operator|!
name|checkaccesslist
argument_list|()
operator|||
operator|!
name|dorewrite
argument_list|(
name|lockflag
argument_list|,
name|changelock
argument_list|)
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|Expand
operator|=
name|expmode
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|lockflag
operator|&&
name|Expand
operator|==
name|VAL_EXPAND
condition|)
block|{
name|error
argument_list|(
literal|"cannot combine -kv and -l"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|join
operator|&&
operator|!
name|preparejoin
argument_list|()
condition|)
continue|continue;
name|diagnose
argument_list|(
literal|"revision %s%s\n"
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|,
literal|0
operator|<
name|lockflag
condition|?
literal|" (locked)"
else|:
name|lockflag
operator|<
literal|0
condition|?
literal|" (unlocked)"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Prepare to remove old working file if necessary.  */
if|if
condition|(
name|workstatstat
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|rmworkfile
argument_list|()
condition|)
continue|continue;
comment|/* skip description */
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* don't echo*/
name|locker_expansion
operator|=
literal|0
operator|<
name|lockflag
expr_stmt|;
name|joinfilename
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
name|join
operator|&&
name|tostdout
condition|?
operator|(
name|FILE
operator|*
operator|)
literal|0
else|:
name|neworkptr
argument_list|,
name|Expand
operator|!=
name|OLD_EXPAND
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
if|if
condition|(
name|fcopy
operator|==
name|neworkptr
condition|)
name|fcopy
operator|=
literal|0
expr_stmt|;
comment|/* Don't close it twice.  */
endif|#
directive|endif
name|if_advise_access
argument_list|(
name|changelock
operator|&&
name|gendeltas
operator|->
name|first
operator|!=
name|targetdelta
argument_list|,
name|finptr
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|donerewrite
argument_list|(
name|changelock
argument_list|)
condition|)
continue|continue;
name|newdate
operator|=
name|targetdelta
operator|->
name|date
expr_stmt|;
if|if
condition|(
name|join
condition|)
block|{
name|newdate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|joinfilename
condition|)
block|{
name|aflush
argument_list|(
name|neworkptr
argument_list|)
expr_stmt|;
name|joinfilename
operator|=
name|neworkfilename
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buildjoin
argument_list|(
name|joinfilename
argument_list|)
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|tostdout
condition|)
block|{
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtimeflag
operator|&&
name|newdate
condition|)
block|{
if|if
condition|(
operator|!
name|join
condition|)
name|aflush
argument_list|(
name|neworkptr
argument_list|)
expr_stmt|;
name|r
operator|=
name|setfiledate
argument_list|(
name|neworkfilename
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|chnamemod
argument_list|(
operator|&
name|neworkptr
argument_list|,
name|neworkfilename
argument_list|,
name|workfilename
argument_list|,
name|WORKMODE
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|,
operator|!
operator|(
name|Expand
operator|==
name|VAL_EXPAND
operator|||
name|lockflag
operator|<=
literal|0
operator|&&
name|StrictLocks
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|keepdirtemp
argument_list|(
name|neworkfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|eerror
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"see %s"
argument_list|,
name|neworkfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|diagnose
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|tempunlink
argument_list|()
expr_stmt|;
name|Ofclose
argument_list|(
name|workstdout
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of main (co) */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|frewrite
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
if|if
condition|(
name|fcopy
operator|!=
name|workstdout
condition|)
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|neworkptr
operator|!=
name|workstdout
condition|)
name|Ozclose
argument_list|(
operator|&
name|neworkptr
argument_list|)
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|coExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * The following routines are auxiliary routines  *****************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rmworkfile
parameter_list|()
comment|/* Function: prepares to remove workfilename, if it exists, and if  * it is read-only.  * Otherwise (file writable):  *   if !quietmode asks the user whether to really delete it (default: fail);  *   otherwise failure.  * Returns true if permission is gotten.  */
block|{
if|if
condition|(
name|workstat
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&&
operator|!
name|forceflag
condition|)
block|{
comment|/* File is writable */
if|if
condition|(
operator|!
name|yesorno
argument_list|(
name|false
argument_list|,
literal|"writable %s exists%s; remove it? [ny](n): "
argument_list|,
name|workfilename
argument_list|,
name|myself
argument_list|(
name|workstat
operator|.
name|st_uid
argument_list|)
condition|?
literal|""
else|:
literal|", and you do not own it"
argument_list|)
condition|)
block|{
name|error
argument_list|(
operator|!
name|quietflag
operator|&&
name|ttystdin
argument_list|()
condition|?
literal|"checkout aborted"
else|:
literal|"writable %s exists; checkout aborted"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Actual unlink is done later by caller. */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rmlock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* Function: removes the lock held by caller on delta.  * Returns -1 if someone else holds the lock,  * 0 if there is no lock on delta,  * and 1 if a lock was found and removed.  */
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
name|struct
name|lock
name|dummy
decl_stmt|;
name|int
name|whomatch
decl_stmt|,
name|nummatch
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
name|dummy
operator|.
name|nextlock
operator|=
name|next
operator|=
name|Locks
expr_stmt|;
name|trail
operator|=
operator|&
name|dummy
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
name|whomatch
operator|=
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
name|nummatch
operator|=
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|whomatch
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/*found a lock on delta by caller*/
if|if
condition|(
operator|(
name|whomatch
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"revision %s locked by %s; use co -r or rcs -u"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
comment|/*found one; delete it */
name|trail
operator|->
name|nextlock
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|Locks
operator|=
name|dummy
operator|.
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
comment|/* reset locked-by */
return|return
literal|1
return|;
comment|/*success*/
block|}
else|else
return|return
literal|0
return|;
comment|/*no lock on delta*/
block|}
end_function

begin_comment
comment|/*****************************************************************  * The rest of the routines are for handling joins  *****************************************************************/
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|addjoin
parameter_list|(
name|joinrev
parameter_list|)
name|char
modifier|*
name|joinrev
decl_stmt|;
comment|/* Add joinrev's number to joinlist, yielding address of char past joinrev,  * or nil if no such revision exists.  */
block|{
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|d
decl_stmt|;
name|char
name|terminator
decl_stmt|;
name|struct
name|buf
name|numrev
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|joindeltas
decl_stmt|;
name|j
operator|=
name|joinrev
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|j
operator|++
condition|)
block|{
default|default:
continue|continue;
case|case
literal|0
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|':'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
break|break;
block|}
break|break;
block|}
name|terminator
operator|=
operator|*
operator|--
name|j
expr_stmt|;
operator|*
name|j
operator|=
literal|0
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numrev
argument_list|)
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|joinrev
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
name|d
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|joindeltas
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|numrev
argument_list|)
expr_stmt|;
operator|*
name|j
operator|=
name|terminator
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|joinlist
index|[
operator|++
name|lastjoin
index|]
operator|=
name|d
operator|->
name|num
expr_stmt|;
return|return
name|j
return|;
block|}
return|return
name|nil
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|preparejoin
parameter_list|()
comment|/* Function: Parses a join list pointed to by join and places pointers to the  * revision numbers into joinlist.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|j
decl_stmt|;
name|j
operator|=
name|join
expr_stmt|;
name|lastjoin
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|*
name|j
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|','
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|j
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|lastjoin
operator|>=
name|joinlength
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"too many joins"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|j
operator|=
name|addjoin
argument_list|(
name|j
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
while|while
condition|(
operator|(
operator|*
name|j
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|'\t'
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|j
operator|==
literal|':'
condition|)
block|{
name|j
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|j
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|'\t'
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|j
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|=
name|addjoin
argument_list|(
name|j
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"join pair incomplete"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lastjoin
operator|==
literal|0
condition|)
block|{
comment|/* first pair */
comment|/* common ancestor missing */
name|joinlist
index|[
literal|1
index|]
operator|=
name|joinlist
index|[
literal|0
index|]
expr_stmt|;
name|lastjoin
operator|=
literal|1
expr_stmt|;
comment|/*derive common ancestor*/
if|if
condition|(
operator|!
operator|(
name|joinlist
index|[
literal|0
index|]
operator|=
name|getancestor
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
name|joinlist
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"join pair incomplete"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
if|if
condition|(
name|lastjoin
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"empty join"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|getancestor
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|char
specifier|const
modifier|*
name|r1
decl_stmt|,
decl|*
name|r2
decl_stmt|;
end_function

begin_comment
comment|/* Yield the common ancestor of r1 and r2 if successful, nil otherwise.  * Work reliably only if r1 and r2 are not branch numbers.  */
end_comment

begin_block
block|{
specifier|static
name|struct
name|buf
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|unsigned
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l3
decl_stmt|;
name|char
specifier|const
modifier|*
name|r
decl_stmt|;
name|l1
operator|=
name|countnumflds
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|countnumflds
argument_list|(
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|2
operator|<
name|l1
operator|||
literal|2
operator|<
name|l2
operator|)
operator|&&
name|cmpnum
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* not on main trunk or identical */
name|l3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|l3
operator|+=
literal|2
expr_stmt|;
comment|/* This will terminate since r1 and r2 are not the same; see above. */
if|if
condition|(
name|l3
operator|==
literal|0
condition|)
block|{
comment|/* no common prefix; common ancestor on main trunk */
name|VOID
name|partialno
argument_list|(
operator|&
name|t1
argument_list|,
name|r1
argument_list|,
name|l1
operator|>
literal|2
condition|?
operator|(
name|unsigned
operator|)
literal|2
else|:
name|l1
argument_list|)
decl_stmt|;
name|VOID
name|partialno
argument_list|(
operator|&
name|t2
argument_list|,
name|r2
argument_list|,
name|l2
operator|>
literal|2
condition|?
operator|(
name|unsigned
operator|)
literal|2
else|:
name|l2
argument_list|)
decl_stmt|;
name|r
operator|=
name|cmpnum
argument_list|(
name|t1
operator|.
name|string
argument_list|,
name|t2
operator|.
name|string
argument_list|)
operator|<
literal|0
condition|?
name|t1
operator|.
name|string
else|:
name|t2
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|cmpnum
argument_list|(
name|r
argument_list|,
name|r1
argument_list|)
operator|!=
literal|0
operator|&&
name|cmpnum
argument_list|(
name|r
argument_list|,
name|r2
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|partialno
argument_list|(
operator|&
name|t1
argument_list|,
name|r1
argument_list|,
name|l3
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"common ancestor of %s and %s undefined"
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|buildjoin
parameter_list|(
name|initialfile
parameter_list|)
name|char
specifier|const
modifier|*
name|initialfile
decl_stmt|;
comment|/* Function: merge pairs of elements in joinlist into initialfile  * If workstdout is set, copy result to stdout.  * All unlinking of initialfile, rev2, and rev3 should be done by tempunlink().  */
block|{
name|struct
name|buf
name|commarg
decl_stmt|;
name|struct
name|buf
name|subs
decl_stmt|;
name|char
specifier|const
modifier|*
name|rev2
decl_stmt|,
modifier|*
name|rev3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
specifier|const
modifier|*
name|cov
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|mergev
index|[
literal|12
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|p
decl_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|subs
argument_list|)
expr_stmt|;
name|rev2
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rev3
operator|=
name|maketemp
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* buildrevision() may use 1 and 2 */
name|cov
index|[
literal|0
index|]
operator|=
name|nil
expr_stmt|;
comment|/* cov[1] setup below */
name|cov
index|[
literal|2
index|]
operator|=
name|CO
expr_stmt|;
comment|/* cov[3] setup below */
name|p
operator|=
operator|&
name|cov
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|expandarg
condition|)
operator|*
name|p
operator|++
operator|=
name|expandarg
expr_stmt|;
if|if
condition|(
name|suffixarg
condition|)
operator|*
name|p
operator|++
operator|=
name|suffixarg
expr_stmt|;
if|if
condition|(
name|versionarg
condition|)
operator|*
name|p
operator|++
operator|=
name|versionarg
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|quietarg
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|RCSfilename
expr_stmt|;
operator|*
name|p
operator|=
name|nil
expr_stmt|;
name|mergev
index|[
literal|0
index|]
operator|=
name|nil
expr_stmt|;
name|mergev
index|[
literal|1
index|]
operator|=
name|nil
expr_stmt|;
name|mergev
index|[
literal|2
index|]
operator|=
name|MERGE
expr_stmt|;
name|mergev
index|[
literal|3
index|]
operator|=
name|mergev
index|[
literal|5
index|]
operator|=
literal|"-L"
expr_stmt|;
comment|/* rest of mergev setup below */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lastjoin
condition|)
block|{
comment|/*prepare marker for merge*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|bufscpy
argument_list|(
operator|&
name|subs
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
else|else
block|{
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
name|joinlist
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
name|joinlist
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|diagnose
argument_list|(
literal|"revision %s\n"
argument_list|,
name|joinlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|joinlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cov
index|[
literal|1
index|]
operator|=
name|rev2
expr_stmt|;
name|cov
index|[
literal|3
index|]
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
name|cov
argument_list|)
condition|)
goto|goto
name|badmerge
goto|;
name|diagnose
argument_list|(
literal|"revision %s\n"
argument_list|,
name|joinlist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|joinlist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|cov
index|[
literal|1
index|]
operator|=
name|rev3
expr_stmt|;
name|cov
index|[
literal|3
index|]
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
name|cov
argument_list|)
condition|)
goto|goto
name|badmerge
goto|;
name|diagnose
argument_list|(
literal|"merging...\n"
argument_list|)
expr_stmt|;
name|mergev
index|[
literal|4
index|]
operator|=
name|subs
operator|.
name|string
expr_stmt|;
name|mergev
index|[
literal|6
index|]
operator|=
name|joinlist
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|p
operator|=
operator|&
name|mergev
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|quietflag
condition|)
operator|*
name|p
operator|++
operator|=
name|quietarg
expr_stmt|;
if|if
condition|(
name|lastjoin
operator|<=
name|i
operator|+
literal|2
operator|&&
name|workstdout
condition|)
operator|*
name|p
operator|++
operator|=
literal|"-p"
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|initialfile
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rev2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rev3
expr_stmt|;
operator|*
name|p
operator|=
name|nil
expr_stmt|;
switch|switch
condition|(
name|runv
argument_list|(
name|mergev
argument_list|)
condition|)
block|{
case|case
name|DIFF_FAILURE
case|:
case|case
name|DIFF_SUCCESS
case|:
break|break;
default|default:
goto|goto
name|badmerge
goto|;
block|}
name|i
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
name|bufautoend
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|subs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|badmerge
label|:
name|nerror
operator|++
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|subs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

end_unit

