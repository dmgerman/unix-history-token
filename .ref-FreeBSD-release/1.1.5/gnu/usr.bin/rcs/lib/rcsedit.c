begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS stream editor  */
end_comment

begin_comment
comment|/**********************************************************************************  *                       edits the input file according to a  *                       script from stdin, generated by diff -n  *                       performs keyword expansion  **********************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcsedit.c,v $  * Revision 1.1.1.1  1993/06/18  04:22:12  jkh  * Updated GNU utilities  *  * Revision 5.11  1991/11/03  01:11:44  eggert  * Move the warning about link breaking to where they're actually being broken.  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Support piece tables even if !has_mmap.  Fix rare NFS bugs.  *  * Revision 5.9  1991/09/17  19:07:40  eggert  * SGI readlink() yields ENXIO, not EINVAL, for nonlinks.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Add piece tables, NFS bug workarounds.  Catch odd filenames.  Tune.  *  * Revision 5.7  1991/04/21  11:58:21  eggert  * Fix errno bugs.  Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.6  1991/02/25  07:12:40  eggert  * Fix setuid bug.  Support new link behavior.  Work around broken "w+" fopen.  *  * Revision 5.5  1990/12/30  05:07:35  eggert  * Fix report of busy RCS files when !defined(O_CREAT) | !defined(O_EXCL).  *  * Revision 5.4  1990/11/01  05:03:40  eggert  * Permit arbitrary data in comment leaders.  *  * Revision 5.3  1990/09/11  02:41:13  eggert  * Tune expandline().  *  * Revision 5.2  1990/09/04  08:02:21  eggert  * Count RCS lines better.  Improve incomplete line handling.  *  * Revision 5.1  1990/08/29  07:13:56  eggert  * Add -kkvl.  * Fix bug when getting revisions to files ending in incomplete lines.  * Fix bug in comment leader expansion.  *  * Revision 5.0  1990/08/22  08:12:47  eggert  * Don't require final newline.  * Don't append "checked in with -k by " to logs,  * so that checking in a program with -k doesn't change it.  * Don't generate trailing white space for empty comment leader.  * Remove compile-time limits; use malloc instead.  Add -k, -V.  * Permit dates past 1999/12/31.  Make lock and temp files faster and safer.  * Ansify and Posixate.  Check diff's output.  *  * Revision 4.8  89/05/01  15:12:35  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.7  88/11/08  13:54:14  narten  * misplaced semicolon caused infinite loop  *   * Revision 4.6  88/08/09  19:12:45  eggert  * Shrink stdio code size; allow cc -R.  *   * Revision 4.5  87/12/18  11:38:46  narten  * Changes from the 43. version. Don't know the significance of the  * first change involving "rewind". Also, additional "lint" cleanup.  * (Guy Harris)  *   * Revision 4.4  87/10/18  10:32:21  narten  * Updating version numbers. Changes relative to version 1.1 actually  * relative to 4.1  *   * Revision 1.4  87/09/24  13:59:29  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.3  87/09/15  16:39:39  shepler  * added an initializatin of the variables editline and linecorr  * this will be done each time a file is processed.  * (there was an obscure bug where if co was used to retrieve multiple files  *  it would dump)  * fix attributed to  Roy Morris @FileNet Corp ...!felix!roy  *   * Revision 1.2  87/03/27  14:22:17  jenkins  * Port to suns  *   * Revision 4.1  83/05/12  13:10:30  wft  * Added new markers Id and RCSfile; added locker to Header and Id.  * Overhauled expandline completely() (problem with $01234567890123456789@).  * Moved trymatch() and marker table to rcskeys.c.  *   * Revision 3.7  83/05/12  13:04:39  wft  * Added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  * Log no longer expands full path of RCS file.  *   * Revision 3.6  83/05/11  16:06:30  wft  * added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  *   * Revision 3.5  82/12/04  13:20:56  wft  * Added expansion of keyword Locker.  *  * Revision 3.4  82/12/03  12:26:54  wft  * Added line number correction in case editing does not start at the  * beginning of the file.  * Changed keyword expansion to always print a space before closing KDELIM;  * Expansion for Header shortened.  *  * Revision 3.3  82/11/14  14:49:30  wft  * removed Suffix from keyword expansion. Replaced fclose with ffclose.  * keyreplace() gets log message from delta, not from curlogmsg.  * fixed expression overflow in while(c=putc(GETC....  * checked nil printing.  *  * Revision 3.2  82/10/18  21:13:39  wft  * I added checks for write errors during the co process, and renamed  * expandstring() to xpandstring().  *  * Revision 3.1  82/10/13  15:52:55  wft  * changed type of result of getc() from char to int.  * made keyword expansion loop in expandline() portable to machines  * without sign-extension.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|editId
argument_list|,
literal|"$Id: rcsedit.c,v 1.1.1.1 1993/06/18 04:22:12 jkh Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|void
name|keyreplace
name|P
argument_list|(
operator|(
expr|enum
name|markers
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fcopy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file descriptor			    */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|resultfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file name				    */
end_comment

begin_decl_stmt
name|int
name|locker_expansion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should the locker name be appended to Id val?   */
end_comment

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|fedit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|editfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit pathname */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|editline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit line counter; #lines before cursor   */
end_comment

begin_decl_stmt
specifier|static
name|long
name|linecorr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #adds - #deletes in each edit run.		    */
end_comment

begin_comment
comment|/*used to correct editline in case file is not rewound after */
end_comment

begin_comment
comment|/* applying one delta                                        */
end_comment

begin_define
define|#
directive|define
name|DIRTEMPNAMES
value|2
end_define

begin_enum
enum|enum
name|maker
block|{
name|notmade
block|,
name|real
block|,
name|effective
block|}
enum|;
end_enum

begin_decl_stmt
name|struct
name|buf
name|dirtfname
index|[
name|DIRTEMPNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unlink these when done */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|maker
specifier|volatile
name|dirtfmaker
index|[
name|DIRTEMPNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if these are set */
end_comment

begin_if
if|#
directive|if
name|has_NFS
operator|||
name|bad_unlink
end_if

begin_function
name|int
name|un_link
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/*  * Remove S, even if it is unwritable.  * Ignore unlink() ENOENT failures; NFS generates bogus ones.  */
block|{
if|#
directive|if
name|bad_unlink
name|int
name|e
decl_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|e
operator|=
name|errno
expr_stmt|;
if|#
directive|if
name|has_NFS
if|if
condition|(
name|e
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|chmod
argument_list|(
name|s
argument_list|,
name|S_IWUSR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|has_NFS
return|return
name|unlink
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
return|;
else|#
directive|else
return|return
name|unlink
argument_list|(
name|s
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_rename
end_if

begin_if
if|#
directive|if
operator|!
name|has_NFS
end_if

begin_define
define|#
directive|define
name|do_link
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|link(s,t)
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|do_link
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_comment
comment|/* Link S to T, ignoring bogus EEXIST problems due to NFS failures.  */
end_comment

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|,
name|tb
decl_stmt|;
if|if
condition|(
name|link
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|t
argument_list|,
operator|&
name|tb
argument_list|)
operator|==
literal|0
operator|&&
name|sb
operator|.
name|st_ino
operator|==
name|tb
operator|.
name|st_ino
operator|&&
name|sb
operator|.
name|st_dev
operator|==
name|tb
operator|.
name|st_dev
condition|)
return|return
literal|0
return|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|exiting
name|void
name|editEndsPrematurely
parameter_list|()
block|{
name|fatserror
argument_list|(
literal|"edit script ends prematurely"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|exiting
name|void
name|editLineNumberOverflow
parameter_list|()
block|{
name|fatserror
argument_list|(
literal|"edit script refers to line past end of file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|large_memory
end_if

begin_if
if|#
directive|if
name|has_memmove
end_if

begin_define
define|#
directive|define
name|movelines
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|VOID memmove(s1, s2, (n)*sizeof(Iptr_type))
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|movelines
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
specifier|register
name|Iptr_type
modifier|*
name|s1
decl_stmt|;
specifier|register
name|Iptr_type
specifier|const
modifier|*
name|s2
decl_stmt|;
specifier|register
name|unsigned
name|long
name|n
decl_stmt|;
block|{
if|if
condition|(
name|s1
operator|<
name|s2
condition|)
do|do
block|{
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
else|else
block|{
name|s1
operator|+=
name|n
expr_stmt|;
name|s2
operator|+=
name|n
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|s1
operator|=
operator|*
operator|--
name|s2
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * `line' contains pointers to the lines in the currently `edited' file.  * It is a 0-origin array that represents linelim-gapsize lines.  * line[0..gap-1] and line[gap+gapsize..linelim-1] contain pointers to lines.  * line[gap..gap+gapsize-1] contains garbage.  *  * Any @s in lines are duplicated.  * Lines are terminated by \n, or (for a last partial line only) by single @.  */
end_comment

begin_decl_stmt
specifier|static
name|Iptr_type
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|gap
decl_stmt|,
name|gapsize
decl_stmt|,
name|linelim
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|insertline
parameter_list|(
name|n
parameter_list|,
name|l
parameter_list|)
name|unsigned
name|long
name|n
decl_stmt|;
name|Iptr_type
name|l
decl_stmt|;
comment|/* Before line N, insert line L.  N is 0-origin.  */
block|{
if|if
condition|(
name|linelim
operator|-
name|gapsize
operator|<
name|n
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gapsize
condition|)
name|line
operator|=
operator|!
name|linelim
condition|?
name|tnalloc
argument_list|(
name|Iptr_type
argument_list|,
name|linelim
operator|=
name|gapsize
operator|=
literal|1024
argument_list|)
else|:
operator|(
name|gap
operator|=
name|gapsize
operator|=
name|linelim
operator|,
name|trealloc
argument_list|(
name|Iptr_type
argument_list|,
name|line
argument_list|,
name|linelim
operator|<<=
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|gap
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|n
operator|+
name|gapsize
argument_list|,
name|line
operator|+
name|n
argument_list|,
name|gap
operator|-
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gap
operator|<
name|n
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|gap
argument_list|,
name|line
operator|+
name|gap
operator|+
name|gapsize
argument_list|,
name|n
operator|-
name|gap
argument_list|)
expr_stmt|;
name|line
index|[
name|n
index|]
operator|=
name|l
expr_stmt|;
name|gap
operator|=
name|n
operator|+
literal|1
expr_stmt|;
name|gapsize
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|deletelines
parameter_list|(
name|n
parameter_list|,
name|nlines
parameter_list|)
name|unsigned
name|long
name|n
decl_stmt|,
name|nlines
decl_stmt|;
comment|/* Delete lines N through N+NLINES-1.  N is 0-origin.  */
block|{
name|unsigned
name|long
name|l
init|=
name|n
operator|+
name|nlines
decl_stmt|;
if|if
condition|(
name|linelim
operator|-
name|gapsize
operator|<
name|l
operator|||
name|l
operator|<
name|n
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|gap
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|l
operator|+
name|gapsize
argument_list|,
name|line
operator|+
name|l
argument_list|,
name|gap
operator|-
name|l
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gap
operator|<
name|n
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|gap
argument_list|,
name|line
operator|+
name|gap
operator|+
name|gapsize
argument_list|,
name|n
operator|-
name|gap
argument_list|)
expr_stmt|;
name|gap
operator|=
name|n
expr_stmt|;
name|gapsize
operator|+=
name|nlines
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snapshotline
parameter_list|(
name|f
parameter_list|,
name|l
parameter_list|)
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|Iptr_type
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|l
operator|++
operator|)
operator|==
name|SDELIM
operator|&&
operator|*
name|l
operator|++
operator|!=
name|SDELIM
condition|)
return|return;
name|aputc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
end_function

begin_function
name|void
name|snapshotedit
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Copy the current state of the edits to F.  */
block|{
specifier|register
name|Iptr_type
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|l
init|=
name|line
decl_stmt|;
for|for
control|(
name|p
operator|=
name|l
operator|,
name|lim
operator|=
name|l
operator|+
name|gap
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|snapshotline
argument_list|(
name|f
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|+=
name|gapsize
operator|,
name|lim
operator|=
name|l
operator|+
name|linelim
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|snapshotline
argument_list|(
name|f
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finisheditline
parameter_list|(
name|fin
parameter_list|,
name|fout
parameter_list|,
name|l
parameter_list|,
name|delta
parameter_list|)
name|RILE
modifier|*
name|fin
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
name|Iptr_type
name|l
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
block|{
name|Iseek
argument_list|(
name|fin
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|expandline
argument_list|(
name|fin
argument_list|,
name|fout
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|faterror
argument_list|(
literal|"finisheditline internal error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finishedit
parameter_list|(
name|delta
parameter_list|,
name|outfile
parameter_list|,
name|done
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/*  * Doing expansion if DELTA is set, output the state of the edits to OUTFILE.  * But do nothing unless DONE is set (which means we are on the last pass).  */
block|{
if|if
condition|(
name|done
condition|)
block|{
name|openfcopy
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
name|snapshotedit
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|Iptr_type
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|l
init|=
name|line
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
init|=
name|finptr
decl_stmt|;
name|Iptr_type
name|here
init|=
name|Itell
argument_list|(
name|fin
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|l
operator|,
name|lim
operator|=
name|l
operator|+
name|gap
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|finisheditline
argument_list|(
name|fin
argument_list|,
name|outfile
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|delta
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|+=
name|gapsize
operator|,
name|lim
operator|=
name|l
operator|+
name|linelim
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|finisheditline
argument_list|(
name|fin
argument_list|,
name|outfile
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|Iseek
argument_list|(
name|fin
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Open a temporary FILENAME for output, truncating any previous contents.  */
end_comment

begin_define
define|#
directive|define
name|fopen_update_truncate
parameter_list|(
name|filename
parameter_list|)
value|fopen(filename, FOPEN_W_WORK)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !large_memory */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|fopen_update_truncate
parameter_list|(
name|filename
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
block|{
if|#
directive|if
name|bad_fopen_wplus
if|if
condition|(
name|un_link
argument_list|(
name|filename
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_WPLUS_WORK
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|openfcopy
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|fcopy
operator|=
name|f
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|resultfile
condition|)
name|resultfile
operator|=
name|maketemp
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fcopy
operator|=
name|fopen_update_truncate
argument_list|(
name|resultfile
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|resultfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_function
specifier|static
name|void
name|swapeditfiles
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
comment|/* Function: swaps resultfile and editfile, assigns fedit=fcopy,  * and rewinds fedit for reading.  Set fcopy to outfile if nonnull;  * otherwise, set fcopy to be resultfile opened for reading and writing.  */
block|{
name|char
specifier|const
modifier|*
name|tmpptr
decl_stmt|;
name|editline
operator|=
literal|0
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|fcopy
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
name|fedit
operator|=
name|fcopy
expr_stmt|;
name|tmpptr
operator|=
name|editfile
expr_stmt|;
name|editfile
operator|=
name|resultfile
expr_stmt|;
name|resultfile
operator|=
name|tmpptr
expr_stmt|;
name|openfcopy
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|snapshotedit
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Copy the current state of the edits to F.  */
block|{
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fastcopy
argument_list|(
name|fedit
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|Irewind
argument_list|(
name|fedit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finishedit
parameter_list|(
name|delta
parameter_list|,
name|outfile
parameter_list|,
name|done
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* copy the rest of the edit file and close it (if it exists).  * if delta!=nil, perform keyword substitution at the same time.  * If DONE is set, we are finishing the last pass.  */
block|{
specifier|register
name|RILE
modifier|*
name|fe
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fc
decl_stmt|;
name|fe
operator|=
name|fedit
expr_stmt|;
if|if
condition|(
name|fe
condition|)
block|{
name|fc
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
name|nil
condition|)
block|{
while|while
condition|(
literal|1
operator|<
name|expandline
argument_list|(
name|fe
argument_list|,
name|fc
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
block|{
name|fastcopy
argument_list|(
name|fe
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
name|Ifclose
argument_list|(
name|fe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|swapeditfiles
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|large_memory
end_if

begin_define
define|#
directive|define
name|copylines
parameter_list|(
name|upto
parameter_list|,
name|delta
parameter_list|)
value|(editline = (upto))
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|copylines
parameter_list|(
name|upto
parameter_list|,
name|delta
parameter_list|)
specifier|register
name|unsigned
name|long
name|upto
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/*  * Copy input lines editline+1..upto from fedit to fcopy.  * If delta != nil, keyword expansion is done simultaneously.  * editline is updated. Rewinds a file only if necessary.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fc
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fe
decl_stmt|;
if|if
condition|(
name|upto
operator|<
name|editline
condition|)
block|{
comment|/* swap files */
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* assumes edit only during last pass, from the beginning*/
block|}
name|fe
operator|=
name|fedit
expr_stmt|;
name|fc
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
name|editline
operator|<
name|upto
condition|)
if|if
condition|(
name|delta
condition|)
do|do
block|{
if|if
condition|(
name|expandline
argument_list|(
name|fe
argument_list|,
name|fc
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
operator|<=
literal|1
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|editline
operator|<
name|upto
condition|)
do|;
else|else
block|{
name|setupcache
argument_list|(
name|fe
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fe
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
name|cachegeteof
argument_list|(
argument|c
argument_list|,
argument|editLineNumberOverflow();
argument_list|)
empty_stmt|;
name|aputc
argument_list|(
name|c
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|++
name|editline
operator|<
name|upto
condition|)
do|;
name|uncache
argument_list|(
name|fe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|xpandstring
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* Function: Reads a string terminated by SDELIM from finptr and writes it  * to fcopy. Double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If foutptr is nonnull, the string is also copied unchanged to foutptr.  */
block|{
while|while
condition|(
literal|1
operator|<
name|expandline
argument_list|(
name|finptr
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|foutptr
argument_list|)
condition|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|copystring
parameter_list|()
comment|/* Function: copies a string terminated with a single SDELIM from finptr to  * fcopy, replacing all double SDELIM with a single SDELIM.  * If foutptr is nonnull, the string also copied unchanged to foutptr.  * editline is incremented by the number of lines copied.  * Assumption: next character read is first string character.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|,
modifier|*
name|fcop
decl_stmt|;
specifier|register
name|int
name|amidline
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|fcop
operator|=
name|fcopy
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|editline
expr_stmt|;
operator|++
name|rcsline
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|editline
operator|+=
name|amidline
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall into */
default|default:
name|amidline
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|aputc
argument_list|(
name|c
argument_list|,
name|fcop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|enterstring
parameter_list|()
comment|/* Like copystring, except the string is put into the edit data structure.  */
block|{
if|#
directive|if
operator|!
name|large_memory
name|editfile
operator|=
literal|0
expr_stmt|;
name|fedit
operator|=
literal|0
expr_stmt|;
name|editline
operator|=
name|linecorr
operator|=
literal|0
expr_stmt|;
name|resultfile
operator|=
name|maketemp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fcopy
operator|=
name|fopen_update_truncate
argument_list|(
name|resultfile
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|resultfile
argument_list|)
expr_stmt|;
name|copystring
argument_list|()
expr_stmt|;
else|#
directive|else
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|unsigned
name|long
name|e
decl_stmt|,
name|oe
decl_stmt|;
specifier|register
name|int
name|amidline
decl_stmt|,
name|oamidline
decl_stmt|;
specifier|register
name|Iptr_type
name|optr
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
name|gap
operator|=
literal|0
expr_stmt|;
name|gapsize
operator|=
name|linelim
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|advise_access
argument_list|(
name|fin
argument_list|,
name|MADV_NORMAL
argument_list|)
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|optr
operator|=
name|cachetell
argument_list|()
expr_stmt|;
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|oamidline
operator|=
name|amidline
expr_stmt|;
name|oe
operator|=
name|e
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|e
expr_stmt|;
operator|++
name|rcsline
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|editline
operator|=
name|e
operator|+
name|amidline
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall into */
default|default:
name|amidline
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|oamidline
condition|)
name|insertline
argument_list|(
name|oe
argument_list|,
name|optr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
if|#
directive|if
name|large_memory
name|edit_string
parameter_list|()
else|#
directive|else
function|editstring
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
endif|#
directive|endif
comment|/*  * Read an edit script from finptr and applies it to the edit file. #if !large_memory  * The result is written to fcopy.  * If delta!=nil, keyword expansion is performed simultaneously.  * If running out of lines in fedit, fedit and fcopy are swapped.  * editfile is the name of the file that goes with fedit. #endif  * If foutptr is set, the edit script is also copied verbatim to foutptr.  * Assumes that all these files are open.  * resultfile is the name of the file that goes with fcopy.  * Assumes the next input character from finptr is the first character of  * the edit script. Resets nextc on exit.  */
block|{
name|int
name|ed
decl_stmt|;
comment|/* editor command */
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
if|#
directive|if
operator|!
name|large_memory
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|unsigned
name|long
name|line_lim
init|=
name|ULONG_MAX
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fe
decl_stmt|;
endif|#
directive|endif
specifier|register
name|unsigned
name|long
name|i
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
if|#
directive|if
name|large_memory
specifier|register
name|unsigned
name|long
name|j
decl_stmt|;
endif|#
directive|endif
name|struct
name|diffcmd
name|dc
decl_stmt|;
name|editline
operator|+=
name|linecorr
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
comment|/*correct line number*/
name|frew
operator|=
name|foutptr
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|initdiffcmd
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|(
name|ed
operator|=
name|getdiffcmd
argument_list|(
name|fin
argument_list|,
name|true
argument_list|,
name|frew
argument_list|,
operator|&
name|dc
argument_list|)
operator|)
condition|)
if|#
directive|if
operator|!
name|large_memory
if|if
condition|(
name|line_lim
operator|<=
name|dc
operator|.
name|line1
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|ed
condition|)
block|{
name|copylines
argument_list|(
name|dc
operator|.
name|line1
operator|-
literal|1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* skip over unwanted lines */
name|i
operator|=
name|dc
operator|.
name|nlines
expr_stmt|;
name|linecorr
operator|-=
name|i
expr_stmt|;
name|editline
operator|+=
name|i
expr_stmt|;
if|#
directive|if
name|large_memory
name|deletelines
argument_list|(
name|editline
operator|+
name|linecorr
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|fe
operator|=
name|fedit
expr_stmt|;
do|do
block|{
comment|/*skip next line*/
do|do
block|{
name|Igeteof
argument_list|(
argument|fe
argument_list|,
argument|c
argument_list|,
argument|{ if (i!=
literal|1
argument|) editLineNumberOverflow(); line_lim = dc.dafter; break; }
argument_list|)
empty_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
endif|#
directive|endif
block|}
else|else
block|{
name|copylines
argument_list|(
name|dc
operator|.
name|line1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/*copy only; no delete*/
name|i
operator|=
name|dc
operator|.
name|nlines
expr_stmt|;
if|#
directive|if
name|large_memory
name|j
operator|=
name|editline
operator|+
name|linecorr
expr_stmt|;
endif|#
directive|endif
name|linecorr
operator|+=
name|i
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
name|f
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
name|delta
condition|)
do|do
block|{
switch|switch
condition|(
name|expandline
argument_list|(
name|fin
argument_list|,
name|f
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|frew
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return;
comment|/* fall into */
case|case
operator|-
literal|1
case|:
name|editEndsPrematurely
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
else|else
endif|#
directive|endif
block|{
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
do|do
block|{
if|#
directive|if
name|large_memory
name|insertline
argument_list|(
name|j
operator|++
argument_list|,
name|cachetell
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
name|aputc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
if|if
condition|(
operator|--
name|i
condition|)
name|editEndsPrematurely
argument_list|()
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
operator|++
name|rcsline
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The rest is for keyword expansion */
end_comment

begin_function
name|int
name|expandline
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|,
name|delta
parameter_list|,
name|delimstuffed
parameter_list|,
name|frewfile
parameter_list|)
name|RILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|,
decl|*
name|frewfile
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delimstuffed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read a line from INFILE and write it to OUTFILE.  * If DELIMSTUFFED is true, double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If FREWFILE is set, copy the line unchanged to FREWFILE.  * DELIMSTUFFED must be true if FREWFILE is set.  * Yields -1 if no data is copied, 0 if an incomplete line is copied,  * 2 if a complete line is copied; adds 1 to yield if expansion occurred.  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|,
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|e
decl_stmt|,
name|ds
decl_stmt|,
name|r
decl_stmt|;
name|char
specifier|const
modifier|*
name|tlim
decl_stmt|;
specifier|static
name|struct
name|buf
name|keyval
decl_stmt|;
name|enum
name|markers
name|matchresult
decl_stmt|;
name|setupcache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|out
operator|=
name|outfile
expr_stmt|;
name|frew
operator|=
name|frewfile
expr_stmt|;
name|ds
operator|=
name|delimstuffed
expr_stmt|;
name|bufalloc
argument_list|(
operator|&
name|keyval
argument_list|,
name|keylength
operator|+
literal|3
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ds
condition|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|cachegeteof
argument_list|(
argument|c
argument_list|,
argument|goto uncache_exit;
argument_list|)
empty_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SDELIM
case|:
if|if
condition|(
name|ds
condition|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
goto|goto
name|uncache_exit
goto|;
block|}
block|}
comment|/* fall into */
default|default:
name|aputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|rcsline
operator|+=
name|ds
expr_stmt|;
name|aputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|r
operator|=
literal|2
expr_stmt|;
goto|goto
name|uncache_exit
goto|;
case|case
name|KDELIM
case|:
name|r
operator|=
literal|0
expr_stmt|;
comment|/* check for keyword */
comment|/* first, copy a long enough string into keystring */
name|tp
operator|=
name|keyval
operator|.
name|string
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|KDELIM
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ds
condition|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|cachegeteof
argument_list|(
argument|c
argument_list|,
argument|goto keystring_eof;
argument_list|)
empty_stmt|;
if|if
condition|(
name|tp
operator|<
name|keyval
operator|.
name|string
operator|+
name|keylength
operator|+
literal|1
condition|)
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|matchresult
operator|=
name|trymatch
argument_list|(
name|keyval
operator|.
name|string
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchresult
operator|==
name|Nomatch
condition|)
block|{
name|tp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|aputs
argument_list|(
name|keyval
operator|.
name|string
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
comment|/* last c handled properly */
block|}
comment|/* Now we have a keyword terminated with a K/VDELIM */
if|if
condition|(
name|c
operator|==
name|VDELIM
condition|)
block|{
comment|/* try to find closing KDELIM, and replace value */
name|tlim
operator|=
name|keyval
operator|.
name|string
operator|+
name|keyval
operator|.
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ds
condition|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|cachegeteof
argument_list|(
argument|c
argument_list|,
argument|goto keystring_eof;
argument_list|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|KDELIM
condition|)
break|break;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tlim
operator|<=
name|tp
condition|)
name|tp
operator|=
name|bufenlarge
argument_list|(
operator|&
name|keyval
argument_list|,
operator|&
name|tlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|ds
condition|)
block|{
comment|/*skip next SDELIM */
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string before closing KDELIM or newline */
name|nextc
operator|=
name|c
expr_stmt|;
goto|goto
name|keystring_eof
goto|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|!=
name|KDELIM
condition|)
block|{
comment|/* couldn't find closing KDELIM -- give up */
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|aputs
argument_list|(
name|keyval
operator|.
name|string
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
comment|/* last c handled properly */
block|}
block|}
comment|/* now put out the new keyword value */
name|keyreplace
argument_list|(
name|matchresult
argument_list|,
name|delta
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|e
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|keystring_eof
label|:
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|aputs
argument_list|(
name|keyval
operator|.
name|string
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|uncache_exit
label|:
name|uncache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
name|r
operator|+
name|e
return|;
block|}
end_block

begin_decl_stmt
name|char
specifier|const
name|ciklog
index|[
name|ciklogsize
index|]
init|=
literal|"checked in with -k by "
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|keyreplace
parameter_list|(
name|marker
parameter_list|,
name|delta
parameter_list|,
name|out
parameter_list|)
name|enum
name|markers
name|marker
decl_stmt|;
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* function: outputs the keyword value(s) corresponding to marker.  * Attributes are derived from delta.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|date
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|size_t
name|cs
decl_stmt|,
name|cw
decl_stmt|,
name|ls
decl_stmt|;
name|char
specifier|const
modifier|*
name|sp1
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
index|]
decl_stmt|;
name|int
name|RCSv
decl_stmt|;
name|sp
operator|=
name|Keyword
index|[
operator|(
name|int
operator|)
name|marker
index|]
expr_stmt|;
if|if
condition|(
name|Expand
operator|==
name|KEY_EXPAND
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%c%s%c"
argument_list|,
name|KDELIM
argument_list|,
name|sp
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
return|return;
block|}
name|date
operator|=
name|delta
operator|->
name|date
expr_stmt|;
name|RCSv
operator|=
name|RCSversion
expr_stmt|;
if|if
condition|(
name|Expand
operator|==
name|KEYVAL_EXPAND
operator|||
name|Expand
operator|==
name|KEYVALLOCK_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%c%s%c%c"
argument_list|,
name|KDELIM
argument_list|,
name|sp
argument_list|,
name|VDELIM
argument_list|,
name|marker
operator|==
name|Log
operator|&&
name|RCSv
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|?
literal|'\t'
else|:
literal|' '
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|marker
condition|)
block|{
case|case
name|Author
case|:
name|aputs
argument_list|(
name|delta
operator|->
name|author
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Date
case|:
name|aputs
argument_list|(
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * The FreeBSD keyword is identical to Id. 	 */
case|case
name|FreeBSD
case|:
case|case
name|Id
case|:
case|case
name|Header
case|:
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|marker
operator|==
name|Id
operator|||
name|marker
operator|==
name|FreeBSD
operator|||
name|RCSv
operator|<
name|VERSION
argument_list|(
literal|4
argument_list|)
condition|?
name|basename
argument_list|(
name|RCSfilename
argument_list|)
else|:
name|getfullRCSname
argument_list|()
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|RCSv
operator|==
name|VERSION
argument_list|(
literal|3
argument_list|)
operator|&&
name|delta
operator|->
name|lockedby
condition|?
literal|"Locked"
else|:
name|delta
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|lockedby
operator|!=
name|nil
condition|)
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSv
condition|)
block|{
if|if
condition|(
name|locker_expansion
operator|||
name|Expand
operator|==
name|KEYVALLOCK_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|" %s"
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RCSv
operator|==
name|VERSION
argument_list|(
literal|4
argument_list|)
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|" Locker: %s"
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
expr_stmt|;
break|break;
case|case
name|Locker
case|:
if|if
condition|(
name|delta
operator|->
name|lockedby
condition|)
if|if
condition|(
name|locker_expansion
operator|||
name|Expand
operator|==
name|KEYVALLOCK_EXPAND
operator|||
name|RCSv
operator|<=
name|VERSION
argument_list|(
literal|4
argument_list|)
condition|)
name|aputs
argument_list|(
name|delta
operator|->
name|lockedby
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Log
case|:
case|case
name|RCSfile
case|:
name|aputs
argument_list|(
name|basename
argument_list|(
name|RCSfilename
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Revision
case|:
name|aputs
argument_list|(
name|delta
operator|->
name|num
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Source
case|:
name|aputs
argument_list|(
name|getfullRCSname
argument_list|()
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|State
case|:
name|aputs
argument_list|(
name|delta
operator|->
name|state
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|Expand
operator|==
name|KEYVAL_EXPAND
operator|||
name|Expand
operator|==
name|KEYVALLOCK_EXPAND
condition|)
block|{
name|afputc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
name|KDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|marker
operator|==
name|Log
condition|)
block|{
name|sp
operator|=
name|delta
operator|->
name|log
operator|.
name|string
expr_stmt|;
name|ls
operator|=
name|delta
operator|->
name|log
operator|.
name|size
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|-
literal|1
operator|<=
name|ls
operator|&&
operator|!
name|memcmp
argument_list|(
name|sp
argument_list|,
name|ciklog
argument_list|,
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|cp
operator|=
name|Comment
operator|.
name|string
expr_stmt|;
name|cw
operator|=
name|cs
operator|=
name|Comment
operator|.
name|size
expr_stmt|;
name|awrite
argument_list|(
name|cp
argument_list|,
name|cs
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* oddity: 2 spaces between date and time, not 1 as usual */
name|sp1
operator|=
name|strchr
argument_list|(
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"Revision %s  %.*s %s  %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|,
call|(
name|int
call|)
argument_list|(
name|sp1
operator|-
name|datebuf
argument_list|)
argument_list|,
name|datebuf
argument_list|,
name|sp1
argument_list|,
name|delta
operator|->
name|author
argument_list|)
expr_stmt|;
comment|/* Do not include state: it may change and is not updated.  */
comment|/* Comment is the comment leader.  */
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSv
condition|)
for|for
control|(
init|;
name|cw
operator|&&
operator|(
name|cp
index|[
name|cw
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|cp
index|[
name|cw
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|;
operator|--
name|cw
control|)
empty_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|cp
argument_list|,
name|cw
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
break|break;
operator|--
name|ls
expr_stmt|;
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|awrite
argument_list|(
name|cp
operator|+
name|cw
argument_list|,
name|cs
operator|-
name|cw
argument_list|,
name|out
argument_list|)
expr_stmt|;
do|do
block|{
name|afputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
break|break;
operator|--
name|ls
expr_stmt|;
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|has_readlink
end_if

begin_function
specifier|static
name|int
name|resolve_symlink
parameter_list|(
name|L
parameter_list|)
name|struct
name|buf
modifier|*
name|L
decl_stmt|;
comment|/*  * If L is a symbolic link, resolve it to the name that it points to.  * If unsuccessful, set errno and yield -1.  * If it points to an existing file, yield 1.  * Otherwise, set errno=ENOENT and yield 0.  */
block|{
name|char
modifier|*
name|b
decl_stmt|,
name|a
index|[
name|SIZEABLE_PATH
index|]
decl_stmt|;
name|int
name|e
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
name|struct
name|buf
name|bigbuf
decl_stmt|;
name|unsigned
name|linkcount
init|=
name|MAXSYMLINKS
operator|+
literal|1
decl_stmt|;
name|b
operator|=
name|a
expr_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|bigbuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|readlink
argument_list|(
name|L
operator|->
name|string
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|r
operator|==
name|s
condition|)
block|{
name|bufalloc
argument_list|(
operator|&
name|bigbuf
argument_list|,
name|s
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|b
operator|=
name|bigbuf
operator|.
name|string
expr_stmt|;
name|s
operator|=
name|bigbuf
operator|.
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|--
name|linkcount
condition|)
block|{
name|errno
operator|=
name|ELOOP
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Splice symbolic link into L.  */
name|b
index|[
name|r
index|]
operator|=
literal|'\0'
expr_stmt|;
name|L
operator|->
name|string
index|[
name|ROOTPATH
argument_list|(
name|b
argument_list|)
condition|?
operator|(
name|size_t
operator|)
literal|0
else|:
name|dirlen
argument_list|(
name|L
operator|->
name|string
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bufscat
argument_list|(
name|L
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|errno
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|bigbuf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|ENXIO
case|:
case|case
name|EINVAL
case|:
return|return
literal|1
return|;
case|case
name|ENOENT
case|:
return|return
literal|0
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|RILE
modifier|*
name|rcswriteopen
parameter_list|(
name|RCSbuf
parameter_list|,
name|status
parameter_list|,
name|mustread
parameter_list|)
name|struct
name|buf
modifier|*
name|RCSbuf
decl_stmt|;
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
name|int
name|mustread
decl_stmt|;
comment|/*  * Create the lock file corresponding to RCSNAME.  * Then try to open RCSNAME for reading and yield its FILE* descriptor.  * Put its status into *STATUS too.  * MUSTREAD is true if the file must already exist, too.  * If all goes well, discard any previously acquired locks,  * and set frewrite to the FILE* descriptor of the lock file,  * which will eventually turn into the new RCS file.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|,
modifier|*
name|RCSname
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|RILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|,
name|exists
decl_stmt|,
name|fdesc
decl_stmt|,
name|previouslock
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|buf
modifier|*
name|dirt
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|previouslock
operator|=
name|frewrite
operator|!=
literal|0
expr_stmt|;
name|exists
operator|=
if|#
directive|if
name|has_readlink
name|resolve_symlink
argument_list|(
name|RCSbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|stat
argument_list|(
name|RCSbuf
operator|->
name|string
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|?
literal|1
else|:
name|errno
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exists
operator|<
operator|(
name|mustread
operator||
name|previouslock
operator|)
condition|)
comment|/* 		 * There's an unusual problem with the RCS file; 		 * or the RCS file doesn't exist, 		 * and we must read or we already have a lock elsewhere. 		 */
return|return
literal|0
return|;
name|RCSname
operator|=
name|RCSbuf
operator|->
name|string
expr_stmt|;
name|sp
operator|=
name|basename
argument_list|(
name|RCSname
argument_list|)
expr_stmt|;
name|l
operator|=
name|sp
operator|-
name|RCSname
expr_stmt|;
name|dirt
operator|=
operator|&
name|dirtfname
index|[
name|previouslock
index|]
expr_stmt|;
name|bufscpy
argument_list|(
name|dirt
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
name|tp
operator|=
name|dirt
operator|->
name|string
operator|+
name|l
expr_stmt|;
name|x
operator|=
name|rcssuffix
argument_list|(
name|RCSname
argument_list|)
expr_stmt|;
if|#
directive|if
name|has_readlink
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"symbolic link to non RCS filename `%s'"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|sp
operator|==
operator|*
name|x
condition|)
block|{
name|error
argument_list|(
literal|"RCS filename `%s' incompatible with suffix `%s'"
argument_list|,
name|sp
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Create a lock file whose name is a function of the RCS filename.  */
if|if
condition|(
operator|*
name|x
condition|)
block|{
comment|/* 		 * The suffix is nonempty. 		 * The lock filename is the first char of of the suffix, 		 * followed by the RCS filename with last char removed.  E.g.: 		 *	foo,v	RCS filename with suffix ,v 		 *	,foo,	lock filename 		 */
operator|*
name|tp
operator|++
operator|=
operator|*
name|x
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
operator|--
name|tp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The suffix is empty. 		 * The lock filename is the RCS filename 		 * with last char replaced by '_'. 		 */
while|while
condition|(
operator|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
operator|)
condition|)
empty_stmt|;
name|tp
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'_'
condition|)
block|{
name|error
argument_list|(
literal|"RCS filename `%s' ends with `%c'"
argument_list|,
name|RCSname
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|tp
operator|=
literal|'_'
expr_stmt|;
block|}
name|sp
operator|=
name|tp
operator|=
name|dirt
operator|->
name|string
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
comment|/* 	* good news: 	*	open(f, O_CREAT|O_EXCL|O_TRUNC|O_WRONLY, READONLY) is atomic 	*	according to Posix 1003.1-1990. 	* bad news: 	*	NFS ignores O_EXCL and doesn't comply with Posix 1003.1-1990. 	* good news: 	*	(O_TRUNC,READONLY) normally guarantees atomicity even with NFS. 	* bad news: 	*	If you're root, (O_TRUNC,READONLY) doesn't guarantee atomicity. 	* good news: 	*	Root-over-the-wire NFS access is rare for security reasons. 	*	This bug has never been reported in practice with RCS. 	* So we don't worry about this bug. 	* 	* An even rarer NFS bug can occur when clients retry requests. 	* Suppose client A renames the lock file ",f," to "f,v" 	* at about the same time that client B creates ",f,", 	* and suppose A's first rename request is delayed, so A reissues it. 	* The sequence of events might be: 	*	A sends rename(",f,", "f,v") 	*	B sends create(",f,") 	*	A sends retry of rename(",f,", "f,v") 	*	server receives, does, and acknowledges A's first rename() 	*	A receives acknowledgment, and its RCS program exits 	*	server receives, does, and acknowledges B's create() 	*	server receives, does, and acknowledges A's retry of rename() 	* This not only wrongly deletes B's lock, it removes the RCS file! 	* Most NFS implementations have idempotency caches that usually prevent 	* this scenario, but such caches are finite and can be overrun. 	* This problem afflicts programs that use the traditional 	* Unix method of using link() and unlink() to get and release locks, 	* as well as RCS's method of using open() and rename(). 	* There is no easy workaround for either link-unlink or open-rename. 	* Any new method based on lockf() seemingly would be incompatible with 	* the old methods; besides, lockf() is notoriously buggy under NFS. 	* Since this problem afflicts scads of Unix programs, but is so rare 	* that nobody seems to be worried about it, we won't worry either. 	*/
define|#
directive|define
name|READONLY
value|(S_IRUSR|S_IRGRP|S_IROTH)
if|#
directive|if
operator|!
name|open_can_creat
define|#
directive|define
name|create
parameter_list|(
name|f
parameter_list|)
value|creat(f, READONLY)
else|#
directive|else
define|#
directive|define
name|create
parameter_list|(
name|f
parameter_list|)
value|open(f, O_BINARY|O_CREAT|O_EXCL|O_TRUNC|O_WRONLY, READONLY)
endif|#
directive|endif
name|catchints
argument_list|()
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
comment|/* 	 * Create a lock file for an RCS file.  This should be atomic, i.e. 	 * if two processes try it simultaneously, at most one should succeed. 	 */
name|seteid
argument_list|()
expr_stmt|;
name|fdesc
operator|=
name|create
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|fdesc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|EACCES
operator|&&
name|stat
argument_list|(
name|tp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
comment|/* The RCS file is busy.  */
name|e
operator|=
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
name|dirtfmaker
index|[
literal|0
index|]
operator|=
name|effective
expr_stmt|;
name|e
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|f
operator|=
name|Iopen
argument_list|(
name|RCSname
argument_list|,
name|FOPEN_R
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|previouslock
condition|)
block|{
comment|/* Discard the previous lock in favor of this one.  */
name|Ozclose
argument_list|(
operator|&
name|frewrite
argument_list|)
expr_stmt|;
name|seteid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|un_link
argument_list|(
name|newRCSfilename
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|e
operator|=
name|errno
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|enfaterror
argument_list|(
name|e
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|dirtfname
index|[
literal|0
index|]
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|frewrite
operator|=
name|fdopen
argument_list|(
name|fdesc
argument_list|,
name|FOPEN_W
argument_list|)
operator|)
condition|)
block|{
name|efaterror
argument_list|(
name|newRCSfilename
argument_list|)
expr_stmt|;
block|}
block|}
name|restoreints
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|void
name|keepdirtemp
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
comment|/* Do not unlink name, either because it's not there any more,  * or because it has already been unlinked.  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|DIRTEMPNAMES
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|dirtfname
index|[
name|i
index|]
operator|.
name|string
operator|==
name|name
condition|)
block|{
name|dirtfmaker
index|[
name|i
index|]
operator|=
name|notmade
expr_stmt|;
return|return;
block|}
name|faterror
argument_list|(
literal|"keepdirtemp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|makedirtemp
parameter_list|(
name|name
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/*  * Have maketemp() do all the work if name is null.  * Otherwise, create a unique filename in name's dir using n and name  * and store it into the dirtfname[n].  * Because of storage in tfnames, dirtempunlink() can unlink the file later.  * Return a pointer to the filename created.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|register
name|size_t
name|dl
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bn
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|maketemp
argument_list|(
name|n
argument_list|)
return|;
name|dl
operator|=
name|dirlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bn
operator|=
operator|&
name|dirtfname
index|[
name|n
index|]
expr_stmt|;
name|bufalloc
argument_list|(
name|bn
argument_list|,
if|#
directive|if
name|has_mktemp
name|dl
operator|+
literal|9
else|#
directive|else
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
name|bn
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|np
operator|=
name|tp
operator|=
name|bn
operator|->
name|string
expr_stmt|;
name|tp
operator|+=
name|dl
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'0'
operator|+
name|n
expr_stmt|;
name|catchints
argument_list|()
expr_stmt|;
if|#
directive|if
name|has_mktemp
name|VOID
name|strcpy
argument_list|(
name|tp
argument_list|,
literal|"XXXXXX"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mktemp
argument_list|(
name|np
argument_list|)
operator|||
operator|!
operator|*
name|np
condition|)
name|faterror
argument_list|(
literal|"can't make temporary file name `%.*s%c_%cXXXXXX'"
argument_list|,
operator|(
name|int
operator|)
name|dl
argument_list|,
name|name
argument_list|,
name|SLASH
argument_list|,
literal|'0'
operator|+
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * Posix 1003.1-1990 has no reliable way 		 * to create a unique file in a named directory. 		 * We fudge here.  If the working file name is abcde, 		 * the temp filename is _Ncde where N is a digit. 		 */
name|name
operator|+=
name|dl
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
name|name
operator|++
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|tp
argument_list|,
name|name
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|dirtfmaker
index|[
name|n
index|]
operator|=
name|real
expr_stmt|;
return|return
name|np
return|;
block|}
end_function

begin_function
name|void
name|dirtempunlink
parameter_list|()
comment|/* Clean up makedirtemp() files.  May be invoked by signal handler. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|enum
name|maker
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|DIRTEMPNAMES
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
operator|(
name|m
operator|=
name|dirtfmaker
index|[
name|i
index|]
operator|)
operator|!=
name|notmade
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|effective
condition|)
name|seteid
argument_list|()
expr_stmt|;
name|VOID
name|un_link
argument_list|(
name|dirtfname
index|[
name|i
index|]
operator|.
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|effective
condition|)
name|setrid
argument_list|()
expr_stmt|;
name|dirtfmaker
index|[
name|i
index|]
operator|=
name|notmade
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
if|#
directive|if
name|has_prototypes
name|chnamemod
parameter_list|(
name|FILE
modifier|*
modifier|*
name|fromp
parameter_list|,
name|char
specifier|const
modifier|*
name|from
parameter_list|,
name|char
specifier|const
modifier|*
name|to
parameter_list|,
name|mode_t
name|mode
parameter_list|)
comment|/* The `#if has_prototypes' is needed because mode_t might promote to int.  */
else|#
directive|else
function|chnamemod
parameter_list|(
name|fromp
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|mode
parameter_list|)
name|FILE
modifier|*
modifier|*
name|fromp
decl_stmt|;
name|char
specifier|const
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Rename a file (with optional stream pointer *FROMP) from FROM to TO.  * FROM already exists.  * Change its mode to MODE, before renaming if possible.  * If FROMP, close and clear *FROMP before renaming it.  * Unlink TO if it already exists.  * Return -1 on error (setting errno), 0 otherwise.  */
end_comment

begin_block
block|{
if|#
directive|if
name|bad_a_rename
comment|/* 		 * This host is brain damaged.  A race condition is possible 		 * while the lock file is temporarily writable. 		 * There doesn't seem to be a workaround. 		 */
name|mode_t
name|mode_while_renaming
init|=
name|mode
operator||
name|S_IWUSR
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|mode_while_renaming
value|mode
endif|#
directive|endif
if|if
condition|(
name|fromp
condition|)
block|{
if|#
directive|if
name|has_fchmod
if|if
condition|(
name|fchmod
argument_list|(
name|fileno
argument_list|(
operator|*
name|fromp
argument_list|)
argument_list|,
name|mode_while_renaming
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
name|Ozclose
argument_list|(
name|fromp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|has_fchmod
elseif|else
endif|#
directive|endif
if|if
condition|(
name|chmod
argument_list|(
name|from
argument_list|,
name|mode_while_renaming
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
operator|!
name|has_rename
operator|||
name|bad_b_rename
name|VOID
name|un_link
parameter_list|(
name|to
parameter_list|)
function_decl|;
comment|/* 		 * We need not check the result; 		 * link() or rename() will catch it. 		 * No harm is done if TO does not exist. 		 * However, there's a short window of inconsistency 		 * during which TO does not exist. 		 */
endif|#
directive|endif
return|return
if|#
directive|if
operator|!
name|has_rename
name|do_link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
name|un_link
argument_list|(
argument|from
argument_list|)
else|#
directive|else
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|!=
literal|0
if|#
directive|if
name|has_NFS
operator|&&
name|errno
operator|!=
name|ENOENT
endif|#
directive|endif
condition|?
operator|-
literal|1
if|#
directive|if
name|bad_a_rename
else|:
name|mode
operator|!=
name|mode_while_renaming
condition|?
name|chmod
argument_list|(
name|to
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
else|:
literal|0
endif|#
directive|endif
return|;
undef|#
directive|undef
name|mode_while_renaming
block|}
end_block

begin_function
name|int
name|findlock
parameter_list|(
name|delete
parameter_list|,
name|target
parameter_list|)
name|int
name|delete
decl_stmt|;
name|struct
name|hshentry
modifier|*
modifier|*
name|target
decl_stmt|;
comment|/*  * Find the first lock held by caller and return a pointer  * to the locked delta; also removes the lock if DELETE.  * If one lock, put it into *TARGET.  * Return 0 for no locks, 1 for one, 2 for two or more.  */
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|trail
decl_stmt|,
modifier|*
modifier|*
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|trail
operator|=
operator|&
name|Locks
init|;
operator|(
name|next
operator|=
operator|*
name|trail
operator|)
condition|;
name|trail
operator|=
operator|&
name|next
operator|->
name|nextlock
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
name|error
argument_list|(
literal|"multiple revisions locked by %s; please specify one"
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|found
operator|=
name|trail
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|0
return|;
name|next
operator|=
operator|*
name|found
expr_stmt|;
operator|*
name|target
operator|=
name|next
operator|->
name|delta
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
operator|*
name|found
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|addlock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
comment|/*  * Add a lock held by caller to DELTA and yield 1 if successful.  * Print an error message and yield -1 if no lock is added because  * DELTA is locked by somebody other than caller.  * Return 0 if the caller already holds the lock.  */
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|Locks
expr_stmt|;
for|for
control|(
name|next
operator|=
name|Locks
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|nextlock
control|)
if|if
condition|(
name|cmpnum
argument_list|(
name|delta
operator|->
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|error
argument_list|(
literal|"revision %s already locked by %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|next
operator|=
name|ftalloc
argument_list|(
expr|struct
name|lock
argument_list|)
expr_stmt|;
name|delta
operator|->
name|lockedby
operator|=
name|next
operator|->
name|login
operator|=
name|getcaller
argument_list|()
expr_stmt|;
name|next
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
name|next
operator|->
name|nextlock
operator|=
name|Locks
expr_stmt|;
name|Locks
operator|=
name|next
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|addsymbol
parameter_list|(
name|num
parameter_list|,
name|name
parameter_list|,
name|rebind
parameter_list|)
name|char
specifier|const
modifier|*
name|num
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|rebind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Associate with revision NUM the new symbolic NAME.  * If NAME already exists and REBIND is set, associate NAME with NUM;  * otherwise, print an error message and return false;  * Return true if successful.  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|assoc
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|Symbols
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|nextassoc
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|next
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|rebind
operator|||
name|strcmp
argument_list|(
name|next
operator|->
name|num
argument_list|,
name|num
argument_list|)
operator|==
literal|0
condition|)
block|{
name|next
operator|->
name|num
operator|=
name|num
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"symbolic name %s already bound to %s"
argument_list|,
name|name
argument_list|,
name|next
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|next
operator|=
name|ftalloc
argument_list|(
expr|struct
name|assoc
argument_list|)
expr_stmt|;
name|next
operator|->
name|symbol
operator|=
name|name
expr_stmt|;
name|next
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|next
operator|->
name|nextassoc
operator|=
name|Symbols
expr_stmt|;
name|Symbols
operator|=
name|next
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_function
name|char
specifier|const
modifier|*
name|getcaller
parameter_list|()
comment|/* Get the caller's login name.  */
block|{
if|#
directive|if
name|has_setuid
return|return
name|getusername
argument_list|(
name|euid
argument_list|()
operator|!=
name|ruid
argument_list|()
argument_list|)
return|;
else|#
directive|else
return|return
name|getusername
argument_list|(
name|false
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|checkaccesslist
parameter_list|()
comment|/*  * Return true if caller is the superuser, the owner of the  * file, the access list is empty, or caller is on the access list.  * Otherwise, print an error message and return false.  */
block|{
specifier|register
name|struct
name|access
specifier|const
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|AccessList
operator|||
name|myself
argument_list|(
name|RCSstat
operator|.
name|st_uid
argument_list|)
operator|||
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|next
operator|=
name|AccessList
expr_stmt|;
do|do
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
do|while
condition|(
operator|(
name|next
operator|=
name|next
operator|->
name|nextaccess
operator|)
condition|)
do|;
name|error
argument_list|(
literal|"user %s not on the access list"
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|int
name|dorewrite
parameter_list|(
name|lockflag
parameter_list|,
name|changed
parameter_list|)
name|int
name|lockflag
decl_stmt|,
name|changed
decl_stmt|;
comment|/*  * Do nothing if LOCKFLAG is zero.  * Prepare to rewrite an RCS file if CHANGED is positive.  * Stop rewriting if CHANGED is zero, because there won't be any changes.  * Fail if CHANGED is negative.  * Return true on success.  */
block|{
name|int
name|r
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
name|lockflag
condition|)
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|changed
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|putadmin
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|frewrite
argument_list|,
literal|"\n\n%s%c"
argument_list|,
name|Kdesc
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|foutptr
operator|=
name|frewrite
expr_stmt|;
block|}
else|else
block|{
name|Ozclose
argument_list|(
operator|&
name|frewrite
argument_list|)
expr_stmt|;
name|seteid
argument_list|()
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|un_link
argument_list|(
name|newRCSfilename
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|newRCSfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|enerror
argument_list|(
name|e
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|donerewrite
parameter_list|(
name|changed
parameter_list|)
name|int
name|changed
decl_stmt|;
comment|/*  * Finish rewriting an RCS file if CHANGED is nonzero.  * Return true on success.  */
block|{
name|int
name|r
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
name|changed
operator|&&
operator|!
name|nerror
condition|)
block|{
if|if
condition|(
name|finptr
condition|)
block|{
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|<
name|RCSstat
operator|.
name|st_nlink
condition|)
name|warn
argument_list|(
literal|"breaking hard link to %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|seteid
argument_list|()
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|chnamemod
argument_list|(
operator|&
name|frewrite
argument_list|,
name|newRCSfilename
argument_list|,
name|RCSfilename
argument_list|,
name|RCSstat
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|newRCSfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|enerror
argument_list|(
name|e
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"saved in %s"
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|aflush
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|fflush
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

