begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS file input  */
end_comment

begin_comment
comment|/*********************************************************************************  *                     Lexical Analysis.  *                     hashtable, Lexinit, nextlex, getlex, getkey,  *                     getid, getnum, readstring, printstring, savestring,  *                     checkid, fatserror, error, faterror, warn, diagnose  *                     Testprogram: define LEXDB  *********************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcslex.c,v $  * Revision 1.1.1.1  1993/06/18  04:22:12  jkh  * Updated GNU utilities  *  * Revision 5.11  1991/11/03  03:30:44  eggert  * Fix porting bug to ancient hosts lacking vfprintf.  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Support piece tables even if !has_mmap.  *  * Revision 5.9  1991/09/24  00:28:42  eggert  * Don't export errsay().  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Add eoflex(), mmap support.  Tune.  *  * Revision 5.7  1991/04/21  11:58:26  eggert  * Add MS-DOS support.  *  * Revision 5.6  1991/02/25  07:12:42  eggert  * Work around fputs bug.  strsave -> str_save (DG/UX name clash)  *  * Revision 5.5  1990/12/04  05:18:47  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.4  1990/11/19  20:05:28  hammer  * no longer gives warning about unknown keywords if -q is specified  *  * Revision 5.3  1990/11/01  05:03:48  eggert  * When ignoring unknown phrases, copy them to the output RCS file.  *  * Revision 5.2  1990/09/04  08:02:27  eggert  * Count RCS lines better.  *  * Revision 5.1  1990/08/29  07:14:03  eggert  * Work around buggy compilers with defective argument promotion.  *  * Revision 5.0  1990/08/22  08:12:55  eggert  * Remove compile-time limits; use malloc instead.  * Report errno-related errors with perror().  * Ansify and Posixate.  Add support for ISO 8859.  * Use better hash function.  *  * Revision 4.6  89/05/01  15:13:07  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.5  88/08/28  15:01:12  eggert  * Don't loop when writing error messages to a full filesystem.  * Flush stderr/stdout when mixing output.  * Yield exit status compatible with diff(1).  * Shrink stdio code size; allow cc -R; remove lint.  *   * Revision 4.4  87/12/18  11:44:47  narten  * fixed to use "varargs" in "fprintf"; this is required if it is to  * work on a SPARC machine such as a Sun-4  *   * Revision 4.3  87/10/18  10:37:18  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to version 4.1  *   * Revision 1.3  87/09/24  14:00:17  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:33  jenkins  * Port to suns  *   * Revision 4.1  83/03/25  18:12:51  wft  * Only changed $Header to $Id.  *   * Revision 3.3  82/12/10  16:22:37  wft  * Improved error messages, changed exit status on error to 1.  *  * Revision 3.2  82/11/28  21:27:10  wft  * Renamed ctab to map and included EOFILE; ctab is now a macro in rcsbase.h.  * Added fflsbuf(), fputs(), and fprintf(), which abort the RCS operations  * properly in case there is an IO-error (e.g., file system full).  *  * Revision 3.1  82/10/11  19:43:56  wft  * removed unused label out:;  * made sure all calls to getc() return into an integer, not a char.  */
end_comment

begin_comment
comment|/* #define LEXDB */
end_comment

begin_comment
comment|/* version LEXDB is for testing the lexical analyzer. The testprogram  * reads a stream of lexemes, enters the revision numbers into the  * hashtable, and prints the recognized tokens. Keywords are recognized  * as identifiers.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|lexId
argument_list|,
literal|"$Id: rcslex.c,v 1.1.1.1 1993/06/18 04:22:12 jkh Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|nexthsh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*pointer to next hash entry, set by lookup*/
end_comment

begin_decl_stmt
name|enum
name|tokens
name|nexttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next token, set by nextlex                    */
end_comment

begin_decl_stmt
name|int
name|hshenter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*if true, next suitable lexeme will be entered */
end_comment

begin_comment
comment|/*into the symbol table. Handle with care.      */
end_comment

begin_decl_stmt
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next input character, initialized by Lexinit  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|rcsline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current line-number of input		    */
end_comment

begin_decl_stmt
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*counter for errors                            */
end_comment

begin_decl_stmt
name|int
name|quietflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*indicates quiet mode                          */
end_comment

begin_decl_stmt
name|RILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*input file descriptor			    */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*file descriptor for echoing input             */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|foutptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy of frewrite, but 0 to suppress echo  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf
name|tokbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token buffer				    */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|NextString
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next token				    */
end_comment

begin_comment
comment|/*  * Our hash algorithm is h[0] = 0, h[i+1] = 4*h[i] + c,  * so hshsize should be odd.  * See B J McKenzie, R Harries& T Bell, Selecting a hashing algorithm,  * Software--practice& experience 20, 2 (Feb 1990), 209-224.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|hshsize
end_ifndef

begin_define
define|#
directive|define
name|hshsize
value|511
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|hshtab
index|[
name|hshsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*hashtable			    */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignored_phrases
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* have we ignored phrases in this RCS file? */
end_comment

begin_function
name|void
name|warnignore
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|ignored_phrases
operator||
name|quietflag
operator|)
condition|)
block|{
name|ignored_phrases
operator|=
name|true
expr_stmt|;
name|warn
argument_list|(
literal|"Unknown phrases like `%s ...;' are in the RCS file."
argument_list|,
name|NextString
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lookup
parameter_list|(
name|str
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
comment|/* Function: Looks up the character string pointed to by str in the  * hashtable. If the string is not present, a new entry for it is created.  * In any case, the address of the corresponding hashtable entry is placed  * into nexthsh.  */
block|{
specifier|register
name|unsigned
name|ihash
decl_stmt|;
comment|/* index into hashtable */
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* calculate hash code */
name|sp
operator|=
name|str
expr_stmt|;
name|ihash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
name|ihash
operator|=
operator|(
name|ihash
operator|<<
literal|2
operator|)
operator|+
operator|*
name|sp
operator|++
expr_stmt|;
name|ihash
operator|%=
name|hshsize
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|hshtab
index|[
name|ihash
index|]
init|;
condition|;
name|p
operator|=
operator|&
name|n
operator|->
name|nexthsh
control|)
if|if
condition|(
operator|!
operator|(
name|n
operator|=
operator|*
name|p
operator|)
condition|)
block|{
comment|/* empty slot found */
operator|*
name|p
operator|=
name|n
operator|=
name|ftalloc
argument_list|(
expr|struct
name|hshentry
argument_list|)
expr_stmt|;
name|n
operator|->
name|num
operator|=
name|fstr_save
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|n
operator|->
name|nexthsh
operator|=
name|nil
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDB
name|VOID
name|printf
argument_list|(
literal|"\nEntered: %s at %u "
argument_list|,
name|str
argument_list|,
name|ihash
argument_list|)
decl_stmt|;
endif|#
directive|endif
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|n
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
comment|/* match found */
break|break;
name|nexthsh
operator|=
name|n
expr_stmt|;
name|NextString
operator|=
name|n
operator|->
name|num
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Lexinit
parameter_list|()
comment|/* Function: Initialization of lexical analyzer:  * initializes the hashtable,  * initializes nextc, nexttok if finptr != 0  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|hshsize
init|;
literal|0
operator|<=
operator|--
name|c
condition|;
control|)
block|{
name|hshtab
index|[
name|c
index|]
operator|=
name|nil
expr_stmt|;
block|}
name|nerror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|finptr
condition|)
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
name|hshenter
operator|=
name|true
expr_stmt|;
name|ignored_phrases
operator|=
name|false
expr_stmt|;
name|rcsline
operator|=
literal|1
expr_stmt|;
name|bufrealloc
argument_list|(
operator|&
name|tokbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Iget
argument_list|(
name|finptr
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
comment|/*initial token*/
block|}
block|}
end_function

begin_function
name|void
name|nextlex
parameter_list|()
comment|/* Function: Reads the next token and sets nexttok to the next token code.  * Only if hshenter is set, a revision number is entered into the  * hashtable and a pointer to it is placed into nexthsh.  * This is useful for avoiding that dates are placed into the hashtable.  * For ID's and NUM's, NextString is set to the character string.  * Assumption: nextc contains the next character.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|char
specifier|const
modifier|*
name|limit
decl_stmt|;
specifier|register
name|enum
name|tokens
name|d
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
index|]
operator|)
condition|)
block|{
default|default:
name|fatserror
argument_list|(
literal|"unknown character `%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDB
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note: falls into next case */
case|case
name|SPACE
case|:
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DIGIT
case|:
name|sp
operator|=
name|tokbuf
operator|.
name|string
expr_stmt|;
name|limit
operator|=
name|sp
operator|+
name|tokbuf
operator|.
name|size
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
index|]
operator|)
operator|!=
name|DIGIT
operator|&&
name|d
operator|!=
name|PERIOD
condition|)
break|break;
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* 1.2. and 1.2 are different */
if|if
condition|(
name|limit
operator|<=
name|sp
condition|)
name|sp
operator|=
name|bufenlarge
argument_list|(
operator|&
name|tokbuf
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
block|}
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hshenter
condition|)
name|lookup
argument_list|(
name|tokbuf
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|NextString
operator|=
name|fstr_save
argument_list|(
name|tokbuf
operator|.
name|string
argument_list|)
expr_stmt|;
name|d
operator|=
name|NUM
expr_stmt|;
break|break;
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
name|sp
operator|=
name|tokbuf
operator|.
name|string
expr_stmt|;
name|limit
operator|=
name|sp
operator|+
name|tokbuf
operator|.
name|size
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
index|]
operator|)
operator|!=
name|LETTER
operator|&&
name|d
operator|!=
name|Letter
operator|&&
name|d
operator|!=
name|DIGIT
operator|&&
name|d
operator|!=
name|IDCHAR
condition|)
break|break;
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
name|sp
condition|)
name|sp
operator|=
name|bufenlarge
argument_list|(
operator|&
name|tokbuf
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
block|}
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
name|NextString
operator|=
name|fstr_save
argument_list|(
name|tokbuf
operator|.
name|string
argument_list|)
expr_stmt|;
name|d
operator|=
name|ID
expr_stmt|;
comment|/* may be ID or keyword */
break|break;
case|case
name|SBEGIN
case|:
comment|/* long string */
name|d
operator|=
name|STRING
expr_stmt|;
comment|/* note: only the initial SBEGIN has been read*/
comment|/* read the string, and reset nextc afterwards*/
break|break;
case|case
name|COLON
case|:
case|case
name|SEMI
case|:
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|nexttok
operator|=
name|d
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eoflex
parameter_list|()
comment|/*  * Yield true if we look ahead to the end of the input, false otherwise.  * nextc becomes undefined at end of file.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|fout
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
default|default:
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
case|case
name|SPACE
case|:
name|cachegeteof
argument_list|(
argument|c
argument_list|,
argument|{uncache(fin);return true;}
argument_list|)
empty_stmt|;
break|break;
block|}
if|if
condition|(
name|fout
condition|)
name|aputc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|getlex
parameter_list|(
name|token
parameter_list|)
name|enum
name|tokens
name|token
decl_stmt|;
comment|/* Function: Checks if nexttok is the same as token. If so,  * advances the input by calling nextlex and returns true.  * otherwise returns false.  * Doesn't work for strings and keywords; loses the character string for ids.  */
block|{
if|if
condition|(
name|nexttok
operator|==
name|token
condition|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|int
name|getkeyopt
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Function: If the current token is a keyword identical to key,  * advances the input by calling nextlex and returns true;  * otherwise returns false.  */
block|{
if|if
condition|(
name|nexttok
operator|==
name|ID
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|NextString
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* match found */
name|ffree1
argument_list|(
name|NextString
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|void
name|getkey
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Check that the current input token is a keyword identical to key,  * and advance the input by calling nextlex.  */
block|{
if|if
condition|(
operator|!
name|getkeyopt
argument_list|(
name|key
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"missing '%s' keyword"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getkeystring
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Check that the current input token is a keyword identical to key,  * and advance the input by calling nextlex; then look ahead for a string.  */
block|{
name|getkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttok
operator|!=
name|STRING
condition|)
name|fatserror
argument_list|(
literal|"missing string after '%s' keyword"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|getid
parameter_list|()
comment|/* Function: Checks if nexttok is an identifier. If so,  * advances the input by calling nextlex and returns a pointer  * to the identifier; otherwise returns nil.  * Treats keywords as identifiers.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|ID
condition|)
block|{
name|name
operator|=
name|NextString
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
name|name
return|;
block|}
else|else
return|return
name|nil
return|;
block|}
end_function

begin_function
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
comment|/* Function: Checks if nexttok is a number. If so,  * advances the input by calling nextlex and returns a pointer  * to the hashtable entry. Otherwise returns nil.  * Doesn't work if hshenter is false.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|num
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|NUM
condition|)
block|{
name|num
operator|=
name|nexthsh
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
name|num
return|;
block|}
else|else
return|return
name|nil
return|;
block|}
end_function

begin_function
name|struct
name|cbuf
name|getphrases
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Get a series of phrases that do not start with KEY, yield resulting buffer.  * Stop when the next phrase starts with a token that is not an identifier,  * or is KEY.  * Assume !foutptr.  */
block|{
name|declarecache
expr_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|limit
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|ki
decl_stmt|,
modifier|*
name|kn
decl_stmt|;
name|struct
name|cbuf
name|r
decl_stmt|;
name|struct
name|buf
name|b
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
if|if
condition|(
name|nexttok
operator|!=
name|ID
operator|||
name|strcmp
argument_list|(
name|NextString
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|.
name|string
operator|=
literal|0
expr_stmt|;
name|r
operator|.
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
name|warnignore
argument_list|()
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|b
argument_list|,
name|NextString
argument_list|)
expr_stmt|;
name|ffree1
argument_list|(
name|NextString
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|.
name|string
operator|+
name|strlen
argument_list|(
name|b
operator|.
name|string
argument_list|)
expr_stmt|;
name|limit
operator|=
name|b
operator|.
name|string
operator|+
name|b
operator|.
name|size
expr_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|limit
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
default|default:
name|fatserror
argument_list|(
literal|"unknown character `%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
case|case
name|COLON
case|:
case|case
name|DIGIT
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
case|case
name|PERIOD
case|:
case|case
name|SPACE
case|:
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SBEGIN
case|:
comment|/* long string */
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|limit
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
default|default:
continue|continue;
case|case
name|SDELIM
case|:
break|break;
block|}
break|break;
block|}
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
break|break;
if|if
condition|(
name|limit
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
continue|continue;
case|case
name|SEMI
case|:
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctab
index|[
name|c
index|]
operator|==
name|NEWLN
condition|)
block|{
operator|++
name|rcsline
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|NEWLN
case|:
operator|++
name|rcsline
expr_stmt|;
comment|/* fall into */
case|case
name|SPACE
case|:
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
break|break;
block|}
break|break;
block|}
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
for|for
control|(
name|kn
operator|=
name|key
init|;
name|c
operator|&&
operator|*
name|kn
operator|==
name|c
condition|;
name|kn
operator|++
control|)
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|kn
condition|)
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|DIGIT
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
break|break;
default|default:
name|nextc
operator|=
name|c
expr_stmt|;
name|NextString
operator|=
name|fstr_save
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|nexttok
operator|=
name|ID
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
goto|goto
name|returnit
goto|;
block|}
for|for
control|(
name|ki
operator|=
name|key
init|;
name|ki
operator|<
name|kn
condition|;
control|)
block|{
if|if
condition|(
name|limit
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|ki
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
goto|goto
name|returnit
goto|;
block|}
block|}
name|returnit
label|:
return|return
name|bufremember
argument_list|(
operator|&
name|b
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|b
operator|.
name|string
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|readstring
parameter_list|()
comment|/* skip over characters until terminating single SDELIM        */
comment|/* If foutptr is set, copy every character read to foutptr.    */
comment|/* Does not advance nextlex at the end.                        */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|printstring
parameter_list|()
comment|/* Function: copy a string to stdout, until terminated with a single SDELIM.  * Does not advance nextlex at the end.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|fout
operator|=
name|stdout
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|aputc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|cbuf
name|savestring
parameter_list|(
name|target
parameter_list|)
name|struct
name|buf
modifier|*
name|target
decl_stmt|;
comment|/* Copies a string terminated with SDELIM from file finptr to buffer target.  * Double SDELIM is replaced with SDELIM.  * If foutptr is set, the string is also copied unchanged to foutptr.  * Does not advance nextlex at the end.  * Yield a copy of *TARGET, except with exact length.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|char
specifier|const
modifier|*
name|limit
decl_stmt|;
name|struct
name|cbuf
name|r
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|tp
operator|=
name|target
operator|->
name|string
expr_stmt|;
name|limit
operator|=
name|tp
operator|+
name|target
operator|->
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|rcsline
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC
argument_list|(
name|frew
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|r
operator|.
name|string
operator|=
name|target
operator|->
name|string
expr_stmt|;
name|r
operator|.
name|size
operator|=
name|tp
operator|-
name|r
operator|.
name|string
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
break|break;
block|}
if|if
condition|(
name|tp
operator|==
name|limit
condition|)
name|tp
operator|=
name|bufenlarge
argument_list|(
name|target
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|checkid
parameter_list|(
name|id
parameter_list|,
name|delimiter
parameter_list|)
specifier|register
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|delimiter
decl_stmt|;
comment|/*   Function:  check whether the string starting at id is an   */
comment|/*		identifier and return a pointer to the delimiter*/
comment|/*		after the identifier.  White space, delim and 0 */
comment|/*              are legal delimiters.  Aborts the program if not*/
comment|/*              a legal identifier. Useful for checking commands*/
comment|/*		If !delim, the only delimiter is 0.		*/
block|{
specifier|register
name|enum
name|tokens
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|tc
decl_stmt|;
specifier|register
name|char
name|delim
init|=
name|delimiter
decl_stmt|;
name|temp
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|=
operator|*
name|id
argument_list|)
index|]
operator|)
operator|==
name|LETTER
operator|||
name|d
operator|==
name|Letter
condition|)
block|{
while|while
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|=
operator|*
operator|++
name|id
argument_list|)
index|]
operator|)
operator|==
name|LETTER
operator|||
name|d
operator|==
name|Letter
operator|||
name|d
operator|==
name|DIGIT
operator|||
name|d
operator|==
name|IDCHAR
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|&&
operator|(
operator|!
name|delim
operator|||
name|c
operator|!=
name|delim
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|)
condition|)
block|{
comment|/* append \0 to end of id before error message */
name|tc
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|id
operator|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
empty_stmt|;
operator|*
name|id
operator|=
literal|'\0'
expr_stmt|;
name|faterror
argument_list|(
literal|"invalid character %c in identifier `%s'"
argument_list|,
name|tc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* append \0 to end of id before error message */
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|id
operator|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
empty_stmt|;
operator|*
name|id
operator|=
literal|'\0'
expr_stmt|;
name|faterror
argument_list|(
literal|"identifier `%s' doesn't start with letter"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_function
name|void
name|checksid
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
comment|/* Check whether the string ID is an identifier.  */
block|{
name|VOID
name|checkid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
specifier|static
name|RILE
modifier|*
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
name|fd2_RILE
parameter_list|(
name|fd
parameter_list|,
name|filename
parameter_list|,
name|status
parameter_list|)
else|#
directive|else
function|fd2RILE
parameter_list|(
name|fd
parameter_list|,
name|filename
parameter_list|,
name|mode
parameter_list|,
name|status
parameter_list|)
name|char
specifier|const
modifier|*
name|mode
decl_stmt|;
endif|#
directive|endif
name|int
name|fd
decl_stmt|;
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|status
operator|=
operator|&
name|st
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
name|status
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|status
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is not a regular file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|VOID
name|close
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|#
directive|if
operator|!
operator|(
name|has_mmap
operator|&&
name|large_memory
operator|)
name|FILE
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|large_memory
return|return
name|stream
return|;
else|#
directive|else
define|#
directive|define
name|RILES
value|3
block|{
specifier|static
name|RILE
name|rilebuf
index|[
name|RILES
index|]
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|s
init|=
name|status
operator|->
name|st_size
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|status
operator|->
name|st_size
condition|)
name|faterror
argument_list|(
literal|"`%s' is enormous"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|rilebuf
init|;
name|f
operator|->
name|base
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|f
operator|==
name|rilebuf
operator|+
name|RILES
condition|)
name|faterror
argument_list|(
literal|"too many RILEs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
specifier|static
name|unsigned
name|char
name|dummy
decl_stmt|;
name|f
operator|->
name|base
operator|=
operator|&
name|dummy
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|has_mmap
if|if
condition|(
operator|(
name|f
operator|->
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|s
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|efaterror
argument_list|(
literal|"mmap"
argument_list|)
expr_stmt|;
else|#
directive|else
name|f
operator|->
name|base
operator|=
name|tnalloc
argument_list|(
argument|unsigned char
argument_list|,
argument|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|f
operator|->
name|ptr
operator|=
name|f
operator|->
name|base
expr_stmt|;
name|f
operator|->
name|lim
operator|=
name|f
operator|->
name|base
operator|+
name|s
expr_stmt|;
if|#
directive|if
name|has_mmap
name|f
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
else|#
directive|else
name|f
operator|->
name|readlim
operator|=
name|f
operator|->
name|base
expr_stmt|;
name|f
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
endif|#
directive|endif
name|if_advise_access
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|has_mmap
operator|&&
name|large_memory
end_if

begin_function
name|int
name|Igetmore
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|fread_type
name|r
decl_stmt|;
specifier|register
name|size_t
name|s
init|=
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|readlim
decl_stmt|;
if|if
condition|(
name|BUFSIZ
operator|<
name|s
condition|)
name|s
operator|=
name|BUFSIZ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|Fread
argument_list|(
name|f
operator|->
name|readlim
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|readlim
argument_list|)
argument_list|,
name|s
argument_list|,
name|f
operator|->
name|stream
argument_list|)
operator|)
condition|)
block|{
name|testIerror
argument_list|(
name|f
operator|->
name|stream
argument_list|)
expr_stmt|;
name|f
operator|->
name|lim
operator|=
name|f
operator|->
name|readlim
expr_stmt|;
comment|/* The file might have shrunk!  */
return|return
literal|0
return|;
block|}
name|f
operator|->
name|readlim
operator|+=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_madvise
operator|&&
name|has_mmap
operator|&&
name|large_memory
end_if

begin_function
name|void
name|advise_access
parameter_list|(
name|f
parameter_list|,
name|advice
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
name|int
name|advice
decl_stmt|;
block|{
if|if
condition|(
name|madvise
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|base
argument_list|)
argument_list|,
name|advice
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"madvise"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|RILE
modifier|*
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
name|I_open
parameter_list|(
name|filename
parameter_list|,
name|status
parameter_list|)
else|#
directive|else
function|Iopen
parameter_list|(
name|filename
parameter_list|,
name|mode
parameter_list|,
name|status
parameter_list|)
name|char
specifier|const
modifier|*
name|mode
decl_stmt|;
endif|#
directive|endif
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
comment|/* Open FILENAME for reading, yield its descriptor, and set *STATUS.  */
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
return|return
name|fd2_RILE
argument_list|(
name|fd
argument_list|,
name|filename
argument_list|,
name|status
argument_list|)
return|;
else|#
directive|else
return|return
name|fd2RILE
argument_list|(
name|fd
argument_list|,
name|filename
argument_list|,
name|mode
argument_list|,
name|status
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_define
define|#
directive|define
name|Iclose
parameter_list|(
name|f
parameter_list|)
value|fclose(f)
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|Iclose
parameter_list|(
name|f
parameter_list|)
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
if|#
directive|if
name|has_mmap
name|size_t
name|s
init|=
name|f
operator|->
name|lim
operator|-
name|f
operator|->
name|base
decl_stmt|;
if|if
condition|(
name|s
operator|&&
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|base
argument_list|,
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|f
operator|->
name|base
operator|=
literal|0
expr_stmt|;
return|return
name|close
argument_list|(
name|f
operator|->
name|fd
argument_list|)
return|;
else|#
directive|else
name|tfree
argument_list|(
name|f
operator|->
name|base
argument_list|)
expr_stmt|;
name|f
operator|->
name|base
operator|=
literal|0
expr_stmt|;
return|return
name|fclose
argument_list|(
name|f
operator|->
name|stream
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|Oerrloop
decl_stmt|;
end_decl_stmt

begin_function
name|exiting
name|void
name|Oerror
parameter_list|()
block|{
if|if
condition|(
name|Oerrloop
condition|)
name|exiterr
argument_list|()
expr_stmt|;
name|Oerrloop
operator|=
name|true
expr_stmt|;
name|efaterror
argument_list|(
literal|"output error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|exiting
name|void
name|Ieof
parameter_list|()
block|{
name|fatserror
argument_list|(
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|exiting
name|void
name|Ierror
parameter_list|()
block|{
name|efaterror
argument_list|(
literal|"input error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testIerror
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|Ierror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testOerror
parameter_list|(
name|o
parameter_list|)
name|FILE
modifier|*
name|o
decl_stmt|;
block|{
if|if
condition|(
name|ferror
argument_list|(
name|o
argument_list|)
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ifclose
parameter_list|(
name|f
parameter_list|)
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
name|Iclose
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FSYNC_ALL
end_ifndef

begin_function
name|void
name|Ofclose
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
name|fclose
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|Ofclose
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
operator|(
name|fflush
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
operator|||
name|fsync
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|fclose
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|Izclose
parameter_list|(
name|p
parameter_list|)
name|RILE
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|Ifclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Ozclose
parameter_list|(
name|p
parameter_list|)
name|FILE
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|Ofclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_function
name|void
name|testIeof
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|testIerror
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|Ieof
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Irewind
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|eflush
parameter_list|()
block|{
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|Oerrloop
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|oflush
parameter_list|()
block|{
if|if
condition|(
name|fflush
argument_list|(
name|workstdout
condition|?
name|workstdout
else|:
name|stdout
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|Oerrloop
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|exiting
name|void
name|fatcleanup
parameter_list|(
name|already_newline
parameter_list|)
name|int
name|already_newline
decl_stmt|;
block|{
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|already_newline
operator|+
literal|"\n%s aborted\n"
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|exiterr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|errsay
parameter_list|()
block|{
name|oflush
argument_list|()
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: "
argument_list|,
name|cmdid
argument_list|)
expr_stmt|;
name|nerror
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatsay
parameter_list|()
block|{
name|oflush
argument_list|()
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: "
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|eerror
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|enerror
argument_list|(
name|errno
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enerror
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
name|int
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|errsay
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|exiting
name|void
name|efaterror
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|enfaterror
argument_list|(
name|errno
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|exiting
name|void
name|enfaterror
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
name|int
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|fatsay
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|error
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|error
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-fatal error */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|errsay
argument_list|()
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|exiting
name|void
name|fatserror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|exiting
name|void
name|fatserror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fatal syntax error */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|oflush
argument_list|()
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s:%lu: "
argument_list|,
name|cmdid
argument_list|,
name|RCSfilename
argument_list|,
name|rcsline
argument_list|)
decl_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|exiting
name|void
name|faterror
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|exiting
name|void
name|faterror
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fatal error, terminates program after cleanup */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|fatsay
argument_list|()
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|warn
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|warn
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prints a warning message */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|oflush
argument_list|()
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s warning: "
argument_list|,
name|cmdid
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|void
name|redefined
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|warn
argument_list|(
literal|"redefinition of -%c option"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_decl_stmt
name|void
name|diagnose
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|diagnose
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prints a diagnostic message */
end_comment

begin_comment
comment|/* Unlike the other routines, it does not append a newline. */
end_comment

begin_comment
comment|/* This lets some callers suppress the newline, and is faster */
end_comment

begin_comment
comment|/* in implementations that flush stderr just at the end of each printf. */
end_comment

begin_block
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|afputc
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
comment|/* Function: afputc(c,f) acts like aputc(c,f), but is smaller and slower.  */
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|aputc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aputs
parameter_list|(
name|s
parameter_list|,
name|iop
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|iop
decl_stmt|;
comment|/* Function: Put string s on file iop, abort on error.  */
block|{
if|#
directive|if
name|has_fputs
if|if
condition|(
name|fputs
argument_list|(
name|s
argument_list|,
name|iop
argument_list|)
operator|<
literal|0
condition|)
name|Oerror
argument_list|()
expr_stmt|;
else|#
directive|else
name|awrite
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|iop
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
if|#
directive|if
name|has_prototypes
name|fvfprintf
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|char
specifier|const
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
else|#
directive|else
function|fvfprintf
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
comment|/* like vfprintf, except abort program on error */
block|{
if|#
directive|if
name|has_vfprintf
if|if
condition|(
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|#
directive|if
name|has__doprintf
name|_doprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has__doprnt
name|_doprnt
argument_list|(
name|format
argument_list|,
name|args
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
modifier|*
name|a
init|=
operator|(
name|int
operator|*
operator|)
name|args
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
endif|#
directive|endif
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_function
name|void
name|aprintf
parameter_list|(
name|FILE
modifier|*
name|iop
parameter_list|,
name|char
specifier|const
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|void aprintf
parameter_list|(
name|iop
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|FILE
modifier|*
name|iop
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* Function: formatted output. Same as fprintf in stdio,  * but aborts program on error  */
block|{
name|va_list
name|ap
decl_stmt|;
name|vararg_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|iop
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LEXDB
end_ifdef

begin_comment
comment|/* test program reading a stream of lexemes and printing the tokens.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|cmdid
operator|=
literal|"lextest"
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|aputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|finptr
operator|=
name|Iopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|FOPEN_R
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"can't open input file %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|eoflex
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|nexttok
condition|)
block|{
case|case
name|ID
case|:
name|VOID
name|printf
argument_list|(
literal|"ID: %s"
argument_list|,
name|NextString
argument_list|)
decl_stmt|;
break|break;
case|case
name|NUM
case|:
if|if
condition|(
name|hshenter
condition|)
name|VOID
name|printf
argument_list|(
literal|"NUM: %s, index: %d"
argument_list|,
name|nexthsh
operator|->
name|num
argument_list|,
name|nexthsh
operator|-
name|hshtab
argument_list|)
decl_stmt|;
else|else
name|VOID
name|printf
argument_list|(
literal|"NUM, unentered: %s"
argument_list|,
name|NextString
argument_list|)
decl_stmt|;
name|hshenter
operator|=
operator|!
name|hshenter
expr_stmt|;
comment|/*alternate between dates and numbers*/
break|break;
case|case
name|COLON
case|:
name|VOID
name|printf
argument_list|(
literal|"COLON"
argument_list|)
decl_stmt|;
break|break;
case|case
name|SEMI
case|:
name|VOID
name|printf
argument_list|(
literal|"SEMI"
argument_list|)
decl_stmt|;
break|break;
case|case
name|STRING
case|:
name|readstring
argument_list|()
expr_stmt|;
name|VOID
name|printf
argument_list|(
literal|"STRING"
argument_list|)
decl_stmt|;
break|break;
case|case
name|UNKN
case|:
name|VOID
name|printf
argument_list|(
literal|"UNKN"
argument_list|)
decl_stmt|;
break|break;
default|default:
name|VOID
name|printf
argument_list|(
literal|"DEFAULT"
argument_list|)
decl_stmt|;
break|break;
block|}
name|VOID
name|printf
argument_list|(
literal|" | "
argument_list|)
decl_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
name|exitmain
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

