begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                       RLOG    operation  */
end_comment

begin_comment
comment|/*****************************************************************************  *                       print contents of RCS files  *****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rlog.c,v $  * Revision 1.4  1994/05/12  00:37:59  phk  * made -v produce tip-revision, which was what I wanted in the first place...  *  * Revision 1.3  1994/05/11  22:39:44  phk  * Added -v option to rlog.  This gives a quick way to get a list of versions.  *  * Revision 1.2  1993/08/06  16:47:16  nate  * Have rlog output be much easier to parse.  (Added one line which is not  * used by any CVS/RCS commands)  *  * Revision 1.1.1.1  1993/06/18  04:22:17  jkh  * Updated GNU utilities  *  * Revision 5.9  1991/09/17  19:07:40  eggert  * Getscript() didn't uncache partial lines.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Revision separator is `:', not `-'.  * Check for missing and duplicate logs.  Tune.  * Permit log messages that do not end in newline (including empty logs).  *  * Revision 5.7  1991/04/21  11:58:31  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.6  1991/02/26  17:07:17  eggert  * Survive RCS files with missing logs.  * strsave -> str_save (DG/UX name clash)  *  * Revision 5.5  1990/11/01  05:03:55  eggert  * Permit arbitrary data in logs and comment leaders.  *  * Revision 5.4  1990/10/04  06:30:22  eggert  * Accumulate exit status across files.  *  * Revision 5.3  1990/09/11  02:41:16  eggert  * Plug memory leak.  *  * Revision 5.2  1990/09/04  08:02:33  eggert  * Count RCS lines better.  *  * Revision 5.0  1990/08/22  08:13:48  eggert  * Remove compile-time limits; use malloc instead.  Add setuid support.  * Switch to GMT.  * Report dates in long form, to warn about dates past 1999/12/31.  * Change "added/del" message to make room for the longer dates.  * Don't generate trailing white space.  Add -V.  Ansify and Posixate.  *  * Revision 4.7  89/05/01  15:13:48  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.6  88/08/09  19:13:28  eggert  * Check for memory exhaustion; don't access freed storage.  * Shrink stdio code size; remove lint.  *   * Revision 4.5  87/12/18  11:46:38  narten  * more lint cleanups (Guy Harris)  *   * Revision 4.4  87/10/18  10:41:12  narten  * Updating version numbers  * Changes relative to 1.1 actually relative to 4.2  *   * Revision 1.3  87/09/24  14:01:10  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:45  jenkins  * Port to suns  *   * Revision 4.2  83/12/05  09:18:09  wft  * changed rewriteflag to external.  *   * Revision 4.1  83/05/11  16:16:55  wft  * Added -b, updated getnumericrev() accordingly.  * Replaced getpwuid() with getcaller().  *   * Revision 3.7  83/05/11  14:24:13  wft  * Added options -L and -R;  * Fixed selection bug with -l on multiple files.  * Fixed error on dates of the form -d'>date' (rewrote getdatepair()).  *   * Revision 3.6  82/12/24  15:57:53  wft  * shortened output format.  *  * Revision 3.5  82/12/08  21:45:26  wft  * removed call to checkaccesslist(); used DATEFORM to format all dates;  * removed unused variables.  *  * Revision 3.4  82/12/04  13:26:25  wft  * Replaced getdelta() with gettree(); removed updating of field lockedby.  *  * Revision 3.3  82/12/03  14:08:20  wft  * Replaced getlogin with getpwuid(), %02d with %.2d, fancydate with PRINTDATE.  * Fixed printing of nil, removed printing of Suffix,  * added shortcut if no revisions are printed, disambiguated struct members.  *  * Revision 3.2  82/10/18  21:09:06  wft  * call to curdir replaced with getfullRCSname(),  * fixed call to getlogin(), cosmetic changes on output,  * changed conflicting long identifiers.  *  * Revision 3.1  82/10/13  16:07:56  wft  * fixed type of variables receiving from getc() (char -> int).  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_struct
struct|struct
name|lockers
block|{
comment|/* lockers in locker option; stored   */
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
comment|/* lockerlist			    */
name|struct
name|lockers
modifier|*
name|lockerlink
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stateattri
block|{
comment|/* states in state option; stored in  */
name|char
specifier|const
modifier|*
name|status
decl_stmt|;
comment|/* statelist			    */
name|struct
name|stateattri
modifier|*
name|nextstate
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|authors
block|{
comment|/* login names in author option;      */
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
comment|/* stored in authorlist		    */
name|struct
name|authors
modifier|*
name|nextauthor
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Revpairs
block|{
comment|/* revision or branch range in -r     */
name|unsigned
name|numfld
decl_stmt|;
comment|/* option; stored in revlist	    */
name|char
specifier|const
modifier|*
name|strtrev
decl_stmt|;
name|char
specifier|const
modifier|*
name|endrev
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|rnext
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Datepairs
block|{
comment|/* date range in -d option; stored in */
name|char
name|strtdate
index|[
name|datesize
index|]
decl_stmt|;
comment|/* duelst and datelist      */
name|char
name|enddate
index|[
name|datesize
index|]
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|dnext
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|extractdelta
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkrevpair
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
specifier|const
modifier|*
name|readdeltalog
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|extdate
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exttree
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getauthor
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getdatepair
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getlocker
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getnumericrev
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getrevpairs
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getscript
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getstate
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putabranch
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putadelta
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putforest
name|P
argument_list|(
operator|(
expr|struct
name|branchhead
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putree
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putrunk
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recentdate
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
expr|struct
name|Datepairs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trunclocks
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|insDelFormat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|branchflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*set on -b */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Datepairs
modifier|*
name|datelist
decl_stmt|,
modifier|*
name|duelst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Revpairs
modifier|*
name|revlist
decl_stmt|,
modifier|*
name|Revlst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|authors
modifier|*
name|authorlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lockers
modifier|*
name|lockerlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stateattri
modifier|*
name|statelist
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rlogId
argument_list|,
literal|"rlog"
argument_list|,
literal|"$Id: rlog.c,v 1.4 1994/05/12 00:37:59 phk Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrlog usage: rlog -{bhLRt} [-v[string]] -ddates -l[lockers] -rrevs -sstates -w[logins] -Vn file ..."
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|currdate
decl_stmt|;
name|char
specifier|const
modifier|*
name|accessListString
decl_stmt|,
modifier|*
name|accessFormat
decl_stmt|,
modifier|*
name|commentFormat
decl_stmt|;
name|char
specifier|const
modifier|*
name|headFormat
decl_stmt|,
modifier|*
name|symbolFormat
decl_stmt|;
name|struct
name|access
specifier|const
modifier|*
name|curaccess
decl_stmt|;
name|struct
name|assoc
specifier|const
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|struct
name|lock
specifier|const
modifier|*
name|currlock
decl_stmt|;
name|int
name|descflag
decl_stmt|,
name|selectflag
decl_stmt|;
name|int
name|onlylockflag
decl_stmt|;
comment|/* print only files with locks */
name|int
name|versionlist
decl_stmt|;
name|char
modifier|*
name|vstring
decl_stmt|;
name|int
name|onlyRCSflag
decl_stmt|;
comment|/* print only RCS file name */
name|unsigned
name|revno
decl_stmt|;
name|descflag
operator|=
name|selectflag
operator|=
name|true
expr_stmt|;
name|versionlist
operator|=
name|onlylockflag
operator|=
name|onlyRCSflag
operator|=
name|false
expr_stmt|;
name|vstring
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|stdout
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
name|onlylockflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|onlyRCSflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lockflag
operator|=
name|true
expr_stmt|;
name|getlocker
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|branchflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|getrevpairs
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|getdatepair
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|getstate
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|getauthor
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|descflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|selectflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* This has no effect; it's here for consistency.  */
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|setRCSversion
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|versionlist
operator|=
name|true
expr_stmt|;
name|vstring
operator|=
name|a
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end of option processing */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|descflag
operator||
name|selectflag
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"-t overrides -h."
argument_list|)
expr_stmt|;
name|descflag
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|)
block|{
name|accessListString
operator|=
literal|"\naccess list:   "
expr_stmt|;
name|accessFormat
operator|=
literal|"  %s"
expr_stmt|;
name|commentFormat
operator|=
literal|"\ncomment leader:  \""
expr_stmt|;
name|headFormat
operator|=
literal|"\nRCS file:        %s;   Working file:    %s\nhead:           %s%s\nbranch:         %s%s\nlocks:         "
expr_stmt|;
name|insDelFormat
operator|=
literal|"  lines added/del: %lu/%lu"
expr_stmt|;
name|symbolFormat
operator|=
literal|"  %s: %s;"
expr_stmt|;
block|}
else|else
block|{
name|accessListString
operator|=
literal|"\naccess list:"
expr_stmt|;
name|accessFormat
operator|=
literal|"\n\t%s"
expr_stmt|;
name|commentFormat
operator|=
literal|"\ncomment leader: \""
expr_stmt|;
name|headFormat
operator|=
literal|"\nRCS file: %s\nWorking file: %s\nhead:%s%s\nbranch:%s%s\nlocks:%s"
expr_stmt|;
name|insDelFormat
operator|=
literal|"  lines: +%lu -%lu"
expr_stmt|;
name|symbolFormat
operator|=
literal|"\n\t%s: %s"
expr_stmt|;
block|}
comment|/* now handle all filenames */
do|do
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|/* now RCSfilename contains the name of the RCS file, and finptr              * the file descriptor. Workfilename contains the name of the              * working file.              */
comment|/* Keep only those locks given by -l.  */
if|if
condition|(
name|lockflag
condition|)
name|trunclocks
argument_list|()
expr_stmt|;
comment|/* do nothing if -L is given and there are no locks*/
if|if
condition|(
name|onlylockflag
operator|&&
operator|!
name|Locks
condition|)
continue|continue;
if|if
condition|(
name|versionlist
condition|)
block|{
name|gettree
argument_list|()
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%s%s %s\n"
argument_list|,
name|vstring
argument_list|,
name|workfilename
argument_list|,
name|tiprev
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|onlyRCSflag
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*   print RCS filename , working filename and optional                  administrative information                         */
comment|/* could use getfullRCSname() here, but that is very slow */
name|aprintf
argument_list|(
name|out
argument_list|,
name|headFormat
argument_list|,
name|RCSfilename
argument_list|,
name|workfilename
argument_list|,
name|Head
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|Head
condition|?
name|Head
operator|->
name|num
else|:
literal|""
argument_list|,
name|Dbranch
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|Dbranch
condition|?
name|Dbranch
else|:
literal|""
argument_list|,
name|StrictLocks
condition|?
literal|" strict"
else|:
literal|""
argument_list|)
expr_stmt|;
name|currlock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|currlock
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
name|symbolFormat
argument_list|,
name|currlock
operator|->
name|login
argument_list|,
name|currlock
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|currlock
operator|=
name|currlock
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|StrictLocks
operator|&&
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|)
name|aputs
argument_list|(
literal|"  strict"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
name|accessListString
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/*  print access list  */
name|curaccess
operator|=
name|AccessList
expr_stmt|;
while|while
condition|(
name|curaccess
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
name|accessFormat
argument_list|,
name|curaccess
operator|->
name|login
argument_list|)
expr_stmt|;
name|curaccess
operator|=
name|curaccess
operator|->
name|nextaccess
expr_stmt|;
block|}
name|aputs
argument_list|(
literal|"\nsymbolic names:"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/*  print symbolic names   */
for|for
control|(
name|curassoc
operator|=
name|Symbols
init|;
name|curassoc
condition|;
name|curassoc
operator|=
name|curassoc
operator|->
name|nextassoc
control|)
name|aprintf
argument_list|(
name|out
argument_list|,
name|symbolFormat
argument_list|,
name|curassoc
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|num
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
name|commentFormat
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|Comment
operator|.
name|string
argument_list|,
name|Comment
operator|.
name|size
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"\"\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
operator|||
name|Expand
operator|!=
name|KEYVAL_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"keyword substitution: %s\n"
argument_list|,
name|expand_names
index|[
name|Expand
index|]
argument_list|)
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"total revisions: %u"
argument_list|,
name|TotalDeltas
argument_list|)
expr_stmt|;
name|revno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Head
operator|&&
name|selectflag
operator|&
name|descflag
condition|)
block|{
name|getnumericrev
argument_list|()
expr_stmt|;
comment|/* get numeric revision or branch names */
name|exttree
argument_list|(
name|Head
argument_list|)
expr_stmt|;
comment|/*  get most recently date of the dates pointed by duelst  */
name|currdate
operator|=
name|duelst
expr_stmt|;
while|while
condition|(
name|currdate
condition|)
block|{
name|VOID
name|sprintf
argument_list|(
name|currdate
operator|->
name|strtdate
argument_list|,
name|DATEFORM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|recentdate
argument_list|(
name|Head
argument_list|,
name|currdate
argument_list|)
expr_stmt|;
name|currdate
operator|=
name|currdate
operator|->
name|dnext
expr_stmt|;
block|}
name|revno
operator|=
name|extdate
argument_list|(
name|Head
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|";\tselected revisions: %u"
argument_list|,
name|revno
argument_list|)
expr_stmt|;
block|}
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|descflag
condition|)
block|{
name|aputs
argument_list|(
literal|"description:\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|getdesc
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|revno
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|delta
operator|=
name|readdeltalog
argument_list|()
operator|)
operator|->
name|selector
operator|||
operator|--
name|revno
condition|)
empty_stmt|;
if|if
condition|(
name|delta
operator|->
name|next
operator|&&
name|countnumflds
argument_list|(
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|2
condition|)
comment|/* Read through delta->next to get its insertlns.  */
while|while
condition|(
name|readdeltalog
argument_list|()
operator|!=
name|delta
operator|->
name|next
condition|)
empty_stmt|;
name|putrunk
argument_list|()
expr_stmt|;
name|putree
argument_list|(
name|Head
argument_list|)
expr_stmt|;
block|}
name|aputs
argument_list|(
literal|"----------------------------\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"=============================================================================\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|Ofclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|rlogExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putrunk
parameter_list|()
comment|/*  function:  print revisions chosen, which are in trunk      */
block|{
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|Head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|putadelta
argument_list|(
name|ptr
argument_list|,
name|ptr
operator|->
name|next
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putree
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
comment|/*   function: print delta tree (not including trunk) in reverse                order on each branch                                        */
block|{
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
name|putree
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|putforest
argument_list|(
name|root
operator|->
name|branches
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putforest
parameter_list|(
name|branchroot
parameter_list|)
name|struct
name|branchhead
specifier|const
modifier|*
name|branchroot
decl_stmt|;
comment|/*   function:  print branches that has the same direct ancestor    */
block|{
if|if
condition|(
name|branchroot
operator|==
name|nil
condition|)
return|return;
name|putforest
argument_list|(
name|branchroot
operator|->
name|nextbranch
argument_list|)
expr_stmt|;
name|putabranch
argument_list|(
name|branchroot
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|putree
argument_list|(
name|branchroot
operator|->
name|hsh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putabranch
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
comment|/*   function  :  print one branch     */
block|{
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
name|putabranch
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|putadelta
argument_list|(
name|root
argument_list|,
name|root
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putadelta
parameter_list|(
name|node
parameter_list|,
name|editscript
parameter_list|,
name|trunk
parameter_list|)
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|node
decl_stmt|,
decl|*
name|editscript
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|trunk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function: Print delta node if node->selector is set.        */
end_comment

begin_comment
comment|/*      editscript indicates where the editscript is stored     */
end_comment

begin_comment
comment|/*      trunk indicated whether this node is in trunk           */
end_comment

begin_block
block|{
specifier|static
name|char
name|emptych
index|[]
init|=
name|EMPTYLOG
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
name|struct
name|buf
name|branchnum
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|selector
condition|)
return|return;
name|out
operator|=
name|stdout
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"----------------------------\nrevision %s"
argument_list|,
name|node
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|lockedby
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"\tlocked by: %s;"
argument_list|,
name|node
operator|->
name|lockedby
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"\ndate: %s;  author: %s;  state: %s;"
argument_list|,
name|date2str
argument_list|(
name|node
operator|->
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
name|node
operator|->
name|author
argument_list|,
name|node
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|editscript
condition|)
if|if
condition|(
name|trunk
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
name|insDelFormat
argument_list|,
name|editscript
operator|->
name|deletelns
argument_list|,
name|editscript
operator|->
name|insertlns
argument_list|)
expr_stmt|;
else|else
name|aprintf
argument_list|(
name|out
argument_list|,
name|insDelFormat
argument_list|,
name|editscript
operator|->
name|insertlns
argument_list|,
name|editscript
operator|->
name|deletelns
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|node
operator|->
name|branches
expr_stmt|;
if|if
condition|(
name|newbranch
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"\nbranches:"
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|getbranchno
argument_list|(
name|newbranch
operator|->
name|hsh
operator|->
name|num
argument_list|,
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"  %s;"
argument_list|,
name|branchnum
operator|.
name|string
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
name|bufautoend
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
block|}
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|s
operator|=
name|node
operator|->
name|log
operator|.
name|string
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|=
name|node
operator|->
name|log
operator|.
name|size
operator|)
condition|)
block|{
name|s
operator|=
name|emptych
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|emptych
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|awrite
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|struct
name|hshentry
specifier|const
modifier|*
name|readdeltalog
parameter_list|()
comment|/*  Function : get the log message and skip the text of a deltatext node.  *	       Return the delta found.  *             Assumes the current lexeme is not yet in nexttok; does not  *             advance nexttok.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
name|struct
name|buf
name|logbuf
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
if|if
condition|(
name|eoflex
argument_list|()
condition|)
name|fatserror
argument_list|(
literal|"missing delta log"
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
name|fatserror
argument_list|(
literal|"delta number corrupted"
argument_list|)
expr_stmt|;
name|getkeystring
argument_list|(
name|Klog
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delta
operator|->
name|log
operator|.
name|string
condition|)
name|fatserror
argument_list|(
literal|"duplicate delta log"
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|logbuf
argument_list|)
expr_stmt|;
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|logbuf
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|log
operator|=
name|bufremember
argument_list|(
operator|&
name|logbuf
argument_list|,
name|cb
operator|.
name|size
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
while|while
condition|(
name|nexttok
operator|==
name|ID
operator|&&
name|strcmp
argument_list|(
name|NextString
argument_list|,
name|Ktext
argument_list|)
operator|!=
literal|0
condition|)
name|ignorephrase
argument_list|()
expr_stmt|;
name|getkeystring
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|insertlns
operator|=
name|Delta
operator|->
name|deletelns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Delta
operator|!=
name|Head
condition|)
name|getscript
argument_list|(
name|Delta
argument_list|)
expr_stmt|;
else|else
name|readstring
argument_list|()
expr_stmt|;
return|return
name|Delta
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getscript
parameter_list|(
name|Delta
parameter_list|)
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
comment|/*   function:  read edit script of Delta and count how many lines added  */
comment|/*              and deleted in the script                                 */
block|{
name|int
name|ed
decl_stmt|;
comment|/*  editor command  */
name|declarecache
expr_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|long
name|i
decl_stmt|;
name|struct
name|diffcmd
name|dc
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|initdiffcmd
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|(
name|ed
operator|=
name|getdiffcmd
argument_list|(
name|fin
argument_list|,
name|true
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|dc
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
name|ed
condition|)
name|Delta
operator|->
name|deletelns
operator|+=
name|dc
operator|.
name|nlines
expr_stmt|;
else|else
block|{
comment|/*  skip scripted lines  */
name|i
operator|=
name|dc
operator|.
name|nlines
expr_stmt|;
name|Delta
operator|->
name|insertlns
operator|+=
name|i
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
continue|continue;
case|case
name|SDELIM
case|:
name|cacheget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
continue|continue;
if|if
condition|(
operator|--
name|i
condition|)
name|fatserror
argument_list|(
literal|"unexpected end to edit script"
argument_list|)
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\n'
case|:
break|break;
block|}
break|break;
block|}
operator|++
name|rcsline
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exttree
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
comment|/*  function: select revisions , starting with root             */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
name|root
operator|->
name|selector
operator|=
name|extractdelta
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|->
name|log
operator|.
name|string
operator|=
name|nil
expr_stmt|;
name|exttree
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|exttree
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getlocker
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*   function : get the login names of lockers from command line   */
comment|/*              and store in lockerlist.                           */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|lockers
modifier|*
name|newlocker
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|lockerlist
operator|=
name|nil
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newlocker
operator|=
name|talloc
argument_list|(
expr|struct
name|lockers
argument_list|)
expr_stmt|;
name|newlocker
operator|->
name|lockerlink
operator|=
name|lockerlist
expr_stmt|;
name|newlocker
operator|->
name|login
operator|=
name|argv
expr_stmt|;
name|lockerlist
operator|=
name|newlocker
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getauthor
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*   function:  get the author's name from command line   */
comment|/*              and store in authorlist                   */
block|{
specifier|register
name|c
expr_stmt|;
name|struct
name|authors
modifier|*
name|newauthor
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|authorlist
operator|=
name|talloc
argument_list|(
expr|struct
name|authors
argument_list|)
expr_stmt|;
name|authorlist
operator|->
name|login
operator|=
name|getusername
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|authorlist
operator|->
name|nextauthor
operator|=
name|nil
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newauthor
operator|=
name|talloc
argument_list|(
expr|struct
name|authors
argument_list|)
expr_stmt|;
name|newauthor
operator|->
name|nextauthor
operator|=
name|authorlist
expr_stmt|;
name|newauthor
operator|->
name|login
operator|=
name|argv
expr_stmt|;
name|authorlist
operator|=
name|newauthor
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getstate
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*   function :  get the states of revisions from command line  */
comment|/*               and store in statelist                         */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|stateattri
modifier|*
name|newstate
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|warn
argument_list|(
literal|"missing state attributes after -s options"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newstate
operator|=
name|talloc
argument_list|(
expr|struct
name|stateattri
argument_list|)
expr_stmt|;
name|newstate
operator|->
name|nextstate
operator|=
name|statelist
expr_stmt|;
name|newstate
operator|->
name|status
operator|=
name|argv
expr_stmt|;
name|statelist
operator|=
name|newstate
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trunclocks
parameter_list|()
comment|/*  Function:  Truncate the list of locks to those that are held by the  */
comment|/*             id's on lockerlist. Do not truncate if lockerlist empty.  */
block|{
name|struct
name|lockers
specifier|const
modifier|*
name|plocker
decl_stmt|;
name|struct
name|lock
modifier|*
name|plocked
decl_stmt|,
modifier|*
name|nextlocked
decl_stmt|;
if|if
condition|(
operator|(
name|lockerlist
operator|==
name|nil
operator|)
operator|||
operator|(
name|Locks
operator|==
name|nil
operator|)
condition|)
return|return;
comment|/* shorten Locks to those contained in lockerlist */
name|plocked
operator|=
name|Locks
expr_stmt|;
name|Locks
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|plocked
operator|!=
name|nil
condition|)
block|{
name|plocker
operator|=
name|lockerlist
expr_stmt|;
while|while
condition|(
operator|(
name|plocker
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|plocker
operator|->
name|login
argument_list|,
name|plocked
operator|->
name|login
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|plocker
operator|=
name|plocker
operator|->
name|lockerlink
expr_stmt|;
name|nextlocked
operator|=
name|plocked
operator|->
name|nextlock
expr_stmt|;
if|if
condition|(
name|plocker
operator|!=
name|nil
condition|)
block|{
name|plocked
operator|->
name|nextlock
operator|=
name|Locks
expr_stmt|;
name|Locks
operator|=
name|plocked
expr_stmt|;
block|}
name|plocked
operator|=
name|nextlocked
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|recentdate
parameter_list|(
name|root
parameter_list|,
name|pd
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|pd
decl_stmt|;
comment|/*  function:  Finds the delta that is closest to the cutoff date given by   */
comment|/*             pd among the revisions selected by exttree.                   */
comment|/*             Successively narrows down the interval given by pd,           */
comment|/*             and sets the strtdate of pd to the date of the selected delta */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
if|if
condition|(
name|root
operator|->
name|selector
condition|)
block|{
if|if
condition|(
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pd
operator|->
name|strtdate
argument_list|)
operator|>=
literal|0
operator|&&
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pd
operator|->
name|enddate
argument_list|)
operator|<=
literal|0
condition|)
name|VOID
name|strcpy
argument_list|(
name|pd
operator|->
name|strtdate
argument_list|,
name|root
operator|->
name|date
argument_list|)
decl_stmt|;
block|}
name|recentdate
argument_list|(
name|root
operator|->
name|next
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|recentdate
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|extdate
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
comment|/*  function:  select revisions which are in the date range specified     */
comment|/*             in duelst  and datelist, start at root                     */
comment|/* Yield number of revisions selected, including those already selected.  */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
name|struct
name|Datepairs
specifier|const
modifier|*
name|pdate
decl_stmt|;
name|unsigned
name|revno
decl_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|datelist
operator|||
name|duelst
condition|)
block|{
name|pdate
operator|=
name|datelist
expr_stmt|;
while|while
condition|(
name|pdate
condition|)
block|{
if|if
condition|(
operator|(
name|pdate
operator|->
name|strtdate
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pdate
operator|->
name|strtdate
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pdate
operator|->
name|enddate
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|cmpnum
argument_list|(
name|pdate
operator|->
name|enddate
argument_list|,
name|root
operator|->
name|date
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
name|pdate
operator|=
name|pdate
operator|->
name|dnext
expr_stmt|;
block|}
if|if
condition|(
name|pdate
operator|==
name|nil
condition|)
block|{
name|pdate
operator|=
name|duelst
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|pdate
condition|)
block|{
name|root
operator|->
name|selector
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pdate
operator|->
name|strtdate
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pdate
operator|=
name|pdate
operator|->
name|dnext
expr_stmt|;
block|}
block|}
block|}
name|revno
operator|=
name|root
operator|->
name|selector
operator|+
name|extdate
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|revno
operator|+=
name|extdate
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
return|return
name|revno
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|extractdelta
parameter_list|(
name|pdelta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|pdelta
decl_stmt|;
comment|/*  function:  compare information of pdelta to the authorlist, lockerlist,*/
comment|/*             statelist, revlist and yield true if pdelta is selected.    */
block|{
name|struct
name|lock
specifier|const
modifier|*
name|plock
decl_stmt|;
name|struct
name|stateattri
specifier|const
modifier|*
name|pstate
decl_stmt|;
name|struct
name|authors
specifier|const
modifier|*
name|pauthor
decl_stmt|;
name|struct
name|Revpairs
specifier|const
modifier|*
name|prevision
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|pauthor
operator|=
name|authorlist
operator|)
condition|)
comment|/* only certain authors wanted */
while|while
condition|(
name|strcmp
argument_list|(
name|pauthor
operator|->
name|login
argument_list|,
name|pdelta
operator|->
name|author
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|pauthor
operator|=
name|pauthor
operator|->
name|nextauthor
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|pstate
operator|=
name|statelist
operator|)
condition|)
comment|/* only certain states wanted */
while|while
condition|(
name|strcmp
argument_list|(
name|pstate
operator|->
name|status
argument_list|,
name|pdelta
operator|->
name|state
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|pstate
operator|=
name|pstate
operator|->
name|nextstate
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|lockflag
condition|)
comment|/* only locked revisions wanted */
for|for
control|(
name|plock
operator|=
name|Locks
init|;
condition|;
name|plock
operator|=
name|plock
operator|->
name|nextlock
control|)
if|if
condition|(
operator|!
name|plock
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|plock
operator|->
name|delta
operator|==
name|pdelta
condition|)
break|break;
if|if
condition|(
operator|(
name|prevision
operator|=
name|Revlst
operator|)
condition|)
comment|/* only certain revs or branches wanted */
for|for
control|(
init|;
condition|;
control|)
block|{
name|length
operator|=
name|prevision
operator|->
name|numfld
expr_stmt|;
if|if
condition|(
name|countnumflds
argument_list|(
name|pdelta
operator|->
name|num
argument_list|)
operator|==
name|length
operator|+
operator|(
name|length
operator|&
literal|1
operator|)
operator|&&
literal|0
operator|<=
name|compartial
argument_list|(
name|pdelta
operator|->
name|num
argument_list|,
name|prevision
operator|->
name|strtrev
argument_list|,
name|length
argument_list|)
operator|&&
literal|0
operator|<=
name|compartial
argument_list|(
name|prevision
operator|->
name|endrev
argument_list|,
name|pdelta
operator|->
name|num
argument_list|,
name|length
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|prevision
operator|=
name|prevision
operator|->
name|rnext
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getdatepair
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*  function:  get time range from command line and store in datelist if    */
comment|/*             a time range specified or in duelst if a time spot specified */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|nextdate
decl_stmt|;
name|char
specifier|const
modifier|*
name|rawdate
decl_stmt|;
name|int
name|switchflag
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|warn
argument_list|(
literal|"missing date/time after -d"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|switchflag
operator|=
name|false
expr_stmt|;
name|nextdate
operator|=
name|talloc
argument_list|(
expr|struct
name|Datepairs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
comment|/*   case: -d<date   */
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|(
name|nextdate
operator|->
name|strtdate
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
comment|/* case: -d'>date' */
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|(
name|nextdate
operator|->
name|enddate
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|switchflag
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|rawdate
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|switchflag
operator|=
name|true
expr_stmt|;
name|str2date
argument_list|(
name|rawdate
argument_list|,
name|switchflag
condition|?
name|nextdate
operator|->
name|enddate
else|:
name|nextdate
operator|->
name|strtdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  case: -d date  */
name|VOID
name|strcpy
argument_list|(
name|nextdate
operator|->
name|enddate
argument_list|,
name|nextdate
operator|->
name|strtdate
argument_list|)
decl_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|duelst
expr_stmt|;
name|duelst
operator|=
name|nextdate
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
block|{
comment|/*   case:   -d date<  or -d  date>; see switchflag */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* second date missing */
if|if
condition|(
name|switchflag
condition|)
operator|*
name|nextdate
operator|->
name|strtdate
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|nextdate
operator|->
name|enddate
operator|=
literal|'\0'
expr_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|datelist
expr_stmt|;
name|datelist
operator|=
name|nextdate
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
block|}
name|rawdate
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
name|str2date
argument_list|(
name|rawdate
argument_list|,
name|switchflag
condition|?
name|nextdate
operator|->
name|strtdate
else|:
name|nextdate
operator|->
name|enddate
argument_list|)
expr_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|datelist
expr_stmt|;
name|datelist
operator|=
name|nextdate
expr_stmt|;
name|end
label|:
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|';'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getnumericrev
parameter_list|()
comment|/*  function:  get the numeric name of revisions which stored in revlist  */
comment|/*             and then stored the numeric names in Revlst                */
comment|/*             if branchflag, also add default branch                     */
block|{
name|struct
name|Revpairs
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|struct
name|buf
name|s
decl_stmt|,
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|lrev
decl_stmt|;
name|struct
name|buf
specifier|const
modifier|*
name|rstart
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
name|Revlst
operator|=
name|nil
expr_stmt|;
name|ptr
operator|=
name|revlist
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|rstart
operator|=
operator|&
name|s
expr_stmt|;
name|rend
operator|=
operator|&
name|e
expr_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|numfld
condition|)
block|{
case|case
literal|1
case|:
comment|/* -r rev */
if|if
condition|(
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
name|rend
operator|=
operator|&
name|s
expr_stmt|;
name|n
operator|=
name|countnumflds
argument_list|(
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|&&
operator|(
name|lrev
operator|=
name|tiprev
argument_list|()
operator|)
condition|)
block|{
name|bufscpy
argument_list|(
operator|&
name|s
argument_list|,
name|lrev
argument_list|)
expr_stmt|;
name|n
operator|=
name|countnumflds
argument_list|(
name|lrev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
comment|/* -r rev- */
if|if
condition|(
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
name|bufscpy
argument_list|(
operator|&
name|e
argument_list|,
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
name|n
operator|=
name|countnumflds
argument_list|(
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
name|n
operator|<
literal|2
condition|?
name|e
operator|.
name|string
else|:
name|strrchr
argument_list|(
name|e
operator|.
name|string
argument_list|,
literal|'.'
argument_list|)
operator|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* -r -rev */
if|if
condition|(
name|expandsym
argument_list|(
name|ptr
operator|->
name|endrev
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|countnumflds
argument_list|(
name|e
operator|.
name|string
argument_list|)
operator|)
operator|<
literal|2
condition|)
name|bufscpy
argument_list|(
operator|&
name|s
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
else|else
block|{
name|bufscpy
argument_list|(
operator|&
name|s
argument_list|,
name|e
operator|.
name|string
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|strrchr
argument_list|(
name|s
operator|.
name|string
argument_list|,
literal|'.'
argument_list|)
argument_list|,
literal|".1"
argument_list|)
decl_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* -r rev1-rev2 */
if|if
condition|(
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
operator|&
name|s
argument_list|)
operator|&&
name|expandsym
argument_list|(
name|ptr
operator|->
name|endrev
argument_list|,
operator|&
name|e
argument_list|)
operator|&&
name|checkrevpair
argument_list|(
name|s
operator|.
name|string
argument_list|,
name|e
operator|.
name|string
argument_list|)
condition|)
block|{
name|n
operator|=
name|countnumflds
argument_list|(
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* Swap if out of order.  */
if|if
condition|(
name|compartial
argument_list|(
name|s
operator|.
name|string
argument_list|,
name|e
operator|.
name|string
argument_list|,
name|n
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rstart
operator|=
operator|&
name|e
expr_stmt|;
name|rend
operator|=
operator|&
name|s
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|pt
operator|=
name|ftalloc
argument_list|(
expr|struct
name|Revpairs
argument_list|)
expr_stmt|;
name|pt
operator|->
name|numfld
operator|=
name|n
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|fstr_save
argument_list|(
name|rstart
operator|->
name|string
argument_list|)
expr_stmt|;
name|pt
operator|->
name|endrev
operator|=
name|fstr_save
argument_list|(
name|rend
operator|->
name|string
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rnext
operator|=
name|Revlst
expr_stmt|;
name|Revlst
operator|=
name|pt
expr_stmt|;
block|}
name|ptr
operator|=
name|ptr
operator|->
name|rnext
expr_stmt|;
block|}
comment|/* Now take care of branchflag */
if|if
condition|(
name|branchflag
operator|&&
operator|(
name|Dbranch
operator|||
name|Head
operator|)
condition|)
block|{
name|pt
operator|=
name|ftalloc
argument_list|(
expr|struct
name|Revpairs
argument_list|)
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|pt
operator|->
name|endrev
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
name|fstr_save
argument_list|(
name|partialno
argument_list|(
operator|&
name|s
argument_list|,
name|Head
operator|->
name|num
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rnext
operator|=
name|Revlst
expr_stmt|;
name|Revlst
operator|=
name|pt
expr_stmt|;
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|)
expr_stmt|;
block|}
name|bufautoend
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|checkrevpair
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|)
name|char
specifier|const
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_comment
comment|/*  function:  check whether num1, num2 are legal pair,i.e.     only the last field are different and have same number of     fields( if length<= 2, may be different if first field)   */
end_comment

begin_block
block|{
name|unsigned
name|length
init|=
name|countnumflds
argument_list|(
name|num1
argument_list|)
decl_stmt|;
if|if
condition|(
name|countnumflds
argument_list|(
name|num2
argument_list|)
operator|!=
name|length
operator|||
literal|2
operator|<
name|length
operator|&&
name|compartial
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid branch or revision pair %s : %s"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|getrevpairs
parameter_list|(
name|argv
parameter_list|)
specifier|register
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*  function:  get revision or branch range from command line, and   */
comment|/*             store in revlist                                      */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|nextrevpair
decl_stmt|;
name|int
name|separator
decl_stmt|;
name|c
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* Support old ambiguous '-' syntax; this will go away.  */
if|if
condition|(
name|strchr
argument_list|(
name|argv
argument_list|,
literal|':'
argument_list|)
condition|)
name|separator
operator|=
literal|':'
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|argv
argument_list|,
literal|'-'
argument_list|)
operator|&&
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|)
name|warn
argument_list|(
literal|"`-' is obsolete in `-r%s'; use `:' instead"
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|'-'
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|nextrevpair
operator|=
name|talloc
argument_list|(
expr|struct
name|Revpairs
argument_list|)
expr_stmt|;
name|nextrevpair
operator|->
name|rnext
operator|=
name|revlist
expr_stmt|;
name|revlist
operator|=
name|nextrevpair
expr_stmt|;
name|nextrevpair
operator|->
name|numfld
operator|=
literal|1
expr_stmt|;
name|nextrevpair
operator|->
name|strtrev
operator|=
name|argv
expr_stmt|;
for|for
control|(
init|;
condition|;
name|c
operator|=
operator|*
operator|++
name|argv
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
continue|continue;
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
break|break;
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|c
operator|==
name|separator
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|separator
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|nextrevpair
operator|->
name|endrev
operator|=
name|argv
expr_stmt|;
for|for
control|(
init|;
condition|;
name|c
operator|=
operator|*
operator|++
name|argv
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
continue|continue;
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
break|break;
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|c
operator|==
name|separator
condition|)
continue|continue;
break|break;
block|}
break|break;
block|}
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|nextrevpair
operator|->
name|numfld
operator|=
operator|!
name|nextrevpair
operator|->
name|endrev
index|[
literal|0
index|]
condition|?
literal|2
comment|/* -rrev- */
else|:
operator|!
name|nextrevpair
operator|->
name|strtrev
index|[
literal|0
index|]
condition|?
literal|3
comment|/* -r-rev */
else|:
literal|4
comment|/* -rrev1-rev2 */
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|';'
condition|)
name|error
argument_list|(
literal|"missing `,' near `%c%s'"
argument_list|,
name|c
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

