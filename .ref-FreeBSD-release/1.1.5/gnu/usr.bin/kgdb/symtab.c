begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  *  * $Header: /a/cvs/386BSD/src/gnu/gdb/symtab.c,v 1.1 1993/06/29 09:47:40 nate Exp $;  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)symtab.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Symbol table lookup for the GNU debugger, GDB.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|cplus_demangle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|value
modifier|*
name|value_of_this
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate an obstack to hold objects that should be freed    when we load a new symbol table.    This includes the symbols made by dbxread    and the types that are not permanent.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|obstack1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|symbol_obstack
init|=
operator|&
name|obstack1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This obstack will be used for partial_symbol objects.  It can    probably actually be the same as the symbol_obstack above, but I'd    like to keep them seperate for now.  If I want to later, I'll    replace one with the other.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|obstack2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|psymbol_obstack
init|=
operator|&
name|obstack2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables point to the objects    representing the predefined C data types.  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_void
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_long
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LONG_LONG
end_ifdef

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_long_long
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_long
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LONG_LONG
end_ifdef

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_long_long
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block in which the most recently searched-for symbol was found.    Might be better to make this a parameter to lookup_symbol and     value_of_this. */
end_comment

begin_decl_stmt
name|struct
name|block
modifier|*
name|block_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions */
end_comment

begin_function_decl
specifier|static
name|int
name|find_line_common
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lookup_misc_func
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Check for a symtab of a specific name; first in symtabs, then in    psymtabs.  *If* there is no '/' in the name, a match after a '/'    in the symtab filename will also work.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|char
modifier|*
name|slash
init|=
name|index
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
return|return
name|s
return|;
for|for
control|(
name|ps
operator|=
name|partial_symtab_list
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|fatal
argument_list|(
literal|"Internal: readin pst found when no symtab found."
argument_list|)
expr_stmt|;
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
operator|!
name|slash
condition|)
block|{
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|s
operator|->
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|filename
index|[
name|l
operator|-
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|filename
operator|+
name|l
operator|-
name|len
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|s
return|;
block|}
for|for
control|(
name|ps
operator|=
name|partial_symtab_list
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|filename
index|[
name|l
operator|-
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|strcmp
argument_list|(
name|ps
operator|->
name|filename
operator|+
name|l
operator|-
name|len
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|fatal
argument_list|(
literal|"Internal: readin pst found when no symtab found."
argument_list|)
expr_stmt|;
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lookup the symbol table of a source file named NAME.  Try a couple    of variations if the first lookup doesn't work.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|lookup_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|copy
decl_stmt|;
name|s
operator|=
name|lookup_symtab_1
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* If name not found as specified, see if adding ".c" helps.  */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|copy
argument_list|,
literal|".c"
argument_list|)
expr_stmt|;
name|s
operator|=
name|lookup_symtab_1
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* We didn't find anything; die.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lookup the partial symbol table of a source file named NAME.  This    only returns true on an exact match (ie. this semantics are    different from lookup_symtab.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|copy
decl_stmt|;
for|for
control|(
name|s
operator|=
name|partial_symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
return|return
name|s
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lookup a typedef or primitive type named NAME,    visible in lexical block BLOCK.    If NOERR is nonzero, return zero if NAME is not suitably defined.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_typename
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|noerr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|)
condition|)
return|return
name|builtin_type_int
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long"
argument_list|)
condition|)
return|return
name|builtin_type_long
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short"
argument_list|)
condition|)
return|return
name|builtin_type_short
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|)
condition|)
return|return
name|builtin_type_char
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"float"
argument_list|)
condition|)
return|return
name|builtin_type_float
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"double"
argument_list|)
condition|)
return|return
name|builtin_type_double
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"void"
argument_list|)
condition|)
return|return
name|builtin_type_void
return|;
if|if
condition|(
name|noerr
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|"No type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|lookup_unsigned_typename
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|)
condition|)
return|return
name|builtin_type_unsigned_int
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long"
argument_list|)
condition|)
return|return
name|builtin_type_unsigned_long
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short"
argument_list|)
condition|)
return|return
name|builtin_type_unsigned_short
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|)
condition|)
return|return
name|builtin_type_unsigned_char
return|;
name|error
argument_list|(
literal|"No type named unsigned %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a structure type named "struct NAME",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_struct
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No struct type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"This context has class, union or enum %s, not a struct."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a union type named "union NAME",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_union
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No union type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"This context has class, struct or enum %s, not a union."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup an enum type named "enum NAME",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_enum
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No enum type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
name|error
argument_list|(
literal|"This context has class, struct or union %s, not an enum."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, lookup the type of the component of type named    NAME.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_struct_elt_type
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
block|{
name|terminal_ours
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stderr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is not a structure or union type.\n"
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
return|;
name|terminal_ours
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stderr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" has no component named %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, return a type of pointers to that type.    May need to construct such a type if this is the first use.     C++: use TYPE_MAIN_VARIANT and TYPE_CHAIN to keep pointer    to member types under control.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_pointer_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|ptype
init|=
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptype
condition|)
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|ptype
argument_list|)
return|;
comment|/* This is the first time anyone wanted a pointer to a TYPE.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|ptype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ptype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ptype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|ptype
argument_list|)
operator|=
name|ptype
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|ptype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|ptype
expr_stmt|;
comment|/* New type is permanent if type pointed to is permanent.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|TYPE_FLAGS
argument_list|(
name|ptype
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
comment|/* We assume the machine has only one representation for pointers!  */
name|TYPE_LENGTH
argument_list|(
name|ptype
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|ptype
argument_list|)
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
return|return
name|ptype
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|lookup_reference_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|rtype
init|=
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtype
condition|)
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|rtype
argument_list|)
return|;
comment|/* This is the first time anyone wanted a pointer to a TYPE.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|rtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rtype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|rtype
argument_list|)
operator|=
name|rtype
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|rtype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|rtype
expr_stmt|;
comment|/* New type is permanent if type pointed to is permanent.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|TYPE_FLAGS
argument_list|(
name|rtype
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
comment|/* We assume the machine has only one representation for pointers!  */
name|TYPE_LENGTH
argument_list|(
name|rtype
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|rtype
argument_list|)
operator|=
name|TYPE_CODE_REF
expr_stmt|;
return|return
name|rtype
return|;
block|}
end_function

begin_comment
comment|/* Implement direct support for MEMBER_TYPE in GNU C++.    May need to construct such a type if this is the first use.    The TYPE is the type of the member.  The DOMAIN is the type    of the aggregate that the member belongs to.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_member_type
parameter_list|(
name|type
parameter_list|,
name|domain
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|domain
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|type
modifier|*
name|mtype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|main_type
decl_stmt|;
name|main_type
operator|=
name|mtype
expr_stmt|;
while|while
condition|(
name|mtype
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|mtype
argument_list|)
operator|==
name|domain
condition|)
return|return
name|mtype
return|;
name|mtype
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|mtype
argument_list|)
expr_stmt|;
block|}
comment|/* This is the first time anyone wanted this member type.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|mtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mtype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_type
operator|==
literal|0
condition|)
name|main_type
operator|=
name|mtype
expr_stmt|;
else|else
block|{
name|TYPE_NEXT_VARIANT
argument_list|(
name|mtype
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|main_type
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|main_type
argument_list|)
operator|=
name|mtype
expr_stmt|;
block|}
name|TYPE_MAIN_VARIANT
argument_list|(
name|mtype
argument_list|)
operator|=
name|main_type
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mtype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|mtype
argument_list|)
operator|=
name|domain
expr_stmt|;
comment|/* New type is permanent if type pointed to is permanent.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|TYPE_FLAGS
argument_list|(
name|mtype
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
comment|/* In practice, this is never used.  */
name|TYPE_LENGTH
argument_list|(
name|mtype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|mtype
argument_list|)
operator|=
name|TYPE_CODE_MEMBER
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now splice in the new member pointer type.  */
block|if (main_type)     {
comment|/* This type was not "smashed".  */
block|TYPE_CHAIN (mtype) = TYPE_CHAIN (main_type);       TYPE_CHAIN (main_type) = mtype;     }
endif|#
directive|endif
return|return
name|mtype
return|;
block|}
end_block

begin_function
name|struct
name|type
modifier|*
name|lookup_method_type
parameter_list|(
name|type
parameter_list|,
name|domain
parameter_list|,
name|args
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|domain
decl_stmt|,
modifier|*
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|type
modifier|*
name|mtype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|main_type
decl_stmt|;
name|main_type
operator|=
name|mtype
expr_stmt|;
while|while
condition|(
name|mtype
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|mtype
argument_list|)
operator|==
name|domain
condition|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|t1
init|=
name|args
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|t2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|mtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t2
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t1
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|t1
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t1
index|[
name|i
index|]
operator|!=
name|t2
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|t1
index|[
name|i
index|]
operator|==
name|t2
index|[
name|i
index|]
condition|)
return|return
name|mtype
return|;
block|}
block|}
name|mtype
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|mtype
argument_list|)
expr_stmt|;
block|}
comment|/* This is the first time anyone wanted this member type.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|mtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mtype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_type
operator|==
literal|0
condition|)
name|main_type
operator|=
name|mtype
expr_stmt|;
else|else
block|{
name|TYPE_NEXT_VARIANT
argument_list|(
name|mtype
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|main_type
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|main_type
argument_list|)
operator|=
name|mtype
expr_stmt|;
block|}
name|TYPE_MAIN_VARIANT
argument_list|(
name|mtype
argument_list|)
operator|=
name|main_type
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mtype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|mtype
argument_list|)
operator|=
name|domain
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|mtype
argument_list|)
operator|=
name|args
expr_stmt|;
comment|/* New type is permanent if type pointed to is permanent.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|TYPE_FLAGS
argument_list|(
name|mtype
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
comment|/* In practice, this is never used.  */
name|TYPE_LENGTH
argument_list|(
name|mtype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|mtype
argument_list|)
operator|=
name|TYPE_CODE_METHOD
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now splice in the new member pointer type.  */
block|if (main_type)     {
comment|/* This type was not "smashed".  */
block|TYPE_CHAIN (mtype) = TYPE_CHAIN (main_type);       TYPE_CHAIN (main_type) = mtype;     }
endif|#
directive|endif
return|return
name|mtype
return|;
block|}
end_block

begin_comment
comment|/* Given a type TYPE, return a type which has offset OFFSET,    via_virtual VIA_VIRTUAL, and via_public VIA_PUBLIC.    May need to construct such a type if none exists.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_basetype_type
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|via_virtual
parameter_list|,
name|via_public
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|via_virtual
decl_stmt|,
name|via_public
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|btype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|main_type
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Internal error: type offset non-zero in lookup_basetype_type"
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|main_type
operator|=
name|btype
expr_stmt|;
while|while
condition|(
name|btype
condition|)
block|{
if|if
condition|(
comment|/* TYPE_OFFSET (btype) == offset&& */
name|TYPE_VIA_PUBLIC
argument_list|(
name|btype
argument_list|)
operator|==
name|via_public
operator|&&
name|TYPE_VIA_VIRTUAL
argument_list|(
name|btype
argument_list|)
operator|==
name|via_virtual
condition|)
return|return
name|btype
return|;
name|btype
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|btype
argument_list|)
expr_stmt|;
block|}
comment|/* This is the first time anyone wanted this member type.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|btype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|btype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_type
operator|==
literal|0
condition|)
block|{
name|main_type
operator|=
name|btype
expr_stmt|;
name|bzero
argument_list|(
name|btype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|btype
argument_list|)
operator|=
name|main_type
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|main_type
argument_list|,
name|btype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|main_type
argument_list|)
operator|=
name|btype
expr_stmt|;
block|}
comment|/* TYPE_OFFSET (btype) = offset; */
if|if
condition|(
name|via_public
condition|)
name|TYPE_FLAGS
argument_list|(
name|btype
argument_list|)
operator||=
name|TYPE_FLAG_VIA_PUBLIC
expr_stmt|;
if|if
condition|(
name|via_virtual
condition|)
name|TYPE_FLAGS
argument_list|(
name|btype
argument_list|)
operator||=
name|TYPE_FLAG_VIA_VIRTUAL
expr_stmt|;
comment|/* New type is permanent if type pointed to is permanent.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|TYPE_FLAGS
argument_list|(
name|btype
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
comment|/* In practice, this is never used.  */
name|TYPE_LENGTH
argument_list|(
name|btype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|btype
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
return|return
name|btype
return|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, return a type of functions that return that type.    May need to construct such a type if this is the first use.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_function_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|ptype
init|=
name|TYPE_FUNCTION_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptype
condition|)
return|return
name|ptype
return|;
comment|/* This is the first time anyone wanted a function returning a TYPE.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|ptype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ptype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ptype
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|ptype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FUNCTION_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|ptype
expr_stmt|;
comment|/* New type is permanent if type returned is permanent.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
condition|)
name|TYPE_FLAGS
argument_list|(
name|ptype
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|ptype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|ptype
argument_list|)
operator|=
name|TYPE_CODE_FUNC
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|ptype
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|ptype
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an array type.  Elements will be of type TYPE, and there will    be NUM of them.     Eventually this should be extended to take two more arguments which    specify the bounds of the array and the type of the index.    It should also be changed to be a "lookup" function, with the    appropriate data structures added to the type field.    Then read array type should call here.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|create_array_type
parameter_list|(
name|element_type
parameter_list|,
name|number
parameter_list|)
name|struct
name|type
modifier|*
name|element_type
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|result_type
init|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|result_type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|=
name|element_type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
name|number
operator|*
name|TYPE_LENGTH
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
name|TYPE_VPTR_FIELDNO
argument_list|(
name|result_type
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|result_type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Smash TYPE to be a type of pointers to TO_TYPE.    If TO_TYPE is not permanent and has no pointer-type yet,    record TYPE as its pointer-type.  */
end_comment

begin_function
name|void
name|smash_to_pointer_type
parameter_list|(
name|type
parameter_list|,
name|to_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|to_type
decl_stmt|;
end_function

begin_block
block|{
name|int
name|type_permanent
init|=
operator|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
decl_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
comment|/* We assume the machine has only one representation for pointers!  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type_permanent
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
if|if
condition|(
name|TYPE_POINTER_TYPE
argument_list|(
name|to_type
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
operator|(
name|TYPE_FLAGS
argument_list|(
name|to_type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|||
name|type_permanent
operator|)
condition|)
block|{
name|TYPE_POINTER_TYPE
argument_list|(
name|to_type
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Smash TYPE to be a type of members of DOMAIN with type TO_TYPE.  */
end_comment

begin_function
name|void
name|smash_to_member_type
parameter_list|(
name|type
parameter_list|,
name|domain
parameter_list|,
name|to_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|domain
decl_stmt|,
modifier|*
name|to_type
decl_stmt|;
end_function

begin_block
block|{
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|domain
expr_stmt|;
comment|/* In practice, this is never needed.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_MEMBER
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|lookup_member_type
argument_list|(
name|domain
argument_list|,
name|to_type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Smash TYPE to be a type of method of DOMAIN with type TO_TYPE.  */
end_comment

begin_function
name|void
name|smash_to_method_type
parameter_list|(
name|type
parameter_list|,
name|domain
parameter_list|,
name|to_type
parameter_list|,
name|args
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|domain
decl_stmt|,
modifier|*
name|to_type
decl_stmt|,
modifier|*
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|domain
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
operator|=
name|args
expr_stmt|;
comment|/* In practice, this is never needed.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_METHOD
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|lookup_method_type
argument_list|(
name|domain
argument_list|,
name|to_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Smash TYPE to be a type of reference to TO_TYPE.    If TO_TYPE is not permanent and has no pointer-type yet,    record TYPE as its pointer-type.  */
end_comment

begin_function
name|void
name|smash_to_reference_type
parameter_list|(
name|type
parameter_list|,
name|to_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|to_type
decl_stmt|;
end_function

begin_block
block|{
name|int
name|type_permanent
init|=
operator|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
decl_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
comment|/* We assume the machine has only one representation for pointers!  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_REF
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type_permanent
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
if|if
condition|(
name|TYPE_REFERENCE_TYPE
argument_list|(
name|to_type
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
operator|(
name|TYPE_FLAGS
argument_list|(
name|to_type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|||
name|type_permanent
operator|)
condition|)
block|{
name|TYPE_REFERENCE_TYPE
argument_list|(
name|to_type
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Smash TYPE to be a type of functions returning TO_TYPE.    If TO_TYPE is not permanent and has no function-type yet,    record TYPE as its function-type.  */
end_comment

begin_function
name|void
name|smash_to_function_type
parameter_list|(
name|type
parameter_list|,
name|to_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|,
decl|*
name|to_type
decl_stmt|;
end_function

begin_block
block|{
name|int
name|type_permanent
init|=
operator|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
decl_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_FUNC
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type_permanent
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
if|if
condition|(
name|TYPE_FUNCTION_TYPE
argument_list|(
name|to_type
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
operator|(
name|TYPE_FLAGS
argument_list|(
name|to_type
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|||
name|type_permanent
operator|)
condition|)
block|{
name|TYPE_FUNCTION_TYPE
argument_list|(
name|to_type
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find which partial symtab on the partial_symtab_list contains    PC.  Return 0 if none.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_psymtab
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
for|for
control|(
name|ps
operator|=
name|partial_symtab_list
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
if|if
condition|(
name|pc
operator|>=
name|ps
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|ps
operator|->
name|texthigh
condition|)
return|return
name|ps
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab contains PC.  Return 0    if none.  Check all psymtabs if PSYMTAB is 0.  */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_psymbol
parameter_list|(
name|psymtab
parameter_list|,
name|pc
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|best
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|best_pc
decl_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
name|psymtab
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
return|return
literal|0
return|;
name|best_pc
operator|=
name|psymtab
operator|->
name|textlow
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
init|;
operator|(
name|p
operator|-
operator|(
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_static_syms
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE
argument_list|(
name|p
argument_list|)
operator|&&
name|SYMBOL_VALUE
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
condition|)
block|{
name|best_pc
operator|=
name|SYMBOL_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|best_pc
operator|==
name|psymtab
operator|->
name|textlow
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Find the definition for a specified symbol name NAME    in namespace NAMESPACE, visible from lexical block BLOCK.    Returns the struct symbol pointer, or zero if no symbol is found.     C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if    NAME is a field of the current implied argument `this'.  If so set    *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.     BLOCK_FOUND is set to the block in which NAME is found (in the case of    a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|namespace
parameter_list|,
name|is_a_field_of_this
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
name|int
modifier|*
name|is_a_field_of_this
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
comment|/* Search specified block and its superiors.  */
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
return|return
name|sym
return|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* C++: If requested to do so by the caller,       check to see if NAME is a field of `this'. */
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_of_this
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|*
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|check_field
argument_list|(
name|v
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|is_a_field_of_this
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Now search all global blocks.  Do the symtab's first, then      check the psymtab's */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Check for the possibility of the symbol being a global function      that is stored on the misc function vector.  Eventually, all      global symbols might be resolved in this way.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|int
name|index
init|=
name|lookup_misc_func
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Look for a mangled C++ name for NAME. */
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
name|misc_function_count
init|;
operator|--
name|index
operator|>=
literal|0
condition|;
control|)
comment|/* Assume orginal name is prefix of mangled name. */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|misc_function_vector
index|[
name|index
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
condition|)
block|{
name|char
modifier|*
name|demangled
init|=
name|cplus_demangle
argument_list|(
name|misc_function_vector
index|[
name|index
index|]
operator|.
name|name
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|int
name|cond
init|=
name|strcmp
argument_list|(
name|demangled
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
break|break;
block|}
block|}
comment|/* Loop terminates on no match with index == -1. */
block|}
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|misc_function_vector
index|[
name|index
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* sym == 0 if symbol was found in the psymtab but not 		 in the symtab. 		 Return 0 to use the misc_function definition of "foo_".  		 This happens for Fortran  "foo_" symbols, 		 which are "foo" in the symtab.  		 This can also happen if "asm" is used to make a 		 regular symbol but not a debugging symbol, e.g. 		 asm(".globl _main"); 		 asm("_main:"); 		 */
return|return
name|sym
return|;
block|}
block|}
block|}
if|if
condition|(
name|psym
operator|=
name|lookup_partial_symbol
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|ps
operator|=
name|psym
operator|->
name|pst
expr_stmt|;
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|fatal
argument_list|(
literal|"Internal: global symbol found in psymtab but not in symtab"
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
comment|/* Now search all per-file blocks.      Not strictly correct, but more useful than an error.      Do the symtabs first, then check the psymtabs */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
if|if
condition|(
name|psym
operator|=
name|lookup_partial_symbol
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|ps
operator|=
name|psym
operator|->
name|pst
expr_stmt|;
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|fatal
argument_list|(
literal|"Internal: static symbol found in psymtab but not in symtab"
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol NAME.  Check the global    symbols if GLOBAL, the static symbols if not */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|name
parameter_list|,
name|global
parameter_list|,
name|namespace
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|global
decl_stmt|;
specifier|register
name|enum
name|namespace
name|namespace
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symbol
modifier|*
name|start
decl_stmt|,
modifier|*
name|psym
decl_stmt|;
specifier|register
name|struct
name|partial_symbol
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|,
modifier|*
name|center
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
if|if
condition|(
name|global
condition|)
block|{
name|start
operator|=
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|length
operator|=
name|global_psymbols
operator|.
name|next
operator|-
name|start
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|static_psymbols
operator|.
name|list
expr_stmt|;
name|length
operator|=
name|static_psymbols
operator|.
name|next
operator|-
name|start
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|length
condition|)
return|return
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
literal|0
return|;
comment|/* Binary search.  This search is guarranteed to end with center      pointing at the earliest partial symbol with the correct      name.  At that point *all* partial symbols with that name      will be checked against the correct namespace. */
name|bottom
operator|=
name|start
expr_stmt|;
name|top
operator|=
name|start
operator|+
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bottom
condition|)
block|{
name|center
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
name|assert
argument_list|(
name|center
operator|<
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|center
argument_list|)
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
name|top
operator|=
name|center
expr_stmt|;
else|else
name|bottom
operator|=
name|center
operator|+
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|top
operator|==
name|bottom
argument_list|)
expr_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|top
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|->
name|pst
operator|->
name|readin
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|top
argument_list|)
operator|==
name|namespace
condition|)
return|return
name|top
return|;
name|top
operator|++
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for a symbol in block BLOCK.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|(
name|block
parameter_list|,
name|name
parameter_list|,
name|namespace
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|parameter_sym
decl_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
comment|/* If the blocks's symbols were sorted, start with a binary search.  */
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* First, advance BOT to not far before 	 the first symbol whose name is NAME.  */
while|while
condition|(
literal|1
condition|)
block|{
name|inc
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* No need to keep binary searching for the last few bits worth.  */
if|if
condition|(
name|inc
operator|<
literal|4
condition|)
break|break;
name|inc
operator|=
operator|(
name|inc
operator|>>
literal|1
operator|)
operator|+
name|bot
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|<
name|name
index|[
literal|0
index|]
condition|)
name|bot
operator|=
name|inc
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
name|top
operator|=
name|inc
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
name|bot
operator|=
name|inc
expr_stmt|;
else|else
name|top
operator|=
name|inc
expr_stmt|;
block|}
comment|/* Now scan forward until we run out of symbols, 	 find one whose name is greater than NAME, 	 or find one we want. 	 If there is more than one symbol with the right name and namespace, 	 we return the first one.  dbxread.c is careful to make sure 	 that if one is a register then it comes first.  */
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|inc
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|-
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
name|inc
operator|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
condition|)
return|return
name|sym
return|;
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
return|return
literal|0
return|;
name|bot
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Here if block isn't sorted.      This loop is equivalent to the loop above,      but hacked greatly for speed.       Note that parameter symbols do not always show up last in the      list; this loop makes sure to take anything else other than      parameter symbols first; it only uses parameter symbols as a      last resort.  Note that this only takes up extra computation      time on a match.  */
name|parameter_sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|inc
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|inc
operator|&&
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REF_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
name|parameter_sym
operator|=
name|sym
expr_stmt|;
else|else
return|return
name|sym
return|;
block|}
name|bot
operator|++
expr_stmt|;
block|}
return|return
name|parameter_sym
return|;
comment|/* Will be 0 if not found. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol for the function which contains a specified    lexical block, described by a struct block BL.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|block_function
parameter_list|(
name|bl
parameter_list|)
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
block|{
while|while
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|==
literal|0
operator|&&
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|!=
literal|0
condition|)
name|bl
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
expr_stmt|;
return|return
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of find_pc_line */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_symtab
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
comment|/* Search all symtabs for one whose file contains our pc */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
name|ps
operator|->
name|readin
condition|)
name|fatal
argument_list|(
literal|"Internal error: pc in read in psymtab, but not in symtab."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Find the source file and line number for a given PC value.    Return a structure containing a symtab pointer, a line number,    and a pc range for the entire source line.    The value's .pc field is NOT the specified pc.    NOTCURRENT nonzero means, if specified pc is on a line boundary,    use the line that ends there.  Otherwise, in that case, the line    that begins there is used.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_line
parameter_list|(
name|pc
parameter_list|,
name|notcurrent
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|notcurrent
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
decl_stmt|;
name|struct
name|symtab_and_line
name|value
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
comment|/* Info on best line seen so far, and where it starts, and its file.  */
name|int
name|best_line
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|best_pc
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|best_end
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
init|=
literal|0
decl_stmt|;
comment|/* Store here the first line number      of a file which contains the line at the smallest pc after PC.      If we don't find a line whose range contains PC,      we will use a line one less than this,      with a range from the start of that file to the first line's pc.  */
name|int
name|alt_line
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|alt_pc
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|alt_symtab
init|=
literal|0
decl_stmt|;
comment|/* Info on best line seen in this file.  */
name|int
name|prev_line
decl_stmt|;
name|CORE_ADDR
name|prev_pc
decl_stmt|;
comment|/* Info on first line of this file.  */
name|int
name|first_line
decl_stmt|;
name|CORE_ADDR
name|first_pc
decl_stmt|;
comment|/* If this pc is not from the current frame,      it is the address of the end of a call instruction.      Quite likely that is the start of the following statement.      But what we want is the statement containing the instruction.      Fudge the pc to make sure we get that.  */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|-=
literal|1
expr_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|value
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|value
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|value
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|value
operator|.
name|end
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all the symtabs that share this blockvector.      They all have the same apriori range, that we found was right;      but they have different line tables.  */
for|for
control|(
init|;
name|s
operator|&&
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|==
name|bv
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Find the best line in this symtab.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
name|prev_line
operator|=
operator|-
literal|1
expr_stmt|;
name|first_line
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|first_line
operator|<
literal|0
condition|)
block|{
name|first_line
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|first_pc
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
comment|/* Return the last line that did not start after PC.  */
if|if
condition|(
name|pc
operator|>=
name|item
operator|->
name|pc
condition|)
block|{
name|prev_line
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|prev_pc
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Is this file's best line closer than the best in the other files? 	 If so, record this file, and its best line, as best so far.  */
if|if
condition|(
name|prev_line
operator|>=
literal|0
operator|&&
name|prev_pc
operator|>
name|best_pc
condition|)
block|{
name|best_pc
operator|=
name|prev_pc
expr_stmt|;
name|best_line
operator|=
name|prev_line
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|best_end
operator|=
name|item
operator|->
name|pc
expr_stmt|;
else|else
name|best_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is this file's first line closer than the first lines of other files? 	 If so, record this file, and its first line, as best alternate.  */
if|if
condition|(
name|first_line
operator|>=
literal|0
operator|&&
name|first_pc
operator|>
name|pc
operator|&&
operator|(
name|alt_pc
operator|==
literal|0
operator|||
name|first_pc
operator|<
name|alt_pc
operator|)
condition|)
block|{
name|alt_pc
operator|=
name|first_pc
expr_stmt|;
name|alt_line
operator|=
name|first_line
expr_stmt|;
name|alt_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_symtab
operator|==
literal|0
condition|)
block|{
name|value
operator|.
name|symtab
operator|=
name|alt_symtab
expr_stmt|;
name|value
operator|.
name|line
operator|=
name|alt_line
operator|-
literal|1
expr_stmt|;
name|value
operator|.
name|pc
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|.
name|end
operator|=
name|alt_pc
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
name|value
operator|.
name|line
operator|=
name|best_line
expr_stmt|;
name|value
operator|.
name|pc
operator|=
name|best_pc
expr_stmt|;
name|value
operator|.
name|end
operator|=
operator|(
name|best_end
condition|?
name|best_end
else|:
operator|(
name|alt_pc
condition|?
name|alt_pc
else|:
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the PC value for a given source file and line number.    Returns zero for invalid line number.    The source file is specified with a struct symtab.  */
end_comment

begin_function
name|CORE_ADDR
name|find_line_pc
parameter_list|(
name|symtab
parameter_list|,
name|line
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|dummy
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|index
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|line
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
name|index
condition|?
name|l
operator|->
name|item
index|[
name|index
index|]
operator|.
name|pc
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the range of pc values in a line.    Store the starting pc of the line into *STARTPTR    and the ending pc (start of next line) into *ENDPTR.    Returns 1 to indicate success.    Returns 0 if could not find the specified line.  */
end_comment

begin_function
name|int
name|find_line_pc_range
parameter_list|(
name|symtab
parameter_list|,
name|thisline
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|thisline
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|exact_match
decl_stmt|;
comment|/* did we get an exact linenumber match */
specifier|register
name|CORE_ADDR
name|prev_pc
decl_stmt|;
name|CORE_ADDR
name|last_pc
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|index
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|thisline
argument_list|,
operator|&
name|exact_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
operator|*
name|startptr
operator|=
name|l
operator|->
name|item
index|[
name|index
index|]
operator|.
name|pc
expr_stmt|;
comment|/* If we have not seen an entry for the specified line, 	 assume that means the specified line has zero bytes.  */
if|if
condition|(
operator|!
name|exact_match
operator|||
name|index
operator|==
name|l
operator|->
name|nitems
operator|-
literal|1
condition|)
operator|*
name|endptr
operator|=
operator|*
name|startptr
expr_stmt|;
elseif|else
comment|/* Perhaps the following entry is for the following line. 	   It's worth a try.  */
if|if
condition|(
name|l
operator|->
name|item
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|line
operator|==
name|thisline
operator|+
literal|1
condition|)
operator|*
name|endptr
operator|=
name|l
operator|->
name|item
index|[
name|index
operator|+
literal|1
index|]
operator|.
name|pc
expr_stmt|;
else|else
operator|*
name|endptr
operator|=
name|find_line_pc
argument_list|(
name|symtab
argument_list|,
name|thisline
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given a line table and a line number, return the index into the line    table for the pc of the nearest line whose number is>= the specified one.    Return 0 if none is found.  The value is never zero is it is an index.     Set *EXACT_MATCH nonzero if the value returned is an exact match.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_common
parameter_list|(
name|l
parameter_list|,
name|lineno
parameter_list|,
name|exact_match
parameter_list|)
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|lineno
decl_stmt|;
name|int
modifier|*
name|exact_match
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* BEST is the smallest linenumber> LINENO so far seen,      or 0 if none has been seen so far.      BEST_INDEX identifies the item for it.  */
name|int
name|best_index
init|=
literal|0
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
name|int
name|nextline
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lineno
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|lineno
condition|)
block|{
operator|*
name|exact_match
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|lineno
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we got here, we didn't get an exact match.  */
operator|*
name|exact_match
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_function
name|int
name|find_pc_line_pc_range
parameter_list|(
name|pc
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|startptr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
return|return
name|sal
operator|.
name|symtab
operator|!=
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Parse a string that specifies a line number.    Pass the address of a char * variable; that variable will be    advanced over the characters actually parsed.     The string can be:     LINENUM -- that line number in current file.  PC returned is 0.    FILE:LINENUM -- that line in that file.  PC returned is 0.    FUNCTION -- line number of openbrace of that function.       PC returned is the start of the function.    FILE:FUNCTION -- likewise, but prefer functions in that file.    *EXPR -- line in which address EXPR appears.     FUNCTION may be an undebuggable function found in misc_function_vector.     If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside a function when a function is specified.     DEFAULT_SYMTAB specifies the file to use if none is specified.    It defaults to current_source_symtab.    DEFAULT_LINE specifies the line number to use for relative    line numbers (that start with signs).  Defaults to current_source_line.     Note that it is possible to return zero for the symtab    if no file is validly specified.  Callers must check that.    Also, the line number returned may be invalid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_1
parameter_list|(
name|argptr
parameter_list|,
name|funfirstline
parameter_list|,
name|default_symtab
parameter_list|,
name|default_line
parameter_list|)
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
name|struct
name|symtab
modifier|*
name|default_symtab
decl_stmt|;
name|int
name|default_line
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|()
function_decl|;
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|struct
name|symtab_and_line
name|value
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|char
modifier|*
name|class_name
decl_stmt|,
modifier|*
name|method_name
decl_stmt|,
modifier|*
name|phys_name
decl_stmt|;
name|int
name|method_counter
decl_stmt|;
name|int
name|i1
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
modifier|*
name|physnames
decl_stmt|;
comment|/* Defaults have defaults.  */
if|if
condition|(
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
comment|/* See if arg is *PC */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|pc
operator|=
name|parse_and_eval_address_1
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
name|s
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argptr
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
break|break;
block|}
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
comment|/*  C++  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Extract the class name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|argptr
argument_list|,
name|copy
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Discard the class name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_class
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
comment|/* Arg token is not digits => try it as a function name 		 Find the next token (everything up to end or next whitespace). */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|argptr
argument_list|,
name|copy
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no line number may be specified */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym
operator|=
literal|0
expr_stmt|;
name|i1
operator|=
literal|0
expr_stmt|;
comment|/*  counter for the symbol array */
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
expr_stmt|;
name|sym_arr
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|physnames
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor_name_p
argument_list|(
name|copy
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* destructors are a special case.  */
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|physnames
index|[
name|i1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|phys_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|physnames
index|[
name|i1
index|]
argument_list|,
name|phys_name
argument_list|)
expr_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
name|t
condition|)
block|{
name|class_name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Ignore this class if it doesn't have a name. 		     This prevents core dumps, but is just a workaround 		     because we might not find the function in 		     certain cases, such as 		     struct D {virtual int f();} 		     struct C : D {virtual int g();} 		     (in this case g++ 1.35.1- does not put out a name 		     for D as such, it defines type 19 (for example) in 		     the same stab as C, and then does a 		     .stabs "D:T19" and a .stabs "D:t19". 		     Thus 		     "break C::f" should not be looking for field f in 		     the class named D,  		     but just for the field f in the baseclasses of C 		     (no matter what their names).  		     However, I don't know how to replace the code below 		     that depends on knowing the name of D.  */
if|if
condition|(
name|class_name
condition|)
block|{
comment|/* We just want the class name.  In the context 			 of C++, stripping off "struct " is always 			 sensible.  */
if|if
condition|(
name|strncmp
argument_list|(
literal|"struct "
argument_list|,
name|class_name
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|class_name
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"union "
argument_list|,
name|class_name
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|class_name
operator|+=
literal|6
expr_stmt|;
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|class_name
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|method_counter
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|method_counter
operator|>=
literal|0
condition|;
operator|--
name|method_counter
control|)
block|{
name|int
name|field_counter
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|method_name
operator|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|method_counter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|copy
argument_list|,
name|method_name
argument_list|)
condition|)
comment|/* Find all the fields with that name.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|physnames
index|[
name|i1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|phys_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|physnames
index|[
name|i1
index|]
argument_list|,
name|phys_name
argument_list|)
expr_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
comment|/* There is exactly one field with that name.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
operator|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|end
operator|&&
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|!=
name|pc
operator|)
condition|?
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|end
else|:
name|pc
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
comment|/* There is more than one field with that name 		     (overloaded).  Ask the user which one to use.  */
return|return
name|decode_line_2
argument_list|(
name|argptr
argument_list|,
name|sym_arr
argument_list|,
name|physnames
argument_list|,
name|i1
argument_list|,
name|funfirstline
argument_list|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"that class does not have any method named %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"no class, struct, or union named %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/*  end of C++  */
comment|/* Extract the file name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|argptr
argument_list|,
name|copy
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find that file's data.  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symtab_list
operator|==
literal|0
operator|&&
name|partial_symtab_list
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"symbol-file\" command."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the file name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
block|}
comment|/* S is specified file's symtab, or 0 if no file specified.      arg no longer contains the file name.  */
comment|/* Check whether arg is all digits (and sign) */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
operator|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|','
operator|)
condition|)
block|{
comment|/* We found a token consisting of all digits -- at least one digit.  */
enum|enum
name|sign
block|{
name|none
block|,
name|plus
block|,
name|minus
block|}
name|sign
init|=
name|none
enum|;
comment|/* This is where we need to make sure that we have good defaults. 	 We must guarrantee that this section of code is never executed 	 when we are called with just a function name, since 	 select_source_symtab calls us with such an argument  */
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|default_symtab
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symtab_list
operator|==
literal|0
operator|&&
name|partial_symtab_list
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"symbol-file\" command."
argument_list|)
expr_stmt|;
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'+'
condition|)
name|sign
operator|=
name|plus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'-'
condition|)
name|sign
operator|=
name|minus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|value
operator|.
name|line
operator|=
name|atoi
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
name|plus
case|:
if|if
condition|(
name|p
operator|==
operator|*
name|argptr
condition|)
name|value
operator|.
name|line
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|value
operator|.
name|line
operator|=
name|default_line
operator|+
name|value
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|minus
case|:
if|if
condition|(
name|p
operator|==
operator|*
name|argptr
condition|)
name|value
operator|.
name|line
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|value
operator|.
name|line
operator|=
name|default_line
operator|-
name|value
operator|.
name|line
expr_stmt|;
else|else
name|value
operator|.
name|line
operator|=
literal|1
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|s
operator|=
name|default_symtab
expr_stmt|;
name|value
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|value
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Arg token is not digits => try it as a function name      Find the next token (everything up to end or next whitespace).  */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|argptr
argument_list|,
name|copy
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* Look up that token as a function.      If file specified, use that file's per-file block to start with.  */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
comment|/* use current file as default if none is specified. */
name|s
operator|=
name|default_symtab
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
name|s
condition|?
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|value
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* Convex: no need to suppress code on first line, if any */
name|value
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
else|#
directive|else
name|value
operator|.
name|pc
operator|=
operator|(
name|value
operator|.
name|end
operator|&&
name|value
operator|.
name|pc
operator|!=
name|pc
operator|)
condition|?
name|value
operator|.
name|end
else|:
name|pc
expr_stmt|;
endif|#
directive|endif
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
if|if
condition|(
name|sym
condition|)
name|error
argument_list|(
literal|"%s is not a function."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab_list
operator|==
literal|0
operator|&&
name|partial_symtab_list
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"symbol-file\" command."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|lookup_misc_func
argument_list|(
name|copy
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|value
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|value
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|value
operator|.
name|pc
operator|=
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|value
operator|.
name|pc
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
name|error
argument_list|(
literal|"Function %s not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Given a list of NELTS symbols in sym_arr (with corresponding    mangled names in physnames), return a list of lines to operate on    (ask user if necessary).  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|argptr
parameter_list|,
name|sym_arr
parameter_list|,
name|physnames
parameter_list|,
name|nelts
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_arr
index|[]
decl_stmt|;
name|char
modifier|*
name|physnames
index|[]
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|struct
name|symtabs_and_lines
name|values
decl_stmt|,
name|return_values
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|command_line_input
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|alloca
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"[0] cancel\n[1] all\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nelts
condition|)
block|{
if|if
condition|(
name|sym_arr
index|[
name|i
index|]
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
operator|=
operator|(
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|end
operator|&&
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
operator|!=
name|pc
operator|)
condition|?
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|end
else|:
name|pc
expr_stmt|;
name|printf
argument_list|(
literal|"[%d] file:%s; line number:%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"?HERE\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|prompt
operator|=
literal|">"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|args
operator|=
name|command_line_input
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|int
name|num
decl_stmt|;
name|arg1
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|>=
literal|'0'
operator|&&
operator|*
name|arg1
operator|<=
literal|'9'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|&&
operator|*
name|arg1
operator|!=
literal|' '
operator|&&
operator|*
name|arg1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be choice numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cancelled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|bcopy
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|return_values
operator|.
name|sals
argument_list|,
operator|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|nelts
operator|=
name|nelts
expr_stmt|;
return|return
name|return_values
return|;
block|}
if|if
condition|(
name|num
operator|>
name|nelts
operator|+
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"No choice number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
condition|)
block|{
name|return_values
operator|.
name|sals
index|[
name|i
operator|++
index|]
operator|=
name|values
operator|.
name|sals
index|[
name|num
index|]
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"duplicate request for %d ignored.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
name|args
operator|=
name|arg1
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
name|return_values
operator|.
name|nelts
operator|=
name|i
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_comment
comment|/* hash a symbol ("hashpjw" from Aho, Sethi& Ullman, p.436) */
end_comment

begin_function
name|int
name|hash_symbol
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|,
name|g
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
operator|++
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
condition|)
block|{
name|h
operator|=
name|h
operator|^
operator|(
name|g
operator|>>
literal|24
operator|)
expr_stmt|;
name|h
operator|=
name|h
operator|^
name|g
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the index of misc function named NAME.  */
end_comment

begin_function
name|int
name|lookup_misc_func
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|hash_symbol
argument_list|(
name|name
argument_list|)
operator|&
operator|(
name|MISC_FUNC_HASH_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|misc_function_vector
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol file"
argument_list|)
expr_stmt|;
name|i
operator|=
name|misc_function_hash_tab
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|=
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|next
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Slave routine for sources_info.  Force line breaks at ,'s.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|name
parameter_list|,
name|next
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|next
decl_stmt|;
block|{
specifier|static
name|int
name|column
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|column
operator|!=
literal|0
operator|&&
name|column
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
literal|70
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|column
operator|!=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|column
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|printf_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|next
condition|)
name|column
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sources_info
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|int
name|column
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symtab_list
operator|==
literal|0
operator|&&
name|partial_symtab_list
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No symbol table is loaded.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Source files for which symbols have been read in:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|output_source_filename
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|s
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source files for which symbols will be read in on demand:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|partial_symtab_list
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
name|output_source_filename
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|ps
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List all symbols (if REGEXP is 0) or all symbols matching REGEXP.    If CLASS is zero, list all symbols except functions and type names.    If CLASS is 1, list only functions.    If CLASS is 2, list only type names.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sort_block_syms
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|list_symbols
parameter_list|(
name|regexp
parameter_list|,
name|class
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|class
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|,
modifier|*
name|bound
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
specifier|static
name|char
modifier|*
name|classnames
index|[]
init|=
block|{
literal|"variable"
block|,
literal|"function"
block|,
literal|"type"
block|,
literal|"method"
block|}
decl_stmt|;
name|int
name|print_count
init|=
literal|0
decl_stmt|;
name|int
name|found_in_file
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regexp
condition|)
if|if
condition|(
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regexp
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Search through the partial_symtab_list *first* for all symbols      matching the regexp.  That way we don't have to reproduce all of      the machinery below. */
for|for
control|(
name|psym
operator|=
name|global_psymbols
operator|.
name|list
operator|,
name|bound
operator|=
name|global_psymbols
operator|.
name|next
init|;
condition|;
name|psym
operator|=
name|static_psymbols
operator|.
name|list
operator|,
name|bound
operator|=
name|static_psymbols
operator|.
name|next
control|)
block|{
for|for
control|(
init|;
name|psym
operator|<
name|bound
condition|;
operator|++
name|psym
control|)
block|{
if|if
condition|(
name|psym
operator|->
name|pst
operator|->
name|readin
condition|)
continue|continue;
name|QUIT
expr_stmt|;
comment|/* If it would match (logic taken from loop below) 	     load the file and go on to the next one */
if|if
condition|(
operator|(
name|regexp
operator|==
literal|0
operator|||
name|re_exec
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|1
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|class
operator|==
literal|3
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
condition|)
name|psymtab_to_symtab
argument_list|(
name|psym
operator|->
name|pst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psym
operator|==
name|static_psymbols
operator|.
name|next
condition|)
break|break;
block|}
comment|/* Printout here so as to get after the "Reading in symbols"      messages which will be generated above.  */
name|printf_filtered
argument_list|(
name|regexp
condition|?
literal|"All %ss matching regular expression \"%s\":\n"
else|:
literal|"All defined %ss:\n"
argument_list|,
name|classnames
index|[
name|class
index|]
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
comment|/* Here, *if* the class is correct (function only, right now), we      should search through the misc function vector for symbols that      match and call find_pc_psymtab on them.  If find_pc_psymtab returns      0, don't worry about it (already read in or no debugging info).  */
if|if
condition|(
name|class
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_function_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regexp
operator|==
literal|0
operator|||
name|re_exec
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
operator|!
name|ps
operator|->
name|readin
condition|)
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|found_in_file
operator|=
literal|0
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Often many files share a blockvector. 	 Scan each blockvector only once so that 	 we don't get every symbol many times. 	 It happens that the first symtab in the list 	 for any given blockvector is the main file.  */
if|if
condition|(
name|bv
operator|!=
name|prev_bv
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Skip the sort if this block is always sorted.  */
if|if
condition|(
operator|!
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regexp
operator|==
literal|0
operator|||
name|re_exec
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|1
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|class
operator|==
literal|3
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|found_in_file
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nFile %s:\n"
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|print_count
operator|+=
literal|2
expr_stmt|;
block|}
name|found_in_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|class
operator|!=
literal|2
operator|&&
name|i
operator|==
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_NAMESPACE
condition|)
name|printf_filtered
argument_list|(
literal|"typedef "
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|<
literal|3
condition|)
block|{
name|type_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|?
literal|""
else|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|||
literal|0
operator|!=
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|" %s"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|char buf[1024]; 			type_print_base (TYPE_FN_FIELD_TYPE(t, i), stdout, 0, 0);  			type_print_varspec_prefix (TYPE_FN_FIELD_TYPE(t, i), stdout, 0);  			sprintf (buf, " %s::", TYPE_NAME (t)); 			type_print_method_args (TYPE_FN_FIELD_ARGS (t, i), buf, name, stdout);
endif|#
directive|endif
block|}
block|}
block|}
block|}
name|prev_bv
operator|=
name|bv
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|variables_info
parameter_list|(
name|regexp
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|functions_info
parameter_list|(
name|regexp
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|types_info
parameter_list|(
name|regexp
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Tiemann says: "info methods was never implemented."  */
end_comment

begin_endif
unit|static void methods_info (regexp)      char *regexp; {   list_symbols (regexp, 3); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Call sort_block_syms to sort alphabetically the symbols of one block.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|struct
name|symbol
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
comment|/* Names that are less should come first.  */
specifier|register
name|int
name|namediff
init|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* For symbols of the same name, registers should come first.  */
return|return
operator|(
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s2
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|-
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|sort_block_syms
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the standard C scalar types.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|init_type
parameter_list|(
name|code
parameter_list|,
name|length
parameter_list|,
name|uns
parameter_list|,
name|name
parameter_list|)
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|length
decl_stmt|,
name|uns
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
expr|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|=
name|uns
condition|?
name|TYPE_FLAG_UNSIGNED
else|:
literal|0
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_PERM
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
comment|/* C++ fancies.  */
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return Nonzero if block a is lexically nested within block b,    or if a and b have the same pc range.    Return zero otherwise. */
end_comment

begin_function
name|int
name|contained_in
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
return|return
name|a
operator|->
name|startaddr
operator|>=
name|b
operator|->
name|startaddr
operator|&&
name|a
operator|->
name|endaddr
operator|<=
name|b
operator|->
name|endaddr
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
name|int
name|return_val_size
decl_stmt|,
name|return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|completion_list_add_symbol
parameter_list|(
name|symname
parameter_list|)
name|char
modifier|*
name|symname
decl_stmt|;
block|{
if|if
condition|(
name|return_val_index
operator|+
literal|3
operator|>
name|return_val_size
condition|)
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|return_val
argument_list|,
operator|(
name|return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|return_val
index|[
name|return_val_index
index|]
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|return_val
index|[
operator|++
name|return_val_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all symbols (regardless of class) which    begin by matching TEXT.  If the answer is no symbols, then the return value    is an array which contains only a NULL pointer.     Problem: All of the symbols have to be copied because readline    frees them.  I'm not going to worry about this; hopefully there    won't be that many.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
decl_stmt|;
specifier|extern
name|struct
name|block
modifier|*
name|get_selected_block
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|int
name|text_len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|return_val_size
operator|=
literal|100
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|return_val_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching TEXT.  Add each one that you find to the list.  */
for|for
control|(
name|ps
operator|=
name|partial_symtab_list
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search 	 through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* If interrupted, then quit. */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc function vector and add each      symbol you find to the list.  Eventually we want to ignore       anything that isn't a text symbol (everything else will be       handled by the psymtab code above).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_function_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|text
argument_list|,
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|text_len
argument_list|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
comment|/* Also catch fields of types defined in this places which 	 match our text string.  Only complete on types visible 	 from current context.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
condition|)
name|completion_list_add_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_symtab
parameter_list|()
block|{
name|add_info
argument_list|(
literal|"variables"
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"functions"
argument_list|,
name|functions_info
argument_list|,
literal|"All function names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"types"
argument_list|,
name|types_info
argument_list|,
literal|"All types names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_info ("methods", methods_info, 	    "All method names, or those matching REGEXP::REGEXP.\n\ If the class qualifier is ommited, it is assumed to be the current scope.\n\ If the first REGEXP is ommited, then all methods matching the second REGEXP\n\ are listed.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"sources"
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program."
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|symbol_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|psymbol_obstack
argument_list|)
expr_stmt|;
name|builtin_type_void
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
name|builtin_type_float
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
name|builtin_type_double
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
name|builtin_type_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
name|builtin_type_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
name|builtin_type_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
name|builtin_type_int
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"unsigned char"
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"unsigned short"
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"unsigned long"
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_int
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"unsigned int"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LONG_LONG
name|builtin_type_long_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
expr|sizeof
operator|(
name|long
name|long
operator|)
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_long_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
expr|sizeof
operator|(
name|long
name|long
operator|)
argument_list|,
literal|1
argument_list|,
literal|"unsigned long long"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

