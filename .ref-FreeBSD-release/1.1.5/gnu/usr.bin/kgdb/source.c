begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)source.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* List lines of source files for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Path of directories to search for source files.    Same format as the PATH environment variable's value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|source_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symtab of default file for listing lines of.  */
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|current_source_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default next line to list.  */
end_comment

begin_decl_stmt
name|int
name|current_source_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last line printed.  Default for various commands.    current_source_line is usually, but not always, the same as this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_line_listed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line number listed by last listing command.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_line_listed
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Set the source file default for the "list" command, specifying a    symtab.  Sigh.  Behaivior specification: If it is called with a    non-zero argument, that is the symtab to select.  If it is not,    first lookup "main"; if it exists, use the symtab and line it    defines.  If not, take the last symtab in the symtab_list (if it    exists) or the last symtab in the psytab_list (if *it* exists).  If    none of this works, report an error.   */
end_comment

begin_function
name|void
name|select_source_symtab
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|,
modifier|*
name|cs_pst
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Make the default place to list be the function `main'      if one exists.  */
if|if
condition|(
name|lookup_symbol
argument_list|(
literal|"main"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
literal|"main"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
literal|9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* All right; find the last file in the symtab list (ignoring .h's).  */
if|if
condition|(
name|s
operator|=
name|symtab_list
condition|)
block|{
do|do
block|{
name|char
modifier|*
name|name
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|s
condition|)
do|;
name|current_source_line
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|partial_symtab_list
condition|)
block|{
name|ps
operator|=
name|partial_symtab_list
expr_stmt|;
while|while
condition|(
name|ps
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|ps
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
name|cs_pst
operator|=
name|ps
expr_stmt|;
name|ps
operator|=
name|ps
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cs_pst
condition|)
if|if
condition|(
name|cs_pst
operator|->
name|readin
condition|)
name|fatal
argument_list|(
literal|"Internal: select_source_symtab: readin pst found and no symtabs."
argument_list|)
expr_stmt|;
else|else
name|current_source_symtab
operator|=
name|psymtab_to_symtab
argument_list|(
name|cs_pst
argument_list|)
expr_stmt|;
else|else
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|current_source_line
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|directories_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Source directories searched: %s\n"
argument_list|,
name|source_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_source_path
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|source_path
operator|=
name|savestring
argument_list|(
name|current_directory
argument_list|,
name|strlen
argument_list|(
name|current_directory
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Forget what we learned about line positions in source files;      must check again now since files may be found in      a different directory now.  */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|directory_command
parameter_list|(
name|dirname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|old
init|=
name|source_path
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Reinitialize source path to %s? "
argument_list|,
name|current_directory
argument_list|)
condition|)
block|{
name|init_source_path
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dirname
operator|=
name|tilde_expand
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|name
init|=
name|dirname
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
block|{
name|char
modifier|*
name|colon
init|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|space
init|=
name|index
argument_list|(
name|name
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tab
init|=
name|index
argument_list|(
name|name
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon
operator|==
literal|0
operator|&&
name|space
operator|==
literal|0
operator|&&
name|tab
operator|==
literal|0
condition|)
name|p
operator|=
name|dirname
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|colon
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|colon
expr_stmt|;
if|if
condition|(
name|space
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|space
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|tab
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|tab
expr_stmt|;
name|dirname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|dirname
operator|==
literal|':'
operator|||
operator|*
name|dirname
operator|==
literal|' '
operator|||
operator|*
name|dirname
operator|==
literal|'\t'
condition|)
operator|++
name|dirname
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Sigh. "foo/" => "foo" */
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|1
condition|)
block|{
comment|/* "." => getwd ().  */
name|name
operator|=
name|current_directory
expr_stmt|;
goto|goto
name|append
goto|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|2
condition|)
block|{
comment|/* "/." => "/".  */
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|append
goto|;
block|}
else|else
block|{
comment|/* "...foo/." => "...foo".  */
name|p
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|name
operator|!=
literal|'/'
condition|)
name|name
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
name|error
argument_list|(
literal|"%s is not a directory."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|append
label|:
block|{
specifier|register
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|p
operator|=
name|source_path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"\"%s\" is already in the source path.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
operator|++
name|p
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|source_path
operator|=
name|concat
argument_list|(
name|old
argument_list|,
literal|":"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|old
operator|=
name|source_path
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|*
name|dirname
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|from_tty
condition|)
name|directories_info
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file named STRING, searching path PATH (dir names sep by colons)    using mode MODE and protection bits PROT in the calls to open.    If TRY_CWD_FIRST, try to open ./STRING before searching PATH.    (ie pretend the first element of PATH is ".")    If FILENAMED_OPENED is non-null, set it to a newly allocated string naming    the actual file opened (this string will always start with a "/"     If a file is found, return the descriptor.    Otherwise, return -1, with errno set for the last name we tried to open.  */
end_comment

begin_comment
comment|/*>>>> This should only allow files of certain types,>>>>  eg executable, non-directory */
end_comment

begin_function
name|int
name|openp
parameter_list|(
name|path
parameter_list|,
name|try_cwd_first
parameter_list|,
name|string
parameter_list|,
name|mode
parameter_list|,
name|prot
parameter_list|,
name|filename_opened
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|try_cwd_first
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename_opened
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
comment|/* ./foo => foo */
while|while
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|string
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|try_cwd_first
operator|||
name|string
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|filename
operator|=
name|string
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
operator|||
name|string
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|done
goto|;
block|}
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
name|p
condition|;
name|p
operator|=
name|p1
condition|?
name|p1
operator|+
literal|1
else|:
literal|0
control|)
block|{
name|p1
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|len
operator|=
name|p1
operator|-
name|p
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|filename
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
break|break;
block|}
name|done
label|:
if|if
condition|(
name|filename_opened
condition|)
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
operator|*
name|filename_opened
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|*
name|filename_opened
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|filename_opened
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and initialize the table S->line_charpos that records    the positions of the lines in the source file, which is assumed    to be open on descriptor DESC.    All set S->nlines to the number of such lines.  */
end_comment

begin_function
specifier|static
name|void
name|find_source_lines
parameter_list|(
name|s
parameter_list|,
name|desc
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|lines_allocated
init|=
literal|1000
decl_stmt|;
name|int
modifier|*
name|line_charpos
init|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|lines_allocated
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|exec_mtime
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|desc
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_exec_file
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|exec_mtime
operator|<
name|st
operator|.
name|st_mtime
condition|)
name|printf
argument_list|(
literal|"Source file is more recent than executable.\n"
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|desc
argument_list|,
name|data
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|end
operator|=
name|data
operator|+
name|st
operator|.
name|st_size
expr_stmt|;
name|p
operator|=
name|data
expr_stmt|;
name|line_charpos
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
comment|/* A newline at the end does not start a new line.  */
operator|&&
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|p
operator|-
name|data
expr_stmt|;
block|}
block|}
name|s
operator|->
name|nlines
operator|=
name|nlines
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|line_charpos
argument_list|,
name|nlines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the character position of a line LINE in symtab S.    Return 0 if anything is invalid.  */
end_comment

begin_function
name|int
name|source_line_charpos
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s
operator|->
name|line_charpos
operator|||
name|line
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
name|line
operator|=
name|s
operator|->
name|nlines
expr_stmt|;
return|return
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the line number of character position POS in symtab S.  */
end_comment

begin_function
name|int
name|source_charpos_line
parameter_list|(
name|s
parameter_list|,
name|chr
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|chr
decl_stmt|;
block|{
specifier|register
name|int
name|line
init|=
literal|0
decl_stmt|;
specifier|register
name|int
modifier|*
name|lnp
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lnp
operator|=
name|s
operator|->
name|line_charpos
expr_stmt|;
comment|/* Files are usually short, so sequential search is Ok */
while|while
condition|(
name|line
operator|<
name|s
operator|->
name|nlines
operator|&&
operator|*
name|lnp
operator|<=
name|chr
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|lnp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>=
name|s
operator|->
name|nlines
condition|)
name|line
operator|=
name|s
operator|->
name|nlines
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get full pathname and line number positions for a symtab.    Return nonzero if line numbers may have changed.    Set *FULLNAME to actual name of the file as found by `openp',    or to 0 if the file is not found.  */
end_comment

begin_function
name|int
name|get_filename_and_charpos
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|fullname
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
modifier|*
name|fullname
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|,
name|linenums_changed
init|=
literal|0
decl_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|linenums_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|linenums_changed
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|linenums_changed
return|;
block|}
end_function

begin_comment
comment|/* Print text describing the full name of the source file S    and the line number LINE and its corresponding character position.    The text starts with two Ctrl-z so that the Emacs-GDB interface    can easily find it.     MID_STATEMENT is nonzero if the PC is not at the beginning of that line.     Return 1 if successful, 0 if could not find the file.  */
end_comment

begin_function
name|int
name|identify_source_line
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|mid_statement
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|mid_statement
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|get_filename_and_charpos
argument_list|(
name|s
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|printf
argument_list|(
literal|"\032\032%s:%d:%d:%s:0x%x\n"
argument_list|,
name|s
operator|->
name|fullname
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
name|mid_statement
condition|?
literal|"middle"
else|:
literal|"beg"
argument_list|,
name|get_frame_pc
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|last_line_listed
operator|=
name|line
expr_stmt|;
name|current_source_symtab
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print source lines from the file of symtab S,    starting with line number LINE and stopping before line number STOPLINE.  */
end_comment

begin_function
name|void
name|print_source_lines
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|stopline
parameter_list|,
name|noerror
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|,
name|stopline
decl_stmt|;
name|int
name|noerror
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|nlines
init|=
name|stopline
operator|-
name|line
decl_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|noerror
operator|&&
name|line
operator|+
literal|1
operator|==
name|stopline
condition|)
block|{
comment|/* can't find the file - tell user where we are anyway */
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|last_line_listed
operator|=
name|line
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t(%s)\n"
argument_list|,
name|current_source_line
operator|++
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noerror
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Line number %d out of range; %s has %d lines."
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|s
operator|->
name|nlines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|last_line_listed
operator|=
name|current_source_line
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t"
argument_list|,
name|current_source_line
operator|++
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|printf_filtered
argument_list|(
literal|"^%c"
argument_list|,
name|c
operator|+
literal|0100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|printf_filtered
argument_list|(
literal|"^?"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    C++   Print a list of files and line numbers which a user may choose from   in order to list a function which was specified ambiguously   (as with `list classname::overloadedfuncname', for example).   The vector in SALS provides the filenames and line numbers.   */
end_comment

begin_function
specifier|static
name|void
name|ambiguous_line_spec
parameter_list|(
name|sals
parameter_list|)
name|struct
name|symtabs_and_lines
modifier|*
name|sals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|"file: \"%s\", line number: %d\n"
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|linenum_beg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|symtab_list
operator|==
literal|0
operator|&&
name|partial_symtab_list
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"symbol-file\" command."
argument_list|)
expr_stmt|;
comment|/* Pull in a current source symtab if necessary */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|arg1
operator|=
name|arg
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* Record whether the BEG arg is all digits.  */
for|for
control|(
name|p
operator|=
name|arg
init|;
name|p
operator|!=
name|arg1
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|linenum_beg
operator|=
operator|(
name|p
operator|==
name|arg1
operator|)
expr_stmt|;
comment|/* if line was specified by address,      print exactly which line, and which file.      In this case, sal.symtab == 0 means address is outside      of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file for address 0x%x."
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|printf
argument_list|(
literal|"0x%x is in %s (%s, line %d).\n"
argument_list|,
name|sal
operator|.
name|pc
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%x is in %s, line %d.\n"
argument_list|,
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* If line was not specified by just a line number,      and it does not imply a symtab, it must be an undebuggable symbol      which means no source code.  */
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|linenum_beg
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|sal
operator|.
name|line
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PUSH_STACK_SIZE
value|32
end_define

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|}
name|push_stack
index|[
name|PUSH_STACK_SIZE
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|push_stack_ptr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_to_file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|cursym
init|=
name|current_source_symtab
decl_stmt|;
name|int
name|curline
init|=
name|current_source_line
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* if we got back, command was successful */
name|i
operator|=
name|push_stack_ptr
expr_stmt|;
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
operator|=
name|cursym
expr_stmt|;
name|push_stack
index|[
name|i
index|]
operator|.
name|line
operator|=
name|curline
expr_stmt|;
name|push_stack_ptr
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|PUSH_STACK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
init|=
name|push_stack_ptr
decl_stmt|;
comment|/* if there's something on the stack, pop it& clear the slot. */
name|i
operator|=
operator|(
name|i
operator|+
operator|(
name|PUSH_STACK_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
name|PUSH_STACK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
condition|)
block|{
name|current_source_symtab
operator|=
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
expr_stmt|;
name|first_line_listed
operator|=
name|current_source_line
operator|=
name|push_stack
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|push_stack_ptr
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|list_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|,
name|sals_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|,
name|sal_end
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|no_end
init|=
literal|1
decl_stmt|;
name|int
name|dummy_end
init|=
literal|0
decl_stmt|;
name|int
name|dummy_beg
init|=
literal|0
decl_stmt|;
name|int
name|linenum_beg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|symtab_list
operator|==
literal|0
operator|&&
name|partial_symtab_list
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"symbol-file\" command."
argument_list|)
expr_stmt|;
comment|/* Pull in a current source symtab if necessary */
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
operator|&&
operator|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* "l" or "l +" lists next ten lines.  */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"+"
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|,
name|current_source_line
operator|+
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* "l -" lists previous ten lines, the ones before the ten just listed.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|max
argument_list|(
name|first_line_listed
operator|-
literal|10
argument_list|,
literal|1
argument_list|)
argument_list|,
name|first_line_listed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now if there is only one argument, decode it in SAL      and set NO_END.      If there are two arguments, decode them in SAL and SAL_END      and clear NO_END; however, if one of the arguments is blank,      set DUMMY_BEG or DUMMY_END to record that fact.  */
name|arg1
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
name|dummy_beg
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
comment|/* Record whether the BEG arg is all digits.  */
for|for
control|(
name|p
operator|=
name|arg
init|;
name|p
operator|!=
name|arg1
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|linenum_beg
operator|=
operator|(
name|p
operator|==
name|arg1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
block|{
name|no_end
operator|=
literal|0
expr_stmt|;
name|arg1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|0
condition|)
name|dummy_end
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dummy_beg
condition|)
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals_end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal_end
operator|=
name|sals_end
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|arg1
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_end
operator|&&
operator|!
name|dummy_beg
operator|&&
operator|!
name|dummy_end
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|sal_end
operator|.
name|symtab
condition|)
name|error
argument_list|(
literal|"Specified start and end are in different files."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|dummy_end
condition|)
name|error
argument_list|(
literal|"Two empty args do not say what lines to list."
argument_list|)
expr_stmt|;
comment|/* if line was specified by address,      first print exactly which line, and which file.      In this case, sal.symtab == 0 means address is outside      of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file for address 0x%x."
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|printf
argument_list|(
literal|"0x%x is in %s (%s, line %d).\n"
argument_list|,
name|sal
operator|.
name|pc
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%x is in %s, line %d.\n"
argument_list|,
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* If line was not specified by just a line number,      and it does not imply a symtab, it must be an undebuggable symbol      which means no source code.  */
if|if
condition|(
operator|!
name|linenum_beg
operator|&&
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* If this command is repeated with RET,      turn it into the no-arg variant.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|sal_end
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
condition|)
name|print_source_lines
argument_list|(
name|sal_end
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal_end
operator|.
name|line
operator|-
literal|9
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal_end
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|no_end
condition|)
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
literal|5
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|dummy_end
condition|?
name|sal
operator|.
name|line
operator|+
literal|10
else|:
name|sal_end
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print info on range of pc's in a specified line.  */
end_comment

begin_function
specifier|static
name|void
name|line_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|start_pc
decl_stmt|,
name|end_pc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|sal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|last_line_listed
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|=
name|decode_line_spec_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this command is repeated with RET, 	 turn it into the no-arg variant.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* C++  More than one line may have been specified, as when the user      specifies an overloaded function name. Print info on them all. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_pc
operator|==
name|end_pc
condition|)
name|printf
argument_list|(
literal|"Line %d of \"%s\" is at pc 0x%x but contains no code.\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|start_pc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Line %d of \"%s\" starts at pc 0x%x and ends at 0x%x.\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|start_pc
argument_list|,
name|end_pc
argument_list|)
expr_stmt|;
comment|/* x/i should display this line's code.  */
name|set_next_address
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
comment|/* Repeating "info line" should do the following line.  */
name|last_line_listed
operator|=
name|sal
operator|.
name|line
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Line number %d is out of range for \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands to search the source file for a regexp.  */
end_comment

begin_function
specifier|static
name|void
name|forward_search_command
parameter_list|(
name|regex
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regex
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
init|=
name|last_line_listed
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Search from last_line_listed+1 in current_source_symtab */
name|desc
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|0
argument_list|,
name|current_source_symtab
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|current_source_symtab
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Should be reasonable??? */
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|/* we now have a source line in buf, null terminate and match */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reverse_search_command
parameter_list|(
name|regex
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regex
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
init|=
name|last_line_listed
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Search from last_line_listed-1 in current_source_symtab */
name|desc
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|0
argument_list|,
name|current_source_symtab
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|current_source_symtab
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Should be reasonable??? */
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|/* We now have a source line in buf; null terminate and match.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|--
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|stream
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_source
parameter_list|()
block|{
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
name|add_com
argument_list|(
literal|"directory"
argument_list|,
name|class_files
argument_list|,
name|directory_command
argument_list|,
literal|"Add directory DIR to end of search path for source files.\n\ With no argument, reset the search path to just the working directory\n\ and forget cached info on line positions in source files."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"directories"
argument_list|,
name|directories_info
argument_list|,
literal|"Current search path for finding source files."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"line"
argument_list|,
name|line_info
argument_list|,
literal|"Core addresses of the code for a source line.\n\ Line can be specified as\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\ Default is to describe the last source line that was listed.\n\n\ This sets the default address for \"x\" to the line's first instruction\n\ so that \"x/i\" suffices to start examining the machine code.\n\ The address is also stored as the value of \"$_\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
name|forward_search_command
argument_list|,
literal|"Search for regular expression (see regex(3)) from last line listed."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"search"
argument_list|,
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"reverse-search"
argument_list|,
name|class_files
argument_list|,
name|reverse_search_command
argument_list|,
literal|"Search backward for regular expression (see regex(3)) from last line listed."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"list"
argument_list|,
name|class_files
argument_list|,
name|list_command
argument_list|,
literal|"List specified function or line.\n\ With no argument, lists ten more lines after or around previous listing.\n\ \"list -\" lists the ten lines before a previous ten-line listing.\n\ One argument specifies a line, and ten lines are listed around that line.\n\ Two arguments with comma between specify starting and ending lines to list.\n\ Lines can be specified in these ways:\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to list around the line containing that address.\n\ With two args if one is empty it stands for ten lines away from the other arg."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"file"
argument_list|,
name|class_files
argument_list|,
name|file_command
argument_list|,
literal|"Select current file, function and line for display or list.\n\ Specification can have the form:\n\   LINENUM, to select that line in current file,\n\   FILE:LINENUM, to select that line in that file,\n\   FUNCTION, to select beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to select the line containing that address."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"push-to-file"
argument_list|,
name|class_files
argument_list|,
name|push_to_file_command
argument_list|,
literal|"Like \"file\" command but remembers current file& line on a stack.\n\ Can later return to current file with \"pop-file\" command.\n\ Up to 32 file positions can be pushed on stack."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pop-file"
argument_list|,
name|class_files
argument_list|,
name|pop_file_command
argument_list|,
literal|"Pops back to file position saved by most recent \"push-to-file\".\n\ If everything has been popped from stack, command does nothing."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

