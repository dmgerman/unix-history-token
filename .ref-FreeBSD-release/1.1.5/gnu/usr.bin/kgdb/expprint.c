begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print in infix form a struct expression.    Copyright (C) 1986, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* These codes indicate operator precedences, least tightly binding first.  */
end_comment

begin_comment
comment|/* Adding 1 to a precedence value is done for binary operators,    on the operand which is more tightly bound, so that operators    of equal precedence within that operand will get parentheses.  */
end_comment

begin_comment
comment|/* PREC_HYPER and PREC_ABOVE_COMMA are not the precedence of any operator;    they are used as the "surrounding precedence" to force    various kinds of things to be parenthesized.  */
end_comment

begin_enum
enum|enum
name|precedence
block|{
name|PREC_NULL
block|,
name|PREC_COMMA
block|,
name|PREC_ABOVE_COMMA
block|,
name|PREC_ASSIGN
block|,
name|PREC_OR
block|,
name|PREC_AND
block|,
name|PREC_LOGIOR
block|,
name|PREC_LOGAND
block|,
name|PREC_LOGXOR
block|,
name|PREC_EQUAL
block|,
name|PREC_ORDER
block|,
name|PREC_SHIFT
block|,
name|PREC_ADD
block|,
name|PREC_MUL
block|,
name|PREC_REPEAT
block|,
name|PREC_HYPER
block|,
name|PREC_PREFIX
block|,
name|PREC_SUFFIX
block|}
enum|;
end_enum

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_struct
struct|struct
name|op_print
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
comment|/* Precedence of operator.  These values are used only by comparisons.  */
name|enum
name|precedence
name|precedence
decl_stmt|;
name|int
name|right_assoc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|op_print
name|op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"||"
block|,
name|BINOP_OR
block|,
name|PREC_OR
block|,
literal|0
block|}
block|,
block|{
literal|"&&"
block|,
name|BINOP_AND
block|,
name|PREC_AND
block|,
literal|0
block|}
block|,
block|{
literal|"|"
block|,
name|BINOP_LOGIOR
block|,
name|PREC_LOGIOR
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_LOGAND
block|,
name|PREC_LOGAND
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|BINOP_LOGXOR
block|,
name|PREC_LOGXOR
block|,
literal|0
block|}
block|,
block|{
literal|"=="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"!="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"%"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"!"
block|,
name|UNOP_ZEROP
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"~"
block|,
name|UNOP_LOGNOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|UNOP_ADDR
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof "
block|,
name|UNOP_SIZEOF
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"++"
block|,
name|UNOP_PREINCREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
name|UNOP_PREDECREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
comment|/* C++  */
block|{
literal|"::"
block|,
name|BINOP_SCOPE
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,   }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|print_subexp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|print_expression
parameter_list|(
name|exp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|stream
argument_list|,
name|PREC_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the subexpression of EXP that starts in position POS, on STREAM.    PREC is the precedence of the surrounding operator;    if the precedence of the main operator of this subexpression is less,    parentheses are needed here.  */
end_comment

begin_function
specifier|static
name|void
name|print_subexp
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|stream
parameter_list|,
name|prec
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|enum
name|precedence
name|prec
decl_stmt|;
block|{
specifier|register
name|int
name|tem
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|int
name|nargs
decl_stmt|;
specifier|register
name|char
modifier|*
name|op_str
decl_stmt|;
name|int
name|assign_modify
init|=
literal|0
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
name|enum
name|precedence
name|myprec
decl_stmt|;
comment|/* Set to 1 for a right-associative operator.  */
name|int
name|assoc
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_SCOPE
case|:
name|myprec
operator|=
name|PREC_PREFIX
expr_stmt|;
name|assoc
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
name|int
operator|)
name|myprec
operator|+
name|assoc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" :: "
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|1
operator|+
operator|(
name|nargs
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_long
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
operator|(
name|int
operator|)
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_REGISTER
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|reg_names
index|[
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|internalvar_name
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_STRING
case|:
name|nargs
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
operator|+
operator|(
name|nargs
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
name|printchar
argument_list|(
operator|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
operator|)
index|[
name|tem
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERNOP_COND
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
comment|/* Print the subexpressions, forcing parentheses 	 around any binary operations within them. 	 This is more parentheses than are strictly necessary, 	 but it looks clearer.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" ? "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
operator|+
operator|(
name|tem
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|".%s"
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
operator|+
operator|(
name|tem
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"->%s"
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_SUBSCRIPT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTINCREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTDECREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|myprec
operator|=
name|PREC_ASSIGN
expr_stmt|;
name|assoc
operator|=
literal|1
expr_stmt|;
name|assign_modify
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
sizeof|sizeof
name|op_print_tab
operator|/
sizeof|sizeof
name|op_print_tab
index|[
literal|0
index|]
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
break|break;
block|}
case|case
name|OP_THIS
case|:
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"this"
argument_list|)
expr_stmt|;
return|return;
default|default:
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
sizeof|sizeof
name|op_print_tab
operator|/
sizeof|sizeof
name|op_print_tab
index|[
literal|0
index|]
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
name|myprec
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|precedence
expr_stmt|;
name|assoc
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|right_assoc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|opcode
operator|>
operator|(
name|int
operator|)
name|BINOP_END
condition|)
block|{
comment|/* Unary prefix operator.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Binary operator.  */
comment|/* Print left operand. 	 If operator is right-associative, 	 increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
name|int
operator|)
name|myprec
operator|+
name|assoc
argument_list|)
expr_stmt|;
comment|/* Print the operator itself.  */
if|if
condition|(
name|assign_modify
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s= "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op_str
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
comment|/* Print right operand. 	 If operator is left-associative, 	 increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
name|int
operator|)
name|myprec
operator|+
operator|!
name|assoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

