begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Do various things to symbol tables (other than lookup)), for GDB.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_function_decl
specifier|static
name|void
name|free_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Free all the symtabs that are currently installed,    and all storage associated with them.    Leaves us in a consistent state with no symtabs installed.  */
end_comment

begin_function
name|void
name|free_all_symtabs
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|,
modifier|*
name|snext
decl_stmt|;
comment|/* All values will be invalid because their types will be!  */
name|clear_value_history
argument_list|()
expr_stmt|;
name|clear_displays
argument_list|()
expr_stmt|;
name|clear_internalvars
argument_list|()
expr_stmt|;
name|clear_breakpoints
argument_list|()
expr_stmt|;
name|set_default_breakpoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|snext
control|)
block|{
name|snext
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|free_symtab
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|symtab_list
operator|=
literal|0
expr_stmt|;
name|obstack_free
argument_list|(
name|symbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|symbol_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|misc_function_vector
condition|)
name|free
argument_list|(
name|misc_function_vector
argument_list|)
expr_stmt|;
name|misc_function_count
operator|=
literal|0
expr_stmt|;
name|misc_function_vector
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a struct block<- B and all the symbols defined in that block.  */
end_comment

begin_function
specifier|static
name|void
name|free_symtab_block
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the storage associated with the struct symtab<- S.    Note that some symtabs have contents malloc'ed structure by structure,    while some have contents that all live inside one big block of memory,    and some share the contents of another symbol table and so you should    not free the contents on their behalf (except sometimes the linetable,    which maybe per symtab even when the rest is not).    It is s->free_code that says which alternative to use.  */
end_comment

begin_function
specifier|static
name|void
name|free_symtab
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|typevector
modifier|*
name|tv
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|free_code
condition|)
block|{
case|case
name|free_nothing
case|:
comment|/* All the contents are part of a big block of memory 	 and some other symtab is in charge of freeing that block. 	 Therefore, do nothing.  */
break|break;
case|case
name|free_contents
case|:
comment|/* Here all the contents were malloc'ed structure by structure 	 and must be freed that way.  */
comment|/* First free the blocks (and their symbols.  */
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|free_symtab_block
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the blockvector itself.  */
name|free
argument_list|(
name|bv
argument_list|)
expr_stmt|;
comment|/* Free the type vector.  */
name|tv
operator|=
name|TYPEVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tv
argument_list|)
expr_stmt|;
comment|/* Also free the linetable.  */
case|case
name|free_linetable
case|:
comment|/* Everything will be freed either by our `free_ptr' 	 or by some other symbatb, except for our linetable. 	 Free that now.  */
name|free
argument_list|(
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If there is a single block of memory to free, free it.  */
if|if
condition|(
name|s
operator|->
name|free_ptr
condition|)
name|free
argument_list|(
name|s
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
condition|)
name|free
argument_list|(
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a raw symbol-segment to a struct symtab,    and relocate its internal pointers so that it is valid.  */
end_comment

begin_comment
comment|/* This is how to relocate one pointer, given a name for it.    Works independent of the type of object pointed to.  */
end_comment

begin_define
define|#
directive|define
name|RELOCATE
parameter_list|(
name|slot
parameter_list|)
value|(slot ? (* (char **)&slot += relocation) : 0)
end_define

begin_comment
comment|/* This is the inverse of RELOCATE.  We use it when storing    a core address into a slot that has yet to be relocated.  */
end_comment

begin_define
define|#
directive|define
name|UNRELOCATE
parameter_list|(
name|slot
parameter_list|)
value|(slot ? (* (char **)&slot -= relocation) : 0)
end_define

begin_comment
comment|/* During the process of relocation, this holds the amount to relocate by    (the address of the file's symtab data, in core in the debugger).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|relocation
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CORE_RELOCATE
parameter_list|(
name|slot
parameter_list|)
define|\
value|((slot) += (((slot)< data_start) ? text_relocation		\ 	      : ((slot)< bss_start) ? data_relocation : bss_relocation))
end_define

begin_define
define|#
directive|define
name|TEXT_RELOCATE
parameter_list|(
name|slot
parameter_list|)
value|((slot) += text_relocation)
end_define

begin_comment
comment|/* Relocation amounts for addresses in the program's core image.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|text_relocation
decl_stmt|,
name|data_relocation
decl_stmt|,
name|bss_relocation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Boundaries that divide program core addresses into text, data and bss;    used to determine which relocation amount to use.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|relocate_typevector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate_blockvector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate_source
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Relocate a file's symseg so that all the pointers are valid C pointers.    Value is a `struct symtab'; but it is not suitable for direct    insertion into the `symtab_list' because it describes several files.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|relocate_symtab
parameter_list|(
name|root
parameter_list|)
name|struct
name|symbol_root
modifier|*
name|root
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|sp
init|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|int
operator|)
name|root
expr_stmt|;
name|text_relocation
operator|=
name|root
operator|->
name|textrel
expr_stmt|;
name|data_relocation
operator|=
name|root
operator|->
name|datarel
expr_stmt|;
name|bss_relocation
operator|=
name|root
operator|->
name|bssrel
expr_stmt|;
name|data_start
operator|=
name|root
operator|->
name|databeg
expr_stmt|;
name|bss_start
operator|=
name|root
operator|->
name|bssbeg
expr_stmt|;
name|sp
operator|->
name|filename
operator|=
name|root
operator|->
name|filename
expr_stmt|;
name|sp
operator|->
name|ldsymoff
operator|=
name|root
operator|->
name|ldsymoff
expr_stmt|;
name|sp
operator|->
name|language
operator|=
name|root
operator|->
name|language
expr_stmt|;
name|sp
operator|->
name|compilation
operator|=
name|root
operator|->
name|compilation
expr_stmt|;
name|sp
operator|->
name|version
operator|=
name|root
operator|->
name|version
expr_stmt|;
name|sp
operator|->
name|blockvector
operator|=
name|root
operator|->
name|blockvector
expr_stmt|;
name|sp
operator|->
name|typevector
operator|=
name|root
operator|->
name|typevector
expr_stmt|;
name|RELOCATE
argument_list|(
name|TYPEVECTOR
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|sp
operator|->
name|version
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|sp
operator|->
name|compilation
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|sp
operator|->
name|filename
argument_list|)
expr_stmt|;
name|relocate_typevector
argument_list|(
name|TYPEVECTOR
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|relocate_blockvector
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|relocate_blockvector
parameter_list|(
name|blp
parameter_list|)
specifier|register
name|struct
name|blockvector
modifier|*
name|blp
decl_stmt|;
block|{
specifier|register
name|int
name|nblocks
init|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blp
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
name|i
operator|++
control|)
name|RELOCATE
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
name|i
operator|++
control|)
name|relocate_block
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|relocate_block
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|int
name|nsyms
init|=
name|BLOCK_NSYMS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|TEXT_RELOCATE
argument_list|(
name|BLOCK_START
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|TEXT_RELOCATE
argument_list|(
name|BLOCK_END
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These two should not be recursively processed.      The superblock need not be because all blocks are      processed from relocate_blockvector.      The function need not be because it will be processed      under the block which is its scope.  */
name|RELOCATE
argument_list|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|RELOCATE
argument_list|(
name|BLOCK_SYM
argument_list|(
name|bp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|relocate_symbol
argument_list|(
name|BLOCK_SYM
argument_list|(
name|bp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|relocate_symbol
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
block|{
name|RELOCATE
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sp
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|RELOCATE
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can assume the block that belongs to this symbol 	 is not relocated yet, since it comes after 	 the block that contains this symbol.  */
name|BLOCK_FUNCTION
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|=
name|sp
expr_stmt|;
name|UNRELOCATE
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sp
argument_list|)
operator|==
name|LOC_STATIC
condition|)
name|CORE_RELOCATE
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sp
argument_list|)
operator|==
name|LOC_LABEL
condition|)
name|TEXT_RELOCATE
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|relocate_typevector
parameter_list|(
name|tv
parameter_list|)
name|struct
name|typevector
modifier|*
name|tv
decl_stmt|;
block|{
specifier|register
name|int
name|ntypes
init|=
name|TYPEVECTOR_NTYPES
argument_list|(
name|tv
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntypes
condition|;
name|i
operator|++
control|)
name|RELOCATE
argument_list|(
name|TYPEVECTOR_TYPE
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntypes
condition|;
name|i
operator|++
control|)
name|relocate_type
argument_list|(
name|TYPEVECTOR_TYPE
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We cannot come up with an a priori spanning tree    for the network of types, since types can be used    for many symbols and also as components of other types.    Therefore, we need to be able to mark types that we    already have relocated (or are already in the middle of relocating)    as in a garbage collector.  */
end_comment

begin_function
specifier|static
name|void
name|relocate_type
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|type
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|int
name|nfields
init|=
name|TYPE_NFIELDS
argument_list|(
name|tp
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|RELOCATE
argument_list|(
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|TYPE_POINTER_TYPE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfields
condition|;
name|i
operator|++
control|)
block|{
name|RELOCATE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|relocate_sourcevector
parameter_list|(
name|svp
parameter_list|)
specifier|register
name|struct
name|sourcevector
modifier|*
name|svp
decl_stmt|;
block|{
specifier|register
name|int
name|nfiles
init|=
name|svp
operator|->
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
name|RELOCATE
argument_list|(
name|svp
operator|->
name|source
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
name|relocate_source
argument_list|(
name|svp
operator|->
name|source
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|relocate_source
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|source
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|nitems
init|=
name|sp
operator|->
name|contents
operator|.
name|nitems
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|RELOCATE
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
name|TEXT_RELOCATE
argument_list|(
name|sp
operator|->
name|contents
operator|.
name|item
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read symsegs from file named NAME open on DESC,    make symtabs from them, and return a chain of them.    These symtabs are not suitable for direct use in `symtab_list'    because each one describes a single object file, perhaps many source files.    `symbol_file_command' takes each of these, makes many real symtabs    from it, and then frees it.     We assume DESC is prepositioned at the end of the string table,    just before the symsegs if there are any.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|read_symsegs
parameter_list|(
name|desc
parameter_list|,
name|name
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol_root
name|root
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|chain
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
name|myread
argument_list|(
name|desc
argument_list|,
operator|&
name|root
argument_list|,
sizeof|sizeof
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|root
operator|.
name|format
operator|==
literal|0
condition|)
break|break;
comment|/* format 1 was ok for the original gdb, but since the size of the 	 type structure changed when C++ support was added, it can no 	 longer be used.  Accept only format 2. */
if|if
condition|(
name|root
operator|.
name|format
operator|!=
literal|2
operator|||
name|root
operator|.
name|length
operator|<
sizeof|sizeof
name|root
condition|)
name|error
argument_list|(
literal|"\nInvalid symbol segment format code"
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|root
operator|.
name|length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|root
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|root
argument_list|)
expr_stmt|;
name|len
operator|=
name|myread
argument_list|(
name|desc
argument_list|,
name|data
operator|+
sizeof|sizeof
name|root
argument_list|,
name|root
operator|.
name|length
operator|-
sizeof|sizeof
name|root
argument_list|)
expr_stmt|;
name|sp
operator|=
name|relocate_symtab
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|RELOCATE
argument_list|(
operator|(
operator|(
expr|struct
name|symbol_root
operator|*
operator|)
name|data
operator|)
operator|->
name|sourcevector
argument_list|)
expr_stmt|;
name|relocate_sourcevector
argument_list|(
operator|(
operator|(
expr|struct
name|symbol_root
operator|*
operator|)
name|data
operator|)
operator|->
name|sourcevector
argument_list|)
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|linetable
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
operator|(
operator|(
expr|struct
name|symbol_root
operator|*
operator|)
name|data
operator|)
operator|->
name|sourcevector
expr_stmt|;
block|}
return|return
name|chain
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|block_depth
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_spaces
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|print_symtabs
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|outfile
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|,
name|line
decl_stmt|,
name|blen
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"file to write symbol data in"
argument_list|)
expr_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* First print the line table.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Symtab for file %s\n\n"
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Line table:\n\n"
argument_list|)
expr_stmt|;
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" line %d at %x\n"
argument_list|,
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|line
argument_list|,
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
comment|/* Now print the block info.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nBlockvector:\n\n"
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|depth
operator|=
name|block_depth
argument_list|(
name|b
argument_list|)
operator|*
literal|2
expr_stmt|;
name|print_spaces
argument_list|(
name|depth
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"block #%03d (object 0x%x) "
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"[0x%x..0x%x]"
argument_list|,
name|BLOCK_START
argument_list|(
name|b
argument_list|)
argument_list|,
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (under 0x%x)"
argument_list|,
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|blen
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blen
condition|;
name|j
operator|++
control|)
block|{
name|print_symbol
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|--
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_symbol
parameter_list|(
name|symbol
parameter_list|,
name|depth
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|print_spaces
argument_list|(
name|depth
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|symbol
argument_list|)
operator|==
name|LABEL_NAMESPACE
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label %s at 0x%x\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|symbol
argument_list|)
operator|==
name|STRUCT_NAMESPACE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
block|{
name|type_print_1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|""
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s = "
argument_list|,
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|?
literal|"enum"
else|:
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|?
literal|"struct"
else|:
literal|"union"
operator|)
operator|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|type_print_1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|""
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|type_print_1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"const %d (0x%x),"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"const %d hex bytes:"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %2x"
argument_list|,
name|SYMBOL_VALUE_BYTES
argument_list|(
name|symbol
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_STATIC
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"static at 0x%x,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"register %d,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"arg at 0x%x,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"reference arg at 0x%x,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"parameter register %d,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"local at 0x%x,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
break|break;
case|case
name|LOC_LABEL
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label at 0x%x"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"block (object 0x%x) starting at 0x%x,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the nexting depth of a block within other blocks in its symtab.  */
end_comment

begin_function
specifier|static
name|int
name|block_depth
parameter_list|(
name|block
parameter_list|)
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Free all partial_symtab storage.  */
end_comment

begin_function
name|void
name|free_all_psymtabs
parameter_list|()
block|{
name|obstack_free
argument_list|(
name|psymbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|psymbol_obstack
argument_list|)
expr_stmt|;
name|partial_symtab_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_symmisc
parameter_list|()
block|{
name|symtab_list
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|partial_symtab_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|add_com
argument_list|(
literal|"printsyms"
argument_list|,
name|class_obscure
argument_list|,
name|print_symtabs
argument_list|,
literal|"Print dump of current symbol definitions to file OUTFILE."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

