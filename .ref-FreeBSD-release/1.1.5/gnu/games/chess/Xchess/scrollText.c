begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * A Scrollable Text Output Window  *  * David Harrison   * University of California,  Berkeley  * 1986  *  * The following is an implementation for a scrollable text output  * system.  It handles exposure events only (other interactions are  * under user control).  For scrolling,  a always present scroll bar  * is implemented.  It detects size changes and compensates accordingly.  */
end_comment

begin_include
include|#
directive|include
file|<X11/X.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X11/X10.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"scrollText.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|alloc
parameter_list|(
name|type
parameter_list|)
value|(type *) malloc(sizeof(type))
end_define

begin_define
define|#
directive|define
name|numalloc
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
value|(type *) malloc((unsigned) (num * sizeof(type)))
end_define

begin_define
define|#
directive|define
name|MAXINT
value|2147483647
end_define

begin_function_decl
specifier|extern
name|XAssocTable
modifier|*
name|XCreateAssocTable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|caddr_t
name|XLookUpAssoc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|XAssocTable
modifier|*
name|textWindows
init|=
operator|(
name|XAssocTable
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOOPTION
value|-1
end_define

begin_comment
comment|/* Option hasn't been set yet                */
end_comment

begin_define
define|#
directive|define
name|NORMSCROLL
value|0
end_define

begin_comment
comment|/* Smooth scroll on LineToTop and TopToHere  */
end_comment

begin_define
define|#
directive|define
name|JUMPSCROLL
value|1
end_define

begin_comment
comment|/* Jump scrolling on LineToTop and TopToHere */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ScrollOption
init|=
name|NOOPTION
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|char
modifier|*
name|Generic
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DEFAULT_GC
value|textInfo->fontGC[textInfo->curFont]
end_define

begin_define
define|#
directive|define
name|BARSIZE
value|15
end_define

begin_define
define|#
directive|define
name|BARBORDER
value|1
end_define

begin_define
define|#
directive|define
name|MAXFONTS
value|8
end_define

begin_define
define|#
directive|define
name|INITBUFSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|INITLINES
value|50
end_define

begin_define
define|#
directive|define
name|INITEXPARY
value|50
end_define

begin_define
define|#
directive|define
name|XPADDING
value|2
end_define

begin_define
define|#
directive|define
name|YPADDING
value|2
end_define

begin_define
define|#
directive|define
name|INTERLINE
value|5
end_define

begin_define
define|#
directive|define
name|INTERSPACE
value|1
end_define

begin_define
define|#
directive|define
name|CURSORWIDTH
value|2
end_define

begin_define
define|#
directive|define
name|EXPANDPERCENT
value|40
end_define

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|CUROFFSET
value|1
end_define

begin_define
define|#
directive|define
name|MAXFOREIGN
value|250
end_define

begin_define
define|#
directive|define
name|NOINDEX
value|-1
end_define

begin_comment
comment|/* The wrap line indicator */
end_comment

begin_define
define|#
directive|define
name|WRAPINDSIZE
value|7
end_define

begin_define
define|#
directive|define
name|STEMOFFSET
value|5
end_define

begin_define
define|#
directive|define
name|arrow_width
value|7
end_define

begin_define
define|#
directive|define
name|arrow_height
value|5
end_define

begin_decl_stmt
specifier|static
name|char
name|arrow_bits
index|[]
init|=
block|{
literal|0x24
block|,
literal|0x26
block|,
literal|0x3f
block|,
literal|0x06
block|,
literal|0x04
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEWLINE
value|'\n'
end_define

begin_define
define|#
directive|define
name|BACKSPACE
value|'\010'
end_define

begin_define
define|#
directive|define
name|NEWFONT
value|'\006'
end_define

begin_define
define|#
directive|define
name|LOWCHAR
value|'\040'
end_define

begin_define
define|#
directive|define
name|HIGHCHAR
value|'\176'
end_define

begin_define
define|#
directive|define
name|CHARMASK
value|0x00ff
end_define

begin_comment
comment|/* Character mask */
end_comment

begin_define
define|#
directive|define
name|FONTMASK
value|0x0700
end_define

begin_comment
comment|/* Character font */
end_comment

begin_define
define|#
directive|define
name|FONTSHIFT
value|8
end_define

begin_comment
comment|/* Shift amount   */
end_comment

begin_define
define|#
directive|define
name|WRAPFLAG
value|0x01
end_define

begin_comment
comment|/* Line wrap flag */
end_comment

begin_comment
comment|/*  * Lines are represented by a pointer into the overall array of  * 16-bit characters.  The lower eight bits is used to indicate the character  * (in ASCII),  and the next two bits are used to indicate the font  * the character should be drawn in.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|txtLine
block|{
name|int
name|lineLength
decl_stmt|;
comment|/* Current line length               */
name|int
name|lineHeight
decl_stmt|;
comment|/* Full height of line in pixels     */
name|int
name|lineBaseLine
decl_stmt|;
comment|/* Current baseline of the line      */
name|int
name|lineWidth
decl_stmt|;
comment|/* Drawing position at end of line   */
name|int
name|lineText
decl_stmt|;
comment|/* Offset into master buffer         */
name|int
name|lineFlags
decl_stmt|;
comment|/* Line wrap flag is here            */
block|}
empty_stmt|;
end_typedef

begin_comment
comment|/*  * For ExposeCopy events,  we queue up the redraw requests collapsing  * them into line redraw requests until the CopyExpose event arrives.  * The queue is represented as a dynamic array of the following  * structure:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|expEvent
block|{
name|int
name|lineIndex
decl_stmt|;
comment|/* Index of line to redraw  */
name|int
name|ypos
decl_stmt|;
comment|/* Drawing position of line */
block|}
empty_stmt|;
end_typedef

begin_comment
comment|/*  * The text buffer is represented using a dynamic counted array  * of 16-bit quantities. This array expands as needed.  * For the screen representation,  a dynamic counted array  * of line structures is used.  This array points into the  * text buffer to denote the start of each line and its parameters.  * The windows are configured as one overall window which contains  * the scroll bar as a sub-window along its right edge.  Thus,  * the text drawing space is actually w-BARSIZE.  */
end_comment

begin_define
define|#
directive|define
name|NOTATBOTTOM
value|0x01
end_define

begin_comment
comment|/* Need to scroll to bottom before appending */
end_comment

begin_define
define|#
directive|define
name|FONTNUMWAIT
value|0x02
end_define

begin_comment
comment|/* Waiting for font number                   */
end_comment

begin_define
define|#
directive|define
name|COPYEXPOSE
value|0x04
end_define

begin_comment
comment|/* Need to process a copy expose event       */
end_comment

begin_define
define|#
directive|define
name|SCREENWRONG
value|0x08
end_define

begin_comment
comment|/* TxtJamStr has invalidated screen contents */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|txtWin
block|{
comment|/* Basic text buffer */
name|int
name|bufAlloc
decl_stmt|;
comment|/* Allocated size of buffer           */
name|int
name|bufSpot
decl_stmt|;
comment|/* Current writing position in buffer */
name|short
modifier|*
name|mainBuffer
decl_stmt|;
comment|/* Main buffer of text                */
comment|/* Line information */
name|int
name|numLines
decl_stmt|;
comment|/* Number of display lines in buffer */
name|int
name|allocLines
decl_stmt|;
comment|/* Number of lines allocated 	     */
name|struct
name|txtLine
modifier|*
modifier|*
name|txtBuffer
decl_stmt|;
comment|/* Dynamic array of lines    	     */
comment|/* Current Window display information */
name|Window
name|mainWindow
decl_stmt|;
comment|/* Text display window       */
name|Window
name|scrollBar
decl_stmt|;
comment|/* Subwindow for scroll bar  */
name|Pixmap
name|arrowMap
decl_stmt|;
comment|/* line wrap indicator       */
name|int
name|bgPix
decl_stmt|,
name|fgPix
decl_stmt|;
comment|/* Background and cursor     */
name|GC
name|CursorGC
decl_stmt|;
comment|/* gc for the cursor         */
name|GC
name|bgGC
decl_stmt|;
comment|/* gc for erasing things     */
name|GC
name|fontGC
index|[
name|MAXFONTS
index|]
decl_stmt|;
comment|/* gc for doing fonts        */
name|XFontStruct
name|theFonts
index|[
name|MAXFONTS
index|]
decl_stmt|;
comment|/* Display fonts          */
name|int
name|theColors
index|[
name|MAXFONTS
index|]
decl_stmt|;
comment|/* foregrounds of the fonts  */
name|int
name|curFont
decl_stmt|;
comment|/* current font for tracking */
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
comment|/* Current size              */
name|int
name|startLine
decl_stmt|;
comment|/* Top line in display       */
name|int
name|endLine
decl_stmt|;
comment|/* Bottom line in display    */
name|int
name|bottomSpace
decl_stmt|;
comment|/* Space at bottom of screen */
name|int
name|flagWord
decl_stmt|;
comment|/* If non-zero,  not at end  */
comment|/* For handling ExposeCopy events */
name|int
name|exposeSize
decl_stmt|;
comment|/* Current size of array      */
name|int
name|exposeAlloc
decl_stmt|;
comment|/* Allocated size             */
name|struct
name|expEvent
modifier|*
modifier|*
name|exposeAry
decl_stmt|;
comment|/* Array of line indices      */
comment|/* Drawing position information */
name|int
name|curLine
decl_stmt|;
comment|/* Current line in buffer    */
name|int
name|curX
decl_stmt|;
comment|/* Current horizontal positi */
name|int
name|curY
decl_stmt|;
comment|/* Current vertical drawing  */
block|}
empty_stmt|;
end_typedef

begin_comment
comment|/* Flags for the various basic character handling functions */
end_comment

begin_define
define|#
directive|define
name|DODISP
value|0x01
end_define

begin_comment
comment|/* Update the display  */
end_comment

begin_define
define|#
directive|define
name|NONEWLINE
value|0x02
end_define

begin_comment
comment|/* Dont append newline */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|int
name|InitLine
parameter_list|(
name|newLine
parameter_list|)
name|struct
name|txtLine
modifier|*
name|newLine
decl_stmt|;
comment|/* Newly created line structure */
comment|/*  * This routine initializes a newly created line structure.  */
block|{
name|newLine
operator|->
name|lineLength
operator|=
literal|0
expr_stmt|;
name|newLine
operator|->
name|lineHeight
operator|=
literal|0
expr_stmt|;
name|newLine
operator|->
name|lineBaseLine
operator|=
literal|0
expr_stmt|;
name|newLine
operator|->
name|lineWidth
operator|=
name|XPADDING
expr_stmt|;
name|newLine
operator|->
name|lineText
operator|=
name|NOINDEX
expr_stmt|;
name|newLine
operator|->
name|lineFlags
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtGrab
parameter_list|(
name|display
parameter_list|,
name|txtWin
parameter_list|,
name|program
parameter_list|,
name|mainFont
parameter_list|,
name|bg
parameter_list|,
name|fg
parameter_list|,
name|cur
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
comment|/* display window is on  */
name|Window
name|txtWin
decl_stmt|;
comment|/* Window to take over as scrollable text    */
name|char
modifier|*
name|program
decl_stmt|;
comment|/* Program name for Xdefaults                */
name|XFontStruct
modifier|*
name|mainFont
decl_stmt|;
comment|/* Primary text font                         */
name|int
name|bg
decl_stmt|,
name|fg
decl_stmt|,
name|cur
decl_stmt|;
comment|/* Background, foreground, and cursor colors */
comment|/*  * This routine takes control of 'txtWin' and makes it into a scrollable  * text output window.  It will create a sub-window for the scroll bar  * with a background of 'bg' and an bar with color 'fg'.  Both fixed width  * and variable width fonts are supported.  Additional fonts can be loaded  * using 'TxtAddFont'.  Returns 0 if there were problems,  non-zero if  * everything went ok.  */
block|{
name|struct
name|txtWin
modifier|*
name|newWin
decl_stmt|;
comment|/* Text package specific information */
name|XWindowAttributes
name|winInfo
decl_stmt|;
comment|/* Window information                */
name|int
name|index
decl_stmt|;
name|XGCValues
name|gc_val
decl_stmt|;
if|if
condition|(
name|textWindows
operator|==
operator|(
name|XAssocTable
operator|*
operator|)
literal|0
condition|)
block|{
name|textWindows
operator|=
name|XCreateAssocTable
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|textWindows
operator|==
operator|(
name|XAssocTable
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|XGetWindowAttributes
argument_list|(
name|display
argument_list|,
name|txtWin
argument_list|,
operator|&
name|winInfo
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ScrollOption
operator|==
name|NOOPTION
condition|)
block|{
comment|/* Read to see if the user wants jump scrolling or not */
if|if
condition|(
name|XGetDefault
argument_list|(
name|display
argument_list|,
name|program
argument_list|,
literal|"JumpScroll"
argument_list|)
condition|)
block|{
name|ScrollOption
operator|=
name|JUMPSCROLL
expr_stmt|;
block|}
else|else
block|{
name|ScrollOption
operator|=
name|NORMSCROLL
expr_stmt|;
block|}
block|}
comment|/* Initialize local structure */
name|newWin
operator|=
name|alloc
argument_list|(
expr|struct
name|txtWin
argument_list|)
expr_stmt|;
comment|/* Initialize arrow pixmap */
name|newWin
operator|->
name|arrowMap
operator|=
name|XCreatePixmapFromBitmapData
argument_list|(
name|display
argument_list|,
name|txtWin
argument_list|,
name|arrow_bits
argument_list|,
name|arrow_width
argument_list|,
name|arrow_height
argument_list|,
name|cur
argument_list|,
name|bg
argument_list|,
name|DisplayPlanes
argument_list|(
name|display
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newWin
operator|->
name|bufAlloc
operator|=
name|INITBUFSIZE
expr_stmt|;
name|newWin
operator|->
name|bufSpot
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|mainBuffer
operator|=
name|numalloc
argument_list|(
name|short
argument_list|,
name|INITBUFSIZE
argument_list|)
expr_stmt|;
name|newWin
operator|->
name|numLines
operator|=
literal|1
expr_stmt|;
name|newWin
operator|->
name|allocLines
operator|=
name|INITLINES
expr_stmt|;
name|newWin
operator|->
name|txtBuffer
operator|=
name|numalloc
argument_list|(
expr|struct
name|txtLine
operator|*
argument_list|,
name|INITLINES
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|INITLINES
condition|;
name|index
operator|++
control|)
block|{
name|newWin
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|=
name|alloc
argument_list|(
expr|struct
name|txtLine
argument_list|)
expr_stmt|;
name|InitLine
argument_list|(
name|newWin
operator|->
name|txtBuffer
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Window display information */
name|newWin
operator|->
name|mainWindow
operator|=
name|txtWin
expr_stmt|;
name|newWin
operator|->
name|w
operator|=
name|winInfo
operator|.
name|width
expr_stmt|;
name|newWin
operator|->
name|h
operator|=
name|winInfo
operator|.
name|height
expr_stmt|;
name|newWin
operator|->
name|startLine
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|endLine
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|bottomSpace
operator|=
name|winInfo
operator|.
name|height
operator|-
name|YPADDING
operator|-
name|mainFont
operator|->
name|ascent
operator|-
name|mainFont
operator|->
name|descent
operator|-
name|INTERLINE
expr_stmt|;
name|newWin
operator|->
name|flagWord
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|bgPix
operator|=
name|bg
expr_stmt|;
name|newWin
operator|->
name|fgPix
operator|=
name|fg
expr_stmt|;
comment|/* Scroll Bar Creation */
name|newWin
operator|->
name|scrollBar
operator|=
name|XCreateSimpleWindow
argument_list|(
name|display
argument_list|,
name|txtWin
argument_list|,
name|winInfo
operator|.
name|width
operator|-
name|BARSIZE
argument_list|,
literal|0
argument_list|,
name|BARSIZE
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
argument_list|,
name|winInfo
operator|.
name|height
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
argument_list|,
name|BARBORDER
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|display
argument_list|,
name|newWin
operator|->
name|scrollBar
argument_list|,
name|ExposureMask
operator||
name|ButtonReleaseMask
argument_list|)
expr_stmt|;
name|XMapRaised
argument_list|(
name|display
argument_list|,
name|newWin
operator|->
name|scrollBar
argument_list|)
expr_stmt|;
comment|/* Font and Color Initialization */
name|newWin
operator|->
name|theFonts
index|[
literal|0
index|]
operator|=
operator|*
name|mainFont
expr_stmt|;
name|newWin
operator|->
name|theColors
index|[
literal|0
index|]
operator|=
name|fg
expr_stmt|;
name|gc_val
operator|.
name|function
operator|=
name|GXcopy
expr_stmt|;
name|gc_val
operator|.
name|plane_mask
operator|=
name|AllPlanes
expr_stmt|;
name|gc_val
operator|.
name|foreground
operator|=
name|fg
expr_stmt|;
name|gc_val
operator|.
name|background
operator|=
name|bg
expr_stmt|;
name|gc_val
operator|.
name|graphics_exposures
operator|=
literal|1
expr_stmt|;
name|gc_val
operator|.
name|font
operator|=
name|mainFont
operator|->
name|fid
expr_stmt|;
name|gc_val
operator|.
name|line_width
operator|=
literal|1
expr_stmt|;
name|gc_val
operator|.
name|line_style
operator|=
name|LineSolid
expr_stmt|;
name|newWin
operator|->
name|fontGC
index|[
literal|0
index|]
operator|=
name|XCreateGC
argument_list|(
name|display
argument_list|,
name|txtWin
argument_list|,
name|GCFunction
operator||
name|GCPlaneMask
operator||
name|GCForeground
operator||
name|GCBackground
operator||
name|GCGraphicsExposures
operator||
name|GCFont
argument_list|,
operator|&
name|gc_val
argument_list|)
expr_stmt|;
name|gc_val
operator|.
name|foreground
operator|=
name|cur
expr_stmt|;
name|newWin
operator|->
name|CursorGC
operator|=
name|XCreateGC
argument_list|(
name|display
argument_list|,
name|txtWin
argument_list|,
name|GCFunction
operator||
name|GCPlaneMask
operator||
name|GCForeground
operator||
name|GCBackground
operator||
name|GCLineStyle
operator||
name|GCLineWidth
argument_list|,
operator|&
name|gc_val
argument_list|)
expr_stmt|;
name|gc_val
operator|.
name|foreground
operator|=
name|bg
expr_stmt|;
name|newWin
operator|->
name|bgGC
operator|=
name|XCreateGC
argument_list|(
name|display
argument_list|,
name|txtWin
argument_list|,
name|GCFunction
operator||
name|GCPlaneMask
operator||
name|GCForeground
operator||
name|GCBackground
operator||
name|GCGraphicsExposures
operator||
name|GCFont
argument_list|,
operator|&
name|gc_val
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<
name|MAXFONTS
condition|;
name|index
operator|++
control|)
block|{
name|newWin
operator|->
name|theFonts
index|[
name|index
index|]
operator|.
name|fid
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|fontGC
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initialize size of first line */
name|newWin
operator|->
name|txtBuffer
index|[
literal|0
index|]
operator|->
name|lineHeight
operator|=
name|newWin
operator|->
name|theFonts
index|[
literal|0
index|]
operator|.
name|ascent
operator|+
name|newWin
operator|->
name|theFonts
index|[
literal|0
index|]
operator|.
name|descent
expr_stmt|;
name|newWin
operator|->
name|txtBuffer
index|[
literal|0
index|]
operator|->
name|lineText
operator|=
literal|0
expr_stmt|;
comment|/* ExposeCopy array initialization */
name|newWin
operator|->
name|exposeSize
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|exposeAlloc
operator|=
name|INITEXPARY
expr_stmt|;
name|newWin
operator|->
name|exposeAry
operator|=
name|numalloc
argument_list|(
expr|struct
name|expEvent
operator|*
argument_list|,
name|INITEXPARY
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|newWin
operator|->
name|exposeAlloc
condition|;
name|index
operator|++
control|)
name|newWin
operator|->
name|exposeAry
index|[
name|index
index|]
operator|=
name|alloc
argument_list|(
expr|struct
name|expEvent
argument_list|)
expr_stmt|;
comment|/* Put plus infinity in last slot for sorting purposes */
name|newWin
operator|->
name|exposeAry
index|[
literal|0
index|]
operator|->
name|lineIndex
operator|=
name|MAXINT
expr_stmt|;
comment|/* Drawing Position Information */
name|newWin
operator|->
name|curLine
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|curX
operator|=
literal|0
expr_stmt|;
name|newWin
operator|->
name|curY
operator|=
name|YPADDING
operator|+
name|mainFont
operator|->
name|ascent
operator|+
name|mainFont
operator|->
name|descent
expr_stmt|;
comment|/* Attach it to both windows */
name|XMakeAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|txtWin
argument_list|,
operator|(
name|caddr_t
operator|)
name|newWin
argument_list|)
expr_stmt|;
name|XMakeAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|newWin
operator|->
name|scrollBar
argument_list|,
operator|(
name|caddr_t
operator|)
name|newWin
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtRelease
parameter_list|(
name|display
parameter_list|,
name|w
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|w
decl_stmt|;
comment|/* Window to release */
comment|/*  * This routine releases all resources associated with the  * specified window which are consumed by the text  * window package. This includes the entire text buffer,  line start  * array,  and the scroll bar window.  However,  the window  * itself is NOT destroyed.  The routine will return zero if  * the window is not owned by the text window package.  */
block|{
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAXFONTS
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|textInfo
operator|->
name|fontGC
index|[
name|index
index|]
operator|!=
literal|0
condition|)
name|XFreeGC
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|fontGC
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Generic
operator|)
name|textInfo
operator|->
name|mainBuffer
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|textInfo
operator|->
name|numLines
condition|;
name|index
operator|++
control|)
block|{
name|free
argument_list|(
operator|(
name|Generic
operator|)
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|Generic
operator|)
name|textInfo
operator|->
name|txtBuffer
argument_list|)
expr_stmt|;
name|XDestroyWindow
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|scrollBar
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|textInfo
operator|->
name|exposeSize
condition|;
name|index
operator|++
control|)
block|{
name|free
argument_list|(
operator|(
name|Generic
operator|)
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|Generic
operator|)
name|textInfo
operator|->
name|exposeAry
argument_list|)
expr_stmt|;
name|XDeleteAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Generic
operator|)
name|textInfo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|RecompBuffer
parameter_list|(
name|textInfo
parameter_list|)
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information */
comment|/*  * This routine recomputes all line breaks in a buffer after  * a change in window size or font.  This is done by throwing  * away the old line start array and recomputing it.  Although  * a lot of this work is also done elsewhere,  it has been included  * inline here for efficiency.  */
block|{
name|int
name|startPos
decl_stmt|,
name|endSize
decl_stmt|,
name|linenum
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|,
name|chsize
decl_stmt|,
name|curfont
decl_stmt|;
specifier|register
name|short
modifier|*
name|bufptr
decl_stmt|;
specifier|register
name|XFontStruct
modifier|*
name|fontptr
decl_stmt|;
specifier|register
name|struct
name|txtLine
modifier|*
name|lineptr
decl_stmt|;
name|char
name|theChar
decl_stmt|;
comment|/* Record the old position so we can come back to it */
for|for
control|(
name|startPos
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|startLine
index|]
operator|->
name|lineText
init|;
operator|(
name|startPos
operator|>
literal|0
operator|)
operator|&&
operator|(
name|textInfo
operator|->
name|mainBuffer
index|[
name|startPos
index|]
operator|!=
literal|'\n'
operator|)
condition|;
name|startPos
operator|--
control|)
comment|/* null loop body */
empty_stmt|;
comment|/* Clear out the old line start array */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|textInfo
operator|->
name|numLines
condition|;
name|index
operator|++
control|)
block|{
name|InitLine
argument_list|(
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize first line */
name|textInfo
operator|->
name|txtBuffer
index|[
literal|0
index|]
operator|->
name|lineHeight
operator|=
name|textInfo
operator|->
name|theFonts
index|[
literal|0
index|]
operator|.
name|ascent
operator|+
name|textInfo
operator|->
name|theFonts
index|[
literal|0
index|]
operator|.
name|descent
expr_stmt|;
name|textInfo
operator|->
name|txtBuffer
index|[
literal|0
index|]
operator|->
name|lineText
operator|=
literal|0
expr_stmt|;
comment|/* Process the text back into lines */
name|endSize
operator|=
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
operator|-
name|WRAPINDSIZE
expr_stmt|;
name|bufptr
operator|=
name|textInfo
operator|->
name|mainBuffer
expr_stmt|;
name|lineptr
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
literal|0
index|]
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
name|fontptr
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|theFonts
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|curfont
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|textInfo
operator|->
name|bufSpot
condition|;
name|index
operator|++
control|)
block|{
name|theChar
operator|=
name|bufptr
index|[
name|index
index|]
operator|&
name|CHARMASK
expr_stmt|;
if|if
condition|(
operator|(
name|bufptr
index|[
name|index
index|]
operator|&
name|FONTMASK
operator|)
operator|!=
name|curfont
condition|)
block|{
name|int
name|newFontNum
decl_stmt|,
name|heightDiff
decl_stmt|;
comment|/* Switch fonts */
name|newFontNum
operator|=
operator|(
name|bufptr
index|[
name|index
index|]
operator|&
name|FONTMASK
operator|)
operator|>>
name|FONTSHIFT
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|theFonts
index|[
name|newFontNum
index|]
operator|.
name|fid
operator|!=
literal|0
condition|)
block|{
comment|/* Valid font */
name|curfont
operator|=
name|bufptr
index|[
name|index
index|]
operator|&
name|FONTMASK
expr_stmt|;
name|fontptr
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|theFonts
index|[
name|newFontNum
index|]
operator|)
expr_stmt|;
name|heightDiff
operator|=
operator|(
name|fontptr
operator|->
name|ascent
operator|+
name|fontptr
operator|->
name|descent
operator|)
operator|-
name|lineptr
operator|->
name|lineHeight
expr_stmt|;
if|if
condition|(
name|heightDiff
operator|<
literal|0
condition|)
name|heightDiff
operator|=
literal|0
expr_stmt|;
name|lineptr
operator|->
name|lineHeight
operator|+=
name|heightDiff
expr_stmt|;
block|}
block|}
if|if
condition|(
name|theChar
operator|==
literal|'\n'
condition|)
block|{
comment|/* Handle new line */
if|if
condition|(
name|linenum
operator|>=
name|textInfo
operator|->
name|allocLines
operator|-
literal|1
condition|)
comment|/* Expand number of lines */
name|ExpandLines
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
name|linenum
operator|++
expr_stmt|;
name|lineptr
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|linenum
index|]
expr_stmt|;
comment|/* Initialize next line */
name|lineptr
operator|->
name|lineHeight
operator|=
name|fontptr
operator|->
name|ascent
operator|+
name|fontptr
operator|->
name|descent
expr_stmt|;
name|lineptr
operator|->
name|lineText
operator|=
name|index
operator|+
literal|1
expr_stmt|;
comment|/* Check to see if its the starting line */
if|if
condition|(
name|index
operator|==
name|startPos
condition|)
name|textInfo
operator|->
name|startLine
operator|=
name|linenum
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle normal character */
name|chsize
operator|=
name|CharSize
argument_list|(
name|textInfo
argument_list|,
name|linenum
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineptr
operator|->
name|lineWidth
operator|+
name|chsize
operator|>
name|endSize
condition|)
block|{
comment|/* Handle line wrap */
name|lineptr
operator|->
name|lineFlags
operator||=
name|WRAPFLAG
expr_stmt|;
if|if
condition|(
name|linenum
operator|>=
name|textInfo
operator|->
name|allocLines
operator|-
literal|1
condition|)
comment|/* Expand number of lines */
name|ExpandLines
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
name|linenum
operator|++
expr_stmt|;
name|lineptr
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|linenum
index|]
expr_stmt|;
comment|/* Initialize next line */
name|lineptr
operator|->
name|lineHeight
operator|=
name|fontptr
operator|->
name|ascent
operator|+
name|fontptr
operator|->
name|descent
expr_stmt|;
name|lineptr
operator|->
name|lineText
operator|=
name|index
expr_stmt|;
name|lineptr
operator|->
name|lineLength
operator|=
literal|1
expr_stmt|;
name|lineptr
operator|->
name|lineWidth
operator|+=
name|chsize
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle normal addition of character */
name|lineptr
operator|->
name|lineLength
operator|+=
literal|1
expr_stmt|;
name|lineptr
operator|->
name|lineWidth
operator|+=
name|chsize
expr_stmt|;
block|}
block|}
block|}
comment|/* We now have a valid line array.  Let's clean up some other fields. */
name|textInfo
operator|->
name|numLines
operator|=
name|linenum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|startPos
operator|==
literal|0
condition|)
block|{
name|textInfo
operator|->
name|startLine
operator|=
literal|0
expr_stmt|;
block|}
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|curLine
operator|=
name|linenum
expr_stmt|;
comment|/* Check to see if we are at the bottom */
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|>=
name|textInfo
operator|->
name|numLines
operator|-
literal|1
condition|)
block|{
name|textInfo
operator|->
name|curY
operator|=
name|textInfo
operator|->
name|h
operator|-
name|textInfo
operator|->
name|bottomSpace
operator|-
name|lineptr
operator|->
name|lineHeight
expr_stmt|;
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|NOTATBOTTOM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|textInfo
operator|->
name|flagWord
operator||=
name|NOTATBOTTOM
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtAddFont
parameter_list|(
name|display
parameter_list|,
name|textWin
parameter_list|,
name|fontNumber
parameter_list|,
name|newFont
parameter_list|,
name|newColor
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|textWin
decl_stmt|;
comment|/* Scrollable text window  */
name|int
name|fontNumber
decl_stmt|;
comment|/* Place to add font (0-7) */
name|XFontStruct
modifier|*
name|newFont
decl_stmt|;
comment|/* Font to add             */
name|int
name|newColor
decl_stmt|;
comment|/* Color of font           */
comment|/*  * This routine loads a new font so that it can be used in a previously  * created text window.  There are eight font slots numbered 0 through 7.  * If there is already a font in the specified slot,  it will be replaced  * and an automatic redraw of the window will take place.  See TxtWriteStr  * for details on using alternate fonts.  The color specifies the foreground  * color of the text.  The default foreground color is used if this  * parameter is TXT_NO_COLOR.  Returns a non-zero value if  * everything went well.  */
block|{
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|int
name|redrawFlag
decl_stmt|;
name|XGCValues
name|gc_val
decl_stmt|;
if|if
condition|(
operator|(
name|fontNumber
operator|<
literal|0
operator|)
operator|||
operator|(
name|fontNumber
operator|>=
name|MAXFONTS
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|textWin
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|newColor
operator|==
name|TXT_NO_COLOR
condition|)
block|{
name|newColor
operator|=
name|textInfo
operator|->
name|fgPix
expr_stmt|;
block|}
name|gc_val
operator|.
name|font
operator|=
name|newFont
operator|->
name|fid
expr_stmt|;
name|gc_val
operator|.
name|foreground
operator|=
name|newColor
expr_stmt|;
name|gc_val
operator|.
name|background
operator|=
name|textInfo
operator|->
name|bgPix
expr_stmt|;
name|gc_val
operator|.
name|plane_mask
operator|=
name|AllPlanes
expr_stmt|;
name|gc_val
operator|.
name|graphics_exposures
operator|=
literal|1
expr_stmt|;
name|gc_val
operator|.
name|function
operator|=
name|GXcopy
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|fontGC
index|[
name|fontNumber
index|]
operator|!=
literal|0
condition|)
block|{
name|XChangeGC
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|fontGC
index|[
name|fontNumber
index|]
argument_list|,
name|GCFont
operator||
name|GCForeground
argument_list|,
operator|&
name|gc_val
argument_list|)
expr_stmt|;
block|}
else|else
name|textInfo
operator|->
name|fontGC
index|[
name|fontNumber
index|]
operator|=
name|XCreateGC
argument_list|(
name|display
argument_list|,
name|textWin
argument_list|,
name|GCFont
operator||
name|GCForeground
operator||
name|GCBackground
operator||
name|GCFunction
operator||
name|GCPlaneMask
operator||
name|GCGraphicsExposures
argument_list|,
operator|&
name|gc_val
argument_list|)
expr_stmt|;
name|redrawFlag
operator|=
operator|(
name|textInfo
operator|->
name|theFonts
index|[
name|fontNumber
index|]
operator|.
name|fid
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|newFont
operator|)
operator|&&
operator|(
name|newFont
operator|->
name|fid
operator|!=
name|textInfo
operator|->
name|theFonts
index|[
name|fontNumber
index|]
operator|.
name|fid
operator|)
operator|)
operator|||
operator|(
name|newColor
operator|!=
name|textInfo
operator|->
name|theColors
index|[
name|fontNumber
index|]
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|newFont
condition|)
block|{
name|textInfo
operator|->
name|theFonts
index|[
name|fontNumber
index|]
operator|=
operator|*
name|newFont
expr_stmt|;
block|}
name|textInfo
operator|->
name|theColors
index|[
name|fontNumber
index|]
operator|=
name|newColor
expr_stmt|;
if|if
condition|(
name|redrawFlag
condition|)
block|{
name|RecompBuffer
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|textWin
argument_list|)
expr_stmt|;
name|TxtRepaint
argument_list|(
name|display
argument_list|,
name|textWin
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtWinP
parameter_list|(
name|display
parameter_list|,
name|w
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|w
decl_stmt|;
comment|/*  * Returns a non-zero value if the window has been previously grabbed  * using TxtGrab and 0 if it has not.  */
block|{
if|if
condition|(
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|FindEndLine
parameter_list|(
name|textInfo
parameter_list|,
name|botSpace
parameter_list|)
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|int
modifier|*
name|botSpace
decl_stmt|;
comment|/*  * Given the starting line in 'textInfo->startLine',  this routine  * determines the index of the last line that can be drawn given the  * current size of the screen.  If there are not enough lines to  * fill the screen,  the index of the last line will be returned.  * The amount of empty bottom space is returned in 'botSpace'.  */
block|{
name|int
name|index
decl_stmt|,
name|height
decl_stmt|,
name|lineHeight
decl_stmt|;
name|height
operator|=
name|YPADDING
expr_stmt|;
name|index
operator|=
name|textInfo
operator|->
name|startLine
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|textInfo
operator|->
name|numLines
condition|)
block|{
name|lineHeight
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
expr_stmt|;
if|if
condition|(
name|height
operator|+
name|lineHeight
operator|>
name|textInfo
operator|->
name|h
condition|)
break|break;
name|height
operator|+=
name|lineHeight
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|botSpace
condition|)
block|{
operator|*
name|botSpace
operator|=
name|textInfo
operator|->
name|h
operator|-
name|height
expr_stmt|;
block|}
return|return
name|index
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|UpdateScroll
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information */
comment|/*  * This routine computes the current extent of the scroll bar  * indicator and repaints the bar with the correct information.  */
block|{
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|numLines
operator|>
literal|1
condition|)
block|{
name|top
operator|=
name|textInfo
operator|->
name|startLine
operator|*
operator|(
name|textInfo
operator|->
name|h
operator|-
literal|2
operator|*
name|BARBORDER
operator|)
operator|/
operator|(
name|textInfo
operator|->
name|numLines
operator|-
literal|1
operator|)
expr_stmt|;
name|bottom
operator|=
name|textInfo
operator|->
name|endLine
operator|*
operator|(
name|textInfo
operator|->
name|h
operator|-
literal|2
operator|*
name|BARBORDER
operator|)
operator|/
operator|(
name|textInfo
operator|->
name|numLines
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
name|textInfo
operator|->
name|h
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
expr_stmt|;
block|}
comment|/* Draw it - make sure there is a little padding */
if|if
condition|(
name|top
operator|==
literal|0
condition|)
name|top
operator|++
expr_stmt|;
if|if
condition|(
name|bottom
operator|==
name|textInfo
operator|->
name|h
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
condition|)
name|bottom
operator|--
expr_stmt|;
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|scrollBar
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BARSIZE
argument_list|,
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__386BSD__
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|scrollBar
argument_list|,
name|DEFAULT_GC
argument_list|,
name|top
argument_list|,
name|BARSIZE
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
operator|-
literal|2
argument_list|,
name|BARSIZE
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
else|#
directive|else
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|scrollBar
argument_list|,
name|DEFAULT_GC
argument_list|,
name|top
argument_list|,
name|BARSIZE
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
operator|-
literal|2
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|scrollBar
argument_list|,
name|DEFAULT_GC
argument_list|,
literal|0
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|BARSIZE
argument_list|,
name|textInfo
operator|->
name|h
operator|-
operator|(
literal|2
operator|*
name|BARBORDER
operator|)
operator|-
name|bottom
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtClear
parameter_list|(
name|display
parameter_list|,
name|w
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|w
decl_stmt|;
comment|/*  * This routine clears a scrollable text window.  It resets the current  * writing position to the upper left hand corner of the screen.   * NOTE:  THIS ALSO CLEARS THE CONTENTS OF THE TEXT WINDOW BUFFER AND  * RESETS THE SCROLL BAR.  Returns 0 if the window is not a text window.  * This should be used *instead* of XClear.  */
block|{
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Zero out the arrays */
name|textInfo
operator|->
name|bufSpot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|textInfo
operator|->
name|numLines
condition|;
name|index
operator|++
control|)
block|{
name|InitLine
argument_list|(
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|textInfo
operator|->
name|txtBuffer
index|[
literal|0
index|]
operator|->
name|lineHeight
operator|=
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|ascent
operator|+
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|descent
expr_stmt|;
name|textInfo
operator|->
name|numLines
operator|=
literal|1
expr_stmt|;
name|textInfo
operator|->
name|startLine
operator|=
literal|0
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
literal|0
expr_stmt|;
name|textInfo
operator|->
name|curLine
operator|=
literal|0
expr_stmt|;
name|textInfo
operator|->
name|curX
operator|=
literal|0
expr_stmt|;
name|textInfo
operator|->
name|curY
operator|=
name|YPADDING
operator|+
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|ascent
operator|+
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|descent
expr_stmt|;
name|textInfo
operator|->
name|bottomSpace
operator|=
name|textInfo
operator|->
name|h
operator|-
name|YPADDING
operator|-
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|ascent
operator|-
name|INTERLINE
operator|-
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|descent
expr_stmt|;
comment|/* Actually clear the window */
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|w
argument_list|)
expr_stmt|;
comment|/* Draw the current cursor */
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|w
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
name|XPADDING
operator|+
name|CUROFFSET
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|,
name|CURSORWIDTH
argument_list|,
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|ascent
operator|+
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|descent
argument_list|)
expr_stmt|;
comment|/* Update the scroll bar */
name|UpdateScroll
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|WarpToBottom
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text Information */
comment|/*  * This routine causes the specified text window to display its  * last screen of information.   It updates the scroll bar  * to the appropriate spot.  The implementation scans backward  * through the buffer to find an appropriate starting spot for  * the window.  */
block|{
name|int
name|index
decl_stmt|,
name|height
decl_stmt|,
name|lineHeight
decl_stmt|;
name|index
operator|=
name|textInfo
operator|->
name|numLines
operator|-
literal|1
expr_stmt|;
name|height
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|lineHeight
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
expr_stmt|;
if|if
condition|(
name|height
operator|+
name|lineHeight
operator|>
name|textInfo
operator|->
name|h
condition|)
break|break;
name|height
operator|+=
name|lineHeight
expr_stmt|;
name|index
operator|--
expr_stmt|;
block|}
name|textInfo
operator|->
name|startLine
operator|=
name|index
operator|+
literal|1
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|curY
operator|=
name|textInfo
operator|->
name|h
operator|-
name|textInfo
operator|->
name|bottomSpace
operator|-
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|endLine
index|]
operator|->
name|lineHeight
expr_stmt|;
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
name|TxtRepaint
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|UpdateExposures
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information */
comment|/*  * Before a new scrolling action occurs,  the text window package  * must handle all COPYEXPOSE events generated by the last scrolling  * action.  This routine is called to do this.  Foreign events (those  * not handled by TxtFilter) are queued up and replaced on the queue  * after the processing of the exposure events is complete.  */
block|{
if|#
directive|if
literal|0
block|XEvent foreignQueue[MAXFOREIGN];     int index, lastItem = 0;      while (textInfo->flagWord& COPYEXPOSE) { 	XNextEvent(display,&(foreignQueue[lastItem])); 	if (!TxtFilter(display,&(foreignQueue[lastItem]))) 	  lastItem++; 	if (lastItem>= MAXFOREIGN) { 	    printf("Too many foreign events to queue!\n"); 	    textInfo->flagWord&= (~COPYEXPOSE); 	}     }     for (index = 0;  index< lastItem;  index++) { 	XPutBackEvent(display,&(foreignQueue[index]));     }
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|ScrollDown
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information */
comment|/*  * This routine scrolls the indicated text window down by one  * line.  The line below the current line must exist.  The window  * is scrolled so that the line below the last line is fully  * displayed.  This may cause many lines to scroll off the top.  * Scrolling is done using XCopyArea.  The exposure events should  * be caught using ExposeCopy.  */
block|{
name|int
name|lineSum
decl_stmt|,
name|index
decl_stmt|,
name|targetSpace
decl_stmt|,
name|freeSpace
decl_stmt|,
name|updateFlag
decl_stmt|;
name|lineSum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|+
literal|1
operator|>=
name|textInfo
operator|->
name|numLines
condition|)
return|return
literal|0
return|;
name|targetSpace
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|endLine
operator|+
literal|1
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|bottomSpace
operator|<
name|targetSpace
condition|)
block|{
name|index
operator|=
name|textInfo
operator|->
name|startLine
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|textInfo
operator|->
name|endLine
condition|)
block|{
name|lineSum
operator|+=
operator|(
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|)
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|bottomSpace
operator|+
name|lineSum
operator|>=
name|targetSpace
condition|)
break|break;
name|index
operator|++
expr_stmt|;
block|}
comment|/* Must move upward by 'lineSum' pixels */
name|XCopyArea
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|DEFAULT_GC
argument_list|,
literal|0
argument_list|,
name|lineSum
argument_list|,
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
argument_list|,
name|textInfo
operator|->
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|flagWord
operator||=
name|COPYEXPOSE
expr_stmt|;
comment|/* Repair the damage to the structures */
name|textInfo
operator|->
name|startLine
operator|=
name|index
operator|+
literal|1
expr_stmt|;
name|updateFlag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|updateFlag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* More lines might be able to fit.  Let's check. */
name|freeSpace
operator|=
name|textInfo
operator|->
name|bottomSpace
operator|+
name|lineSum
operator|-
name|targetSpace
expr_stmt|;
name|index
operator|=
name|textInfo
operator|->
name|endLine
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|textInfo
operator|->
name|numLines
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|freeSpace
operator|-
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
operator|+
literal|1
index|]
operator|->
name|lineHeight
operator|-
name|INTERLINE
operator|<
literal|0
condition|)
break|break;
name|freeSpace
operator|-=
operator|(
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
operator|+
literal|1
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|textInfo
operator|->
name|endLine
operator|=
name|index
expr_stmt|;
name|textInfo
operator|->
name|bottomSpace
operator|=
name|freeSpace
expr_stmt|;
if|if
condition|(
name|updateFlag
condition|)
block|{
name|UpdateExposures
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
block|}
name|UpdateScroll
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|ExpandLines
parameter_list|(
name|textInfo
parameter_list|)
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text Information */
comment|/*  * This routine allocates and initializes additional space in  * the line start array (txtBuffer).  The new space  * is allocated using realloc.  The expansion factor is a percentage  * given by EXPANDPERCENT.  */
block|{
name|int
name|newSize
decl_stmt|,
name|index
decl_stmt|;
name|newSize
operator|=
name|textInfo
operator|->
name|allocLines
expr_stmt|;
name|newSize
operator|+=
operator|(
name|newSize
operator|*
name|EXPANDPERCENT
operator|)
operator|/
literal|100
expr_stmt|;
name|textInfo
operator|->
name|txtBuffer
operator|=
operator|(
expr|struct
name|txtLine
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|textInfo
operator|->
name|txtBuffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|newSize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|txtLine
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|textInfo
operator|->
name|allocLines
init|;
name|index
operator|<
name|newSize
condition|;
name|index
operator|++
control|)
block|{
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|=
name|alloc
argument_list|(
expr|struct
name|txtLine
argument_list|)
expr_stmt|;
name|InitLine
argument_list|(
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|textInfo
operator|->
name|allocLines
operator|=
name|newSize
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExpandBuffer
parameter_list|(
name|textInfo
parameter_list|)
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text information */
comment|/*  * Expands the basic character buffer using realloc.  The expansion  * factor is a percentage given by EXPANDPERCENT.  */
block|{
name|int
name|newSize
decl_stmt|;
name|newSize
operator|=
name|textInfo
operator|->
name|bufAlloc
operator|+
operator|(
name|textInfo
operator|->
name|bufAlloc
operator|*
name|EXPANDPERCENT
operator|)
operator|/
literal|100
expr_stmt|;
name|textInfo
operator|->
name|mainBuffer
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|textInfo
operator|->
name|mainBuffer
argument_list|,
operator|(
name|unsigned
operator|)
name|newSize
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|bufAlloc
operator|=
name|newSize
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|HandleNewLine
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|,
name|flagWord
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text Information            */
name|int
name|flagWord
decl_stmt|;
comment|/* DODISP or NONEWLINE or both */
comment|/*  * This routine initializes the next line for drawing by setting  * its height to the current font height,  scrolls the screen down  * one line,  and updates the current drawing position to the  * left edge of the newly cleared line.  If DODISP is specified,  * the screen will be updated (otherwise not).  If NONEWLINE is  * specified,  no newline character will be added to the text buffer  * (this is for line wrap).  */
block|{
name|struct
name|txtLine
modifier|*
name|curLine
decl_stmt|,
modifier|*
name|nextLine
decl_stmt|;
comment|/* Check to see if a new line must be allocated */
if|if
condition|(
name|textInfo
operator|->
name|curLine
operator|>=
name|textInfo
operator|->
name|allocLines
operator|-
literal|1
condition|)
comment|/* Expand the number of lines */
name|ExpandLines
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|numLines
operator|+=
literal|1
expr_stmt|;
comment|/* Then we initialize the next line */
name|nextLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|numLines
operator|-
literal|1
index|]
expr_stmt|;
name|nextLine
operator|->
name|lineHeight
operator|=
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|ascent
operator|+
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|.
name|descent
expr_stmt|;
name|curLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
if|if
condition|(
name|flagWord
operator|&
name|DODISP
condition|)
block|{
comment|/* Scroll down a line if required */
if|if
condition|(
operator|(
name|textInfo
operator|->
name|curY
operator|+
name|curLine
operator|->
name|lineHeight
operator|+
name|nextLine
operator|->
name|lineHeight
operator|+
operator|(
name|INTERLINE
operator|*
literal|2
operator|)
operator|)
operator|>
name|textInfo
operator|->
name|h
condition|)
block|{
name|ScrollDown
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update the bottom space appropriately */
name|textInfo
operator|->
name|bottomSpace
operator|-=
operator|(
name|nextLine
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|)
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Update drawing position */
name|textInfo
operator|->
name|curY
operator|=
name|textInfo
operator|->
name|h
operator|-
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|+
name|nextLine
operator|->
name|lineHeight
operator|)
expr_stmt|;
block|}
comment|/* Move down a line */
name|textInfo
operator|->
name|curLine
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flagWord
operator|&
name|NONEWLINE
operator|)
condition|)
block|{
comment|/* Append end-of-line to text buffer */
if|if
condition|(
name|textInfo
operator|->
name|bufSpot
operator|>=
name|textInfo
operator|->
name|bufAlloc
condition|)
block|{
comment|/* Allocate more space in main text buffer */
name|ExpandBuffer
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
block|}
name|textInfo
operator|->
name|mainBuffer
index|[
operator|(
name|textInfo
operator|->
name|bufSpot
operator|)
operator|++
index|]
operator|=
operator|(
name|textInfo
operator|->
name|curFont
operator|<<
name|FONTSHIFT
operator|)
operator||
literal|'\n'
expr_stmt|;
block|}
name|nextLine
operator|->
name|lineText
operator|=
name|textInfo
operator|->
name|bufSpot
expr_stmt|;
name|textInfo
operator|->
name|curX
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|CharSize
parameter_list|(
name|textInfo
parameter_list|,
name|lineNum
parameter_list|,
name|charNum
parameter_list|)
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Current Text Information */
name|int
name|lineNum
decl_stmt|;
comment|/* Line in buffer           */
name|int
name|charNum
decl_stmt|;
comment|/* Character in line        */
comment|/*  * This routine determines the size of the specified character.  * It takes in account the font of the character and whether its  * fixed or variable.  The size includes INTERSPACE spacing between  * the characters.  */
block|{
specifier|register
name|XFontStruct
modifier|*
name|charFont
decl_stmt|;
specifier|register
name|short
modifier|*
name|theLine
decl_stmt|;
specifier|register
name|short
name|theChar
decl_stmt|;
name|theLine
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|mainBuffer
index|[
name|textInfo
operator|->
name|txtBuffer
index|[
name|lineNum
index|]
operator|->
name|lineText
index|]
operator|)
expr_stmt|;
name|theChar
operator|=
name|theLine
index|[
name|charNum
index|]
operator|&
name|CHARMASK
expr_stmt|;
name|charFont
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|theFonts
index|[
operator|(
name|theChar
operator|&
name|FONTMASK
operator|)
operator|>>
name|FONTSHIFT
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|theChar
operator|<=
name|charFont
operator|->
name|min_char_or_byte2
operator|||
name|theChar
operator|>=
name|charFont
operator|->
name|max_char_or_byte2
operator|||
name|charFont
operator|->
name|per_char
operator|==
literal|0
condition|)
return|return
name|charFont
operator|->
name|max_bounds
operator|.
name|width
operator|+
literal|1
return|;
else|else
return|return
name|charFont
operator|->
name|per_char
index|[
name|theChar
index|]
operator|.
name|width
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|HandleBackspace
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|,
name|flagWord
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text Information  */
name|int
name|flagWord
decl_stmt|;
comment|/* DODISP or nothing */
comment|/*  * This routine handles a backspace found in the input stream.  The  * character before the current writing position will be erased and  * the drawing position will move back one character.  If the writing  * position is at the left margin,  the drawing position will move  * up to the previous line.  If it is a line that has been wrapped,  * the character at the end of the previous line will be erased.  */
block|{
name|struct
name|txtLine
modifier|*
name|thisLine
decl_stmt|,
modifier|*
name|prevLine
decl_stmt|;
name|int
name|chSize
decl_stmt|;
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
comment|/* First,  determine whether we need to go back a line */
if|if
condition|(
name|thisLine
operator|->
name|lineLength
operator|==
literal|0
condition|)
block|{
comment|/* Bleep if at top of buffer */
if|if
condition|(
name|textInfo
operator|->
name|curLine
operator|==
literal|0
condition|)
block|{
name|XBell
argument_list|(
name|display
argument_list|,
literal|50
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See if we have to scroll in the other direction */
if|if
condition|(
operator|(
name|flagWord
operator|&
name|DODISP
operator|)
operator|&&
operator|(
name|textInfo
operator|->
name|curY
operator|<=
name|YPADDING
operator|)
condition|)
block|{
comment|/* This will display the last lines of the buffer */
name|WarpToBottom
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
block|}
comment|/* Set drawing position at end of previous line */
name|textInfo
operator|->
name|curLine
operator|-=
literal|1
expr_stmt|;
name|prevLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
name|textInfo
operator|->
name|numLines
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|flagWord
operator|&
name|DODISP
condition|)
block|{
name|textInfo
operator|->
name|curY
operator|-=
operator|(
name|prevLine
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|)
expr_stmt|;
name|textInfo
operator|->
name|bottomSpace
operator|+=
operator|(
name|thisLine
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|)
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* We are unlinewrapping if the previous line has flag set */
if|if
condition|(
name|prevLine
operator|->
name|lineFlags
operator|&
name|WRAPFLAG
condition|)
block|{
comment|/* Get rid of line wrap indicator */
if|if
condition|(
name|flagWord
operator|&
name|DODISP
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
operator|-
name|WRAPINDSIZE
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|,
name|WRAPINDSIZE
argument_list|,
name|prevLine
operator|->
name|lineHeight
argument_list|)
expr_stmt|;
block|}
name|prevLine
operator|->
name|lineFlags
operator|&=
operator|(
operator|~
name|WRAPFLAG
operator|)
expr_stmt|;
comment|/* Call recursively to wipe out the ending character */
name|HandleBackspace
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|flagWord
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Delete the end-of-line in the primary buffer */
name|textInfo
operator|->
name|bufSpot
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Normal deletion of character */
name|chSize
operator|=
name|CharSize
argument_list|(
name|textInfo
argument_list|,
name|textInfo
operator|->
name|curLine
argument_list|,
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
operator|->
name|lineLength
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Move back appropriate amount and wipe it out */
name|thisLine
operator|->
name|lineWidth
operator|-=
name|chSize
expr_stmt|;
if|if
condition|(
name|flagWord
operator|&
name|DODISP
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
name|thisLine
operator|->
name|lineWidth
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|,
name|chSize
argument_list|,
name|thisLine
operator|->
name|lineHeight
argument_list|)
expr_stmt|;
block|}
comment|/* Delete from buffer */
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
operator|->
name|lineLength
operator|-=
literal|1
expr_stmt|;
name|textInfo
operator|->
name|bufSpot
operator|-=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|DrawLineWrap
parameter_list|(
name|display
parameter_list|,
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|h
parameter_list|,
name|col
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|win
decl_stmt|;
comment|/* What window to draw it in     */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Position of upper left corner */
name|int
name|h
decl_stmt|;
comment|/* Height of indicator           */
name|int
name|col
decl_stmt|;
comment|/* Color of indicator            */
comment|/*  * This routine draws a line wrap indicator at the end of a line.  * Visually,  it is an arrow of the specified height directly against  * the scroll bar border.  The bitmap used for the arrow is stored  * in 'arrowMap' with size 'arrow_width' and 'arrow_height'.  */
block|{
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|win
argument_list|)
expr_stmt|;
comment|/* First,  draw the arrow */
ifdef|#
directive|ifdef
name|__386BSD__
name|XCopyArea
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|arrowMap
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|arrow_width
argument_list|,
name|arrow_height
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
name|arrow_height
argument_list|)
expr_stmt|;
else|#
directive|else
name|XCopyArea
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|arrowMap
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|arrow_width
argument_list|,
name|arrow_height
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
name|arrow_height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Then draw the stem */
name|XDrawLine
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
name|x
operator|+
name|STEMOFFSET
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|STEMOFFSET
argument_list|,
name|y
operator|+
name|h
operator|-
name|arrow_height
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|DrawLine
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|,
name|lineIndex
parameter_list|,
name|ypos
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information   */
name|int
name|lineIndex
decl_stmt|;
comment|/* Index of line to draw     */
name|int
name|ypos
decl_stmt|;
comment|/* Y position for line       */
comment|/*  * This routine destructively draws the indicated line in the  * indicated window at the indicated position.  It does not  * clear to end of line however.  It draws a line wrap indicator  * if needed but does not draw a cursor.  */
block|{
name|int
name|index
decl_stmt|,
name|startPos
decl_stmt|,
name|curFont
decl_stmt|,
name|theColor
decl_stmt|,
name|curX
decl_stmt|,
name|saveX
decl_stmt|,
name|fontIndex
decl_stmt|;
name|struct
name|txtLine
modifier|*
name|someLine
decl_stmt|;
name|char
name|lineBuffer
index|[
name|BUFSIZE
index|]
decl_stmt|,
modifier|*
name|glyph
decl_stmt|;
name|short
modifier|*
name|linePointer
decl_stmt|;
name|XFontStruct
modifier|*
name|theFont
decl_stmt|;
name|XGCValues
name|gc
decl_stmt|;
comment|/* First,  we draw the text */
name|index
operator|=
literal|0
expr_stmt|;
name|curX
operator|=
name|XPADDING
expr_stmt|;
name|someLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|lineIndex
index|]
expr_stmt|;
name|linePointer
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|mainBuffer
index|[
name|someLine
operator|->
name|lineText
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|someLine
operator|->
name|lineLength
condition|)
block|{
name|startPos
operator|=
name|index
expr_stmt|;
name|saveX
operator|=
name|curX
expr_stmt|;
name|curFont
operator|=
name|linePointer
index|[
name|index
index|]
operator|&
name|FONTMASK
expr_stmt|;
name|fontIndex
operator|=
name|curFont
operator|>>
name|FONTSHIFT
expr_stmt|;
name|theFont
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|theFonts
index|[
name|fontIndex
index|]
operator|)
expr_stmt|;
name|theColor
operator|=
name|textInfo
operator|->
name|theColors
index|[
name|fontIndex
index|]
expr_stmt|;
name|glyph
operator|=
operator|&
operator|(
name|lineBuffer
index|[
literal|0
index|]
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|index
operator|<
name|someLine
operator|->
name|lineLength
operator|)
operator|&&
operator|(
operator|(
name|linePointer
index|[
name|index
index|]
operator|&
name|FONTMASK
operator|)
operator|==
name|curFont
operator|)
condition|)
block|{
operator|*
name|glyph
operator|=
name|linePointer
index|[
name|index
index|]
operator|&
name|CHARMASK
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|curX
operator|+=
name|CharSize
argument_list|(
name|textInfo
argument_list|,
name|lineIndex
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|glyph
operator|++
expr_stmt|;
block|}
comment|/* Flush out the glyphs */
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
name|saveX
argument_list|,
name|ypos
argument_list|,
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
argument_list|,
name|someLine
operator|->
name|lineHeight
operator|+
name|YPADDING
operator|+
name|INTERLINE
argument_list|)
expr_stmt|;
name|XDrawString
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|fontGC
index|[
name|fontIndex
index|]
argument_list|,
name|saveX
argument_list|,
name|ypos
argument_list|,
name|lineBuffer
argument_list|,
name|someLine
operator|->
name|lineLength
argument_list|)
expr_stmt|;
block|}
comment|/* Then the line wrap indicator (if needed) */
if|if
condition|(
name|someLine
operator|->
name|lineFlags
operator|&
name|WRAPFLAG
condition|)
block|{
name|DrawLineWrap
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
operator|-
name|WRAPINDSIZE
argument_list|,
name|ypos
argument_list|,
name|someLine
operator|->
name|lineHeight
argument_list|,
name|textInfo
operator|->
name|fgPix
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|HandleNewFont
parameter_list|(
name|display
parameter_list|,
name|fontNum
parameter_list|,
name|textInfo
parameter_list|,
name|flagWord
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|int
name|fontNum
decl_stmt|;
comment|/* Font number       */
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text information  */
name|int
name|flagWord
decl_stmt|;
comment|/* DODISP or nothing */
comment|/*  * This routine handles a new font request.  These requests take  * the form "^F<digit>".  The parsing is done in TxtWriteStr.  * This routine is called only if the form is valid.  It may return  * a failure (0 status) if the requested font is not loaded.  * If the new font is larger than any of the current  * fonts on the line,  it will change the line height and redisplay  * the line.  */
block|{
name|struct
name|txtLine
modifier|*
name|thisLine
decl_stmt|;
name|int
name|heightDiff
decl_stmt|,
name|baseDiff
decl_stmt|,
name|redrawFlag
decl_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|theFonts
index|[
name|fontNum
index|]
operator|.
name|fid
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
name|textInfo
operator|->
name|curFont
operator|=
name|fontNum
expr_stmt|;
name|redrawFlag
operator|=
literal|0
expr_stmt|;
name|heightDiff
operator|=
name|textInfo
operator|->
name|theFonts
index|[
name|fontNum
index|]
operator|.
name|ascent
operator|+
name|textInfo
operator|->
name|theFonts
index|[
name|fontNum
index|]
operator|.
name|descent
operator|-
name|thisLine
operator|->
name|lineHeight
expr_stmt|;
if|if
condition|(
name|heightDiff
operator|>
literal|0
condition|)
block|{
name|redrawFlag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|heightDiff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|redrawFlag
condition|)
block|{
if|if
condition|(
name|flagWord
operator|&
name|DODISP
condition|)
block|{
comment|/* Clear current line */
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
literal|0
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|,
name|textInfo
operator|->
name|w
argument_list|,
name|thisLine
operator|->
name|lineHeight
argument_list|)
expr_stmt|;
comment|/* Check to see if it requires scrolling */
if|if
condition|(
operator|(
name|textInfo
operator|->
name|curY
operator|+
name|thisLine
operator|->
name|lineHeight
operator|+
name|heightDiff
operator|+
name|INTERLINE
operator|)
operator|>
name|textInfo
operator|->
name|h
condition|)
block|{
comment|/*  		       * General approach:  "unscroll" the last line up 		       * and then call ScrollDown to do the right thing. 		       */
name|textInfo
operator|->
name|endLine
operator|-=
literal|1
expr_stmt|;
name|textInfo
operator|->
name|bottomSpace
operator|+=
name|thisLine
operator|->
name|lineHeight
operator|+
name|INTERLINE
expr_stmt|;
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
literal|0
argument_list|,
name|textInfo
operator|->
name|h
operator|-
name|textInfo
operator|->
name|bottomSpace
argument_list|,
name|textInfo
operator|->
name|w
argument_list|,
name|textInfo
operator|->
name|bottomSpace
argument_list|)
expr_stmt|;
name|thisLine
operator|->
name|lineHeight
operator|+=
name|heightDiff
expr_stmt|;
name|ScrollDown
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|curY
operator|=
name|textInfo
operator|->
name|h
operator|-
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|+
name|INTERLINE
operator|+
name|thisLine
operator|->
name|lineHeight
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just update bottom space */
name|textInfo
operator|->
name|bottomSpace
operator|-=
name|heightDiff
expr_stmt|;
name|thisLine
operator|->
name|lineHeight
operator|+=
name|heightDiff
expr_stmt|;
block|}
comment|/* Redraw the current line */
name|DrawLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|textInfo
operator|->
name|curLine
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just update line height */
name|thisLine
operator|->
name|lineHeight
operator|+=
name|heightDiff
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtWriteStr
parameter_list|(
name|display
parameter_list|,
name|w
parameter_list|,
name|str
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|w
decl_stmt|;
comment|/* Text window            */
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* 0 terminated string */
comment|/*  * This routine writes a string to the specified text window.  * The following notes apply:  *   - Text is always appended to the end of the text buffer.  *   - If the scroll bar is positioned such that the end of the  *     text is not visible,  an automatic scroll to the bottom  *     will be done before the appending of text.  *   - Non-printable ASCII characters are not displayed.  *   - The '\n' character causes the current text position to  *     advance one line and start at the left.  *   - Tabs are not supported.  *   - Lines too long for the screen will be wrapped and a line wrap  *     indication will be drawn.  *   - Backspace clears the previous character.  It will do the right  *     thing if asked to backspace past a wrapped line.  *   - A new font can be chosen using the sequence '^F<digit>' where  *<digit> is 0-7.  The directive will be ignored if  *     there is no font in the specified slot.  * Returns 0 if something went wrong.    */
block|{
specifier|register
name|int
name|fontIndex
decl_stmt|;
specifier|register
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
specifier|register
name|struct
name|txtLine
modifier|*
name|thisLine
decl_stmt|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* See if screen needs to be updated */
if|if
condition|(
name|textInfo
operator|->
name|flagWord
operator|&
name|SCREENWRONG
condition|)
block|{
name|TxtRepaint
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
block|}
comment|/* See if we have to scroll down to the bottom */
if|if
condition|(
name|textInfo
operator|->
name|flagWord
operator|&
name|NOTATBOTTOM
condition|)
block|{
name|WarpToBottom
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|NOTATBOTTOM
operator|)
expr_stmt|;
block|}
comment|/* Undraw the current cursor */
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|w
argument_list|,
name|textInfo
operator|->
name|bgGC
argument_list|,
name|thisLine
operator|->
name|lineWidth
operator|+
name|CUROFFSET
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|,
name|CURSORWIDTH
argument_list|,
name|thisLine
operator|->
name|lineHeight
argument_list|)
expr_stmt|;
for|for
control|(
comment|/* str is ok */
init|;
operator|(
operator|*
name|str
operator|!=
literal|0
operator|)
condition|;
name|str
operator|++
control|)
block|{
comment|/* Check to see if we are waiting on a font */
if|if
condition|(
name|textInfo
operator|->
name|flagWord
operator|&
name|FONTNUMWAIT
condition|)
block|{
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|FONTNUMWAIT
operator|)
expr_stmt|;
name|fontIndex
operator|=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|fontIndex
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|fontIndex
operator|<
name|MAXFONTS
operator|)
condition|)
block|{
comment|/* Handle font -- go get next character */
if|if
condition|(
name|HandleNewFont
argument_list|(
name|display
argument_list|,
name|fontIndex
argument_list|,
name|textInfo
argument_list|,
name|DODISP
argument_list|)
condition|)
continue|continue;
block|}
block|}
comment|/* Inline code for handling normal character case */
if|if
condition|(
operator|(
operator|*
name|str
operator|>=
name|LOWCHAR
operator|)
operator|&&
operator|(
operator|*
name|str
operator|<=
name|HIGHCHAR
operator|)
condition|)
block|{
specifier|register
name|XFontStruct
modifier|*
name|thisFont
decl_stmt|;
specifier|register
name|struct
name|txtLine
modifier|*
name|thisLine
decl_stmt|;
specifier|register
name|int
name|charWidth
decl_stmt|;
name|int
name|thisColor
decl_stmt|;
comment|/* Determine size of character */
name|thisFont
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|)
expr_stmt|;
name|thisColor
operator|=
name|textInfo
operator|->
name|theColors
index|[
name|textInfo
operator|->
name|curFont
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|<=
name|thisFont
operator|->
name|min_char_or_byte2
operator|||
operator|*
name|str
operator|>=
name|thisFont
operator|->
name|max_char_or_byte2
operator|||
name|thisFont
operator|->
name|per_char
operator|==
literal|0
condition|)
name|charWidth
operator|=
name|thisFont
operator|->
name|max_bounds
operator|.
name|width
operator|+
literal|1
expr_stmt|;
else|else
name|charWidth
operator|=
name|thisFont
operator|->
name|per_char
index|[
operator|*
name|str
index|]
operator|.
name|width
operator|+
literal|1
expr_stmt|;
comment|/* Check to see if line wrap is required */
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
if|if
condition|(
name|thisLine
operator|->
name|lineWidth
operator|+
name|charWidth
operator|>
operator|(
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
operator|-
name|WRAPINDSIZE
operator|)
condition|)
block|{
name|DrawLineWrap
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
operator|-
name|WRAPINDSIZE
argument_list|,
name|textInfo
operator|->
name|curY
argument_list|,
name|thisLine
operator|->
name|lineHeight
argument_list|,
name|textInfo
operator|->
name|fgPix
argument_list|)
expr_stmt|;
name|thisLine
operator|->
name|lineFlags
operator||=
name|WRAPFLAG
expr_stmt|;
comment|/* Handle the spacing problem the same way as a newline */
name|HandleNewLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|DODISP
operator||
name|NONEWLINE
argument_list|)
expr_stmt|;
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
block|}
comment|/* Ready to draw character */
name|XDrawString
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|DEFAULT_GC
argument_list|,
name|textInfo
operator|->
name|curX
operator|+=
name|charWidth
argument_list|,
name|textInfo
operator|->
name|curY
operator|+
name|thisLine
operator|->
name|lineHeight
argument_list|,
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append character onto main buffer */
if|if
condition|(
name|textInfo
operator|->
name|bufSpot
operator|>=
name|textInfo
operator|->
name|bufAlloc
condition|)
comment|/* Make room for more characters */
name|ExpandBuffer
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|mainBuffer
index|[
operator|(
name|textInfo
operator|->
name|bufSpot
operator|)
operator|++
index|]
operator|=
operator|(
name|textInfo
operator|->
name|curFont
operator|<<
name|FONTSHIFT
operator|)
operator||
operator|(
operator|*
name|str
operator|)
expr_stmt|;
comment|/* Update the line start array */
name|thisLine
operator|->
name|lineLength
operator|+=
literal|1
expr_stmt|;
name|thisLine
operator|->
name|lineWidth
operator|+=
name|charWidth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|NEWLINE
condition|)
block|{
name|HandleNewLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|DODISP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|NEWFONT
condition|)
block|{
comment|/* Go into waiting for font number mode */
name|textInfo
operator|->
name|flagWord
operator||=
name|FONTNUMWAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|BACKSPACE
condition|)
block|{
name|HandleBackspace
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|DODISP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ignore all others */
block|}
block|}
comment|/* Draw the cursor in its new position */
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|w
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
name|thisLine
operator|->
name|lineWidth
operator|+
name|CUROFFSET
argument_list|,
name|textInfo
operator|->
name|curY
comment|/* + thisLine->lineHeight */
argument_list|,
name|CURSORWIDTH
argument_list|,
name|thisLine
operator|->
name|lineHeight
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtJamStr
parameter_list|(
name|display
parameter_list|,
name|w
parameter_list|,
name|str
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|w
decl_stmt|;
comment|/* Text window            */
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* NULL terminated string */
comment|/*  * This is the same as TxtWriteStr except the screen is NOT updated.  * After a call to this routine,  TxtRepaint should be called to  * update the screen.  This routine is meant to be used to load  * a text buffer with information and then allow the user to  * scroll through it at will.  */
block|{
specifier|register
name|int
name|fontIndex
decl_stmt|;
specifier|register
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
comment|/* str is ok */
init|;
operator|(
operator|*
name|str
operator|!=
literal|0
operator|)
condition|;
name|str
operator|++
control|)
block|{
comment|/* Check to see if we are waiting on a font */
if|if
condition|(
name|textInfo
operator|->
name|flagWord
operator|&
name|FONTNUMWAIT
condition|)
block|{
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|FONTNUMWAIT
operator|)
expr_stmt|;
name|fontIndex
operator|=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|fontIndex
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|fontIndex
operator|<
name|MAXFONTS
operator|)
condition|)
block|{
if|if
condition|(
name|HandleNewFont
argument_list|(
name|display
argument_list|,
name|fontIndex
argument_list|,
name|textInfo
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Handled font -- go get next character */
continue|continue;
block|}
block|}
block|}
comment|/* Inline code for handling normal character case */
if|if
condition|(
operator|(
operator|*
name|str
operator|>=
name|LOWCHAR
operator|)
operator|&&
operator|(
operator|*
name|str
operator|<=
name|HIGHCHAR
operator|)
condition|)
block|{
specifier|register
name|XFontStruct
modifier|*
name|thisFont
decl_stmt|;
specifier|register
name|struct
name|txtLine
modifier|*
name|thisLine
decl_stmt|;
specifier|register
name|int
name|charWidth
decl_stmt|;
comment|/* Determine size of character */
name|thisFont
operator|=
operator|&
operator|(
name|textInfo
operator|->
name|theFonts
index|[
name|textInfo
operator|->
name|curFont
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|<=
name|thisFont
operator|->
name|min_char_or_byte2
operator|||
operator|*
name|str
operator|>=
name|thisFont
operator|->
name|max_char_or_byte2
operator|||
name|thisFont
operator|->
name|per_char
operator|==
literal|0
condition|)
name|charWidth
operator|=
name|thisFont
operator|->
name|max_bounds
operator|.
name|width
operator|+
literal|1
expr_stmt|;
else|else
name|charWidth
operator|=
name|thisFont
operator|->
name|per_char
index|[
operator|*
name|str
index|]
operator|.
name|width
operator|+
literal|1
expr_stmt|;
comment|/* Check to see if line wrap is required */
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
if|if
condition|(
name|thisLine
operator|->
name|lineWidth
operator|+
name|charWidth
operator|>
operator|(
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
operator|-
name|WRAPINDSIZE
operator|)
condition|)
block|{
name|thisLine
operator|->
name|lineFlags
operator||=
name|WRAPFLAG
expr_stmt|;
comment|/* Handle the spacing problem the same way as a newline */
name|HandleNewLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|NONEWLINE
argument_list|)
expr_stmt|;
name|thisLine
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|curLine
index|]
expr_stmt|;
block|}
comment|/* Append character onto main buffer */
if|if
condition|(
name|textInfo
operator|->
name|bufSpot
operator|>=
name|textInfo
operator|->
name|bufAlloc
condition|)
comment|/* Make room for more characters */
name|ExpandBuffer
argument_list|(
name|textInfo
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|mainBuffer
index|[
operator|(
name|textInfo
operator|->
name|bufSpot
operator|)
operator|++
index|]
operator|=
operator|(
name|textInfo
operator|->
name|curFont
operator|<<
name|FONTSHIFT
operator|)
operator||
operator|(
operator|*
name|str
operator|)
expr_stmt|;
comment|/* Update the line start array */
name|thisLine
operator|->
name|lineLength
operator|+=
literal|1
expr_stmt|;
name|thisLine
operator|->
name|lineWidth
operator|+=
name|charWidth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|NEWLINE
condition|)
block|{
name|HandleNewLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|NEWFONT
condition|)
block|{
comment|/* Go into waiting for font number mode */
name|textInfo
operator|->
name|flagWord
operator||=
name|FONTNUMWAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|BACKSPACE
condition|)
block|{
name|HandleBackspace
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ignore all others */
block|}
block|}
name|textInfo
operator|->
name|flagWord
operator||=
name|SCREENWRONG
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtRepaint
parameter_list|(
name|display
parameter_list|,
name|w
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|w
decl_stmt|;
comment|/*  * Repaints the given scrollable text window.  The routine repaints  * the entire window.  For handling exposure events,  the TxtFilter   * routine should be used.  */
block|{
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|int
name|index
decl_stmt|,
name|ypos
decl_stmt|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check to see if the screen is up to date */
if|if
condition|(
name|textInfo
operator|->
name|flagWord
operator|&
name|SCREENWRONG
condition|)
block|{
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|SCREENWRONG
operator|)
expr_stmt|;
block|}
name|ypos
operator|=
name|YPADDING
expr_stmt|;
name|index
operator|=
name|textInfo
operator|->
name|startLine
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DrawLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|index
argument_list|,
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|textInfo
operator|->
name|endLine
condition|)
break|break;
name|ypos
operator|+=
operator|(
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
comment|/* Draw the cursor (if on screen) */
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|==
name|textInfo
operator|->
name|curLine
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|w
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineWidth
operator|+
name|CUROFFSET
argument_list|,
name|ypos
comment|/* + textInfo->txtBuffer[index]->lineHeight */
argument_list|,
name|CURSORWIDTH
argument_list|,
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
argument_list|)
expr_stmt|;
block|}
comment|/* Update the scroll bar */
name|UpdateScroll
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|InsertIndex
parameter_list|(
name|textInfo
parameter_list|,
name|thisIndex
parameter_list|,
name|ypos
parameter_list|)
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text Window Information    */
name|int
name|thisIndex
decl_stmt|;
comment|/* Line index of exposed line */
name|int
name|ypos
decl_stmt|;
comment|/* Drawing position of line   */
comment|/*  * This routine inserts the supplied line index into the copy  * exposure array for 'textInfo'.  The array is kept sorted  * from lowest to highest using insertion sort.  The array  * is dynamically expanded if needed.  */
block|{
name|struct
name|expEvent
modifier|*
name|newItem
decl_stmt|;
name|int
name|newSize
decl_stmt|,
name|index
decl_stmt|,
name|downIndex
decl_stmt|;
comment|/* Check to see if we need to expand it */
if|if
condition|(
operator|(
name|textInfo
operator|->
name|exposeSize
operator|+
literal|3
operator|)
operator|>=
name|textInfo
operator|->
name|exposeAlloc
condition|)
block|{
name|newSize
operator|=
name|textInfo
operator|->
name|exposeAlloc
operator|+
operator|(
name|textInfo
operator|->
name|exposeAlloc
operator|*
name|EXPANDPERCENT
operator|/
literal|100
operator|)
expr_stmt|;
name|textInfo
operator|->
name|exposeAry
operator|=
operator|(
expr|struct
name|expEvent
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|textInfo
operator|->
name|exposeAry
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|newSize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expEvent
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|textInfo
operator|->
name|exposeAlloc
init|;
name|index
operator|<
name|newSize
condition|;
name|index
operator|++
control|)
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
operator|=
name|alloc
argument_list|(
expr|struct
name|expEvent
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|exposeAlloc
operator|=
name|newSize
expr_stmt|;
block|}
comment|/* Find spot for insertion.  NOTE: last spot has big number */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<=
name|textInfo
operator|->
name|exposeSize
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
operator|->
name|lineIndex
operator|>=
name|thisIndex
condition|)
block|{
if|if
condition|(
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
operator|->
name|lineIndex
operator|>
name|thisIndex
condition|)
block|{
comment|/* Insert before this entry */
name|newItem
operator|=
name|textInfo
operator|->
name|exposeAry
index|[
name|textInfo
operator|->
name|exposeSize
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|downIndex
operator|=
name|textInfo
operator|->
name|exposeSize
init|;
name|downIndex
operator|>=
name|index
condition|;
name|downIndex
operator|--
control|)
block|{
name|textInfo
operator|->
name|exposeAry
index|[
name|downIndex
operator|+
literal|1
index|]
operator|=
name|textInfo
operator|->
name|exposeAry
index|[
name|downIndex
index|]
expr_stmt|;
block|}
comment|/* Put a free structure at this spot */
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
operator|=
name|newItem
expr_stmt|;
comment|/* Fill it in */
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
operator|->
name|lineIndex
operator|=
name|thisIndex
expr_stmt|;
name|textInfo
operator|->
name|exposeAry
index|[
name|index
index|]
operator|->
name|ypos
operator|=
name|ypos
expr_stmt|;
comment|/* Break out of loop */
name|textInfo
operator|->
name|exposeSize
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|ScrollUp
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information   */
comment|/*  * This routine scrolls the indicated text window up by one  * line.  The line above the current line must exist.  The  * window is scrolled so that the line above the start line  * is displayed at the top of the screen.  This may cause  * many lines to scroll off the bottom.  The scrolling is  * done using XCopyArea.  The exposure events should be caught  * by ExposeCopy.  */
block|{
name|int
name|targetSpace
decl_stmt|;
comment|/* Make sure all exposures have been handled by now */
if|if
condition|(
name|textInfo
operator|->
name|startLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|targetSpace
operator|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|startLine
operator|-
literal|1
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
expr_stmt|;
comment|/* Move the area downward by the target amount */
name|XCopyArea
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
name|DEFAULT_GC
argument_list|,
literal|0
argument_list|,
name|YPADDING
argument_list|,
name|textInfo
operator|->
name|w
operator|-
name|BARSIZE
argument_list|,
name|textInfo
operator|->
name|h
argument_list|,
literal|0
argument_list|,
name|targetSpace
argument_list|)
expr_stmt|;
name|textInfo
operator|->
name|flagWord
operator||=
name|COPYEXPOSE
expr_stmt|;
comment|/* Update the text window parameters */
name|textInfo
operator|->
name|startLine
operator|-=
literal|1
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear out bottom space region */
ifdef|#
directive|ifdef
name|__386BSD__
name|XClearArea
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
literal|0
argument_list|,
name|textInfo
operator|->
name|h
operator|-
name|textInfo
operator|->
name|bottomSpace
argument_list|,
name|textInfo
operator|->
name|w
argument_list|,
name|textInfo
operator|->
name|bottomSpace
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|XClearArea
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|,
literal|0
argument_list|,
name|textInfo
operator|->
name|h
operator|-
name|textInfo
operator|->
name|bottomSpace
argument_list|,
name|textInfo
operator|->
name|w
argument_list|,
name|textInfo
operator|->
name|bottomSpace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UpdateExposures
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
name|UpdateScroll
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|ScrollToSpot
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|,
name|ySpot
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information          */
name|int
name|ySpot
decl_stmt|;
comment|/* Button position in scroll window */
comment|/*  * This routine scrolls the specified text window relative to the  * position of the mouse in the scroll bar.  The center of the screen  * will be positioned to correspond to the mouse position.  */
block|{
name|int
name|targetLine
decl_stmt|,
name|aboveLines
decl_stmt|;
name|targetLine
operator|=
name|textInfo
operator|->
name|numLines
operator|*
name|ySpot
operator|/
name|textInfo
operator|->
name|h
expr_stmt|;
name|textInfo
operator|->
name|startLine
operator|=
name|targetLine
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
name|aboveLines
operator|=
literal|0
expr_stmt|;
comment|/* Make the target line the *center* of the window */
while|while
condition|(
operator|(
name|textInfo
operator|->
name|startLine
operator|>
literal|0
operator|)
operator|&&
operator|(
name|aboveLines
operator|<
name|textInfo
operator|->
name|endLine
operator|-
name|targetLine
operator|)
condition|)
block|{
name|textInfo
operator|->
name|startLine
operator|-=
literal|1
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
name|aboveLines
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|==
name|textInfo
operator|->
name|numLines
operator|-
literal|1
condition|)
block|{
name|WarpToBottom
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
name|TxtRepaint
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|LineToTop
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|,
name|pos
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information */
name|int
name|pos
decl_stmt|;
comment|/* Y position of mouse     */
comment|/*  * This routine scrolls the screen down until the line at the  * mouse position is at the top of the screen.  It stops  * if it can't scroll the buffer down that far.  If the  * global 'ScrollOption' is NORMSCROLL,  a smooth scroll  * is used.  Otherwise,  it jumps to the right position  * and repaints the screen.  */
block|{
name|int
name|index
decl_stmt|,
name|sum
decl_stmt|;
comment|/* First,  we find the current line */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
name|textInfo
operator|->
name|startLine
init|;
name|index
operator|<=
name|textInfo
operator|->
name|endLine
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|sum
operator|+
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
operator|>
name|pos
condition|)
break|break;
name|sum
operator|+=
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
operator|+
name|INTERLINE
expr_stmt|;
block|}
comment|/* We always want to scroll down at least one line */
if|if
condition|(
name|index
operator|==
name|textInfo
operator|->
name|startLine
condition|)
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|ScrollOption
operator|==
name|NORMSCROLL
condition|)
block|{
comment|/* Scroll down until 'index' is the starting line */
while|while
condition|(
operator|(
name|textInfo
operator|->
name|startLine
operator|<
name|index
operator|)
operator|&&
name|ScrollDown
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
condition|)
block|{
comment|/* Empty Loop Body */
block|}
block|}
else|else
block|{
comment|/* Immediately jump to correct spot */
name|textInfo
operator|->
name|startLine
operator|=
name|index
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|==
name|textInfo
operator|->
name|numLines
operator|-
literal|1
condition|)
block|{
name|WarpToBottom
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
name|TxtRepaint
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check to see if at end of buffer */
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|>=
name|textInfo
operator|->
name|numLines
operator|-
literal|1
condition|)
block|{
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|NOTATBOTTOM
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|TopToHere
parameter_list|(
name|display
parameter_list|,
name|textInfo
parameter_list|,
name|pos
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
comment|/* Text window information */
name|int
name|pos
decl_stmt|;
comment|/* Y position of mouse     */
comment|/*  * This routine scrolls the screen up until the top line of  * the screen is at the current Y position of the mouse.  Again,  * it will stop if it can't scroll that far.  If the global  * 'ScrollOption' is NORMSCROLL,  a smooth scroll is used.  * If it's not,  it will simply redraw the screen at the  * correct spot.  */
block|{
name|int
name|sum
decl_stmt|,
name|target
decl_stmt|,
name|linesup
decl_stmt|,
name|index
decl_stmt|;
name|target
operator|=
name|pos
operator|-
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|startLine
index|]
operator|->
name|lineHeight
expr_stmt|;
comment|/* We always want to scroll up at least one line */
if|if
condition|(
name|target
operator|<=
literal|0
condition|)
name|target
operator|=
literal|1
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|linesup
operator|=
literal|0
expr_stmt|;
comment|/* Check to see if we are at the top anyway */
if|if
condition|(
name|textInfo
operator|->
name|startLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ScrollOption
operator|==
name|NORMSCROLL
condition|)
block|{
comment|/* Scroll up until sum of new top lines greater than target */
while|while
condition|(
operator|(
name|sum
operator|<
name|target
operator|)
operator|&&
name|ScrollUp
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|textInfo
operator|->
name|txtBuffer
index|[
name|textInfo
operator|->
name|startLine
index|]
operator|->
name|lineHeight
expr_stmt|;
name|linesup
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Search backward to find index */
name|index
operator|=
name|textInfo
operator|->
name|startLine
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|index
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sum
operator|<
name|target
operator|)
condition|)
block|{
name|sum
operator|+=
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
expr_stmt|;
name|linesup
operator|++
expr_stmt|;
name|index
operator|--
expr_stmt|;
block|}
comment|/* Go directly to the index */
name|textInfo
operator|->
name|startLine
operator|=
name|index
expr_stmt|;
name|textInfo
operator|->
name|endLine
operator|=
name|FindEndLine
argument_list|(
name|textInfo
argument_list|,
operator|&
operator|(
name|textInfo
operator|->
name|bottomSpace
operator|)
argument_list|)
expr_stmt|;
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
name|TxtRepaint
argument_list|(
name|display
argument_list|,
name|textInfo
operator|->
name|mainWindow
argument_list|)
expr_stmt|;
block|}
comment|/* If we scrolled,  assert we are not at bottom of buffer */
if|if
condition|(
name|linesup
operator|>
literal|0
condition|)
block|{
name|textInfo
operator|->
name|flagWord
operator||=
name|NOTATBOTTOM
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|TxtFilter
parameter_list|(
name|display
parameter_list|,
name|evt
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|XEvent
modifier|*
name|evt
decl_stmt|;
comment|/*  * This routine handles events associated with scrollable text windows.  * It will handle all exposure events and any button released events  * in the scroll bar of a text window.  It does NOT handle any other  * events.  If it cannot handle the event,  it will return 0.  */
block|{
name|XExposeEvent
modifier|*
name|expose
init|=
operator|&
name|evt
operator|->
name|xexpose
decl_stmt|;
name|XButtonEvent
modifier|*
name|btEvt
init|=
operator|&
name|evt
operator|->
name|xbutton
decl_stmt|;
name|XGraphicsExposeEvent
modifier|*
name|gexpose
init|=
operator|&
name|evt
operator|->
name|xgraphicsexpose
decl_stmt|;
name|XNoExposeEvent
modifier|*
name|noexpose
init|=
operator|&
name|evt
operator|->
name|xnoexpose
decl_stmt|;
name|struct
name|txtWin
modifier|*
name|textInfo
decl_stmt|;
name|int
name|index
decl_stmt|,
name|ypos
decl_stmt|;
name|Window
name|w
decl_stmt|,
name|sw
decl_stmt|;
if|if
condition|(
name|textWindows
operator|==
operator|(
name|XAssocTable
operator|*
operator|)
literal|0
condition|)
block|{
name|textWindows
operator|=
name|XCreateAssocTable
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|textWindows
operator|==
operator|(
name|XAssocTable
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|evt
operator|->
name|type
operator|==
name|Expose
condition|)
block|{
name|w
operator|=
name|expose
operator|->
name|window
expr_stmt|;
name|sw
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evt
operator|->
name|type
operator|==
name|GraphicsExpose
condition|)
block|{
name|w
operator|=
name|gexpose
operator|->
name|drawable
expr_stmt|;
name|sw
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evt
operator|->
name|type
operator|==
name|NoExpose
condition|)
block|{
name|w
operator|=
name|noexpose
operator|->
name|drawable
expr_stmt|;
name|sw
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evt
operator|->
name|type
operator|==
name|ButtonRelease
condition|)
block|{
name|w
operator|=
name|btEvt
operator|->
name|window
expr_stmt|;
name|sw
operator|=
name|btEvt
operator|->
name|subwindow
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|textInfo
operator|=
operator|(
expr|struct
name|txtWin
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|textWindows
argument_list|,
operator|(
name|XID
operator|)
name|w
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Determine whether it's main window or not */
if|if
condition|(
operator|(
name|w
operator|==
name|textInfo
operator|->
name|mainWindow
operator|)
operator|&&
operator|(
name|sw
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Main Window - handle exposures */
switch|switch
condition|(
name|evt
operator|->
name|type
condition|)
block|{
case|case
name|Expose
case|:
name|ypos
operator|=
literal|0
comment|/*YPADDING*/
expr_stmt|;
for|for
control|(
name|index
operator|=
name|textInfo
operator|->
name|startLine
init|;
name|index
operator|<=
name|textInfo
operator|->
name|endLine
condition|;
name|index
operator|++
control|)
block|{
name|int
name|lh
init|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ypos
operator|+
name|lh
operator|)
operator|>=
name|expose
operator|->
name|y
operator|)
operator|&&
operator|(
name|ypos
operator|<=
operator|(
name|expose
operator|->
name|y
operator|+
name|expose
operator|->
name|height
operator|)
operator|)
condition|)
block|{
comment|/* Intersection region */
comment|/* Draw line immediately */
name|DrawLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|index
argument_list|,
name|ypos
argument_list|)
expr_stmt|;
comment|/* And possibly draw cursor */
if|if
condition|(
name|textInfo
operator|->
name|curLine
operator|==
name|index
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|w
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineWidth
operator|+
name|CUROFFSET
argument_list|,
name|ypos
argument_list|,
name|CURSORWIDTH
argument_list|,
name|lh
argument_list|)
expr_stmt|;
block|}
block|}
name|ypos
operator|+=
name|lh
operator|+
name|INTERLINE
expr_stmt|;
block|}
break|break;
case|case
name|GraphicsExpose
case|:
name|ypos
operator|=
literal|0
comment|/*YPADDING*/
expr_stmt|;
for|for
control|(
name|index
operator|=
name|textInfo
operator|->
name|startLine
init|;
name|index
operator|<=
name|textInfo
operator|->
name|endLine
condition|;
name|index
operator|++
control|)
block|{
name|int
name|lh
init|=
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineHeight
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ypos
operator|+
name|lh
operator|)
operator|>=
name|gexpose
operator|->
name|y
operator|)
operator|&&
operator|(
name|ypos
operator|<=
operator|(
name|gexpose
operator|->
name|y
operator|+
name|gexpose
operator|->
name|height
operator|)
operator|)
condition|)
block|{
comment|/* Intersection region */
comment|/* Draw line immediately */
name|DrawLine
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|index
argument_list|,
name|ypos
argument_list|)
expr_stmt|;
comment|/* And possibly draw cursor */
if|if
condition|(
name|textInfo
operator|->
name|curLine
operator|==
name|index
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|w
argument_list|,
name|textInfo
operator|->
name|CursorGC
argument_list|,
name|textInfo
operator|->
name|txtBuffer
index|[
name|index
index|]
operator|->
name|lineWidth
operator|+
name|CUROFFSET
argument_list|,
name|ypos
argument_list|,
name|CURSORWIDTH
argument_list|,
name|lh
argument_list|)
expr_stmt|;
block|}
block|}
name|ypos
operator|+=
name|lh
operator|+
name|INTERLINE
expr_stmt|;
block|}
break|break;
case|case
name|NoExpose
case|:
break|break;
default|default:
comment|/* Not one of our events */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|evt
operator|->
name|type
condition|)
block|{
case|case
name|Expose
case|:
name|UpdateScroll
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|ButtonRelease
case|:
comment|/* Find out which button */
switch|switch
condition|(
name|btEvt
operator|->
name|button
condition|)
block|{
case|case
name|Button1
case|:
comment|/* Scroll up until top line is at mouse position */
name|TopToHere
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|btEvt
operator|->
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|Button2
case|:
comment|/* Scroll to spot relative to position */
name|ScrollToSpot
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|btEvt
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|textInfo
operator|->
name|endLine
operator|>=
name|textInfo
operator|->
name|numLines
operator|-
literal|1
condition|)
block|{
name|textInfo
operator|->
name|flagWord
operator|&=
operator|(
operator|~
name|NOTATBOTTOM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|textInfo
operator|->
name|flagWord
operator||=
name|NOTATBOTTOM
expr_stmt|;
block|}
break|break;
case|case
name|Button3
case|:
comment|/* Scroll down until pointed line is at top */
name|LineToTop
argument_list|(
name|display
argument_list|,
name|textInfo
argument_list|,
name|btEvt
operator|->
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/* Not one of our events */
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

