begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.1.1.1 $ on $Date: 1993/06/12 14:41:07 $  *           $Source: /a/cvs/386BSD/src/gnu/chess/Xchess/std.c,v $  * Copyright (c) 1985 Wayne A. Christopher, U. C. Berkeley CAD Group  *  * Utility routines.  */
end_comment

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
endif|not IBMPC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
endif|UNIX
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
endif|BSD
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|prefix
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|s
operator|)
condition|)
name|p
operator|++
operator|,
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Create a copy of a string. */
end_comment

begin_function
name|char
modifier|*
name|copy
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|tmalloc
argument_list|()
decl_stmt|;
name|p
operator|=
name|tmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether sub is a substring of str. */
end_comment

begin_function
name|bool
name|substring
parameter_list|(
name|sub
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|sub
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
operator|*
name|sub
condition|)
block|{
for|for
control|(
name|s
operator|=
name|sub
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|str
operator|++
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
name|str
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Malloc num bytes and initialize to zero. Fatal error if the space can't  * be malloc'd.   */
end_comment

begin_function
name|char
modifier|*
name|tmalloc
parameter_list|(
name|num
parameter_list|)
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|s
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: can't allocate %d bytes"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|s
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|trealloc
parameter_list|(
name|ptr
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
name|s
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
operator|(
name|unsigned
operator|)
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|fatal
argument_list|(
literal|"realloc: can't allocate %d bytes"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
comment|/* Well, this won't be zeroed... Too bad... */
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Append one character to a string. Don't check for overflow. */
end_comment

begin_function
name|void
name|appendc
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|scannum
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|*
operator|(
name|str
operator|++
operator|)
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Case insensitive prefix. */
end_comment

begin_function
name|bool
name|ciprefix
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
else|:
operator|*
name|p
operator|)
operator|!=
operator|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
else|:
operator|*
name|s
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|p
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Case insensitive strcmp... */
end_comment

begin_function
name|bool
name|cieq
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
else|:
operator|*
name|p
operator|)
operator|!=
operator|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
else|:
operator|*
name|s
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|p
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|!
operator|*
name|s
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_comment
comment|/* Return the date. Return value is static data. */
end_comment

begin_function
name|char
modifier|*
name|datestring
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|tzn
decl_stmt|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
specifier|static
name|char
name|tbuf
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|char
modifier|*
name|timezone
argument_list|()
decl_stmt|,
modifier|*
name|asctime
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|ap
operator|=
name|asctime
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tzn
operator|=
name|timezone
argument_list|(
name|tz
operator|.
name|tz_minuteswest
argument_list|,
name|tp
operator|->
name|tm_isdst
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%.20s"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzn
condition|)
name|strcat
argument_list|(
name|tbuf
argument_list|,
name|tzn
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tbuf
argument_list|,
name|ap
operator|+
literal|19
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|tbuf
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|tbuf
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
else|BSD
end_else

begin_comment
comment|/* Give it a try... */
end_comment

begin_function
name|char
modifier|*
name|datestring
parameter_list|()
block|{
name|long
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|i
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ctime
argument_list|(
operator|&
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Kill the nl. */
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How many seconds have elapsed in running time. */
end_comment

begin_function
name|int
name|seconds
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BSD
name|struct
name|rusage
name|ruse
decl_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|ruse
argument_list|)
expr_stmt|;
return|return
operator|(
name|ruse
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|)
return|;
else|#
directive|else
else|BSD
endif|#
directive|endif
endif|BSD
block|}
end_function

begin_comment
comment|/* A few things that may not exist on non-unix systems. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_function
name|char
modifier|*
name|index
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|s
operator|!=
name|c
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\0'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|not index
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|rindex
end_ifndef

begin_function
name|char
modifier|*
name|rindex
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|!=
literal|'\0'
condition|;
name|t
operator|++
control|)
empty_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|!=
name|c
operator|)
operator|&&
operator|(
name|t
operator|!=
name|s
operator|)
condition|)
name|t
operator|--
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|s
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|not rindex
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|bcopy
end_ifndef

begin_function
name|void
name|bcopy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|num
parameter_list|)
specifier|register
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|num
operator|--
operator|>
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|not bcopy
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|bzero
end_ifndef

begin_function
name|void
name|bzero
parameter_list|(
name|ptr
parameter_list|,
name|num
parameter_list|)
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
while|while
condition|(
name|num
operator|--
operator|>
literal|0
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|not bzero
end_endif

begin_comment
comment|/* This might not be around... If not then forget about sorting... */
end_comment

begin_function
name|void
name|qsort
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
endif|BSD
end_endif

begin_function
name|char
modifier|*
name|gettok
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
operator|(
operator|*
name|s
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|s
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
operator|(
operator|*
name|s
operator|)
operator|++
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
operator|(
operator|*
name|s
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|copy
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Die horribly. */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"Internal Error: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__386BSD__
name|_doprnt
argument_list|(
name|s
argument_list|,
operator|&
name|args
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGIOT
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|setenv
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|xx
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|tmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s="
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Copy the old environment... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|prefix
argument_list|(
name|s
argument_list|,
name|environ
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|environ
index|[
name|i
index|]
condition|)
block|{
name|xx
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|tmalloc
argument_list|(
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|xx
index|[
name|i
index|]
operator|=
name|environ
index|[
name|i
index|]
expr_stmt|;
name|xx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|environ
operator|=
name|xx
expr_stmt|;
block|}
else|else
name|xx
operator|=
name|environ
expr_stmt|;
name|xx
index|[
name|i
index|]
operator|=
name|tmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|xx
index|[
name|i
index|]
argument_list|,
literal|"%s=%s"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|char
modifier|*
name|getusername
parameter_list|()
block|{
name|int
name|i
init|=
name|getuid
argument_list|()
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
init|=
name|getpwuid
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
operator|(
name|pw
condition|?
name|pw
operator|->
name|pw_name
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gethome
parameter_list|()
block|{
name|int
name|i
init|=
name|getuid
argument_list|()
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
init|=
name|getpwuid
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
operator|(
name|pw
condition|?
name|pw
operator|->
name|pw_dir
else|:
literal|"/strange"
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|tildexpand
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|,
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'~'
condition|)
return|return
operator|(
name|copy
argument_list|(
name|s
argument_list|)
operator|)
return|;
for|for
control|(
name|s
operator|++
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'/'
condition|;
name|s
operator|++
operator|,
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|pw
operator|=
name|getpwnam
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|n
operator|=
name|tmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|strlen
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

