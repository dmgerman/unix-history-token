begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   C source for CHESS      Revision: 4-25-88    Copyright (C) 1986, 1987, 1988 Free Software Foundation, Inc.   Copyright (c) 1988   John Stanback    This file is part of CHESS.    CHESS is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY.  No author or distributor   accepts responsibility to anyone for the consequences of using it   or for whether it serves any particular purpose or works at all,   unless he says so in writing.  Refer to the CHESS General Public   License for full details.    Everyone is granted permission to copy, modify and redistribute   CHESS, but only under the conditions described in the   CHESS General Public License.   A copy of this license is   supposed to have been given to you along with CHESS so you   can know your rights and responsibilities.  It should be in a   file named COPYING.  Among other things, the copyright notice   and this notice must be preserved on all copies. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<alloc.h>
end_include

begin_define
define|#
directive|define
name|ttblsz
value|4096
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_define
define|#
directive|define
name|ttblsz
value|16384
end_define

begin_define
define|#
directive|define
name|huge
end_define

begin_endif
endif|#
directive|endif
endif|MSDOS
end_endif

begin_include
include|#
directive|include
file|"move.h"
end_include

begin_define
define|#
directive|define
name|neutral
value|2
end_define

begin_define
define|#
directive|define
name|white
value|0
end_define

begin_define
define|#
directive|define
name|black
value|1
end_define

begin_define
define|#
directive|define
name|no_piece
value|0
end_define

begin_define
define|#
directive|define
name|pawn
value|1
end_define

begin_define
define|#
directive|define
name|knight
value|2
end_define

begin_define
define|#
directive|define
name|bishop
value|3
end_define

begin_define
define|#
directive|define
name|rook
value|4
end_define

begin_define
define|#
directive|define
name|queen
value|5
end_define

begin_define
define|#
directive|define
name|king
value|6
end_define

begin_define
define|#
directive|define
name|valueP
value|100
end_define

begin_define
define|#
directive|define
name|valueN
value|350
end_define

begin_define
define|#
directive|define
name|valueB
value|355
end_define

begin_define
define|#
directive|define
name|valueR
value|550
end_define

begin_define
define|#
directive|define
name|valueQ
value|1100
end_define

begin_define
define|#
directive|define
name|valueK
value|1200
end_define

begin_define
define|#
directive|define
name|ctlP
value|0x4000
end_define

begin_define
define|#
directive|define
name|ctlN
value|0x2800
end_define

begin_define
define|#
directive|define
name|ctlB
value|0x1800
end_define

begin_define
define|#
directive|define
name|ctlR
value|0x0400
end_define

begin_define
define|#
directive|define
name|ctlQ
value|0x0200
end_define

begin_define
define|#
directive|define
name|ctlK
value|0x0100
end_define

begin_define
define|#
directive|define
name|ctlBQ
value|0x1200
end_define

begin_define
define|#
directive|define
name|ctlRQ
value|0x0600
end_define

begin_define
define|#
directive|define
name|ctlNN
value|0x2000
end_define

begin_define
define|#
directive|define
name|pxx
value|" PNBRQK"
end_define

begin_define
define|#
directive|define
name|qxx
value|" pnbrqk"
end_define

begin_define
define|#
directive|define
name|rxx
value|"12345678"
end_define

begin_define
define|#
directive|define
name|cxx
value|"abcdefgh"
end_define

begin_define
define|#
directive|define
name|check
value|0x0001
end_define

begin_define
define|#
directive|define
name|capture
value|0x0002
end_define

begin_define
define|#
directive|define
name|draw
value|0x0004
end_define

begin_define
define|#
directive|define
name|promote
value|0x0008
end_define

begin_define
define|#
directive|define
name|cstlmask
value|0x0010
end_define

begin_define
define|#
directive|define
name|epmask
value|0x0020
end_define

begin_define
define|#
directive|define
name|exact
value|0x0040
end_define

begin_define
define|#
directive|define
name|pwnthrt
value|0x0080
end_define

begin_define
define|#
directive|define
name|truescore
value|0x0001
end_define

begin_define
define|#
directive|define
name|lowerbound
value|0x0002
end_define

begin_define
define|#
directive|define
name|upperbound
value|0x0004
end_define

begin_define
define|#
directive|define
name|maxdepth
value|30
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_define
define|#
directive|define
name|absv
parameter_list|(
name|x
parameter_list|)
value|((x)< 0 ? -(x) : (x))
end_define

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|1
operator|)
end_if

begin_define
define|#
directive|define
name|taxicab
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(abs(column[a]-column[b]) + abs(row[a]-row[b]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|leaf
block|{
name|short
name|f
decl_stmt|,
name|t
decl_stmt|,
name|score
decl_stmt|,
name|reply
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|GameRec
block|{
name|unsigned
name|short
name|gmove
decl_stmt|;
name|short
name|score
decl_stmt|,
name|depth
decl_stmt|,
name|time
decl_stmt|,
name|piece
decl_stmt|,
name|color
decl_stmt|;
name|long
name|nodes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|TimeControlRec
block|{
name|short
name|moves
index|[
literal|2
index|]
decl_stmt|;
name|long
name|clock
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|BookEntry
block|{
name|struct
name|BookEntry
modifier|*
name|next
decl_stmt|;
name|unsigned
name|short
modifier|*
name|mv
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hashval
block|{
name|unsigned
name|long
name|bd
decl_stmt|;
name|unsigned
name|short
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hashentry
block|{
name|unsigned
name|long
name|hashbd
decl_stmt|;
name|unsigned
name|short
name|mv
decl_stmt|,
name|flags
decl_stmt|;
name|short
name|score
decl_stmt|,
name|depth
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|mvstr1
index|[
literal|5
index|]
decl_stmt|,
name|mvstr2
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|leaf
name|Tree
index|[
literal|2000
index|]
decl_stmt|,
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|TrPnt
index|[
name|maxdepth
index|]
decl_stmt|,
name|board
index|[
literal|64
index|]
decl_stmt|,
name|color
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|row
index|[
literal|64
index|]
decl_stmt|,
name|column
index|[
literal|64
index|]
decl_stmt|,
name|locn
index|[
literal|8
index|]
index|[
literal|8
index|]
decl_stmt|,
name|Pindex
index|[
literal|64
index|]
decl_stmt|,
name|svalue
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PieceList
index|[
literal|2
index|]
index|[
literal|16
index|]
decl_stmt|,
name|PieceCnt
index|[
literal|2
index|]
decl_stmt|,
name|atak
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|,
name|PawnCnt
index|[
literal|2
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|castld
index|[
literal|2
index|]
decl_stmt|,
name|kingmoved
index|[
literal|2
index|]
decl_stmt|,
name|mtl
index|[
literal|2
index|]
decl_stmt|,
name|pmtl
index|[
literal|2
index|]
decl_stmt|,
name|emtl
index|[
literal|2
index|]
decl_stmt|,
name|hung
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|c1
decl_stmt|,
name|c2
decl_stmt|,
modifier|*
name|atk1
decl_stmt|,
modifier|*
name|atk2
decl_stmt|,
modifier|*
name|PC1
decl_stmt|,
modifier|*
name|PC2
decl_stmt|,
name|EnemyKing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|mate
decl_stmt|,
name|post
decl_stmt|,
name|opponent
decl_stmt|,
name|computer
decl_stmt|,
name|Sdepth
decl_stmt|,
name|Awindow
decl_stmt|,
name|Bwindow
decl_stmt|,
name|dither
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ResponseTime
decl_stmt|,
name|ExtraTime
decl_stmt|,
name|Level
decl_stmt|,
name|et
decl_stmt|,
name|et0
decl_stmt|,
name|time0
decl_stmt|,
name|cputimer
decl_stmt|,
name|ft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|NodeCnt
decl_stmt|,
name|evrate
decl_stmt|,
name|ETnodes
decl_stmt|,
name|EvalNodes
decl_stmt|,
name|HashCnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|quit
decl_stmt|,
name|reverse
decl_stmt|,
name|bothsides
decl_stmt|,
name|hashflag
decl_stmt|,
name|InChk
decl_stmt|,
name|player
decl_stmt|,
name|force
decl_stmt|,
name|easy
decl_stmt|,
name|beep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|wking
decl_stmt|,
name|bking
decl_stmt|,
name|FROMsquare
decl_stmt|,
name|TOsquare
decl_stmt|,
name|timeout
decl_stmt|,
name|Zscore
decl_stmt|,
name|zwndw
decl_stmt|,
name|xwndw
decl_stmt|,
name|slk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|INCscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|HasPawn
index|[
literal|2
index|]
decl_stmt|,
name|HasKnight
index|[
literal|2
index|]
decl_stmt|,
name|HasBishop
index|[
literal|2
index|]
decl_stmt|,
name|HasRook
index|[
literal|2
index|]
decl_stmt|,
name|HasQueen
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ChkFlag
index|[
name|maxdepth
index|]
decl_stmt|,
name|CptrFlag
index|[
name|maxdepth
index|]
decl_stmt|,
name|PawnThreat
index|[
name|maxdepth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Pscore
index|[
name|maxdepth
index|]
decl_stmt|,
name|Tscore
index|[
name|maxdepth
index|]
decl_stmt|,
name|Threat
index|[
name|maxdepth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|GameRec
name|GameList
index|[
literal|240
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|GameCnt
decl_stmt|,
name|Game50
decl_stmt|,
name|epsquare
decl_stmt|,
name|lpost
decl_stmt|,
name|rcptr
decl_stmt|,
name|contempt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|MaxSearchDepth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|BookEntry
modifier|*
name|Book
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|TimeControlRec
name|TimeControl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|TCflag
decl_stmt|,
name|TCmoves
decl_stmt|,
name|TCminutes
decl_stmt|,
name|OperatorTime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|otherside
index|[
literal|3
index|]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rank7
index|[
literal|3
index|]
init|=
block|{
literal|6
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|map
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x20
block|,
literal|0x21
block|,
literal|0x22
block|,
literal|0x23
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x40
block|,
literal|0x41
block|,
literal|0x42
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x50
block|,
literal|0x51
block|,
literal|0x52
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x60
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|unmap
index|[
literal|120
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Dcode
index|[
literal|120
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0E
block|,
literal|0x0F
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0F
block|,
literal|0x1F
block|,
literal|0x10
block|,
literal|0x21
block|,
literal|0x11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0F
block|,
literal|0
block|,
literal|0
block|,
literal|0x10
block|,
literal|0
block|,
literal|0
block|,
literal|0x11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0F
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0F
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0F
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x11
block|,
literal|0
block|,
literal|0
block|,
literal|0x0F
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x11
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Stboard
index|[
literal|64
index|]
init|=
block|{
name|rook
block|,
name|knight
block|,
name|bishop
block|,
name|queen
block|,
name|king
block|,
name|bishop
block|,
name|knight
block|,
name|rook
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|pawn
block|,
name|rook
block|,
name|knight
block|,
name|bishop
block|,
name|queen
block|,
name|king
block|,
name|bishop
block|,
name|knight
block|,
name|rook
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Stcolor
index|[
literal|64
index|]
init|=
block|{
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
name|white
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|,
name|black
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|sweep
index|[
literal|7
index|]
init|=
block|{
name|false
block|,
name|false
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Dpwn
index|[
literal|3
index|]
init|=
block|{
literal|4
block|,
literal|6
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Dstart
index|[
literal|7
index|]
init|=
block|{
literal|6
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Dstop
index|[
literal|7
index|]
init|=
block|{
literal|7
block|,
literal|5
block|,
literal|15
block|,
literal|7
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Dir
index|[
literal|16
index|]
init|=
block|{
literal|1
block|,
literal|0x10
block|,
operator|-
literal|1
block|,
operator|-
literal|0x10
block|,
literal|0x0F
block|,
literal|0x11
block|,
operator|-
literal|0x0F
block|,
operator|-
literal|0x11
block|,
literal|0x0E
block|,
operator|-
literal|0x0E
block|,
literal|0x12
block|,
operator|-
literal|0x12
block|,
literal|0x1F
block|,
operator|-
literal|0x1F
block|,
literal|0x21
block|,
operator|-
literal|0x21
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Pdir
index|[
literal|34
index|]
init|=
block|{
literal|0
block|,
literal|0x38
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x02
block|,
literal|0x35
block|,
literal|0x38
block|,
literal|0x35
block|,
literal|0x02
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x02
block|,
literal|0
block|,
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|pbit
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|killr0
index|[
name|maxdepth
index|]
decl_stmt|,
name|killr1
index|[
name|maxdepth
index|]
decl_stmt|,
name|killr2
index|[
name|maxdepth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|killr3
index|[
name|maxdepth
index|]
decl_stmt|,
name|PrVar
index|[
name|maxdepth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|PV
decl_stmt|,
name|hint
decl_stmt|,
name|Swag0
decl_stmt|,
name|Swag1
decl_stmt|,
name|Swag2
decl_stmt|,
name|Swag3
decl_stmt|,
name|Swag4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|hashkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|hashbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hashval
name|hashcode
index|[
literal|2
index|]
index|[
literal|7
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hashentry
name|huge
modifier|*
name|ttable
decl_stmt|,
modifier|*
name|ptbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|history
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Mwpawn
index|[
literal|64
index|]
decl_stmt|,
name|Mbpawn
index|[
literal|64
index|]
decl_stmt|,
name|Mknight
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|,
name|Mbishop
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Mking
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|,
name|Kfield
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|value
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
name|valueP
block|,
name|valueN
block|,
name|valueB
block|,
name|valueR
block|,
name|valueQ
block|,
name|valueK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|control
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
name|ctlP
block|,
name|ctlN
block|,
name|ctlB
block|,
name|ctlR
block|,
name|ctlQ
block|,
name|ctlK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PassedPawn0
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|60
block|,
literal|80
block|,
literal|120
block|,
literal|200
block|,
literal|360
block|,
literal|600
block|,
literal|800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PassedPawn1
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|30
block|,
literal|40
block|,
literal|60
block|,
literal|100
block|,
literal|180
block|,
literal|300
block|,
literal|800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PassedPawn2
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|15
block|,
literal|25
block|,
literal|35
block|,
literal|50
block|,
literal|90
block|,
literal|140
block|,
literal|800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PassedPawn3
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|5
block|,
literal|10
block|,
literal|15
block|,
literal|20
block|,
literal|30
block|,
literal|140
block|,
literal|800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ISOLANI
index|[
literal|8
index|]
init|=
block|{
operator|-
literal|12
block|,
operator|-
literal|16
block|,
operator|-
literal|20
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|20
block|,
operator|-
literal|16
block|,
operator|-
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|BACKWARD
index|[
literal|8
index|]
init|=
block|{
operator|-
literal|6
block|,
operator|-
literal|10
block|,
operator|-
literal|15
block|,
operator|-
literal|21
block|,
operator|-
literal|28
block|,
operator|-
literal|28
block|,
operator|-
literal|28
block|,
operator|-
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|BMBLTY
index|[
literal|14
index|]
init|=
block|{
operator|-
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|RMBLTY
index|[
literal|14
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Kthreat
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
operator|-
literal|8
block|,
operator|-
literal|20
block|,
operator|-
literal|36
block|,
operator|-
literal|52
block|,
operator|-
literal|68
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|KNIGHTPOST
decl_stmt|,
name|KNIGHTSTRONG
decl_stmt|,
name|BISHOPSTRONG
decl_stmt|,
name|KATAK
decl_stmt|,
name|KBNKsq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PEDRNK2B
decl_stmt|,
name|PWEAKH
decl_stmt|,
name|PADVNCM
decl_stmt|,
name|PADVNCI
decl_stmt|,
name|PAWNSHIELD
decl_stmt|,
name|PDOUBLED
decl_stmt|,
name|PBLOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|RHOPN
decl_stmt|,
name|RHOPNX
decl_stmt|,
name|KHOPN
decl_stmt|,
name|KHOPNX
decl_stmt|,
name|KSFTY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ATAKD
decl_stmt|,
name|HUNGP
decl_stmt|,
name|HUNGX
decl_stmt|,
name|KCASTLD
decl_stmt|,
name|KMOVD
decl_stmt|,
name|XRAY
decl_stmt|,
name|PINVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|stage
decl_stmt|,
name|stage2
decl_stmt|,
name|Zwmtl
decl_stmt|,
name|Zbmtl
decl_stmt|,
name|Developed
index|[
literal|2
index|]
decl_stmt|,
name|PawnStorm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PawnBonus
decl_stmt|,
name|BishopBonus
decl_stmt|,
name|RookBonus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|KingOpening
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|4
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|4
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|8
block|,
operator|-
literal|12
block|,
operator|-
literal|12
block|,
operator|-
literal|8
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|12
block|,
operator|-
literal|16
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|16
block|,
operator|-
literal|12
block|,
operator|-
literal|16
block|,
operator|-
literal|20
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|20
block|,
operator|-
literal|16
block|,
operator|-
literal|16
block|,
operator|-
literal|20
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|24
block|,
operator|-
literal|20
block|,
operator|-
literal|16
block|,
operator|-
literal|12
block|,
operator|-
literal|16
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|16
block|,
operator|-
literal|12
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|8
block|,
operator|-
literal|12
block|,
operator|-
literal|12
block|,
operator|-
literal|8
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|4
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|4
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|KingEnding
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|6
block|,
literal|12
block|,
literal|18
block|,
literal|18
block|,
literal|12
block|,
literal|6
block|,
literal|0
block|,
literal|6
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|24
block|,
literal|18
block|,
literal|12
block|,
literal|6
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|30
block|,
literal|30
block|,
literal|24
block|,
literal|18
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|30
block|,
literal|36
block|,
literal|36
block|,
literal|30
block|,
literal|24
block|,
literal|18
block|,
literal|18
block|,
literal|24
block|,
literal|30
block|,
literal|36
block|,
literal|36
block|,
literal|30
block|,
literal|24
block|,
literal|18
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|30
block|,
literal|30
block|,
literal|24
block|,
literal|18
block|,
literal|12
block|,
literal|6
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|24
block|,
literal|18
block|,
literal|12
block|,
literal|6
block|,
literal|0
block|,
literal|6
block|,
literal|12
block|,
literal|18
block|,
literal|18
block|,
literal|12
block|,
literal|6
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|DyingKing
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|16
block|,
literal|24
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|0
block|,
literal|8
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|48
block|,
literal|40
block|,
literal|32
block|,
literal|8
block|,
literal|16
block|,
literal|40
block|,
literal|56
block|,
literal|64
block|,
literal|64
block|,
literal|56
block|,
literal|40
block|,
literal|16
block|,
literal|24
block|,
literal|48
block|,
literal|64
block|,
literal|72
block|,
literal|72
block|,
literal|64
block|,
literal|48
block|,
literal|24
block|,
literal|24
block|,
literal|48
block|,
literal|64
block|,
literal|72
block|,
literal|72
block|,
literal|64
block|,
literal|48
block|,
literal|24
block|,
literal|16
block|,
literal|40
block|,
literal|56
block|,
literal|64
block|,
literal|64
block|,
literal|56
block|,
literal|40
block|,
literal|16
block|,
literal|8
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|48
block|,
literal|40
block|,
literal|32
block|,
literal|8
block|,
literal|0
block|,
literal|8
block|,
literal|16
block|,
literal|24
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|KBNK
index|[
literal|64
index|]
init|=
block|{
literal|99
block|,
literal|90
block|,
literal|80
block|,
literal|70
block|,
literal|60
block|,
literal|50
block|,
literal|40
block|,
literal|40
block|,
literal|90
block|,
literal|80
block|,
literal|60
block|,
literal|50
block|,
literal|40
block|,
literal|30
block|,
literal|20
block|,
literal|40
block|,
literal|80
block|,
literal|60
block|,
literal|40
block|,
literal|30
block|,
literal|20
block|,
literal|10
block|,
literal|30
block|,
literal|50
block|,
literal|70
block|,
literal|50
block|,
literal|30
block|,
literal|10
block|,
literal|0
block|,
literal|20
block|,
literal|40
block|,
literal|60
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|0
block|,
literal|10
block|,
literal|30
block|,
literal|50
block|,
literal|70
block|,
literal|50
block|,
literal|30
block|,
literal|10
block|,
literal|20
block|,
literal|30
block|,
literal|40
block|,
literal|60
block|,
literal|80
block|,
literal|40
block|,
literal|20
block|,
literal|30
block|,
literal|40
block|,
literal|50
block|,
literal|60
block|,
literal|80
block|,
literal|90
block|,
literal|40
block|,
literal|40
block|,
literal|50
block|,
literal|60
block|,
literal|70
block|,
literal|80
block|,
literal|90
block|,
literal|99
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|pknight
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|10
block|,
literal|10
block|,
literal|8
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|20
block|,
literal|20
block|,
literal|16
block|,
literal|8
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|24
block|,
literal|28
block|,
literal|28
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|10
block|,
literal|20
block|,
literal|28
block|,
literal|32
block|,
literal|32
block|,
literal|28
block|,
literal|20
block|,
literal|10
block|,
literal|10
block|,
literal|20
block|,
literal|28
block|,
literal|32
block|,
literal|32
block|,
literal|28
block|,
literal|20
block|,
literal|10
block|,
literal|8
block|,
literal|16
block|,
literal|24
block|,
literal|28
block|,
literal|28
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|20
block|,
literal|20
block|,
literal|16
block|,
literal|8
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|10
block|,
literal|10
block|,
literal|8
block|,
literal|4
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|pbishop
index|[
literal|64
index|]
init|=
block|{
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|22
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|22
block|,
literal|14
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|18
block|,
literal|14
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|18
block|,
literal|14
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|18
block|,
literal|14
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|18
block|,
literal|14
block|,
literal|14
block|,
literal|22
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|22
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|PawnAdvance
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|2
block|,
literal|10
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|6
block|,
literal|6
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|16
block|,
literal|12
block|,
literal|8
block|,
literal|6
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|24
block|,
literal|16
block|,
literal|12
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|24
block|,
literal|16
block|,
literal|12
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|24
block|,
literal|16
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MSDOS
name|ttable
operator|=
operator|(
expr|struct
name|hashentry
name|huge
operator|*
operator|)
name|farmalloc
argument_list|(
name|ttblsz
operator|*
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hashentry
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ttable
operator|=
operator|(
expr|struct
name|hashentry
operator|*
operator|)
name|malloc
argument_list|(
name|ttblsz
operator|*
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hashentry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Level
operator|=
literal|0
expr_stmt|;
name|TCflag
operator|=
name|false
expr_stmt|;
name|OperatorTime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|Level
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|TCmoves
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TCminutes
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TCflag
operator|=
name|true
expr_stmt|;
block|}
name|Initialize
argument_list|()
expr_stmt|;
name|NewGame
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|NEWMOVE
operator|>
literal|0
operator|)
name|Initialize_dist
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|NEWMOVE
operator|>
literal|1
operator|)
name|Initialize_moves
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
operator|!
operator|(
name|quit
operator|)
condition|)
block|{
if|if
condition|(
name|bothsides
operator|&&
operator|!
name|mate
condition|)
name|SelectMove
argument_list|(
name|opponent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|InputCommand
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|quit
operator|||
name|mate
operator|||
name|force
operator|)
condition|)
name|SelectMove
argument_list|(
name|computer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ExitChess
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ............    INTERFACE ROUTINES    ........................... */
end_comment

begin_function
name|int
name|VerifyMove
parameter_list|(
name|s
parameter_list|,
name|iop
parameter_list|,
name|mv
parameter_list|)
name|char
name|s
index|[]
decl_stmt|;
name|short
name|iop
decl_stmt|;
name|unsigned
name|short
modifier|*
name|mv
decl_stmt|;
comment|/*    Compare the string 's' to the list of legal moves available for the     opponent. If a match is found, make the move on the board.  */
block|{
specifier|static
name|short
name|pnt
decl_stmt|,
name|tempb
decl_stmt|,
name|tempc
decl_stmt|,
name|tempsf
decl_stmt|,
name|tempst
decl_stmt|,
name|cnt
decl_stmt|;
specifier|static
name|struct
name|leaf
name|xnode
decl_stmt|;
name|struct
name|leaf
modifier|*
name|node
decl_stmt|;
operator|*
name|mv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iop
operator|==
literal|2
condition|)
block|{
name|UnmakeMove
argument_list|(
name|opponent
argument_list|,
operator|&
name|xnode
argument_list|,
operator|&
name|tempb
argument_list|,
operator|&
name|tempc
argument_list|,
operator|&
name|tempsf
argument_list|,
operator|&
name|tempst
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
name|MoveList
argument_list|(
name|opponent
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|TrPnt
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
name|pnt
operator|<
name|TrPnt
index|[
literal|3
index|]
condition|)
block|{
name|node
operator|=
operator|&
name|Tree
index|[
name|pnt
operator|++
index|]
expr_stmt|;
name|algbr
argument_list|(
name|node
operator|->
name|f
argument_list|,
name|node
operator|->
name|t
argument_list|,
operator|(
name|short
operator|)
name|node
operator|->
name|flags
operator|&
name|cstlmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|mvstr1
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
name|mvstr2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|xnode
operator|=
operator|*
name|node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
block|{
name|MakeMove
argument_list|(
name|opponent
argument_list|,
operator|&
name|xnode
argument_list|,
operator|&
name|tempb
argument_list|,
operator|&
name|tempc
argument_list|,
operator|&
name|tempsf
argument_list|,
operator|&
name|tempst
argument_list|)
expr_stmt|;
if|if
condition|(
name|SqAtakd
argument_list|(
name|PieceList
index|[
name|opponent
index|]
index|[
literal|0
index|]
argument_list|,
name|computer
argument_list|)
condition|)
block|{
name|UnmakeMove
argument_list|(
name|opponent
argument_list|,
operator|&
name|xnode
argument_list|,
operator|&
name|tempb
argument_list|,
operator|&
name|tempc
argument_list|,
operator|&
name|tempsf
argument_list|,
operator|&
name|tempst
argument_list|)
expr_stmt|;
name|ShowMessage
argument_list|(
literal|"Illegal Move!!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|iop
operator|==
literal|1
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|xnode
operator|.
name|flags
operator|&
name|epmask
condition|)
name|UpdateDisplay
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|UpdateDisplay
argument_list|(
name|xnode
operator|.
name|f
argument_list|,
name|xnode
operator|.
name|t
argument_list|,
literal|0
argument_list|,
name|xnode
operator|.
name|flags
operator|&
name|cstlmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|xnode
operator|.
name|flags
operator|&
name|cstlmask
condition|)
name|Game50
operator|=
name|GameCnt
expr_stmt|;
elseif|else
if|if
condition|(
name|board
index|[
name|xnode
operator|.
name|t
index|]
operator|==
name|pawn
operator|||
operator|(
name|xnode
operator|.
name|flags
operator|&
name|capture
operator|)
condition|)
name|Game50
operator|=
name|GameCnt
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|depth
operator|=
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|score
operator|=
literal|0
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|nodes
operator|=
literal|0
expr_stmt|;
name|ElapsedTime
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|time
operator|=
operator|(
name|short
operator|)
name|et
expr_stmt|;
name|TimeControl
operator|.
name|clock
index|[
name|opponent
index|]
operator|-=
name|et
expr_stmt|;
operator|--
name|TimeControl
operator|.
name|moves
index|[
name|opponent
index|]
expr_stmt|;
operator|*
name|mv
operator|=
operator|(
name|xnode
operator|.
name|f
operator|<<
literal|8
operator|)
operator|+
name|xnode
operator|.
name|t
expr_stmt|;
name|algbr
argument_list|(
name|xnode
operator|.
name|f
argument_list|,
name|xnode
operator|.
name|t
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
name|ShowMessage
argument_list|(
literal|"Ambiguous Move!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_macro
name|NewGame
argument_list|()
end_macro

begin_comment
comment|/*    Reset the board and other variables to start a new game. */
end_comment

begin_block
block|{
name|short
name|l
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|,
name|p
decl_stmt|;
name|mate
operator|=
name|quit
operator|=
name|reverse
operator|=
name|bothsides
operator|=
name|post
operator|=
name|false
expr_stmt|;
name|hashflag
operator|=
name|force
operator|=
name|PawnStorm
operator|=
name|false
expr_stmt|;
name|beep
operator|=
name|rcptr
operator|=
name|easy
operator|=
name|true
expr_stmt|;
name|lpost
operator|=
name|NodeCnt
operator|=
name|epsquare
operator|=
name|et0
operator|=
literal|0
expr_stmt|;
name|dither
operator|=
literal|0
expr_stmt|;
name|Awindow
operator|=
literal|90
expr_stmt|;
name|Bwindow
operator|=
literal|90
expr_stmt|;
name|xwndw
operator|=
literal|90
expr_stmt|;
name|MaxSearchDepth
operator|=
literal|29
expr_stmt|;
name|contempt
operator|=
literal|0
expr_stmt|;
name|GameCnt
operator|=
operator|-
literal|1
expr_stmt|;
name|Game50
operator|=
literal|0
expr_stmt|;
name|Zwmtl
operator|=
name|Zbmtl
operator|=
literal|0
expr_stmt|;
name|Developed
index|[
name|white
index|]
operator|=
name|Developed
index|[
name|black
index|]
operator|=
name|false
expr_stmt|;
name|castld
index|[
name|white
index|]
operator|=
name|castld
index|[
name|black
index|]
operator|=
name|false
expr_stmt|;
name|kingmoved
index|[
name|white
index|]
operator|=
name|kingmoved
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|PawnThreat
index|[
literal|0
index|]
operator|=
name|CptrFlag
index|[
literal|0
index|]
operator|=
name|Threat
index|[
literal|0
index|]
operator|=
name|false
expr_stmt|;
name|Pscore
index|[
literal|0
index|]
operator|=
literal|12000
expr_stmt|;
name|Tscore
index|[
literal|0
index|]
operator|=
literal|12000
expr_stmt|;
name|opponent
operator|=
name|white
expr_stmt|;
name|computer
operator|=
name|black
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|8
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|++
control|)
block|{
name|l
operator|=
literal|8
operator|*
name|r
operator|+
name|c
expr_stmt|;
name|locn
index|[
name|r
index|]
index|[
name|c
index|]
operator|=
name|l
expr_stmt|;
name|row
index|[
name|l
index|]
operator|=
name|r
expr_stmt|;
name|column
index|[
name|l
index|]
operator|=
name|c
expr_stmt|;
name|board
index|[
name|l
index|]
operator|=
name|Stboard
index|[
name|l
index|]
expr_stmt|;
name|color
index|[
name|l
index|]
operator|=
name|Stcolor
index|[
name|l
index|]
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|white
init|;
name|c
operator|<=
name|black
condition|;
name|c
operator|++
control|)
for|for
control|(
name|p
operator|=
name|pawn
init|;
name|p
operator|<=
name|king
condition|;
name|p
operator|++
control|)
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
literal|64
condition|;
name|l
operator|++
control|)
block|{
name|hashcode
index|[
name|c
index|]
index|[
name|p
index|]
index|[
name|l
index|]
operator|.
name|key
operator|=
operator|(
name|unsigned
name|short
operator|)
name|rand
argument_list|()
expr_stmt|;
name|hashcode
index|[
name|c
index|]
index|[
name|p
index|]
index|[
name|l
index|]
operator|.
name|bd
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|rand
argument_list|()
operator|<<
literal|16
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|rand
argument_list|()
expr_stmt|;
block|}
name|ClrScreen
argument_list|()
expr_stmt|;
if|if
condition|(
name|TCflag
condition|)
name|SetTimeControl
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Level
operator|==
literal|0
condition|)
name|SelectLevel
argument_list|()
expr_stmt|;
name|UpdateDisplay
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|InitializeStats
argument_list|()
expr_stmt|;
name|time0
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ElapsedTime
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|GetOpenings
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|algbr
argument_list|(
argument|f
argument_list|,
argument|t
argument_list|,
argument|iscastle
argument_list|)
end_macro

begin_decl_stmt
name|short
name|f
decl_stmt|,
name|t
decl_stmt|,
name|iscastle
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mvstr1
index|[
literal|0
index|]
operator|=
name|cxx
index|[
name|column
index|[
name|f
index|]
index|]
expr_stmt|;
name|mvstr1
index|[
literal|1
index|]
operator|=
name|rxx
index|[
name|row
index|[
name|f
index|]
index|]
expr_stmt|;
name|mvstr1
index|[
literal|2
index|]
operator|=
name|cxx
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
name|mvstr1
index|[
literal|3
index|]
operator|=
name|rxx
index|[
name|row
index|[
name|t
index|]
index|]
expr_stmt|;
name|mvstr2
index|[
literal|0
index|]
operator|=
name|qxx
index|[
name|board
index|[
name|f
index|]
index|]
expr_stmt|;
name|mvstr2
index|[
literal|1
index|]
operator|=
name|mvstr1
index|[
literal|2
index|]
expr_stmt|;
name|mvstr2
index|[
literal|2
index|]
operator|=
name|mvstr1
index|[
literal|3
index|]
expr_stmt|;
name|mvstr1
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mvstr2
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|iscastle
condition|)
if|if
condition|(
name|t
operator|>
name|f
condition|)
name|strcpy
argument_list|(
name|mvstr2
argument_list|,
literal|"o-o"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mvstr2
argument_list|,
literal|"o-o-o"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ............    MOVE GENERATION& SEARCH ROUTINES    .............. */
end_comment

begin_macro
name|SelectMove
argument_list|(
argument|side
argument_list|,
argument|iop
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|iop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Select a move by calling function search() at progressively deeper     ply until time is up or a mate or draw is reached. An alpha-beta     window of -90 to +90 points is set around the score returned from the     previous iteration. If Sdepth != 0 then the program has correctly     predicted the opponents move and the search will start at a depth of     Sdepth+1 rather than a depth of 1.  */
end_comment

begin_block
block|{
specifier|static
name|short
name|i
decl_stmt|,
name|alpha
decl_stmt|,
name|beta
decl_stmt|,
name|score
decl_stmt|,
name|tempb
decl_stmt|,
name|tempc
decl_stmt|,
name|tempsf
decl_stmt|,
name|tempst
decl_stmt|,
name|xside
decl_stmt|,
name|rpt
decl_stmt|;
name|timeout
operator|=
name|false
expr_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
if|if
condition|(
name|iop
operator|!=
literal|2
condition|)
name|player
operator|=
name|side
expr_stmt|;
if|if
condition|(
name|TCflag
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|TimeControl
operator|.
name|moves
index|[
name|side
index|]
operator|+
literal|3
operator|)
operator|-
name|OperatorTime
operator|)
operator|!=
literal|0
condition|)
name|ResponseTime
operator|=
operator|(
name|TimeControl
operator|.
name|clock
index|[
name|side
index|]
operator|)
operator|/
operator|(
name|TimeControl
operator|.
name|moves
index|[
name|side
index|]
operator|+
literal|3
operator|)
operator|-
name|OperatorTime
expr_stmt|;
else|else
name|ResponseTime
operator|=
literal|0
expr_stmt|;
name|ResponseTime
operator|+=
operator|(
name|ResponseTime
operator|*
name|TimeControl
operator|.
name|moves
index|[
name|side
index|]
operator|)
operator|/
operator|(
literal|2
operator|*
name|TCmoves
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|ResponseTime
operator|=
name|Level
expr_stmt|;
if|if
condition|(
name|iop
operator|==
literal|2
condition|)
name|ResponseTime
operator|=
literal|999
expr_stmt|;
if|if
condition|(
name|Sdepth
operator|>
literal|0
operator|&&
name|root
operator|->
name|score
operator|>
name|Zscore
operator|-
name|zwndw
condition|)
name|ResponseTime
operator|-=
name|ft
expr_stmt|;
elseif|else
if|if
condition|(
name|ResponseTime
operator|<
literal|1
condition|)
name|ResponseTime
operator|=
literal|1
expr_stmt|;
name|ExtraTime
operator|=
literal|0
expr_stmt|;
name|ExaminePosition
argument_list|()
expr_stmt|;
name|ScorePosition
argument_list|(
name|side
argument_list|,
operator|&
name|score
argument_list|)
expr_stmt|;
name|ShowSidetomove
argument_list|()
expr_stmt|;
if|if
condition|(
name|Sdepth
operator|==
literal|0
condition|)
block|{
name|ZeroTTable
argument_list|()
expr_stmt|;
name|SearchStartStuff
argument_list|(
name|side
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8192
condition|;
name|i
operator|++
control|)
name|history
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|FROMsquare
operator|=
name|TOsquare
operator|=
operator|-
literal|1
expr_stmt|;
name|PV
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iop
operator|!=
literal|2
condition|)
name|hint
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxdepth
condition|;
name|i
operator|++
control|)
name|PrVar
index|[
name|i
index|]
operator|=
name|killr0
index|[
name|i
index|]
operator|=
name|killr1
index|[
name|i
index|]
operator|=
name|killr2
index|[
name|i
index|]
operator|=
name|killr3
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alpha
operator|=
name|score
operator|-
literal|90
expr_stmt|;
name|beta
operator|=
name|score
operator|+
literal|90
expr_stmt|;
name|rpt
operator|=
literal|0
expr_stmt|;
name|TrPnt
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|root
operator|=
operator|&
name|Tree
index|[
literal|0
index|]
expr_stmt|;
name|MoveList
argument_list|(
name|side
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TrPnt
index|[
literal|1
index|]
init|;
name|i
operator|<
name|TrPnt
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
name|pick
argument_list|(
name|i
argument_list|,
name|TrPnt
index|[
literal|2
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Book
operator|!=
name|NULL
condition|)
name|OpeningBook
argument_list|()
expr_stmt|;
if|if
condition|(
name|Book
operator|!=
name|NULL
condition|)
name|timeout
operator|=
name|true
expr_stmt|;
name|NodeCnt
operator|=
name|ETnodes
operator|=
name|EvalNodes
operator|=
name|HashCnt
operator|=
literal|0
expr_stmt|;
name|Zscore
operator|=
literal|0
expr_stmt|;
name|zwndw
operator|=
literal|20
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|timeout
operator|&&
name|Sdepth
operator|<
name|MaxSearchDepth
condition|)
block|{
name|Sdepth
operator|++
expr_stmt|;
name|ShowDepth
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|score
operator|=
name|search
argument_list|(
name|side
argument_list|,
literal|1
argument_list|,
name|Sdepth
argument_list|,
name|alpha
argument_list|,
name|beta
argument_list|,
name|PrVar
argument_list|,
operator|&
name|rpt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Sdepth
condition|;
name|i
operator|++
control|)
name|killr0
index|[
name|i
index|]
operator|=
name|PrVar
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|score
operator|<
name|alpha
condition|)
block|{
name|ShowDepth
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|ExtraTime
operator|=
literal|10
operator|*
name|ResponseTime
expr_stmt|;
name|ZeroTTable
argument_list|()
expr_stmt|;
name|score
operator|=
name|search
argument_list|(
name|side
argument_list|,
literal|1
argument_list|,
name|Sdepth
argument_list|,
operator|-
literal|9000
argument_list|,
name|beta
argument_list|,
name|PrVar
argument_list|,
operator|&
name|rpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|>
name|beta
operator|&&
operator|!
operator|(
name|root
operator|->
name|flags
operator|&
name|exact
operator|)
condition|)
block|{
name|ShowDepth
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|ExtraTime
operator|=
literal|0
expr_stmt|;
name|ZeroTTable
argument_list|()
expr_stmt|;
name|score
operator|=
name|search
argument_list|(
name|side
argument_list|,
literal|1
argument_list|,
name|Sdepth
argument_list|,
name|alpha
argument_list|,
literal|9000
argument_list|,
name|PrVar
argument_list|,
operator|&
name|rpt
argument_list|)
expr_stmt|;
block|}
name|score
operator|=
name|root
operator|->
name|score
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
for|for
control|(
name|i
operator|=
name|TrPnt
index|[
literal|1
index|]
operator|+
literal|1
init|;
name|i
operator|<
name|TrPnt
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
name|pick
argument_list|(
name|i
argument_list|,
name|TrPnt
index|[
literal|2
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ShowResults
argument_list|(
name|score
argument_list|,
name|PrVar
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Sdepth
condition|;
name|i
operator|++
control|)
name|killr0
index|[
name|i
index|]
operator|=
name|PrVar
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|Zscore
operator|-
name|zwndw
operator|&&
name|score
operator|>
name|Tree
index|[
literal|1
index|]
operator|.
name|score
operator|+
literal|250
condition|)
name|ExtraTime
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|score
operator|>
name|Zscore
operator|-
literal|3
operator|*
name|zwndw
condition|)
name|ExtraTime
operator|=
name|ResponseTime
expr_stmt|;
else|else
name|ExtraTime
operator|=
literal|3
operator|*
name|ResponseTime
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|flags
operator|&
name|exact
condition|)
name|timeout
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|Tree
index|[
literal|1
index|]
operator|.
name|score
operator|<
operator|-
literal|9000
condition|)
name|timeout
operator|=
name|true
expr_stmt|;
if|if
condition|(
literal|4
operator|*
name|et
operator|>
literal|2
operator|*
name|ResponseTime
operator|+
name|ExtraTime
condition|)
name|timeout
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|Tscore
index|[
literal|0
index|]
operator|=
name|score
expr_stmt|;
if|if
condition|(
name|Zscore
operator|==
literal|0
condition|)
name|Zscore
operator|=
name|score
expr_stmt|;
else|else
name|Zscore
operator|=
operator|(
name|Zscore
operator|+
name|score
operator|)
operator|/
literal|2
expr_stmt|;
block|}
name|zwndw
operator|=
literal|20
operator|+
name|abs
argument_list|(
name|Zscore
operator|/
literal|12
argument_list|)
expr_stmt|;
name|beta
operator|=
name|score
operator|+
name|Bwindow
expr_stmt|;
if|if
condition|(
name|Zscore
operator|<
name|score
condition|)
name|alpha
operator|=
name|Zscore
operator|-
name|Awindow
operator|-
name|zwndw
expr_stmt|;
else|else
name|alpha
operator|=
name|score
operator|-
name|Awindow
operator|-
name|zwndw
expr_stmt|;
block|}
name|score
operator|=
name|root
operator|->
name|score
expr_stmt|;
if|if
condition|(
name|rpt
operator|>=
literal|2
operator|||
name|score
operator|<
operator|-
literal|12000
condition|)
name|root
operator|->
name|flags
operator||=
name|draw
expr_stmt|;
if|if
condition|(
name|iop
operator|==
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|Book
operator|==
name|NULL
condition|)
name|hint
operator|=
name|PrVar
index|[
literal|2
index|]
expr_stmt|;
name|ElapsedTime
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|>
operator|-
literal|9999
operator|&&
name|rpt
operator|<=
literal|2
condition|)
block|{
name|MakeMove
argument_list|(
name|side
argument_list|,
name|root
argument_list|,
operator|&
name|tempb
argument_list|,
operator|&
name|tempc
argument_list|,
operator|&
name|tempsf
argument_list|,
operator|&
name|tempst
argument_list|)
expr_stmt|;
name|algbr
argument_list|(
name|root
operator|->
name|f
argument_list|,
name|root
operator|->
name|t
argument_list|,
operator|(
name|short
operator|)
name|root
operator|->
name|flags
operator|&
name|cstlmask
argument_list|)
expr_stmt|;
block|}
else|else
name|mvstr1
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|OutputMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|score
operator|==
operator|-
literal|9999
operator|||
name|score
operator|==
literal|9998
condition|)
name|mate
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mate
condition|)
name|hint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|flags
operator|&
name|cstlmask
condition|)
name|Game50
operator|=
name|GameCnt
expr_stmt|;
elseif|else
if|if
condition|(
name|board
index|[
name|root
operator|->
name|t
index|]
operator|==
name|pawn
operator|||
operator|(
name|root
operator|->
name|flags
operator|&
name|capture
operator|)
condition|)
name|Game50
operator|=
name|GameCnt
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|score
operator|=
name|score
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|nodes
operator|=
name|NodeCnt
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|time
operator|=
operator|(
name|short
operator|)
name|et
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|depth
operator|=
name|Sdepth
expr_stmt|;
if|if
condition|(
name|TCflag
condition|)
block|{
name|TimeControl
operator|.
name|clock
index|[
name|side
index|]
operator|-=
operator|(
name|et
operator|+
name|OperatorTime
operator|)
expr_stmt|;
if|if
condition|(
operator|--
name|TimeControl
operator|.
name|moves
index|[
name|side
index|]
operator|==
literal|0
condition|)
name|SetTimeControl
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|root
operator|->
name|flags
operator|&
name|draw
operator|)
operator|&&
name|bothsides
condition|)
name|quit
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|GameCnt
operator|>
literal|238
condition|)
name|quit
operator|=
name|true
expr_stmt|;
name|player
operator|=
name|xside
expr_stmt|;
name|Sdepth
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|OpeningBook
argument_list|()
end_macro

begin_comment
comment|/*    Go thru each of the opening lines of play and check for a match with     the current game listing. If a match occurs, generate a random number.     If this number is the largest generated so far then the next move in     this line becomes the current "candidate". After all lines are     checked, the candidate move is put at the top of the Tree[] array and     will be played by the program. Note that the program does not handle     book transpositions.  */
end_comment

begin_block
block|{
name|short
name|j
decl_stmt|,
name|pnt
decl_stmt|;
name|unsigned
name|short
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|unsigned
name|r
decl_stmt|,
name|r0
decl_stmt|;
name|struct
name|BookEntry
modifier|*
name|p
decl_stmt|;
name|srand
argument_list|(
operator|(
name|unsigned
operator|)
name|time0
argument_list|)
expr_stmt|;
name|r0
operator|=
name|m
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|Book
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|mp
operator|=
name|p
operator|->
name|mv
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|GameCnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|GameList
index|[
name|j
index|]
operator|.
name|gmove
operator|!=
operator|*
operator|(
name|mp
operator|++
operator|)
condition|)
break|break;
if|if
condition|(
name|j
operator|>
name|GameCnt
condition|)
if|if
condition|(
operator|(
name|r
operator|=
name|rand
argument_list|()
operator|)
operator|>
name|r0
condition|)
block|{
name|r0
operator|=
name|r
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|hint
operator|=
operator|*
operator|(
operator|++
name|mp
operator|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|pnt
operator|=
name|TrPnt
index|[
literal|1
index|]
init|;
name|pnt
operator|<
name|TrPnt
index|[
literal|2
index|]
condition|;
name|pnt
operator|++
control|)
if|if
condition|(
operator|(
name|Tree
index|[
name|pnt
index|]
operator|.
name|f
operator|<<
literal|8
operator|)
operator|+
name|Tree
index|[
name|pnt
index|]
operator|.
name|t
operator|==
name|m
condition|)
name|Tree
index|[
name|pnt
index|]
operator|.
name|score
operator|=
literal|0
expr_stmt|;
name|pick
argument_list|(
name|TrPnt
index|[
literal|1
index|]
argument_list|,
name|TrPnt
index|[
literal|2
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tree
index|[
name|TrPnt
index|[
literal|1
index|]
index|]
operator|.
name|score
operator|<
literal|0
condition|)
name|Book
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|UpdateSearchStatus
define|\
value|{\   if (post) ShowCurrentMove(pnt,node->f,node->t);\   if (pnt> TrPnt[1])\     {\       d = best-Zscore; e = best-node->score;\       if (best< alpha) ExtraTime = 10*ResponseTime;\       else if (d> -zwndw&& e> 4*zwndw) ExtraTime = -ResponseTime/3;\       else if (d> -zwndw) ExtraTime = 0;\       else if (d> -3*zwndw) ExtraTime = ResponseTime;\       else if (d> -9*zwndw) ExtraTime = 3*ResponseTime;\       else ExtraTime = 5*ResponseTime;\     }\ }
end_define

begin_function
name|int
name|search
parameter_list|(
name|side
parameter_list|,
name|ply
parameter_list|,
name|depth
parameter_list|,
name|alpha
parameter_list|,
name|beta
parameter_list|,
name|bstline
parameter_list|,
name|rpt
parameter_list|)
name|short
name|side
decl_stmt|,
name|ply
decl_stmt|,
name|depth
decl_stmt|,
name|alpha
decl_stmt|,
name|beta
decl_stmt|,
decl|*
name|rpt
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|short
name|bstline
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Perform an alpha-beta search to determine the score for the current     board position. If depth<= 0 only capturing moves, pawn promotions     and responses to check are generated and searched, otherwise all     moves are processed. The search depth is modified for check evasions,     certain re-captures and threats. Extensions may continue for up to 11     ply beyond the nominal search depth.  */
end_comment

begin_define
define|#
directive|define
name|prune
value|(cf&& score+node->score< alpha)
end_define

begin_define
define|#
directive|define
name|ReCapture
value|(rcptr&& score> alpha&& score< beta&&\                    ply> 2&& CptrFlag[ply-1]&& CptrFlag[ply-2])
end_define

begin_define
define|#
directive|define
name|MateThreat
value|(ply< Sdepth+4&& ply> 4&&\                     ChkFlag[ply-2]&& ChkFlag[ply-4]&&\                     ChkFlag[ply-2] != ChkFlag[ply-4])
end_define

begin_block
block|{
specifier|register
name|short
name|j
decl_stmt|,
name|pnt
decl_stmt|;
name|short
name|best
decl_stmt|,
name|tempb
decl_stmt|,
name|tempc
decl_stmt|,
name|tempsf
decl_stmt|,
name|tempst
decl_stmt|;
name|short
name|xside
decl_stmt|,
name|pbst
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|cf
decl_stmt|,
name|score
decl_stmt|,
name|rcnt
decl_stmt|;
name|unsigned
name|short
name|mv
decl_stmt|,
name|nxtline
index|[
name|maxdepth
index|]
decl_stmt|;
name|struct
name|leaf
modifier|*
name|node
decl_stmt|,
name|tmp
decl_stmt|;
name|NodeCnt
operator|++
expr_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
name|depth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ply
operator|<=
name|Sdepth
operator|+
literal|3
condition|)
name|repetition
argument_list|(
name|rpt
argument_list|)
expr_stmt|;
else|else
operator|*
name|rpt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|rpt
operator|>=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|score
operator|=
name|evaluate
argument_list|(
name|side
argument_list|,
name|xside
argument_list|,
name|ply
argument_list|,
name|alpha
argument_list|,
name|beta
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|>
literal|9000
condition|)
block|{
name|bstline
index|[
name|ply
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|score
operator|)
return|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|InChk
operator|||
name|PawnThreat
index|[
name|ply
operator|-
literal|1
index|]
operator|||
name|ReCapture
condition|)
operator|++
name|depth
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|score
operator|>=
name|alpha
operator|&&
operator|(
name|InChk
operator|||
name|PawnThreat
index|[
name|ply
operator|-
literal|1
index|]
operator|||
name|Threat
index|[
name|ply
operator|-
literal|1
index|]
operator|)
condition|)
operator|++
name|depth
expr_stmt|;
elseif|else
if|if
condition|(
name|score
operator|<=
name|beta
operator|&&
name|MateThreat
condition|)
operator|++
name|depth
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|hashflag
operator|&&
name|ply
operator|>
literal|1
condition|)
block|{
name|ProbeTTable
argument_list|(
name|side
argument_list|,
name|depth
argument_list|,
operator|&
name|alpha
argument_list|,
operator|&
name|beta
argument_list|,
operator|&
name|score
argument_list|)
expr_stmt|;
name|bstline
index|[
name|ply
index|]
operator|=
name|PV
expr_stmt|;
name|bstline
index|[
name|ply
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|beta
operator|==
operator|-
literal|20000
condition|)
return|return
operator|(
name|score
operator|)
return|;
if|if
condition|(
name|alpha
operator|>
name|beta
condition|)
return|return
operator|(
name|alpha
operator|)
return|;
block|}
if|if
condition|(
name|Sdepth
operator|==
literal|1
condition|)
name|d
operator|=
literal|7
expr_stmt|;
else|else
name|d
operator|=
literal|11
expr_stmt|;
if|if
condition|(
name|ply
operator|>
name|Sdepth
operator|+
name|d
operator|||
operator|(
name|depth
operator|<
literal|1
operator|&&
name|score
operator|>
name|beta
operator|)
condition|)
return|return
operator|(
name|score
operator|)
return|;
if|if
condition|(
name|ply
operator|>
literal|1
condition|)
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|MoveList
argument_list|(
name|side
argument_list|,
name|ply
argument_list|)
expr_stmt|;
else|else
name|CaptureList
argument_list|(
name|side
argument_list|,
name|xside
argument_list|,
name|ply
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrPnt
index|[
name|ply
index|]
operator|==
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
condition|)
return|return
operator|(
name|score
operator|)
return|;
name|cf
operator|=
operator|(
name|depth
operator|<
literal|1
operator|&&
name|ply
operator|>
name|Sdepth
operator|+
literal|1
operator|&&
operator|!
name|ChkFlag
index|[
name|ply
operator|-
literal|2
index|]
operator|&&
operator|!
name|slk
operator|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|best
operator|=
operator|-
literal|12000
expr_stmt|;
else|else
name|best
operator|=
name|score
expr_stmt|;
if|if
condition|(
name|best
operator|>
name|alpha
condition|)
name|alpha
operator|=
name|best
expr_stmt|;
for|for
control|(
name|pnt
operator|=
name|pbst
operator|=
name|TrPnt
index|[
name|ply
index|]
init|;
name|pnt
operator|<
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
operator|&&
name|best
operator|<=
name|beta
condition|;
name|pnt
operator|++
control|)
block|{
if|if
condition|(
name|ply
operator|>
literal|1
condition|)
name|pick
argument_list|(
name|pnt
argument_list|,
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|node
operator|=
operator|&
name|Tree
index|[
name|pnt
index|]
expr_stmt|;
name|mv
operator|=
operator|(
name|node
operator|->
name|f
operator|<<
literal|8
operator|)
operator|+
name|node
operator|->
name|t
expr_stmt|;
name|nxtline
index|[
name|ply
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prune
condition|)
break|break;
if|if
condition|(
name|ply
operator|==
literal|1
condition|)
name|UpdateSearchStatus
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|exact
operator|)
condition|)
block|{
name|MakeMove
argument_list|(
name|side
argument_list|,
name|node
argument_list|,
operator|&
name|tempb
argument_list|,
operator|&
name|tempc
argument_list|,
operator|&
name|tempsf
argument_list|,
operator|&
name|tempst
argument_list|)
expr_stmt|;
name|CptrFlag
index|[
name|ply
index|]
operator|=
operator|(
name|node
operator|->
name|flags
operator|&
name|capture
operator|)
expr_stmt|;
name|PawnThreat
index|[
name|ply
index|]
operator|=
operator|(
name|node
operator|->
name|flags
operator|&
name|pwnthrt
operator|)
expr_stmt|;
name|Tscore
index|[
name|ply
index|]
operator|=
name|node
operator|->
name|score
expr_stmt|;
name|PV
operator|=
name|node
operator|->
name|reply
expr_stmt|;
name|node
operator|->
name|score
operator|=
operator|-
name|search
argument_list|(
name|xside
argument_list|,
name|ply
operator|+
literal|1
argument_list|,
name|depth
operator|-
literal|1
argument_list|,
operator|-
name|beta
argument_list|,
operator|-
name|alpha
argument_list|,
name|nxtline
argument_list|,
operator|&
name|rcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|node
operator|->
name|score
argument_list|)
operator|>
literal|9000
condition|)
name|node
operator|->
name|flags
operator||=
name|exact
expr_stmt|;
elseif|else
if|if
condition|(
name|rcnt
operator|==
literal|1
condition|)
name|node
operator|->
name|score
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|rcnt
operator|>=
literal|2
operator|||
name|GameCnt
operator|-
name|Game50
operator|>
literal|99
operator|||
operator|(
name|node
operator|->
name|score
operator|==
literal|9999
operator|-
name|ply
operator|&&
operator|!
name|ChkFlag
index|[
name|ply
index|]
operator|)
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|draw
expr_stmt|;
name|node
operator|->
name|flags
operator||=
name|exact
expr_stmt|;
if|if
condition|(
name|side
operator|==
name|computer
condition|)
name|node
operator|->
name|score
operator|=
name|contempt
expr_stmt|;
else|else
name|node
operator|->
name|score
operator|=
operator|-
name|contempt
expr_stmt|;
block|}
name|node
operator|->
name|reply
operator|=
name|nxtline
index|[
name|ply
operator|+
literal|1
index|]
expr_stmt|;
name|UnmakeMove
argument_list|(
name|side
argument_list|,
name|node
argument_list|,
operator|&
name|tempb
argument_list|,
operator|&
name|tempc
argument_list|,
operator|&
name|tempsf
argument_list|,
operator|&
name|tempst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|score
operator|>
name|best
operator|&&
operator|!
name|timeout
condition|)
block|{
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
if|if
condition|(
name|node
operator|->
name|score
operator|>
name|alpha
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|exact
operator|)
condition|)
name|node
operator|->
name|score
operator|+=
name|depth
expr_stmt|;
name|best
operator|=
name|node
operator|->
name|score
expr_stmt|;
name|pbst
operator|=
name|pnt
expr_stmt|;
if|if
condition|(
name|best
operator|>
name|alpha
condition|)
name|alpha
operator|=
name|best
expr_stmt|;
for|for
control|(
name|j
operator|=
name|ply
operator|+
literal|1
init|;
name|nxtline
index|[
name|j
index|]
operator|>
literal|0
condition|;
name|j
operator|++
control|)
name|bstline
index|[
name|j
index|]
operator|=
name|nxtline
index|[
name|j
index|]
expr_stmt|;
name|bstline
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|bstline
index|[
name|ply
index|]
operator|=
name|mv
expr_stmt|;
if|if
condition|(
name|ply
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|best
operator|==
name|alpha
condition|)
block|{
name|tmp
operator|=
name|Tree
index|[
name|pnt
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|pnt
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|Tree
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|Tree
index|[
name|j
index|]
expr_stmt|;
name|Tree
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|pbst
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|Sdepth
operator|>
literal|2
condition|)
if|if
condition|(
name|best
operator|>
name|beta
condition|)
name|ShowResults
argument_list|(
name|best
argument_list|,
name|bstline
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|<
name|alpha
condition|)
name|ShowResults
argument_list|(
name|best
argument_list|,
name|bstline
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
else|else
name|ShowResults
argument_list|(
name|best
argument_list|,
name|bstline
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NodeCnt
operator|>
name|ETnodes
condition|)
name|ElapsedTime
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
return|return
operator|(
operator|-
name|Tscore
index|[
name|ply
operator|-
literal|1
index|]
operator|)
return|;
block|}
name|node
operator|=
operator|&
name|Tree
index|[
name|pbst
index|]
expr_stmt|;
name|mv
operator|=
operator|(
name|node
operator|->
name|f
operator|<<
literal|8
operator|)
operator|+
name|node
operator|->
name|t
expr_stmt|;
if|if
condition|(
name|hashflag
operator|&&
name|ply
operator|<=
name|Sdepth
operator|&&
operator|*
name|rpt
operator|==
literal|0
operator|&&
name|best
operator|==
name|alpha
condition|)
name|PutInTTable
argument_list|(
name|side
argument_list|,
name|best
argument_list|,
name|depth
argument_list|,
name|alpha
argument_list|,
name|beta
argument_list|,
name|mv
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|j
operator|=
operator|(
name|node
operator|->
name|f
operator|<<
literal|6
operator|)
operator|+
name|node
operator|->
name|t
expr_stmt|;
if|if
condition|(
name|side
operator|==
name|black
condition|)
name|j
operator||=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|history
index|[
name|j
index|]
operator|<
literal|150
condition|)
name|history
index|[
name|j
index|]
operator|+=
literal|2
operator|*
name|depth
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|t
operator|!=
operator|(
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|gmove
operator|&
literal|0xFF
operator|)
condition|)
if|if
condition|(
name|best
operator|<=
name|beta
condition|)
name|killr3
index|[
name|ply
index|]
operator|=
name|mv
expr_stmt|;
elseif|else
if|if
condition|(
name|mv
operator|!=
name|killr1
index|[
name|ply
index|]
condition|)
block|{
name|killr2
index|[
name|ply
index|]
operator|=
name|killr1
index|[
name|ply
index|]
expr_stmt|;
name|killr1
index|[
name|ply
index|]
operator|=
name|mv
expr_stmt|;
block|}
if|if
condition|(
name|best
operator|>
literal|9000
condition|)
name|killr0
index|[
name|ply
index|]
operator|=
name|mv
expr_stmt|;
else|else
name|killr0
index|[
name|ply
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|best
operator|)
return|;
block|}
end_block

begin_macro
name|evaluate
argument_list|(
argument|side
argument_list|,
argument|xside
argument_list|,
argument|ply
argument_list|,
argument|alpha
argument_list|,
argument|beta
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|xside
decl_stmt|,
name|ply
decl_stmt|,
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Compute an estimate of the score by adding the positional score from     the previous ply to the material difference. If this score falls     inside a window which is 180 points wider than the alpha-beta window     (or within a 50 point window during quiescence search) call     ScorePosition() to determine a score, otherwise return the estimated     score. If one side has only a king and the other either has no pawns     or no pieces then the function ScoreLoneKing() is called.  */
end_comment

begin_block
block|{
name|short
name|s
decl_stmt|,
name|evflag
decl_stmt|;
name|hung
index|[
name|white
index|]
operator|=
name|hung
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|slk
operator|=
operator|(
operator|(
name|mtl
index|[
name|white
index|]
operator|==
name|valueK
operator|&&
operator|(
name|pmtl
index|[
name|black
index|]
operator|==
literal|0
operator|||
name|emtl
index|[
name|black
index|]
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|mtl
index|[
name|black
index|]
operator|==
name|valueK
operator|&&
operator|(
name|pmtl
index|[
name|white
index|]
operator|==
literal|0
operator|||
name|emtl
index|[
name|white
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|-
name|Pscore
index|[
name|ply
operator|-
literal|1
index|]
operator|+
name|mtl
index|[
name|side
index|]
operator|-
name|mtl
index|[
name|xside
index|]
expr_stmt|;
name|s
operator|-=
name|INCscore
expr_stmt|;
if|if
condition|(
name|slk
condition|)
name|evflag
operator|=
name|false
expr_stmt|;
else|else
name|evflag
operator|=
operator|(
name|ply
operator|==
literal|1
operator|||
name|ply
operator|<
name|Sdepth
operator|||
operator|(
operator|(
name|ply
operator|==
name|Sdepth
operator|+
literal|1
operator|||
name|ply
operator|==
name|Sdepth
operator|+
literal|2
operator|)
operator|&&
operator|(
name|s
operator|>
name|alpha
operator|-
name|xwndw
operator|&&
name|s
operator|<
name|beta
operator|+
name|xwndw
operator|)
operator|)
operator|||
operator|(
name|ply
operator|>
name|Sdepth
operator|+
literal|2
operator|&&
name|s
operator|>=
name|alpha
operator|-
literal|25
operator|&&
name|s
operator|<=
name|beta
operator|+
literal|25
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|evflag
condition|)
block|{
name|EvalNodes
operator|++
expr_stmt|;
name|ataks
argument_list|(
name|side
argument_list|,
name|atak
index|[
name|side
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|atak
index|[
name|side
index|]
index|[
name|PieceList
index|[
name|xside
index|]
index|[
literal|0
index|]
index|]
operator|>
literal|0
condition|)
return|return
operator|(
literal|10001
operator|-
name|ply
operator|)
return|;
name|ataks
argument_list|(
name|xside
argument_list|,
name|atak
index|[
name|xside
index|]
argument_list|)
expr_stmt|;
name|InChk
operator|=
operator|(
name|atak
index|[
name|xside
index|]
index|[
name|PieceList
index|[
name|side
index|]
index|[
literal|0
index|]
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|ScorePosition
argument_list|(
name|side
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SqAtakd
argument_list|(
name|PieceList
index|[
name|xside
index|]
index|[
literal|0
index|]
argument_list|,
name|side
argument_list|)
condition|)
return|return
operator|(
literal|10001
operator|-
name|ply
operator|)
return|;
name|InChk
operator|=
name|SqAtakd
argument_list|(
name|PieceList
index|[
name|side
index|]
index|[
literal|0
index|]
argument_list|,
name|xside
argument_list|)
expr_stmt|;
if|if
condition|(
name|slk
condition|)
name|ScoreLoneKing
argument_list|(
name|side
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|Pscore
index|[
name|ply
index|]
operator|=
name|s
operator|-
name|mtl
index|[
name|side
index|]
operator|+
name|mtl
index|[
name|xside
index|]
expr_stmt|;
if|if
condition|(
name|InChk
condition|)
name|ChkFlag
index|[
name|ply
operator|-
literal|1
index|]
operator|=
name|Pindex
index|[
name|TOsquare
index|]
expr_stmt|;
else|else
name|ChkFlag
index|[
name|ply
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|Threat
index|[
name|ply
operator|-
literal|1
index|]
operator|=
operator|(
name|hung
index|[
name|side
index|]
operator|>
literal|1
operator|&&
name|ply
operator|==
name|Sdepth
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|ProbeTTable
argument_list|(
argument|side
argument_list|,
argument|depth
argument_list|,
argument|alpha
argument_list|,
argument|beta
argument_list|,
argument|score
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|depth
decl_stmt|,
modifier|*
name|alpha
decl_stmt|,
modifier|*
name|beta
decl_stmt|,
modifier|*
name|score
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     Look for the current board position in the transposition table. */
end_comment

begin_block
block|{
name|short
name|hindx
decl_stmt|;
if|if
condition|(
name|side
operator|==
name|white
condition|)
name|hashkey
operator||=
literal|1
expr_stmt|;
else|else
name|hashkey
operator|&=
literal|0xFFFE
expr_stmt|;
name|hindx
operator|=
operator|(
name|hashkey
operator|&
operator|(
name|ttblsz
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ptbl
operator|=
operator|(
name|ttable
operator|+
name|hindx
operator|)
expr_stmt|;
if|if
condition|(
name|ptbl
operator|->
name|depth
operator|>=
name|depth
operator|&&
name|ptbl
operator|->
name|hashbd
operator|==
name|hashbd
condition|)
block|{
name|HashCnt
operator|++
expr_stmt|;
name|PV
operator|=
name|ptbl
operator|->
name|mv
expr_stmt|;
if|if
condition|(
name|ptbl
operator|->
name|flags
operator|&
name|truescore
condition|)
block|{
operator|*
name|score
operator|=
name|ptbl
operator|->
name|score
expr_stmt|;
operator|*
name|beta
operator|=
operator|-
literal|20000
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/*       else if (ptbl->flags& upperbound)         {           if (ptbl->score< *beta) *beta = ptbl->score+1;         } */
elseif|else
if|if
condition|(
name|ptbl
operator|->
name|flags
operator|&
name|lowerbound
condition|)
block|{
if|if
condition|(
name|ptbl
operator|->
name|score
operator|>
operator|*
name|alpha
condition|)
operator|*
name|alpha
operator|=
name|ptbl
operator|->
name|score
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_block

begin_macro
name|PutInTTable
argument_list|(
argument|side
argument_list|,
argument|score
argument_list|,
argument|depth
argument_list|,
argument|alpha
argument_list|,
argument|beta
argument_list|,
argument|mv
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|score
decl_stmt|,
name|depth
decl_stmt|,
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|mv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Store the current board position in the transposition table. */
end_comment

begin_block
block|{
name|short
name|hindx
decl_stmt|;
if|if
condition|(
name|side
operator|==
name|white
condition|)
name|hashkey
operator||=
literal|1
expr_stmt|;
else|else
name|hashkey
operator|&=
literal|0xFFFE
expr_stmt|;
name|hindx
operator|=
operator|(
name|hashkey
operator|&
operator|(
name|ttblsz
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ptbl
operator|=
operator|(
name|ttable
operator|+
name|hindx
operator|)
expr_stmt|;
name|ptbl
operator|->
name|hashbd
operator|=
name|hashbd
expr_stmt|;
name|ptbl
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|ptbl
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|ptbl
operator|->
name|mv
operator|=
name|mv
expr_stmt|;
name|ptbl
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|score
operator|<
name|alpha
condition|)
name|ptbl
operator|->
name|flags
operator||=
name|upperbound
expr_stmt|;
elseif|else
if|if
condition|(
name|score
operator|>
name|beta
condition|)
name|ptbl
operator|->
name|flags
operator||=
name|lowerbound
expr_stmt|;
else|else
name|ptbl
operator|->
name|flags
operator||=
name|truescore
expr_stmt|;
block|}
end_block

begin_macro
name|ZeroTTable
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hashflag
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ttblsz
condition|;
name|i
operator|++
control|)
block|{
name|ptbl
operator|=
operator|(
name|ttable
operator|+
name|i
operator|)
expr_stmt|;
name|ptbl
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|MoveList
argument_list|(
argument|side
argument_list|,
argument|ply
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|ply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Fill the array Tree[] with all available moves for side to play. Array     TrPnt[ply] contains the index into Tree[] of the first move at a ply.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|i
decl_stmt|;
name|short
name|xside
decl_stmt|,
name|f
decl_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
if|if
condition|(
name|PV
operator|==
literal|0
condition|)
name|Swag0
operator|=
name|killr0
index|[
name|ply
index|]
expr_stmt|;
else|else
name|Swag0
operator|=
name|PV
expr_stmt|;
name|Swag1
operator|=
name|killr1
index|[
name|ply
index|]
expr_stmt|;
name|Swag2
operator|=
name|killr2
index|[
name|ply
index|]
expr_stmt|;
name|Swag3
operator|=
name|killr3
index|[
name|ply
index|]
expr_stmt|;
name|Swag4
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ply
operator|>
literal|2
condition|)
name|Swag4
operator|=
name|killr1
index|[
name|ply
operator|-
literal|2
index|]
expr_stmt|;
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
operator|=
name|TrPnt
index|[
name|ply
index|]
expr_stmt|;
name|Dstart
index|[
name|pawn
index|]
operator|=
name|Dpwn
index|[
name|side
index|]
expr_stmt|;
name|Dstop
index|[
name|pawn
index|]
operator|=
name|Dstart
index|[
name|pawn
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PieceCnt
index|[
name|side
index|]
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|GenMoves
argument_list|(
name|ply
argument_list|,
name|PieceList
index|[
name|side
index|]
index|[
name|i
index|]
argument_list|,
name|side
argument_list|,
name|xside
argument_list|)
expr_stmt|;
if|if
condition|(
name|kingmoved
index|[
name|side
index|]
operator|==
literal|0
operator|&&
operator|!
name|castld
index|[
name|side
index|]
condition|)
block|{
name|f
operator|=
name|PieceList
index|[
name|side
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|castle
argument_list|(
name|side
argument_list|,
name|f
argument_list|,
name|f
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|f
argument_list|,
name|f
operator|+
literal|2
argument_list|,
name|xside
argument_list|)
expr_stmt|;
name|Tree
index|[
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
operator|-
literal|1
index|]
operator|.
name|flags
operator||=
name|cstlmask
expr_stmt|;
block|}
if|if
condition|(
name|castle
argument_list|(
name|side
argument_list|,
name|f
argument_list|,
name|f
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|f
argument_list|,
name|f
operator|-
literal|2
argument_list|,
name|xside
argument_list|)
expr_stmt|;
name|Tree
index|[
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
operator|-
literal|1
index|]
operator|.
name|flags
operator||=
name|cstlmask
expr_stmt|;
block|}
block|}
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|11
operator|)
end_if

begin_macro
name|GenMoves
argument_list|(
argument|ply
argument_list|,
argument|sq
argument_list|,
argument|side
argument_list|,
argument|xside
argument_list|)
end_macro

begin_decl_stmt
name|short
name|ply
decl_stmt|,
name|sq
decl_stmt|,
name|side
decl_stmt|,
name|xside
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Generate moves for a piece. The from square is mapped onto a special      board and offsets (taken from array Dir[]) are added to the mapped     location. The newly generated square is tested to see if it falls off     the board by ANDing the square with 88 HEX. Legal moves are linked     into the tree.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|m
decl_stmt|,
name|u
decl_stmt|,
name|d
decl_stmt|;
name|short
name|i
decl_stmt|,
name|m0
decl_stmt|,
name|piece
decl_stmt|;
name|piece
operator|=
name|board
index|[
name|sq
index|]
expr_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|sweep
index|[
name|piece
index|]
condition|)
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|piece
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|piece
index|]
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|Dir
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|neutral
condition|)
block|{
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|u
argument_list|,
name|xside
argument_list|)
expr_stmt|;
name|m
operator|+=
name|d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|xside
condition|)
block|{
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|u
argument_list|,
name|xside
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|pawn
condition|)
block|{
if|if
condition|(
name|side
operator|==
name|white
operator|&&
name|color
index|[
name|sq
operator|+
literal|8
index|]
operator|==
name|neutral
condition|)
block|{
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|sq
operator|+
literal|8
argument_list|,
name|xside
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
index|[
name|sq
index|]
operator|==
literal|1
condition|)
if|if
condition|(
name|color
index|[
name|sq
operator|+
literal|16
index|]
operator|==
name|neutral
condition|)
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|sq
operator|+
literal|16
argument_list|,
name|xside
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|side
operator|==
name|black
operator|&&
name|color
index|[
name|sq
operator|-
literal|8
index|]
operator|==
name|neutral
condition|)
block|{
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|sq
operator|-
literal|8
argument_list|,
name|xside
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
index|[
name|sq
index|]
operator|==
literal|6
condition|)
if|if
condition|(
name|color
index|[
name|sq
operator|-
literal|16
index|]
operator|==
name|neutral
condition|)
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|sq
operator|-
literal|16
argument_list|,
name|xside
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|piece
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|piece
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|i
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|xside
operator|||
name|u
operator|==
name|epsquare
condition|)
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|u
argument_list|,
name|xside
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|piece
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|piece
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|i
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|!=
name|side
condition|)
name|LinkMove
argument_list|(
name|ply
argument_list|,
name|sq
argument_list|,
name|u
argument_list|,
name|xside
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|LinkMove
argument_list|(
argument|ply
argument_list|,
argument|f
argument_list|,
argument|t
argument_list|,
argument|xside
argument_list|)
end_macro

begin_decl_stmt
name|short
name|ply
decl_stmt|,
name|f
decl_stmt|,
name|t
decl_stmt|,
name|xside
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Add a move to the tree.  Assign a bonus to order the moves    as follows:      1. Principle variation      2. Capture of last moved piece      3. Other captures (major pieces first)      4. Killer moves      5. "history" killers     */
end_comment

begin_block
block|{
specifier|register
name|short
name|s
decl_stmt|,
name|z
decl_stmt|;
name|unsigned
name|short
name|mv
decl_stmt|;
name|struct
name|leaf
modifier|*
name|node
decl_stmt|;
name|node
operator|=
operator|&
name|Tree
index|[
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
index|]
expr_stmt|;
operator|++
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
expr_stmt|;
name|node
operator|->
name|flags
operator|=
name|node
operator|->
name|reply
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|node
operator|->
name|t
operator|=
name|t
expr_stmt|;
name|mv
operator|=
operator|(
name|f
operator|<<
literal|8
operator|)
operator|+
name|t
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mv
operator|==
name|Swag0
condition|)
name|s
operator|=
literal|2000
expr_stmt|;
elseif|else
if|if
condition|(
name|mv
operator|==
name|Swag1
condition|)
name|s
operator|=
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|mv
operator|==
name|Swag2
condition|)
name|s
operator|=
literal|50
expr_stmt|;
elseif|else
if|if
condition|(
name|mv
operator|==
name|Swag3
condition|)
name|s
operator|=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
name|mv
operator|==
name|Swag4
condition|)
name|s
operator|=
literal|30
expr_stmt|;
if|if
condition|(
name|color
index|[
name|t
index|]
operator|!=
name|neutral
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|capture
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TOsquare
condition|)
name|s
operator|+=
literal|500
expr_stmt|;
name|s
operator|+=
name|value
index|[
name|board
index|[
name|t
index|]
index|]
operator|-
name|board
index|[
name|f
index|]
expr_stmt|;
block|}
if|if
condition|(
name|board
index|[
name|f
index|]
operator|==
name|pawn
condition|)
if|if
condition|(
name|row
index|[
name|t
index|]
operator|==
literal|0
operator|||
name|row
index|[
name|t
index|]
operator|==
literal|7
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|promote
expr_stmt|;
name|s
operator|+=
literal|800
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row
index|[
name|t
index|]
operator|==
literal|1
operator|||
name|row
index|[
name|t
index|]
operator|==
literal|6
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|pwnthrt
expr_stmt|;
name|s
operator|+=
literal|600
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|epsquare
condition|)
name|node
operator|->
name|flags
operator||=
name|epmask
expr_stmt|;
name|z
operator|=
operator|(
name|f
operator|<<
literal|6
operator|)
operator|+
name|t
expr_stmt|;
if|if
condition|(
name|xside
operator|==
name|white
condition|)
name|z
operator||=
literal|0x1000
expr_stmt|;
name|s
operator|+=
name|history
index|[
name|z
index|]
expr_stmt|;
name|node
operator|->
name|score
operator|=
name|s
operator|-
literal|20000
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|10
operator|)
end_if

begin_macro
name|CaptureList
argument_list|(
argument|side
argument_list|,
argument|xside
argument_list|,
argument|ply
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|xside
decl_stmt|,
name|ply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     Generate captures and Pawn promotions only. */
end_comment

begin_define
define|#
directive|define
name|LinkCapture
define|\
value|{\   node->f = sq; node->t = u;\   node->reply = 0;\   node->flags = capture;\   node->score = value[board[u]] + svalue[board[u]] - piece;\   if (piece == pawn&& (u< 8 || u> 55))\     {\       node->flags |= promote;\       node->score = valueQ;\     }\   ++node;\   ++TrPnt[ply+1];\ }
end_define

begin_block
block|{
specifier|register
name|short
name|m
decl_stmt|,
name|u
decl_stmt|;
name|short
name|d
decl_stmt|,
name|sq
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|j1
decl_stmt|,
name|j2
decl_stmt|,
name|m0
decl_stmt|,
name|r7
decl_stmt|,
name|d0
decl_stmt|,
name|piece
decl_stmt|,
modifier|*
name|PL
decl_stmt|;
name|struct
name|leaf
modifier|*
name|node
decl_stmt|;
name|TrPnt
index|[
name|ply
operator|+
literal|1
index|]
operator|=
name|TrPnt
index|[
name|ply
index|]
expr_stmt|;
name|node
operator|=
operator|&
name|Tree
index|[
name|TrPnt
index|[
name|ply
index|]
index|]
expr_stmt|;
name|Dstart
index|[
name|pawn
index|]
operator|=
name|Dpwn
index|[
name|side
index|]
expr_stmt|;
name|Dstop
index|[
name|pawn
index|]
operator|=
name|Dstart
index|[
name|pawn
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|side
operator|==
name|white
condition|)
block|{
name|r7
operator|=
literal|6
expr_stmt|;
name|d0
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|r7
operator|=
literal|1
expr_stmt|;
name|d0
operator|=
operator|-
literal|8
expr_stmt|;
block|}
name|PL
operator|=
name|PieceList
index|[
name|side
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|side
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sq
operator|=
name|PL
index|[
name|i
index|]
expr_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
name|piece
operator|=
name|board
index|[
name|sq
index|]
expr_stmt|;
name|j1
operator|=
name|Dstart
index|[
name|piece
index|]
expr_stmt|;
name|j2
operator|=
name|Dstop
index|[
name|piece
index|]
expr_stmt|;
if|if
condition|(
name|sweep
index|[
name|piece
index|]
condition|)
for|for
control|(
name|j
operator|=
name|j1
init|;
name|j
operator|<=
name|j2
condition|;
name|j
operator|++
control|)
block|{
name|d
operator|=
name|Dir
index|[
name|j
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|neutral
condition|)
name|m
operator|+=
name|d
expr_stmt|;
else|else
block|{
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|xside
condition|)
name|LinkCapture
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|j1
init|;
name|j
operator|<=
name|j2
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|j
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|xside
condition|)
name|LinkCapture
expr_stmt|;
block|}
if|if
condition|(
name|piece
operator|==
name|pawn
operator|&&
name|row
index|[
name|sq
index|]
operator|==
name|r7
condition|)
block|{
name|u
operator|=
name|sq
operator|+
name|d0
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|neutral
condition|)
name|LinkCapture
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|castle
parameter_list|(
name|side
parameter_list|,
name|kf
parameter_list|,
name|kt
parameter_list|,
name|iop
parameter_list|)
name|short
name|side
decl_stmt|,
name|kf
decl_stmt|,
name|kt
decl_stmt|,
name|iop
decl_stmt|;
comment|/*    Make or Unmake a castling move. */
block|{
name|short
name|rf
decl_stmt|,
name|rt
decl_stmt|,
name|d
decl_stmt|,
name|t0
decl_stmt|,
name|xside
decl_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
if|if
condition|(
name|kt
operator|>
name|kf
condition|)
block|{
name|rf
operator|=
name|kf
operator|+
literal|3
expr_stmt|;
name|rt
operator|=
name|kt
operator|-
literal|1
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rf
operator|=
name|kf
operator|-
literal|4
expr_stmt|;
name|rt
operator|=
name|kt
operator|+
literal|1
expr_stmt|;
name|d
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|board
index|[
name|kf
index|]
operator|!=
name|king
operator|||
name|board
index|[
name|rf
index|]
operator|!=
name|rook
operator|||
name|color
index|[
name|rf
index|]
operator|!=
name|side
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|color
index|[
name|kt
index|]
operator|!=
name|neutral
operator|||
name|color
index|[
name|rt
index|]
operator|!=
name|neutral
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|d
operator|==
operator|-
literal|1
operator|&&
name|color
index|[
name|kt
operator|+
name|d
index|]
operator|!=
name|neutral
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|SqAtakd
argument_list|(
name|kf
argument_list|,
name|xside
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|SqAtakd
argument_list|(
name|kt
argument_list|,
name|xside
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|SqAtakd
argument_list|(
name|kf
operator|+
name|d
argument_list|,
name|xside
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|iop
operator|==
literal|1
condition|)
name|castld
index|[
name|side
index|]
operator|=
name|true
expr_stmt|;
else|else
name|castld
index|[
name|side
index|]
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|iop
operator|==
literal|2
condition|)
block|{
name|t0
operator|=
name|kt
expr_stmt|;
name|kt
operator|=
name|kf
expr_stmt|;
name|kf
operator|=
name|t0
expr_stmt|;
name|t0
operator|=
name|rt
expr_stmt|;
name|rt
operator|=
name|rf
expr_stmt|;
name|rf
operator|=
name|t0
expr_stmt|;
block|}
name|board
index|[
name|kt
index|]
operator|=
name|king
expr_stmt|;
name|color
index|[
name|kt
index|]
operator|=
name|side
expr_stmt|;
name|Pindex
index|[
name|kt
index|]
operator|=
literal|0
expr_stmt|;
name|board
index|[
name|kf
index|]
operator|=
name|no_piece
expr_stmt|;
name|color
index|[
name|kf
index|]
operator|=
name|neutral
expr_stmt|;
name|board
index|[
name|rt
index|]
operator|=
name|rook
expr_stmt|;
name|color
index|[
name|rt
index|]
operator|=
name|side
expr_stmt|;
name|Pindex
index|[
name|rt
index|]
operator|=
name|Pindex
index|[
name|rf
index|]
expr_stmt|;
name|board
index|[
name|rf
index|]
operator|=
name|no_piece
expr_stmt|;
name|color
index|[
name|rf
index|]
operator|=
name|neutral
expr_stmt|;
name|PieceList
index|[
name|side
index|]
index|[
name|Pindex
index|[
name|kt
index|]
index|]
operator|=
name|kt
expr_stmt|;
name|PieceList
index|[
name|side
index|]
index|[
name|Pindex
index|[
name|rt
index|]
index|]
operator|=
name|rt
expr_stmt|;
if|if
condition|(
name|hashflag
condition|)
block|{
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|king
argument_list|,
name|kf
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|rook
argument_list|,
name|rf
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_macro
name|EnPassant
argument_list|(
argument|xside
argument_list|,
argument|f
argument_list|,
argument|t
argument_list|,
argument|iop
argument_list|)
end_macro

begin_decl_stmt
name|short
name|xside
decl_stmt|,
name|f
decl_stmt|,
name|t
decl_stmt|,
name|iop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Make or unmake an en passant move. */
end_comment

begin_block
block|{
name|short
name|l
decl_stmt|;
if|if
condition|(
name|t
operator|>
name|f
condition|)
name|l
operator|=
name|t
operator|-
literal|8
expr_stmt|;
else|else
name|l
operator|=
name|t
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|iop
operator|==
literal|1
condition|)
block|{
name|board
index|[
name|l
index|]
operator|=
name|no_piece
expr_stmt|;
name|color
index|[
name|l
index|]
operator|=
name|neutral
expr_stmt|;
block|}
else|else
block|{
name|board
index|[
name|l
index|]
operator|=
name|pawn
expr_stmt|;
name|color
index|[
name|l
index|]
operator|=
name|xside
expr_stmt|;
block|}
name|InitializeStats
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|MakeMove
argument_list|(
argument|side
argument_list|,
argument|node
argument_list|,
argument|tempb
argument_list|,
argument|tempc
argument_list|,
argument|tempsf
argument_list|,
argument|tempst
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
modifier|*
name|tempc
decl_stmt|,
modifier|*
name|tempb
decl_stmt|,
modifier|*
name|tempsf
decl_stmt|,
modifier|*
name|tempst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|leaf
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Update Arrays board[], color[], and Pindex[] to reflect the new board     position obtained after making the move pointed to by node. Also     update miscellaneous stuff that changes when a move is made.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|f
decl_stmt|,
name|t
decl_stmt|;
name|short
name|xside
decl_stmt|,
name|ct
decl_stmt|,
name|cf
decl_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
name|f
operator|=
name|node
operator|->
name|f
expr_stmt|;
name|t
operator|=
name|node
operator|->
name|t
expr_stmt|;
name|epsquare
operator|=
operator|-
literal|1
expr_stmt|;
name|FROMsquare
operator|=
name|f
expr_stmt|;
name|TOsquare
operator|=
name|t
expr_stmt|;
name|INCscore
operator|=
literal|0
expr_stmt|;
name|GameList
index|[
operator|++
name|GameCnt
index|]
operator|.
name|gmove
operator|=
operator|(
name|f
operator|<<
literal|8
operator|)
operator|+
name|t
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|cstlmask
condition|)
block|{
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|piece
operator|=
name|no_piece
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|color
operator|=
name|side
expr_stmt|;
name|castle
argument_list|(
name|side
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tempc
operator|=
name|color
index|[
name|t
index|]
expr_stmt|;
operator|*
name|tempb
operator|=
name|board
index|[
name|t
index|]
expr_stmt|;
operator|*
name|tempsf
operator|=
name|svalue
index|[
name|f
index|]
expr_stmt|;
operator|*
name|tempst
operator|=
name|svalue
index|[
name|t
index|]
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|piece
operator|=
operator|*
name|tempb
expr_stmt|;
name|GameList
index|[
name|GameCnt
index|]
operator|.
name|color
operator|=
operator|*
name|tempc
expr_stmt|;
if|if
condition|(
operator|*
name|tempc
operator|!=
name|neutral
condition|)
block|{
name|UpdatePieceList
argument_list|(
operator|*
name|tempc
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tempb
operator|==
name|pawn
condition|)
operator|--
name|PawnCnt
index|[
operator|*
name|tempc
index|]
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
if|if
condition|(
name|board
index|[
name|f
index|]
operator|==
name|pawn
condition|)
block|{
operator|--
name|PawnCnt
index|[
name|side
index|]
index|[
name|column
index|[
name|f
index|]
index|]
expr_stmt|;
operator|++
name|PawnCnt
index|[
name|side
index|]
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
name|cf
operator|=
name|column
index|[
name|f
index|]
expr_stmt|;
name|ct
operator|=
name|column
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
name|PawnCnt
index|[
name|side
index|]
index|[
name|ct
index|]
operator|>
literal|1
operator|+
name|PawnCnt
index|[
name|side
index|]
index|[
name|cf
index|]
condition|)
name|INCscore
operator|-=
literal|15
expr_stmt|;
elseif|else
if|if
condition|(
name|PawnCnt
index|[
name|side
index|]
index|[
name|ct
index|]
operator|<
literal|1
operator|+
name|PawnCnt
index|[
name|side
index|]
index|[
name|cf
index|]
condition|)
name|INCscore
operator|+=
literal|15
expr_stmt|;
elseif|else
if|if
condition|(
name|ct
operator|==
literal|0
operator|||
name|ct
operator|==
literal|7
operator|||
name|PawnCnt
index|[
name|side
index|]
index|[
name|ct
operator|+
name|ct
operator|-
name|cf
index|]
operator|==
literal|0
condition|)
name|INCscore
operator|-=
literal|15
expr_stmt|;
block|}
name|mtl
index|[
name|xside
index|]
operator|-=
name|value
index|[
operator|*
name|tempb
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|tempb
operator|==
name|pawn
condition|)
name|pmtl
index|[
name|xside
index|]
operator|-=
name|valueP
expr_stmt|;
if|if
condition|(
name|hashflag
condition|)
name|UpdateHashbd
argument_list|(
name|xside
argument_list|,
operator|*
name|tempb
argument_list|,
operator|-
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INCscore
operator|+=
operator|*
name|tempst
expr_stmt|;
block|}
name|color
index|[
name|t
index|]
operator|=
name|color
index|[
name|f
index|]
expr_stmt|;
name|board
index|[
name|t
index|]
operator|=
name|board
index|[
name|f
index|]
expr_stmt|;
name|svalue
index|[
name|t
index|]
operator|=
name|svalue
index|[
name|f
index|]
expr_stmt|;
name|Pindex
index|[
name|t
index|]
operator|=
name|Pindex
index|[
name|f
index|]
expr_stmt|;
name|PieceList
index|[
name|side
index|]
index|[
name|Pindex
index|[
name|t
index|]
index|]
operator|=
name|t
expr_stmt|;
name|color
index|[
name|f
index|]
operator|=
name|neutral
expr_stmt|;
name|board
index|[
name|f
index|]
operator|=
name|no_piece
expr_stmt|;
if|if
condition|(
name|board
index|[
name|t
index|]
operator|==
name|pawn
condition|)
if|if
condition|(
name|t
operator|-
name|f
operator|==
literal|16
condition|)
name|epsquare
operator|=
name|f
operator|+
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|-
name|t
operator|==
literal|16
condition|)
name|epsquare
operator|=
name|f
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|promote
condition|)
block|{
name|board
index|[
name|t
index|]
operator|=
name|queen
expr_stmt|;
operator|--
name|PawnCnt
index|[
name|side
index|]
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
name|mtl
index|[
name|side
index|]
operator|+=
name|valueQ
operator|-
name|valueP
expr_stmt|;
name|pmtl
index|[
name|side
index|]
operator|-=
name|valueP
expr_stmt|;
name|HasQueen
index|[
name|side
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|hashflag
condition|)
block|{
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|pawn
argument_list|,
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|queen
argument_list|,
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|INCscore
operator|-=
operator|*
name|tempsf
expr_stmt|;
block|}
if|if
condition|(
name|board
index|[
name|t
index|]
operator|==
name|king
condition|)
operator|++
name|kingmoved
index|[
name|side
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|epmask
condition|)
name|EnPassant
argument_list|(
name|xside
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hashflag
condition|)
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|board
index|[
name|t
index|]
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|UnmakeMove
argument_list|(
argument|side
argument_list|,
argument|node
argument_list|,
argument|tempb
argument_list|,
argument|tempc
argument_list|,
argument|tempsf
argument_list|,
argument|tempst
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
modifier|*
name|tempc
decl_stmt|,
modifier|*
name|tempb
decl_stmt|,
modifier|*
name|tempsf
decl_stmt|,
modifier|*
name|tempst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|leaf
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Take back a move. */
end_comment

begin_block
block|{
specifier|register
name|short
name|f
decl_stmt|,
name|t
decl_stmt|;
name|short
name|xside
decl_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
name|f
operator|=
name|node
operator|->
name|f
expr_stmt|;
name|t
operator|=
name|node
operator|->
name|t
expr_stmt|;
name|epsquare
operator|=
operator|-
literal|1
expr_stmt|;
name|GameCnt
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|cstlmask
condition|)
name|castle
argument_list|(
name|side
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|color
index|[
name|f
index|]
operator|=
name|color
index|[
name|t
index|]
expr_stmt|;
name|board
index|[
name|f
index|]
operator|=
name|board
index|[
name|t
index|]
expr_stmt|;
name|svalue
index|[
name|f
index|]
operator|=
operator|*
name|tempsf
expr_stmt|;
name|Pindex
index|[
name|f
index|]
operator|=
name|Pindex
index|[
name|t
index|]
expr_stmt|;
name|PieceList
index|[
name|side
index|]
index|[
name|Pindex
index|[
name|f
index|]
index|]
operator|=
name|f
expr_stmt|;
name|color
index|[
name|t
index|]
operator|=
operator|*
name|tempc
expr_stmt|;
name|board
index|[
name|t
index|]
operator|=
operator|*
name|tempb
expr_stmt|;
name|svalue
index|[
name|t
index|]
operator|=
operator|*
name|tempst
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|promote
condition|)
block|{
name|board
index|[
name|f
index|]
operator|=
name|pawn
expr_stmt|;
operator|++
name|PawnCnt
index|[
name|side
index|]
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
name|mtl
index|[
name|side
index|]
operator|+=
name|valueP
operator|-
name|valueQ
expr_stmt|;
name|pmtl
index|[
name|side
index|]
operator|+=
name|valueP
expr_stmt|;
if|if
condition|(
name|hashflag
condition|)
block|{
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|queen
argument_list|,
operator|-
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|pawn
argument_list|,
operator|-
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|tempc
operator|!=
name|neutral
condition|)
block|{
name|UpdatePieceList
argument_list|(
operator|*
name|tempc
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tempb
operator|==
name|pawn
condition|)
operator|++
name|PawnCnt
index|[
operator|*
name|tempc
index|]
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
if|if
condition|(
name|board
index|[
name|f
index|]
operator|==
name|pawn
condition|)
block|{
operator|--
name|PawnCnt
index|[
name|side
index|]
index|[
name|column
index|[
name|t
index|]
index|]
expr_stmt|;
operator|++
name|PawnCnt
index|[
name|side
index|]
index|[
name|column
index|[
name|f
index|]
index|]
expr_stmt|;
block|}
name|mtl
index|[
name|xside
index|]
operator|+=
name|value
index|[
operator|*
name|tempb
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|tempb
operator|==
name|pawn
condition|)
name|pmtl
index|[
name|xside
index|]
operator|+=
name|valueP
expr_stmt|;
if|if
condition|(
name|hashflag
condition|)
name|UpdateHashbd
argument_list|(
name|xside
argument_list|,
operator|*
name|tempb
argument_list|,
operator|-
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|board
index|[
name|f
index|]
operator|==
name|king
condition|)
operator|--
name|kingmoved
index|[
name|side
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|epmask
condition|)
name|EnPassant
argument_list|(
name|xside
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hashflag
condition|)
name|UpdateHashbd
argument_list|(
name|side
argument_list|,
name|board
index|[
name|f
index|]
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|UpdateHashbd
argument_list|(
argument|side
argument_list|,
argument|piece
argument_list|,
argument|f
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|piece
decl_stmt|,
name|f
decl_stmt|,
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    hashbd contains a 32 bit "signature" of the board position. hashkey     contains a 16 bit code used to address the hash table. When a move is     made, XOR'ing the hashcode of moved piece on the from and to squares     with the hashbd and hashkey values keeps things current.  */
end_comment

begin_block
block|{
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|hashbd
operator|^=
name|hashcode
index|[
name|side
index|]
index|[
name|piece
index|]
index|[
name|f
index|]
operator|.
name|bd
expr_stmt|;
name|hashkey
operator|^=
name|hashcode
index|[
name|side
index|]
index|[
name|piece
index|]
index|[
name|f
index|]
operator|.
name|key
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|hashbd
operator|^=
name|hashcode
index|[
name|side
index|]
index|[
name|piece
index|]
index|[
name|t
index|]
operator|.
name|bd
expr_stmt|;
name|hashkey
operator|^=
name|hashcode
index|[
name|side
index|]
index|[
name|piece
index|]
index|[
name|t
index|]
operator|.
name|key
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|UpdatePieceList
argument_list|(
argument|side
argument_list|,
argument|sq
argument_list|,
argument|iop
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
name|sq
decl_stmt|,
name|iop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Update the PieceList and Pindex arrays when a piece is captured or     when a capture is unmade.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|i
decl_stmt|;
if|if
condition|(
name|iop
operator|==
literal|1
condition|)
block|{
name|PieceCnt
index|[
name|side
index|]
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Pindex
index|[
name|sq
index|]
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|side
index|]
condition|;
name|i
operator|++
control|)
block|{
name|PieceList
index|[
name|side
index|]
index|[
name|i
index|]
operator|=
name|PieceList
index|[
name|side
index|]
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|Pindex
index|[
name|PieceList
index|[
name|side
index|]
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|PieceCnt
index|[
name|side
index|]
operator|++
expr_stmt|;
name|PieceList
index|[
name|side
index|]
index|[
name|PieceCnt
index|[
name|side
index|]
index|]
operator|=
name|sq
expr_stmt|;
name|Pindex
index|[
name|sq
index|]
operator|=
name|PieceCnt
index|[
name|side
index|]
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|InitializeStats
argument_list|()
end_macro

begin_comment
comment|/*    Scan thru the board seeing what's on each square. If a piece is found,     update the variables PieceCnt, PawnCnt, Pindex and PieceList. Also     determine the material for each side and set the hashkey and hashbd     variables to represent the current board position. Array     PieceList[side][indx] contains the location of all the pieces of     either side. Array Pindex[sq] contains the indx into PieceList for a     given square.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|i
decl_stmt|,
name|sq
decl_stmt|;
name|epsquare
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|PawnCnt
index|[
name|white
index|]
index|[
name|i
index|]
operator|=
name|PawnCnt
index|[
name|black
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mtl
index|[
name|white
index|]
operator|=
name|mtl
index|[
name|black
index|]
operator|=
name|pmtl
index|[
name|white
index|]
operator|=
name|pmtl
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|PieceCnt
index|[
name|white
index|]
operator|=
name|PieceCnt
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|hashbd
operator|=
name|hashkey
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sq
operator|=
literal|0
init|;
name|sq
operator|<
literal|64
condition|;
name|sq
operator|++
control|)
if|if
condition|(
name|color
index|[
name|sq
index|]
operator|!=
name|neutral
condition|)
block|{
name|mtl
index|[
name|color
index|[
name|sq
index|]
index|]
operator|+=
name|value
index|[
name|board
index|[
name|sq
index|]
index|]
expr_stmt|;
if|if
condition|(
name|board
index|[
name|sq
index|]
operator|==
name|pawn
condition|)
block|{
name|pmtl
index|[
name|color
index|[
name|sq
index|]
index|]
operator|+=
name|valueP
expr_stmt|;
operator|++
name|PawnCnt
index|[
name|color
index|[
name|sq
index|]
index|]
index|[
name|column
index|[
name|sq
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|board
index|[
name|sq
index|]
operator|==
name|king
condition|)
name|Pindex
index|[
name|sq
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|Pindex
index|[
name|sq
index|]
operator|=
operator|++
name|PieceCnt
index|[
name|color
index|[
name|sq
index|]
index|]
expr_stmt|;
name|PieceList
index|[
name|color
index|[
name|sq
index|]
index|]
index|[
name|Pindex
index|[
name|sq
index|]
index|]
operator|=
name|sq
expr_stmt|;
name|hashbd
operator|^=
name|hashcode
index|[
name|color
index|[
name|sq
index|]
index|]
index|[
name|board
index|[
name|sq
index|]
index|]
index|[
name|sq
index|]
operator|.
name|bd
expr_stmt|;
name|hashkey
operator|^=
name|hashcode
index|[
name|color
index|[
name|sq
index|]
index|]
index|[
name|board
index|[
name|sq
index|]
index|]
index|[
name|sq
index|]
operator|.
name|key
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pick
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|short
name|p1
decl_stmt|,
name|p2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      Find the best move in the tree between indexes p1 and p2. Swap the     best move into the p1 element.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|p
decl_stmt|,
name|s
decl_stmt|;
name|short
name|p0
decl_stmt|,
name|s0
decl_stmt|;
name|struct
name|leaf
name|temp
decl_stmt|;
name|s0
operator|=
name|Tree
index|[
name|p1
index|]
operator|.
name|score
expr_stmt|;
name|p0
operator|=
name|p1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p1
operator|+
literal|1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|s
operator|=
name|Tree
index|[
name|p
index|]
operator|.
name|score
operator|)
operator|>
name|s0
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|p0
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|p0
operator|!=
name|p1
condition|)
block|{
name|temp
operator|=
name|Tree
index|[
name|p1
index|]
expr_stmt|;
name|Tree
index|[
name|p1
index|]
operator|=
name|Tree
index|[
name|p0
index|]
expr_stmt|;
name|Tree
index|[
name|p0
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|repetition
argument_list|(
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     Check for draw by threefold repetition. */
end_comment

begin_block
block|{
specifier|register
name|short
name|i
decl_stmt|,
name|c
decl_stmt|;
name|short
name|f
decl_stmt|,
name|t
decl_stmt|,
name|b
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|short
name|m
decl_stmt|;
operator|*
name|cnt
operator|=
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GameCnt
operator|>
name|Game50
operator|+
literal|3
condition|)
block|{
comment|/*       memset((char *)b,0,64*sizeof(short)); */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|b
index|[
name|i
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
name|GameCnt
init|;
name|i
operator|>
name|Game50
condition|;
name|i
operator|--
control|)
block|{
name|m
operator|=
name|GameList
index|[
name|i
index|]
operator|.
name|gmove
expr_stmt|;
name|f
operator|=
name|m
operator|>>
literal|8
expr_stmt|;
name|t
operator|=
name|m
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
operator|++
name|b
index|[
name|f
index|]
operator|==
literal|0
condition|)
name|c
operator|--
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|b
index|[
name|t
index|]
operator|==
literal|0
condition|)
name|c
operator|--
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
operator|(
operator|*
name|cnt
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|3
operator|)
end_if

begin_function
name|int
name|SqAtakd
parameter_list|(
name|sq
parameter_list|,
name|side
parameter_list|)
name|short
name|sq
decl_stmt|,
name|side
decl_stmt|;
comment|/*   See if any piece with color 'side' ataks sq.  First check for pawns   or king, then try other pieces. Array Dcode is used to check for   knight attacks or R,B,Q co-linearity.   */
block|{
specifier|register
name|short
name|m
decl_stmt|,
name|d
decl_stmt|;
name|short
name|i
decl_stmt|,
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|loc
decl_stmt|,
name|piece
decl_stmt|,
modifier|*
name|PL
decl_stmt|;
name|m1
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|side
operator|==
name|white
condition|)
name|m
operator|=
name|m1
operator|-
literal|0x0F
expr_stmt|;
else|else
name|m
operator|=
name|m1
operator|+
literal|0x0F
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
if|if
condition|(
name|board
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|==
name|pawn
operator|&&
name|color
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|==
name|side
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|side
operator|==
name|white
condition|)
name|m
operator|=
name|m1
operator|-
literal|0x11
expr_stmt|;
else|else
name|m
operator|=
name|m1
operator|+
literal|0x11
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
if|if
condition|(
name|board
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|==
name|pawn
operator|&&
name|color
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|==
name|side
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|distance
argument_list|(
name|sq
argument_list|,
name|PieceList
index|[
name|side
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|PL
operator|=
name|PieceList
index|[
name|side
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|side
index|]
condition|;
name|i
operator|++
control|)
block|{
name|loc
operator|=
name|PL
index|[
name|i
index|]
expr_stmt|;
name|piece
operator|=
name|board
index|[
name|loc
index|]
expr_stmt|;
if|if
condition|(
name|piece
operator|==
name|pawn
condition|)
continue|continue;
name|m0
operator|=
name|map
index|[
name|loc
index|]
expr_stmt|;
name|d
operator|=
name|Dcode
index|[
name|abs
argument_list|(
name|m1
operator|-
name|m0
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
operator|||
operator|(
name|Pdir
index|[
name|d
index|]
operator|&
name|pbit
index|[
name|piece
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|piece
operator|==
name|knight
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
block|{
if|if
condition|(
name|m1
operator|<
name|m0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
operator|+
name|d
init|;
name|m
operator|!=
name|m1
condition|;
name|m
operator|+=
name|d
control|)
if|if
condition|(
name|color
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|!=
name|neutral
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|m1
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|2
operator|)
end_if

begin_macro
name|ataks
argument_list|(
argument|side
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     Fill array atak[][] with info about ataks to a square.  Bits 8-15     are set if the piece (king..pawn) ataks the square. Bits 0-7     contain a count of total ataks to the square. */
end_comment

begin_block
block|{
specifier|register
name|short
name|u
decl_stmt|,
name|m
decl_stmt|;
name|short
name|d
decl_stmt|,
name|c
decl_stmt|,
name|j
decl_stmt|,
name|j1
decl_stmt|,
name|j2
decl_stmt|,
name|piece
decl_stmt|,
name|i
decl_stmt|,
name|m0
decl_stmt|,
name|sq
decl_stmt|,
modifier|*
name|PL
decl_stmt|;
comment|/*   memset((char *)a,0,64*sizeof(short)); */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
literal|64
condition|;
name|a
index|[
name|u
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
name|Dstart
index|[
name|pawn
index|]
operator|=
name|Dpwn
index|[
name|side
index|]
expr_stmt|;
name|Dstop
index|[
name|pawn
index|]
operator|=
name|Dstart
index|[
name|pawn
index|]
operator|+
literal|1
expr_stmt|;
name|PL
operator|=
name|PieceList
index|[
name|side
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|side
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sq
operator|=
name|PL
index|[
name|i
index|]
expr_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
name|piece
operator|=
name|board
index|[
name|sq
index|]
expr_stmt|;
name|c
operator|=
name|control
index|[
name|piece
index|]
expr_stmt|;
name|j1
operator|=
name|Dstart
index|[
name|piece
index|]
expr_stmt|;
name|j2
operator|=
name|Dstop
index|[
name|piece
index|]
expr_stmt|;
if|if
condition|(
name|sweep
index|[
name|piece
index|]
condition|)
for|for
control|(
name|j
operator|=
name|j1
init|;
name|j
operator|<=
name|j2
condition|;
name|j
operator|++
control|)
block|{
name|d
operator|=
name|Dir
index|[
name|j
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
name|a
index|[
name|u
index|]
operator|=
operator|++
name|a
index|[
name|u
index|]
operator||
name|c
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|neutral
condition|)
name|m
operator|+=
name|d
expr_stmt|;
else|else
break|break;
block|}
block|}
else|else
for|for
control|(
name|j
operator|=
name|j1
init|;
name|j
operator|<=
name|j2
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|j
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
name|a
index|[
name|u
index|]
operator|=
operator|++
name|a
index|[
name|u
index|]
operator||
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ............    POSITIONAL EVALUATION ROUTINES    ............ */
end_comment

begin_macro
name|ScorePosition
argument_list|(
argument|side
argument_list|,
argument|score
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
modifier|*
name|score
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Perform normal static evaluation of board position. A score is     generated for each piece and these are summed to get a score for each     side.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|sq
decl_stmt|,
name|s
decl_stmt|;
name|short
name|i
decl_stmt|,
name|xside
decl_stmt|,
name|pscore
index|[
literal|3
index|]
decl_stmt|;
name|wking
operator|=
name|PieceList
index|[
name|white
index|]
index|[
literal|0
index|]
expr_stmt|;
name|bking
operator|=
name|PieceList
index|[
name|black
index|]
index|[
literal|0
index|]
expr_stmt|;
name|UpdateWeights
argument_list|()
expr_stmt|;
name|xside
operator|=
name|otherside
index|[
name|side
index|]
expr_stmt|;
name|pscore
index|[
name|white
index|]
operator|=
name|pscore
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|white
init|;
name|c1
operator|<=
name|black
condition|;
name|c1
operator|++
control|)
block|{
name|c2
operator|=
name|otherside
index|[
name|c1
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|white
condition|)
name|EnemyKing
operator|=
name|bking
expr_stmt|;
else|else
name|EnemyKing
operator|=
name|wking
expr_stmt|;
name|atk1
operator|=
name|atak
index|[
name|c1
index|]
expr_stmt|;
name|atk2
operator|=
name|atak
index|[
name|c2
index|]
expr_stmt|;
name|PC1
operator|=
name|PawnCnt
index|[
name|c1
index|]
expr_stmt|;
name|PC2
operator|=
name|PawnCnt
index|[
name|c2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|c1
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sq
operator|=
name|PieceList
index|[
name|c1
index|]
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|SqValue
argument_list|(
name|sq
argument_list|,
name|side
argument_list|)
expr_stmt|;
name|pscore
index|[
name|c1
index|]
operator|+=
name|s
expr_stmt|;
name|svalue
index|[
name|sq
index|]
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hung
index|[
name|side
index|]
operator|>
literal|1
condition|)
name|pscore
index|[
name|side
index|]
operator|+=
name|HUNGX
expr_stmt|;
if|if
condition|(
name|hung
index|[
name|xside
index|]
operator|>
literal|1
condition|)
name|pscore
index|[
name|xside
index|]
operator|+=
name|HUNGX
expr_stmt|;
operator|*
name|score
operator|=
name|mtl
index|[
name|side
index|]
operator|-
name|mtl
index|[
name|xside
index|]
operator|+
name|pscore
index|[
name|side
index|]
operator|-
name|pscore
index|[
name|xside
index|]
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|dither
condition|)
operator|*
name|score
operator|+=
name|rand
argument_list|()
operator|%
name|dither
expr_stmt|;
if|if
condition|(
operator|*
name|score
operator|>
literal|0
operator|&&
name|pmtl
index|[
name|side
index|]
operator|==
literal|0
condition|)
if|if
condition|(
name|emtl
index|[
name|side
index|]
operator|<
name|valueR
condition|)
operator|*
name|score
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|score
operator|<
name|valueR
condition|)
operator|*
name|score
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|score
operator|<
literal|0
operator|&&
name|pmtl
index|[
name|xside
index|]
operator|==
literal|0
condition|)
if|if
condition|(
name|emtl
index|[
name|xside
index|]
operator|<
name|valueR
condition|)
operator|*
name|score
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|-
operator|*
name|score
operator|<
name|valueR
condition|)
operator|*
name|score
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|mtl
index|[
name|xside
index|]
operator|==
name|valueK
operator|&&
name|emtl
index|[
name|side
index|]
operator|>
name|valueB
condition|)
operator|*
name|score
operator|+=
literal|200
expr_stmt|;
if|if
condition|(
name|mtl
index|[
name|side
index|]
operator|==
name|valueK
operator|&&
name|emtl
index|[
name|xside
index|]
operator|>
name|valueB
condition|)
operator|*
name|score
operator|-=
literal|200
expr_stmt|;
block|}
end_block

begin_macro
name|ScoreLoneKing
argument_list|(
argument|side
argument_list|,
argument|score
argument_list|)
end_macro

begin_decl_stmt
name|short
name|side
decl_stmt|,
modifier|*
name|score
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     Static evaluation when loser has only a king and winner has no pawns    or no pieces. */
end_comment

begin_block
block|{
name|short
name|winner
decl_stmt|,
name|loser
decl_stmt|,
name|king1
decl_stmt|,
name|king2
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|;
name|UpdateWeights
argument_list|()
expr_stmt|;
if|if
condition|(
name|mtl
index|[
name|white
index|]
operator|>
name|mtl
index|[
name|black
index|]
condition|)
name|winner
operator|=
name|white
expr_stmt|;
else|else
name|winner
operator|=
name|black
expr_stmt|;
name|loser
operator|=
name|otherside
index|[
name|winner
index|]
expr_stmt|;
name|king1
operator|=
name|PieceList
index|[
name|winner
index|]
index|[
literal|0
index|]
expr_stmt|;
name|king2
operator|=
name|PieceList
index|[
name|loser
index|]
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pmtl
index|[
name|winner
index|]
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|winner
index|]
condition|;
name|i
operator|++
control|)
name|s
operator|+=
name|ScoreKPK
argument_list|(
name|side
argument_list|,
name|winner
argument_list|,
name|loser
argument_list|,
name|king1
argument_list|,
name|king2
argument_list|,
name|PieceList
index|[
name|winner
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|emtl
index|[
name|winner
index|]
operator|==
name|valueB
operator|+
name|valueN
condition|)
name|s
operator|=
name|ScoreKBNK
argument_list|(
name|winner
argument_list|,
name|king1
argument_list|,
name|king2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|emtl
index|[
name|winner
index|]
operator|>
name|valueB
condition|)
name|s
operator|=
literal|500
operator|+
name|emtl
index|[
name|winner
index|]
operator|-
name|DyingKing
index|[
name|king2
index|]
operator|-
literal|2
operator|*
name|distance
argument_list|(
name|king1
argument_list|,
name|king2
argument_list|)
expr_stmt|;
if|if
condition|(
name|side
operator|==
name|winner
condition|)
operator|*
name|score
operator|=
name|s
expr_stmt|;
else|else
operator|*
name|score
operator|=
operator|-
name|s
expr_stmt|;
block|}
end_block

begin_function
name|int
name|ScoreKPK
parameter_list|(
name|side
parameter_list|,
name|winner
parameter_list|,
name|loser
parameter_list|,
name|king1
parameter_list|,
name|king2
parameter_list|,
name|sq
parameter_list|)
name|short
name|side
decl_stmt|,
name|winner
decl_stmt|,
name|loser
decl_stmt|,
name|king1
decl_stmt|,
name|king2
decl_stmt|,
name|sq
decl_stmt|;
comment|/*    Score King and Pawns versus King endings. */
block|{
name|short
name|s
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|PieceCnt
index|[
name|winner
index|]
operator|==
literal|1
condition|)
name|s
operator|=
literal|50
expr_stmt|;
else|else
name|s
operator|=
literal|120
expr_stmt|;
if|if
condition|(
name|winner
operator|==
name|white
condition|)
block|{
if|if
condition|(
name|side
operator|==
name|loser
condition|)
name|r
operator|=
name|row
index|[
name|sq
index|]
operator|-
literal|1
expr_stmt|;
else|else
name|r
operator|=
name|row
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|row
index|[
name|king2
index|]
operator|>=
name|r
operator|&&
name|distance
argument_list|(
name|sq
argument_list|,
name|king2
argument_list|)
operator|<
literal|8
operator|-
name|r
condition|)
name|s
operator|+=
literal|10
operator|*
name|row
index|[
name|sq
index|]
expr_stmt|;
else|else
name|s
operator|=
literal|500
operator|+
literal|50
operator|*
name|row
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|row
index|[
name|sq
index|]
operator|<
literal|6
condition|)
name|sq
operator|+=
literal|16
expr_stmt|;
else|else
name|sq
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|side
operator|==
name|loser
condition|)
name|r
operator|=
name|row
index|[
name|sq
index|]
operator|+
literal|1
expr_stmt|;
else|else
name|r
operator|=
name|row
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|row
index|[
name|king2
index|]
operator|<=
name|r
operator|&&
name|distance
argument_list|(
name|sq
argument_list|,
name|king2
argument_list|)
operator|<
name|r
operator|+
literal|1
condition|)
name|s
operator|+=
literal|10
operator|*
operator|(
literal|7
operator|-
name|row
index|[
name|sq
index|]
operator|)
expr_stmt|;
else|else
name|s
operator|=
literal|500
operator|+
literal|50
operator|*
operator|(
literal|7
operator|-
name|row
index|[
name|sq
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|row
index|[
name|sq
index|]
operator|>
literal|1
condition|)
name|sq
operator|-=
literal|16
expr_stmt|;
else|else
name|sq
operator|-=
literal|8
expr_stmt|;
block|}
name|s
operator|+=
literal|8
operator|*
operator|(
name|taxicab
argument_list|(
name|king2
argument_list|,
name|sq
argument_list|)
operator|-
name|taxicab
argument_list|(
name|king1
argument_list|,
name|sq
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ScoreKBNK
parameter_list|(
name|winner
parameter_list|,
name|king1
parameter_list|,
name|king2
parameter_list|)
name|short
name|winner
decl_stmt|,
name|king1
decl_stmt|,
name|king2
decl_stmt|;
comment|/*    Score King+Bishop+Knight versus King endings.    This doesn't work all that well but it's better than nothing. */
block|{
name|short
name|s
decl_stmt|;
name|s
operator|=
name|emtl
index|[
name|winner
index|]
operator|-
literal|300
expr_stmt|;
if|if
condition|(
name|KBNKsq
operator|==
literal|0
condition|)
name|s
operator|+=
name|KBNK
index|[
name|king2
index|]
expr_stmt|;
else|else
name|s
operator|+=
name|KBNK
index|[
name|locn
index|[
name|row
index|[
name|king2
index|]
index|]
index|[
literal|7
operator|-
name|column
index|[
name|king2
index|]
index|]
index|]
expr_stmt|;
name|s
operator|-=
name|taxicab
argument_list|(
name|king1
argument_list|,
name|king2
argument_list|)
expr_stmt|;
name|s
operator|-=
name|distance
argument_list|(
name|PieceList
index|[
name|winner
index|]
index|[
literal|1
index|]
argument_list|,
name|king2
argument_list|)
expr_stmt|;
name|s
operator|-=
name|distance
argument_list|(
name|PieceList
index|[
name|winner
index|]
index|[
literal|2
index|]
argument_list|,
name|king2
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|SqValue
argument_list|(
argument|sq
argument_list|,
argument|side
argument_list|)
end_macro

begin_decl_stmt
name|short
name|sq
decl_stmt|,
name|side
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Calculate the positional value for the piece on 'sq'. */
end_comment

begin_block
block|{
specifier|register
name|short
name|j
decl_stmt|,
name|fyle
decl_stmt|,
name|rank
decl_stmt|;
name|short
name|s
decl_stmt|,
name|piece
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|in_square
decl_stmt|,
name|r
decl_stmt|,
name|mob
decl_stmt|,
name|e
decl_stmt|,
name|c
decl_stmt|;
name|piece
operator|=
name|board
index|[
name|sq
index|]
expr_stmt|;
name|a1
operator|=
operator|(
name|atk1
index|[
name|sq
index|]
operator|&
literal|0x4FFF
operator|)
expr_stmt|;
name|a2
operator|=
operator|(
name|atk2
index|[
name|sq
index|]
operator|&
literal|0x4FFF
operator|)
expr_stmt|;
name|rank
operator|=
name|row
index|[
name|sq
index|]
expr_stmt|;
name|fyle
operator|=
name|column
index|[
name|sq
index|]
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|piece
operator|==
name|pawn
operator|&&
name|c1
operator|==
name|white
condition|)
block|{
name|s
operator|=
name|Mwpawn
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|sq
operator|==
literal|11
operator|||
name|sq
operator|==
literal|12
condition|)
if|if
condition|(
name|color
index|[
name|sq
operator|+
literal|8
index|]
operator|!=
name|neutral
condition|)
name|s
operator|+=
name|PEDRNK2B
expr_stmt|;
if|if
condition|(
operator|(
name|fyle
operator|==
literal|0
operator|||
name|PC1
index|[
name|fyle
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fyle
operator|==
literal|7
operator|||
name|PC1
index|[
name|fyle
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|s
operator|+=
name|ISOLANI
index|[
name|fyle
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|PC1
index|[
name|fyle
index|]
operator|>
literal|1
condition|)
name|s
operator|+=
name|PDOUBLED
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|ctlP
operator|&&
name|atk1
index|[
name|sq
operator|+
literal|8
index|]
operator|<
name|ctlP
condition|)
block|{
name|s
operator|+=
name|BACKWARD
index|[
name|a2
operator|&
literal|0xFF
index|]
expr_stmt|;
if|if
condition|(
name|PC2
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|PWEAKH
expr_stmt|;
if|if
condition|(
name|color
index|[
name|sq
operator|+
literal|8
index|]
operator|!=
name|neutral
condition|)
name|s
operator|+=
name|PBLOK
expr_stmt|;
block|}
if|if
condition|(
name|PC2
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|side
operator|==
name|black
condition|)
name|r
operator|=
name|rank
operator|-
literal|1
expr_stmt|;
else|else
name|r
operator|=
name|rank
expr_stmt|;
name|in_square
operator|=
operator|(
name|row
index|[
name|bking
index|]
operator|>=
name|r
operator|&&
name|distance
argument_list|(
name|sq
argument_list|,
name|bking
argument_list|)
operator|<
literal|8
operator|-
name|r
operator|)
expr_stmt|;
if|if
condition|(
name|a2
operator|==
literal|0
operator|||
name|side
operator|==
name|white
condition|)
name|e
operator|=
literal|0
expr_stmt|;
else|else
name|e
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|sq
operator|+
literal|8
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|+=
literal|8
control|)
if|if
condition|(
name|atk2
index|[
name|j
index|]
operator|>=
name|ctlP
condition|)
block|{
name|e
operator|=
literal|2
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|atk2
index|[
name|j
index|]
operator|>
literal|0
operator|||
name|color
index|[
name|j
index|]
operator|!=
name|neutral
condition|)
name|e
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|2
condition|)
name|s
operator|+=
operator|(
name|stage
operator|*
name|PassedPawn3
index|[
name|rank
index|]
operator|)
operator|/
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|in_square
operator|||
name|e
operator|==
literal|1
condition|)
name|s
operator|+=
operator|(
name|stage
operator|*
name|PassedPawn2
index|[
name|rank
index|]
operator|)
operator|/
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|emtl
index|[
name|black
index|]
operator|>
literal|0
condition|)
name|s
operator|+=
operator|(
name|stage
operator|*
name|PassedPawn1
index|[
name|rank
index|]
operator|)
operator|/
literal|10
expr_stmt|;
else|else
name|s
operator|+=
name|PassedPawn0
index|[
name|rank
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|pawn
operator|&&
name|c1
operator|==
name|black
condition|)
block|{
name|s
operator|=
name|Mbpawn
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|sq
operator|==
literal|51
operator|||
name|sq
operator|==
literal|52
condition|)
if|if
condition|(
name|color
index|[
name|sq
operator|-
literal|8
index|]
operator|!=
name|neutral
condition|)
name|s
operator|+=
name|PEDRNK2B
expr_stmt|;
if|if
condition|(
operator|(
name|fyle
operator|==
literal|0
operator|||
name|PC1
index|[
name|fyle
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fyle
operator|==
literal|7
operator|||
name|PC1
index|[
name|fyle
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|s
operator|+=
name|ISOLANI
index|[
name|fyle
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|PC1
index|[
name|fyle
index|]
operator|>
literal|1
condition|)
name|s
operator|+=
name|PDOUBLED
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|ctlP
operator|&&
name|atk1
index|[
name|sq
operator|-
literal|8
index|]
operator|<
name|ctlP
condition|)
block|{
name|s
operator|+=
name|BACKWARD
index|[
name|a2
operator|&
literal|0xFF
index|]
expr_stmt|;
if|if
condition|(
name|PC2
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|PWEAKH
expr_stmt|;
if|if
condition|(
name|color
index|[
name|sq
operator|-
literal|8
index|]
operator|!=
name|neutral
condition|)
name|s
operator|+=
name|PBLOK
expr_stmt|;
block|}
if|if
condition|(
name|PC2
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|side
operator|==
name|white
condition|)
name|r
operator|=
name|rank
operator|+
literal|1
expr_stmt|;
else|else
name|r
operator|=
name|rank
expr_stmt|;
name|in_square
operator|=
operator|(
name|row
index|[
name|wking
index|]
operator|<=
name|r
operator|&&
name|distance
argument_list|(
name|sq
argument_list|,
name|wking
argument_list|)
operator|<
name|r
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|a2
operator|==
literal|0
operator|||
name|side
operator|==
name|black
condition|)
name|e
operator|=
literal|0
expr_stmt|;
else|else
name|e
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|sq
operator|-
literal|8
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|8
control|)
if|if
condition|(
name|atk2
index|[
name|j
index|]
operator|>=
name|ctlP
condition|)
block|{
name|e
operator|=
literal|2
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|atk2
index|[
name|j
index|]
operator|>
literal|0
operator|||
name|color
index|[
name|j
index|]
operator|!=
name|neutral
condition|)
name|e
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|2
condition|)
name|s
operator|+=
operator|(
name|stage
operator|*
name|PassedPawn3
index|[
literal|7
operator|-
name|rank
index|]
operator|)
operator|/
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|in_square
operator|||
name|e
operator|==
literal|1
condition|)
name|s
operator|+=
operator|(
name|stage
operator|*
name|PassedPawn2
index|[
literal|7
operator|-
name|rank
index|]
operator|)
operator|/
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|emtl
index|[
name|white
index|]
operator|>
literal|0
condition|)
name|s
operator|+=
operator|(
name|stage
operator|*
name|PassedPawn1
index|[
literal|7
operator|-
name|rank
index|]
operator|)
operator|/
literal|10
expr_stmt|;
else|else
name|s
operator|+=
name|PassedPawn0
index|[
literal|7
operator|-
name|rank
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|knight
condition|)
block|{
name|s
operator|=
name|Mknight
index|[
name|c1
index|]
index|[
name|sq
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|bishop
condition|)
block|{
name|s
operator|=
name|Mbishop
index|[
name|c1
index|]
index|[
name|sq
index|]
expr_stmt|;
name|BRscan
argument_list|(
name|sq
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|mob
argument_list|)
expr_stmt|;
name|s
operator|+=
name|BMBLTY
index|[
name|mob
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|rook
condition|)
block|{
name|s
operator|+=
name|RookBonus
expr_stmt|;
name|BRscan
argument_list|(
name|sq
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|mob
argument_list|)
expr_stmt|;
name|s
operator|+=
name|RMBLTY
index|[
name|mob
index|]
expr_stmt|;
if|if
condition|(
name|PC1
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|RHOPN
expr_stmt|;
if|if
condition|(
name|PC2
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|RHOPNX
expr_stmt|;
if|if
condition|(
name|rank
operator|==
name|rank7
index|[
name|c1
index|]
operator|&&
name|pmtl
index|[
name|c2
index|]
operator|>
literal|100
condition|)
name|s
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|stage
operator|>
literal|2
condition|)
name|s
operator|+=
literal|14
operator|-
name|taxicab
argument_list|(
name|sq
argument_list|,
name|EnemyKing
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|queen
condition|)
block|{
if|if
condition|(
name|stage
operator|>
literal|2
condition|)
name|s
operator|+=
literal|14
operator|-
name|taxicab
argument_list|(
name|sq
argument_list|,
name|EnemyKing
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
argument_list|(
name|sq
argument_list|,
name|EnemyKing
argument_list|)
operator|<
literal|3
condition|)
name|s
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|king
condition|)
block|{
name|s
operator|=
name|Mking
index|[
name|c1
index|]
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|KSFTY
operator|>
literal|0
condition|)
if|if
condition|(
name|Developed
index|[
name|c2
index|]
operator|||
name|stage
operator|>
literal|0
condition|)
name|KingScan
argument_list|(
name|sq
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|castld
index|[
name|c1
index|]
condition|)
name|s
operator|+=
name|KCASTLD
expr_stmt|;
elseif|else
if|if
condition|(
name|kingmoved
index|[
name|c1
index|]
condition|)
name|s
operator|+=
name|KMOVD
expr_stmt|;
if|if
condition|(
name|PC1
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPN
expr_stmt|;
if|if
condition|(
name|PC2
index|[
name|fyle
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPNX
expr_stmt|;
if|if
condition|(
name|fyle
operator|==
literal|1
operator|||
name|fyle
operator|==
literal|2
operator|||
name|fyle
operator|==
literal|3
operator|||
name|fyle
operator|==
literal|7
condition|)
block|{
if|if
condition|(
name|PC1
index|[
name|fyle
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPN
expr_stmt|;
if|if
condition|(
name|PC2
index|[
name|fyle
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPNX
expr_stmt|;
block|}
if|if
condition|(
name|fyle
operator|==
literal|4
operator|||
name|fyle
operator|==
literal|5
operator|||
name|fyle
operator|==
literal|6
operator|||
name|fyle
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PC1
index|[
name|fyle
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPN
expr_stmt|;
if|if
condition|(
name|PC2
index|[
name|fyle
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPNX
expr_stmt|;
block|}
if|if
condition|(
name|fyle
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|PC1
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPN
expr_stmt|;
if|if
condition|(
name|PC2
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPNX
expr_stmt|;
block|}
if|if
condition|(
name|fyle
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|PC1
index|[
literal|7
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPN
expr_stmt|;
if|if
condition|(
name|PC2
index|[
literal|7
index|]
operator|==
literal|0
condition|)
name|s
operator|+=
name|KHOPNX
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a2
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|(
name|control
index|[
name|piece
index|]
operator|&
literal|0x4FFF
operator|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
operator|||
name|a2
operator|>
name|c
operator|+
literal|1
condition|)
block|{
name|s
operator|+=
name|HUNGP
expr_stmt|;
operator|++
name|hung
index|[
name|c1
index|]
expr_stmt|;
if|if
condition|(
name|piece
operator|!=
name|king
operator|&&
name|trapped
argument_list|(
name|sq
argument_list|,
name|piece
argument_list|)
condition|)
operator|++
name|hung
index|[
name|c1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|piece
operator|!=
name|pawn
operator|||
name|a2
operator|>
name|a1
condition|)
if|if
condition|(
name|a2
operator|>=
name|c
operator|||
name|a1
operator|<
name|ctlP
condition|)
name|s
operator|+=
name|ATAKD
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|>
literal|6
operator|)
end_if

begin_macro
name|KingScan
argument_list|(
argument|sq
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|short
name|sq
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Assign penalties if king can be threatened by checks, if squares    near the king are controlled by the enemy (especially the queen),    or if there are no pawns near the king. */
end_comment

begin_define
define|#
directive|define
name|ScoreThreat
define|\
value|if (color[u] != c2)\     if (atk1[u] == 0 || (atk2[u]& 0xFF)> 1) ++cnt;\     else *s -= 3
end_define

begin_block
block|{
specifier|register
name|short
name|m
decl_stmt|,
name|u
decl_stmt|;
name|short
name|d
decl_stmt|,
name|i
decl_stmt|,
name|m0
decl_stmt|,
name|cnt
decl_stmt|,
name|ok
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|HasBishop
index|[
name|c2
index|]
operator|||
name|HasQueen
index|[
name|c2
index|]
condition|)
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|bishop
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|bishop
index|]
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|Dir
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|&
name|ctlBQ
condition|)
name|ScoreThreat
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|!=
name|neutral
condition|)
break|break;
name|m
operator|+=
name|d
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HasRook
index|[
name|c2
index|]
operator|||
name|HasQueen
index|[
name|c2
index|]
condition|)
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|rook
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|rook
index|]
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|Dir
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|&
name|ctlRQ
condition|)
name|ScoreThreat
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|!=
name|neutral
condition|)
break|break;
name|m
operator|+=
name|d
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HasKnight
index|[
name|c2
index|]
condition|)
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|knight
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|knight
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|i
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|&
name|ctlNN
condition|)
name|ScoreThreat
expr_stmt|;
block|}
operator|*
name|s
operator|+=
operator|(
name|KSFTY
operator|*
name|Kthreat
index|[
name|cnt
index|]
operator|)
operator|/
literal|16
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|king
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|king
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|i
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|board
index|[
name|u
index|]
operator|==
name|pawn
condition|)
name|ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|>
name|atk1
index|[
name|u
index|]
condition|)
block|{
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|&
name|ctlQ
condition|)
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|>
name|ctlQ
operator|+
literal|1
operator|&&
name|atk1
index|[
name|u
index|]
operator|<
name|ctlQ
condition|)
operator|*
name|s
operator|-=
literal|4
operator|*
name|KSFTY
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
operator|*
name|s
operator|-=
name|KSFTY
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
operator|*
name|s
operator|-=
name|KSFTY
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|4
operator|)
end_if

begin_macro
name|BRscan
argument_list|(
argument|sq
argument_list|,
argument|s
argument_list|,
argument|mob
argument_list|)
end_macro

begin_decl_stmt
name|short
name|sq
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|mob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Find Bishop and Rook mobility, XRAY attacks, and pins. Increment the     hung[] array if a pin is found.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|m
decl_stmt|,
name|u
decl_stmt|;
name|short
name|d
decl_stmt|,
name|j
decl_stmt|,
name|m0
decl_stmt|,
name|piece
decl_stmt|,
name|pin
decl_stmt|,
modifier|*
name|Kf
decl_stmt|;
name|Kf
operator|=
name|Kfield
index|[
name|c1
index|]
expr_stmt|;
operator|*
name|mob
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
name|piece
operator|=
name|board
index|[
name|sq
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|Dstart
index|[
name|piece
index|]
init|;
name|j
operator|<=
name|Dstop
index|[
name|piece
index|]
condition|;
name|j
operator|++
control|)
block|{
name|pin
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|=
name|Dir
index|[
name|j
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
operator|*
name|s
operator|+=
name|Kf
index|[
name|u
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|neutral
condition|)
block|{
operator|(
operator|*
name|mob
operator|)
operator|++
expr_stmt|;
name|m
operator|+=
name|d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pin
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|board
index|[
name|u
index|]
operator|==
name|pawn
operator|||
name|board
index|[
name|u
index|]
operator|==
name|king
condition|)
break|break;
name|pin
operator|=
name|u
expr_stmt|;
name|m
operator|+=
name|d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|c2
operator|&&
operator|(
name|board
index|[
name|u
index|]
operator|>
name|piece
operator|||
name|atk2
index|[
name|u
index|]
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|color
index|[
name|pin
index|]
operator|==
name|c2
condition|)
block|{
operator|*
name|s
operator|+=
name|PINVAL
expr_stmt|;
if|if
condition|(
name|atk2
index|[
name|pin
index|]
operator|==
literal|0
operator|||
name|atk1
index|[
name|pin
index|]
operator|>
name|control
index|[
name|board
index|[
name|pin
index|]
index|]
operator|+
literal|1
condition|)
operator|++
name|hung
index|[
name|c2
index|]
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|+=
name|XRAY
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|>
literal|5
operator|)
end_if

begin_function
name|int
name|trapped
parameter_list|(
name|sq
parameter_list|,
name|piece
parameter_list|)
name|short
name|sq
decl_stmt|,
name|piece
decl_stmt|;
comment|/*    See if the attacked piece has unattacked squares to move to. */
block|{
specifier|register
name|short
name|u
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|short
name|i
decl_stmt|,
name|m0
decl_stmt|;
name|m0
operator|=
name|map
index|[
name|sq
index|]
expr_stmt|;
if|if
condition|(
name|sweep
index|[
name|piece
index|]
condition|)
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|piece
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|piece
index|]
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|Dir
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
name|m0
operator|+
name|d
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|m
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|c1
condition|)
break|break;
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|==
literal|0
operator|||
name|board
index|[
name|u
index|]
operator|>=
name|piece
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|c2
condition|)
break|break;
name|m
operator|+=
name|d
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|piece
operator|==
name|pawn
condition|)
block|{
if|if
condition|(
name|c1
operator|==
name|white
condition|)
name|u
operator|=
name|sq
operator|+
literal|8
expr_stmt|;
else|else
name|u
operator|=
name|sq
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|==
name|neutral
operator|&&
name|atk1
index|[
name|u
index|]
operator|>=
name|atk2
index|[
name|u
index|]
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|Dpwn
index|[
name|c1
index|]
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
if|if
condition|(
name|color
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|==
name|c2
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|Dpwn
index|[
name|c1
index|]
operator|+
literal|1
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
if|if
condition|(
name|color
index|[
name|unmap
index|[
name|m
index|]
index|]
operator|==
name|c2
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|Dstart
index|[
name|piece
index|]
init|;
name|i
operator|<=
name|Dstop
index|[
name|piece
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|m
operator|=
name|m0
operator|+
name|Dir
index|[
name|i
index|]
operator|)
operator|&
literal|0x88
operator|)
condition|)
block|{
name|u
operator|=
name|unmap
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|color
index|[
name|u
index|]
operator|!=
name|c1
condition|)
if|if
condition|(
name|atk2
index|[
name|u
index|]
operator|==
literal|0
operator|||
name|board
index|[
name|u
index|]
operator|>=
name|piece
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|ExaminePosition
argument_list|()
end_macro

begin_comment
comment|/*    This is done one time before the search is started. Set up arrays     Mwpawn, Mbpawn, Mknight, Mbishop, Mking which are used in the     SqValue() function to determine the positional value of each piece.  */
end_comment

begin_block
block|{
specifier|register
name|short
name|i
decl_stmt|,
name|sq
decl_stmt|;
name|short
name|wpadv
decl_stmt|,
name|bpadv
decl_stmt|,
name|wstrong
decl_stmt|,
name|bstrong
decl_stmt|,
name|z
decl_stmt|,
name|side
decl_stmt|,
name|pp
decl_stmt|,
name|j
decl_stmt|,
name|val
decl_stmt|,
name|Pd
decl_stmt|,
name|fyle
decl_stmt|,
name|rank
decl_stmt|;
name|wking
operator|=
name|PieceList
index|[
name|white
index|]
index|[
literal|0
index|]
expr_stmt|;
name|bking
operator|=
name|PieceList
index|[
name|black
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ataks
argument_list|(
name|white
argument_list|,
name|atak
index|[
name|white
index|]
argument_list|)
expr_stmt|;
name|ataks
argument_list|(
name|black
argument_list|,
name|atak
index|[
name|black
index|]
argument_list|)
expr_stmt|;
name|Zwmtl
operator|=
name|Zbmtl
operator|=
literal|0
expr_stmt|;
name|UpdateWeights
argument_list|()
expr_stmt|;
name|HasPawn
index|[
name|white
index|]
operator|=
name|HasPawn
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|HasKnight
index|[
name|white
index|]
operator|=
name|HasKnight
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|HasBishop
index|[
name|white
index|]
operator|=
name|HasBishop
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|HasRook
index|[
name|white
index|]
operator|=
name|HasRook
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
name|HasQueen
index|[
name|white
index|]
operator|=
name|HasQueen
index|[
name|black
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|side
operator|=
name|white
init|;
name|side
operator|<=
name|black
condition|;
name|side
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|side
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|board
index|[
name|PieceList
index|[
name|side
index|]
index|[
name|i
index|]
index|]
condition|)
block|{
case|case
name|pawn
case|:
operator|++
name|HasPawn
index|[
name|side
index|]
expr_stmt|;
break|break;
case|case
name|knight
case|:
operator|++
name|HasKnight
index|[
name|side
index|]
expr_stmt|;
break|break;
case|case
name|bishop
case|:
operator|++
name|HasBishop
index|[
name|side
index|]
expr_stmt|;
break|break;
case|case
name|rook
case|:
operator|++
name|HasRook
index|[
name|side
index|]
expr_stmt|;
break|break;
case|case
name|queen
case|:
operator|++
name|HasQueen
index|[
name|side
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|Developed
index|[
name|white
index|]
condition|)
name|Developed
index|[
name|white
index|]
operator|=
operator|(
name|board
index|[
literal|1
index|]
operator|!=
name|knight
operator|&&
name|board
index|[
literal|2
index|]
operator|!=
name|bishop
operator|&&
name|board
index|[
literal|5
index|]
operator|!=
name|bishop
operator|&&
name|board
index|[
literal|6
index|]
operator|!=
name|knight
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|Developed
index|[
name|black
index|]
condition|)
name|Developed
index|[
name|black
index|]
operator|=
operator|(
name|board
index|[
literal|57
index|]
operator|!=
name|knight
operator|&&
name|board
index|[
literal|58
index|]
operator|!=
name|bishop
operator|&&
name|board
index|[
literal|61
index|]
operator|!=
name|bishop
operator|&&
name|board
index|[
literal|62
index|]
operator|!=
name|knight
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|PawnStorm
operator|&&
name|stage
operator|<
literal|5
condition|)
name|PawnStorm
operator|=
operator|(
operator|(
name|column
index|[
name|wking
index|]
operator|<
literal|3
operator|&&
name|column
index|[
name|bking
index|]
operator|>
literal|4
operator|)
operator|||
operator|(
name|column
index|[
name|wking
index|]
operator|>
literal|4
operator|&&
name|column
index|[
name|bking
index|]
operator|<
literal|3
operator|)
operator|)
expr_stmt|;
name|CopyBoard
argument_list|(
name|pknight
argument_list|,
name|Mknight
index|[
name|white
index|]
argument_list|)
expr_stmt|;
name|CopyBoard
argument_list|(
name|pknight
argument_list|,
name|Mknight
index|[
name|black
index|]
argument_list|)
expr_stmt|;
name|CopyBoard
argument_list|(
name|pbishop
argument_list|,
name|Mbishop
index|[
name|white
index|]
argument_list|)
expr_stmt|;
name|CopyBoard
argument_list|(
name|pbishop
argument_list|,
name|Mbishop
index|[
name|black
index|]
argument_list|)
expr_stmt|;
name|BlendBoard
argument_list|(
name|KingOpening
argument_list|,
name|KingEnding
argument_list|,
name|Mking
index|[
name|white
index|]
argument_list|)
expr_stmt|;
name|BlendBoard
argument_list|(
name|KingOpening
argument_list|,
name|KingEnding
argument_list|,
name|Mking
index|[
name|black
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|sq
operator|=
literal|0
init|;
name|sq
operator|<
literal|64
condition|;
name|sq
operator|++
control|)
block|{
name|fyle
operator|=
name|column
index|[
name|sq
index|]
expr_stmt|;
name|rank
operator|=
name|row
index|[
name|sq
index|]
expr_stmt|;
name|wstrong
operator|=
name|bstrong
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sq
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|8
control|)
if|if
condition|(
name|atak
index|[
name|black
index|]
index|[
name|i
index|]
operator|>=
name|ctlP
condition|)
name|wstrong
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sq
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
literal|8
control|)
if|if
condition|(
name|atak
index|[
name|white
index|]
index|[
name|i
index|]
operator|>=
name|ctlP
condition|)
name|bstrong
operator|=
name|false
expr_stmt|;
name|wpadv
operator|=
name|bpadv
operator|=
name|PADVNCM
expr_stmt|;
if|if
condition|(
operator|(
name|fyle
operator|==
literal|0
operator|||
name|PawnCnt
index|[
name|white
index|]
index|[
name|fyle
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fyle
operator|==
literal|7
operator|||
name|PawnCnt
index|[
name|white
index|]
index|[
name|fyle
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|wpadv
operator|=
name|PADVNCI
expr_stmt|;
if|if
condition|(
operator|(
name|fyle
operator|==
literal|0
operator|||
name|PawnCnt
index|[
name|black
index|]
index|[
name|fyle
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fyle
operator|==
literal|7
operator|||
name|PawnCnt
index|[
name|black
index|]
index|[
name|fyle
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|bpadv
operator|=
name|PADVNCI
expr_stmt|;
name|Mwpawn
index|[
name|sq
index|]
operator|=
operator|(
name|wpadv
operator|*
name|PawnAdvance
index|[
name|sq
index|]
operator|)
operator|/
literal|10
expr_stmt|;
name|Mbpawn
index|[
name|sq
index|]
operator|=
operator|(
name|bpadv
operator|*
name|PawnAdvance
index|[
literal|63
operator|-
name|sq
index|]
operator|)
operator|/
literal|10
expr_stmt|;
name|Mwpawn
index|[
name|sq
index|]
operator|+=
name|PawnBonus
expr_stmt|;
name|Mbpawn
index|[
name|sq
index|]
operator|+=
name|PawnBonus
expr_stmt|;
if|if
condition|(
name|castld
index|[
name|white
index|]
operator|||
name|kingmoved
index|[
name|white
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|fyle
operator|<
literal|3
operator|||
name|fyle
operator|>
literal|4
operator|)
operator|&&
name|distance
argument_list|(
name|sq
argument_list|,
name|wking
argument_list|)
operator|<
literal|3
condition|)
name|Mwpawn
index|[
name|sq
index|]
operator|+=
name|PAWNSHIELD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rank
operator|<
literal|3
operator|&&
operator|(
name|fyle
operator|<
literal|2
operator|||
name|fyle
operator|>
literal|5
operator|)
condition|)
name|Mwpawn
index|[
name|sq
index|]
operator|+=
name|PAWNSHIELD
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|castld
index|[
name|black
index|]
operator|||
name|kingmoved
index|[
name|black
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|fyle
operator|<
literal|3
operator|||
name|fyle
operator|>
literal|4
operator|)
operator|&&
name|distance
argument_list|(
name|sq
argument_list|,
name|bking
argument_list|)
operator|<
literal|3
condition|)
name|Mbpawn
index|[
name|sq
index|]
operator|+=
name|PAWNSHIELD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rank
operator|>
literal|4
operator|&&
operator|(
name|fyle
operator|<
literal|2
operator|||
name|fyle
operator|>
literal|5
operator|)
condition|)
name|Mbpawn
index|[
name|sq
index|]
operator|+=
name|PAWNSHIELD
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|PawnStorm
condition|)
block|{
if|if
condition|(
operator|(
name|column
index|[
name|wking
index|]
operator|<
literal|4
operator|&&
name|fyle
operator|>
literal|4
operator|)
operator|||
operator|(
name|column
index|[
name|wking
index|]
operator|>
literal|3
operator|&&
name|fyle
operator|<
literal|3
operator|)
condition|)
name|Mwpawn
index|[
name|sq
index|]
operator|+=
literal|3
operator|*
name|rank
operator|-
literal|21
expr_stmt|;
if|if
condition|(
operator|(
name|column
index|[
name|bking
index|]
operator|<
literal|4
operator|&&
name|fyle
operator|>
literal|4
operator|)
operator|||
operator|(
name|column
index|[
name|bking
index|]
operator|>
literal|3
operator|&&
name|fyle
operator|<
literal|3
operator|)
condition|)
name|Mbpawn
index|[
name|sq
index|]
operator|-=
literal|3
operator|*
name|rank
expr_stmt|;
block|}
name|Mknight
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
literal|5
operator|-
name|distance
argument_list|(
name|sq
argument_list|,
name|bking
argument_list|)
expr_stmt|;
name|Mknight
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
literal|5
operator|-
name|distance
argument_list|(
name|sq
argument_list|,
name|wking
argument_list|)
expr_stmt|;
name|Mknight
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
literal|5
operator|-
name|distance
argument_list|(
name|sq
argument_list|,
name|wking
argument_list|)
expr_stmt|;
name|Mknight
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
literal|5
operator|-
name|distance
argument_list|(
name|sq
argument_list|,
name|bking
argument_list|)
expr_stmt|;
name|Mbishop
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
name|BishopBonus
expr_stmt|;
name|Mbishop
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
name|BishopBonus
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|black
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|distance
argument_list|(
name|sq
argument_list|,
name|PieceList
index|[
name|black
index|]
index|[
name|i
index|]
argument_list|)
operator|<
literal|3
condition|)
name|Mknight
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
name|KNIGHTPOST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PieceCnt
index|[
name|white
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|distance
argument_list|(
name|sq
argument_list|,
name|PieceList
index|[
name|white
index|]
index|[
name|i
index|]
argument_list|)
operator|<
literal|3
condition|)
name|Mknight
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
name|KNIGHTPOST
expr_stmt|;
if|if
condition|(
name|wstrong
condition|)
name|Mknight
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
name|KNIGHTSTRONG
expr_stmt|;
if|if
condition|(
name|bstrong
condition|)
name|Mknight
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
name|KNIGHTSTRONG
expr_stmt|;
if|if
condition|(
name|wstrong
condition|)
name|Mbishop
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
name|BISHOPSTRONG
expr_stmt|;
if|if
condition|(
name|bstrong
condition|)
name|Mbishop
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
name|BISHOPSTRONG
expr_stmt|;
if|if
condition|(
name|HasBishop
index|[
name|white
index|]
operator|==
literal|2
condition|)
name|Mbishop
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|HasBishop
index|[
name|black
index|]
operator|==
literal|2
condition|)
name|Mbishop
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|HasKnight
index|[
name|white
index|]
operator|==
literal|2
condition|)
name|Mknight
index|[
name|white
index|]
index|[
name|sq
index|]
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|HasKnight
index|[
name|black
index|]
operator|==
literal|2
condition|)
name|Mknight
index|[
name|black
index|]
index|[
name|sq
index|]
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|board
index|[
name|sq
index|]
operator|==
name|bishop
condition|)
if|if
condition|(
name|rank
operator|%
literal|2
operator|==
name|fyle
operator|%
literal|2
condition|)
name|KBNKsq
operator|=
literal|0
expr_stmt|;
else|else
name|KBNKsq
operator|=
literal|7
expr_stmt|;
name|Kfield
index|[
name|white
index|]
index|[
name|sq
index|]
operator|=
name|Kfield
index|[
name|black
index|]
index|[
name|sq
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|distance
argument_list|(
name|sq
argument_list|,
name|wking
argument_list|)
operator|==
literal|1
condition|)
name|Kfield
index|[
name|black
index|]
index|[
name|sq
index|]
operator|=
name|KATAK
expr_stmt|;
if|if
condition|(
name|distance
argument_list|(
name|sq
argument_list|,
name|bking
argument_list|)
operator|==
literal|1
condition|)
name|Kfield
index|[
name|white
index|]
index|[
name|sq
index|]
operator|=
name|KATAK
expr_stmt|;
name|Pd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|board
index|[
name|i
index|]
operator|==
name|pawn
condition|)
block|{
if|if
condition|(
name|color
index|[
name|i
index|]
operator|==
name|white
condition|)
block|{
name|pp
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|row
index|[
name|i
index|]
operator|==
literal|6
condition|)
name|z
operator|=
name|i
operator|+
literal|8
expr_stmt|;
else|else
name|z
operator|=
name|i
operator|+
literal|16
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|8
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|+=
literal|8
control|)
if|if
condition|(
name|atak
index|[
name|black
index|]
index|[
name|j
index|]
operator|>
name|ctlP
operator|||
name|board
index|[
name|j
index|]
operator|==
name|pawn
condition|)
name|pp
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|row
index|[
name|i
index|]
operator|==
literal|1
condition|)
name|z
operator|=
name|i
operator|-
literal|8
expr_stmt|;
else|else
name|z
operator|=
name|i
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|8
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|8
control|)
if|if
condition|(
name|atak
index|[
name|white
index|]
index|[
name|j
index|]
operator|>
name|ctlP
operator|||
name|board
index|[
name|j
index|]
operator|==
name|pawn
condition|)
name|pp
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|pp
condition|)
name|Pd
operator|+=
literal|5
operator|*
name|taxicab
argument_list|(
name|sq
argument_list|,
name|z
argument_list|)
expr_stmt|;
else|else
name|Pd
operator|+=
name|taxicab
argument_list|(
name|sq
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Pd
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
operator|(
name|Pd
operator|*
name|stage2
operator|)
operator|/
literal|10
expr_stmt|;
name|Mking
index|[
name|white
index|]
index|[
name|sq
index|]
operator|-=
name|val
expr_stmt|;
name|Mking
index|[
name|black
index|]
index|[
name|sq
index|]
operator|-=
name|val
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|UpdateWeights
argument_list|()
end_macro

begin_comment
comment|/*     If material balance has changed, determine the values for the     positional evaluation terms.  */
end_comment

begin_block
block|{
name|short
name|tmtl
decl_stmt|;
if|if
condition|(
name|mtl
index|[
name|white
index|]
operator|!=
name|Zwmtl
operator|||
name|mtl
index|[
name|black
index|]
operator|!=
name|Zbmtl
condition|)
block|{
name|Zwmtl
operator|=
name|mtl
index|[
name|white
index|]
expr_stmt|;
name|Zbmtl
operator|=
name|mtl
index|[
name|black
index|]
expr_stmt|;
name|emtl
index|[
name|white
index|]
operator|=
name|Zwmtl
operator|-
name|pmtl
index|[
name|white
index|]
operator|-
name|valueK
expr_stmt|;
name|emtl
index|[
name|black
index|]
operator|=
name|Zbmtl
operator|-
name|pmtl
index|[
name|black
index|]
operator|-
name|valueK
expr_stmt|;
name|tmtl
operator|=
name|emtl
index|[
name|white
index|]
operator|+
name|emtl
index|[
name|black
index|]
expr_stmt|;
if|if
condition|(
name|tmtl
operator|>
literal|6600
condition|)
name|stage
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tmtl
operator|<
literal|1400
condition|)
name|stage
operator|=
literal|10
expr_stmt|;
else|else
name|stage
operator|=
operator|(
literal|6600
operator|-
name|tmtl
operator|)
operator|/
literal|520
expr_stmt|;
if|if
condition|(
name|tmtl
operator|>
literal|3600
condition|)
name|stage2
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tmtl
operator|<
literal|1400
condition|)
name|stage2
operator|=
literal|10
expr_stmt|;
else|else
name|stage2
operator|=
operator|(
literal|3600
operator|-
name|tmtl
operator|)
operator|/
literal|220
expr_stmt|;
name|PEDRNK2B
operator|=
operator|-
literal|15
expr_stmt|;
comment|/* centre pawn on 2nd rank& blocked */
name|PBLOK
operator|=
operator|-
literal|4
expr_stmt|;
comment|/* blocked backward pawn */
name|PDOUBLED
operator|=
operator|-
literal|14
expr_stmt|;
comment|/* doubled pawn */
name|PWEAKH
operator|=
operator|-
literal|4
expr_stmt|;
comment|/* weak pawn on half open file */
name|PAWNSHIELD
operator|=
literal|10
operator|-
name|stage
expr_stmt|;
comment|/* pawn near friendly king */
name|PADVNCM
operator|=
literal|10
expr_stmt|;
comment|/* advanced pawn multiplier */
name|PADVNCI
operator|=
literal|7
expr_stmt|;
comment|/* muliplier for isolated pawn */
name|PawnBonus
operator|=
name|stage
expr_stmt|;
name|KNIGHTPOST
operator|=
operator|(
name|stage
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
comment|/* knight near enemy pieces */
name|KNIGHTSTRONG
operator|=
operator|(
name|stage
operator|+
literal|6
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* occupies pawn hole */
name|BISHOPSTRONG
operator|=
operator|(
name|stage
operator|+
literal|6
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* occupies pawn hole */
name|BishopBonus
operator|=
literal|2
operator|*
name|stage
expr_stmt|;
name|RHOPN
operator|=
literal|10
expr_stmt|;
comment|/* rook on half open file */
name|RHOPNX
operator|=
literal|4
expr_stmt|;
name|RookBonus
operator|=
literal|6
operator|*
name|stage
expr_stmt|;
name|XRAY
operator|=
literal|8
expr_stmt|;
comment|/* Xray attack on piece */
name|PINVAL
operator|=
literal|10
expr_stmt|;
comment|/* Pin */
name|KHOPN
operator|=
operator|(
literal|3
operator|*
name|stage
operator|-
literal|30
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* king on half open file */
name|KHOPNX
operator|=
name|KHOPN
operator|/
literal|2
expr_stmt|;
name|KCASTLD
operator|=
literal|10
operator|-
name|stage
expr_stmt|;
name|KMOVD
operator|=
operator|-
literal|40
operator|/
operator|(
name|stage
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* king moved before castling */
name|KATAK
operator|=
operator|(
literal|10
operator|-
name|stage
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* B,R attacks near enemy king */
if|if
condition|(
name|stage
operator|<
literal|8
condition|)
name|KSFTY
operator|=
literal|16
operator|-
literal|2
operator|*
name|stage
expr_stmt|;
else|else
name|KSFTY
operator|=
literal|0
expr_stmt|;
name|ATAKD
operator|=
operator|-
literal|6
expr_stmt|;
comment|/* defender> attacker */
name|HUNGP
operator|=
operator|-
literal|8
expr_stmt|;
comment|/* each hung piece */
name|HUNGX
operator|=
operator|-
literal|12
expr_stmt|;
comment|/* extra for>1 hung piece */
block|}
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|NEWMOVE
operator|<
literal|1
operator|)
end_if

begin_function
name|int
name|distance
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|short
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
specifier|register
name|short
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|d1
operator|=
name|abs
argument_list|(
name|column
index|[
name|a
index|]
operator|-
name|column
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|d2
operator|=
name|abs
argument_list|(
name|row
index|[
name|a
index|]
operator|-
name|row
index|[
name|b
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|d1
operator|>
name|d2
condition|?
name|d1
else|:
name|d2
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|BlendBoard
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|short
name|a
index|[
literal|64
index|]
decl_stmt|,
name|b
index|[
literal|64
index|]
decl_stmt|,
name|c
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|sq
decl_stmt|;
for|for
control|(
name|sq
operator|=
literal|0
init|;
name|sq
operator|<
literal|64
condition|;
name|sq
operator|++
control|)
name|c
index|[
name|sq
index|]
operator|=
operator|(
name|a
index|[
name|sq
index|]
operator|*
operator|(
literal|10
operator|-
name|stage
operator|)
operator|+
name|b
index|[
name|sq
index|]
operator|*
name|stage
operator|)
operator|/
literal|10
expr_stmt|;
block|}
end_block

begin_macro
name|CopyBoard
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|short
name|a
index|[
literal|64
index|]
decl_stmt|,
name|b
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|sq
decl_stmt|;
for|for
control|(
name|sq
operator|=
literal|0
init|;
name|sq
operator|<
literal|64
condition|;
name|sq
operator|++
control|)
name|b
index|[
name|sq
index|]
operator|=
name|a
index|[
name|sq
index|]
expr_stmt|;
block|}
end_block

end_unit

