begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|_BLURB_
end_ifndef

begin_define
define|#
directive|define
name|_BLURB_
end_define

begin_comment
comment|/************************************************************************           Copyright 1988, 1991 by Carnegie Mellon University                            All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Carnegie Mellon University not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ************************************************************************/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _BLURB_ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bootp.c	1.1 (Stanford) 1/22/86"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /b/source/CVS/othersrc/bootpd/bootpd.c,v 1.2 1993/08/28 01:55:27 brezak Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * BOOTP (bootstrap protocol) server daemon.  *  * Answers BOOTP request packets from booting client machines.  * See [SRI-NIC]<RFC>RFC951.TXT for a description of the protocol.  * See [SRI-NIC]<RFC>RFC1048.TXT for vendor-information extensions.  * See accompanying man page -- bootpd.8  *  *  * HISTORY  *  * 01/22/86	Bill Croft at Stanford University  *		    Created.  *  * 07/30/86     David Kovar at Carnegie Mellon University  *		    Modified to work at CMU.  *  * 07/24/87	Drew D. Perkins at Carnegie Mellon University  *		    Modified to use syslog instead of Kovar's  *		    routines.  Add debugging dumps.  Many other fixups.  *  * 07/15/88	Walter L. Wimer at Carnegie Mellon University  *		    Added vendor information to conform to RFC1048.  *		    Adopted termcap-like file format to support above.  *		    Added hash table lookup instead of linear search.  *		    Other cleanups.  *  *  * BUGS  *  * Currently mallocs memory in a very haphazard manner.  As such, most of  * the program ends up core-resident all the time just to follow all the  * stupid pointers around. . . .  *  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS40
end_ifdef

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"bootpd.h"
end_include

begin_define
define|#
directive|define
name|HASHTABLESIZE
value|257
end_define

begin_comment
comment|/* Hash table size (prime) */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_TIMEOUT
value|15L
end_define

begin_comment
comment|/* Default timeout in minutes */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_FILE
end_ifndef

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/etc/bootptab"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DUMP_FILE
end_ifndef

begin_define
define|#
directive|define
name|DUMP_FILE
value|"/etc/bootpd.dump"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Externals, forward declarations, and global variables  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_u_long
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_host
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|list_ipaddresses
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|VEND_CMU
end_ifdef

begin_function_decl
name|void
name|dovend_cmu
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|dovend_rfc1048
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|boolean
name|hwlookcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|boolean
name|iplookcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_generic
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_ip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dumptab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chk_access
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|report
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|get_errmsg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * IP port numbers for client and server obtained from /etc/services  */
end_comment

begin_decl_stmt
name|u_short
name|bootps_port
decl_stmt|,
name|bootpc_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internet socket and interface config structures  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|s_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet source */
end_comment

begin_decl_stmt
name|struct
name|ifreq
name|ifreq
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds interface configuration */
end_comment

begin_decl_stmt
name|struct
name|ifconf
name|ifconf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Int. config ioctl block (pnts to ifreq) */
end_comment

begin_decl_stmt
name|struct
name|arpreq
name|arpreq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arp request ioctl block */
end_comment

begin_comment
comment|/*  * General  */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging flag (level) */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket file descriptor */
end_comment

begin_decl_stmt
name|byte
name|buf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receive packet buffer */
end_comment

begin_decl_stmt
name|struct
name|timezone
name|tzp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time zone offset for clients */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|tp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time (extra baggage) */
end_comment

begin_decl_stmt
name|long
name|secondswest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time zone offset in seconds */
end_comment

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System host name */
end_comment

begin_comment
comment|/*  * Globals below are associated with the bootp database file (bootptab).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootptab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|bootpd_dump
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Vendor magic cookies for CMU and RFC1048  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|vm_cmu
index|[
literal|4
index|]
init|=
name|VM_CMU
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|vm_rfc1048
index|[
literal|4
index|]
init|=
name|VM_RFC1048
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hardware address lengths (in bytes) and network name based on hardware  * type code.  List in order specified by Assigned Numbers RFC; Array index  * is hardware type code.  Entries marked as zero are unknown to the author  * at this time.  .  .  .  */
end_comment

begin_decl_stmt
name|struct
name|hwinfo
name|hwinfolist
index|[
name|MAXHTYPES
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|0
block|,
literal|"Reserved"
block|}
block|,
comment|/* Type 0:  Reserved (don't use this)   */
block|{
literal|6
block|,
literal|"Ethernet"
block|}
block|,
comment|/* Type 1:  10Mb Ethernet (48 bits)	*/
block|{
literal|1
block|,
literal|"3Mb Ethernet"
block|}
block|,
comment|/* Type 2:   3Mb Ethernet (8 bits)	*/
block|{
literal|0
block|,
literal|"AX.25"
block|}
block|,
comment|/* Type 3:  Amateur Radio AX.25		*/
block|{
literal|1
block|,
literal|"ProNET"
block|}
block|,
comment|/* Type 4:  Proteon ProNET Token Ring   */
block|{
literal|0
block|,
literal|"Chaos"
block|}
block|,
comment|/* Type 5:  Chaos			*/
block|{
literal|6
block|,
literal|"IEEE 802"
block|}
block|,
comment|/* Type 6:  IEEE 802 Networks		*/
block|{
literal|0
block|,
literal|"ARCNET"
block|}
comment|/* Type 7:  ARCNET			*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main hash tables  */
end_comment

begin_decl_stmt
name|hash_tbl
modifier|*
name|hwhashtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hash_tbl
modifier|*
name|iphashtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hash_tbl
modifier|*
name|nmhashtable
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Initialization such as command-line processing is done and then the main  * server loop is started.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|timeval
name|actualtimeout
decl_stmt|,
modifier|*
name|timeout
decl_stmt|;
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|servent
modifier|*
name|servp
decl_stmt|;
name|char
modifier|*
name|stmp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|tolen
decl_stmt|,
name|fromlen
decl_stmt|;
name|int
name|nfound
decl_stmt|,
name|readfds
decl_stmt|;
name|int
name|standalone
decl_stmt|;
name|stmp
operator|=
name|NULL
expr_stmt|;
name|standalone
operator|=
name|FALSE
expr_stmt|;
name|actualtimeout
operator|.
name|tv_usec
operator|=
literal|0L
expr_stmt|;
name|actualtimeout
operator|.
name|tv_sec
operator|=
literal|60
operator|*
name|DEFAULT_TIMEOUT
expr_stmt|;
name|timeout
operator|=
operator|&
name|actualtimeout
expr_stmt|;
comment|/*      * Assume a socket was passed to us from inetd.      *      * Use getsockname() to determine if descriptor 0 is indeed a socket      * (and thus we are probably a child of inetd) or if it is instead      * something else and we are running standalone.      */
name|s
operator|=
literal|0
expr_stmt|;
name|tolen
operator|=
sizeof|sizeof
argument_list|(
name|s_in
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|s_in
argument_list|,
name|tolen
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|&
name|s_in
argument_list|,
operator|&
name|tolen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Descriptor 0 is a socket.  Assume we're running as a child of inetd. 	 */
name|bootps_port
operator|=
name|ntohs
argument_list|(
name|s_in
operator|.
name|sin_port
argument_list|)
expr_stmt|;
name|standalone
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTSOCK
condition|)
block|{
comment|/* 	     * Descriptor 0 is NOT a socket.  Run in standalone mode. 	     */
name|standalone
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Something else went wrong.  Punt. 	     */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: getsockname: %s\n"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Read switches.      */
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'t'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: invalid timeout specification\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|actualtimeout
operator|.
name|tv_sec
operator|=
call|(
name|long
call|)
argument_list|(
literal|60
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* 		     * If the actual timeout is zero, pass a NULL pointer 		     * to select so it blocks indefinitely, otherwise, 		     * point to the actual timeout value. 		     */
name|timeout
operator|=
operator|(
name|n
operator|>
literal|0
operator|)
condition|?
operator|&
name|actualtimeout
else|:
name|NULL
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
block|{
name|stmp
operator|=
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * Backwards-compatible behavior: 			 * no parameter, so just increment the debug flag. 			 */
name|debug
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stmp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stmp
operator|||
operator|(
name|sscanf
argument_list|(
name|stmp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: invalid debug level\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|debug
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|standalone
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|standalone
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: unknown switch: -%c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bootptab
condition|)
block|{
name|bootptab
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|}
elseif|else
if|if
condition|(
operator|!
name|bootpd_dump
condition|)
block|{
name|bootpd_dump
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: unknown argument: %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Get hostname.      */
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: can't get hostname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set default file names if not specified on command line      */
if|if
condition|(
operator|!
name|bootptab
condition|)
block|{
name|bootptab
operator|=
name|CONFIG_FILE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|bootpd_dump
condition|)
block|{
name|bootpd_dump
operator|=
name|DUMP_FILE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|standalone
condition|)
block|{
comment|/* 	 * Go into background and disassociate from controlling terminal. 	 */
if|if
condition|(
name|debug
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|10
condition|;
name|n
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|n
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|n
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Nuke any timeout value 	 */
name|timeout
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSLOG
comment|/*      * Initialize logging.      */
ifndef|#
directive|ifndef
name|LOG_CONS
define|#
directive|define
name|LOG_CONS
value|0
comment|/* Don't bother if not defined... */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LOG_DAEMON
define|#
directive|define
name|LOG_DAEMON
value|0
endif|#
directive|endif
name|openlog
argument_list|(
literal|"bootpd"
argument_list|,
name|LOG_PID
operator||
name|LOG_CONS
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Log startup      */
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/*      * Get our timezone offset so we can give it to clients if the      * configuration file doesn't specify one.      */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|secondswest
operator|=
literal|0L
expr_stmt|;
comment|/* Assume GMT for lack of anything better */
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday: %s\n"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|secondswest
operator|=
literal|60L
operator|*
name|tzp
operator|.
name|tz_minuteswest
expr_stmt|;
comment|/* Convert to seconds */
block|}
comment|/*      * Allocate hash tables for hardware address, ip address, and hostname      */
name|hwhashtable
operator|=
name|hash_Init
argument_list|(
name|HASHTABLESIZE
argument_list|)
expr_stmt|;
name|iphashtable
operator|=
name|hash_Init
argument_list|(
name|HASHTABLESIZE
argument_list|)
expr_stmt|;
name|nmhashtable
operator|=
name|hash_Init
argument_list|(
name|HASHTABLESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hwhashtable
operator|&&
name|iphashtable
operator|&&
name|nmhashtable
operator|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to allocate hash tables.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Read the bootptab file once immediately upon startup.      */
name|readtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|standalone
condition|)
block|{
comment|/* 	 * Create a socket. 	 */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %s\n"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get server's listening port number 	 */
name|servp
operator|=
name|getservbyname
argument_list|(
literal|"bootps"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|servp
condition|)
block|{
name|bootps_port
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|servp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udp/bootps: unknown service -- assuming port %d\n"
argument_list|,
name|IPPORT_BOOTPS
argument_list|)
expr_stmt|;
name|bootps_port
operator|=
operator|(
name|u_short
operator|)
name|IPPORT_BOOTPS
expr_stmt|;
block|}
comment|/* 	 * Bind socket to BOOTPS port. 	 */
name|s_in
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s_in
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|s_in
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootps_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|&
name|s_in
argument_list|,
sizeof|sizeof
argument_list|(
name|s_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %s\n"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Get destination port number so we can reply to client      */
name|servp
operator|=
name|getservbyname
argument_list|(
literal|"bootpc"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|servp
condition|)
block|{
name|bootpc_port
operator|=
name|ntohs
argument_list|(
name|servp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udp/bootpc: unknown service -- assuming port %d\n"
argument_list|,
name|IPPORT_BOOTPC
argument_list|)
expr_stmt|;
name|bootpc_port
operator|=
operator|(
name|u_short
operator|)
name|IPPORT_BOOTPC
expr_stmt|;
block|}
comment|/*      * Determine network configuration.      */
name|ifconf
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
expr_stmt|;
name|ifconf
operator|.
name|ifc_req
operator|=
name|ifreq
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifconf
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|ifconf
operator|.
name|ifc_len
operator|<=
literal|0
operator|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl: %s\n"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set up signals to read or dump the table.      */
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|readtab
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"signal: %s\n"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|dumptab
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"signal: %s\n"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Process incoming requests.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|readfds
operator|=
literal|1
operator|<<
name|s
expr_stmt|;
name|nfound
operator|=
name|select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfound
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %s\n"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|readfds
operator|&
operator|(
literal|1
operator|<<
name|s
operator|)
operator|)
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"exiting after %ld minutes of inactivity\n"
argument_list|,
name|actualtimeout
operator|.
name|tv_sec
operator|/
literal|60
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"received short packet\n"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|readtab
argument_list|()
expr_stmt|;
comment|/* maybe re-read bootptab */
switch|switch
condition|(
name|bp
operator|->
name|bp_op
condition|)
block|{
case|case
name|BOOTREQUEST
case|:
name|request
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOTREPLY
case|:
name|reply
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Print "usage" message and exit  */
end_comment

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  bootpd [-d level] [-i] [-s] [-t timeout] [configfile [dumpfile]]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -d n\tset debug level\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -i\tforce inetd mode (run as child of inetd)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -s\tforce standalone mode (run without inetd)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t -t n\tset inetd exit timeout to n minutes\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Process BOOTREQUEST packet.  *  * (Note, this version of the bootpd.c server never forwards   * the request to another server.  In our environment the   * stand-alone gateways perform that function.)  *  * (Also this version does not interpret the hostname field of  * the request packet;  it COULD do a name->address lookup and  * forward the request there.)  */
end_comment

begin_macro
name|request
argument_list|()
end_macro

begin_block
block|{
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|host
name|dummyhost
decl_stmt|;
name|long
name|bootsize
decl_stmt|;
name|unsigned
name|hlen
decl_stmt|,
name|hashcode
decl_stmt|;
name|char
name|realpath
index|[
literal|1024
index|]
decl_stmt|;
comment|/*      * If the servername field is set, compare it against us.      * If we're not being addressed, ignore this request.      * If the server name field is null, throw in our name.      */
if|if
condition|(
name|strlen
argument_list|(
name|bp
operator|->
name|bp_sname
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|bp_sname
argument_list|,
name|hostname
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|bp_sname
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|bp_op
operator|=
name|BOOTREPLY
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* 	 * client doesnt know his IP address,  	 * search by hardware address. 	 */
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request from %s address %s\n"
argument_list|,
name|netname
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dummyhost
operator|.
name|htype
operator|=
name|bp
operator|->
name|bp_htype
expr_stmt|;
name|hlen
operator|=
name|haddrlength
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|dummyhost
operator|.
name|haddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|hwhashtable
argument_list|,
name|hashcode
argument_list|,
name|hwlookcmp
argument_list|,
operator|&
name|dummyhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s address not found: %s\n"
argument_list|,
name|netname
argument_list|(
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|,
name|haddrtoa
argument_list|(
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|bp
operator|->
name|bp_htype
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* not found */
block|}
operator|(
name|bp
operator|->
name|bp_yiaddr
operator|)
operator|.
name|s_addr
operator|=
name|hp
operator|->
name|iaddr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * search by IP address. 	 */
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"request from IP addr %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_ciaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dummyhost
operator|.
name|iaddr
operator|.
name|s_addr
operator|=
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
expr_stmt|;
name|hashcode
operator|=
name|hash_HashFunction
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_Lookup
argument_list|(
name|iphashtable
argument_list|,
name|hashcode
argument_list|,
name|iplookcmp
argument_list|,
operator|&
name|dummyhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"IP address not found: %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|bp
operator|->
name|bp_ciaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"found %s %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|hp
operator|->
name|iaddr
argument_list|)
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
comment|/*      * If a specific TFTP server address was specified in the bootptab file,      * fill it in, otherwise zero it.      */
operator|(
name|bp
operator|->
name|bp_siaddr
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|hp
operator|->
name|flags
operator|.
name|bootserver
operator|)
condition|?
name|hp
operator|->
name|bootserver
operator|.
name|s_addr
else|:
literal|0L
expr_stmt|;
comment|/*      * This next line is a bit of a mystery.  It seems to be vestigial      * code (from Stanford???) which should probably be axed.      */
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
literal|"sunboot14"
argument_list|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* pretend it's null */
comment|/*      * Fill in the client's proper bootfile.      *      * If the client specifies an absolute path, try that file with a      * ".host" suffix and then without.  If the file cannot be found, no      * reply is made at all.      *      * If the client specifies a null or relative file, use the following      * table to determine the appropriate action:      *      *  Homedir      Bootfile    Client's file      * specified?   specified?   specification   Action      * -------------------------------------------------------------------      *      No          No          Null         Send null filename      *      No          No          Relative     Discard request      *      No          Yes         Null         Send if absolute else null      *      No          Yes         Relative     Discard request      *      Yes         No          Null         Send null filename      *      Yes         No          Relative     Lookup with ".host"      *      Yes         Yes         Null         Send home/boot or bootfile      *      Yes         Yes         Relative     Lookup with ".host"      *      */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|tftpdir
condition|)
block|{
name|strcpy
argument_list|(
name|realpath
argument_list|,
name|hp
operator|->
name|tftpdir
operator|->
name|string
argument_list|)
expr_stmt|;
name|path
operator|=
operator|&
name|realpath
index|[
name|strlen
argument_list|(
name|realpath
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|realpath
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
condition|)
block|{
comment|/* 	 * The client specified a file. 	 */
if|if
condition|(
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|bp
operator|->
name|bp_file
argument_list|)
expr_stmt|;
comment|/* Absolute pathname */
block|}
else|else
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|homedir
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|hp
operator|->
name|homedir
operator|->
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|bp
operator|->
name|bp_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"requested file \"%s\" not found: hd unspecified\n"
argument_list|,
name|bp
operator|->
name|bp_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * No file specified by the client. 	 */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootfile
operator|&&
operator|(
operator|(
name|hp
operator|->
name|bootfile
operator|->
name|string
operator|)
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|hp
operator|->
name|bootfile
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|homedir
operator|&&
name|hp
operator|->
name|flags
operator|.
name|bootfile
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|hp
operator|->
name|homedir
operator|->
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|hp
operator|->
name|bootfile
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip_file
goto|;
comment|/* Don't bother trying to access the file */
block|}
block|}
comment|/*      * First try to find the file with a ".host" suffix      */
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_access
argument_list|(
name|realpath
argument_list|,
operator|&
name|bootsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|path
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Try it without the suffix */
if|if
condition|(
name|chk_access
argument_list|(
name|realpath
argument_list|,
operator|&
name|bootsize
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_file
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Client wanted specific file 		 * and we didn't have it. 		 */
name|report
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"requested file not found: \"%s\"\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 		 * Client didn't ask for a specific file and we couldn't 		 * access the default file, so just zero-out the bootfile 		 * field in the packet and continue processing the reply. 		 */
name|bzero
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip_file
goto|;
block|}
block|}
block|}
name|strcpy
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|skip_file
label|:
empty_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vendor magic field is %d.%d.%d.%d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|1
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|2
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bp
operator|->
name|bp_vend
operator|)
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * If this host isn't set for automatic vendor info then copy the      * specific cookie into the bootp packet, thus forcing a certain      * reply format.      */
if|if
condition|(
operator|!
name|hp
operator|->
name|flags
operator|.
name|vm_auto
condition|)
block|{
name|bcopy
argument_list|(
name|hp
operator|->
name|vm_cookie
argument_list|,
name|bp
operator|->
name|bp_vend
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/*      * Figure out the format for the vendor-specific info.      */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|,
name|vm_cmu
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* Not an RFC1048 bootp client */
ifdef|#
directive|ifdef
name|VEND_CMU
name|dovend_cmu
argument_list|(
name|bp
argument_list|,
name|hp
argument_list|)
expr_stmt|;
else|#
directive|else
name|dovend_rfc1048
argument_list|(
name|bp
argument_list|,
name|hp
argument_list|,
name|bootsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* RFC1048 conformant bootp client */
name|dovend_rfc1048
argument_list|(
name|bp
argument_list|,
name|hp
argument_list|,
name|bootsize
argument_list|)
expr_stmt|;
block|}
name|sendreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process BOOTREPLY packet (something is using us as a gateway).  */
end_comment

begin_macro
name|reply
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"processing boot reply\n"
argument_list|)
expr_stmt|;
block|}
name|sendreply
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Send a reply packet to the client.  'forward' flag is set if we are  * not the originator of this reply packet.  */
end_comment

begin_macro
name|sendreply
argument_list|(
argument|forward
argument_list|)
end_macro

begin_decl_stmt
name|int
name|forward
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|bootp
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bootp
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|in_addr
name|dst
decl_stmt|;
name|struct
name|sockaddr_in
name|to
decl_stmt|;
name|to
operator|=
name|s_in
expr_stmt|;
name|to
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootpc_port
argument_list|)
expr_stmt|;
comment|/* 	 * If the client IP address is specified, use that 	 * else if gateway IP address is specified, use that 	 * else make a temporary arp cache entry for the client's NEW  	 * IP/hardware address and use that. 	 */
if|if
condition|(
name|bp
operator|->
name|bp_ciaddr
operator|.
name|s_addr
condition|)
block|{
name|dst
operator|=
name|bp
operator|->
name|bp_ciaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bp_giaddr
operator|.
name|s_addr
operator|&&
name|forward
operator|==
literal|0
condition|)
block|{
name|dst
operator|=
name|bp
operator|->
name|bp_giaddr
expr_stmt|;
name|to
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|bootps_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|=
name|bp
operator|->
name|bp_yiaddr
expr_stmt|;
name|setarp
argument_list|(
operator|&
name|dst
argument_list|,
name|bp
operator|->
name|bp_chaddr
argument_list|,
name|bp
operator|->
name|bp_hlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forward
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If we are originating this reply, we 		 * need to find our own interface address to 		 * put in the bp_siaddr field of the reply. 		 * If this server is multi-homed, pick the 		 * 'best' interface (the one on the same net 		 * as the client). 		 */
if|#
directive|if
literal|0
block|int maxmatch = 0; 		int len, m; 		struct ifreq *ifrq, *ifrmax;  		ifrmax = ifrq =&ifreq[0]; 		len = ifconf.ifc_len; 		for (; len> 0; len -= sizeof(ifreq[0]), ifrq++) { 			m = nmatch(&dst,&((struct sockaddr_in *) 					  (&ifrq->ifr_addr))->sin_addr); 			if (m> maxmatch) { 				maxmatch = m; 				ifrmax = ifrq; 			} 		}
endif|#
directive|endif
name|int
name|maxmatch
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifrq
decl_stmt|,
modifier|*
name|ifrmax
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ifrmax
operator|=
operator|&
name|ifreq
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|ifconf
operator|.
name|ifc_len
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
control|)
block|{
name|ifrq
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|p
expr_stmt|;
name|m
operator|=
name|nmatch
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|ifrq
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
name|maxmatch
condition|)
block|{
name|maxmatch
operator|=
name|m
expr_stmt|;
name|ifrmax
operator|=
name|ifrq
expr_stmt|;
block|}
name|p
operator|+=
name|ifrq
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|+
name|IFNAMSIZ
expr_stmt|;
name|len
operator|-=
name|ifrq
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|+
name|IFNAMSIZ
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_giaddr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|maxmatch
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|bp
operator|->
name|bp_giaddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|ifrmax
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
expr_stmt|;
block|}
comment|/* 		 * If a specific TFTP server address wasn't specified 		 * in the bootptab file, fill in our own address. 		 */
if|if
condition|(
name|bp
operator|->
name|bp_siaddr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|bp_siaddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|ifrmax
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
expr_stmt|;
block|}
block|}
name|to
operator|.
name|sin_addr
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|s
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %s\n"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Return the number of leading bytes matching in the  * internet addresses supplied.  */
end_comment

begin_macro
name|nmatch
argument_list|(
argument|ca
argument_list|,
argument|cb
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ca
decl_stmt|,
modifier|*
name|cb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ca
operator|++
operator|!=
operator|*
name|cb
operator|++
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|m
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Setup the arp cache so that IP address 'ia' will be temporarily  * bound to hardware address 'ha' of length 'len'.  */
end_comment

begin_macro
name|setarp
argument_list|(
argument|ia
argument_list|,
argument|ha
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|ia
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|byte
modifier|*
name|ha
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_in
modifier|*
name|si
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|arpreq
argument_list|,
sizeof|sizeof
argument_list|(
name|arpreq
argument_list|)
argument_list|)
expr_stmt|;
name|arpreq
operator|.
name|arp_pa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|si
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|arpreq
operator|.
name|arp_pa
expr_stmt|;
name|si
operator|->
name|sin_addr
operator|=
operator|*
name|ia
expr_stmt|;
name|arpreq
operator|.
name|arp_flags
operator|=
name|ATF_INUSE
operator||
name|ATF_COM
expr_stmt|;
name|bcopy
argument_list|(
name|ha
argument_list|,
name|arpreq
operator|.
name|arp_ha
operator|.
name|sa_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSARP
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arpreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(SIOCSARP): %s\n"
argument_list|,
name|get_network_errmsg
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * This call checks read access to a file.  It returns 0 if the file given  * by "path" exists and is publically readable.  A value of -1 is returned if  * access is not permitted or an error occurs.  Successful calls also  * return the file size in bytes using the long pointer "filesize".  *  * The read permission bit for "other" users is checked.  This bit must be  * set for tftpd(8) to allow clients to read the file.  */
end_comment

begin_function
name|int
name|chk_access
parameter_list|(
name|path
parameter_list|,
name|filesize
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|long
modifier|*
name|filesize
decl_stmt|;
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|buf
operator|.
name|st_mode
operator|&
operator|(
name|S_IREAD
operator|>>
literal|6
operator|)
operator|)
condition|)
block|{
operator|*
name|filesize
operator|=
operator|(
name|long
operator|)
name|buf
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Dump the internal memory database to bootpd_dump.  */
end_comment

begin_macro
name|dumptab
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|long
name|t
decl_stmt|;
comment|/*      * Open bootpd.dump file.      */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bootpd_dump
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error opening \"%s\": %s\n"
argument_list|,
name|bootpd_dump
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n# %s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s: dump of bootp server database.\n"
argument_list|,
name|bootpd_dump
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\n# Dump taken %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\n#\n# Legend:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tbf -- bootfile\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tbs -- bootfile size in 512-octet blocks\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tcs -- cookie servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tdf -- dump file name\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tdn -- domain name\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tds -- domain name servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tgw -- gateways\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tha -- hardware address\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\thd -- home directory for bootfiles\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tht -- hardware type\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tim -- impress servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tip -- host IP address\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tlg -- log servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tlp -- LPR servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tns -- IEN-116 name servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\trl -- resource location protocol servers\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\trp -- root path\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tsm -- subnet mask\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tsw -- swap server\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tto -- time offset (seconds)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\tts -- time servers\n\n\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_FirstEntry
argument_list|(
name|nmhashtable
argument_list|)
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|(
expr|struct
name|host
operator|*
operator|)
name|hash_NextEntry
argument_list|(
name|nmhashtable
argument_list|)
control|)
block|{
name|dump_host
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"dumped %d entries to \"%s\".\n"
argument_list|,
name|n
argument_list|,
name|bootpd_dump
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Dump all the available information on the host pointed to by "hp".  * The output is sent to the file pointed to by "fp".  */
end_comment

begin_function
name|void
name|dump_host
parameter_list|(
name|fp
parameter_list|,
name|hp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|byte
modifier|*
name|dataptr
decl_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|hostname
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:"
argument_list|,
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootfile
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"bf=%s:"
argument_list|,
name|hp
operator|->
name|bootfile
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootsize
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"bs="
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"auto:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d:"
argument_list|,
name|hp
operator|->
name|bootsize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|cookie_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"cs="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|cookie_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ds="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|domain_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"gw="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|gateway
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|homedir
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hd=%s:"
argument_list|,
name|hp
operator|->
name|homedir
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|&&
name|hp
operator|->
name|flags
operator|.
name|send_name
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hn:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|htype
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ht=%u:"
argument_list|,
operator|(
name|unsigned
operator|)
name|hp
operator|->
name|htype
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|haddr
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ha=%s:"
argument_list|,
name|haddrtoa
argument_list|(
name|hp
operator|->
name|haddr
argument_list|,
name|hp
operator|->
name|htype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|impress_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"im="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|impress_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|swap_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"sw=%s:"
argument_list|,
name|inet_ntoa
argument_list|(
name|hp
operator|->
name|subnet_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|iaddr
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ip=%s:"
argument_list|,
name|inet_ntoa
argument_list|(
name|hp
operator|->
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|log_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"lg="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|log_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|lpr_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"lp="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|lpr_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ns="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|name_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rlp_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"rl="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|rlp_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootserver
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"sa=%s:"
argument_list|,
name|inet_ntoa
argument_list|(
name|hp
operator|->
name|bootserver
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"sm=%s:"
argument_list|,
name|inet_ntoa
argument_list|(
name|hp
operator|->
name|subnet_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|tftpdir
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"td=%s:"
argument_list|,
name|hp
operator|->
name|tftpdir
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rootpath
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"rp=%s:"
argument_list|,
name|hp
operator|->
name|rootpath
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domainname
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"dn=%s:"
argument_list|,
name|hp
operator|->
name|domainname
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|dumpfile
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"df=%s:"
argument_list|,
name|hp
operator|->
name|dumpfile
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_offset
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|timeoff_auto
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"to=auto:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"to=%ld:"
argument_list|,
name|hp
operator|->
name|time_offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ts="
argument_list|)
expr_stmt|;
name|list_ipaddresses
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|time_server
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|vendor_magic
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"vm="
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|vm_auto
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"auto:"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|hp
operator|->
name|vm_cookie
argument_list|,
name|vm_cmu
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"cmu:"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|hp
operator|->
name|vm_cookie
argument_list|,
name|vm_rfc1048
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"rfc1048"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d.%d.%d.%d:"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|hp
operator|->
name|vm_cookie
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|hp
operator|->
name|vm_cookie
operator|)
index|[
literal|1
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|hp
operator|->
name|vm_cookie
operator|)
index|[
literal|2
index|]
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|hp
operator|->
name|vm_cookie
operator|)
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|generic
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"generic="
argument_list|)
expr_stmt|;
name|dataptr
operator|=
name|hp
operator|->
name|generic
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hp
operator|->
name|generic
operator|->
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%02X"
argument_list|,
operator|(
name|int
operator|)
operator|*
name|dataptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Dump an entire struct in_addr_list of IP addresses to the indicated file.  *  * The addresses are printed in standard ASCII "dot" notation and separated  * from one another by a single space.  A single leading space is also  * printed before the first adddress.  *  * Null lists produce no output (and no error).  */
end_comment

begin_function
name|void
name|list_ipaddresses
parameter_list|(
name|fp
parameter_list|,
name|ipptr
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|ipptr
decl_stmt|;
block|{
name|unsigned
name|count
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|addrptr
decl_stmt|;
if|if
condition|(
name|ipptr
condition|)
block|{
name|count
operator|=
name|ipptr
operator|->
name|addrcount
expr_stmt|;
name|addrptr
operator|=
name|ipptr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|addrptr
operator|++
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|addrptr
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VEND_CMU
end_ifdef

begin_comment
comment|/*  * Insert the CMU "vendor" data for the host pointed to by "hp" into the  * bootp packet pointed to by "bp".  */
end_comment

begin_function
name|void
name|dovend_cmu
parameter_list|(
name|bp
parameter_list|,
name|hp
parameter_list|)
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|struct
name|cmu_vend
modifier|*
name|vendp
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|taddr
decl_stmt|;
comment|/*      * Initialize the entire vendor field to zeroes.      */
name|bzero
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Fill in vendor information. Subnet mask, default gateway,      * domain name server, ien name server, time server      */
name|vendp
operator|=
operator|(
expr|struct
name|cmu_vend
operator|*
operator|)
name|bp
operator|->
name|bp_vend
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_smask
operator|)
operator|.
name|s_addr
operator|=
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
expr_stmt|;
operator|(
name|vendp
operator|->
name|v_flags
operator|)
operator||=
name|VF_SMASK
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_dgate
operator|)
operator|.
name|s_addr
operator|=
name|hp
operator|->
name|gateway
operator|->
name|addr
operator|->
name|s_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
name|taddr
operator|=
name|hp
operator|->
name|domain_server
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|0
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_dns1
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|1
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_dns2
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
name|taddr
operator|=
name|hp
operator|->
name|name_server
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|0
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ins1
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|1
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ins2
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
name|taddr
operator|=
name|hp
operator|->
name|time_server
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|0
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ts1
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|taddr
operator|->
name|addrcount
operator|>
literal|1
condition|)
block|{
operator|(
name|vendp
operator|->
name|v_ts2
operator|)
operator|.
name|s_addr
operator|=
operator|(
name|taddr
operator|->
name|addr
operator|)
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
block|}
name|strcpy
argument_list|(
name|vendp
operator|->
name|v_magic
argument_list|,
name|vm_cmu
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sending CMU-style reply\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VEND_CMU */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Insert the RFC1048 vendor data for the host pointed to by "hp" into the  * bootp packet pointed to by "bp".  */
end_comment

begin_function
name|void
name|dovend_rfc1048
parameter_list|(
name|bp
parameter_list|,
name|hp
parameter_list|,
name|bootsize
parameter_list|)
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|long
name|bootsize
decl_stmt|;
block|{
name|int
name|bytesleft
decl_stmt|,
name|len
decl_stmt|;
name|byte
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|bp_vend
expr_stmt|;
name|bytesleft
operator|=
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|)
expr_stmt|;
comment|/* Initial vendor area size */
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|vp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Copy in the magic cookie */
name|vp
operator|+=
literal|4
expr_stmt|;
name|bytesleft
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_offset
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_TIME_OFFSET
expr_stmt|;
comment|/* -1 byte  */
operator|*
name|vp
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* -1 byte  */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|timeoff_auto
condition|)
block|{
name|insert_u_long
argument_list|(
name|htonl
argument_list|(
name|secondswest
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert_u_long
argument_list|(
name|htonl
argument_list|(
name|hp
operator|->
name|time_offset
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
comment|/* -4 bytes */
block|}
name|bytesleft
operator|-=
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|subnet_mask
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_SUBNET_MASK
expr_stmt|;
comment|/* -1 byte  */
operator|*
name|vp
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* -1 byte  */
name|insert_u_long
argument_list|(
name|hp
operator|->
name|subnet_mask
operator|.
name|s_addr
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
comment|/* -4 bytes */
name|bytesleft
operator|-=
literal|6
expr_stmt|;
comment|/* Fix real count */
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|gateway
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_GATEWAY
argument_list|,
name|hp
operator|->
name|gateway
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|bootsize
condition|)
block|{
name|bootsize
operator|=
operator|(
name|hp
operator|->
name|flags
operator|.
name|bootsize_auto
operator|)
condition|?
operator|(
operator|(
name|bootsize
operator|+
literal|511
operator|)
operator|/
literal|512
operator|)
else|:
operator|(
name|hp
operator|->
name|bootsize
operator|)
expr_stmt|;
comment|/* Round up */
operator|*
name|vp
operator|++
operator|=
name|TAG_BOOTSIZE
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|bootsize
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|bootsize
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bytesleft
operator|-=
literal|4
expr_stmt|;
comment|/* Tag, length, and 16 bit blocksize */
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|swap_server
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_SWAPSERVER
expr_stmt|;
comment|/* -1 byte  */
operator|*
name|vp
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* -1 byte  */
name|insert_u_long
argument_list|(
name|hp
operator|->
name|swapserver
operator|.
name|s_addr
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
comment|/* -4 bytes */
name|bytesleft
operator|-=
literal|6
expr_stmt|;
comment|/* Fix real count */
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rootpath
condition|)
block|{
comment|/* 	 * Check for room for rootpath.  Add 2 to account for 	 * TAG_ROOTPATH and length. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|rootpath
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|<=
name|bytesleft
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_ROOTPATH
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|rootpath
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|dumpfile
condition|)
block|{
comment|/* 	 * Check for room for dumpfile.  Add 2 to account for 	 * TAG_DUMPFILE and length. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|dumpfile
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|<=
name|bytesleft
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_DUMPFILE
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|dumpfile
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domain_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_DOMAIN_SERVER
argument_list|,
name|hp
operator|->
name|domain_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|domainname
condition|)
block|{
comment|/* 	 * Check for room for domainname.  Add 2 to account for 	 * TAG_DOMAINNAME and length. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|domainname
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|<=
name|bytesleft
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_DOMAINNAME
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|domainname
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_NAME_SERVER
argument_list|,
name|hp
operator|->
name|name_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|rlp_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_RLP_SERVER
argument_list|,
name|hp
operator|->
name|rlp_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|time_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_TIME_SERVER
argument_list|,
name|hp
operator|->
name|time_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|lpr_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_LPR_SERVER
argument_list|,
name|hp
operator|->
name|lpr_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|name_switch
operator|&&
name|hp
operator|->
name|flags
operator|.
name|send_name
condition|)
block|{
comment|/* 	 * Check for room for hostname.  Add 2 to account for 	 * TAG_HOSTNAME and length. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|>
name|bytesleft
condition|)
block|{
comment|/* 	     * Not enough room for full (domain-qualified) hostname, try 	     * stripping it down to just the first field (host). 	     */
name|tmpstr
operator|=
name|hp
operator|->
name|hostname
operator|->
name|string
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|tmpstr
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|tmpstr
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|<=
name|bytesleft
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_HOSTNAME
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|hostname
operator|->
name|string
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|len
expr_stmt|;
name|bytesleft
operator|-=
name|len
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|cookie_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_COOKIE_SERVER
argument_list|,
name|hp
operator|->
name|cookie_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|log_server
condition|)
block|{
name|insert_ip
argument_list|(
name|TAG_LOG_SERVER
argument_list|,
name|hp
operator|->
name|log_server
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|flags
operator|.
name|generic
condition|)
block|{
name|insert_generic
argument_list|(
name|hp
operator|->
name|generic
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesleft
operator|>=
literal|1
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
name|TAG_END
expr_stmt|;
name|bytesleft
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|report
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sending RFC1048-style reply\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesleft
operator|>
literal|0
condition|)
block|{
comment|/* 	 * Zero out any remaining part of the vendor area. 	 */
name|bzero
argument_list|(
name|vp
argument_list|,
name|bytesleft
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Compare function to determine whether two hardware addresses are  * equivalent.  Returns TRUE if "host1" and "host2" are equivalent, FALSE  * otherwise.  *  * This function is used when retrieving elements from the hardware address  * hash table.  */
end_comment

begin_function
name|boolean
name|hwlookcmp
parameter_list|(
name|host1
parameter_list|,
name|host2
parameter_list|)
name|struct
name|host
modifier|*
name|host1
decl_stmt|,
decl|*
name|host2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|host1
operator|->
name|htype
operator|!=
name|host2
operator|->
name|htype
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|host1
operator|->
name|haddr
argument_list|,
name|host2
operator|->
name|haddr
argument_list|,
name|haddrlength
argument_list|(
name|host1
operator|->
name|htype
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * Compare function for doing IP address hash table lookup.  */
end_comment

begin_function
name|boolean
name|iplookcmp
parameter_list|(
name|host1
parameter_list|,
name|host2
parameter_list|)
name|struct
name|host
modifier|*
name|host1
decl_stmt|,
decl|*
name|host2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|host1
operator|->
name|iaddr
operator|.
name|s_addr
operator|==
name|host2
operator|->
name|iaddr
operator|.
name|s_addr
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Insert a tag value, a length value, and a list of IP addresses into the  * memory buffer indirectly pointed to by "dest".  "tag" is the RFC1048 tag  * number to use, "iplist" is a pointer to a list of IP addresses  * (struct in_addr_list), and "bytesleft" points to an integer which  * indicates the size of the "dest" buffer.  The number of IP addresses  * actually inserted   *  * This is used to fill the vendor-specific area of a bootp packet in  * conformance to RFC1048.  */
end_comment

begin_function
name|void
name|insert_ip
parameter_list|(
name|tag
parameter_list|,
name|iplist
parameter_list|,
name|dest
parameter_list|,
name|bytesleft
parameter_list|)
name|byte
name|tag
decl_stmt|;
name|struct
name|in_addr_list
modifier|*
name|iplist
decl_stmt|;
name|byte
modifier|*
modifier|*
name|dest
decl_stmt|;
name|int
modifier|*
name|bytesleft
decl_stmt|;
block|{
name|struct
name|in_addr
modifier|*
name|addrptr
decl_stmt|;
name|unsigned
name|addrcount
decl_stmt|;
name|byte
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|iplist
operator|&&
operator|(
operator|*
name|bytesleft
operator|>=
literal|6
operator|)
condition|)
block|{
name|d
operator|=
operator|*
name|dest
expr_stmt|;
comment|/* Save pointer for later */
operator|*
operator|*
name|dest
operator|=
name|tag
expr_stmt|;
operator|(
operator|*
name|dest
operator|)
operator|+=
literal|2
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|-=
literal|2
expr_stmt|;
comment|/* Account for tag and length */
name|addrptr
operator|=
name|iplist
operator|->
name|addr
expr_stmt|;
name|addrcount
operator|=
name|iplist
operator|->
name|addrcount
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|bytesleft
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|addrcount
operator|>
literal|0
operator|)
condition|)
block|{
name|insert_u_long
argument_list|(
name|addrptr
operator|->
name|s_addr
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|addrptr
operator|++
expr_stmt|;
name|addrcount
operator|--
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|-=
literal|4
expr_stmt|;
comment|/* Four bytes per address */
block|}
name|d
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
operator|*
name|dest
operator|-
name|d
operator|-
literal|2
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Insert generic data into a bootp packet.  The data is assumed to already  * be in RFC1048 format.  It is inserted using a first-fit algorithm which  * attempts to insert as many tags as possible.  Tags and data which are  * too large to fit are skipped; any remaining tags are tried until they  * have all been exhausted.  */
end_comment

begin_function
name|void
name|insert_generic
parameter_list|(
name|gendata
parameter_list|,
name|buff
parameter_list|,
name|bytesleft
parameter_list|)
name|struct
name|shared_bindata
modifier|*
name|gendata
decl_stmt|;
name|byte
modifier|*
modifier|*
name|buff
decl_stmt|;
name|int
modifier|*
name|bytesleft
decl_stmt|;
block|{
name|byte
modifier|*
name|srcptr
decl_stmt|;
name|int
name|length
decl_stmt|,
name|numbytes
decl_stmt|;
if|if
condition|(
name|gendata
condition|)
block|{
name|srcptr
operator|=
name|gendata
operator|->
name|data
expr_stmt|;
name|length
operator|=
name|gendata
operator|->
name|length
expr_stmt|;
while|while
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|bytesleft
operator|>
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|srcptr
condition|)
block|{
case|case
name|TAG_END
case|:
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Force an exit on next iteration */
break|break;
case|case
name|TAG_PAD
case|:
operator|*
operator|(
operator|*
name|buff
operator|)
operator|++
operator|=
operator|*
name|srcptr
operator|++
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|--
expr_stmt|;
name|length
operator|--
expr_stmt|;
break|break;
default|default:
name|numbytes
operator|=
name|srcptr
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|bytesleft
operator|>=
name|numbytes
condition|)
block|{
name|bcopy
argument_list|(
name|srcptr
argument_list|,
operator|*
name|buff
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buff
operator|)
operator|+=
name|numbytes
expr_stmt|;
operator|(
operator|*
name|bytesleft
operator|)
operator|-=
name|numbytes
expr_stmt|;
block|}
name|srcptr
operator|+=
name|numbytes
expr_stmt|;
name|length
operator|-=
name|numbytes
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Convert a hardware address to an ASCII string.  */
end_comment

begin_function
name|char
modifier|*
name|haddrtoa
parameter_list|(
name|haddr
parameter_list|,
name|htype
parameter_list|)
name|byte
modifier|*
name|haddr
decl_stmt|;
name|byte
name|htype
decl_stmt|;
block|{
specifier|static
name|char
name|haddrbuf
index|[
literal|2
operator|*
name|MAXHADDRLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|bufptr
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|bufptr
operator|=
name|haddrbuf
expr_stmt|;
for|for
control|(
name|count
operator|=
name|haddrlength
argument_list|(
name|htype
argument_list|)
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|sprintf
argument_list|(
name|bufptr
argument_list|,
literal|"%02X"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|*
name|haddr
operator|++
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|haddrbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Insert the unsigned long "value" into memory starting at the byte  * pointed to by the byte pointer (*dest).  (*dest) is updated to  * point to the next available byte.  *  * Since it is desirable to internally store network addresses in network  * byte order (in struct in_addr's), this routine expects longs to be  * passed in network byte order.  *  * However, due to the nature of the main algorithm, the long must be in  * host byte order, thus necessitating the use of ntohl() first.  */
end_comment

begin_function
name|void
name|insert_u_long
parameter_list|(
name|value
parameter_list|,
name|dest
parameter_list|)
name|unsigned
name|long
name|value
decl_stmt|;
name|byte
modifier|*
modifier|*
name|dest
decl_stmt|;
block|{
name|byte
modifier|*
name|temp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|value
operator|=
name|ntohl
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Must use host byte order here */
name|temp
operator|=
operator|(
operator|*
name|dest
operator|+=
literal|4
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|4
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
operator|*
operator|--
name|temp
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
block|}
comment|/* Final result is network byte order */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Return pointer to static string which gives full filesystem error message.  */
end_comment

begin_function
name|char
modifier|*
name|get_errmsg
parameter_list|()
block|{
specifier|static
name|char
name|errmsg
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
block|{
return|return
name|sys_errlist
index|[
name|errno
index|]
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Error %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|errmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine reports errors and such via stderr and syslog() if  * appopriate.  It just helps avoid a lot of "#ifdef SYSLOG" constructs  * from being scattered throughout the code.  *  * The syntax is identical to syslog(3), but %m is not considered special  * for output to stderr (i.e. you'll see "%m" in the output. . .).  Also,  * control strings should normally end with \n since newlines aren't  * automatically generated for stderr output (whereas syslog strips out all  * newlines and adds its own at the end).  */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
name|void
name|report
parameter_list|(
name|priority
parameter_list|,
name|fmt
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|)
name|int
name|priority
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|LOG_SALERT
specifier|static
name|char
modifier|*
name|levelnames
index|[]
init|=
block|{
literal|"unknown level: "
block|,
literal|"alert(1):      "
block|,
literal|"subalert(2):   "
block|,
literal|"emergency(3):  "
block|,
literal|"error(4):      "
block|,
literal|"critical(5):   "
block|,
literal|"warning(6):    "
block|,
literal|"notice(7):     "
block|,
literal|"information(8):"
block|,
literal|"debug(9):      "
block|,
literal|"unknown level: "
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|char
modifier|*
name|levelnames
index|[]
init|=
block|{
literal|"emergency(0):  "
block|,
literal|"alert(1):      "
block|,
literal|"critical(2):   "
block|,
literal|"error(3):      "
block|,
literal|"warning(4):    "
block|,
literal|"notice(5):     "
block|,
literal|"information(6):"
block|,
literal|"debug(7):      "
block|,
literal|"unknown level: "
block|}
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|priority
operator|<
literal|0
operator|)
operator|||
operator|(
name|priority
operator|>=
sizeof|sizeof
argument_list|(
name|levelnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
condition|)
block|{
name|priority
operator|=
sizeof|sizeof
argument_list|(
name|levelnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/*      * Print the message      */
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bootpd: %s "
argument_list|,
name|levelnames
index|[
name|priority
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|p0
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|priority
argument_list|,
name|fmt
argument_list|,
name|p0
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

