begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * options.c - handles option processing for PPP.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: options.c,v 1.4 1994/02/08 23:48:50 paulus Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|setdebug
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpassive
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setsilent
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noopt
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnovj
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reqpap
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nopap
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setupapfile
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nochap
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reqchap
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setspeed
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noaccomp
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noasyncmap
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noipaddr
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomagicnumber
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setasyncmap
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setmru
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomru
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nopcomp
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setconnector
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdomain
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnetmask
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setcrtscts
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnodetach
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setmodem
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlocal
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setname
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setuser
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setremote
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setauth
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readfile
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdefaultroute
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setproxyarp
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpersist
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdologin
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setusehostname
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnoipdflt
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcptimeout
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpterm
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpconf
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpfails
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcptimeout
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpterm
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpconf
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpfails
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpaptimeout
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpapreqs
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setchaptimeout
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setchapchal
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setchapintv
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpaccl
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpaccr
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_option
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Option variables  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|modem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|crtscts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nodetach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|connector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inspeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|devname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|default_device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|netmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|user
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|passwd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|auth_required
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|proxyarp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|persist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|uselogin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|our_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|remote_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usehostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|disable_defaultip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Valid arguments.  */
end_comment

begin_struct
specifier|static
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmd_name
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|int
function_decl|(
modifier|*
name|cmd_func
function_decl|)
parameter_list|()
function_decl|;
block|}
name|cmds
index|[]
init|=
block|{
literal|"-all"
block|,
literal|0
block|,
name|noopt
block|,
comment|/* Don't request/allow any options */
literal|"-ac"
block|,
literal|0
block|,
name|noaccomp
block|,
comment|/* Disable Address/Control compress */
literal|"-am"
block|,
literal|0
block|,
name|noasyncmap
block|,
comment|/* Disable asyncmap negotiation */
literal|"-as"
block|,
literal|1
block|,
name|setasyncmap
block|,
comment|/* set the desired async map */
literal|"-d"
block|,
literal|0
block|,
name|setdebug
block|,
comment|/* Increase debugging level */
literal|"-detach"
block|,
literal|0
block|,
name|setnodetach
block|,
comment|/* don't fork */
literal|"-ip"
block|,
literal|0
block|,
name|noipaddr
block|,
comment|/* Disable IP address negotiation */
literal|"-mn"
block|,
literal|0
block|,
name|nomagicnumber
block|,
comment|/* Disable magic number negotiation */
literal|"-mru"
block|,
literal|0
block|,
name|nomru
block|,
comment|/* Disable mru negotiation */
literal|"-p"
block|,
literal|0
block|,
name|setpassive
block|,
comment|/* Set passive mode */
literal|"-pc"
block|,
literal|0
block|,
name|nopcomp
block|,
comment|/* Disable protocol field compress */
literal|"+ua"
block|,
literal|1
block|,
name|setupapfile
block|,
comment|/* Get PAP user and password from file */
literal|"+pap"
block|,
literal|0
block|,
name|reqpap
block|,
comment|/* Require PAP auth from peer */
literal|"-pap"
block|,
literal|0
block|,
name|nopap
block|,
comment|/* Don't allow UPAP authentication with peer */
literal|"+chap"
block|,
literal|0
block|,
name|reqchap
block|,
comment|/* Require CHAP authentication from peer */
literal|"-chap"
block|,
literal|0
block|,
name|nochap
block|,
comment|/* Don't allow CHAP authentication with peer */
literal|"-vj"
block|,
literal|0
block|,
name|setnovj
block|,
comment|/* disable VJ compression */
literal|"asyncmap"
block|,
literal|1
block|,
name|setasyncmap
block|,
comment|/* set the desired async map */
literal|"connect"
block|,
literal|1
block|,
name|setconnector
block|,
comment|/* A program to set up a connection */
literal|"crtscts"
block|,
literal|0
block|,
name|setcrtscts
block|,
comment|/* set h/w flow control */
literal|"debug"
block|,
literal|0
block|,
name|setdebug
block|,
comment|/* Increase debugging level */
literal|"domain"
block|,
literal|1
block|,
name|setdomain
block|,
comment|/* Add given domain name to hostname*/
literal|"mru"
block|,
literal|1
block|,
name|setmru
block|,
comment|/* Set MRU value for negotiation */
literal|"netmask"
block|,
literal|1
block|,
name|setnetmask
block|,
comment|/* set netmask */
literal|"passive"
block|,
literal|0
block|,
name|setpassive
block|,
comment|/* Set passive mode */
literal|"silent"
block|,
literal|0
block|,
name|setsilent
block|,
comment|/* Set silent mode */
literal|"modem"
block|,
literal|0
block|,
name|setmodem
block|,
comment|/* Use modem control lines */
literal|"local"
block|,
literal|0
block|,
name|setlocal
block|,
comment|/* Don't use modem control lines */
literal|"name"
block|,
literal|1
block|,
name|setname
block|,
comment|/* Set local name for authentication */
literal|"user"
block|,
literal|1
block|,
name|setuser
block|,
comment|/* Set username for PAP auth with peer */
literal|"usehostname"
block|,
literal|0
block|,
name|setusehostname
block|,
comment|/* Must use hostname for auth. */
literal|"remotename"
block|,
literal|1
block|,
name|setremote
block|,
comment|/* Set remote name for authentication */
literal|"auth"
block|,
literal|0
block|,
name|setauth
block|,
comment|/* Require authentication from peer */
literal|"file"
block|,
literal|1
block|,
name|readfile
block|,
comment|/* Take options from a file */
literal|"defaultroute"
block|,
literal|0
block|,
name|setdefaultroute
block|,
comment|/* Add default route */
literal|"proxyarp"
block|,
literal|0
block|,
name|setproxyarp
block|,
comment|/* Add proxy ARP entry */
literal|"persist"
block|,
literal|0
block|,
name|setpersist
block|,
comment|/* Keep on reopening connection after close */
literal|"login"
block|,
literal|0
block|,
name|setdologin
block|,
comment|/* Use system password database for UPAP */
literal|"noipdefault"
block|,
literal|0
block|,
name|setnoipdflt
block|,
comment|/* Don't use name for default IP adrs */
literal|"lcp-restart"
block|,
literal|1
block|,
name|setlcptimeout
block|,
comment|/* Set timeout for LCP */
literal|"lcp-max-terminate"
block|,
literal|1
block|,
name|setlcpterm
block|,
comment|/* Set max #xmits for term-reqs */
literal|"lcp-max-configure"
block|,
literal|1
block|,
name|setlcpconf
block|,
comment|/* Set max #xmits for conf-reqs */
literal|"lcp-max-failure"
block|,
literal|1
block|,
name|setlcpfails
block|,
comment|/* Set max #conf-naks for LCP */
literal|"ipcp-restart"
block|,
literal|1
block|,
name|setipcptimeout
block|,
comment|/* Set timeout for IPCP */
literal|"ipcp-max-terminate"
block|,
literal|1
block|,
name|setipcpterm
block|,
comment|/* Set max #xmits for term-reqs */
literal|"ipcp-max-configure"
block|,
literal|1
block|,
name|setipcpconf
block|,
comment|/* Set max #xmits for conf-reqs */
literal|"ipcp-max-failure"
block|,
literal|1
block|,
name|setipcpfails
block|,
comment|/* Set max #conf-naks for IPCP */
literal|"pap-restart"
block|,
literal|1
block|,
name|setpaptimeout
block|,
comment|/* Set timeout for UPAP */
literal|"pap-max-authreq"
block|,
literal|1
block|,
name|setpapreqs
block|,
comment|/* Set max #xmits for auth-reqs */
literal|"chap-restart"
block|,
literal|1
block|,
name|setchaptimeout
block|,
comment|/* Set timeout for CHAP */
literal|"chap-max-challenge"
block|,
literal|1
block|,
name|setchapchal
block|,
comment|/* Set max #xmits for challenge */
literal|"chap-interval"
block|,
literal|1
block|,
name|setchapintv
block|,
comment|/* Set interval for rechallenge */
literal|"ipcp-accept-local"
block|,
literal|0
block|,
name|setipcpaccl
block|,
comment|/* Accept peer's address for us */
literal|"ipcp-accept-remote"
block|,
literal|0
block|,
name|setipcpaccr
block|,
comment|/* Accept peer's address for it */
name|NULL
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|usage_string
init|=
literal|"\ pppd version %s patch level %d\n\ Usage: %s [ arguments ], where arguments are:\n\<device>	Communicate over the named device\n\<speed>		Set the baud rate to<speed>\n\<loc>:<rem>	Set the local and/or remote interface IP\n\ 			addresses.  Either one may be omitted.\n\ 	asyncmap<n>	Set the desired async map to hex<n>\n\ 	auth		Require authentication from peer\n\         connect<p>     Invoke shell command<p> to set up the serial line\n\ 	crtscts		Use hardware RTS/CTS flow control\n\ 	defaultroute	Add default route through interface\n\ 	file<f>	Take options from file<f>\n\ 	modem		Use modem control lines\n\ 	mru<n>		Set MRU value to<n> for negotiation\n\ 	netmask<n>	Set interface netmask to<n>\n\ See pppd(8) for more options.\n\ "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options omitted: 	-all		Don't request/allow any options\n\ 	-ac		Disable Address/Control compression\n\ 	-am		Disable asyncmap negotiation\n\ 	-as<n>		Set the desired async map to hex<n>\n\ 	-d		Increase debugging level\n\ 	-detach		Don't fork to background\n\ 	-ip		Disable IP address negotiation\n\ 	-mn		Disable magic number negotiation\n\ 	-mru		Disable mru negotiation\n\ 	-p		Set passive mode\n\ 	-pc		Disable protocol field compression\n\ 	+ua<f>		Get username and password for authenticating\n\ 			with peer using PAP from file<f>\n\ 	+pap		Require PAP authentication from peer\n\ 	-pap		Don't agree to authenticating with peer using PAP\n\ 	+chap		Require CHAP authentication from peer\n\ 	-chap		Don't agree to authenticating with peer using CHAP\n\         -vj             disable VJ compression\n\ 	-auth		Don't agree to authenticate with peer\n\ 	debug		Increase debugging level\n\         domain<d>      Append domain name<d> to hostname for authentication\n\ 	passive		Set passive mode\n\ 	local		Don't use modem control lines\n\ 	proxyarp	Add proxy ARP entry\n\ */
end_comment

begin_comment
comment|/*  * parse_args - parse a string of arguments, from the command  * line or from a file.  */
end_comment

begin_function
name|int
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|--
name|argc
expr_stmt|;
comment|/* 	 * First see if it's a command. 	 */
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd_name
condition|;
name|cmdp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|cmdp
operator|->
name|cmd_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cmdp
operator|->
name|cmd_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|argc
operator|<
name|cmdp
operator|->
name|num_args
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too few parameters for command %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|cmdp
operator|->
name|cmd_func
call|)
argument_list|(
name|argv
argument_list|)
condition|)
return|return
literal|0
return|;
name|argc
operator|-=
name|cmdp
operator|->
name|num_args
expr_stmt|;
name|argv
operator|+=
name|cmdp
operator|->
name|num_args
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Maybe a tty name, speed or IP address? 	     */
if|if
condition|(
operator|!
name|setdevname
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|setspeed
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|setipaddr
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized command\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * usage - print out a message telling how to use the program.  */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage_string
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * options_from_file - Read a string of options from a file,  * and interpret them.  */
end_comment

begin_function
name|int
name|options_from_file
parameter_list|(
name|filename
parameter_list|,
name|must_exist
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|must_exist
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|newline
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
name|char
name|args
index|[
name|MAXARGS
index|]
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|char
name|cmd
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|must_exist
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|1
return|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|getword
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
block|{
comment|/* 	 * First see if it's a command. 	 */
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd_name
condition|;
name|cmdp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
name|cmdp
operator|->
name|cmd_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cmdp
operator|->
name|cmd_name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdp
operator|->
name|num_args
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file %s: too few parameters for command %s\n"
argument_list|,
name|filename
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argv
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|cmdp
operator|->
name|cmd_func
call|)
argument_list|(
name|argv
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* 	     * Maybe a tty name, speed or IP address? 	     */
if|if
condition|(
operator|!
name|setdevname
argument_list|(
name|cmd
argument_list|)
operator|&&
operator|!
name|setspeed
argument_list|(
name|cmd
argument_list|)
operator|&&
operator|!
name|setipaddr
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file %s: unrecognized command %s\n"
argument_list|,
name|filename
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * options_from_user - See if the use has a ~/.ppprc file,  * and if so, interpret options from it.  */
end_comment

begin_function
name|int
name|options_from_user
parameter_list|()
block|{
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|user
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|file
operator|=
literal|"/.ppprc"
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"init file name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|options_from_file
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Read a word from a file.  * Words are delimited by white-space or by quotes (").  * Quotes, white-space and \ may be escaped with \.  * \<newline> is ignored.  */
end_comment

begin_function
name|int
name|getword
parameter_list|(
name|f
parameter_list|,
name|word
parameter_list|,
name|newlinep
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
name|int
modifier|*
name|newlinep
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|len
decl_stmt|,
name|escape
decl_stmt|;
name|int
name|quoted
decl_stmt|;
operator|*
name|newlinep
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|escape
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
comment|/*      * First skip white-space and comments      */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* 	     * \<newline> is ignored; \ followed by anything else 	     * starts a word. 	     */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
continue|continue;
name|word
index|[
name|len
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|escape
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|*
name|newlinep
operator|=
literal|1
expr_stmt|;
comment|/* next word starts a line */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* comment - ignore until EOF or \n */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|*
name|newlinep
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
comment|/*      * End of file or error - fail      */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Is this character escaped by \ ? 	 */
if|if
condition|(
name|escape
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|--
name|len
expr_stmt|;
comment|/* ignore \<newline> */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|word
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
comment|/* put special char in word */
else|else
block|{
if|if
condition|(
name|len
operator|<
name|MAXWORDLEN
operator|-
literal|1
condition|)
name|word
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|escape
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quoted
operator|&&
operator|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'#'
operator|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|<
name|MAXWORDLEN
operator|-
literal|1
condition|)
name|word
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escape
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
name|MAXWORDLEN
condition|)
block|{
name|word
index|[
name|MAXWORDLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: word in file %s too long (%.20s...)\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
name|word
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * number_option - parse a numeric parameter for an option  */
end_comment

begin_function
specifier|static
name|int
name|number_option
parameter_list|(
name|str
parameter_list|,
name|valp
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|long
modifier|*
name|valp
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
operator|*
name|valp
operator|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|ptr
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|str
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid number: %s\n"
argument_list|,
name|progname
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * int_option - like number_option, but valp is int *,  * the base is assumed to be 0, and *valp is not changed  * if there is an error.  */
end_comment

begin_function
specifier|static
name|int
name|int_option
parameter_list|(
name|str
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|valp
decl_stmt|;
block|{
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
name|str
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|valp
operator|=
operator|(
name|int
operator|)
name|v
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The following procedures execute commands.  */
end_comment

begin_comment
comment|/*  * readfile - take commands from a file.  */
end_comment

begin_function
specifier|static
name|int
name|readfile
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|options_from_file
argument_list|(
operator|*
name|argv
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdebug - Set debug (command line argument).  */
end_comment

begin_function
specifier|static
name|int
name|setdebug
parameter_list|()
block|{
name|debug
operator|++
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noopt - Disable all options.  */
end_comment

begin_function
specifier|static
name|int
name|noopt
parameter_list|()
block|{
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lcp_wantoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lcp_allowoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipcp_allowoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipcp_options
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noaccomp - Disable Address/Control field compression negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noaccomp
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_accompression
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_accompression
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noasyncmap - Disable async map negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noasyncmap
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noipaddr - Disable IP address negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noipaddr
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_addr
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_addr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nomagicnumber - Disable magic number negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nomagicnumber
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_magicnumber
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_magicnumber
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nomru - Disable mru negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nomru
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setmru - Set MRU for negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|setmru
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|long
name|mru
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|mru
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|mru
operator|=
name|mru
expr_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nopcomp - Disable Protocol field compression negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nopcomp
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_pcompression
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_pcompression
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setpassive - Set passive mode (don't give up if we time out sending  * LCP configure-requests).  */
end_comment

begin_function
specifier|static
name|int
name|setpassive
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|passive
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setsilent - Set silent mode (don't start sending LCP configure-requests  * until we get one from the peer).  */
end_comment

begin_function
specifier|static
name|int
name|setsilent
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|silent
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * nopap - Disable PAP authentication with peer.  */
end_comment

begin_function
specifier|static
name|int
name|nopap
parameter_list|()
block|{
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reqpap - Require PAP authentication from peer.  */
end_comment

begin_function
specifier|static
name|int
name|reqpap
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|1
expr_stmt|;
name|auth_required
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setupapfile - specifies UPAP info for authenticating with peer.  */
end_comment

begin_function
specifier|static
name|int
name|setupapfile
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|ufile
decl_stmt|;
name|int
name|l
decl_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|1
expr_stmt|;
comment|/* open user info file */
if|if
condition|(
operator|(
name|ufile
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to open user login data file %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|check_access
argument_list|(
name|ufile
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* get username */
if|if
condition|(
name|fgets
argument_list|(
name|user
argument_list|,
name|MAXNAMELEN
operator|-
literal|1
argument_list|,
name|ufile
argument_list|)
operator|==
name|NULL
operator|||
name|fgets
argument_list|(
name|passwd
argument_list|,
name|MAXSECRETLEN
operator|-
literal|1
argument_list|,
name|ufile
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to read user login data file %s.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ufile
argument_list|)
expr_stmt|;
comment|/* get rid of newlines */
name|l
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
name|user
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|user
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
name|passwd
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|passwd
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nochap - Disable CHAP authentication with peer.  */
end_comment

begin_function
specifier|static
name|int
name|nochap
parameter_list|()
block|{
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reqchap - Require CHAP authentication from peer.  */
end_comment

begin_function
specifier|static
name|int
name|reqchap
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|1
expr_stmt|;
name|auth_required
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setnovj - diable vj compression  */
end_comment

begin_function
specifier|static
name|int
name|setnovj
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_vj
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_vj
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setconnector - Set a program to connect to a serial line  */
end_comment

begin_function
specifier|static
name|int
name|setconnector
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|connector
operator|=
name|strdup
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"connector string"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdomain - Set domain name to append to hostname   */
end_comment

begin_function
specifier|static
name|int
name|setdomain
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|strncat
argument_list|(
name|hostname
argument_list|,
operator|*
name|argv
argument_list|,
name|MAXNAMELEN
operator|-
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|hostname
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setasyncmap
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|long
name|asyncmap
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|asyncmap
argument_list|,
literal|16
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|asyncmap
operator||=
name|asyncmap
expr_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setspeed - Set the speed.  */
end_comment

begin_function
specifier|static
name|int
name|setspeed
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|spd
decl_stmt|;
name|spd
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|arg
operator|||
operator|*
name|ptr
operator|!=
literal|0
operator|||
name|spd
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|inspeed
operator|=
name|spd
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setdevname - Set the device name.  */
end_comment

begin_function
name|int
name|setdevname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|,
modifier|*
name|ttyname
argument_list|()
decl_stmt|;
name|char
name|dev
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"/dev/"
argument_list|,
name|cp
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|dev
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|dev
argument_list|,
name|cp
argument_list|,
name|MAXPATHLEN
operator|-
literal|5
argument_list|)
expr_stmt|;
name|dev
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|dev
expr_stmt|;
block|}
comment|/*      * Check if there is a device by this name.      */
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|devname
argument_list|,
name|cp
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|devname
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|default_device
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setipaddr - Set the IP address  */
end_comment

begin_function
name|int
name|setipaddr
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|u_long
name|local
decl_stmt|,
name|remote
decl_stmt|;
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
comment|/*      * IP address pair separated by ":".      */
if|if
condition|(
operator|(
name|colon
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * If colon first character, then no local addr.      */
if|if
condition|(
name|colon
operator|!=
name|arg
condition|)
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|local
operator|=
name|inet_addr
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown host: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|local
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|local
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|our_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|our_name
argument_list|,
name|arg
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|our_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|local
operator|!=
literal|0
condition|)
name|wo
operator|->
name|ouraddr
operator|=
name|local
expr_stmt|;
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
block|}
comment|/*      * If colon last character, then no remote addr.      */
if|if
condition|(
operator|*
operator|++
name|colon
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|remote
operator|=
name|inet_addr
argument_list|(
name|colon
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|colon
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown host: %s"
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|remote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|remote
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|remote_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|remote_name
argument_list|,
name|colon
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|remote_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|remote
operator|!=
literal|0
condition|)
name|wo
operator|->
name|hisaddr
operator|=
name|remote
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setnoipdflt - disable setipdefault()  */
end_comment

begin_function
specifier|static
name|int
name|setnoipdflt
parameter_list|()
block|{
name|disable_defaultip
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipcpaccl - accept peer's idea of our address  */
end_comment

begin_function
specifier|static
name|int
name|setipcpaccl
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|accept_local
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipcpaccr - accept peer's idea of its address  */
end_comment

begin_function
specifier|static
name|int
name|setipcpaccr
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|accept_remote
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipdefault - default our local IP address based on our hostname.  */
end_comment

begin_function
name|void
name|setipdefault
parameter_list|()
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|u_long
name|local
decl_stmt|;
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
comment|/*      * If local IP address already given, don't bother.      */
if|if
condition|(
name|wo
operator|->
name|ouraddr
operator|!=
literal|0
operator|||
name|disable_defaultip
condition|)
return|return;
comment|/*      * Look up our hostname (possibly with domain name appended)      * and take the first IP address as our local IP address.      * If there isn't an IP address for our hostname, too bad.      */
name|wo
operator|->
name|accept_local
operator|=
literal|1
expr_stmt|;
comment|/* don't insist on this default value */
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|local
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|local
operator|!=
literal|0
condition|)
name|wo
operator|->
name|ouraddr
operator|=
name|local
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setnetmask - set the netmask to be used on the interface.  */
end_comment

begin_function
specifier|static
name|int
name|setnetmask
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|u_long
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|=
name|inet_addr
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid netmask %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|netmask
operator|=
name|mask
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setcrtscts
parameter_list|()
block|{
name|crtscts
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setnodetach
parameter_list|()
block|{
name|nodetach
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setmodem
parameter_list|()
block|{
name|modem
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlocal
parameter_list|()
block|{
name|modem
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setusehostname
parameter_list|()
block|{
name|usehostname
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setname
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|our_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|our_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|our_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setuser
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|user
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|user
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setremote
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|remote_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|remote_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setauth
parameter_list|()
block|{
name|auth_required
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setdefaultroute
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|default_route
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setproxyarp
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|proxy_arp
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setpersist
parameter_list|()
block|{
name|persist
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setdologin
parameter_list|()
block|{
name|uselogin
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to set timeouts, max transmits, etc.  */
end_comment

begin_function
specifier|static
name|int
name|setlcptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|timeouttime
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpterm
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxtermtransmits
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpconf
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxconfreqtransmits
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpfails
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxnakloops
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ipcp_fsm
index|[
literal|0
index|]
operator|.
name|timeouttime
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcpterm
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ipcp_fsm
index|[
literal|0
index|]
operator|.
name|maxtermtransmits
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcpconf
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ipcp_fsm
index|[
literal|0
index|]
operator|.
name|maxconfreqtransmits
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcpfails
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxnakloops
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setpaptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|upap
index|[
literal|0
index|]
operator|.
name|us_timeouttime
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setpapreqs
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|upap
index|[
literal|0
index|]
operator|.
name|us_maxtransmits
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setchaptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|chap
index|[
literal|0
index|]
operator|.
name|timeouttime
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setchapchal
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|chap
index|[
literal|0
index|]
operator|.
name|max_transmits
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setchapintv
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|chap
index|[
literal|0
index|]
operator|.
name|chal_interval
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

