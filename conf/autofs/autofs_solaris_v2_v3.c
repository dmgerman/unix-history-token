begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2003 Ion Badulescu  * Copyright (c) 1997-2014 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/conf/autofs/autofs_solaris_v2_v3.c  *  */
end_comment

begin_comment
comment|/*  * Automounter filesystem  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/*  * MACROS:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUTOFS_NULL
end_ifndef

begin_define
define|#
directive|define
name|AUTOFS_NULL
value|NULLPROC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not AUTOFS_NULL */
end_comment

begin_comment
comment|/*  * STRUCTURES:  */
end_comment

begin_struct
struct|struct
name|amd_rddirres
block|{
name|enum
name|autofs_res
name|rd_status
decl_stmt|;
name|u_long
name|rd_bufsize
decl_stmt|;
name|nfsdirlist
name|rd_dl
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|amd_rddirres
name|amd_rddirres
typedef|;
end_typedef

begin_comment
comment|/*  * VARIABLES:  */
end_comment

begin_decl_stmt
name|SVCXPRT
modifier|*
name|autofs_xprt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
name|bool_t
name|xdr_umntrequest
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntrequest
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_umntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_autofs_lookupargs
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_lookupargs
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_autofs_mountres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_mountres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_autofs_lookupres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_lookupres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_autofs_rddirargs
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_rddirargs
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdr_amd_rddirres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|amd_rddirres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These exist only in the AutoFS V2 protocol.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOFS_POSTUNMOUNT
end_ifdef

begin_function_decl
name|bool_t
name|xdr_postumntreq
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postumntreq
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_postumntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postumntres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_postmountreq
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postmountreq
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool_t
name|xdr_postmountres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postmountres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOFS_POSTUMOUNT */
end_comment

begin_comment
comment|/*  * AUTOFS XDR FUNCTIONS:  */
end_comment

begin_function
name|bool_t
name|xdr_autofs_stat
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_stat
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_enum
argument_list|(
name|xdrs
argument_list|,
operator|(
name|enum_t
operator|*
operator|)
name|objp
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_action
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_action
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_enum
argument_list|(
name|xdrs
argument_list|,
operator|(
name|enum_t
operator|*
operator|)
name|objp
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_linka
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|linka
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|dir
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|link
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_netbuf
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|netbuf
modifier|*
name|objp
parameter_list|)
block|{
name|bool_t
name|dummy
decl_stmt|;
if|if
condition|(
operator|!
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|objp
operator|->
name|maxlen
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|dummy
operator|=
name|xdr_bytes
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
operator|(
name|objp
operator|->
name|buf
operator|)
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
operator|(
name|objp
operator|->
name|len
operator|)
argument_list|,
name|objp
operator|->
name|maxlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_args
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_args
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_autofs_netbuf
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|addr
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|path
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|opts
argument_list|,
name|AUTOFS_MAXOPTSLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|map
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|subdir
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|key
argument_list|,
name|AUTOFS_MAXCOMPONENTLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mount_to
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|rpc_to
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|direct
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_mounta
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|mounta
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|spec
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|dir
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|flags
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|fstype
argument_list|,
name|AUTOFS_MAXCOMPONENTLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_pointer
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|objp
operator|->
name|dataptr
argument_list|,
sizeof|sizeof
argument_list|(
name|autofs_args
argument_list|)
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_autofs_args
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|datalen
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_action_list_entry
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|action_list_entry
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_autofs_action
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|action
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
switch|switch
condition|(
name|objp
operator|->
name|action
condition|)
block|{
case|case
name|AUTOFS_MOUNT_RQ
case|:
if|if
condition|(
operator|!
name|xdr_mounta
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|action_list_entry_u
operator|.
name|mounta
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
case|case
name|AUTOFS_LINK_RQ
case|:
if|if
condition|(
operator|!
name|xdr_linka
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|action_list_entry_u
operator|.
name|linka
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_action_list
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|action_list
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_action_list_entry
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|action
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_pointer
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|objp
operator|->
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|action_list
argument_list|)
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_action_list
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_umntrequest
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntrequest
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_umntrequest:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_bool_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|isdirect
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UMNTREQUEST_DEVID
if|if
condition|(
operator|!
name|xdr_dev_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|devid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_dev_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|rdevid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
comment|/* not HAVE_STRUCT_UMNTREQUEST_DEVID */
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mntresource
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mntpnt
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|fstype
argument_list|,
name|AUTOFS_MAXCOMPONENTLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mntopts
argument_list|,
name|AUTOFS_MAXOPTSLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
comment|/* not HAVE_STRUCT_UMNTREQUEST_DEVID */
if|if
condition|(
operator|!
name|xdr_pointer
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|objp
operator|->
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|umntrequest
argument_list|)
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_umntrequest
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_umntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_mntres:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These exist only in the AutoFS V2 protocol.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOFS_POSTUNMOUNT
end_ifdef

begin_function
name|bool_t
name|xdr_postumntreq
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postumntreq
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_dev_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|devid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_dev_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|rdevid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_pointer
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|objp
operator|->
name|next
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|postumntreq
argument_list|)
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_postumntreq
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_postumntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postumntres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_postmountreq
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postmountreq
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|special
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mountp
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|fstype
argument_list|,
name|AUTOFS_MAXCOMPONENTLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mntopts
argument_list|,
name|AUTOFS_MAXOPTSLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_dev_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|devid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_postmountres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|postmountres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOFS_POSTUNMOUNT */
end_comment

begin_function
name|bool_t
name|xdr_autofs_res
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_res
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_enum
argument_list|(
name|xdrs
argument_list|,
operator|(
name|enum_t
operator|*
operator|)
name|objp
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_lookupargs
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_lookupargs
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_autofs_lookupargs:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|map
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|path
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|name
argument_list|,
name|AUTOFS_MAXCOMPONENTLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|subdir
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|opts
argument_list|,
name|AUTOFS_MAXOPTSLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_bool_t
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|isdirect
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_mount_result_type
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|mount_result_type
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_autofs_stat
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
switch|switch
condition|(
name|objp
operator|->
name|status
condition|)
block|{
case|case
name|AUTOFS_ACTION
case|:
if|if
condition|(
operator|!
name|xdr_pointer
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|objp
operator|->
name|mount_result_type_u
operator|.
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|action_list
argument_list|)
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_action_list
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
case|case
name|AUTOFS_DONE
case|:
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mount_result_type_u
operator|.
name|error
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_mountres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_mountres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_mntres:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_mount_result_type
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mr_type
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|mr_verbose
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_lookup_result_type
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|lookup_result_type
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_autofs_action
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|action
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
switch|switch
condition|(
name|objp
operator|->
name|action
condition|)
block|{
case|case
name|AUTOFS_LINK_RQ
case|:
if|if
condition|(
operator|!
name|xdr_linka
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|lookup_result_type_u
operator|.
name|lt_linka
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_lookupres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_lookupres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_autofs_res
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|lu_res
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_lookup_result_type
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|lu_type
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|lu_verbose
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_autofs_rddirargs
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|autofs_rddirargs
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|rda_map
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|objp
operator|->
name|rda_offset
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|objp
operator|->
name|rda_count
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ENCODE ONLY  *  * Solaris automountd uses struct autofsrddir to pass the results.  * We use the traditional nfsreaddirres and do the conversion ourselves.  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_amd_putrddirres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|nfsdirlist
modifier|*
name|dp
parameter_list|,
name|ulong
name|reqsize
parameter_list|)
block|{
name|nfsentry
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|namlen
decl_stmt|;
name|bool_t
name|true
init|=
name|TRUE
decl_stmt|;
name|bool_t
name|false
init|=
name|FALSE
decl_stmt|;
name|int
name|entrysz
decl_stmt|;
name|int
name|tofit
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|u_long
name|ino
decl_stmt|,
name|off
decl_stmt|;
name|bufsize
operator|=
literal|1
operator|*
name|BYTES_PER_XDR_UNIT
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|dp
operator|->
name|dl_entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|ne_nextentry
control|)
block|{
name|name
operator|=
name|ep
operator|->
name|ne_name
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ino
operator|=
operator|(
name|u_long
operator|)
name|ep
operator|->
name|ne_fileid
expr_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|ep
operator|->
name|ne_cookie
operator|+
name|AUTOFS_DAEMONCOOKIE
expr_stmt|;
name|entrysz
operator|=
operator|(
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_XDR_UNIT
operator|+
name|roundup
argument_list|(
name|namlen
argument_list|,
name|BYTES_PER_XDR_UNIT
argument_list|)
expr_stmt|;
name|tofit
operator|=
name|entrysz
operator|+
literal|2
operator|*
name|BYTES_PER_XDR_UNIT
expr_stmt|;
if|if
condition|(
name|bufsize
operator|+
name|tofit
operator|>
name|reqsize
condition|)
block|{
name|dp
operator|->
name|dl_eof
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|xdr_bool
argument_list|(
name|xdrs
argument_list|,
operator|&
name|true
argument_list|)
operator|||
operator|!
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|&
name|ino
argument_list|)
operator|||
operator|!
name|xdr_bytes
argument_list|(
name|xdrs
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
name|AUTOFS_MAXPATHLEN
argument_list|)
operator|||
operator|!
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|&
name|off
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|bufsize
operator|+=
name|entrysz
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xdr_bool
argument_list|(
name|xdrs
argument_list|,
operator|&
name|false
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|xdr_bool
argument_list|(
name|xdrs
argument_list|,
operator|&
name|dp
operator|->
name|dl_eof
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdr_amd_rddirres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|amd_rddirres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xdr_enum
argument_list|(
name|xdrs
argument_list|,
operator|(
name|enum_t
operator|*
operator|)
operator|&
name|objp
operator|->
name|rd_status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|objp
operator|->
name|rd_status
operator|!=
name|AUTOFS_OK
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|xdr_amd_putrddirres
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|rd_dl
argument_list|,
name|objp
operator|->
name|rd_bufsize
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * AUTOFS RPC methods  */
end_comment

begin_function
specifier|static
name|int
name|autofs_lookup_2_req
parameter_list|(
name|autofs_lookupargs
modifier|*
name|m
parameter_list|,
name|autofs_lookupres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|am_node
modifier|*
name|mp
decl_stmt|,
modifier|*
name|new_mp
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
name|dlog
argument_list|(
literal|"LOOKUP REQUEST: name=%s[%s] map=%s opts=%s path=%s direct=%d"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|subdir
argument_list|,
name|m
operator|->
name|map
argument_list|,
name|m
operator|->
name|opts
argument_list|,
name|m
operator|->
name|path
argument_list|,
name|m
operator|->
name|isdirect
argument_list|)
expr_stmt|;
comment|/* find the effective uid/gid from RPC request */
name|xsnprintf
argument_list|(
name|opt_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|uid_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|cred
operator|->
name|aup_uid
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|opt_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|cred
operator|->
name|aup_gid
argument_list|)
expr_stmt|;
name|mp
operator|=
name|find_ap
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"map %s not found"
argument_list|,
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
name|err
operator|=
name|AUTOFS_NOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
expr_stmt|;
name|new_mp
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|lookup_child
argument_list|(
name|mp
argument_list|,
name|m
operator|->
name|name
argument_list|,
operator|&
name|err
argument_list|,
name|VLOOK_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_mp
condition|)
block|{
name|err
operator|=
name|AUTOFS_NOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"autofs requests to mount an already mounted node???"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_map
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|AUTOFS_OK
expr_stmt|;
name|res
operator|->
name|lu_type
operator|.
name|action
operator|=
name|AUTOFS_NONE
expr_stmt|;
name|out
label|:
name|res
operator|->
name|lu_res
operator|=
name|err
expr_stmt|;
name|res
operator|->
name|lu_verbose
operator|=
literal|1
expr_stmt|;
name|dlog
argument_list|(
literal|"LOOKUP REPLY: status=%d"
argument_list|,
name|res
operator|->
name|lu_res
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|autofs_lookup_2_free
parameter_list|(
name|autofs_lookupres
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|linka
name|link
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|->
name|lu_res
operator|==
name|AUTOFS_OK
operator|)
operator|&&
operator|(
name|res
operator|->
name|lu_type
operator|.
name|action
operator|==
name|AUTOFS_LINK_RQ
operator|)
condition|)
block|{
comment|/*      * Free link information      */
name|link
operator|=
name|res
operator|->
name|lu_type
operator|.
name|lookup_result_type_u
operator|.
name|lt_linka
expr_stmt|;
if|if
condition|(
name|link
operator|.
name|dir
condition|)
name|XFREE
argument_list|(
name|link
operator|.
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|.
name|link
condition|)
name|XFREE
argument_list|(
name|link
operator|.
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_mount_2_req
parameter_list|(
name|autofs_lookupargs
modifier|*
name|m
parameter_list|,
name|autofs_mountres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|int
name|err
init|=
name|AUTOFS_OK
decl_stmt|;
name|am_node
modifier|*
name|mp
decl_stmt|,
modifier|*
name|new_mp
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
name|dlog
argument_list|(
literal|"MOUNT REQUEST: name=%s[%s] map=%s opts=%s path=%s direct=%d"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|subdir
argument_list|,
name|m
operator|->
name|map
argument_list|,
name|m
operator|->
name|opts
argument_list|,
name|m
operator|->
name|path
argument_list|,
name|m
operator|->
name|isdirect
argument_list|)
expr_stmt|;
comment|/* find the effective uid/gid from RPC request */
name|xsnprintf
argument_list|(
name|opt_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|uid_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|cred
operator|->
name|aup_uid
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|opt_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|cred
operator|->
name|aup_gid
argument_list|)
expr_stmt|;
name|mp
operator|=
name|find_ap
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"map %s not found"
argument_list|,
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
name|res
operator|->
name|mr_type
operator|.
name|status
operator|=
name|AUTOFS_DONE
expr_stmt|;
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|error
operator|=
name|AUTOFS_NOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
expr_stmt|;
name|new_mp
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|lookup_child
argument_list|(
name|mp
argument_list|,
name|m
operator|->
name|name
operator|+
name|m
operator|->
name|isdirect
argument_list|,
operator|&
name|err
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mp
operator|&&
name|err
operator|<
literal|0
condition|)
block|{
comment|/* new_mp->am_transp = transp; */
name|new_mp
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|mount_child
argument_list|(
name|new_mp
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
comment|/* we're working on it */
name|amd_stats
operator|.
name|d_drops
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
name|res
operator|->
name|mr_type
operator|.
name|status
operator|=
name|AUTOFS_DONE
expr_stmt|;
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|error
operator|=
name|AUTOFS_NOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_AUTOFS_USE_LOFS
operator|||
name|new_mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
block|{
name|res
operator|->
name|mr_type
operator|.
name|status
operator|=
name|AUTOFS_DONE
expr_stmt|;
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|error
operator|=
name|AUTOFS_OK
expr_stmt|;
block|}
else|else
block|{
name|struct
name|action_list
modifier|*
name|list
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|action_list
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|new_mp
operator|->
name|am_link
condition|)
name|target
operator|=
name|new_mp
operator|->
name|am_link
expr_stmt|;
else|else
name|target
operator|=
name|new_mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
expr_stmt|;
name|list
operator|->
name|action
operator|.
name|action
operator|=
name|AUTOFS_LINK_RQ
expr_stmt|;
name|list
operator|->
name|action
operator|.
name|action_list_entry_u
operator|.
name|linka
operator|.
name|dir
operator|=
name|xstrdup
argument_list|(
name|new_mp
operator|->
name|am_name
argument_list|)
expr_stmt|;
name|list
operator|->
name|action
operator|.
name|action_list_entry_u
operator|.
name|linka
operator|.
name|link
operator|=
name|xstrdup
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|mr_type
operator|.
name|status
operator|=
name|AUTOFS_ACTION
expr_stmt|;
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|list
operator|=
name|list
expr_stmt|;
block|}
name|out
label|:
name|res
operator|->
name|mr_verbose
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|res
operator|->
name|mr_type
operator|.
name|status
condition|)
block|{
case|case
name|AUTOFS_ACTION
case|:
name|dlog
argument_list|(
literal|"MOUNT REPLY: status=%d, AUTOFS_ACTION"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTOFS_DONE
case|:
name|dlog
argument_list|(
literal|"MOUNT REPLY: status=%d, AUTOFS_DONE"
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dlog
argument_list|(
literal|"MOUNT REPLY: status=%d, UNKNOWN(%d)"
argument_list|,
name|err
argument_list|,
name|res
operator|->
name|mr_type
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|isdirect
condition|)
block|{
comment|/* direct mount */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount of %s failed"
argument_list|,
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* indirect mount */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount of %s/%s failed"
argument_list|,
name|m
operator|->
name|path
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|autofs_mount_2_free
parameter_list|(
name|struct
name|autofs_mountres
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|mr_type
operator|.
name|status
operator|==
name|AUTOFS_ACTION
operator|&&
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|list
operator|!=
name|NULL
condition|)
block|{
name|autofs_action
name|action
decl_stmt|;
name|dlog
argument_list|(
literal|"freeing action list"
argument_list|)
expr_stmt|;
name|action
operator|=
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|list
operator|->
name|action
operator|.
name|action
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|AUTOFS_LINK_RQ
condition|)
block|{
comment|/*        * Free link information        */
name|struct
name|linka
modifier|*
name|link
decl_stmt|;
name|link
operator|=
operator|&
operator|(
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|list
operator|->
name|action
operator|.
name|action_list_entry_u
operator|.
name|linka
operator|)
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|dir
condition|)
name|XFREE
argument_list|(
name|link
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|link
condition|)
name|XFREE
argument_list|(
name|link
operator|->
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|AUTOFS_MOUNT_RQ
condition|)
block|{
name|struct
name|mounta
modifier|*
name|mnt
decl_stmt|;
name|mnt
operator|=
operator|&
operator|(
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|list
operator|->
name|action
operator|.
name|action_list_entry_u
operator|.
name|mounta
operator|)
expr_stmt|;
if|if
condition|(
name|mnt
operator|->
name|spec
condition|)
name|XFREE
argument_list|(
name|mnt
operator|->
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnt
operator|->
name|dir
condition|)
name|XFREE
argument_list|(
name|mnt
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnt
operator|->
name|fstype
condition|)
name|XFREE
argument_list|(
name|mnt
operator|->
name|fstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnt
operator|->
name|dataptr
condition|)
name|XFREE
argument_list|(
name|mnt
operator|->
name|dataptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MOUNTA_OPTPTR
if|if
condition|(
name|mnt
operator|->
name|optptr
condition|)
name|XFREE
argument_list|(
name|mnt
operator|->
name|optptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MOUNTA_OPTPTR */
block|}
name|XFREE
argument_list|(
name|res
operator|->
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_unmount_2_req
parameter_list|(
name|umntrequest
modifier|*
name|ul
parameter_list|,
name|umntres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|int
name|mapno
decl_stmt|,
name|err
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UMNTREQUEST_DEVID
name|dlog
argument_list|(
literal|"UNMOUNT REQUEST: dev=%lx rdev=%lx %s"
argument_list|,
operator|(
name|u_long
operator|)
name|ul
operator|->
name|devid
argument_list|,
operator|(
name|u_long
operator|)
name|ul
operator|->
name|rdevid
argument_list|,
name|ul
operator|->
name|isdirect
condition|?
literal|"direct"
else|:
literal|"indirect"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_STRUCT_UMNTREQUEST_DEVID */
name|dlog
argument_list|(
literal|"UNMOUNT REQUEST: mntresource='%s' mntpnt='%s' fstype='%s' mntopts='%s' %s"
argument_list|,
name|ul
operator|->
name|mntresource
argument_list|,
name|ul
operator|->
name|mntpnt
argument_list|,
name|ul
operator|->
name|fstype
argument_list|,
name|ul
operator|->
name|mntopts
argument_list|,
name|ul
operator|->
name|isdirect
condition|?
literal|"direct"
else|:
literal|"indirect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_STRUCT_UMNTREQUEST_DEVID */
comment|/* by default, and if not found, succeed */
name|res
operator|->
name|status
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UMNTREQUEST_DEVID
for|for
control|(
name|mp
operator|=
name|get_first_exported_ap
argument_list|(
operator|&
name|mapno
argument_list|)
init|;
name|mp
condition|;
name|mp
operator|=
name|get_next_exported_ap
argument_list|(
operator|&
name|mapno
argument_list|)
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_dev
operator|==
name|ul
operator|->
name|devid
operator|&&
name|mp
operator|->
name|am_rdev
operator|==
name|ul
operator|->
name|rdevid
condition|)
break|break;
block|}
else|#
directive|else
comment|/* not HAVE_STRUCT_UMNTREQUEST_DEVID */
name|mp
operator|=
name|find_ap
argument_list|(
name|ul
operator|->
name|mntpnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_STRUCT_UMNTREQUEST_DEVID */
if|if
condition|(
name|mp
condition|)
block|{
comment|/* save RPC context */
if|if
condition|(
operator|!
name|mp
operator|->
name|am_transp
operator|&&
name|transp
condition|)
block|{
name|mp
operator|->
name|am_transp
operator|=
operator|(
name|SVCXPRT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SVCXPRT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mp
operator|->
name|am_transp
operator|)
operator|=
operator|*
name|transp
expr_stmt|;
block|}
name|mapno
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
name|err
operator|=
name|unmount_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* backgrounded, don't reply yet */
return|return
literal|1
return|;
if|if
condition|(
name|get_exported_ap
argument_list|(
name|mapno
argument_list|)
condition|)
comment|/* unmounting failed, tell the kernel */
name|res
operator|->
name|status
operator|=
literal|1
expr_stmt|;
block|}
name|dlog
argument_list|(
literal|"UNMOUNT REPLY: status=%d"
argument_list|,
name|res
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * These exist only in the AutoFS V2 protocol.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOFS_POSTUNMOUNT
end_ifdef

begin_comment
comment|/* XXX not implemented */
end_comment

begin_function
specifier|static
name|int
name|autofs_postunmount_2_req
parameter_list|(
name|postumntreq
modifier|*
name|req
parameter_list|,
name|postumntres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|postumntreq
modifier|*
name|ul
init|=
name|req
decl_stmt|;
name|dlog
argument_list|(
literal|"POSTUNMOUNT REQUEST: dev=%lx rdev=%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ul
operator|->
name|devid
argument_list|,
operator|(
name|u_long
operator|)
name|ul
operator|->
name|rdevid
argument_list|)
expr_stmt|;
comment|/* succeed unconditionally */
name|res
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|dlog
argument_list|(
literal|"POSTUNMOUNT REPLY: status=%d"
argument_list|,
name|res
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* XXX not implemented */
end_comment

begin_function
specifier|static
name|int
name|autofs_postmount_2_req
parameter_list|(
name|postmountreq
modifier|*
name|req
parameter_list|,
name|postmountres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|dlog
argument_list|(
literal|"POSTMOUNT REQUEST: %s\tdev=%lx\tspecial=%s %s"
argument_list|,
name|req
operator|->
name|mountp
argument_list|,
operator|(
name|u_long
operator|)
name|req
operator|->
name|devid
argument_list|,
name|req
operator|->
name|special
argument_list|,
name|req
operator|->
name|mntopts
argument_list|)
expr_stmt|;
comment|/* succeed unconditionally */
name|res
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|dlog
argument_list|(
literal|"POSTMOUNT REPLY: status=%d"
argument_list|,
name|res
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOFS_POSTUNMOUNT */
end_comment

begin_function
specifier|static
name|int
name|autofs_readdir_2_req
parameter_list|(
name|struct
name|autofs_rddirargs
modifier|*
name|req
parameter_list|,
name|struct
name|amd_rddirres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|static
name|nfsentry
name|e_res
index|[
name|MAX_READDIR_ENTRIES
index|]
decl_stmt|;
name|dlog
argument_list|(
literal|"READDIR REQUEST: %s @ %d"
argument_list|,
name|req
operator|->
name|rda_map
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|rda_offset
argument_list|)
expr_stmt|;
name|mp
operator|=
name|find_ap
argument_list|(
name|req
operator|->
name|rda_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"map %s not found"
argument_list|,
name|req
operator|->
name|rda_map
argument_list|)
expr_stmt|;
name|res
operator|->
name|rd_status
operator|=
name|AUTOFS_NOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mp
operator|->
name|am_stats
operator|.
name|s_readdir
operator|++
expr_stmt|;
name|req
operator|->
name|rda_offset
operator|-=
name|AUTOFS_DAEMONCOOKIE
expr_stmt|;
name|err
operator|=
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_ops
operator|->
name|readdir
argument_list|(
name|mp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
operator|->
name|rda_offset
argument_list|,
operator|&
name|res
operator|->
name|rd_dl
argument_list|,
name|e_res
argument_list|,
name|req
operator|->
name|rda_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|res
operator|->
name|rd_status
operator|=
name|AUTOFS_ECOMM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|res
operator|->
name|rd_status
operator|=
name|AUTOFS_OK
expr_stmt|;
name|res
operator|->
name|rd_bufsize
operator|=
name|req
operator|->
name|rda_count
expr_stmt|;
name|out
label|:
name|dlog
argument_list|(
literal|"READDIR REPLY: status=%d"
argument_list|,
name|res
operator|->
name|rd_status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* autofs program dispatcher */
end_comment

begin_function
specifier|static
name|void
name|autofs_program_2
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
union|union
block|{
name|autofs_lookupargs
name|autofs_mount_2_arg
decl_stmt|;
name|autofs_lookupargs
name|autofs_lookup_2_arg
decl_stmt|;
name|umntrequest
name|autofs_umount_2_arg
decl_stmt|;
name|autofs_rddirargs
name|autofs_readdir_2_arg
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOFS_POSTUNMOUNT
name|postmountreq
name|autofs_postmount_2_arg
decl_stmt|;
name|postumntreq
name|autofs_postumnt_2_arg
decl_stmt|;
endif|#
directive|endif
comment|/* AUTOFS_POSTUNMOUNT */
block|}
name|argument
union|;
union|union
block|{
name|autofs_mountres
name|mount_res
decl_stmt|;
name|autofs_lookupres
name|lookup_res
decl_stmt|;
name|umntres
name|umount_res
decl_stmt|;
name|amd_rddirres
name|readdir_res
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOFS_POSTUNMOUNT
name|postumntres
name|postumnt_res
decl_stmt|;
name|postmountres
name|postmnt_res
decl_stmt|;
endif|#
directive|endif
comment|/* AUTOFS_POSTUNMOUNT */
block|}
name|result
union|;
name|int
name|ret
decl_stmt|;
name|bool_t
function_decl|(
modifier|*
name|xdr_argument
function_decl|)
parameter_list|()
function_decl|;
name|bool_t
function_decl|(
modifier|*
name|xdr_result
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|local_free
function_decl|)
parameter_list|()
init|=
name|NULL
function_decl|;
name|current_transp
operator|=
name|transp
expr_stmt|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|AUTOFS_NULL
case|:
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_void
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|AUTOFS_LOOKUP
case|:
name|xdr_argument
operator|=
name|xdr_autofs_lookupargs
expr_stmt|;
name|xdr_result
operator|=
name|xdr_autofs_lookupres
expr_stmt|;
name|local
operator|=
name|autofs_lookup_2_req
expr_stmt|;
name|local_free
operator|=
name|autofs_lookup_2_free
expr_stmt|;
break|break;
case|case
name|AUTOFS_MOUNT
case|:
name|xdr_argument
operator|=
name|xdr_autofs_lookupargs
expr_stmt|;
name|xdr_result
operator|=
name|xdr_autofs_mountres
expr_stmt|;
name|local
operator|=
name|autofs_mount_2_req
expr_stmt|;
name|local_free
operator|=
name|autofs_mount_2_free
expr_stmt|;
break|break;
case|case
name|AUTOFS_UNMOUNT
case|:
name|xdr_argument
operator|=
name|xdr_umntrequest
expr_stmt|;
name|xdr_result
operator|=
name|xdr_umntres
expr_stmt|;
name|local
operator|=
name|autofs_unmount_2_req
expr_stmt|;
break|break;
comment|/*  * These exist only in the AutoFS V2 protocol.  */
ifdef|#
directive|ifdef
name|AUTOFS_POSTUNMOUNT
case|case
name|AUTOFS_POSTUNMOUNT
case|:
name|xdr_argument
operator|=
name|xdr_postumntreq
expr_stmt|;
name|xdr_result
operator|=
name|xdr_postumntres
expr_stmt|;
name|local
operator|=
name|autofs_postunmount_2_req
expr_stmt|;
break|break;
case|case
name|AUTOFS_POSTMOUNT
case|:
name|xdr_argument
operator|=
name|xdr_postmountreq
expr_stmt|;
name|xdr_result
operator|=
name|xdr_postmountres
expr_stmt|;
name|local
operator|=
name|autofs_postmount_2_req
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* AUTOFS_POSTUNMOUNT */
case|case
name|AUTOFS_READDIR
case|:
name|xdr_argument
operator|=
name|xdr_autofs_rddirargs
expr_stmt|;
name|xdr_result
operator|=
name|xdr_amd_rddirres
expr_stmt|;
name|local
operator|=
name|autofs_readdir_2_req
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|argument
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_argument
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|argument
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"AUTOFS xdr decode failed for %d %d %d"
argument_list|,
operator|(
name|int
operator|)
name|rqstp
operator|->
name|rq_prog
argument_list|,
operator|(
name|int
operator|)
name|rqstp
operator|->
name|rq_vers
argument_list|,
operator|(
name|int
operator|)
name|rqstp
operator|->
name|rq_proc
argument_list|)
expr_stmt|;
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
operator|&
name|argument
argument_list|,
operator|&
name|result
argument_list|,
name|rqstp
operator|->
name|rq_clntcred
argument_list|,
name|transp
argument_list|)
expr_stmt|;
name|current_transp
operator|=
name|NULL
expr_stmt|;
comment|/* send reply only if the RPC method returned 0 */
if|if
condition|(
operator|!
name|ret
condition|)
block|{
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_result
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|result
argument_list|)
condition|)
block|{
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_argument
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|argument
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"unable to free rpc arguments in autofs_program_2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_free
condition|)
call|(
modifier|*
name|local_free
call|)
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|autofs_get_fh
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|autofs_fh_t
modifier|*
name|fh
decl_stmt|;
name|char
name|buf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
decl_stmt|;
name|struct
name|utsname
name|utsname
decl_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"autofs_get_fh for %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|fh
operator|=
name|ALLOC
argument_list|(
name|autofs_fh_t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|fh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|autofs_fh_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoid */
comment|/*    * SET MOUNT ARGS    */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xstrlcpy
argument_list|(
name|buf
argument_list|,
literal|"localhost.autofs"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xstrlcpy
argument_list|(
name|buf
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|buf
argument_list|,
literal|".autofs"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_AUTOFS_ARGS_T_ADDR
name|fh
operator|->
name|addr
operator|.
name|buf
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fh
operator|->
name|addr
operator|.
name|len
operator|=
name|fh
operator|->
name|addr
operator|.
name|maxlen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUTOFS_ARGS_T_ADDR */
name|fh
operator|->
name|direct
operator|=
operator|(
operator|(
name|mf
operator|->
name|mf_ops
operator|->
name|autofs_fs_flags
operator|&
name|FS_DIRECT
operator|)
operator|==
name|FS_DIRECT
operator|)
expr_stmt|;
name|fh
operator|->
name|rpc_to
operator|=
literal|1
expr_stmt|;
comment|/* XXX: arbitrary */
name|fh
operator|->
name|mount_to
operator|=
name|mp
operator|->
name|am_timeo
expr_stmt|;
name|fh
operator|->
name|path
operator|=
name|mp
operator|->
name|am_path
expr_stmt|;
name|fh
operator|->
name|opts
operator|=
literal|""
expr_stmt|;
comment|/* XXX: arbitrary */
name|fh
operator|->
name|map
operator|=
name|mp
operator|->
name|am_path
expr_stmt|;
comment|/* this is what we get back in readdir */
name|fh
operator|->
name|subdir
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|direct
condition|)
name|fh
operator|->
name|key
operator|=
name|mp
operator|->
name|am_name
expr_stmt|;
else|else
name|fh
operator|->
name|key
operator|=
literal|""
expr_stmt|;
name|mp
operator|->
name|am_autofs_fh
operator|=
name|fh
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|autofs_mounted
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* We don't want any timeouts on autofs nodes */
name|mp
operator|->
name|am_autofs_ttl
operator|=
name|NEVER
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_release_fh
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|autofs_fh_t
modifier|*
name|fh
init|=
name|mp
operator|->
name|am_autofs_fh
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AUTOFS_ARGS_T_ADDR
name|XFREE
argument_list|(
name|fh
operator|->
name|addr
operator|.
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUTOFS_ARGS_T_ADDR */
name|XFREE
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_autofs_fh
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_get_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
name|void
name|autofs_release_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
name|void
name|autofs_add_fdset
parameter_list|(
name|fd_set
modifier|*
name|readfds
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
name|int
name|autofs_handle_fdset
parameter_list|(
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|int
name|nsel
parameter_list|)
block|{
comment|/* nothing to do */
return|return
name|nsel
return|;
block|}
end_function

begin_comment
comment|/*  * Create the autofs service for amd  */
end_comment

begin_function
name|int
name|create_autofs_service
parameter_list|(
name|void
parameter_list|)
block|{
name|dlog
argument_list|(
literal|"creating autofs service listener"
argument_list|)
expr_stmt|;
return|return
name|register_autofs_service
argument_list|(
name|AUTOFS_CONFTYPE
argument_list|,
name|autofs_program_2
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|destroy_autofs_service
parameter_list|(
name|void
parameter_list|)
block|{
name|dlog
argument_list|(
literal|"destroying autofs service listener"
argument_list|)
expr_stmt|;
return|return
name|unregister_autofs_service
argument_list|(
name|AUTOFS_CONFTYPE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|autofs_mount_fs
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|target2
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
comment|/*    * For sublinks, we could end up here with an already mounted f/s.    * Don't do anything in that case.    */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
name|err
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|mount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
comment|/* Nothing else to do */
return|return
name|err
return|;
if|if
condition|(
operator|!
operator|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_AUTOFS_USE_LOFS
operator|)
condition|)
comment|/* Symlinks will be requested in autofs_mount_succeeded */
return|return
literal|0
return|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
name|target
operator|=
name|mp
operator|->
name|am_link
expr_stmt|;
else|else
name|target
operator|=
name|mf
operator|->
name|mf_mount
expr_stmt|;
if|if
condition|(
name|target
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|target2
operator|=
name|str3cat
argument_list|(
name|NULL
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|,
literal|"/"
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|target2
operator|=
name|xstrdup
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: converting from link to lofs (%s -> %s)"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|target2
argument_list|)
expr_stmt|;
comment|/*    * we need to stat() the destination, because the bind mount does not    * follow symlinks and/or allow for non-existent destinations.    * we fall back to symlinks if there are problems.    *    * we need to temporarily change pgrp, otherwise our stat() won't    * trigger whatever cascading mounts are needed.    *    * WARNING: we will deadlock if this function is called from the master    * amd process and it happens to trigger another auto mount. Therefore,    * this function should be called only from a child amd process, or    * at the very least it should not be called from the parent unless we    * know for sure that it won't cause a recursive mount. We refuse to    * cause the recursive mount anyway if called from the parent amd.    */
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|stat
argument_list|(
name|target2
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|lstat
argument_list|(
name|target2
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|err
operator|=
name|mount_lofs
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|target2
argument_list|,
name|mf
operator|->
name|mf_mopts
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|errno
operator|=
name|err
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|target2
condition|)
name|XFREE
argument_list|(
name|target2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|autofs_umount_fs
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
operator|)
operator|&&
name|gopt
operator|.
name|flags
operator|&
name|CFM_AUTOFS_USE_LOFS
condition|)
block|{
name|err
operator|=
name|UMOUNT_FS
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mnttab_file_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
comment|/*    * Multiple sublinks could reference this f/s.    * Don't actually unmount it unless we're holding the last reference.    */
if|if
condition|(
name|mf
operator|->
name|mf_refc
operator|==
literal|1
condition|)
name|err
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|umount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|autofs_umount_succeeded
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|umntres
name|res
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
name|res
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_umntres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: unmounting %s succeeded"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|autofs_umount_failed
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|umntres
name|res
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
name|res
operator|.
name|status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_umntres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: unmounting %s failed"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|autofs_mount_succeeded
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
comment|/*    * Store dev and rdev -- but not for symlinks    */
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_AUTOFS_USE_LOFS
operator|||
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
block|{
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
operator|&
name|stb
argument_list|)
condition|)
block|{
name|mp
operator|->
name|am_dev
operator|=
name|stb
operator|.
name|st_dev
expr_stmt|;
name|mp
operator|->
name|am_rdev
operator|=
name|stb
operator|.
name|st_rdev
expr_stmt|;
block|}
comment|/* don't expire the entries -- the kernel will do it for us */
name|mp
operator|->
name|am_flags
operator||=
name|AMF_NOTIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|transp
condition|)
block|{
name|autofs_mountres
name|res
decl_stmt|;
name|res
operator|.
name|mr_type
operator|.
name|status
operator|=
name|AUTOFS_DONE
expr_stmt|;
name|res
operator|.
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|error
operator|=
name|AUTOFS_OK
expr_stmt|;
name|res
operator|.
name|mr_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_autofs_mountres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: mounting %s succeeded"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_mount_failed
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
name|autofs_mountres
name|res
decl_stmt|;
name|res
operator|.
name|mr_type
operator|.
name|status
operator|=
name|AUTOFS_DONE
expr_stmt|;
name|res
operator|.
name|mr_type
operator|.
name|mount_result_type_u
operator|.
name|error
operator|=
name|AUTOFS_NOENT
expr_stmt|;
name|res
operator|.
name|mr_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_autofs_mountres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: mounting %s failed"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_get_opts
parameter_list|(
name|char
modifier|*
name|opts
parameter_list|,
name|size_t
name|l
parameter_list|,
name|autofs_fh_t
modifier|*
name|fh
parameter_list|)
block|{
name|xsnprintf
argument_list|(
name|opts
argument_list|,
name|l
argument_list|,
literal|"%sdirect"
argument_list|,
name|fh
operator|->
name|direct
condition|?
literal|""
else|:
literal|"in"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|autofs_compute_mount_flags
parameter_list|(
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
comment|/* Must use overlay mounts */
return|return
name|MNT2_GEN_OPT_OVERLAY
return|;
block|}
end_function

begin_function
name|void
name|autofs_timeout_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* We don't want any timeouts on autofs nodes */
name|mp
operator|->
name|am_autofs_ttl
operator|=
name|NEVER
expr_stmt|;
block|}
end_function

end_unit

