begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2003 Ion Badulescu  * Copyright (c) 1997-2014 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/conf/autofs/autofs_solaris_v1.c  *  */
end_comment

begin_comment
comment|/*  * Automounter filesystem  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
end_ifdef

begin_comment
comment|/*  * MACROS:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUTOFS_NULL
end_ifndef

begin_define
define|#
directive|define
name|AUTOFS_NULL
value|NULLPROC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not AUTOFS_NULL */
end_comment

begin_comment
comment|/*  * STRUCTURES:  */
end_comment

begin_comment
comment|/*  * VARIABLES:  */
end_comment

begin_comment
comment|/* forward declarations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_MNTREQUEST
end_ifndef

begin_function_decl
name|bool_t
name|xdr_mntrequest
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|mntrequest
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_MNTREQUEST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_MNTRES
end_ifndef

begin_function_decl
name|bool_t
name|xdr_mntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|mntres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_MNTRES */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_UMNTREQUEST
end_ifndef

begin_function_decl
name|bool_t
name|xdr_umntrequest
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntrequest
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_UMNTREQUEST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_UMNTRES
end_ifndef

begin_function_decl
name|bool_t
name|xdr_umntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntres
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_UMNTRES */
end_comment

begin_function_decl
specifier|static
name|int
name|autofs_mount_1_req
parameter_list|(
name|struct
name|mntrequest
modifier|*
name|mr
parameter_list|,
name|struct
name|mntres
modifier|*
name|result
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|autofs_unmount_1_req
parameter_list|(
name|struct
name|umntrequest
modifier|*
name|ur
parameter_list|,
name|struct
name|umntres
modifier|*
name|result
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************  *** VARIABLES                                                            ***  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *** FUNCTIONS                                                            ***  ****************************************************************************/
end_comment

begin_comment
comment|/*  * AUTOFS XDR FUNCTIONS:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_MNTREQUEST
end_ifndef

begin_function
name|bool_t
name|xdr_mntrequest
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|mntrequest
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_mntrequest:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|name
argument_list|,
name|A_MAXNAME
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|map
argument_list|,
name|A_MAXNAME
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|opts
argument_list|,
name|A_MAXOPTS
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|path
argument_list|,
name|A_MAXPATH
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_MNTREQUEST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_MNTRES
end_ifndef

begin_function
name|bool_t
name|xdr_mntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|mntres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_mntres:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_MNTRES */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_UMNTREQUEST
end_ifndef

begin_function
name|bool_t
name|xdr_umntrequest
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntrequest
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_umntrequest:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|objp
operator|->
name|isdirect
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|objp
operator|->
name|devid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_UMNTREQUEST_RDEVID
if|if
condition|(
operator|!
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|rdevid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_UMNTREQUEST_RDEVID */
if|if
condition|(
operator|!
name|xdr_pointer
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|objp
operator|->
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|umntrequest
argument_list|)
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_umntrequest
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_UMNTREQUEST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_XDR_UMNTRES
end_ifndef

begin_function
name|bool_t
name|xdr_umntres
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|umntres
modifier|*
name|objp
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_XDRTRACE
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"xdr_mntres:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|objp
operator|->
name|status
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_XDR_UMNTRES */
end_comment

begin_comment
comment|/*  * AUTOFS RPC methods  */
end_comment

begin_function
specifier|static
name|int
name|autofs_mount_1_req
parameter_list|(
name|struct
name|mntrequest
modifier|*
name|m
parameter_list|,
name|struct
name|mntres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|isdirect
init|=
literal|0
decl_stmt|;
name|am_node
modifier|*
name|mp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
name|dlog
argument_list|(
literal|"MOUNT REQUEST: name=%s map=%s opts=%s path=%s"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|map
argument_list|,
name|m
operator|->
name|opts
argument_list|,
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* find the effective uid/gid from RPC request */
name|xsnprintf
argument_list|(
name|opt_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|uid_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|cred
operator|->
name|aup_uid
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|opt_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|cred
operator|->
name|aup_gid
argument_list|)
expr_stmt|;
name|mp
operator|=
name|find_ap
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"map %s not found"
argument_list|,
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
expr_stmt|;
name|isdirect
operator|=
operator|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ap
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|lookup_child
argument_list|(
name|mp
argument_list|,
name|m
operator|->
name|name
operator|+
name|isdirect
argument_list|,
operator|&
name|err
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|&&
name|err
operator|<
literal|0
condition|)
name|ap
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|mount_child
argument_list|(
name|ap
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
comment|/* we're working on it */
name|amd_stats
operator|.
name|d_drops
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|isdirect
condition|)
block|{
comment|/* direct mount */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount of %s failed"
argument_list|,
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* indirect mount */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount of %s/%s failed"
argument_list|,
name|m
operator|->
name|path
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|dlog
argument_list|(
literal|"MOUNT REPLY: status=%d (%s)"
argument_list|,
name|err
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|err
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_unmount_1_req
parameter_list|(
name|struct
name|umntrequest
modifier|*
name|ul
parameter_list|,
name|struct
name|umntres
modifier|*
name|res
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|int
name|mapno
decl_stmt|,
name|err
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|dlog
argument_list|(
literal|"UNMOUNT REQUEST: dev=%lx rdev=%lx %s"
argument_list|,
operator|(
name|u_long
operator|)
name|ul
operator|->
name|devid
argument_list|,
operator|(
name|u_long
operator|)
name|ul
operator|->
name|rdevid
argument_list|,
name|ul
operator|->
name|isdirect
condition|?
literal|"direct"
else|:
literal|"indirect"
argument_list|)
expr_stmt|;
comment|/* by default, and if not found, succeed */
name|res
operator|->
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mapno
operator|=
literal|0
init|;
condition|;
name|mapno
operator|++
control|)
block|{
name|mp
operator|=
name|get_exported_ap
argument_list|(
name|mapno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
break|break;
if|if
condition|(
name|mp
operator|->
name|am_dev
operator|==
name|ul
operator|->
name|devid
operator|&&
operator|(
name|ul
operator|->
name|rdevid
operator|==
literal|0
operator|||
name|mp
operator|->
name|am_rdev
operator|==
name|ul
operator|->
name|rdevid
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|mp
condition|)
block|{
comment|/* save RPC context */
if|if
condition|(
operator|!
name|mp
operator|->
name|am_transp
operator|&&
name|transp
condition|)
block|{
name|mp
operator|->
name|am_transp
operator|=
operator|(
name|SVCXPRT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SVCXPRT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mp
operator|->
name|am_transp
operator|)
operator|=
operator|*
name|transp
expr_stmt|;
block|}
name|mapno
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
name|err
operator|=
name|unmount_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* backgrounded, don't reply yet */
return|return
literal|1
return|;
if|if
condition|(
name|get_exported_ap
argument_list|(
name|mapno
argument_list|)
condition|)
comment|/* unmounting failed, tell the kernel */
name|res
operator|->
name|status
operator|=
literal|1
expr_stmt|;
block|}
name|dlog
argument_list|(
literal|"UNMOUNT REPLY: status=%d"
argument_list|,
name|res
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* autofs program dispatcher */
end_comment

begin_function
specifier|static
name|void
name|autofs_program_1
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
union|union
block|{
name|mntrequest
name|autofs_mount_1_arg
decl_stmt|;
name|umntrequest
name|autofs_umount_1_arg
decl_stmt|;
block|}
name|argument
union|;
union|union
block|{
name|mntres
name|mount_res
decl_stmt|;
name|umntres
name|umount_res
decl_stmt|;
block|}
name|result
union|;
name|int
name|ret
decl_stmt|;
name|bool_t
function_decl|(
modifier|*
name|xdr_argument
function_decl|)
parameter_list|()
function_decl|;
name|bool_t
function_decl|(
modifier|*
name|xdr_result
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
name|current_transp
operator|=
name|transp
expr_stmt|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|AUTOFS_NULL
case|:
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_void
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|AUTOFS_MOUNT
case|:
name|xdr_argument
operator|=
name|xdr_mntrequest
expr_stmt|;
name|xdr_result
operator|=
name|xdr_mntres
expr_stmt|;
name|local
operator|=
name|autofs_mount_1_req
expr_stmt|;
break|break;
case|case
name|AUTOFS_UNMOUNT
case|:
name|xdr_argument
operator|=
name|xdr_umntrequest
expr_stmt|;
name|xdr_result
operator|=
name|xdr_umntres
expr_stmt|;
name|local
operator|=
name|autofs_unmount_1_req
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|argument
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_argument
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|argument
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"AUTOFS xdr decode failed for %d %d %d"
argument_list|,
operator|(
name|int
operator|)
name|rqstp
operator|->
name|rq_prog
argument_list|,
operator|(
name|int
operator|)
name|rqstp
operator|->
name|rq_vers
argument_list|,
operator|(
name|int
operator|)
name|rqstp
operator|->
name|rq_proc
argument_list|)
expr_stmt|;
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
operator|&
name|argument
argument_list|,
operator|&
name|result
argument_list|,
name|rqstp
argument_list|,
name|transp
argument_list|)
expr_stmt|;
name|current_transp
operator|=
name|NULL
expr_stmt|;
comment|/* send reply only if the RPC method returned 0 */
if|if
condition|(
operator|!
name|ret
condition|)
block|{
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_result
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|result
argument_list|)
condition|)
block|{
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_argument
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|argument
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"unable to free rpc arguments in autofs_program_1"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|autofs_get_fh
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|autofs_fh_t
modifier|*
name|fh
decl_stmt|;
name|char
name|buf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
decl_stmt|;
name|struct
name|utsname
name|utsname
decl_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"autofs_get_fh for %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|fh
operator|=
name|ALLOC
argument_list|(
name|autofs_fh_t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|fh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|autofs_fh_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoid */
comment|/*    * SET MOUNT ARGS    */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xstrlcpy
argument_list|(
name|buf
argument_list|,
literal|"localhost.autofs"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xstrlcpy
argument_list|(
name|buf
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|buf
argument_list|,
literal|".autofs"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_AUTOFS_ARGS_T_ADDR
name|fh
operator|->
name|addr
operator|.
name|buf
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fh
operator|->
name|addr
operator|.
name|len
operator|=
name|fh
operator|->
name|addr
operator|.
name|maxlen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUTOFS_ARGS_T_ADDR */
name|fh
operator|->
name|direct
operator|=
operator|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|fh
operator|->
name|rpc_to
operator|=
literal|1
expr_stmt|;
comment|/* XXX: arbitrary */
name|fh
operator|->
name|mount_to
operator|=
name|mp
operator|->
name|am_timeo
expr_stmt|;
name|fh
operator|->
name|path
operator|=
name|mp
operator|->
name|am_path
expr_stmt|;
name|fh
operator|->
name|opts
operator|=
literal|""
expr_stmt|;
comment|/* XXX: arbitrary */
name|fh
operator|->
name|map
operator|=
name|mp
operator|->
name|am_path
expr_stmt|;
comment|/* this is what we get back in readdir */
name|mp
operator|->
name|am_autofs_fh
operator|=
name|fh
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|autofs_mounted
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* We don't want any timeouts on autofs nodes */
name|mp
operator|->
name|am_autofs_ttl
operator|=
name|NEVER
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_release_fh
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|autofs_fh_t
modifier|*
name|fh
init|=
name|mp
operator|->
name|am_autofs_fh
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AUTOFS_ARGS_T_ADDR
name|XFREE
argument_list|(
name|fh
operator|->
name|addr
operator|.
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUTOFS_ARGS_T_ADDR */
name|XFREE
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_autofs_fh
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_get_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
name|void
name|autofs_release_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
name|void
name|autofs_add_fdset
parameter_list|(
name|fd_set
modifier|*
name|readfds
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function

begin_function
name|int
name|autofs_handle_fdset
parameter_list|(
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|int
name|nsel
parameter_list|)
block|{
comment|/* nothing to do */
return|return
name|nsel
return|;
block|}
end_function

begin_comment
comment|/*  * Create the autofs service for amd  */
end_comment

begin_function
name|int
name|create_autofs_service
parameter_list|(
name|void
parameter_list|)
block|{
name|dlog
argument_list|(
literal|"creating autofs service listener"
argument_list|)
expr_stmt|;
return|return
name|register_autofs_service
argument_list|(
name|AUTOFS_CONFTYPE
argument_list|,
name|autofs_program_1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|destroy_autofs_service
parameter_list|(
name|void
parameter_list|)
block|{
name|dlog
argument_list|(
literal|"destroying autofs service listener"
argument_list|)
expr_stmt|;
return|return
name|unregister_autofs_service
argument_list|(
name|AUTOFS_CONFTYPE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|autofs_mount_fs
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|target2
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|space_hack
init|=
name|autofs_strdup_space_hack
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mkdir
argument_list|(
name|space_hack
argument_list|,
literal|0555
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/*    * For sublinks, we could end up here with an already mounted f/s.    * Don't do anything in that case.    */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
name|err
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|mount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
name|rmdir
argument_list|(
name|space_hack
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*    * Autofs v1 doesn't support symlinks,    * so we ignore the CFM_AUTOFS_USE_LOFS flag    */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
comment|/* Nothing to do */
goto|goto
name|out
goto|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
name|target
operator|=
name|mp
operator|->
name|am_link
expr_stmt|;
else|else
name|target
operator|=
name|mf
operator|->
name|mf_mount
expr_stmt|;
if|if
condition|(
name|target
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|target2
operator|=
name|str3cat
argument_list|(
name|NULL
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|,
literal|"/"
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|target2
operator|=
name|xstrdup
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: converting from link to lofs (%s -> %s)"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|target2
argument_list|)
expr_stmt|;
comment|/*    * we need to stat() the destination, because the bind mount does not    * follow symlinks and/or allow for non-existent destinations.    *    * WARNING: we will deadlock if this function is called from the master    * amd process and it happens to trigger another auto mount. Therefore,    * this function should be called only from a child amd process, or    * at the very least it should not be called from the parent unless we    * know for sure that it won't cause a recursive mount. We refuse to    * cause the recursive mount anyway if called from the parent amd.    */
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|stat
argument_list|(
name|target2
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|lstat
argument_list|(
name|target2
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|err
operator|=
name|mkdir
argument_list|(
name|space_hack
argument_list|,
literal|0555
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|err
operator|=
name|mount_lofs
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|target2
argument_list|,
name|mf
operator|->
name|mf_mopts
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|errno
operator|=
name|err
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|XFREE
argument_list|(
name|space_hack
argument_list|)
expr_stmt|;
if|if
condition|(
name|target2
condition|)
name|XFREE
argument_list|(
name|target2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|autofs_umount_fs
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|space_hack
init|=
name|autofs_strdup_space_hack
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
decl_stmt|;
comment|/*    * Autofs v1 doesn't support symlinks,    * so we ignore the CFM_AUTOFS_USE_LOFS flag    */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
operator|)
condition|)
block|{
name|err
operator|=
name|UMOUNT_FS
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mnttab_file_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|rmdir
argument_list|(
name|space_hack
argument_list|)
expr_stmt|;
block|}
comment|/*    * Multiple sublinks could reference this f/s.    * Don't actually unmount it unless we're holding the last reference.    */
if|if
condition|(
name|mf
operator|->
name|mf_refc
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|umount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
condition|)
name|rmdir
argument_list|(
name|space_hack
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|XFREE
argument_list|(
name|space_hack
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|autofs_umount_succeeded
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|umntres
name|res
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
name|res
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_umntres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: unmounting %s succeeded"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|autofs_umount_failed
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|umntres
name|res
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
name|res
operator|.
name|status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_umntres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: unmounting %s failed"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|autofs_mount_succeeded
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|char
modifier|*
name|space_hack
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
comment|/* this was a mount request */
name|mntres
name|res
decl_stmt|;
name|res
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_mntres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|space_hack
operator|=
name|autofs_strdup_space_hack
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|space_hack
argument_list|,
operator|&
name|stb
argument_list|)
condition|)
block|{
name|mp
operator|->
name|am_dev
operator|=
name|stb
operator|.
name|st_dev
expr_stmt|;
name|mp
operator|->
name|am_rdev
operator|=
name|stb
operator|.
name|st_rdev
expr_stmt|;
block|}
name|XFREE
argument_list|(
name|space_hack
argument_list|)
expr_stmt|;
comment|/* don't expire the entries -- the kernel will do it for us */
name|mp
operator|->
name|am_flags
operator||=
name|AMF_NOTIMEOUT
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: mounting %s succeeded"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_mount_failed
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|SVCXPRT
modifier|*
name|transp
init|=
name|mp
operator|->
name|am_transp
decl_stmt|;
if|if
condition|(
name|transp
condition|)
block|{
comment|/* this was a mount request */
name|mntres
name|res
decl_stmt|;
name|res
operator|.
name|status
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_mntres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Quick reply sent for %s"
argument_list|,
name|mp
operator|->
name|am_al
operator|->
name|al_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_transp
operator|=
name|NULL
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"autofs: mounting %s failed"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|autofs_get_opts
parameter_list|(
name|char
modifier|*
name|opts
parameter_list|,
name|size_t
name|l
parameter_list|,
name|autofs_fh_t
modifier|*
name|fh
parameter_list|)
block|{
name|xsnprintf
argument_list|(
name|opts
argument_list|,
name|l
argument_list|,
literal|"%sdirect"
argument_list|,
name|fh
operator|->
name|direct
condition|?
literal|""
else|:
literal|"in"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|autofs_compute_mount_flags
parameter_list|(
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
comment|/* Must use overlay mounts */
return|return
name|MNT2_GEN_OPT_OVERLAY
return|;
block|}
end_function

begin_function
name|void
name|autofs_timeout_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/* We don't want any timeouts on autofs nodes */
name|mp
operator|->
name|am_autofs_ttl
operator|=
name|NEVER
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FS_AUTOFS */
end_comment

end_unit

