begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2014 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/conf/mount/mount_linux.c  */
end_comment

begin_comment
comment|/*  * Linux mount helper.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amu.h>
end_include

begin_include
include|#
directive|include
file|<nfs_common.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RPC_AUTH_H
end_ifdef

begin_include
include|#
directive|include
file|<rpc/auth.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MOUNT_TYPE_UFS
end_ifndef

begin_comment
comment|/*  * Autoconf didn't find any disk-based f/s on this system,  * So provide some default definition for this file to compile.  */
end_comment

begin_define
define|#
directive|define
name|MOUNT_TYPE_UFS
value|"no_disk_fs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MOUNT_TYPE_UFS */
end_comment

begin_struct
struct|struct
name|opt_map
block|{
specifier|const
name|char
modifier|*
name|opt
decl_stmt|;
comment|/* option name */
name|int
name|inv
decl_stmt|;
comment|/* true if flag value should be inverted */
name|int
name|mask
decl_stmt|;
comment|/* flag mask value */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|opt_map
name|opt_map
index|[]
init|=
block|{
block|{
literal|"defaults"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MNTTAB_OPT_RO
block|,
literal|0
block|,
name|MNT2_GEN_OPT_RDONLY
block|}
block|,
block|{
name|MNTTAB_OPT_RW
block|,
literal|1
block|,
name|MNT2_GEN_OPT_RDONLY
block|}
block|,
block|{
name|MNTTAB_OPT_EXEC
block|,
literal|1
block|,
name|MNT2_GEN_OPT_NOEXEC
block|}
block|,
block|{
name|MNTTAB_OPT_NOEXEC
block|,
literal|0
block|,
name|MNT2_GEN_OPT_NOEXEC
block|}
block|,
block|{
name|MNTTAB_OPT_SUID
block|,
literal|1
block|,
name|MNT2_GEN_OPT_NOSUID
block|}
block|,
block|{
name|MNTTAB_OPT_NOSUID
block|,
literal|0
block|,
name|MNT2_GEN_OPT_NOSUID
block|}
block|,
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_NODEV
block|{
name|MNTTAB_OPT_NODEV
block|,
literal|0
block|,
name|MNT2_GEN_OPT_NODEV
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_NODEV */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_SYNC
block|{
name|MNTTAB_OPT_SYNC
block|,
literal|0
block|,
name|MNT2_GEN_OPT_SYNC
block|}
block|,
block|{
name|MNTTAB_OPT_ASYNC
block|,
literal|1
block|,
name|MNT2_GEN_OPT_SYNC
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_SYNC */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_NOSUB
block|{
name|MNTTAB_OPT_SUB
block|,
literal|1
block|,
name|MNT2_GEN_OPT_NOSUB
block|}
block|,
block|{
name|MNTTAB_OPT_NOSUB
block|,
literal|0
block|,
name|MNT2_GEN_OPT_NOSUB
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_NOSUB */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_SYNCHRONOUS
block|{
literal|"synchronous"
block|,
literal|0
block|,
name|MNT2_GEN_OPT_SYNCHRONOUS
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_SYNCHRONOUS */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_MANDLOCK
block|{
literal|"mandlock"
block|,
literal|0
block|,
name|MNT2_GEN_OPT_MANDLOCK
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_MANDLOCK */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_NOATIME
block|{
literal|"noatime"
block|,
literal|0
block|,
name|MNT2_GEN_OPT_NOATIME
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_NOATIME */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_NODIRATIME
block|{
literal|"nodiratime"
block|,
literal|0
block|,
name|MNT2_GEN_OPT_NODIRATIME
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_NODIRATIME */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fs_opts
block|{
specifier|const
name|char
modifier|*
name|opt
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* XXX: Ion, what is this for? */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|iso_opts
index|[]
init|=
block|{
block|{
literal|"map"
block|,
literal|0
block|}
block|,
block|{
literal|"norock"
block|,
literal|0
block|}
block|,
block|{
literal|"cruft"
block|,
literal|0
block|}
block|,
block|{
literal|"unhide"
block|,
literal|0
block|}
block|,
block|{
literal|"conv"
block|,
literal|1
block|}
block|,
block|{
literal|"block"
block|,
literal|1
block|}
block|,
block|{
literal|"mode"
block|,
literal|1
block|}
block|,
block|{
literal|"gid"
block|,
literal|1
block|}
block|,
block|{
literal|"uid"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|dos_opts
index|[]
init|=
block|{
block|{
literal|"check"
block|,
literal|1
block|}
block|,
block|{
literal|"conv"
block|,
literal|1
block|}
block|,
block|{
literal|"uid"
block|,
literal|1
block|}
block|,
block|{
literal|"gid"
block|,
literal|1
block|}
block|,
block|{
literal|"umask"
block|,
literal|1
block|}
block|,
block|{
literal|"debug"
block|,
literal|0
block|}
block|,
block|{
literal|"fat"
block|,
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|}
block|,
block|{
literal|"blocksize"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|autofs_opts
index|[]
init|=
block|{
block|{
literal|"fd"
block|,
literal|1
block|}
block|,
block|{
literal|"pgrp"
block|,
literal|1
block|}
block|,
block|{
literal|"minproto"
block|,
literal|1
block|}
block|,
block|{
literal|"maxproto"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|lustre_opts
index|[]
init|=
block|{
block|{
literal|"flock"
block|,
literal|0
block|}
block|,
block|{
literal|"localflock"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|null_opts
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|ext2_opts
index|[]
init|=
block|{
block|{
literal|"check"
block|,
literal|1
block|}
block|,
block|{
literal|"nocheck"
block|,
literal|0
block|}
block|,
block|{
literal|"debug"
block|,
literal|0
block|}
block|,
block|{
literal|"errors"
block|,
literal|1
block|}
block|,
block|{
literal|"grpid"
block|,
literal|0
block|}
block|,
block|{
literal|"nogrpid"
block|,
literal|0
block|}
block|,
block|{
literal|"bsdgroups"
block|,
literal|0
block|}
block|,
block|{
literal|"sysvgroups"
block|,
literal|0
block|}
block|,
block|{
literal|"grpquota"
block|,
literal|0
block|}
block|,
block|{
literal|"usrquota"
block|,
literal|0
block|}
block|,
block|{
literal|"noquota"
block|,
literal|0
block|}
block|,
block|{
literal|"quota"
block|,
literal|0
block|}
block|,
block|{
literal|"nouid32"
block|,
literal|0
block|}
block|,
block|{
literal|"oldalloc"
block|,
literal|0
block|}
block|,
block|{
literal|"orlov"
block|,
literal|0
block|}
block|,
block|{
literal|"resgid"
block|,
literal|1
block|}
block|,
block|{
literal|"resuid"
block|,
literal|1
block|}
block|,
block|{
literal|"sb"
block|,
literal|1
block|}
block|,
block|{
literal|"user_xattr"
block|,
literal|1
block|}
block|,
block|{
literal|"nouser_xattr"
block|,
literal|1
block|}
block|,
block|{
literal|"journal_dev"
block|,
literal|0
block|}
block|,
block|{
literal|"norecovery"
block|,
literal|0
block|}
block|,
block|{
literal|"noload"
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
literal|1
block|}
block|,
block|{
literal|"barrier"
block|,
literal|1
block|}
block|,
block|{
literal|"commit"
block|,
literal|1
block|}
block|,
block|{
literal|"user_xattr"
block|,
literal|0
block|}
block|,
block|{
literal|"nouser_xattr"
block|,
literal|0
block|}
block|,
block|{
literal|"acl"
block|,
literal|0
block|}
block|,
block|{
literal|"noacl"
block|,
literal|0
block|}
block|,
block|{
literal|"bsddf"
block|,
literal|0
block|}
block|,
block|{
literal|"minixdf"
block|,
literal|0
block|}
block|,
block|{
literal|"usrjquota"
block|,
literal|1
block|}
block|,
block|{
literal|"grpjquota"
block|,
literal|1
block|}
block|,
block|{
literal|"jqfmt"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|ext3_opts
index|[]
init|=
block|{
block|{
literal|"check"
block|,
literal|1
block|}
block|,
block|{
literal|"nocheck"
block|,
literal|0
block|}
block|,
block|{
literal|"debug"
block|,
literal|0
block|}
block|,
block|{
literal|"errors"
block|,
literal|1
block|}
block|,
block|{
literal|"grpid"
block|,
literal|0
block|}
block|,
block|{
literal|"nogrpid"
block|,
literal|0
block|}
block|,
block|{
literal|"bsdgroups"
block|,
literal|0
block|}
block|,
block|{
literal|"sysvgroups"
block|,
literal|0
block|}
block|,
block|{
literal|"grpquota"
block|,
literal|0
block|}
block|,
block|{
literal|"usrquota"
block|,
literal|0
block|}
block|,
block|{
literal|"noquota"
block|,
literal|0
block|}
block|,
block|{
literal|"quota"
block|,
literal|0
block|}
block|,
block|{
literal|"nouid32"
block|,
literal|0
block|}
block|,
block|{
literal|"oldalloc"
block|,
literal|0
block|}
block|,
block|{
literal|"orlov"
block|,
literal|0
block|}
block|,
block|{
literal|"resgid"
block|,
literal|1
block|}
block|,
block|{
literal|"resuid"
block|,
literal|1
block|}
block|,
block|{
literal|"sb"
block|,
literal|1
block|}
block|,
block|{
literal|"user_xattr"
block|,
literal|1
block|}
block|,
block|{
literal|"nouser_xattr"
block|,
literal|1
block|}
block|,
block|{
literal|"journal"
block|,
literal|1
block|}
block|,
block|{
literal|"journal_dev"
block|,
literal|1
block|}
block|,
block|{
literal|"norecovery"
block|,
literal|0
block|}
block|,
block|{
literal|"noload"
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
literal|1
block|}
block|,
block|{
literal|"barrier"
block|,
literal|1
block|}
block|,
block|{
literal|"commit"
block|,
literal|1
block|}
block|,
block|{
literal|"user_xattr"
block|,
literal|0
block|}
block|,
block|{
literal|"nouser_xattr"
block|,
literal|0
block|}
block|,
block|{
literal|"acl"
block|,
literal|0
block|}
block|,
block|{
literal|"noacl"
block|,
literal|0
block|}
block|,
block|{
literal|"bsddf"
block|,
literal|0
block|}
block|,
block|{
literal|"minixdf"
block|,
literal|0
block|}
block|,
block|{
literal|"usrjquota"
block|,
literal|1
block|}
block|,
block|{
literal|"grpjquota"
block|,
literal|1
block|}
block|,
block|{
literal|"jqfmt"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|fs_opts
name|ext4_opts
index|[]
init|=
block|{
block|{
literal|"debug"
block|,
literal|0
block|}
block|,
block|{
literal|"errors"
block|,
literal|1
block|}
block|,
block|{
literal|"grpid"
block|,
literal|0
block|}
block|,
block|{
literal|"nogrpid"
block|,
literal|0
block|}
block|,
block|{
literal|"bsdgroups"
block|,
literal|0
block|}
block|,
block|{
literal|"sysvgroups"
block|,
literal|0
block|}
block|,
block|{
literal|"grpquota"
block|,
literal|0
block|}
block|,
block|{
literal|"usrquota"
block|,
literal|0
block|}
block|,
block|{
literal|"noquota"
block|,
literal|0
block|}
block|,
block|{
literal|"quota"
block|,
literal|0
block|}
block|,
block|{
literal|"oldalloc"
block|,
literal|0
block|}
block|,
block|{
literal|"orlov"
block|,
literal|0
block|}
block|,
block|{
literal|"resgid"
block|,
literal|1
block|}
block|,
block|{
literal|"resuid"
block|,
literal|1
block|}
block|,
block|{
literal|"sb"
block|,
literal|1
block|}
block|,
block|{
literal|"user_xattr"
block|,
literal|1
block|}
block|,
block|{
literal|"nouser_xattr"
block|,
literal|1
block|}
block|,
block|{
literal|"journal"
block|,
literal|1
block|}
block|,
block|{
literal|"journal_dev"
block|,
literal|1
block|}
block|,
block|{
literal|"noload"
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
literal|1
block|}
block|,
block|{
literal|"commit"
block|,
literal|1
block|}
block|,
block|{
literal|"user_xattr"
block|,
literal|0
block|}
block|,
block|{
literal|"nouser_xattr"
block|,
literal|0
block|}
block|,
block|{
literal|"acl"
block|,
literal|0
block|}
block|,
block|{
literal|"noacl"
block|,
literal|0
block|}
block|,
block|{
literal|"bsddf"
block|,
literal|0
block|}
block|,
block|{
literal|"minixdf"
block|,
literal|0
block|}
block|,
block|{
literal|"usrjquota"
block|,
literal|1
block|}
block|,
block|{
literal|"grpjquota"
block|,
literal|1
block|}
block|,
block|{
literal|"jqfmt"
block|,
literal|1
block|}
block|,
block|{
literal|"journal_checksum"
block|,
literal|0
block|}
block|,
block|{
literal|"journal_async_commit"
block|,
literal|0
block|}
block|,
block|{
literal|"journal"
block|,
literal|1
block|}
block|,
block|{
literal|"barrier"
block|,
literal|1
block|}
block|,
block|{
literal|"nobarrier"
block|,
literal|0
block|}
block|,
block|{
literal|"inode_readahead_blks"
block|,
literal|1
block|}
block|,
block|{
literal|"stripe"
block|,
literal|1
block|}
block|,
block|{
literal|"delalloc"
block|,
literal|0
block|}
block|,
block|{
literal|"nodelalloc"
block|,
literal|0
block|}
block|,
block|{
literal|"min_batch_time"
block|,
literal|1
block|}
block|,
block|{
literal|"mxn_batch_time"
block|,
literal|1
block|}
block|,
block|{
literal|"journal_ioprio"
block|,
literal|1
block|}
block|,
block|{
literal|"abort"
block|,
literal|0
block|}
block|,
block|{
literal|"auto_da_alloc"
block|,
literal|0
block|}
block|,
block|{
literal|"noauto_da_alloc"
block|,
literal|0
block|}
block|,
block|{
literal|"discard"
block|,
literal|0
block|}
block|,
block|{
literal|"nodiscard"
block|,
literal|0
block|}
block|,
block|{
literal|"nouid32"
block|,
literal|0
block|}
block|,
block|{
literal|"resize"
block|,
literal|0
block|}
block|,
block|{
literal|"block_validity"
block|,
literal|0
block|}
block|,
block|{
literal|"noblock_validity"
block|,
literal|0
block|}
block|,
block|{
literal|"dioread_lock"
block|,
literal|0
block|}
block|,
block|{
literal|"dioread_nolock"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * New parser for linux-specific mounts.  * Should now handle fs-type specific mount-options correctly.  * Currently implemented: msdos, iso9660.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_opts
parameter_list|(
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|optstr
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|,
name|char
modifier|*
modifier|*
name|xopts
parameter_list|,
name|int
modifier|*
name|noauto
parameter_list|)
block|{
specifier|const
name|struct
name|opt_map
modifier|*
name|std_opts
decl_stmt|;
specifier|const
name|struct
name|fs_opts
modifier|*
name|dev_opts
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|,
modifier|*
name|topts
decl_stmt|,
modifier|*
name|xoptstr
decl_stmt|;
name|size_t
name|l
decl_stmt|;
if|if
condition|(
name|optstr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|xoptstr
operator|=
name|xstrdup
argument_list|(
name|optstr
argument_list|)
expr_stmt|;
comment|/* because strtok is destructive below */
operator|*
name|noauto
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|optstr
argument_list|)
operator|+
literal|2
expr_stmt|;
operator|*
name|xopts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|topts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|*
name|topts
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|*
name|xopts
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|strtok
argument_list|(
name|xoptstr
argument_list|,
literal|","
argument_list|)
init|;
name|opt
condition|;
name|opt
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
comment|/*      * First, parse standard options      */
name|std_opts
operator|=
name|opt_map
expr_stmt|;
while|while
condition|(
name|std_opts
operator|->
name|opt
operator|&&
operator|!
name|NSTREQ
argument_list|(
name|std_opts
operator|->
name|opt
argument_list|,
name|opt
argument_list|,
name|strlen
argument_list|(
name|std_opts
operator|->
name|opt
argument_list|)
argument_list|)
condition|)
operator|++
name|std_opts
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|noauto
operator|=
name|STREQ
argument_list|(
name|opt
argument_list|,
name|MNTTAB_OPT_NOAUTO
argument_list|)
operator|)
operator|||
name|std_opts
operator|->
name|opt
condition|)
block|{
name|xstrlcat
argument_list|(
name|topts
argument_list|,
name|opt
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|topts
argument_list|,
literal|","
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|std_opts
operator|->
name|inv
condition|)
operator|*
name|flags
operator|&=
operator|~
name|std_opts
operator|->
name|mask
expr_stmt|;
else|else
operator|*
name|flags
operator||=
name|std_opts
operator|->
name|mask
expr_stmt|;
block|}
comment|/*      * Next, select which fs-type is to be used      * and parse the fs-specific options      */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_AUTOFS
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_AUTOFS
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|autofs_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_AUTOFS */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_PCFS
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_PCFS
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|dos_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_PCFS */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_CDFS
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_CDFS
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|iso_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_CDFS */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_LOFS
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_LOFS
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|null_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_LOFS */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_LUSTRE
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_LUSTRE
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|lustre_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_LUSTRE */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_EXT2
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_EXT2
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|ext2_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_EXT2 */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_EXT3
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_EXT3
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|ext3_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_EXT3 */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_EXT4
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_EXT4
argument_list|)
condition|)
block|{
name|dev_opts
operator|=
name|ext4_opts
expr_stmt|;
goto|goto
name|do_opts
goto|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_EXT4 */
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"linux mount: unknown fs-type: %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|xoptstr
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
operator|*
name|xopts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|topts
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|do_opts
label|:
while|while
condition|(
name|dev_opts
operator|->
name|opt
operator|&&
operator|(
operator|!
name|NSTREQ
argument_list|(
name|dev_opts
operator|->
name|opt
argument_list|,
name|opt
argument_list|,
name|strlen
argument_list|(
name|dev_opts
operator|->
name|opt
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|++
name|dev_opts
expr_stmt|;
block|}
if|if
condition|(
name|dev_opts
operator|->
name|opt
condition|)
block|{
name|xstrlcat
argument_list|(
operator|*
name|xopts
argument_list|,
name|opt
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
operator|*
name|xopts
argument_list|,
literal|","
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * All other options are discarded    */
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|xopts
argument_list|)
condition|)
operator|*
operator|(
operator|*
name|xopts
operator|+
name|strlen
argument_list|(
operator|*
name|xopts
argument_list|)
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|topts
argument_list|)
condition|)
name|topts
index|[
name|strlen
argument_list|(
name|topts
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|XFREE
argument_list|(
name|xoptstr
argument_list|)
expr_stmt|;
return|return
name|topts
return|;
block|}
end_function

begin_comment
comment|/*  * Returns combined linux kernel version number.  For a kernel numbered  * x.y.z, returns x*65535+y*256+z.  */
end_comment

begin_function
name|int
name|linux_version_code
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
name|int
name|shift
init|=
literal|16
decl_stmt|;
name|struct
name|utsname
name|my_utsname
decl_stmt|;
specifier|static
name|int
name|release
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|release
operator|||
name|uname
argument_list|(
operator|&
name|my_utsname
argument_list|)
condition|)
return|return
name|release
return|;
for|for
control|(
name|token
operator|=
name|strtok
argument_list|(
name|my_utsname
operator|.
name|release
argument_list|,
literal|"."
argument_list|)
init|;
name|token
operator|&&
operator|(
name|shift
operator|>
operator|-
literal|1
operator|)
condition|;
name|token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|)
control|)
block|{
name|release
operator||=
operator|(
name|atoi
argument_list|(
name|token
argument_list|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|-=
literal|8
expr_stmt|;
block|}
return|return
name|release
return|;
block|}
end_function

begin_function
name|int
name|do_mount_linux
parameter_list|(
name|MTYPE_TYPE
name|type
parameter_list|,
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|amuDebug
argument_list|(
name|D_FULL
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"do_mount_linux: fsname %s\n"
argument_list|,
name|mnt
operator|->
name|mnt_fsname
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"do_mount_linux: type (mntent) %s\n"
argument_list|,
name|mnt
operator|->
name|mnt_type
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"do_mount_linux: opts %s\n"
argument_list|,
name|mnt
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"do_mount_linux: dir %s\n"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
block|}
comment|/*    * If we have an nfs mount, the 5th argument to system mount() must be the    * nfs_mount_data structure, otherwise it is the return from parse_opts()    */
return|return
name|mount
argument_list|(
name|mnt
operator|->
name|mnt_fsname
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|,
name|type
argument_list|,
name|MS_MGC_VAL
operator||
name|flags
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_nfs_args
parameter_list|(
name|struct
name|nfs_common_args
modifier|*
name|ca
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ca
operator|->
name|timeo
condition|)
block|{
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_TCP
if|if
condition|(
name|ca
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_TCP
condition|)
name|ca
operator|->
name|timeo
operator|=
literal|600
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_TCP */
name|ca
operator|->
name|timeo
operator|=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ca
operator|->
name|retrans
condition|)
name|ca
operator|->
name|retrans
operator|=
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOAC
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_NOAC
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_ACREGMIN
operator|)
condition|)
name|ca
operator|->
name|acregmin
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_ACREGMAX
operator|)
condition|)
name|ca
operator|->
name|acregmax
operator|=
literal|60
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_ACDIRMIN
operator|)
condition|)
name|ca
operator|->
name|acdirmin
operator|=
literal|30
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_ACDIRMAX
operator|)
condition|)
name|ca
operator|->
name|acdirmax
operator|=
literal|60
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOAC */
block|}
end_function

begin_function
name|int
name|mount_linux_nfs
parameter_list|(
name|MTYPE_TYPE
name|type
parameter_list|,
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|nfs_args_t
modifier|*
name|mnt_data
init|=
operator|(
name|nfs_args_t
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|errorcode
decl_stmt|;
name|struct
name|nfs_common_args
name|a
decl_stmt|;
comment|/* Fake some values for linux */
name|mnt_data
operator|->
name|version
operator|=
name|NFS_MOUNT_VERSION
expr_stmt|;
name|put_nfs_common_args
argument_list|(
name|mnt_data
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|setup_nfs_args
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|get_nfs_common_args
argument_list|(
name|mnt_data
argument_list|,
name|a
argument_list|)
expr_stmt|;
comment|/*    * in nfs structure implementation version 4, the old    * filehandle field was renamed "old_root" and left as 3rd field,    * while a new field called "root" was added to the end of the    * structure. Both of them however need a copy of the file handle    * for NFSv2 mounts.    */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_VER3
if|if
condition|(
name|mnt_data
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_VER3
condition|)
name|memset
argument_list|(
name|mnt_data
operator|->
name|old_root
operator|.
name|data
argument_list|,
literal|0
argument_list|,
name|FHSIZE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_VER3 */
name|memcpy
argument_list|(
name|mnt_data
operator|->
name|old_root
operator|.
name|data
argument_list|,
name|mnt_data
operator|->
name|root
operator|.
name|data
argument_list|,
name|FHSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_BSIZE
comment|/* linux mount version 3 */
name|mnt_data
operator|->
name|bsize
operator|=
literal|0
expr_stmt|;
comment|/* let the kernel decide */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_BSIZE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_NAMLEN
comment|/* linux mount version 2 */
name|mnt_data
operator|->
name|namlen
operator|=
name|NAME_MAX
expr_stmt|;
comment|/* 256 bytes */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_NAMELEN */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PSEUDOFLAVOR
ifdef|#
directive|ifdef
name|HAVE_RPC_AUTH_H
name|mnt_data
operator|->
name|pseudoflavor
operator|=
name|AUTH_UNIX
expr_stmt|;
else|#
directive|else
name|mnt_data
operator|->
name|pseudoflavor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_PSEUDOFLAVOR */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_CONTEXT
name|memset
argument_list|(
name|mnt_data
operator|->
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mnt_data
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_CONTEXT */
name|mnt_data
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnt_data
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't create socket for kernel"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|bindresvport
argument_list|(
name|mnt_data
operator|->
name|fd
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't bind to reserved port"
argument_list|)
expr_stmt|;
name|errorcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*    * connect() the socket for kernels 1.3.10 and below    * only to avoid problems with multihomed hosts.    */
if|if
condition|(
name|linux_version_code
argument_list|()
operator|<=
literal|0x01030a
condition|)
block|{
name|int
name|ret
init|=
name|connect
argument_list|(
name|mnt_data
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mnt_data
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mnt_data
operator|->
name|addr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't connect socket for kernel"
argument_list|)
expr_stmt|;
name|errorcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|amuDebug
argument_list|(
name|D_FULL
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: type %s\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: version %d\n"
argument_list|,
name|__func__
argument_list|,
name|mnt_data
operator|->
name|version
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: fd %d\n"
argument_list|,
name|__func__
argument_list|,
name|mnt_data
operator|->
name|fd
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: hostname %s\n"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mnt_data
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: port %d\n"
argument_list|,
name|__func__
argument_list|,
name|htons
argument_list|(
name|mnt_data
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amuDebug
argument_list|(
name|D_TRACE
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: Generic mount flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|MS_MGC_VAL
operator||
name|flags
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: updated nfs_args..."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|print_nfs_args
argument_list|(
name|mnt_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mnt_data
operator|->
name|flags
operator|&=
name|MNT2_NFS_OPT_FLAGMASK
expr_stmt|;
name|errorcode
operator|=
name|do_mount_linux
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|out
label|:
comment|/*    * If we failed, (i.e. errorcode != 0), then close the socket    * if it is open.    */
if|if
condition|(
name|errorcode
operator|&&
name|mnt_data
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* save errno, may be clobbered by close() call! */
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|close
argument_list|(
name|mnt_data
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
return|return
name|errorcode
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FS_NFS4
end_ifdef

begin_function
name|int
name|mount_linux_nfs4
parameter_list|(
name|MTYPE_TYPE
name|type
parameter_list|,
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|nfs4_args_t
modifier|*
name|mnt_data
init|=
operator|(
name|nfs4_args_t
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|errorcode
decl_stmt|;
name|struct
name|nfs_common_args
name|a
decl_stmt|;
comment|/* Fake some values for linux */
name|mnt_data
operator|->
name|version
operator|=
name|NFS4_MOUNT_VERSION
expr_stmt|;
name|put_nfs_common_args
argument_list|(
name|mnt_data
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|setup_nfs_args
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|get_nfs_common_args
argument_list|(
name|mnt_data
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|amuDebug
argument_list|(
name|D_FULL
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: type %s\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: version %d\n"
argument_list|,
name|__func__
argument_list|,
name|mnt_data
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amuDebug
argument_list|(
name|D_TRACE
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: Generic mount flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|MS_MGC_VAL
operator||
name|flags
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"%s: updated nfs_args..."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|print_nfs_args
argument_list|(
name|mnt_data
argument_list|,
name|NFS_VERSION4
argument_list|)
expr_stmt|;
block|}
name|errorcode
operator|=
name|do_mount_linux
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|errorcode
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mount_linux_nonfs
parameter_list|(
name|MTYPE_TYPE
name|type
parameter_list|,
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|char
modifier|*
name|extra_opts
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp_opts
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sub_type
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|loopdev
init|=
name|NULL
decl_stmt|;
name|int
name|noauto
init|=
literal|0
decl_stmt|;
name|int
name|errorcode
decl_stmt|;
name|sub_type
operator|=
name|hasmnteq
argument_list|(
name|mnt
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_type
condition|)
block|{
name|sub_type
operator|=
name|xstrdup
argument_list|(
name|sub_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|strpbrk
argument_list|(
name|sub_type
argument_list|,
literal|",:;\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|MOUNT_TYPE_UFS
expr_stmt|;
else|else
block|{
operator|*
name|type
operator|=
literal|'\0'
expr_stmt|;
name|type
operator|=
name|sub_type
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasmntopt
argument_list|(
name|mnt
argument_list|,
literal|"type"
argument_list|)
condition|)
name|mnt
operator|->
name|mnt_type
operator|=
name|type
expr_stmt|;
name|tmp_opts
operator|=
name|parse_opts
argument_list|(
name|type
argument_list|,
name|mnt
operator|->
name|mnt_opts
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|extra_opts
argument_list|,
operator|&
name|noauto
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MOUNT_TYPE_LOFS
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_LOFS
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|MNT2_GEN_OPT_BIND
name|size_t
name|l
decl_stmt|;
comment|/* this is basically a hack to support fist lofs */
name|XFREE
argument_list|(
name|extra_opts
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|mnt
operator|->
name|mnt_fsname
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"dir="
argument_list|)
operator|+
literal|1
expr_stmt|;
name|extra_opts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|extra_opts
argument_list|,
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|extra_opts
argument_list|)
argument_list|,
literal|"dir=%s"
argument_list|,
name|mnt
operator|->
name|mnt_fsname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MNT2_GEN_OPT_BIND */
comment|/* use bind mounts for lofs */
name|flags
operator||=
name|MNT2_GEN_OPT_BIND
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_BIND */
name|errorcode
operator|=
name|do_mount_linux
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|extra_opts
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* end of "if type is LOFS" */
endif|#
directive|endif
comment|/* MOUNT_TYPE_LOFS */
ifdef|#
directive|ifdef
name|MOUNT_TYPE_LUSTRE
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_LUSTRE
argument_list|)
condition|)
block|{
name|char
modifier|*
name|topts
decl_stmt|;
if|if
condition|(
operator|*
name|extra_opts
condition|)
name|topts
operator|=
name|strvcat
argument_list|(
name|extra_opts
argument_list|,
literal|",device="
argument_list|,
name|mnt
operator|->
name|mnt_fsname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|topts
operator|=
name|strvcat
argument_list|(
literal|"device="
argument_list|,
name|mnt
operator|->
name|mnt_fsname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra_opts
argument_list|)
expr_stmt|;
name|extra_opts
operator|=
name|topts
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MOUNT_TYPE_LOFS */
block|{
ifdef|#
directive|ifdef
name|HAVE_LOOP_DEVICE
comment|/*      * If the mounted "device" is actually a regular file,      # try to attach a loop device to it.      */
name|struct
name|stat
name|buf
decl_stmt|;
name|char
modifier|*
name|old_fsname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|mnt
operator|->
name|mnt_fsname
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|loopdev
operator|=
name|setup_loop_device
argument_list|(
name|mnt
operator|->
name|mnt_fsname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"setup loop device %s over %s OK"
argument_list|,
name|loopdev
argument_list|,
name|mnt
operator|->
name|mnt_fsname
argument_list|)
expr_stmt|;
name|old_fsname
operator|=
name|mnt
operator|->
name|mnt_fsname
expr_stmt|;
name|mnt
operator|->
name|mnt_fsname
operator|=
name|loopdev
expr_stmt|;
comment|/* XXX: hack, append loop=/dev/loopX to mnttab opts */
name|l
operator|=
name|strlen
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|)
operator|+
literal|7
operator|+
name|strlen
argument_list|(
name|loopdev
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|xsnprintf
argument_list|(
name|str
argument_list|,
name|l
argument_list|,
literal|"%s,loop=%s"
argument_list|,
name|mnt
operator|->
name|mnt_opts
argument_list|,
name|loopdev
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
name|mnt
operator|->
name|mnt_opts
operator|=
name|str
expr_stmt|;
block|}
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"failed to set up a loop device: %m"
argument_list|)
expr_stmt|;
name|errorcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LOOP_DEVICE */
name|errorcode
operator|=
name|do_mount_linux
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|extra_opts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LOOP_DEVICE
comment|/* if mount failed and we used a loop device, then undo it */
if|if
condition|(
name|errorcode
operator|!=
literal|0
operator|&&
name|loopdev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|delete_loop_device
argument_list|(
name|loopdev
argument_list|)
operator|<
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"mount() failed to release loop device %s: %m"
argument_list|,
name|loopdev
argument_list|)
expr_stmt|;
else|else
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"mount() released loop device %s OK"
argument_list|,
name|loopdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_fsname
condition|)
name|mnt
operator|->
name|mnt_fsname
operator|=
name|old_fsname
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_LOOP_DEVICE */
block|}
comment|/*    * Free all allocated space and return errorcode.    */
name|out
label|:
if|if
condition|(
name|loopdev
condition|)
name|XFREE
argument_list|(
name|loopdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_opts
operator|!=
name|NULL
condition|)
name|XFREE
argument_list|(
name|extra_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_opts
operator|!=
name|NULL
condition|)
name|XFREE
argument_list|(
name|tmp_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_type
operator|!=
name|NULL
condition|)
name|XFREE
argument_list|(
name|sub_type
argument_list|)
expr_stmt|;
return|return
name|errorcode
return|;
block|}
end_function

begin_function
name|int
name|mount_linux
parameter_list|(
name|MTYPE_TYPE
name|type
parameter_list|,
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|errorcode
decl_stmt|;
if|if
condition|(
name|mnt
operator|->
name|mnt_opts
operator|&&
name|STREQ
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|,
literal|"defaults"
argument_list|)
condition|)
name|mnt
operator|->
name|mnt_opts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|index
argument_list|(
name|mnt
operator|->
name|mnt_fsname
argument_list|,
literal|':'
argument_list|)
condition|?
name|MOUNT_TYPE_NFS
else|:
name|MOUNT_TYPE_UFS
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_NFS4
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_NFS4
argument_list|)
condition|)
name|errorcode
operator|=
name|mount_linux_nfs4
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|data
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
name|MOUNT_TYPE_NFS
argument_list|)
condition|)
name|errorcode
operator|=
name|mount_linux_nfs
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
comment|/* non-NFS mounts */
name|errorcode
operator|=
name|mount_linux_nonfs
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|errorcode
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*  * NFS error numbers and Linux errno's are two different things!  Linux is  * `worse' than other OSes in the respect that it loudly complains about  * undefined NFS return value ("bad NFS return value..").  So we should  * translate ANY possible Linux errno to their NFS equivalent.  Just, there  * aren't much NFS numbers, so most go to EINVAL or EIO.  The mapping below  * should fit at least for Linux/i386 and Linux/68k.  I haven't checked  * other architectures yet.  */
end_comment

begin_define
define|#
directive|define
name|NE_PERM
value|1
end_define

begin_define
define|#
directive|define
name|NE_NOENT
value|2
end_define

begin_define
define|#
directive|define
name|NE_IO
value|5
end_define

begin_define
define|#
directive|define
name|NE_NXIO
value|6
end_define

begin_define
define|#
directive|define
name|NE_AGAIN
value|11
end_define

begin_define
define|#
directive|define
name|NE_ACCES
value|13
end_define

begin_define
define|#
directive|define
name|NE_EXIST
value|17
end_define

begin_define
define|#
directive|define
name|NE_NODEV
value|19
end_define

begin_define
define|#
directive|define
name|NE_NOTDIR
value|20
end_define

begin_define
define|#
directive|define
name|NE_ISDIR
value|21
end_define

begin_define
define|#
directive|define
name|NE_INVAL
value|22
end_define

begin_define
define|#
directive|define
name|NE_FBIG
value|27
end_define

begin_define
define|#
directive|define
name|NE_NOSPC
value|28
end_define

begin_define
define|#
directive|define
name|NE_ROFS
value|30
end_define

begin_define
define|#
directive|define
name|NE_OPNOTSUPP
value|45
end_define

begin_define
define|#
directive|define
name|NE_NAMETOOLONG
value|63
end_define

begin_define
define|#
directive|define
name|NE_NOTEMPTY
value|66
end_define

begin_define
define|#
directive|define
name|NE_DQUOT
value|69
end_define

begin_define
define|#
directive|define
name|NE_STALE
value|70
end_define

begin_define
define|#
directive|define
name|NE_REMOTE
value|71
end_define

begin_define
define|#
directive|define
name|NFS_LOMAP
value|0
end_define

begin_define
define|#
directive|define
name|NFS_HIMAP
value|122
end_define

begin_comment
comment|/*  * The errno's below are correct for Linux/i386. One day, somebody  * with lots of energy ought to verify them against the other ports...  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfs_errormap
index|[]
init|=
block|{
literal|0
block|,
comment|/* success(0)		*/
name|NE_PERM
block|,
comment|/* EPERM (1)		*/
name|NE_NOENT
block|,
comment|/* ENOENT (2)		*/
name|NE_INVAL
block|,
comment|/* ESRCH (3)		*/
name|NE_IO
block|,
comment|/* EINTR (4)		*/
name|NE_IO
block|,
comment|/* EIO (5)		*/
name|NE_NXIO
block|,
comment|/* ENXIO (6)		*/
name|NE_INVAL
block|,
comment|/* E2BIG (7)		*/
name|NE_INVAL
block|,
comment|/* ENOEXEC (8)		*/
name|NE_INVAL
block|,
comment|/* EBADF (9)		*/
name|NE_IO
block|,
comment|/* ECHILD (10)		*/
name|NE_AGAIN
block|,
comment|/* EAGAIN (11)		*/
name|NE_IO
block|,
comment|/* ENOMEM (12)		*/
name|NE_ACCES
block|,
comment|/* EACCES (13)		*/
name|NE_INVAL
block|,
comment|/* EFAULT (14)		*/
name|NE_INVAL
block|,
comment|/* ENOTBLK (15)		*/
name|NE_IO
block|,
comment|/* EBUSY (16)		*/
name|NE_EXIST
block|,
comment|/* EEXIST (17)		*/
name|NE_INVAL
block|,
comment|/* EXDEV (18)		*/
name|NE_NODEV
block|,
comment|/* ENODEV (19)		*/
name|NE_NOTDIR
block|,
comment|/* ENOTDIR (20)		*/
name|NE_ISDIR
block|,
comment|/* EISDIR (21)		*/
name|NE_INVAL
block|,
comment|/* EINVAL (22)		*/
name|NE_IO
block|,
comment|/* ENFILE (23)		*/
name|NE_IO
block|,
comment|/* EMFILE (24)		*/
name|NE_INVAL
block|,
comment|/* ENOTTY (25)		*/
name|NE_ACCES
block|,
comment|/* ETXTBSY (26)		*/
name|NE_FBIG
block|,
comment|/* EFBIG (27)		*/
name|NE_NOSPC
block|,
comment|/* ENOSPC (28)		*/
name|NE_INVAL
block|,
comment|/* ESPIPE (29)		*/
name|NE_ROFS
block|,
comment|/* EROFS (30)		*/
name|NE_INVAL
block|,
comment|/* EMLINK (31)		*/
name|NE_INVAL
block|,
comment|/* EPIPE (32)		*/
name|NE_INVAL
block|,
comment|/* EDOM (33)		*/
name|NE_INVAL
block|,
comment|/* ERANGE (34)		*/
name|NE_INVAL
block|,
comment|/* EDEADLK (35)		*/
name|NE_NAMETOOLONG
block|,
comment|/* ENAMETOOLONG (36)	*/
name|NE_INVAL
block|,
comment|/* ENOLCK (37)		*/
name|NE_INVAL
block|,
comment|/* ENOSYS (38)		*/
name|NE_NOTEMPTY
block|,
comment|/* ENOTEMPTY (39)	*/
name|NE_INVAL
block|,
comment|/* ELOOP (40)		*/
name|NE_INVAL
block|,
comment|/* unused (41)		*/
name|NE_INVAL
block|,
comment|/* ENOMSG (42)		*/
name|NE_INVAL
block|,
comment|/* EIDRM (43)		*/
name|NE_INVAL
block|,
comment|/* ECHRNG (44)		*/
name|NE_INVAL
block|,
comment|/* EL2NSYNC (45)	*/
name|NE_INVAL
block|,
comment|/* EL3HLT (46)		*/
name|NE_INVAL
block|,
comment|/* EL3RST (47)		*/
name|NE_INVAL
block|,
comment|/* ELNRNG (48)		*/
name|NE_INVAL
block|,
comment|/* EUNATCH (49)		*/
name|NE_INVAL
block|,
comment|/* ENOCSI (50)		*/
name|NE_INVAL
block|,
comment|/* EL2HLT (51)		*/
name|NE_INVAL
block|,
comment|/* EBADE (52)		*/
name|NE_INVAL
block|,
comment|/* EBADR (53)		*/
name|NE_INVAL
block|,
comment|/* EXFULL (54)		*/
name|NE_INVAL
block|,
comment|/* ENOANO (55)		*/
name|NE_INVAL
block|,
comment|/* EBADRQC (56)		*/
name|NE_INVAL
block|,
comment|/* EBADSLT (57)		*/
name|NE_INVAL
block|,
comment|/* unused (58)		*/
name|NE_INVAL
block|,
comment|/* EBFONT (59)		*/
name|NE_INVAL
block|,
comment|/* ENOSTR (60)		*/
name|NE_INVAL
block|,
comment|/* ENODATA (61)		*/
name|NE_INVAL
block|,
comment|/* ETIME (62)		*/
name|NE_INVAL
block|,
comment|/* ENOSR (63)		*/
name|NE_INVAL
block|,
comment|/* ENONET (64)		*/
name|NE_INVAL
block|,
comment|/* ENOPKG (65)		*/
name|NE_INVAL
block|,
comment|/* EREMOTE (66)		*/
name|NE_INVAL
block|,
comment|/* ENOLINK (67)		*/
name|NE_INVAL
block|,
comment|/* EADV (68)		*/
name|NE_INVAL
block|,
comment|/* ESRMNT (69)		*/
name|NE_IO
block|,
comment|/* ECOMM (70)		*/
name|NE_IO
block|,
comment|/* EPROTO (71)		*/
name|NE_IO
block|,
comment|/* EMULTIHOP (72)	*/
name|NE_IO
block|,
comment|/* EDOTDOT (73)		*/
name|NE_INVAL
block|,
comment|/* EBADMSG (74)		*/
name|NE_INVAL
block|,
comment|/* EOVERFLOW (75)	*/
name|NE_INVAL
block|,
comment|/* ENOTUNIQ (76)	*/
name|NE_INVAL
block|,
comment|/* EBADFD (77)		*/
name|NE_IO
block|,
comment|/* EREMCHG (78)		*/
name|NE_IO
block|,
comment|/* ELIBACC (79)		*/
name|NE_IO
block|,
comment|/* ELIBBAD (80)		*/
name|NE_IO
block|,
comment|/* ELIBSCN (81)		*/
name|NE_IO
block|,
comment|/* ELIBMAX (82)		*/
name|NE_IO
block|,
comment|/* ELIBEXEC (83)	*/
name|NE_INVAL
block|,
comment|/* EILSEQ (84)		*/
name|NE_INVAL
block|,
comment|/* ERESTART (85)	*/
name|NE_INVAL
block|,
comment|/* ESTRPIPE (86)	*/
name|NE_INVAL
block|,
comment|/* EUSERS (87)		*/
name|NE_INVAL
block|,
comment|/* ENOTSOCK (88)	*/
name|NE_INVAL
block|,
comment|/* EDESTADDRREQ (89)	*/
name|NE_INVAL
block|,
comment|/* EMSGSIZE (90)	*/
name|NE_INVAL
block|,
comment|/* EPROTOTYPE (91)	*/
name|NE_INVAL
block|,
comment|/* ENOPROTOOPT (92)	*/
name|NE_INVAL
block|,
comment|/* EPROTONOSUPPORT (93) */
name|NE_INVAL
block|,
comment|/* ESOCKTNOSUPPORT (94) */
name|NE_INVAL
block|,
comment|/* EOPNOTSUPP (95)	*/
name|NE_INVAL
block|,
comment|/* EPFNOSUPPORT (96)	*/
name|NE_INVAL
block|,
comment|/* EAFNOSUPPORT (97)	*/
name|NE_INVAL
block|,
comment|/* EADDRINUSE (98)	*/
name|NE_INVAL
block|,
comment|/* EADDRNOTAVAIL (99)	*/
name|NE_IO
block|,
comment|/* ENETDOWN (100)	*/
name|NE_IO
block|,
comment|/* ENETUNREACH (101)	*/
name|NE_IO
block|,
comment|/* ENETRESET (102)	*/
name|NE_IO
block|,
comment|/* ECONNABORTED (103)	*/
name|NE_IO
block|,
comment|/* ECONNRESET (104)	*/
name|NE_IO
block|,
comment|/* ENOBUFS (105)	*/
name|NE_IO
block|,
comment|/* EISCONN (106)	*/
name|NE_IO
block|,
comment|/* ENOTCONN (107)	*/
name|NE_IO
block|,
comment|/* ESHUTDOWN (108)	*/
name|NE_IO
block|,
comment|/* ETOOMANYREFS (109)	*/
name|NE_IO
block|,
comment|/* ETIMEDOUT (110)	*/
name|NE_IO
block|,
comment|/* ECONNREFUSED (111)	*/
name|NE_IO
block|,
comment|/* EHOSTDOWN (112)	*/
name|NE_IO
block|,
comment|/* EHOSTUNREACH (113)	*/
name|NE_IO
block|,
comment|/* EALREADY (114)	*/
name|NE_IO
block|,
comment|/* EINPROGRESS (115)	*/
name|NE_STALE
block|,
comment|/* ESTALE (116)		*/
name|NE_IO
block|,
comment|/* EUCLEAN (117)	*/
name|NE_INVAL
block|,
comment|/* ENOTNAM (118)	*/
name|NE_INVAL
block|,
comment|/* ENAVAIL (119)	*/
name|NE_INVAL
block|,
comment|/* EISNAM (120)		*/
name|NE_IO
block|,
comment|/* EREMOTEIO (121)	*/
name|NE_DQUOT
block|,
comment|/* EDQUOT (122)		*/
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|linux_nfs_error
parameter_list|(
name|int
name|e
parameter_list|)
block|{
name|int
name|ret
init|=
operator|(
name|nfsstat
operator|)
name|NE_IO
decl_stmt|;
if|if
condition|(
name|e
operator|<
name|NFS_LOMAP
operator|||
name|e
operator|>
name|NFS_HIMAP
condition|)
name|ret
operator|=
operator|(
name|nfsstat
operator|)
name|NE_IO
expr_stmt|;
else|else
name|ret
operator|=
name|nfs_errormap
index|[
name|e
operator|-
name|NFS_LOMAP
index|]
expr_stmt|;
name|dlog
argument_list|(
literal|"linux_nfs_error: map error %d to NFS error %d"
argument_list|,
name|e
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|nfsstat
operator|)
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LOOP_DEVICE
end_ifdef

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*** LOOP DEVICE SUPPORT						  ***/
end_comment

begin_comment
comment|/*** Loop Device setup code taken from mount-2.11g-5.src.rpm, which was   ***/
end_comment

begin_comment
comment|/*** originally written bt Ted T'so and others.				  ***/
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|PROC_DEVICES
value|"/proc/devices"
end_define

begin_if
if|#
directive|if
name|not_used_yet
end_if

begin_function
specifier|static
name|int
name|show_loop
parameter_list|(
name|char
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|loop_info
name|loopinfo
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"loop: can't open device %s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|LOOP_GET_STATUS
argument_list|,
operator|&
name|loopinfo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"loop: can't get info on device %s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dlog
argument_list|(
literal|"show_loop: %s: [%04x]:%ld (%s)"
argument_list|,
name|device
argument_list|,
name|loopinfo
operator|.
name|lo_device
argument_list|,
name|loopinfo
operator|.
name|lo_inode
argument_list|,
name|loopinfo
operator|.
name|lo_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_loop_device
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|loopmajor
init|=
literal|7
decl_stmt|;
return|return
operator|(
name|loopmajor
operator|&&
name|stat
argument_list|(
name|device
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISBLK
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|statbuf
operator|.
name|st_rdev
operator|>>
literal|8
operator|)
operator|==
name|loopmajor
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not_used_yet */
end_comment

begin_comment
comment|/*  * Just creating a device, say in /tmp, is probably a bad idea - people  * might have problems with backup or so.  So, we just try /dev/loop[0-7].  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_unused_loop_device
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|dev
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|loop_formats
index|[]
init|=
block|{
literal|"/dev/loop%d"
block|,
literal|"/dev/loop/%d"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|fd
decl_stmt|,
name|somedev
init|=
literal|0
decl_stmt|,
name|someloop
init|=
literal|0
decl_stmt|,
name|loop_known
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|struct
name|loop_info
name|loopinfo
decl_stmt|;
name|FILE
modifier|*
name|procdev
decl_stmt|;
define|#
directive|define
name|LOOP_FMT_SIZE
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|LOOP_FMT_SIZE
argument_list|(
name|loop_formats
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|xsnprintf
argument_list|(
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
argument_list|)
argument_list|,
name|loop_formats
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dev
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISBLK
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|somedev
operator|++
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|dev
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|LOOP_GET_STATUS
argument_list|,
operator|&
name|loopinfo
argument_list|)
operator|==
literal|0
condition|)
name|someloop
operator|++
expr_stmt|;
comment|/* in use */
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENXIO
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|dev
argument_list|)
return|;
comment|/* probably free */
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* continue trying as long as devices exist */
block|}
break|break;
block|}
block|}
comment|/* Nothing found. Why not? */
if|if
condition|(
operator|(
name|procdev
operator|=
name|fopen
argument_list|(
name|PROC_DEVICES
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|line
index|[
literal|100
index|]
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|procdev
argument_list|)
condition|)
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|" loop\n"
argument_list|)
condition|)
block|{
name|loop_known
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fclose
argument_list|(
name|procdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loop_known
condition|)
name|loop_known
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|somedev
condition|)
block|{
name|dlog
argument_list|(
literal|"Could not find any device /dev/loop#"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|someloop
condition|)
block|{
if|if
condition|(
name|loop_known
operator|==
literal|1
condition|)
block|{
name|dlog
argument_list|(
literal|"Could not find any loop device."
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"...Maybe /dev/loop# has a wrong major number?"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop_known
operator|==
operator|-
literal|1
condition|)
block|{
name|dlog
argument_list|(
literal|"Could not find any loop device, and, according to %s,"
argument_list|,
name|PROC_DEVICES
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"...this kernel does not know about the loop device."
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"... (If so, then recompile or `insmod loop.o'.)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"Could not find any loop device. Maybe this kernel does not know,"
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"...about the loop device (then recompile or `insmod loop.o'), or"
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"...maybe /dev/loop# has the wrong major number?"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"Could not find any free loop device!"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* returns 0 if OK, -1 otherwise */
end_comment

begin_function
name|char
modifier|*
name|setup_loop_device
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|loop_info
name|loopinfo
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ffd
decl_stmt|,
name|mode
decl_stmt|,
name|err
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|find_unused_loop_device
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|dlog
argument_list|(
literal|"no unused loop device"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mode
operator|=
name|O_RDWR
operator||
name|O_LARGEFILE
expr_stmt|;
if|if
condition|(
operator|(
name|ffd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EROFS
condition|)
block|{
name|mode
operator|=
name|O_RDONLY
operator||
name|O_LARGEFILE
expr_stmt|;
name|ffd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffd
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"%s: %m"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"%s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
goto|goto
name|out_close
goto|;
block|}
name|memset
argument_list|(
operator|&
name|loopinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|loopinfo
argument_list|)
argument_list|)
expr_stmt|;
name|xstrlcpy
argument_list|(
name|loopinfo
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|LO_NAME_SIZE
argument_list|)
expr_stmt|;
name|loopinfo
operator|.
name|lo_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|LOOP_SET_FD
argument_list|,
name|ffd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"ioctl: LOOP_SET_FD: %m"
argument_list|)
expr_stmt|;
goto|goto
name|out_close_all
goto|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|LOOP_SET_STATUS
argument_list|,
operator|&
name|loopinfo
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|LOOP_CLR_FD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"ioctl: LOOP_SET_STATUS: %m"
argument_list|)
expr_stmt|;
goto|goto
name|out_close_all
goto|;
block|}
comment|/* if gets here, all is OK */
name|err
operator|=
literal|0
expr_stmt|;
name|out_close_all
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|out_close
label|:
name|close
argument_list|(
name|ffd
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
condition|)
block|{
name|XFREE
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"setup_loop_device(%s,%s): success"
argument_list|,
name|device
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|device
return|;
block|}
block|}
end_function

begin_function
name|int
name|delete_loop_device
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"delete_loop_device: can't delete device %s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|LOOP_CLR_FD
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"ioctl: LOOP_CLR_FD: %m"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"delete_loop_device(%s): success"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LOOP_DEVICE */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

end_unit

