begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2014 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/conf/mtab/mtab_linux.c  *  */
end_comment

begin_comment
comment|/* This file was adapted by Red Hat for Linux from mtab_file.c */
end_comment

begin_comment
comment|/*  * The locking code must be kept in sync with that used  * by the mount command in util-linux, otherwise you'll  * end with with race conditions leading to a corrupt  * /etc/mtab, particularly when AutoFS is used on same  * machine as AMD.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amu.h>
end_include

begin_define
define|#
directive|define
name|NFILE_RETRIES
value|10
end_define

begin_comment
comment|/* number of retries (seconds) */
end_comment

begin_define
define|#
directive|define
name|LOCK_TIMEOUT
value|10
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
end_ifdef

begin_define
define|#
directive|define
name|PROC_MOUNTS
value|"/proc/mounts"
end_define

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|mnt_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information about mtab. ------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_mtab_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|var_mtab_does_not_exist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|var_mtab_is_a_symlink
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for already existing lock file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|we_created_lockfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lockfile_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_mtab_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|mtab_stat
decl_stmt|;
if|if
condition|(
operator|!
name|have_mtab_info
condition|)
block|{
if|if
condition|(
name|lstat
argument_list|(
name|MOUNTED
argument_list|,
operator|&
name|mtab_stat
argument_list|)
condition|)
name|var_mtab_does_not_exist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mtab_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|var_mtab_is_a_symlink
operator|=
literal|1
expr_stmt|;
name|have_mtab_info
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mtab_is_a_symlink
parameter_list|(
name|void
parameter_list|)
block|{
name|get_mtab_info
argument_list|()
expr_stmt|;
return|return
name|var_mtab_is_a_symlink
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtab_is_writable
parameter_list|()
block|{
specifier|static
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
comment|/*    * Should we write to /etc/mtab upon an update?  Probably not if it is a    * symlink to /proc/mounts, since that would create a file /proc/mounts in    * case the proc filesystem is not mounted.    */
if|if
condition|(
name|mtab_is_a_symlink
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|MOUNTED
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setlkw_timeout
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* nothing, fcntl will fail anyway */
block|}
end_function

begin_comment
comment|/*  * Create the lock file.  * The lock file will be removed if we catch a signal or when we exit.  *  * The old code here used flock on a lock file /etc/mtab~ and deleted  * this lock file afterwards.  However, as rgooch remarks, that has a  * race: a second mount may be waiting on the lock and proceed as  * soon as the lock file is deleted by the first mount, and immediately  * afterwards a third mount comes, creates a new /etc/mtab~, applies  * flock to that, and also proceeds, so that the second and third mount  * now both are scribbling in /etc/mtab.  * The new code uses a link() instead of a creat(), where we proceed  * only if it was us that created the lock, and hence we always have  * to delete the lock afterwards.  Now the use of flock() is in principle  * superfluous, but avoids an arbitrary sleep().  */
end_comment

begin_comment
comment|/*  * Where does the link point to?  Obvious choices are mtab and mtab~~.  * HJLu points out that the latter leads to races.  Right now we use  * mtab~.<pid> instead.  */
end_comment

begin_define
define|#
directive|define
name|MOUNTED_LOCK
value|"/etc/mtab~"
end_define

begin_define
define|#
directive|define
name|MOUNTLOCK_LINKTARGET
value|MOUNTED_LOCK "%d"
end_define

begin_function
name|int
name|lock_mtab
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|tries
init|=
literal|100000
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|linktargetfile
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|rc
init|=
literal|1
decl_stmt|;
comment|/*    * Redhat's original code set a signal handler called "handler()" for all    * non-ALRM signals.  The handler called unlock_mntlist(), plog'ed the    * signal name, and then exit(1)!  Never, ever, exit() from inside a    * utility function.  This messed up Amd's careful signal-handling code,    * and caused Amd to abort uncleanly only any other "innocent" signal    * (even simple SIGUSR1), leaving behind a hung Amd mnt point.  That code    * should have at least restored the signal handlers' states upon a    * successful mtab unlocking.  Anyway, that handler was unnecessary,    * because will call unlock_mntlist() properly anyway on exit.    */
name|setup_sighandler
argument_list|(
name|SIGALRM
argument_list|,
name|setlkw_timeout
argument_list|)
expr_stmt|;
comment|/* somewhat clumsy, but some ancient systems do not have snprintf() */
comment|/* use 20 as upper bound for the length of %d output */
name|l
operator|=
name|strlen
argument_list|(
name|MOUNTLOCK_LINKTARGET
argument_list|)
operator|+
literal|20
expr_stmt|;
name|linktargetfile
operator|=
name|xmalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|linktargetfile
argument_list|,
name|l
argument_list|,
name|MOUNTLOCK_LINKTARGET
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|linktargetfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|int
name|errsv
init|=
name|errno
decl_stmt|;
comment|/*      * linktargetfile does not exist (as a file) and we cannot create      * it. Read-only filesystem?  Too many files open in the system?      * Filesystem full?      */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: can't create lock file %s: %s "
literal|"(use -n flag to override)"
argument_list|,
name|__func__
argument_list|,
name|linktargetfile
argument_list|,
name|strerror
argument_list|(
name|errsv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Repeat until it was us who made the link */
while|while
condition|(
operator|!
name|we_created_lockfile
condition|)
block|{
name|struct
name|flock
name|flock
decl_stmt|;
name|int
name|errsv
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|link
argument_list|(
name|linktargetfile
argument_list|,
name|MOUNTED_LOCK
argument_list|)
expr_stmt|;
name|errsv
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
operator|&&
name|errsv
operator|!=
name|EEXIST
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|linktargetfile
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"can't link lock file %s: %s "
argument_list|,
name|MOUNTED_LOCK
argument_list|,
name|strerror
argument_list|(
name|errsv
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|lockfile_fd
operator|=
name|open
argument_list|(
name|MOUNTED_LOCK
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfile_fd
operator|<
literal|0
condition|)
block|{
name|int
name|errsv
init|=
name|errno
decl_stmt|;
comment|/* Strange... Maybe the file was just deleted? */
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|tries
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tries
operator|%
literal|200
operator|==
literal|0
condition|)
name|usleep
argument_list|(
literal|30
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|linktargetfile
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: can't open lock file %s: %s "
argument_list|,
name|__func__
argument_list|,
name|MOUNTED_LOCK
argument_list|,
name|strerror
argument_list|(
name|errsv
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|flock
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|flock
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|flock
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
name|flock
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
comment|/* We made the link. Now claim the lock. */
if|if
condition|(
name|fcntl
argument_list|(
name|lockfile_fd
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|flock
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errsv
init|=
name|errno
decl_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Can't lock lock file %s: %s"
argument_list|,
name|__func__
argument_list|,
name|MOUNTED_LOCK
argument_list|,
name|strerror
argument_list|(
name|errsv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* proceed, since it was us who created the lockfile anyway */
block|}
name|we_created_lockfile
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|linktargetfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|int
name|tries
init|=
literal|0
decl_stmt|;
comment|/* Someone else made the link. Wait. */
name|alarm
argument_list|(
name|LOCK_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|lockfile_fd
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|flock
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errsv
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|linktargetfile
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: can't lock lock file %s: %s"
argument_list|,
name|__func__
argument_list|,
name|MOUNTED_LOCK
argument_list|,
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|?
literal|"timed out"
else|:
name|strerror
argument_list|(
name|errsv
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*        * Limit the number of iterations - maybe there        * still is some old /etc/mtab~        */
operator|++
name|tries
expr_stmt|;
if|if
condition|(
name|tries
operator|%
literal|200
operator|==
literal|0
condition|)
name|usleep
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|>
literal|100000
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|linktargetfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|lockfile_fd
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Cannot create link %s; Perhaps there is a stale lock file?"
argument_list|,
name|__func__
argument_list|,
name|MOUNTED_LOCK
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|close
argument_list|(
name|lockfile_fd
argument_list|)
expr_stmt|;
block|}
block|}
name|error
label|:
name|XFREE
argument_list|(
name|linktargetfile
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|open_locked_mtab
parameter_list|(
specifier|const
name|char
modifier|*
name|mnttabname
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|char
modifier|*
name|fs
parameter_list|)
block|{
name|FILE
modifier|*
name|mfp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mnt_file
condition|)
block|{
name|dlog
argument_list|(
literal|"Forced close on %s in read_mtab"
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
name|endmntent
argument_list|(
name|mnt_file
argument_list|)
expr_stmt|;
name|mnt_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mtab_is_a_symlink
argument_list|()
operator|&&
operator|!
name|lock_mtab
argument_list|()
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Couldn't lock mtab"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mfp
operator|=
name|setmntent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mnttabname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: setmntent(\"%s\", \"%s\"): %m"
argument_list|,
name|__func__
argument_list|,
name|mnttabname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|mfp
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the mount table  */
end_comment

begin_function
name|void
name|unlock_mntlist
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mnt_file
operator|||
name|we_created_lockfile
condition|)
name|dlog
argument_list|(
literal|"unlock_mntlist: releasing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnt_file
condition|)
block|{
name|endmntent
argument_list|(
name|mnt_file
argument_list|)
expr_stmt|;
name|mnt_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|we_created_lockfile
condition|)
block|{
name|close
argument_list|(
name|lockfile_fd
argument_list|)
expr_stmt|;
name|lockfile_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|unlink
argument_list|(
name|MOUNTED_LOCK
argument_list|)
expr_stmt|;
name|we_created_lockfile
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write out a mount list  */
end_comment

begin_function
name|void
name|rewrite_mtab
parameter_list|(
name|mntlist
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|mnttabname
parameter_list|)
block|{
name|FILE
modifier|*
name|mfp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|tmpname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|tmpfd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|mcp
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|mtab_is_writable
argument_list|()
condition|)
block|{
return|return;
block|}
comment|/*    * Concoct a temporary name in the same directory as the target mount    * table so that rename() will work.    */
name|xstrlcpy
argument_list|(
name|mcp
argument_list|,
name|mnttabname
argument_list|,
sizeof|sizeof
argument_list|(
name|mcp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|mcp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|memmove
argument_list|(
name|tmpname
argument_list|,
name|mcp
argument_list|,
name|cp
operator|-
name|mcp
argument_list|)
expr_stmt|;
name|tmpname
index|[
name|cp
operator|-
name|mcp
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"No '/' in mtab (%s), using \".\" as tmp directory"
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
name|tmpname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|tmpname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|xstrlcat
argument_list|(
name|tmpname
argument_list|,
literal|"/mtabXXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpname
argument_list|)
argument_list|)
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|enfile1
label|:
ifdef|#
directive|ifdef
name|HAVE_MKSTEMP
name|tmpfd
operator|=
name|mkstemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|fchmod
argument_list|(
name|tmpfd
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_MKSTEMP */
name|mktemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_MKSTEMP */
if|if
condition|(
name|tmpfd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENFILE
operator|&&
name|retries
operator|++
operator|<
name|NFILE_RETRIES
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|enfile1
goto|;
block|}
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: open: %m"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|close
argument_list|(
name|tmpfd
argument_list|)
operator|<
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Couldn't close tmp file descriptor: %m"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|enfile2
label|:
name|mfp
operator|=
name|setmntent
argument_list|(
name|tmpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfp
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENFILE
operator|&&
name|retries
operator|++
operator|<
name|NFILE_RETRIES
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|enfile2
goto|;
block|}
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: setmntent(\"%s\", \"w\"): %m"
argument_list|,
name|__func__
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|mp
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|mnt
condition|)
block|{
if|if
condition|(
name|addmntent
argument_list|(
name|mfp
argument_list|,
name|mp
operator|->
name|mnt
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Can't write entry to %s"
argument_list|,
name|__func__
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mp
operator|=
name|mp
operator|->
name|mnext
expr_stmt|;
block|}
comment|/*    * SunOS 4.1 manuals say that the return code from entmntent()    * is always 1 and to treat as a void.  That means we need to    * call fflush() to make sure the new mtab file got written.    */
if|if
condition|(
name|fflush
argument_list|(
name|mfp
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"flush new mtab file: %m"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|endmntent
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
comment|/*    * Rename temporary mtab to real mtab    */
if|if
condition|(
name|rename
argument_list|(
name|tmpname
argument_list|,
name|mnttabname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"rename %s to %s: %m"
argument_list|,
name|tmpname
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtab_stripnl
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
do|do
block|{
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
do|while
condition|(
name|s
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Append a mntent structure to the  * current mount table.  */
end_comment

begin_function
name|void
name|write_mntent
parameter_list|(
name|mntent_t
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|mnttabname
parameter_list|)
block|{
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|mfp
decl_stmt|;
if|if
condition|(
operator|!
name|mtab_is_writable
argument_list|()
condition|)
block|{
return|return;
block|}
name|enfile
label|:
name|mfp
operator|=
name|open_locked_mtab
argument_list|(
name|mnttabname
argument_list|,
literal|"a"
argument_list|,
name|mp
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfp
condition|)
block|{
name|mtab_stripnl
argument_list|(
name|mp
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|addmntent
argument_list|(
name|mfp
argument_list|,
name|mp
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Couldn't write %s: %m"
argument_list|,
name|__func__
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|mfp
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: Couldn't flush %s: %m"
argument_list|,
name|__func__
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|endmntent
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|ENFILE
operator|&&
name|retries
operator|<
name|NFILE_RETRIES
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|enfile
goto|;
block|}
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: setmntent(\"%s\", \"a\"): %m"
argument_list|,
name|__func__
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
block|}
name|unlock_mntlist
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MOUNT_TABLE_ON_FILE */
end_comment

begin_function
specifier|static
name|mntent_t
modifier|*
name|mnt_dup
parameter_list|(
name|mntent_t
modifier|*
name|mp
parameter_list|)
block|{
name|mntent_t
modifier|*
name|new_mp
init|=
name|ALLOC
argument_list|(
name|mntent_t
argument_list|)
decl_stmt|;
name|new_mp
operator|->
name|mnt_fsname
operator|=
name|xstrdup
argument_list|(
name|mp
operator|->
name|mnt_fsname
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|mnt_dir
operator|=
name|xstrdup
argument_list|(
name|mp
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|mnt_type
operator|=
name|xstrdup
argument_list|(
name|mp
operator|->
name|mnt_type
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|mnt_opts
operator|=
name|xstrdup
argument_list|(
name|mp
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|mnt_freq
operator|=
name|mp
operator|->
name|mnt_freq
expr_stmt|;
name|new_mp
operator|->
name|mnt_passno
operator|=
name|mp
operator|->
name|mnt_passno
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_TIME
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_TIME_STRING
name|new_mp
operator|->
name|mnt_time
operator|=
name|xstrdup
argument_list|(
name|mp
operator|->
name|mnt_time
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_MNTENT_T_MNT_TIME_STRING */
name|new_mp
operator|->
name|mnt_time
operator|=
name|mp
operator|->
name|mnt_time
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_MNTENT_T_MNT_TIME_STRING */
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_TIME */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_CNODE
name|new_mp
operator|->
name|mnt_cnode
operator|=
name|mp
operator|->
name|mnt_cnode
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_CNODE */
return|return
name|new_mp
return|;
block|}
end_function

begin_comment
comment|/*  * Read a mount table into memory  */
end_comment

begin_function
name|mntlist
modifier|*
name|read_mtab
parameter_list|(
name|char
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|mnttabname
parameter_list|)
block|{
name|mntlist
modifier|*
modifier|*
name|mpp
decl_stmt|,
modifier|*
name|mhp
decl_stmt|;
name|mntent_t
modifier|*
name|mep
decl_stmt|;
name|FILE
modifier|*
name|mfp
init|=
name|open_locked_mtab
argument_list|(
name|mnttabname
argument_list|,
literal|"r+"
argument_list|,
name|fs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mfp
condition|)
return|return
literal|0
return|;
name|mpp
operator|=
operator|&
name|mhp
expr_stmt|;
comment|/*    * XXX - In SunOS 4 there is (yet another) memory leak    * which loses 1K the first time getmntent is called.    * (jsp)    */
while|while
condition|(
operator|(
name|mep
operator|=
name|getmntent
argument_list|(
name|mfp
argument_list|)
operator|)
condition|)
block|{
comment|/*      * Allocate a new slot      */
operator|*
name|mpp
operator|=
name|ALLOC
argument_list|(
expr|struct
name|mntlist
argument_list|)
expr_stmt|;
comment|/*      * Copy the data returned by getmntent      */
operator|(
operator|*
name|mpp
operator|)
operator|->
name|mnt
operator|=
name|mnt_dup
argument_list|(
name|mep
argument_list|)
expr_stmt|;
comment|/*      * Move to next pointer      */
name|mpp
operator|=
operator|&
operator|(
operator|*
name|mpp
operator|)
operator|->
name|mnext
expr_stmt|;
block|}
operator|*
name|mpp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
comment|/*    * If we are not updating the mount table then we    * can free the resources held here, otherwise they    * must be held until the mount table update is complete    */
name|mnt_file
operator|=
name|mfp
expr_stmt|;
else|#
directive|else
comment|/* not MOUNT_TABLE_ON_FILE */
name|endmntent
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MOUNT_TABLE_ON_FILE */
return|return
name|mhp
return|;
block|}
end_function

end_unit

