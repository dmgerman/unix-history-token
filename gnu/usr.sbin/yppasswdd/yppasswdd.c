begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * yppasswdd  * Copyright 1994 Olaf Kirch,<okir@monad.swb.de>  *  * This program is covered by the GNU General Public License, version 2.  * It is provided in the hope that it is useful. However, the author  * disclaims ALL WARRANTIES, expressed or implied. See the GPL for details.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_clnt.h>
end_include

begin_include
include|#
directive|include
file|"yppasswd.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|pw_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|version
init|=
literal|"yppasswdd "
name|VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|passfile
init|=
name|_PATH_MASTERPASSWD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allow_chfn
init|=
literal|0
decl_stmt|,
name|allow_chsh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|xprt_addr
parameter_list|(
name|xprt
parameter_list|)
value|(svc_getcaller(xprt)->sin_addr)
end_define

begin_define
define|#
directive|define
name|xprt_port
parameter_list|(
name|xprt
parameter_list|)
value|ntohs(svc_getcaller(xprt)->sin_port)
end_define

begin_function_decl
name|void
name|yppasswdprog_1
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reaper
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*==============================================================*  * RPC dispatch function  *==============================================================*/
end_comment

begin_function
name|void
name|yppasswdprog_1
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
union|union
block|{
name|yppasswd
name|yppasswdproc_update_1_arg
decl_stmt|;
block|}
name|argument
union|;
name|char
modifier|*
name|result
decl_stmt|;
name|xdrproc_t
name|xdr_argument
decl_stmt|,
name|xdr_result
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|NULLPROC
case|:
operator|(
name|void
operator|)
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|YPPASSWDPROC_UPDATE
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_yppasswd
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_int
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|yppasswdproc_pwupdate_1
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|argument
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
operator|&
name|argument
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
operator|&&
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_result
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to free arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage: %s [-m master password file] [-f] [-s] [-h] [-v]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reaper
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
specifier|extern
name|pid_t
name|pid
decl_stmt|;
specifier|extern
name|int
name|pstat
decl_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|pstat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|install_reaper
parameter_list|(
name|int
name|on
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|reaper
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
block|}
else|else
block|{
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
block|}
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|opterr
decl_stmt|;
name|int
name|c
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|program_name
operator|=
operator|++
name|sp
expr_stmt|;
block|}
comment|/* Parse the command line options and arguments. */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"m:fshv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
name|passfile
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|allow_chfn
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|allow_chsh
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp_get_default_domain
argument_list|(
operator|&
name|domain
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: NIS domain name not set -- aborting\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We can call this here since it does some necessary setup 	 * for us (blocking signals, setting resourse limits, etc. 	 */
name|pw_init
argument_list|()
expr_stmt|;
comment|/* Initialize logging.      */
name|openlog
argument_list|(
literal|"yppasswdd"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
comment|/* Register a signal handler to reap children after they terminated      */
name|install_reaper
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Create the RPC server      */
operator|(
name|void
operator|)
name|pmap_unset
argument_list|(
name|YPPASSWDPROG
argument_list|,
name|YPPASSWDVERS
argument_list|)
expr_stmt|;
name|transp
operator|=
name|svcudp_create
argument_list|(
name|RPC_ANYSOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|transp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot create udp service.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_register
argument_list|(
name|transp
argument_list|,
name|YPPASSWDPROG
argument_list|,
name|YPPASSWDVERS
argument_list|,
name|yppasswdprog_1
argument_list|,
name|IPPROTO_UDP
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to register yppaswdd udp service.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Run the server      */
name|svc_run
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"svc_run returned\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

