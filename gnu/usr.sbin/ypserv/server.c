begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** server.c			YP server routines. ** ** Copyright (c) 1993 Signum Support AB, Sweden ** ** This file is part of the NYS YP Server. ** ** The NYS YP Server is free software; you can redistribute it and/or ** modify it under the terms of the GNU General Public License as ** published by the Free Software Foundation; either version 2 of the ** License, or (at your option) any later version. ** ** The NYS YP Server is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU ** General Public License for more details. ** ** You should have received a copy of the GNU General Public ** License along with the NYS YP Server; see the file COPYING.  If ** not, write to the Free Software Foundation, Inc., 675 Mass Ave, ** Cambridge, MA 02139, USA. ** ** Author: Peter Eriksson<pen@signum.se> ** Ported to FreeBSD and hacked all to pieces ** by Bill Paul<wpaul@ctr.columbia.edu> ** ** $FreeBSD$ ** */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|"yp.h"
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PERM_SECURE
value|(S_IRUSR|S_IWUSR)
end_define

begin_decl_stmt
name|HASHINFO
name|openinfo
init|=
block|{
literal|4096
block|,
comment|/* bsize */
literal|32
block|,
comment|/* ffactor */
literal|256
block|,
comment|/* nelem */
literal|2048
operator|*
literal|1024
block|,
comment|/* cachesize */
name|NULL
block|,
comment|/* hash */
literal|0
block|,
comment|/* lorder */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TCP_WRAPPER
end_if

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_decl_stmt
name|int
name|allow_severity
init|=
name|LOG_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deny_severity
init|=
name|LOG_WARNING
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|verr
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|_BSD_VA_LIST_
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|Perror
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|dnsname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|dnsaddr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|_gethostbydnsaddr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dns_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|children
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|verr
parameter_list|(
name|fmt
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|_BSD_VA_LIST_
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|debug_flag
condition|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|vsyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|Perror
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|Perror
parameter_list|(
name|fmt
parameter_list|,
name|va_list
parameter_list|)
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|verr
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Return 1 if request comes from an authorized host ** ** XXX This function should implement the "securenets" functionality */
end_comment

begin_function
specifier|static
name|int
name|is_valid_host
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|)
block|{
if|#
directive|if
name|TCP_WRAPPER
specifier|extern
name|int
name|hosts_ctl
argument_list|(
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|static
name|long
name|oldaddr
init|=
literal|0
decl_stmt|;
comment|/* so we dont log multiple times */
specifier|static
name|int
name|oldstatus
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|TRYRESOLVE
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|_gethostbydnsaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|hp
operator|&&
name|hp
operator|->
name|h_name
operator|)
condition|?
name|hp
operator|->
name|h_name
else|:
name|NULL
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FROM_UNKNOWN
define|#
directive|define
name|FROM_UNKNOWN
value|STRING_UNKNOWN
endif|#
directive|endif
name|status
operator|=
name|hosts_ctl
argument_list|(
name|progname
argument_list|,
name|h
condition|?
name|h
else|:
name|FROM_UNKNOWN
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|&&
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|oldaddr
operator|||
name|status
operator|!=
name|oldstatus
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|status
condition|?
name|allow_severity
else|:
name|deny_severity
argument_list|,
literal|"%sconnect from %s\n"
argument_list|,
name|status
condition|?
literal|""
else|:
literal|"refused "
argument_list|,
name|h
condition|?
name|h
else|:
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|oldaddr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|oldstatus
operator|=
name|status
expr_stmt|;
block|}
return|return
name|status
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
modifier|*
name|ypproc_null_2_svc
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|int
name|foo
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"ypproc_null() [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|foo
return|;
block|}
end_function

begin_comment
comment|/* ** Return 1 if the name is a valid domain name served by us, else 0. */
end_comment

begin_function
specifier|static
name|int
name|is_valid_domain
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|domain
argument_list|,
literal|"binding"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|domain
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
argument_list|(
name|domain
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|sbuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|bool_t
modifier|*
name|ypproc_domain_2_svc
parameter_list|(
name|domainname
modifier|*
name|name
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|bool_t
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"ypproc_domain(\"%s\") [From: %s:%d]\n"
argument_list|,
operator|*
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|is_valid_domain
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
else|else
name|result
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> %s.\n"
argument_list|,
operator|(
name|result
operator|==
name|TRUE
condition|?
literal|"Ok"
else|:
literal|"Not served by us"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
name|bool_t
modifier|*
name|ypproc_domain_nonack_2_svc
parameter_list|(
name|domainname
modifier|*
name|name
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|bool_t
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"ypproc_domain_nonack(\"%s\") [From: %s:%d]\n"
argument_list|,
operator|*
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid domain)\n"
argument_list|)
expr_stmt|;
comment|/* Bail out and don't return any RPC value */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> OK.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
end_function

begin_comment
comment|/* ** Open a DB database */
end_comment

begin_function
specifier|static
name|DB
modifier|*
name|open_database
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|DB
modifier|*
name|dbp
decl_stmt|;
name|char
name|buf
index|[
literal|1025
index|]
decl_stmt|;
if|if
condition|(
name|map
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|strchr
argument_list|(
name|map
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
literal|0
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|domain
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|dbopen
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
operator||
name|O_EXCL
argument_list|,
name|PERM_SECURE
argument_list|,
name|DB_HASH
argument_list|,
operator|&
name|openinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
operator|>
literal|1
operator|&&
name|dbp
operator|==
name|NULL
condition|)
name|Perror
argument_list|(
literal|"dbopen(%s): %s"
argument_list|,
name|map
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dbp
return|;
block|}
end_function

begin_define
define|#
directive|define
name|F_ALL
value|0x01
end_define

begin_define
define|#
directive|define
name|F_NEXT
value|0x02
end_define

begin_define
define|#
directive|define
name|F_YPALL
value|0x08
end_define

begin_comment
comment|/* ** Get a record from a DB database. ** This looks ugly because it emulates the behavior of the original ** GDBM-based routines. Blech. */
end_comment

begin_function
name|int
name|read_database
parameter_list|(
name|DB
modifier|*
name|dbp
parameter_list|,
specifier|const
name|DBT
modifier|*
name|ikey
parameter_list|,
name|DBT
modifier|*
name|okey
parameter_list|,
name|DBT
modifier|*
name|dval
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|first_flag
init|=
literal|0
decl_stmt|;
name|DBT
name|nkey
decl_stmt|,
name|ckey
decl_stmt|,
name|dummyval
decl_stmt|;
if|if
condition|(
name|ikey
operator|==
name|NULL
operator|||
name|ikey
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
call|(
name|dbp
operator|->
name|seq
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|dummyval
argument_list|,
name|R_FIRST
argument_list|)
expr_stmt|;
name|first_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|F_NEXT
operator|)
condition|)
block|{
comment|/* 	** This crap would be unnecessary if R_CURSOR actually worked. 	*/
if|if
condition|(
name|flags
operator|<
name|F_YPALL
condition|)
block|{
call|(
name|dbp
operator|->
name|seq
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|dummyval
argument_list|,
name|R_FIRST
argument_list|)
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ikey
operator|->
name|data
argument_list|,
name|ckey
operator|.
name|data
argument_list|,
operator|(
name|int
operator|)
name|ikey
operator|->
name|size
argument_list|)
operator|||
name|ikey
operator|->
name|size
operator|!=
name|ckey
operator|.
name|size
condition|)
call|(
name|dbp
operator|->
name|seq
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|dummyval
argument_list|,
name|R_NEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
call|(
name|dbp
operator|->
name|seq
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|ckey
argument_list|,
operator|&
name|dummyval
argument_list|,
name|R_NEXT
argument_list|)
condition|)
name|ckey
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|dummyval
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ckey
operator|=
operator|*
name|ikey
expr_stmt|;
block|}
if|if
condition|(
name|ckey
operator|.
name|data
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|flags
operator|&
name|F_NEXT
operator|)
condition|?
name|YP_NOMORE
else|:
name|YP_NOKEY
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
call|(
name|dbp
operator|->
name|get
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|ckey
argument_list|,
name|dval
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
comment|/* Free key, unless it comes from the caller! */
if|if
condition|(
name|ikey
operator|==
name|NULL
operator|||
name|ckey
operator|.
name|data
operator|!=
name|ikey
operator|->
name|data
condition|)
name|free
argument_list|(
name|ckey
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ikey
operator|&&
name|ikey
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
return|return
name|YP_NOKEY
return|;
block|}
elseif|else
if|if
condition|(
name|first_flag
condition|)
return|return
name|YP_BADDB
return|;
else|else
return|return
name|YP_FALSE
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|F_ALL
operator|)
operator|||
name|strncmp
argument_list|(
name|ckey
operator|.
name|data
argument_list|,
literal|"YP_"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|okey
condition|)
operator|*
name|okey
operator|=
name|ckey
expr_stmt|;
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
elseif|else
if|if
condition|(
name|ikey
operator|==
name|NULL
operator|||
name|ikey
operator|->
name|data
operator|!=
name|ckey
operator|.
name|data
condition|)
name|free
argument_list|(
name|ckey
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|YP_TRUE
return|;
block|}
comment|/* Free old value */
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|dval
operator|->
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
call|(
name|dbp
operator|->
name|seq
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|nkey
argument_list|,
operator|&
name|dummyval
argument_list|,
name|R_NEXT
argument_list|)
condition|)
name|nkey
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|dummyval
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* Free old key, unless it comes from the caller! */
if|if
condition|(
name|ikey
operator|==
name|NULL
operator|||
name|ckey
operator|.
name|data
operator|!=
name|ikey
operator|->
name|data
condition|)
name|free
argument_list|(
name|ckey
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ckey
operator|.
name|data
operator|==
name|NULL
operator|||
name|nkey
operator|.
name|data
operator|==
name|NULL
condition|)
return|return
name|YP_NOMORE
return|;
name|ckey
operator|=
name|nkey
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Get the DateTimeModified value for a certain map database */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_dtm
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|char
name|buf
index|[
literal|1025
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
name|unsigned
name|long
operator|)
name|sbuf
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* ** YP function "MATCH" implementation */
end_comment

begin_function
name|ypresp_val
modifier|*
name|ypproc_match_2_svc
parameter_list|(
name|ypreq_key
modifier|*
name|key
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_val
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_match(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tdomainname = \"%s\"\n"
argument_list|,
name|key
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tmapname = \"%s\"\n"
argument_list|,
name|key
operator|->
name|map
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tkeydat = \"%.*s\"\n"
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|key
operator|.
name|keydat_len
argument_list|,
name|key
operator|->
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*     ** If this request deals with master.passwd.* and it didn't     ** originate on a privileged port (< 1024), return a YP_YPERR.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|strstr
argument_list|(
name|key
operator|->
name|map
argument_list|,
literal|"master.passwd"
argument_list|)
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|val
operator|.
name|valdat_val
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
comment|/* 	 * In general, if you malloc() data in an RPC service 	 * routine, you have to free() it the next time that 	 * routine is called since the XDR routines won't free 	 * it for you. However, in this case, we don't have to 	 * do that because the DB routines do garbage collection 	 * for us. 	 */
name|free
argument_list|(
name|result
operator|.
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|key
operator|->
name|map
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
name|key
operator|->
name|domain
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DBT
name|rdat
decl_stmt|,
name|qdat
decl_stmt|;
name|DB
modifier|*
name|dbp
init|=
name|open_database
argument_list|(
name|key
operator|->
name|domain
argument_list|,
name|key
operator|->
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NOMAP
expr_stmt|;
else|else
block|{
name|qdat
operator|.
name|size
operator|=
name|key
operator|->
name|key
operator|.
name|keydat_len
expr_stmt|;
name|qdat
operator|.
name|data
operator|=
name|key
operator|->
name|key
operator|.
name|keydat_val
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|read_database
argument_list|(
name|dbp
argument_list|,
operator|&
name|qdat
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdat
argument_list|,
name|F_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|rdat
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|rdat
operator|.
name|data
expr_stmt|;
block|}
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_flag
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
name|Perror
argument_list|(
literal|"\t-> Value = \"%.*s\"\n"
argument_list|,
operator|(
name|int
operator|)
name|result
operator|.
name|val
operator|.
name|valdat_len
argument_list|,
name|result
operator|.
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
else|else
name|Perror
argument_list|(
literal|"\t-> Error #%d\n"
argument_list|,
name|result
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
comment|/*     ** Do the jive thing if we didn't find the host in the YP map     ** and we have enabled the magic DNS lookup stuff.     **     ** DNS lookups are handled in a subprocess so that the server     ** doesn't block while waiting for requests to complete.     */
if|if
condition|(
name|result
operator|.
name|stat
operator|!=
name|YP_TRUE
operator|&&
name|strstr
argument_list|(
name|key
operator|->
name|map
argument_list|,
literal|"hosts"
argument_list|)
operator|&&
name|dns_flag
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|char
name|nbuf
index|[
name|YPMAXRECORD
index|]
decl_stmt|;
if|if
condition|(
name|children
operator|<
name|MAX_CHILDREN
operator|&&
name|fork
argument_list|()
condition|)
block|{
name|children
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
name|forked
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|key
operator|->
name|key
operator|.
name|keydat_val
argument_list|,
name|nbuf
argument_list|,
name|key
operator|->
name|key
operator|.
name|keydat_len
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|key
operator|->
name|key
operator|.
name|keydat_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"Doing DNS lookup of %s\n"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
operator|->
name|map
argument_list|,
literal|"hosts.byname"
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
name|dnsname
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
operator|->
name|map
argument_list|,
literal|"hosts.byaddr"
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
name|dnsaddr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> OK (%s)\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|cp
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"\t-> Not Found\n"
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"DNS lookup: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|stat
operator|=
name|YP_NOKEY
expr_stmt|;
block|}
block|}
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
name|ypresp_key_val
modifier|*
name|ypproc_first_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|key
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_key_val
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_first(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\tdomainname = \"%s\"\n"
argument_list|,
name|key
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\tmapname = \"%s\"\n"
argument_list|,
name|key
operator|->
name|map
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|Perror("\tkeydat = \"%.*s\"\n", 		(int) key->key.keydat_len, 		key->key.keydat_val);
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*     ** If this request deals with master.passwd.* and it didn't     ** originate on a privileged port (< 1024), return a YP_YPERR.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|strstr
argument_list|(
name|key
operator|->
name|map
argument_list|,
literal|"master.passwd"
argument_list|)
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|key
operator|.
name|keydat_val
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|result
operator|.
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|NULL
expr_stmt|;
block|}
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|val
operator|.
name|valdat_val
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|result
operator|.
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|map
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|key
operator|->
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
name|key
operator|->
name|domain
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DBT
name|dkey
decl_stmt|,
name|dval
decl_stmt|;
name|DB
modifier|*
name|dbp
init|=
name|open_database
argument_list|(
name|key
operator|->
name|domain
argument_list|,
name|key
operator|->
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NOMAP
expr_stmt|;
else|else
block|{
name|result
operator|.
name|stat
operator|=
name|read_database
argument_list|(
name|dbp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dkey
argument_list|,
operator|&
name|dval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|dkey
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|dkey
operator|.
name|data
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|dval
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|dval
operator|.
name|data
expr_stmt|;
block|}
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_flag
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
name|Perror
argument_list|(
literal|"\t-> Key = \"%.*s\", Value = \"%.*s\"\n"
argument_list|,
operator|(
name|int
operator|)
name|result
operator|.
name|key
operator|.
name|keydat_len
argument_list|,
name|result
operator|.
name|key
operator|.
name|keydat_val
argument_list|,
operator|(
name|int
operator|)
name|result
operator|.
name|val
operator|.
name|valdat_len
argument_list|,
name|result
operator|.
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
else|else
name|Perror
argument_list|(
literal|"\t-> Error #%d\n"
argument_list|,
name|result
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
name|ypresp_key_val
modifier|*
name|ypproc_next_2_svc
parameter_list|(
name|ypreq_key
modifier|*
name|key
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_key_val
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_next(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\tdomainname = \"%s\"\n"
argument_list|,
name|key
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\tmapname = \"%s\"\n"
argument_list|,
name|key
operator|->
name|map
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\tkeydat = \"%.*s\"\n"
argument_list|,
operator|(
name|int
operator|)
name|key
operator|->
name|key
operator|.
name|keydat_len
argument_list|,
name|key
operator|->
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*     ** If this request deals with master.passwd.* and it didn't     ** originate on a privileged port (< 1024), return a YP_YPERR.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|strstr
argument_list|(
name|key
operator|->
name|map
argument_list|,
literal|"master.passwd"
argument_list|)
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|key
operator|.
name|keydat_val
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|result
operator|.
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|NULL
expr_stmt|;
block|}
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|val
operator|.
name|valdat_val
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|result
operator|.
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|map
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|key
operator|->
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
name|key
operator|->
name|domain
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DBT
name|dkey
decl_stmt|,
name|dval
decl_stmt|,
name|okey
decl_stmt|;
name|DB
modifier|*
name|dbp
init|=
name|open_database
argument_list|(
name|key
operator|->
name|domain
argument_list|,
name|key
operator|->
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NOMAP
expr_stmt|;
else|else
block|{
name|dkey
operator|.
name|size
operator|=
name|key
operator|->
name|key
operator|.
name|keydat_len
expr_stmt|;
name|dkey
operator|.
name|data
operator|=
name|key
operator|->
name|key
operator|.
name|keydat_val
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|read_database
argument_list|(
name|dbp
argument_list|,
operator|&
name|dkey
argument_list|,
operator|&
name|okey
argument_list|,
operator|&
name|dval
argument_list|,
name|F_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|okey
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|okey
operator|.
name|data
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|dval
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|dval
operator|.
name|data
expr_stmt|;
block|}
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_flag
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
name|Perror
argument_list|(
literal|"\t-> Key = \"%.*s\", Value = \"%.*s\"\n"
argument_list|,
operator|(
name|int
operator|)
name|result
operator|.
name|key
operator|.
name|keydat_len
argument_list|,
name|result
operator|.
name|key
operator|.
name|keydat_val
argument_list|,
operator|(
name|int
operator|)
name|result
operator|.
name|val
operator|.
name|valdat_len
argument_list|,
name|result
operator|.
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
else|else
name|Perror
argument_list|(
literal|"\t-> Error #%d\n"
argument_list|,
name|result
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_ypmap_parms
parameter_list|(
specifier|const
name|struct
name|ypmap_parms
modifier|*
name|pp
parameter_list|)
block|{
name|Perror
argument_list|(
literal|"\t\tdomain   = \"%s\"\n"
argument_list|,
name|pp
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tmap      = \"%s\"\n"
argument_list|,
name|pp
operator|->
name|map
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tordernum = %u\n"
argument_list|,
name|pp
operator|->
name|ordernum
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tpeer     = \"%s\"\n"
argument_list|,
name|pp
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Clean up after child processes signal their termination. */
end_comment

begin_function
name|void
name|reapchild
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|st
decl_stmt|;
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|st
argument_list|,
name|WNOHANG
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
name|children
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Stole the ypxfr implementation from the yps package. */
end_comment

begin_function
name|ypresp_xfr
modifier|*
name|ypproc_xfr_2_svc
parameter_list|(
name|ypreq_xfr
modifier|*
name|xfr
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_xfr
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|char
name|ypxfr_command
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|ypresp_master
modifier|*
name|mres
decl_stmt|;
name|ypreq_nokey
name|mreq
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_xfr_2_svc(): [From: %s:%d]\n\tmap_parms:\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|print_ypmap_parms
argument_list|(
operator|&
name|xfr
operator|->
name|map_parms
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\ttransid = %u\n"
argument_list|,
name|xfr
operator|->
name|transid
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tprog = %u\n"
argument_list|,
name|xfr
operator|->
name|prog
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tport = %u\n"
argument_list|,
name|xfr
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*     ** If this request originates on a non-privileged port (< 1024),     ** refuse it. We really only need to guard the master.passwd.*     ** maps, but what the hell.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_REFUSED
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
name|mreq
operator|.
name|domain
operator|=
name|xfr
operator|->
name|map_parms
operator|.
name|domain
expr_stmt|;
name|mreq
operator|.
name|map
operator|=
name|xfr
operator|->
name|map_parms
operator|.
name|map
expr_stmt|;
name|mres
operator|=
name|ypproc_master_2_svc
argument_list|(
operator|&
name|mreq
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mres
operator|->
name|stat
operator|!=
name|YP_TRUE
condition|)
block|{
name|Perror
argument_list|(
literal|"couldn't find master for map %s@%s"
argument_list|,
name|xfr
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|xfr
operator|->
name|map_parms
operator|.
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"host at %s (%s) may be pulling my leg"
argument_list|,
name|xfr
operator|->
name|map_parms
operator|.
name|peer
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_REFUSED
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|g
index|[
literal|11
index|]
decl_stmt|,
name|t
index|[
literal|11
index|]
decl_stmt|,
name|p
index|[
literal|11
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|ypxfr_command
argument_list|,
literal|"%s/ypxfr"
argument_list|,
name|INSTDIR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%u"
argument_list|,
name|xfr
operator|->
name|transid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|g
argument_list|,
literal|"%u"
argument_list|,
name|xfr
operator|->
name|prog
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%u"
argument_list|,
name|xfr
operator|->
name|port
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|ypxfr_command
argument_list|,
literal|"ypxfr"
argument_list|,
literal|"-d"
argument_list|,
name|xfr
operator|->
name|map_parms
operator|.
name|domain
argument_list|,
literal|"-h"
argument_list|,
name|mres
operator|->
name|peer
argument_list|,
literal|"-f"
argument_list|,
literal|"-C"
argument_list|,
name|t
argument_list|,
name|g
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|p
argument_list|,
name|xfr
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"ypxfr execl(): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
case|case
operator|-
literal|1
case|:
name|Perror
argument_list|(
literal|"fork(): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_XFRERR
expr_stmt|;
default|default:
block|{
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_SUCC
expr_stmt|;
break|break;
block|}
block|}
name|result
operator|.
name|transid
operator|=
name|xfr
operator|->
name|transid
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ypproc_clear_2_svc
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|int
name|foo
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"ypproc_clear_2_svc() [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|foo
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ypall_close
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|DB
modifier|*
name|locptr
decl_stmt|;
if|if
condition|(
name|debug_flag
operator|&&
name|data
operator|==
name|NULL
condition|)
block|{
name|Perror
argument_list|(
literal|"ypall_close() called with NULL pointer.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|locptr
operator|=
operator|(
name|DB
operator|*
operator|)
name|data
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|locptr
operator|->
name|close
argument_list|)
argument_list|(
name|locptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ypall_encode
parameter_list|(
name|ypresp_key_val
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|DBT
name|dkey
decl_stmt|,
name|dval
decl_stmt|,
name|okey
decl_stmt|;
name|dkey
operator|.
name|data
operator|=
name|val
operator|->
name|key
operator|.
name|keydat_val
expr_stmt|;
name|dkey
operator|.
name|size
operator|=
name|val
operator|->
name|key
operator|.
name|keydat_len
expr_stmt|;
name|val
operator|->
name|stat
operator|=
name|read_database
argument_list|(
operator|(
name|DB
operator|*
operator|)
name|data
argument_list|,
operator|&
name|dkey
argument_list|,
operator|&
name|okey
argument_list|,
operator|&
name|dval
argument_list|,
name|F_NEXT
operator||
name|F_YPALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|->
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|val
operator|->
name|key
operator|.
name|keydat_val
operator|=
name|okey
operator|.
name|data
expr_stmt|;
name|val
operator|->
name|key
operator|.
name|keydat_len
operator|=
name|okey
operator|.
name|size
expr_stmt|;
name|val
operator|->
name|val
operator|.
name|valdat_val
operator|=
name|dval
operator|.
name|data
expr_stmt|;
name|val
operator|->
name|val
operator|.
name|valdat_len
operator|=
name|dval
operator|.
name|size
expr_stmt|;
block|}
return|return
name|val
operator|->
name|stat
return|;
block|}
end_function

begin_function
name|ypresp_all
modifier|*
name|ypproc_all_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|nokey
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_all
name|result
decl_stmt|;
specifier|extern
name|__xdr_ypall_cb_t
name|__xdr_ypall_cb
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_all_2_svc(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tdomain = \"%s\"\n"
argument_list|,
name|nokey
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tmap = \"%s\"\n"
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|children
operator|<
name|MAX_CHILDREN
operator|&&
name|fork
argument_list|()
condition|)
block|{
name|children
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
name|forked
operator|++
expr_stmt|;
name|__xdr_ypall_cb
operator|.
name|u
operator|.
name|encode
operator|=
name|NULL
expr_stmt|;
name|__xdr_ypall_cb
operator|.
name|u
operator|.
name|close
operator|=
name|NULL
expr_stmt|;
name|__xdr_ypall_cb
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|result
operator|.
name|more
operator|=
name|TRUE
expr_stmt|;
comment|/*     ** If this request deals with master.passwd.* and it didn't     ** originate on a privileged port (< 1024), return a YP_YPERR.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|strstr
argument_list|(
name|nokey
operator|->
name|map
argument_list|,
literal|"master.passwd"
argument_list|)
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
if|if
condition|(
name|nokey
operator|->
name|map
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|nokey
operator|->
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
name|nokey
operator|->
name|domain
argument_list|)
condition|)
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DBT
name|dkey
decl_stmt|,
name|dval
decl_stmt|;
name|DB
modifier|*
name|dbp
init|=
name|open_database
argument_list|(
name|nokey
operator|->
name|domain
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_NOMAP
expr_stmt|;
else|else
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|read_database
argument_list|(
name|dbp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dkey
argument_list|,
operator|&
name|dval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|dkey
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|dkey
operator|.
name|data
expr_stmt|;
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|dval
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|dval
operator|.
name|data
expr_stmt|;
name|__xdr_ypall_cb
operator|.
name|u
operator|.
name|encode
operator|=
name|ypall_encode
expr_stmt|;
name|__xdr_ypall_cb
operator|.
name|u
operator|.
name|close
operator|=
name|ypall_close
expr_stmt|;
name|__xdr_ypall_cb
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|dbp
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
name|ypresp_master
modifier|*
name|ypproc_master_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|nokey
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_master
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_master_2_svc(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tdomain = \"%s\"\n"
argument_list|,
name|nokey
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tmap = \"%s\"\n"
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*     ** If this request deals with master.passwd.* and it didn't     ** originate on a privileged port (< 1024), return a YP_YPERR.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|strstr
argument_list|(
name|nokey
operator|->
name|map
argument_list|,
literal|"master.passwd"
argument_list|)
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
if|if
condition|(
name|result
operator|.
name|peer
condition|)
block|{
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|result
operator|.
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|peer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|nokey
operator|->
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
name|nokey
operator|->
name|domain
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DB
modifier|*
name|dbp
init|=
name|open_database
argument_list|(
name|nokey
operator|->
name|domain
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NOMAP
expr_stmt|;
else|else
block|{
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_MASTER_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|key
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
if|if
condition|(
call|(
name|dbp
operator|->
name|get
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* No YP_MASTER_NAME record in map? Assume we are Master */
specifier|static
name|char
name|hostbuf
index|[
literal|1025
index|]
decl_stmt|;
name|gethostname
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hostbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"Hostname: [%s]"
argument_list|,
name|hostbuf
argument_list|)
expr_stmt|;
name|result
operator|.
name|peer
operator|=
name|strdup
argument_list|(
name|hostbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|val
operator|.
name|data
operator|)
operator|+
name|val
operator|.
name|size
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|.
name|peer
operator|=
name|val
operator|.
name|data
expr_stmt|;
block|}
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|peer
operator|==
name|NULL
condition|)
name|result
operator|.
name|peer
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Peer = \"%s\"\n"
argument_list|,
name|result
operator|.
name|peer
argument_list|)
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
name|ypresp_order
modifier|*
name|ypproc_order_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|nokey
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_order
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_order_2_svc(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tdomain = \"%s\"\n"
argument_list|,
name|nokey
operator|->
name|domain
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tmap = \"%s\"\n"
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*     ** If this request deals with master.passwd.* and it didn't     ** originate on a privileged port (< 1024), return a YP_YPERR.     ** This is our half-assed way of preventing non-root users     ** on NIS clients from getting at the real password map. Bah.     */
if|if
condition|(
name|strstr
argument_list|(
name|nokey
operator|->
name|map
argument_list|,
literal|"master.passwd"
argument_list|)
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
operator|>
literal|1023
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
name|result
operator|.
name|ordernum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nokey
operator|->
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
name|nokey
operator|->
name|domain
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DB
modifier|*
name|dbp
init|=
name|open_database
argument_list|(
name|nokey
operator|->
name|domain
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NOMAP
expr_stmt|;
else|else
block|{
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_LAST_MODIFIED"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|key
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
if|if
condition|(
call|(
name|dbp
operator|->
name|get
call|)
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* No YP_LAST_MODIFIED record in map? Use DTM timestamp.. */
name|result
operator|.
name|ordernum
operator|=
name|get_dtm
argument_list|(
name|nokey
operator|->
name|domain
argument_list|,
name|nokey
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|ordernum
operator|=
name|atoi
argument_list|(
name|val
operator|.
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GNU_YPSERV_ARTIFACT
name|free
argument_list|(
name|val
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"-> Order # %d\n"
argument_list|,
name|result
operator|.
name|ordernum
argument_list|)
expr_stmt|;
return|return
operator|&
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_maplist
parameter_list|(
name|ypmaplist
modifier|*
name|mlp
parameter_list|)
block|{
name|ypmaplist
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|mlp
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|mlp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|mlp
operator|->
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlp
argument_list|)
expr_stmt|;
name|mlp
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_maplist
parameter_list|(
name|ypmaplist
modifier|*
modifier|*
name|mlhp
parameter_list|,
name|char
modifier|*
name|map
parameter_list|)
block|{
name|ypmaplist
modifier|*
name|mlp
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|map
argument_list|,
literal|"."
argument_list|,
name|strlen
argument_list|(
name|map
argument_list|)
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|map
argument_list|,
literal|".."
argument_list|,
name|strlen
argument_list|(
name|map
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|mlp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mlp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|mlp
operator|->
name|map
operator|=
name|strdup
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mlp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|mlp
operator|->
name|next
operator|=
operator|*
name|mlhp
expr_stmt|;
operator|*
name|mlhp
operator|=
name|mlp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|ypresp_maplist
modifier|*
name|ypproc_maplist_2_svc
parameter_list|(
name|domainname
modifier|*
name|name
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_maplist
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"ypproc_maplist_2_svc(): [From: %s:%d]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|rqhost
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"\t\tdomain = \"%s\"\n"
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_valid_host
argument_list|(
name|rqhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
name|Perror
argument_list|(
literal|"\t-> Ignored (not a valid source host)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|result
operator|.
name|maps
condition|)
name|free_maplist
argument_list|(
name|result
operator|.
name|maps
argument_list|)
expr_stmt|;
name|result
operator|.
name|maps
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|name
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_valid_domain
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
else|else
block|{
name|DIR
modifier|*
name|dp
decl_stmt|;
name|char
name|dirname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|dirname
argument_list|,
literal|"./%s"
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
name|dp
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug_flag
condition|)
block|{
name|Perror
argument_list|(
literal|"%s: opendir: %s"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|stat
operator|=
name|YP_BADDB
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dirent
modifier|*
name|dep
decl_stmt|;
while|while
condition|(
operator|(
name|dep
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|add_maplist
argument_list|(
operator|&
name|result
operator|.
name|maps
argument_list|,
name|dep
operator|->
name|d_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_flag
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|ypmaplist
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|result
operator|.
name|maps
expr_stmt|;
name|Perror
argument_list|(
literal|"-> "
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
condition|)
block|{
name|Perror
argument_list|(
literal|"%s,"
argument_list|,
name|p
operator|->
name|map
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
name|Perror
argument_list|(
literal|"\t-> Error #%d\n"
argument_list|,
name|result
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|result
return|;
block|}
end_function

end_unit

