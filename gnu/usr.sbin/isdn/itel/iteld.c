begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************************  *  II - Version 0.1 $Revision: 1.2 $   $State: Exp $  *  * Copyright 1994 Dietmar Friede  *******************************************************************************  * Bug reports, patches, comments, suggestions should be sent to:  *  *	jkr@saarlink.de or jkrause@guug.de  *  *******************************************************************************  * $Log: iteld.c,v $  *  ******************************************************************************/
end_comment

begin_comment
comment|/* This is a ISDN-Daemon */
end_comment

begin_comment
comment|/* It accepts ISDN-Telefon calls */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"../../../../sys/gnu/isdn/isdn_ioctl.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_define
define|#
directive|define
name|NITEL
value|1
end_define

begin_define
define|#
directive|define
name|NR_RINGS
value|10
end_define

begin_define
define|#
directive|define
name|ANSWER_NUM
value|2
end_define

begin_comment
comment|/* which number we use */
end_comment

begin_define
define|#
directive|define
name|TEL_LOG_FILE
value|"/var/log/isdn.tel"
end_define

begin_decl_stmt
name|listen_t
name|listen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isdn_param
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dofork
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|def_subadr
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|logfile
init|=
name|TEL_LOG_FILE
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|answ
block|{
name|char
name|occupied
decl_stmt|;
name|u_char
name|an
decl_stmt|,
name|cn
decl_stmt|;
name|char
name|no
index|[
literal|15
index|]
decl_stmt|;
block|}
name|answ
index|[
name|NITEL
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ind
decl_stmt|,
name|rind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rbuf
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|catchsig
parameter_list|()
block|{
name|quit
operator|++
expr_stmt|;
name|longjmp
argument_list|(
name|context
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|process
argument_list|(
argument|int n
argument_list|)
end_macro

begin_block
block|{
name|fillparam
argument_list|(
literal|0
argument_list|,
operator|&
name|ip
argument_list|,
operator|&
name|listen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|n
argument_list|,
name|ISDN_SET_PARAM
argument_list|,
operator|&
name|ip
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl: Set Param"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|n
argument_list|,
name|ISDN_LISTEN
argument_list|,
operator|&
name|listen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl: Listen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fillparam
argument_list|(
argument|int ap
argument_list|,
argument|isdn_param * ip
argument_list|,
argument|listen_t * t
argument_list|)
end_macro

begin_block
block|{
name|bzero
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
name|isdn_param
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|listen_t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|appl
operator|=
name|ip
operator|->
name|appl
operator|=
name|ap
expr_stmt|;
name|t
operator|->
name|ctrl
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|inf_mask
operator|=
literal|3
expr_stmt|;
name|t
operator|->
name|subadr_mask
operator|=
operator|(
name|u_short
operator|)
literal|0x3ff
expr_stmt|;
name|t
operator|->
name|si_mask
operator|=
operator|(
name|u_short
operator|)
literal|6
expr_stmt|;
name|ip
operator|->
name|dlpd
operator|.
name|protokoll
operator|=
literal|3
expr_stmt|;
name|ip
operator|->
name|dlpd
operator|.
name|length
operator|=
literal|7
expr_stmt|;
name|ip
operator|->
name|dlpd
operator|.
name|data_length
operator|=
literal|1024
expr_stmt|;
name|ip
operator|->
name|timeout
operator|=
literal|60
expr_stmt|;
name|ip
operator|->
name|prot
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ncpd
operator|.
name|protokoll
operator|=
literal|4
expr_stmt|;
block|}
end_block

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|a
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|dofork
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:l:F"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: itel [ -F ] [ -l logfile ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
name|logfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|dofork
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dofork
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't fork, %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* running as daemon now */
if|if
condition|(
name|freopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|open
argument_list|(
literal|"/dev/isdn2"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"open: /dev/isdn2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|process
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGKILL
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
name|quit
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:iteld started\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|l
decl_stmt|;
name|int
name|an
decl_stmt|,
name|cn
decl_stmt|,
name|serv
decl_stmt|,
name|serv_add
decl_stmt|,
name|subadr
decl_stmt|;
name|int
name|typ
decl_stmt|,
name|nl
decl_stmt|,
name|dl
decl_stmt|;
name|char
modifier|*
name|tn
decl_stmt|;
name|u_char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u_char
name|telnum
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|read
argument_list|(
name|n
argument_list|,
name|rbuf
argument_list|,
literal|1024
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|rbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|sscanf
argument_list|(
name|rbuf
operator|+
literal|2
argument_list|,
literal|"%d %d %d %d %d %d %d %n"
argument_list|,
operator|&
name|an
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|serv
argument_list|,
operator|&
name|serv_add
argument_list|,
operator|&
name|subadr
argument_list|,
operator|&
name|typ
argument_list|,
operator|&
name|nl
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|l
operator|+=
literal|2
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|cn
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|find_appl
argument_list|()
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|0xff
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator|=
literal|0x3e
expr_stmt|;
comment|/* call reject */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"iteld: No Application\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|n
argument_list|,
name|ISDN_ACCEPT
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl: Accept"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|0xff
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"r:%d:%s\n"
argument_list|,
name|an
argument_list|,
name|rbuf
operator|+
name|l
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a:%d:%s\n"
argument_list|,
name|an
argument_list|,
name|rbuf
operator|+
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" s:dialing?i\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|sscanf
argument_list|(
name|rbuf
operator|+
literal|2
argument_list|,
literal|"%d %d %d %n"
argument_list|,
operator|&
name|an
argument_list|,
operator|&
name|typ
argument_list|,
operator|&
name|nl
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"i:%d:%x:%s\n"
argument_list|,
name|an
argument_list|,
name|typ
argument_list|,
name|rbuf
operator|+
name|l
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|sscanf
argument_list|(
name|rbuf
operator|+
literal|2
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|an
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"C:%d:%d\n"
argument_list|,
name|an
argument_list|,
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|subadr
operator|==
name|def_subadr
condition|)
comment|/* jkr */
name|system
argument_list|(
literal|"/isdn/lib/answ>/dev/null 2>&1&"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|sscanf
argument_list|(
name|rbuf
operator|+
literal|2
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|an
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
name|answ
index|[
literal|0
index|]
operator|.
name|occupied
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"D:%d:%d\n"
argument_list|,
name|an
argument_list|,
name|cn
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|quit
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:Quit\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|find_appl
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|struct
name|answ
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NITEL
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
operator|&
name|answ
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|occupied
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|occupied
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

