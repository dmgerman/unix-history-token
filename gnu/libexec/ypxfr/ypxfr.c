begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*     YPS-0.2, NIS-Server for Linux     Copyright (C) 1994  Tobias Reber      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.      Modified for use with FreeBSD 2.x by Bill Paul (wpaul@ctr.columbia.edu)   $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
name|DB
modifier|*
name|db
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_YP
end_ifndef

begin_define
define|#
directive|define
name|_PATH_YP
value|"/var/yp/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PERM_SECURE
value|(S_IRUSR|S_IWUSR)
end_define

begin_decl_stmt
name|HASHINFO
name|openinfo
init|=
block|{
literal|4096
block|,
comment|/* bsize */
literal|32
block|,
comment|/* ffactor */
literal|256
block|,
comment|/* nelem */
literal|2048
operator|*
literal|1024
block|,
comment|/* cachesize */
name|NULL
block|,
comment|/* hash */
literal|0
comment|/* lorder */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<rpcsvc/yp.h>
end_include

begin_struct
struct|struct
name|dom_binding
block|{
name|struct
name|dom_binding
modifier|*
name|dom_pnext
decl_stmt|;
name|char
name|dom_domain
index|[
name|YPMAXDOMAIN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|dom_server_addr
decl_stmt|;
name|u_short
name|dom_server_port
decl_stmt|;
name|int
name|dom_socket
decl_stmt|;
name|CLIENT
modifier|*
name|dom_client
decl_stmt|;
name|u_short
name|dom_local_port
decl_stmt|;
name|long
name|dom_vers
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DATUM
end_define

begin_comment
comment|/* Otherwise ypclnt.h redefines datum */
end_comment

begin_include
include|#
directive|include
file|<rpcsvc/ypclnt.h>
end_include

begin_comment
comment|/*  * These are hooks to the ypclnt library in ../lib  */
end_comment

begin_function_decl
specifier|extern
name|int
name|_yp_bind
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_yp_clear
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
name|Perror
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SourceHost
init|=
name|NULL
decl_stmt|,
modifier|*
name|TargetDomain
init|=
name|NULL
decl_stmt|,
modifier|*
name|SourceDomain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|IpAddress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Force
init|=
literal|0
decl_stmt|,
name|NoClear
init|=
literal|0
decl_stmt|,
name|TaskId
init|=
literal|0
decl_stmt|,
name|ProgramNumber
init|=
literal|0
decl_stmt|,
name|PortNumber
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|ypxfr_err_string
parameter_list|(
name|enum
name|ypxfrstat
name|y
parameter_list|)
block|{
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|YPXFR_SUCC
case|:
return|return
literal|"Success"
return|;
case|case
name|YPXFR_AGE
case|:
return|return
literal|"Master's version not newer"
return|;
case|case
name|YPXFR_NOMAP
case|:
return|return
literal|"Can't find server for map"
return|;
case|case
name|YPXFR_NODOM
case|:
return|return
literal|"Domain not supported"
return|;
case|case
name|YPXFR_RSRC
case|:
return|return
literal|"Local resource alloc failure"
return|;
case|case
name|YPXFR_RPC
case|:
return|return
literal|"RPC failure talking to server"
return|;
case|case
name|YPXFR_MADDR
case|:
return|return
literal|"Can't get master address"
return|;
case|case
name|YPXFR_YPERR
case|:
return|return
literal|"YP server/map db error"
return|;
case|case
name|YPXFR_BADARGS
case|:
return|return
literal|"Request arguments bad"
return|;
case|case
name|YPXFR_DBM
case|:
return|return
literal|"Local dbm operation failed"
return|;
case|case
name|YPXFR_FILE
case|:
return|return
literal|"Local file I/O operation failed"
return|;
case|case
name|YPXFR_SKEW
case|:
return|return
literal|"Map version skew during transfer"
return|;
case|case
name|YPXFR_CLEAR
case|:
return|return
literal|"Can't send \"Clear\" req to local ypserv"
return|;
case|case
name|YPXFR_FORCE
case|:
return|return
literal|"No local order number in map  use -f flag."
return|;
case|case
name|YPXFR_XFRERR
case|:
return|return
literal|"ypxfr error"
return|;
case|case
name|YPXFR_REFUSED
case|:
return|return
literal|"Transfer request refused by ypserv"
return|;
block|}
block|}
end_function

begin_macro
name|ypxfr_foreach
argument_list|(
argument|int status
argument_list|,
argument|char *key
argument_list|,
argument|int keylen
argument_list|,
argument|char *val
argument_list|,
argument|int vallen
argument_list|,
argument|int *data
argument_list|)
end_macro

begin_block
block|{
name|DBT
name|outKey
decl_stmt|,
name|outData
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|YP_NOMORE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|status
operator|!=
name|YP_TRUE
condition|)
block|{
name|int
name|s
init|=
name|ypprot_err
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|Perror
argument_list|(
literal|"%s\n"
argument_list|,
name|yperr_string
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|outKey
operator|.
name|data
operator|=
name|key
expr_stmt|;
name|outKey
operator|.
name|size
operator|=
operator|(
name|size_t
operator|)
name|keylen
expr_stmt|;
name|outData
operator|.
name|data
operator|=
name|val
expr_stmt|;
name|outData
operator|.
name|size
operator|=
operator|(
name|size_t
operator|)
name|vallen
expr_stmt|;
call|(
name|db
operator|->
name|put
call|)
argument_list|(
name|db
argument_list|,
operator|&
name|outKey
argument_list|,
operator|&
name|outData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|enum
name|ypxfrstat
name|ypxfr
parameter_list|(
name|char
modifier|*
name|mapName
parameter_list|)
block|{
name|int
name|localOrderNum
init|=
literal|0
decl_stmt|;
name|int
name|masterOrderNum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|masterName
decl_stmt|;
name|struct
name|sockaddr_in
name|localHost
decl_stmt|;
name|struct
name|sockaddr_in
name|masterHost
decl_stmt|;
name|struct
name|ypall_callback
name|callback
decl_stmt|;
name|char
name|dbName
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|dbName2
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|y
decl_stmt|,
name|masterSock
decl_stmt|;
name|CLIENT
modifier|*
name|masterClient
decl_stmt|;
name|memset
argument_list|(
operator|&
name|localHost
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|localHost
argument_list|)
expr_stmt|;
name|localHost
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|localHost
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SourceHost
condition|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|yp_master
argument_list|(
name|SourceDomain
argument_list|,
name|mapName
argument_list|,
operator|&
name|masterName
argument_list|)
operator|)
condition|)
return|return
name|YPXFR_MADDR
return|;
name|SourceHost
operator|=
name|masterName
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|masterHost
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|masterHost
argument_list|)
expr_stmt|;
name|masterHost
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|h
init|=
name|gethostbyname
argument_list|(
name|SourceHost
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
return|return
name|YPXFR_MADDR
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|masterHost
operator|.
name|sin_addr
argument_list|,
name|h
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
name|masterHost
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|_yp_bind
argument_list|(
operator|&
name|masterHost
argument_list|,
name|SourceDomain
argument_list|)
operator|)
condition|)
return|return
name|YPXFR_RPC
return|;
name|masterSock
operator|=
name|RPC_ANYSOCK
expr_stmt|;
name|masterClient
operator|=
name|clnttcp_create
argument_list|(
operator|&
name|masterHost
argument_list|,
name|YPPROG
argument_list|,
name|YPVERS
argument_list|,
operator|&
name|masterSock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterClient
operator|==
name|NULL
condition|)
block|{
name|clnt_pcreateerror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|YPXFR_RPC
return|;
block|}
block|{
specifier|static
name|struct
name|timeval
name|tv
init|=
block|{
literal|25
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|ypreq_nokey
name|req
decl_stmt|;
name|struct
name|ypresp_order
name|resp
decl_stmt|;
name|int
name|y
decl_stmt|;
name|req
operator|.
name|domain
operator|=
name|SourceDomain
expr_stmt|;
name|req
operator|.
name|map
operator|=
name|mapName
expr_stmt|;
name|y
operator|=
name|clnt_call
argument_list|(
name|masterClient
argument_list|,
name|YPPROC_ORDER
argument_list|,
name|xdr_ypreq_nokey
argument_list|,
operator|&
name|req
argument_list|,
name|xdr_ypresp_order
argument_list|,
operator|&
name|resp
argument_list|,
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|clnt_perror
argument_list|(
name|masterClient
argument_list|,
literal|"masterOrderNum"
argument_list|)
expr_stmt|;
name|masterOrderNum
operator|=
literal|0x7fffffff
expr_stmt|;
block|}
else|else
block|{
name|masterOrderNum
operator|=
name|resp
operator|.
name|ordernum
expr_stmt|;
block|}
name|xdr_free
argument_list|(
name|xdr_ypresp_order
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Force
condition|)
block|{
name|DBT
name|inKey
decl_stmt|,
name|inVal
decl_stmt|;
name|sprintf
argument_list|(
name|dbName
argument_list|,
literal|"%s%s/%s"
argument_list|,
name|_PATH_YP
argument_list|,
name|TargetDomain
argument_list|,
name|mapName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dbopen
argument_list|(
name|dbName
argument_list|,
name|O_RDWR
operator||
name|O_EXCL
argument_list|,
name|PERM_SECURE
argument_list|,
name|DB_HASH
argument_list|,
operator|&
name|openinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Perror
argument_list|(
literal|"dbopen: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Perror
argument_list|(
literal|"%s: cannot open - ignored.\n"
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
name|localOrderNum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|inKey
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
name|inKey
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|inKey
operator|.
name|data
argument_list|)
expr_stmt|;
call|(
name|db
operator|->
name|get
call|)
argument_list|(
name|db
argument_list|,
operator|&
name|inKey
argument_list|,
operator|&
name|inVal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inVal
operator|.
name|data
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|inVal
operator|.
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inVal
operator|.
name|size
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
name|db
operator|->
name|close
argument_list|)
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|YPXFR_SKEW
return|;
block|}
block|}
name|localOrderNum
operator|=
name|atoi
argument_list|(
name|inVal
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
call|(
name|void
call|)
argument_list|(
name|db
operator|->
name|close
argument_list|)
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localOrderNum
operator|>=
name|masterOrderNum
condition|)
return|return
name|YPXFR_AGE
return|;
block|}
name|sprintf
argument_list|(
name|dbName
argument_list|,
literal|"%s%s/%s~"
argument_list|,
name|_PATH_YP
argument_list|,
name|TargetDomain
argument_list|,
name|mapName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dbopen
argument_list|(
name|dbName
argument_list|,
name|O_RDWR
operator||
name|O_EXCL
operator||
name|O_CREAT
argument_list|,
name|PERM_SECURE
argument_list|,
name|DB_HASH
argument_list|,
operator|&
name|openinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Perror
argument_list|(
literal|"%s: Cannot open\n"
argument_list|,
name|dbName
argument_list|)
expr_stmt|;
return|return
name|YPXFR_DBM
return|;
block|}
block|{
name|DBT
name|outKey
decl_stmt|,
name|outData
decl_stmt|;
name|char
name|orderNum
index|[
literal|12
index|]
decl_stmt|;
name|outKey
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
name|outKey
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|outKey
operator|.
name|data
argument_list|)
expr_stmt|;
name|outData
operator|.
name|data
operator|=
name|SourceHost
expr_stmt|;
name|outData
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|outData
operator|.
name|data
argument_list|)
expr_stmt|;
call|(
name|db
operator|->
name|put
call|)
argument_list|(
name|db
argument_list|,
operator|&
name|outKey
argument_list|,
operator|&
name|outData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|orderNum
argument_list|,
literal|"%d"
argument_list|,
name|masterOrderNum
argument_list|)
expr_stmt|;
name|outKey
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
name|outKey
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|outKey
operator|.
name|data
argument_list|)
expr_stmt|;
name|outData
operator|.
name|data
operator|=
name|orderNum
expr_stmt|;
name|outData
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|outData
operator|.
name|data
argument_list|)
expr_stmt|;
call|(
name|db
operator|->
name|put
call|)
argument_list|(
name|db
argument_list|,
operator|&
name|outKey
argument_list|,
operator|&
name|outData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|callback
operator|.
name|foreach
operator|=
name|ypxfr_foreach
expr_stmt|;
name|callback
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We have to use our own private version of yp_all() here since 	 * the yp_all() in libc doesn't allow us to specify the server that 	 * we want to talk to: it's imperative that we transfer data from 	 * the NIS master server and no one else. 	 */
name|y
operator|=
name|__yp_all
argument_list|(
name|SourceDomain
argument_list|,
name|mapName
argument_list|,
operator|&
name|callback
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|db
operator|->
name|close
argument_list|)
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dbName
argument_list|,
literal|"%s%s/%s~"
argument_list|,
name|_PATH_YP
argument_list|,
name|TargetDomain
argument_list|,
name|mapName
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dbName2
argument_list|,
literal|"%s%s/%s"
argument_list|,
name|_PATH_YP
argument_list|,
name|TargetDomain
argument_list|,
name|mapName
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dbName2
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|dbName
argument_list|,
name|dbName2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NoClear
condition|)
block|{
name|memset
argument_list|(
operator|&
name|localHost
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|localHost
argument_list|)
expr_stmt|;
name|localHost
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|localHost
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|_yp_bind
argument_list|(
operator|&
name|localHost
argument_list|,
name|TargetDomain
argument_list|)
operator|||
name|_yp_clear
argument_list|(
name|TargetDomain
argument_list|)
condition|)
return|return
name|YPXFR_CLEAR
return|;
block|}
return|return
name|y
operator|==
literal|0
condition|?
name|YPXFR_SUCC
else|:
name|YPXFR_YPERR
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|progname
parameter_list|)
name|char
modifier|*
name|progname
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-f] [-c] [-d target domain] \ [-h source host]\n	[-s source domain] \ [-C taskid program-number ipaddr port] mapname\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|openlog
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|logflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fcd:h:s:C:S"
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|Force
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|NoClear
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|TargetDomain
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|SourceHost
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|SourceDomain
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|TaskId
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|ProgramNumber
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|IpAddress
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|PortNumber
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|TargetDomain
condition|)
block|{
name|yp_get_default_domain
argument_list|(
operator|&
name|TargetDomain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SourceDomain
condition|)
block|{
name|SourceDomain
operator|=
name|TargetDomain
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
name|enum
name|ypxfrstat
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|ypxfr
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|!=
name|YPXFR_SUCC
condition|)
block|{
name|Perror
argument_list|(
literal|"%s\n"
argument_list|,
name|ypxfr_err_string
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TaskId
condition|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|struct
name|timeval
name|wait
decl_stmt|;
name|CLIENT
modifier|*
name|clnt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ypresp_xfr
name|resp
decl_stmt|;
specifier|static
name|struct
name|timeval
name|tv
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|=
name|IpAddress
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|PortNumber
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
literal|25
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|RPC_ANYSOCK
expr_stmt|;
name|clnt
operator|=
name|clntudp_create
argument_list|(
operator|&
name|addr
argument_list|,
name|ProgramNumber
argument_list|,
literal|1
argument_list|,
name|wait
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clnt
condition|)
block|{
name|clnt_pcreateerror
argument_list|(
literal|"ypxfr_callback"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|resp
operator|.
name|transid
operator|=
name|TaskId
expr_stmt|;
name|resp
operator|.
name|xfrstat
operator|=
name|y
expr_stmt|;
switch|switch
condition|(
name|clnt_call
argument_list|(
name|clnt
argument_list|,
literal|1
argument_list|,
name|xdr_ypresp_xfr
argument_list|,
operator|&
name|resp
argument_list|,
name|xdr_void
argument_list|,
name|NULL
argument_list|,
name|tv
argument_list|)
condition|)
block|{
case|case
name|RPC_SUCCESS
case|:
case|case
name|RPC_TIMEDOUT
case|:
break|break;
default|default:
name|clnt_perror
argument_list|(
name|clnt
argument_list|,
literal|"ypxfr_callback"
argument_list|)
expr_stmt|;
block|}
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

