begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tstuu.c    Test the uucp package on a UNIX system.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|tstuu_rcsid
index|[]
init|=
literal|"$Id: tstuu.c,v 1.4 1995/08/19 21:23:11 ache Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TIMES_H
end_if

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_IOCTL_H
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SELECT
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POLL
end_if

begin_if
if|#
directive|if
name|HAVE_STROPTS_H
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POLL_H
end_if

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_if
if|#
directive|if
operator|!
name|HAVE_SYS_TIME_H
operator|||
operator|!
name|HAVE_SELECT
operator|||
name|TIME_WITH_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_WAIT_H
end_if

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_UNION_WAIT
end_if

begin_typedef
typedef|typedef
name|union
name|wait
name|wait_status
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|wait_status
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STREAMS_PTYS
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|ptsname
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for both O_NONBLOCK and O_NDELAY.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NDELAY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNDELAY
end_ifdef

begin_define
define|#
directive|define
name|O_NDELAY
value|FNDELAY
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_define
define|#
directive|define
name|O_NDELAY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NDELAY) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNBLOCK
end_ifdef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|FNBLOCK
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_define
define|#
directive|define
name|O_NONBLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NONBLOCK) */
end_comment

begin_if
if|#
directive|if
name|O_NDELAY
operator|==
literal|0
operator|&&
name|O_NONBLOCK
operator|==
literal|0
end_if

begin_error
error|#
directive|error
error|No way to do nonblocking I/O
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for EAGAIN, EWOULDBLOCK and ENODATA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EAGAIN
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EAGAIN
value|(-1)
end_define

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_define
define|#
directive|define
name|EAGAIN
value|EWOULDBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (EWOULDBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENODATA
end_ifndef

begin_define
define|#
directive|define
name|ENODATA
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make sure we have a CLK_TCK definition, even if it makes no sense.    This is in case TIMES_TICK is defined as CLK_TCK.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CLK_TCK
end_ifndef

begin_define
define|#
directive|define
name|CLK_TCK
value|(60)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't try too hard to get a TIMES_TICK value; it doesn't matter    that much.  */
end_comment

begin_if
if|#
directive|if
name|TIMES_TICK
operator|==
literal|0
end_if

begin_undef
undef|#
directive|undef
name|TIMES_TICK
end_undef

begin_define
define|#
directive|define
name|TIMES_TICK
value|CLK_TCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TIMES_DECLARATION_OK
end_if

begin_function_decl
specifier|extern
name|long
name|times
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|ZUUCICO_CMD
value|"login uucp"
end_define

begin_define
define|#
directive|define
name|UUCICO_EXECL
value|"/bin/login", "login", "uucp"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZUUCICO_CMD
value|"su - nuucp"
end_define

begin_define
define|#
directive|define
name|UUCICO_EXECL
value|"/bin/su", "su", "-", "nuucp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_SELECT
operator|&&
operator|!
name|HAVE_POLL
end_if

begin_error
error|#
directive|error
error|You need select or poll
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_REMOVE
end_if

begin_undef
undef|#
directive|undef
name|remove
end_undef

begin_define
define|#
directive|define
name|remove
value|unlink
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Buffer chain to hold data read from a uucico.  */
end_comment

begin_define
define|#
directive|define
name|BUFCHARS
value|(512)
end_define

begin_struct
struct|struct
name|sbuf
block|{
name|struct
name|sbuf
modifier|*
name|qnext
decl_stmt|;
name|int
name|cstart
decl_stmt|;
name|int
name|cend
decl_stmt|;
name|char
name|ab
index|[
name|BUFCHARS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|umake_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|,
name|int
name|cextra
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uprepare_test
name|P
argument_list|(
operator|(
name|boolean
name|fmake
operator|,
name|int
name|itest
operator|,
name|boolean
name|fcall_uucico
operator|,
specifier|const
name|char
operator|*
name|zsys
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucheck_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|,
name|int
name|cextra
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucheck_test
name|P
argument_list|(
operator|(
name|int
name|itest
operator|,
name|boolean
name|fcall_uucico
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|uchild
name|P
argument_list|(
operator|(
name|int
name|isig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpshow
name|P
argument_list|(
operator|(
name|char
operator|*
name|z
operator|,
name|int
name|bchar
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uchoose
name|P
argument_list|(
operator|(
name|int
operator|*
name|po1
operator|,
name|int
operator|*
name|po2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cread
name|P
argument_list|(
operator|(
name|int
name|o
operator|,
expr|struct
name|sbuf
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend
name|P
argument_list|(
operator|(
name|int
name|o
operator|,
name|int
name|oslave
operator|,
expr|struct
name|sbuf
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fwritable
name|P
argument_list|(
operator|(
name|int
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xsystem
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zcmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|xfopen
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zname
operator|,
specifier|const
name|char
operator|*
name|zmode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zDebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iTest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fCall_uucico
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iPercent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|iPid1
decl_stmt|,
name|iPid2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cFrom1
decl_stmt|,
name|cFrom2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|char
name|abLogout1
index|[
sizeof|sizeof
expr|"tstout /dev/ptyp0"]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|char
name|abLogout2
index|[
sizeof|sizeof
expr|"tstout /dev/ptyp0"]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zProtocols
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iopt
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcmd1
decl_stmt|,
modifier|*
name|zcmd2
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|boolean
name|fmake
init|=
name|TRUE
decl_stmt|;
name|int
name|omaster1
decl_stmt|,
name|oslave1
decl_stmt|,
name|omaster2
decl_stmt|,
name|oslave2
decl_stmt|;
name|char
name|abpty1
index|[
sizeof|sizeof
expr|"/dev/ptyp0"]
expr_stmt|;
name|char
name|abpty2
index|[
sizeof|sizeof
expr|"/dev/ptyp0"]
expr_stmt|;
name|struct
name|sbuf
modifier|*
name|qbuf1
decl_stmt|,
modifier|*
name|qbuf2
decl_stmt|;
if|#
directive|if
operator|!
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: only works when compiled with HAVE_TAYLOR_CONFIG\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zcmd1
operator|=
name|NULL
expr_stmt|;
name|zcmd2
operator|=
name|NULL
expr_stmt|;
name|zsys
operator|=
literal|"test2"
expr_stmt|;
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:np:s:t:ux:1:2:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'c'
case|:
name|zProtocols
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|fmake
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|iPercent
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|srand
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|zsys
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|iTest
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fCall_uucico
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|zDebug
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|zcmd1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|zcmd2
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: tstuu [-xn] [-t #] [-u] [-1 cmd] [-2 cmd]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fCall_uucico
operator|&&
name|zcmd2
operator|==
name|NULL
condition|)
name|zcmd2
operator|=
name|ZUUCICO_CMD
expr_stmt|;
name|uprepare_test
argument_list|(
name|fmake
argument_list|,
name|iTest
argument_list|,
name|fCall_uucico
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/spool1/core"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/spool2/core"
argument_list|)
expr_stmt|;
name|omaster1
operator|=
operator|-
literal|1
expr_stmt|;
name|oslave1
operator|=
operator|-
literal|1
expr_stmt|;
name|omaster2
operator|=
operator|-
literal|1
expr_stmt|;
name|oslave2
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_STREAMS_PTYS
block|{
name|char
modifier|*
name|zptyname
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpty
decl_stmt|;
name|zptyname
operator|=
name|abpty1
expr_stmt|;
for|for
control|(
name|zpty
operator|=
literal|"pqrs"
init|;
operator|*
name|zpty
operator|!=
literal|'\0'
condition|;
operator|++
name|zpty
control|)
block|{
name|int
name|ipty
decl_stmt|;
for|for
control|(
name|ipty
operator|=
literal|0
init|;
name|ipty
operator|<
literal|16
condition|;
name|ipty
operator|++
control|)
block|{
name|int
name|om
decl_stmt|,
name|os
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|sprintf
argument_list|(
name|zptyname
argument_list|,
literal|"/dev/pty%c%c"
argument_list|,
operator|*
name|zpty
argument_list|,
literal|"0123456789abcdef"
index|[
name|ipty
index|]
argument_list|)
expr_stmt|;
name|om
operator|=
name|open
argument_list|(
name|zptyname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|om
operator|<
literal|0
condition|)
continue|continue;
name|zptyname
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
name|os
operator|=
name|open
argument_list|(
name|zptyname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|om
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|omaster1
operator|==
operator|-
literal|1
condition|)
block|{
name|omaster1
operator|=
name|om
expr_stmt|;
name|oslave1
operator|=
name|os
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"/usr/tmp/tstuu/pty1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|zptyname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|zptyname
operator|=
name|abpty2
expr_stmt|;
block|}
else|else
block|{
name|omaster2
operator|=
name|om
expr_stmt|;
name|oslave2
operator|=
name|os
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"/usr/tmp/tstuu/pty2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|zptyname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|omaster1
operator|!=
operator|-
literal|1
operator|&&
name|omaster2
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
block|}
else|#
directive|else
comment|/* HAVE_STREAMS_PTYS */
block|{
name|int
name|ipty
decl_stmt|;
for|for
control|(
name|ipty
operator|=
literal|0
init|;
name|ipty
operator|<
literal|2
condition|;
name|ipty
operator|++
control|)
block|{
name|int
name|om
decl_stmt|,
name|os
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|znam
decl_stmt|;
name|struct
name|termio
name|stio
decl_stmt|;
name|om
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/dev/ptmx"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|om
operator|<
literal|0
condition|)
break|break;
name|znam
operator|=
name|ptsname
argument_list|(
name|om
argument_list|)
expr_stmt|;
if|if
condition|(
name|znam
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|unlockpt
argument_list|(
name|om
argument_list|)
operator|!=
literal|0
operator|||
name|grantpt
argument_list|(
name|om
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|os
operator|=
name|open
argument_list|(
name|znam
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|om
argument_list|)
expr_stmt|;
name|om
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|os
argument_list|,
name|I_PUSH
argument_list|,
literal|"ptem"
argument_list|)
operator|<
literal|0
operator|||
name|ioctl
argument_list|(
name|os
argument_list|,
name|I_PUSH
argument_list|,
literal|"ldterm"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Can this really be right? */
name|memset
argument_list|(
operator|&
name|stio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stio
argument_list|)
argument_list|)
expr_stmt|;
name|stio
operator|.
name|c_cflag
operator|=
name|B9600
operator||
name|CS8
operator||
name|CREAD
operator||
name|HUPCL
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|os
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|stio
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"TCSETA"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|omaster1
operator|==
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|abpty1
argument_list|,
name|znam
argument_list|)
expr_stmt|;
name|omaster1
operator|=
name|om
expr_stmt|;
name|oslave1
operator|=
name|os
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"/usr/tmp/tstuu/pty1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|znam
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
name|abpty2
argument_list|,
name|znam
argument_list|)
expr_stmt|;
name|omaster2
operator|=
name|om
expr_stmt|;
name|oslave2
operator|=
name|os
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"/usr/tmp/tstuu/pty2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|znam
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_STREAMS_PTYS */
if|if
condition|(
name|omaster2
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No pseudo-terminals available\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we can or these into an int for the select call.  Most      systems could use 31 instead of 15, but it should never be a      problem.  */
if|if
condition|(
name|omaster1
operator|>
literal|15
operator|||
name|omaster2
operator|>
literal|15
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File descriptors are too large\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare to log out the command if it is a login command.  On      Ultrix 4.0 uucico can only be run from login for some reason.  */
if|if
condition|(
name|zcmd1
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|zcmd1
argument_list|,
literal|"login"
argument_list|,
sizeof|sizeof
expr|"login"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|abLogout1
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|abLogout1
argument_list|,
literal|"tstout %s"
argument_list|,
name|abpty1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd2
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|zcmd2
argument_list|,
literal|"login"
argument_list|,
sizeof|sizeof
expr|"login"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|abLogout2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|abLogout2
argument_list|,
literal|"tstout %s"
argument_list|,
name|abpty2
argument_list|)
expr_stmt|;
name|iPid1
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|iPid1
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPid1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster2
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|oslave2
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|oslave1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup2
argument_list|(
name|oslave1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|oslave1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
comment|/* This is said to improve the tests on Linux.  */
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"About to exec first process\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd1
operator|!=
name|NULL
condition|)
name|exit
argument_list|(
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zcmd1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"uucico"
argument_list|,
literal|"uucico"
argument_list|,
literal|"-I"
argument_list|,
literal|"/usr/tmp/tstuu/Config1"
argument_list|,
literal|"-q"
argument_list|,
literal|"-S"
argument_list|,
name|zsys
argument_list|,
literal|"-pstdin"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"execl failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|iPid2
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|iPid2
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|iPid1
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPid2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|oslave1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster2
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|oslave2
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup2
argument_list|(
name|oslave2
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|oslave2
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
comment|/* This is said to improve the tests on Linux.  */
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"About to exec second process\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fCall_uucico
condition|)
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
name|UUCICO_EXECL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"execl failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zcmd2
operator|!=
name|NULL
condition|)
name|exit
argument_list|(
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zcmd2
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"uucico"
argument_list|,
literal|"uucico"
argument_list|,
literal|"-I"
argument_list|,
literal|"/usr/tmp/tstuu/Config2"
argument_list|,
literal|"-lq"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"execl failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|uchild
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|omaster1
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|omaster1
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|omaster2
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|omaster2
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|qbuf1
operator|=
name|NULL
expr_stmt|;
name|qbuf2
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|o1
decl_stmt|,
name|o2
decl_stmt|;
name|boolean
name|fcont
decl_stmt|;
name|o1
operator|=
name|omaster1
expr_stmt|;
name|o2
operator|=
name|omaster2
expr_stmt|;
name|uchoose
argument_list|(
operator|&
name|o1
argument_list|,
operator|&
name|o2
argument_list|)
expr_stmt|;
if|if
condition|(
name|o1
operator|==
operator|-
literal|1
operator|&&
name|o2
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Five second pause\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|o1
operator|!=
operator|-
literal|1
condition|)
name|cFrom1
operator|+=
name|cread
argument_list|(
name|omaster1
argument_list|,
operator|&
name|qbuf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|o2
operator|!=
operator|-
literal|1
condition|)
name|cFrom2
operator|+=
name|cread
argument_list|(
name|omaster2
argument_list|,
operator|&
name|qbuf2
argument_list|)
expr_stmt|;
do|do
block|{
name|fcont
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|qbuf1
operator|!=
name|NULL
operator|&&
name|fwritable
argument_list|(
name|omaster2
argument_list|)
operator|&&
name|fsend
argument_list|(
name|omaster2
argument_list|,
name|oslave2
argument_list|,
operator|&
name|qbuf1
argument_list|)
condition|)
name|fcont
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qbuf2
operator|!=
name|NULL
operator|&&
name|fwritable
argument_list|(
name|omaster1
argument_list|)
operator|&&
name|fsend
argument_list|(
name|omaster1
argument_list|,
name|oslave1
argument_list|,
operator|&
name|qbuf2
argument_list|)
condition|)
name|fcont
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fcont
operator|&&
operator|(
name|qbuf1
operator|!=
name|NULL
operator|||
name|qbuf2
operator|!=
name|NULL
operator|)
condition|)
block|{
name|long
name|cgot1
decl_stmt|,
name|cgot2
decl_stmt|;
name|cgot1
operator|=
name|cread
argument_list|(
name|omaster1
argument_list|,
operator|&
name|qbuf1
argument_list|)
expr_stmt|;
name|cFrom1
operator|+=
name|cgot1
expr_stmt|;
name|cgot2
operator|=
name|cread
argument_list|(
name|omaster2
argument_list|,
operator|&
name|qbuf2
argument_list|)
expr_stmt|;
name|cFrom2
operator|+=
name|cgot2
expr_stmt|;
name|fcont
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|fcont
condition|)
do|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* When a child dies, kill them both.  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|uchild
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
name|struct
name|tms
name|sbase
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Give the processes a chance to die on their own.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|iPid1
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|iPid2
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|sbase
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_WAITPID
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|iPid1
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAITPID */
if|#
directive|if
name|HAVE_WAIT4
operator|(
name|void
operator|)
name|wait4
argument_list|(
name|iPid1
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAIT4 */
operator|(
name|void
operator|)
name|wait
argument_list|(
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_WAIT4 */
endif|#
directive|endif
comment|/* ! HAVE_WAITPID */
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|s1
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_WAITPID
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|iPid2
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAITPID */
if|#
directive|if
name|HAVE_WAIT4
operator|(
name|void
operator|)
name|wait4
argument_list|(
name|iPid2
argument_list|,
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAIT4 */
operator|(
name|void
operator|)
name|wait
argument_list|(
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_WAIT4 */
endif|#
directive|endif
comment|/* ! HAVE_WAITPID */
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" First child: user: %g; system: %g\n"
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s1
operator|.
name|tms_cutime
operator|-
name|sbase
operator|.
name|tms_cutime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s1
operator|.
name|tms_cstime
operator|-
name|sbase
operator|.
name|tms_cstime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second child: user: %g; system: %g\n"
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s2
operator|.
name|tms_cutime
operator|-
name|s1
operator|.
name|tms_cutime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s2
operator|.
name|tms_cstime
operator|-
name|s1
operator|.
name|tms_cstime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|)
expr_stmt|;
name|ucheck_test
argument_list|(
name|iTest
argument_list|,
name|fCall_uucico
argument_list|)
expr_stmt|;
if|if
condition|(
name|abLogout1
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Executing %s\n"
argument_list|,
name|abLogout1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|abLogout1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abLogout2
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Executing %s\n"
argument_list|,
name|abLogout2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|abLogout2
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrote %d bytes from 1 to 2\n"
argument_list|,
name|cFrom1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrote %d bytes from 2 to 1\n"
argument_list|,
name|cFrom2
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp/tstuu/spool1/core"
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"core file 1 exists\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp/tstuu/spool2/core"
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"core file 2 exists\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file without error.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|xfopen
parameter_list|(
name|zname
parameter_list|,
name|zmode
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmode
decl_stmt|;
block|{
name|FILE
modifier|*
name|eret
decl_stmt|;
name|eret
operator|=
name|fopen
argument_list|(
name|zname
argument_list|,
name|zmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|eret
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|zname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|eret
return|;
block|}
end_function

begin_comment
comment|/* Close a file without error.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|xfclose
name|P
argument_list|(
operator|(
name|FILE
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xfclose
parameter_list|(
name|e
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a test file.  */
end_comment

begin_function
specifier|static
name|void
name|umake_file
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
name|z
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i2
decl_stmt|;
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
literal|256
condition|;
name|i2
operator|++
control|)
name|putc
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a test file.  */
end_comment

begin_function
specifier|static
name|void
name|ucheck_file
parameter_list|(
name|z
parameter_list|,
name|zerr
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
name|z
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i2
decl_stmt|;
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
literal|256
condition|;
name|i2
operator|++
control|)
block|{
name|int
name|bread
decl_stmt|;
name|bread
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unexpected EOF at position %d,%d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bread
operator|!=
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: At position %d,%d got %d expected %d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|,
name|i2
argument_list|,
name|bread
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bread
decl_stmt|;
name|bread
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unexpected EOF at extra %d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bread
operator|!=
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: At extra %d got %d expected %d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|,
name|bread
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getc
argument_list|(
name|e
argument_list|)
operator|!=
name|EOF
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: File is too long"
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare all the configuration files for testing.  */
end_comment

begin_function
specifier|static
name|void
name|uprepare_test
parameter_list|(
name|fmake
parameter_list|,
name|itest
parameter_list|,
name|fcall_uucico
parameter_list|,
name|zsys
parameter_list|)
name|boolean
name|fmake
decl_stmt|;
name|int
name|itest
decl_stmt|;
name|boolean
name|fcall_uucico
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuucp1
decl_stmt|,
modifier|*
name|zuucp2
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuux1
decl_stmt|,
modifier|*
name|zuux2
decl_stmt|;
name|char
name|ab
index|[
literal|1000
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
comment|/* We must make /usr/tmp/tstuu world writeable or we won't be able to    receive files into it.  */
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_IWOTH
define|#
directive|define
name|S_IWOTH
value|02
endif|#
directive|endif
if|if
condition|(
name|mkdir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/usr/tmp/tstuu"
argument_list|,
name|IPUBLIC_DIRECTORY_MODE
operator||
name|S_IWOTH
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|perror
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/usr/tmp/tstuu/spool1"
argument_list|,
name|IPUBLIC_DIRECTORY_MODE
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|perror
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/usr/tmp/tstuu/spool2"
argument_list|,
name|IPUBLIC_DIRECTORY_MODE
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|perror
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmake
condition|)
block|{
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Config1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# First test configuration file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"nodename test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"spool /usr/tmp/tstuu/spool1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"lockdir /usr/tmp/tstuu/spool1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"sysfile /usr/tmp/tstuu/System1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"sysfile /usr/tmp/tstuu/System1.2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"portfile /usr/tmp/tstuu/Port1\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/Log1"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_HDB_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log1\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s\n"
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log1/%s/%s"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"statfile /usr/tmp/tstuu/Stats1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debugfile /usr/tmp/tstuu/Debug1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"callfile /usr/tmp/tstuu/Call1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"pubdir /usr/tmp/tstuu\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_V2_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"v2-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_HDB_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"hdb-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debug %s\n"
argument_list|,
name|zDebug
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/System1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# This file is ignored, to test multiple system files\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"time never\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/System1.2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# First test system file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"time any\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"port stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# That was the defaults\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"system %s\n"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcall_uucico
condition|)
block|{
name|FILE
modifier|*
name|eprog
decl_stmt|;
name|eprog
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Chat1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* Wait for the other side to open the port and flush input.  */
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"sleep 2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"echo password $1 speed $2 1>&2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"echo test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"exit 0\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|eprog
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
literal|"/usr/tmp/tstuu/Chat1"
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IXOTH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"chmod (/usr/tmp/tstuu/Chat1)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat-program /usr/tmp/tstuu/Chat1 \\P \\S\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat word: \\P\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat-fail login;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"call-login *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"call-password *\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat \"\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"call-transfer yes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"commands cat\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcall_uucico
operator|&&
name|iPercent
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol-parameter g window 7\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol-parameter g packet-size 4096\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol-parameter j avoid \\377\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zProtocols
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol %s\n"
argument_list|,
name|zProtocols
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Port1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"port stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"type stdin\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Call1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"Call out password file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s test1 pass\\s1\n"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcall_uucico
condition|)
block|{
name|FILE
modifier|*
name|eprog
decl_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Config2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# Second test configuration file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"nodename test2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"spool /usr/tmp/tstuu/spool2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"lockdir /usr/tmp/tstuu/spool2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"sysfile /usr/tmp/tstuu/System2\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/Log2"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_HDB_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log2\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s\n"
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log2/%s/%s"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"statfile /usr/tmp/tstuu/Stats2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debugfile /usr/tmp/tstuu/Debug2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"passwdfile /usr/tmp/tstuu/Pass2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"pubdir /usr/tmp/tstuu\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_V2_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"v2-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_HDB_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"hdb-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debug %s\n"
argument_list|,
name|zDebug
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/System2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# Second test system file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"system test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"called-login test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"request true\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"commands cat\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zProtocols
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol %s\n"
argument_list|,
name|zProtocols
argument_list|)
expr_stmt|;
name|eprog
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Chat2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"echo port $1 1>&2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"exit 0\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|eprog
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
literal|"/usr/tmp/tstuu/Chat2"
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IXOTH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"chmod (/usr/tmp/tstuu/Chat2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"called-chat-program /bin/sh /usr/tmp/tstuu/Chat2 \\Y\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"time any\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Pass2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# Call in password file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"test1 pass\\s1\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|zuucp1
operator|=
literal|"./uucp -I /usr/tmp/tstuu/Config1 -r"
expr_stmt|;
name|zuux1
operator|=
literal|"./uux -I /usr/tmp/tstuu/Config1 -r"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zuucp2
operator|=
literal|"/usr/bin/uucp -r"
expr_stmt|;
name|zuux2
operator|=
literal|"/usr/bin/uux -r"
expr_stmt|;
block|}
else|else
block|{
name|zuucp2
operator|=
literal|"./uucp -I /usr/tmp/tstuu/Config2 -r"
expr_stmt|;
name|zuux2
operator|=
literal|"./uux -I /usr/tmp/tstuu/Config2 -r"
expr_stmt|;
block|}
comment|/* Test transferring a file from the first system to the second.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|1
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from1"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
name|zto
operator|=
literal|"/usr/spool/uucppublic/to1"
expr_stmt|;
else|else
name|zto
operator|=
literal|"/usr/tmp/tstuu/to1"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s %s %s!%s"
argument_list|,
name|zuucp1
argument_list|,
name|zfrom
argument_list|,
name|zsys
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the first system request a file from the second.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|zfrom
operator|=
literal|"/usr/spool/uucppublic/from2"
expr_stmt|;
else|else
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from2"
expr_stmt|;
name|zto
operator|=
literal|"/usr/tmp/tstuu/to2"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s %s!%s %s"
argument_list|,
name|zuucp1
argument_list|,
name|zsys
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system send a file to the first.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|zfrom
operator|=
literal|"/usr/spool/uucppublic/from3"
expr_stmt|;
else|else
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from3"
expr_stmt|;
name|zto
operator|=
literal|"/usr/tmp/tstuu/to3"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s -c \\~/from3 test1!~/to3"
argument_list|,
name|zuucp2
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system request a file from the first.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|4
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from4"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
name|zto
operator|=
literal|"/usr/spool/uucppublic/to4"
expr_stmt|;
else|else
name|zto
operator|=
literal|"/usr/tmp/tstuu/to4"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s test1!%s %s"
argument_list|,
name|zuucp2
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system make an execution request.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|5
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from5"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
name|zto
operator|=
literal|"/usr/spool/uucppublic/to5"
expr_stmt|;
else|else
name|zto
operator|=
literal|"/usr/tmp/tstuu/to5"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s test1!cat '<%s' '>%s'"
argument_list|,
name|zuux2
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the first system request a wildcard.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|6
condition|)
block|{
specifier|const
name|char
modifier|*
name|zfrom1
decl_stmt|,
modifier|*
name|zfrom2
decl_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/spool/uucppublic/to6\\*"
expr_stmt|;
name|zfrom1
operator|=
literal|"/usr/spool/uucppublic/to6.1"
expr_stmt|;
name|zfrom2
operator|=
literal|"/usr/spool/uucppublic/to6.2"
expr_stmt|;
block|}
else|else
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/spool2/to6\\*"
expr_stmt|;
name|zfrom1
operator|=
literal|"/usr/tmp/tstuu/spool2/to6.1"
expr_stmt|;
name|zfrom2
operator|=
literal|"/usr/tmp/tstuu/spool2/to6.2"
expr_stmt|;
block|}
name|umake_file
argument_list|(
name|zfrom1
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom2
argument_list|,
literal|101
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/to6.1"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/to6.2"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s %s!%s /usr/tmp/tstuu"
argument_list|,
name|zuucp1
argument_list|,
name|zsys
argument_list|,
name|zfrom
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system request a wildcard.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|7
condition|)
block|{
specifier|const
name|char
modifier|*
name|zto1
decl_stmt|,
modifier|*
name|zto2
decl_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zto
operator|=
literal|"/usr/spool/uucppublic"
expr_stmt|;
name|zto1
operator|=
literal|"/usr/spool/uucppublic/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/spool/uucppublic/to7.2"
expr_stmt|;
block|}
else|else
block|{
name|zto
operator|=
literal|"/usr/tmp/tstuu"
expr_stmt|;
name|zto1
operator|=
literal|"/usr/tmp/tstuu/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/tmp/tstuu/to7.2"
expr_stmt|;
block|}
name|umake_file
argument_list|(
literal|"/usr/tmp/tstuu/spool1/to7.1"
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
literal|"/usr/tmp/tstuu/spool1/to7.2"
argument_list|,
literal|155
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s test1!/usr/tmp/tstuu/spool1/to7.\\* %s"
argument_list|,
name|zuucp2
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test an E command.  This runs cat, discarding the output.  */
if|if
condition|(
operator|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|8
operator|)
operator|&&
operator|!
name|fcall_uucico
condition|)
block|{
name|umake_file
argument_list|(
literal|"/usr/tmp/tstuu/from8"
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s - test2!cat< /usr/tmp/tstuu/from8"
argument_list|,
name|zuux1
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to make sure the file transfers were successful.  */
end_comment

begin_function
specifier|static
name|void
name|ucheck_test
parameter_list|(
name|itest
parameter_list|,
name|fcall_uucico
parameter_list|)
name|int
name|itest
decl_stmt|;
name|boolean
name|fcall_uucico
decl_stmt|;
block|{
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/spool/uucppublic/to1"
argument_list|,
literal|"test 1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to1"
argument_list|,
literal|"test 1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|2
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to2"
argument_list|,
literal|"test 2"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|3
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to3"
argument_list|,
literal|"test 3"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/spool/uucppublic/to4"
argument_list|,
literal|"test 4"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to4"
argument_list|,
literal|"test 4"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|6
condition|)
block|{
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to6.1"
argument_list|,
literal|"test 6.1"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to6.2"
argument_list|,
literal|"test 6.2"
argument_list|,
literal|101
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|7
condition|)
block|{
specifier|const
name|char
modifier|*
name|zto1
decl_stmt|,
modifier|*
name|zto2
decl_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zto1
operator|=
literal|"/usr/spool/uucppublic/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/spool/uucppublic/to7.2"
expr_stmt|;
block|}
else|else
block|{
name|zto1
operator|=
literal|"/usr/tmp/tstuu/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/tmp/tstuu/to7.2"
expr_stmt|;
block|}
name|ucheck_file
argument_list|(
name|zto1
argument_list|,
literal|"test 7.1"
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|ucheck_file
argument_list|(
name|zto2
argument_list|,
literal|"test 7.2"
argument_list|,
literal|155
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A debugging routine used when displaying buffers.  */
end_comment

begin_function
specifier|static
name|int
name|cpshow
parameter_list|(
name|z
parameter_list|,
name|ichar
parameter_list|)
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ichar
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|BUCHAR
argument_list|(
name|ichar
argument_list|)
argument_list|)
operator|&&
name|ichar
operator|!=
literal|'\"'
condition|)
block|{
operator|*
name|z
operator|=
operator|(
name|char
operator|)
name|ichar
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|z
operator|++
operator|=
literal|'\\'
expr_stmt|;
switch|switch
condition|(
name|ichar
condition|)
block|{
case|case
literal|'\n'
case|:
operator|*
name|z
operator|=
literal|'n'
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'\r'
case|:
operator|*
name|z
operator|=
literal|'r'
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'\"'
case|:
operator|*
name|z
operator|=
literal|'\"'
expr_stmt|;
return|return
literal|2
return|;
default|default:
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"%03o"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|ichar
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pick one of two file descriptors which is ready for reading, or    return in five seconds.  If the argument is ready for reading,    leave it alone; otherwise set it to -1.  */
end_comment

begin_function
specifier|static
name|void
name|uchoose
parameter_list|(
name|po1
parameter_list|,
name|po2
parameter_list|)
name|int
modifier|*
name|po1
decl_stmt|;
name|int
modifier|*
name|po2
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_SELECT
name|int
name|iread
decl_stmt|;
name|struct
name|timeval
name|stime
decl_stmt|;
name|iread
operator|=
operator|(
literal|1
operator|<<
operator|*
name|po1
operator|)
operator||
operator|(
literal|1
operator|<<
operator|*
name|po2
operator|)
expr_stmt|;
name|stime
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|stime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
operator|(
operator|*
name|po1
operator|>
operator|*
name|po2
condition|?
operator|*
name|po1
else|:
operator|*
name|po2
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|iread
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|&
name|stime
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iread
operator|&
operator|(
literal|1
operator|<<
operator|*
name|po1
operator|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|po1
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|iread
operator|&
operator|(
literal|1
operator|<<
operator|*
name|po2
operator|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|po2
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_SELECT */
if|#
directive|if
name|HAVE_POLL
name|struct
name|pollfd
name|as
index|[
literal|2
index|]
decl_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|fd
operator|=
operator|*
name|po1
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|fd
operator|=
operator|*
name|po2
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|as
argument_list|,
literal|2
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"poll"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|as
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
operator|==
literal|0
condition|)
operator|*
name|po1
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|as
index|[
literal|1
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
operator|==
literal|0
condition|)
operator|*
name|po2
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
endif|#
directive|endif
comment|/* ! HAVE_SELECT */
block|}
end_function

begin_comment
comment|/* Read some data from a file descriptor.  This keeps reading until    one of the reads gets no data.  */
end_comment

begin_function
specifier|static
name|long
name|cread
parameter_list|(
name|o
parameter_list|,
name|pqbuf
parameter_list|)
name|int
name|o
decl_stmt|;
name|struct
name|sbuf
modifier|*
modifier|*
name|pqbuf
decl_stmt|;
block|{
name|long
name|ctotal
decl_stmt|;
while|while
condition|(
operator|*
name|pqbuf
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|qnext
operator|!=
name|NULL
condition|)
name|pqbuf
operator|=
operator|&
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|qnext
expr_stmt|;
name|ctotal
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|cgot
decl_stmt|;
if|if
condition|(
operator|*
name|pqbuf
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|pqbuf
argument_list|)
operator|->
name|ab
condition|)
name|pqbuf
operator|=
operator|&
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|qnext
expr_stmt|;
if|if
condition|(
operator|*
name|pqbuf
operator|==
name|NULL
condition|)
block|{
operator|*
name|pqbuf
operator|=
operator|(
expr|struct
name|sbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pqbuf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory\n"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cstart
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
operator|=
literal|0
expr_stmt|;
block|}
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|ab
operator|+
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|pqbuf
argument_list|)
operator|->
name|ab
operator|)
operator|-
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|ENODATA
condition|)
name|cgot
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cgot
operator|==
literal|0
condition|)
return|return
name|ctotal
return|;
name|ctotal
operator|+=
name|cgot
expr_stmt|;
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
block|{
name|char
name|abshow
index|[
literal|325
index|]
decl_stmt|;
name|char
modifier|*
name|zfrom
decl_stmt|;
name|char
modifier|*
name|zshow
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zfrom
operator|=
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|ab
operator|+
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
expr_stmt|;
name|zshow
operator|=
name|abshow
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cgot
operator|&&
name|i
operator|<
literal|80
condition|;
name|i
operator|++
operator|,
name|zfrom
operator|++
control|)
name|zshow
operator|+=
name|cpshow
argument_list|(
name|zshow
argument_list|,
operator|*
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|cgot
condition|)
block|{
operator|*
name|zshow
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|zshow
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|zshow
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|zshow
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Read from %d: %d \"%s\"\n"
argument_list|,
name|o
argument_list|,
name|cgot
argument_list|,
name|abshow
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iPercent
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cgot
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rand
argument_list|()
operator|%
literal|1000
operator|<
name|iPercent
condition|)
block|{
operator|++
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|ab
index|[
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
operator|+
name|i
index|]
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zDebug
operator|!=
name|NULL
operator|&&
name|c
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Clobbered %d bytes\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
operator|+=
name|cgot
expr_stmt|;
if|if
condition|(
name|ctotal
operator|>
literal|256
condition|)
return|return
name|ctotal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Write data to a file descriptor until one of the writes gets no    data.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsend
parameter_list|(
name|o
parameter_list|,
name|oslave
parameter_list|,
name|pqbuf
parameter_list|)
name|int
name|o
decl_stmt|;
name|int
name|oslave
decl_stmt|;
name|struct
name|sbuf
modifier|*
modifier|*
name|pqbuf
decl_stmt|;
block|{
name|long
name|ctotal
decl_stmt|;
name|ctotal
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pqbuf
operator|!=
name|NULL
condition|)
block|{
name|int
name|cwrite
decl_stmt|,
name|cwrote
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cstart
operator|>=
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
condition|)
block|{
name|struct
name|sbuf
modifier|*
name|qfree
decl_stmt|;
name|qfree
operator|=
operator|*
name|pqbuf
expr_stmt|;
operator|*
name|pqbuf
operator|=
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|qnext
expr_stmt|;
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|qfree
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|FIONREAD
block|{
name|long
name|cunread
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|oslave
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|cunread
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"FIONREAD"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld unread\n"
argument_list|,
name|cunread
argument_list|)
expr_stmt|;
name|cwrite
operator|=
literal|256
operator|-
name|cunread
expr_stmt|;
if|if
condition|(
name|cwrite
operator|<=
literal|0
condition|)
break|break;
block|}
else|#
directive|else
comment|/* ! FIONREAD */
if|if
condition|(
operator|!
name|fwritable
argument_list|(
name|o
argument_list|)
condition|)
break|break;
name|cwrite
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* ! FIONREAD */
if|if
condition|(
name|cwrite
operator|>
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
operator|-
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cstart
condition|)
name|cwrite
operator|=
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cend
operator|-
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cstart
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|ab
operator|+
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cstart
argument_list|,
name|cwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|ENODATA
condition|)
name|cwrote
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cwrote
operator|==
literal|0
condition|)
break|break;
name|ctotal
operator|+=
name|cwrote
expr_stmt|;
operator|(
operator|*
name|pqbuf
operator|)
operator|->
name|cstart
operator|+=
name|cwrote
expr_stmt|;
block|}
if|if
condition|(
name|zDebug
operator|!=
name|NULL
operator|&&
name|ctotal
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrote %ld to %d\n"
argument_list|,
name|ctotal
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
name|ctotal
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether a file descriptor can be written to.  */
end_comment

begin_function
specifier|static
name|boolean
name|fwritable
parameter_list|(
name|o
parameter_list|)
name|int
name|o
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_SELECT
name|int
name|iwrite
decl_stmt|;
name|struct
name|timeval
name|stime
decl_stmt|;
name|int
name|cfds
decl_stmt|;
name|iwrite
operator|=
literal|1
operator|<<
name|o
expr_stmt|;
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|stime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|cfds
operator|=
name|select
argument_list|(
name|o
operator|+
literal|1
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|iwrite
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfds
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
return|return
name|cfds
operator|>
literal|0
return|;
else|#
directive|else
comment|/* ! HAVE_SELECT */
if|#
directive|if
name|HAVE_POLL
name|struct
name|pollfd
name|s
decl_stmt|;
name|int
name|cfds
decl_stmt|;
name|s
operator|.
name|fd
operator|=
name|o
expr_stmt|;
name|s
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|cfds
operator|=
name|poll
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfds
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"poll"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
return|return
name|cfds
operator|>
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_POLL */
endif|#
directive|endif
comment|/* ! HAVE_SELECT */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A version of the system command that checks for errors.  */
end_comment

begin_function
specifier|static
name|void
name|xsystem
parameter_list|(
name|zcmd
parameter_list|)
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
block|{
name|int
name|istat
decl_stmt|;
name|istat
operator|=
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command failed with status %d\n"
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

