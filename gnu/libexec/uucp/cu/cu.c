begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cu.c    Call up a remote system.     Copyright (C) 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|cu_rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cu.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Here are the user settable variables.  The user is permitted to    change these while running the program, using ~s.  */
end_comment

begin_comment
comment|/* The escape character used to introduce a special command.  The    escape character is the first character of this string.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_escape
init|=
literal|"~"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to delay for a second before printing the host name after    seeing an escape character.  */
end_comment

begin_decl_stmt
name|boolean
name|fCuvar_delay
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The input characters which finish a line.  The escape character is    only recognized following one of these characters.  The default is    carriage return, ^U, ^C, ^O, ^D, ^S, ^Q, ^R, which I got from the    Ultrix /etc/remote file.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_eol
init|=
literal|"\r\025\003\017\004\023\021\022"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to transfer binary data (nonprintable characters other than    newline and tab) when sending a file.  If this is FALSE, then    newline is changed to carriage return.  */
end_comment

begin_decl_stmt
name|boolean
name|fCuvar_binary
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A prefix string to use before sending a binary character from a    file; this is only used if fCuvar_binary is TRUE.  The default is    ^V. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_binary_prefix
init|=
literal|"\026"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to check for echoes of characters sent when sending a file.    This is ignored if fCuvar_binary is TRUE.  */
end_comment

begin_decl_stmt
name|boolean
name|fCuvar_echocheck
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A character to look for after each newline is sent when sending a    file.  The character is the first character in this string, except    that a '\0' means that no echo check is done.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_echonl
init|=
literal|"\r"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The timeout to use when looking for an character.  */
end_comment

begin_decl_stmt
name|int
name|cCuvar_timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character to use to kill a line if an echo check fails.  The    first character in this string is sent.  The default is ^U.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_kill
init|=
literal|"\025"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times to try resending a line if the echo check keeps    failing.  */
end_comment

begin_decl_stmt
name|int
name|cCuvar_resend
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to send at the end of a file sent with ~>.  The default    is ^D.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_eofwrite
init|=
literal|"\004"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to look for to finish a file received with ~<.  For tip    this is a collection of single characters, but I don't want to do    that because it means that there are characters which cannot be    received.  The default is a guess at a typical shell prompt.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zCuvar_eofread
init|=
literal|"$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to provide verbose information when sending or receiving a    file.  */
end_comment

begin_decl_stmt
name|boolean
name|fCuvar_verbose
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table used to give a value to a variable, and to print all the    variable values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uuconf_cmdtab
name|asCuvars
index|[]
init|=
block|{
block|{
literal|"escape"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_escape
block|,
name|NULL
block|}
block|,
block|{
literal|"delay"
block|,
name|UUCONF_CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fCuvar_delay
block|,
name|NULL
block|}
block|,
block|{
literal|"eol"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_eol
block|,
name|NULL
block|}
block|,
block|{
literal|"binary"
block|,
name|UUCONF_CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fCuvar_binary
block|,
name|NULL
block|}
block|,
block|{
literal|"binary-prefix"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_binary_prefix
block|,
name|NULL
block|}
block|,
block|{
literal|"echocheck"
block|,
name|UUCONF_CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fCuvar_echocheck
block|,
name|NULL
block|}
block|,
block|{
literal|"echonl"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_echonl
block|,
name|NULL
block|}
block|,
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cCuvar_timeout
block|,
name|NULL
block|}
block|,
block|{
literal|"kill"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_kill
block|,
name|NULL
block|}
block|,
block|{
literal|"resend"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cCuvar_resend
block|,
name|NULL
block|}
block|,
block|{
literal|"eofwrite"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_eofwrite
block|,
name|NULL
block|}
block|,
block|{
literal|"eofread"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCuvar_eofread
block|,
name|NULL
block|}
block|,
block|{
literal|"verbose"
block|,
name|UUCONF_CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fCuvar_verbose
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The string printed at the initial connect.  */
end_comment

begin_if
if|#
directive|if
name|ANSI_C
end_if

begin_define
define|#
directive|define
name|ZCONNMSG
value|"\aConnected."
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZCONNMSG
value|"Connected."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string printed when disconnecting.  */
end_comment

begin_if
if|#
directive|if
name|ANSI_C
end_if

begin_define
define|#
directive|define
name|ZDISMSG
value|"\aDisconnected."
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZDISMSG
value|"Disconnected."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* The string we print when the user is once again connected to the    port after transferring a file or taking some other action.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|abCuconnected
index|[]
if|#
directive|if
name|ANSI_C
init|=
literal|"\a[connected]"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|=
literal|"[connected]"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global uuconf pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|pointer
name|pCuuuconf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sconnection
modifier|*
name|qCuconn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to close the connection.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fCuclose_conn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dialer used to dial out.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uuconf_dialer
modifier|*
name|qCudialer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we need to restore the terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fCurestore_terminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are doing local echoing.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fCulocalecho
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we need to call fsysdep_cu_finish.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fCustarted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether ZCONNMSG has been printed yet.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fCuconnprinted
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A structure used to pass information to icuport_lock.  */
end_comment

begin_struct
struct|struct
name|sconninfo
block|{
name|boolean
name|fmatched
decl_stmt|;
name|boolean
name|flocked
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zline
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ucuusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucuhelp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucuabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uculog_start
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uculog_end
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icuport_lock
name|P
argument_list|(
operator|(
expr|struct
name|uuconf_port
operator|*
name|qport
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcudo_cmd
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|int
name|bcmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcuset_var
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|char
operator|*
name|zline
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icuunrecogvar
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icuunrecogfn
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uculist_vars
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uculist_fns
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zescape
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcudo_subcmd
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|char
operator|*
name|zline
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcusend_buf
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|zbuf
operator|,
name|size_t
name|cbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ucuputs
parameter_list|(
name|zline
parameter_list|)
define|\
value|do { if (! fsysdep_terminal_puts (zline)) ucuabort (); } while (0)
end_define

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asCulongopts
index|[]
init|=
block|{
block|{
literal|"phone"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"escape"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"parity"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|2
block|}
block|,
block|{
literal|"halfduplex"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"prompt"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"line"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"port"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"speed"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"baud"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"mapcr"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"nostop"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|3
block|}
block|,
block|{
literal|"system"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"config"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"debug"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* -c: phone number.  */
name|char
modifier|*
name|zphone
init|=
name|NULL
decl_stmt|;
comment|/* -e: even parity.  */
name|boolean
name|feven
init|=
name|FALSE
decl_stmt|;
comment|/* -l: line.  */
name|char
modifier|*
name|zline
init|=
name|NULL
decl_stmt|;
comment|/* -n: prompt for phone number.  */
name|boolean
name|fprompt
init|=
name|FALSE
decl_stmt|;
comment|/* -o: odd parity.  */
name|boolean
name|fodd
init|=
name|FALSE
decl_stmt|;
comment|/* -p: port name.  */
specifier|const
name|char
modifier|*
name|zport
init|=
name|NULL
decl_stmt|;
comment|/* -s: speed.  */
name|long
name|ibaud
init|=
literal|0L
decl_stmt|;
comment|/* -t: map cr to crlf.  */
name|boolean
name|fmapcr
init|=
name|FALSE
decl_stmt|;
comment|/* -z: system.  */
specifier|const
name|char
modifier|*
name|zsystem
init|=
name|NULL
decl_stmt|;
comment|/* --nostop: turn off XON/XOFF.  */
name|enum
name|txonxoffsetting
name|txonxoff
init|=
name|XONXOFF_ON
decl_stmt|;
comment|/* -I: configuration file name.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
name|int
name|iopt
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|uuconf_system
name|ssys
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
init|=
name|NULL
decl_stmt|;
name|boolean
name|flooped
decl_stmt|;
name|struct
name|uuconf_port
name|sport
decl_stmt|;
name|struct
name|sconnection
name|sconn
decl_stmt|;
name|struct
name|sconninfo
name|sinfo
decl_stmt|;
name|long
name|ihighbaud
decl_stmt|;
name|struct
name|uuconf_dialer
name|sdialer
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|char
name|bcmd
decl_stmt|;
name|zProgram
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* We want to accept -# as a speed.  It's easiest to look through      the arguments, replace -# with -s#, and let getopt handle it.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|z
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|z
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|z
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
name|memcpy
argument_list|(
name|z
operator|+
literal|2
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|z
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:c:deE:hnI:l:op:s:tvx:z:"
argument_list|,
name|asCulongopts
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* Phone number.  */
name|zphone
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Set debugging level to maximum.  */
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|DEBUG_MAX
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'e'
case|:
comment|/* Even parity.  */
name|feven
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Escape character.  */
name|zCuvar_escape
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Local echo.  */
name|fCulocalecho
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Prompt for phone number.  */
name|fprompt
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Line name.  */
name|zline
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Odd parity.  */
name|fodd
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'a'
case|:
comment|/* Port name (-a is for compatibility).  */
name|zport
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Speed.  */
name|ibaud
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Map cr to crlf.  */
name|fmapcr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* System name.  */
name|zsystem
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Configuration file name.  */
if|if
condition|(
name|fsysdep_other_config
argument_list|(
name|optarg
argument_list|)
condition|)
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'v'
case|:
comment|/* Print version and exit.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|zProgram
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|2
case|:
comment|/* --parity.  */
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"even"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|feven
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"odd"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fodd
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"none"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|feven
operator|=
name|TRUE
expr_stmt|;
name|fodd
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --parity requires even, odd or none\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|ucuusage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* --nostop.  */
name|txonxoff
operator|=
name|XONXOFF_OFF
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* --help.  */
name|ucuhelp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* Long option found and flag set.  */
break|break;
default|default:
name|ucuusage
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
comment|/* There can be one more argument, which is either a system name, a      phone number, or "dir".  We decide which it is based on the first      character.  To call a UUCP system whose name begins with a digit,      or one which is named "dir", you must use -z.  */
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
block|{
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|1
operator|||
name|zsystem
operator|!=
name|NULL
operator|||
name|zphone
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too many arguments\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|ucuusage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"dir"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|zphone
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
else|else
name|zsystem
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
block|}
comment|/* If the user doesn't give a system, port, line or speed, then      there's no basis on which to select a port.  */
if|if
condition|(
name|zsystem
operator|==
name|NULL
operator|&&
name|zport
operator|==
name|NULL
operator|&&
name|zline
operator|==
name|NULL
operator|&&
name|ibaud
operator|==
literal|0L
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: must specify system, line, port or speed\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|ucuusage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fprompt
condition|)
block|{
name|size_t
name|cphone
decl_stmt|;
name|printf
argument_list|(
literal|"Phone number: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|zphone
operator|=
name|NULL
expr_stmt|;
name|cphone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zphone
argument_list|,
operator|&
name|cphone
argument_list|,
name|stdin
argument_list|)
operator|<=
literal|0
operator|||
operator|*
name|zphone
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no phone number entered\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|iuuconf
operator|=
name|uuconf_init
argument_list|(
operator|&
name|puuconf
argument_list|,
literal|"cu"
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|pCuuuconf
operator|=
name|puuconf
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
block|{
specifier|const
name|char
modifier|*
name|zdebug
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_debuglevel
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zdebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdebug
operator|!=
name|NULL
condition|)
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|zdebug
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|puuconf
argument_list|,
name|INIT_NOCHDIR
operator||
name|INIT_SUID
argument_list|)
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_localname
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zlocalname
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|zlocalname
operator|=
name|zsysdep_localname
argument_list|()
expr_stmt|;
if|if
condition|(
name|zlocalname
operator|==
name|NULL
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|ucuabort
argument_list|)
expr_stmt|;
name|pfLstart
operator|=
name|uculog_start
expr_stmt|;
name|pfLend
operator|=
name|uculog_end
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zsystem
operator|!=
name|NULL
condition|)
block|{
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zsystem
argument_list|,
operator|&
name|ssys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: System not found"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
block|}
name|qsys
operator|=
operator|&
name|ssys
expr_stmt|;
block|}
comment|/* This loop is used if a system is specified.  It loops over the      various alternates until it finds one for which the dial      succeeds.  This is an ugly spaghetti construction, and it should      be broken up into different functions someday.  */
name|flooped
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|enum
name|tparitysetting
name|tparity
decl_stmt|;
name|enum
name|tstripsetting
name|tstrip
decl_stmt|;
name|long
name|iusebaud
decl_stmt|;
comment|/* The uuconf_find_port function only selects directly on a port 	 name and a speed.  To select based on the line name, we use a 	 function.  If we can't find any defined port, and the user 	 specified a line name but did not specify a port name or a 	 system or a phone number, then we fake a direct port with 	 that line name (we don't fake a port if a system or phone 	 number were given because if we fake a port we have no way to 	 place a call; perhaps we should automatically look up a 	 particular dialer).  This permits users to say cu -lttyd0 	 without having to put ttyd0 in the ports file, provided they 	 have read and write access to the port.  */
name|sinfo
operator|.
name|fmatched
operator|=
name|FALSE
expr_stmt|;
name|sinfo
operator|.
name|flocked
operator|=
name|FALSE
expr_stmt|;
name|sinfo
operator|.
name|qconn
operator|=
operator|&
name|sconn
expr_stmt|;
name|sinfo
operator|.
name|zline
operator|=
name|zline
expr_stmt|;
if|if
condition|(
name|zport
operator|!=
name|NULL
operator|||
name|zline
operator|!=
name|NULL
operator|||
name|ibaud
operator|!=
literal|0L
condition|)
block|{
name|iuuconf
operator|=
name|uuconf_find_port
argument_list|(
name|puuconf
argument_list|,
name|zport
argument_list|,
name|ibaud
argument_list|,
literal|0L
argument_list|,
name|icuport_lock
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|sinfo
argument_list|,
operator|&
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|sinfo
operator|.
name|flocked
condition|)
block|{
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
block|}
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zline
operator|==
name|NULL
operator|||
name|zport
operator|!=
name|NULL
operator|||
name|zphone
operator|!=
name|NULL
operator|||
name|qsys
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sinfo
operator|.
name|fmatched
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"All matching ports in use"
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"No matching ports"
argument_list|)
expr_stmt|;
block|}
name|sport
operator|.
name|uuconf_zname
operator|=
name|zline
expr_stmt|;
name|sport
operator|.
name|uuconf_ttype
operator|=
name|UUCONF_PORTTYPE_DIRECT
expr_stmt|;
name|sport
operator|.
name|uuconf_zprotocols
operator|=
name|NULL
expr_stmt|;
name|sport
operator|.
name|uuconf_qproto_params
operator|=
name|NULL
expr_stmt|;
name|sport
operator|.
name|uuconf_ireliable
operator|=
literal|0
expr_stmt|;
name|sport
operator|.
name|uuconf_zlockname
operator|=
name|NULL
expr_stmt|;
name|sport
operator|.
name|uuconf_palloc
operator|=
name|NULL
expr_stmt|;
name|sport
operator|.
name|uuconf_u
operator|.
name|uuconf_sdirect
operator|.
name|uuconf_zdevice
operator|=
name|NULL
expr_stmt|;
name|sport
operator|.
name|uuconf_u
operator|.
name|uuconf_sdirect
operator|.
name|uuconf_ibaud
operator|=
name|ibaud
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_init
argument_list|(
operator|&
name|sport
argument_list|,
operator|&
name|sconn
argument_list|,
name|UUCONF_PORTTYPE_UNKNOWN
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_lock
argument_list|(
operator|&
name|sconn
argument_list|,
name|FALSE
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: Line in use"
argument_list|,
name|zline
argument_list|)
expr_stmt|;
name|qCuconn
operator|=
operator|&
name|sconn
expr_stmt|;
comment|/* Check user access after locking the port, because on 		 some systems shared lines affect the ownership and 		 permissions.  In such a case ``Line in use'' is more 		 clear than ``Permission denied.''  */
if|if
condition|(
operator|!
name|fsysdep_port_access
argument_list|(
operator|&
name|sport
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: Permission denied"
argument_list|,
name|zline
argument_list|)
expr_stmt|;
block|}
name|iusebaud
operator|=
name|ibaud
expr_stmt|;
name|ihighbaud
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|qsys
operator|!=
name|NULL
condition|;
name|qsys
operator|=
name|qsys
operator|->
name|uuconf_qalternate
control|)
block|{
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fcall
condition|)
continue|continue;
if|if
condition|(
name|qsys
operator|->
name|uuconf_qport
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fconn_init
argument_list|(
name|qsys
operator|->
name|uuconf_qport
argument_list|,
operator|&
name|sconn
argument_list|,
name|UUCONF_PORTTYPE_UNKNOWN
argument_list|)
condition|)
block|{
if|if
condition|(
name|fconn_lock
argument_list|(
operator|&
name|sconn
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|qCuconn
operator|=
operator|&
name|sconn
expr_stmt|;
break|break;
block|}
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sinfo
operator|.
name|fmatched
operator|=
name|FALSE
expr_stmt|;
name|sinfo
operator|.
name|flocked
operator|=
name|FALSE
expr_stmt|;
name|sinfo
operator|.
name|qconn
operator|=
operator|&
name|sconn
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_find_port
argument_list|(
name|puuconf
argument_list|,
name|qsys
operator|->
name|uuconf_zport
argument_list|,
name|qsys
operator|->
name|uuconf_ibaud
argument_list|,
name|qsys
operator|->
name|uuconf_ihighbaud
argument_list|,
name|icuport_lock
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|sinfo
argument_list|,
operator|&
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_SUCCESS
condition|)
break|break;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|sinfo
operator|.
name|flocked
condition|)
block|{
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
block|}
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zrem
decl_stmt|;
if|if
condition|(
name|flooped
condition|)
name|zrem
operator|=
literal|"remaining "
expr_stmt|;
else|else
name|zrem
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|sinfo
operator|.
name|fmatched
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: All %smatching ports in use"
argument_list|,
name|zsystem
argument_list|,
name|zrem
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: No %smatching ports"
argument_list|,
name|zsystem
argument_list|,
name|zrem
argument_list|)
expr_stmt|;
block|}
name|iusebaud
operator|=
name|qsys
operator|->
name|uuconf_ibaud
expr_stmt|;
name|ihighbaud
operator|=
name|qsys
operator|->
name|uuconf_ihighbaud
expr_stmt|;
block|}
comment|/* Here we have locked a connection to use.  */
if|if
condition|(
operator|!
name|fconn_open
argument_list|(
operator|&
name|sconn
argument_list|,
name|iusebaud
argument_list|,
name|ihighbaud
argument_list|,
name|FALSE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCuclose_conn
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
comment|/* Set up the connection.  */
if|if
condition|(
name|fodd
operator|&&
name|feven
condition|)
block|{
name|tparity
operator|=
name|PARITYSETTING_NONE
expr_stmt|;
name|tstrip
operator|=
name|STRIPSETTING_SEVENBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fodd
condition|)
block|{
name|tparity
operator|=
name|PARITYSETTING_ODD
expr_stmt|;
name|tstrip
operator|=
name|STRIPSETTING_SEVENBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|feven
condition|)
block|{
name|tparity
operator|=
name|PARITYSETTING_EVEN
expr_stmt|;
name|tstrip
operator|=
name|STRIPSETTING_SEVENBITS
expr_stmt|;
block|}
else|else
block|{
name|tparity
operator|=
name|PARITYSETTING_DEFAULT
expr_stmt|;
name|tstrip
operator|=
name|STRIPSETTING_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
operator|&
name|sconn
argument_list|,
name|tparity
argument_list|,
name|tstrip
argument_list|,
name|txonxoff
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|qsys
operator|!=
name|NULL
condition|)
name|zphone
operator|=
name|qsys
operator|->
name|uuconf_zphone
expr_stmt|;
if|if
condition|(
name|qsys
operator|!=
name|NULL
operator|||
name|zphone
operator|!=
name|NULL
condition|)
block|{
name|enum
name|tdialerfound
name|tdialer
decl_stmt|;
if|if
condition|(
operator|!
name|fconn_dial
argument_list|(
operator|&
name|sconn
argument_list|,
name|puuconf
argument_list|,
name|qsys
argument_list|,
name|zphone
argument_list|,
operator|&
name|sdialer
argument_list|,
operator|&
name|tdialer
argument_list|)
condition|)
block|{
if|if
condition|(
name|zport
operator|!=
name|NULL
operator|||
name|zline
operator|!=
name|NULL
operator|||
name|ibaud
operator|!=
literal|0L
operator|||
name|qsys
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|qsys
operator|=
name|qsys
operator|->
name|uuconf_qalternate
expr_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: No remaining alternates"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
name|fCuclose_conn
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_close
argument_list|(
operator|&
name|sconn
argument_list|,
name|pCuuuconf
argument_list|,
name|qCudialer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|qCuconn
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
comment|/* Loop around and try another alternate.  */
name|flooped
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tdialer
operator|==
name|DIALERFOUND_FALSE
condition|)
name|qdialer
operator|=
name|NULL
expr_stmt|;
else|else
name|qdialer
operator|=
operator|&
name|sdialer
expr_stmt|;
block|}
else|else
block|{
comment|/* If no system or phone number was specified, we connect 	     directly to the modem.  We only permit this if the user 	     has access to the port, since it permits various 	     shenanigans such as reprogramming the automatic 	     callbacks.  */
if|if
condition|(
operator|!
name|fsysdep_port_access
argument_list|(
name|sconn
operator|.
name|qport
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Access to port denied"
argument_list|)
expr_stmt|;
name|qdialer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_carrier
argument_list|(
operator|&
name|sconn
argument_list|,
name|FALSE
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Can't turn off carrier"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|qCudialer
operator|=
name|qdialer
expr_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
comment|/* Here we have connected, and can start the main cu protocol.  The      program spends most of its time in system dependent code, and      only comes out when a special command is received from the      terminal.  */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ZCONNMSG
argument_list|)
expr_stmt|;
name|fCuconnprinted
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_terminal_raw
argument_list|(
name|fCulocalecho
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_init
argument_list|(
operator|&
name|sconn
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCustarted
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|fsysdep_cu
argument_list|(
operator|&
name|sconn
argument_list|,
operator|&
name|bcmd
argument_list|,
name|zlocalname
argument_list|)
condition|)
if|if
condition|(
operator|!
name|fcudo_cmd
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sconn
argument_list|,
name|bcmd
argument_list|)
condition|)
break|break;
name|fCustarted
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_finish
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_terminal_restore
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_close
argument_list|(
operator|&
name|sconn
argument_list|,
name|puuconf
argument_list|,
name|qdialer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fCuconnprinted
condition|)
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|ZDISMSG
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Avoid errors about not returning a value.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print a usage message and die.  */
end_comment

begin_function
specifier|static
name|void
name|ucuusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options] [system or phone-number]\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use %s --help for help\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a help message.  */
end_comment

begin_function
specifier|static
name|void
name|ucuhelp
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options] [system or phone-number]\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -a,-p,--port port: Use named port\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -l,--line line: Use named device (e.g. tty0)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -s,--speed,--baud speed, -#: Use given speed\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -c,--phone phone: Phone number to call\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -z,--system system: System to call\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -e: Set even parity\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -o: Set odd parity\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" --parity={odd,even}: Set parity\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -E,--escape char: Set escape character\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -h,--halfduplex: Echo locally\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" --nostop: Turn off XON/XOFF handling\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -t,--mapcr: Map carriage return to carriage return/linefeed\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -n,--prompt: Prompt for phone number\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -d: Set maximum debugging level\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -x,--debug debug: Set debugging type\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -I,--config file: Set configuration file to use\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -v,--version: Print version and exit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" --help: Print help and exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when a fatal error occurs.  */
end_comment

begin_function
specifier|static
name|void
name|ucuabort
parameter_list|()
block|{
if|if
condition|(
name|fCustarted
condition|)
block|{
name|fCustarted
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_cu_finish
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fCurestore_terminal
condition|)
block|{
name|fCurestore_terminal
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_terminal_restore
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|qCuconn
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
if|if
condition|(
name|fCuclose_conn
condition|)
block|{
name|fCuclose_conn
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_close
argument_list|(
name|qCuconn
argument_list|,
name|pCuuuconf
argument_list|,
name|qCudialer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|qconn
operator|=
name|qCuconn
expr_stmt|;
name|qCuconn
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
name|qconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
name|qconn
argument_list|)
expr_stmt|;
block|}
name|ulog_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|fCuconnprinted
condition|)
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|ZDISMSG
argument_list|)
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This variable is just used to communicate between uculog_start and    uculog_end.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fCulog_restore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is called by ulog before it output anything.  We use    it to restore the terminal, if necessary.  ulog is only called for    errors or debugging in cu, so it's not too costly to do this.  If    we didn't do it, then at least on Unix each line would leave the    cursor in the same column rather than wrapping back to the start,    since CRMOD will not be on.  */
end_comment

begin_function
specifier|static
name|void
name|uculog_start
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fCurestore_terminal
condition|)
name|fCulog_restore
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|fCulog_restore
operator|=
name|TRUE
expr_stmt|;
name|fCurestore_terminal
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_terminal_restore
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called by ulog after everything is output.  It    sets the terminal back, if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|uculog_end
parameter_list|()
block|{
if|if
condition|(
name|fCulog_restore
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_terminal_raw
argument_list|(
name|fCulocalecho
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if this port has the desired line, to handle the -l    option.  If it does, or if no line was specified, set up a    connection and lock it.  */
end_comment

begin_function
specifier|static
name|int
name|icuport_lock
parameter_list|(
name|qport
parameter_list|,
name|pinfo
parameter_list|)
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|sconninfo
modifier|*
name|q
init|=
operator|(
expr|struct
name|sconninfo
operator|*
operator|)
name|pinfo
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|zline
operator|!=
name|NULL
operator|&&
operator|!
name|fsysdep_port_is_line
argument_list|(
name|qport
argument_list|,
name|q
operator|->
name|zline
argument_list|)
condition|)
return|return
name|UUCONF_NOT_FOUND
return|;
name|q
operator|->
name|fmatched
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_init
argument_list|(
name|qport
argument_list|,
name|q
operator|->
name|qconn
argument_list|,
name|UUCONF_PORTTYPE_UNKNOWN
argument_list|)
condition|)
return|return
name|UUCONF_NOT_FOUND
return|;
elseif|else
if|if
condition|(
operator|!
name|fconn_lock
argument_list|(
name|q
operator|->
name|qconn
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|uconn_free
argument_list|(
name|q
operator|->
name|qconn
argument_list|)
expr_stmt|;
return|return
name|UUCONF_NOT_FOUND
return|;
block|}
else|else
block|{
name|qCuconn
operator|=
name|q
operator|->
name|qconn
expr_stmt|;
name|q
operator|->
name|flocked
operator|=
name|TRUE
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute a cu escape command.  Return TRUE if the connection should    continue, or FALSE if the connection should be terminated.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcudo_cmd
parameter_list|(
name|puuconf
parameter_list|,
name|qconn
parameter_list|,
name|bcmd
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|int
name|bcmd
decl_stmt|;
block|{
name|char
modifier|*
name|zline
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|char
name|abescape
index|[
literal|5
index|]
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|char
name|abbuf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Some commands take a string up to the next newline character.  */
switch|switch
condition|(
name|bcmd
condition|)
block|{
default|default:
name|zline
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'|'
case|:
case|case
literal|'+'
case|:
case|case
literal|'%'
case|:
case|case
literal|'c'
case|:
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'p'
case|:
case|case
literal|'t'
case|:
case|case
literal|'s'
case|:
block|{
name|zline
operator|=
name|zsysdep_terminal_line
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zline
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
block|}
switch|switch
condition|(
name|bcmd
condition|)
block|{
default|default:
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
condition|)
name|sprintf
argument_list|(
name|abescape
argument_list|,
literal|"\\%03o"
argument_list|,
name|BUCHAR
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|abescape
index|[
literal|0
index|]
operator|=
operator|*
name|zCuvar_escape
expr_stmt|;
name|abescape
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[Unrecognized.  Use %s%s to send %s]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'.'
case|:
comment|/* Hangup.  */
return|return
name|FALSE
return|;
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'|'
case|:
case|case
literal|'+'
case|:
comment|/* Shell out.  */
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|FALSE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_restore
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|FALSE
expr_stmt|;
block|{
name|enum
name|tshell_cmd
name|t
decl_stmt|;
switch|switch
condition|(
name|bcmd
condition|)
block|{
default|default:
case|case
literal|'!'
case|:
name|t
operator|=
name|SHELL_NORMAL
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|t
operator|=
name|SHELL_STDOUT_TO_PORT
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|t
operator|=
name|SHELL_STDIN_FROM_PORT
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|t
operator|=
name|SHELL_STDIO_ON_PORT
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fsysdep_shell
argument_list|(
name|qconn
argument_list|,
name|zline
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|TRUE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_raw
argument_list|(
name|fCulocalecho
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|TRUE
expr_stmt|;
name|ubuffree
argument_list|(
name|zline
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'%'
case|:
name|fret
operator|=
name|fcudo_subcmd
argument_list|(
name|puuconf
argument_list|,
name|qconn
argument_list|,
name|zline
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zline
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
case|case
literal|'#'
case|:
if|if
condition|(
operator|!
name|fconn_break
argument_list|(
name|qconn
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'c'
case|:
operator|(
name|void
operator|)
name|fsysdep_chdir
argument_list|(
name|zline
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zline
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'p'
case|:
case|case
literal|'t'
case|:
name|clen
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
expr_stmt|;
name|z
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|z
index|[
literal|0
index|]
operator|=
name|bcmd
expr_stmt|;
name|z
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|z
operator|+
literal|2
argument_list|,
name|zline
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zline
argument_list|)
expr_stmt|;
name|fret
operator|=
name|fcudo_subcmd
argument_list|(
name|puuconf
argument_list|,
name|qconn
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
case|case
literal|'z'
case|:
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|FALSE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_restore
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_suspend
argument_list|()
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|TRUE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_raw
argument_list|(
name|fCulocalecho
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|fCurestore_terminal
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'s'
case|:
name|fret
operator|=
name|fcuset_var
argument_list|(
name|puuconf
argument_list|,
name|zline
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zline
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
case|case
literal|'v'
case|:
name|uculist_vars
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'?'
case|:
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
condition|)
name|sprintf
argument_list|(
name|abescape
argument_list|,
literal|"\\%03o"
argument_list|,
name|BUCHAR
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|abescape
index|[
literal|0
index|]
operator|=
operator|*
name|zCuvar_escape
expr_stmt|;
name|abescape
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ucuputs
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[Escape sequences]"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s. hangup]                   [%s!CMD run shell]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s$CMD stdout to remote]      [%s|CMD stdin from remote]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s+CMD stdin and stdout to remote]"
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s# send break]               [%scDIR change directory]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s> send file]                [%s< receive file]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%spFROM TO send to Unix]      [%stFROM TO receive from Unix]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%ssVAR VAL set variable]      [%ssVAR set boolean]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%ss!VAR unset boolean]        [%sv list variables]"
argument_list|,
name|abescape
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%sz suspend]"
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uculist_fns
argument_list|(
name|abescape
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* List ~% functions.  */
end_comment

begin_function
specifier|static
name|void
name|uculist_fns
parameter_list|(
name|zescape
parameter_list|)
specifier|const
name|char
modifier|*
name|zescape
decl_stmt|;
block|{
name|char
name|abbuf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s%%break send break]         [%s%%cd DIR change directory]"
argument_list|,
name|zescape
argument_list|,
name|zescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s%%put FROM TO send file]    [%s%%take FROM TO receive file]"
argument_list|,
name|zescape
argument_list|,
name|zescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"[%s%%nostop no XON/XOFF]       [%s%%stop use XON/XOFF]"
argument_list|,
name|zescape
argument_list|,
name|zescape
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set a variable.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcuset_var
parameter_list|(
name|puuconf
parameter_list|,
name|zline
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
block|{
name|char
modifier|*
name|zvar
decl_stmt|,
modifier|*
name|zval
decl_stmt|;
name|char
modifier|*
name|azargs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
name|zvar
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|"= \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zvar
operator|==
name|NULL
condition|)
block|{
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|zval
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zval
operator|==
name|NULL
condition|)
block|{
name|azargs
index|[
literal|0
index|]
operator|=
name|zvar
expr_stmt|;
if|if
condition|(
name|azargs
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'!'
condition|)
name|azargs
index|[
literal|1
index|]
operator|=
name|zbufcpy
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|azargs
index|[
literal|0
index|]
expr_stmt|;
name|azargs
index|[
literal|1
index|]
operator|=
name|zbufcpy
argument_list|(
literal|"f"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|azargs
index|[
literal|0
index|]
operator|=
name|zvar
expr_stmt|;
name|azargs
index|[
literal|1
index|]
operator|=
name|zbufcpy
argument_list|(
name|zval
argument_list|)
expr_stmt|;
block|}
name|iuuconf
operator|=
name|uuconf_cmd_args
argument_list|(
name|puuconf
argument_list|,
literal|2
argument_list|,
name|azargs
argument_list|,
name|asCuvars
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
name|icuunrecogvar
argument_list|,
literal|0
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iuuconf
operator|&
name|UUCONF_CMDTABRET_KEEP
operator|)
operator|==
literal|0
condition|)
name|ubuffree
argument_list|(
name|azargs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iuuconf
operator|&
operator|~
name|UUCONF_CMDTABRET_KEEP
operator|)
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Warn about an unknown variable.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icuunrecogvar
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|char
name|abescape
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
condition|)
name|sprintf
argument_list|(
name|abescape
argument_list|,
literal|"\\%03o"
argument_list|,
name|BUCHAR
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|abescape
index|[
literal|0
index|]
operator|=
operator|*
name|zCuvar_escape
expr_stmt|;
name|abescape
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unknown variable (%sv lists variables)"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* List all the variables with their values.  */
end_comment

begin_function
specifier|static
name|void
name|uculist_vars
parameter_list|()
block|{
specifier|const
name|struct
name|uuconf_cmdtab
modifier|*
name|q
decl_stmt|;
name|char
name|abbuf
index|[
literal|100
index|]
decl_stmt|;
name|ucuputs
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|asCuvars
init|;
name|q
operator|->
name|uuconf_zcmd
operator|!=
name|NULL
condition|;
name|q
operator|++
control|)
block|{
switch|switch
condition|(
name|UUCONF_TTYPE_CMDTABTYPE
argument_list|(
name|q
operator|->
name|uuconf_itype
argument_list|)
condition|)
block|{
case|case
name|UUCONF_TTYPE_CMDTABTYPE
argument_list|(
name|UUCONF_CMDTABTYPE_BOOLEAN
argument_list|)
case|:
if|if
condition|(
operator|*
operator|(
name|boolean
operator|*
operator|)
name|q
operator|->
name|uuconf_pvar
condition|)
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"%s true"
argument_list|,
name|q
operator|->
name|uuconf_zcmd
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"%s false"
argument_list|,
name|q
operator|->
name|uuconf_zcmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|UUCONF_TTYPE_CMDTABTYPE
argument_list|(
name|UUCONF_CMDTABTYPE_INT
argument_list|)
case|:
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"%s %d"
argument_list|,
name|q
operator|->
name|uuconf_zcmd
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|q
operator|->
name|uuconf_pvar
argument_list|)
expr_stmt|;
break|break;
case|case
name|UUCONF_TTYPE_CMDTABTYPE
argument_list|(
name|UUCONF_CMDTABTYPE_LONG
argument_list|)
case|:
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"%s %ld"
argument_list|,
name|q
operator|->
name|uuconf_zcmd
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|q
operator|->
name|uuconf_pvar
argument_list|)
expr_stmt|;
break|break;
case|case
name|UUCONF_TTYPE_CMDTABTYPE
argument_list|(
name|UUCONF_CMDTABTYPE_STRING
argument_list|)
case|:
case|case
name|UUCONF_TTYPE_CMDTABTYPE
argument_list|(
name|UUCONF_CMDTABTYPE_FULLSTRING
argument_list|)
case|:
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|char
name|abchar
index|[
literal|5
index|]
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"%s "
argument_list|,
name|q
operator|->
name|uuconf_zcmd
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|z
operator|=
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|q
operator|->
name|uuconf_pvar
init|;
operator|*
name|z
operator|!=
literal|'\0'
condition|;
name|z
operator|++
control|)
block|{
name|int
name|cchar
decl_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|abchar
argument_list|,
literal|"\\%03o"
argument_list|,
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|cchar
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|abchar
index|[
literal|0
index|]
operator|=
operator|*
name|z
expr_stmt|;
name|abchar
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cchar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|+
name|cchar
operator|<
sizeof|sizeof
argument_list|(
name|abbuf
argument_list|)
condition|)
name|strcat
argument_list|(
name|abbuf
argument_list|,
name|abchar
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|cchar
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|sprintf
argument_list|(
name|abbuf
argument_list|,
literal|"%s [unprintable type]"
argument_list|,
name|q
operator|->
name|uuconf_zcmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ucuputs
argument_list|(
name|abbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subcommands.  These are commands that begin with ~%.  */
end_comment

begin_comment
comment|/* This variable is only used so that we can pass a non-NULL address    in pvar.  It is never assigned to or examined.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bCutype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command table for the subcommands.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|icubreak
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icudebug
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icuchdir
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icuput
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icutake
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icunostop
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uuconf_cmdtab
name|asCucmds
index|[]
init|=
block|{
block|{
literal|"break"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|1
block|,
name|NULL
block|,
name|icubreak
block|}
block|,
block|{
literal|"b"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|1
block|,
name|NULL
block|,
name|icubreak
block|}
block|,
block|{
literal|"cd"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|icuchdir
block|}
block|,
block|{
literal|"d"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|1
block|,
name|NULL
block|,
name|icudebug
block|}
block|,
block|{
literal|"put"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|icuput
block|}
block|,
block|{
literal|"take"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|icutake
block|}
block|,
block|{
literal|"nostop"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|1
block|,
name|NULL
block|,
name|icunostop
block|}
block|,
block|{
literal|"stop"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|1
block|,
operator|&
name|bCutype
block|,
name|icunostop
block|}
block|,
block|{
literal|">"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
operator|&
name|bCutype
block|,
name|icuput
block|}
block|,
block|{
literal|"<"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
operator|&
name|bCutype
block|,
name|icutake
block|}
block|,
block|{
literal|"p"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|icuput
block|}
block|,
block|{
literal|"t"
block|,
name|UUCONF_CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|icutake
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a subcommand.  This is called by commands beginning with ~%.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcudo_subcmd
parameter_list|(
name|puuconf
parameter_list|,
name|qconn
parameter_list|,
name|zline
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
block|{
name|char
modifier|*
name|azargs
index|[
literal|3
index|]
decl_stmt|;
name|int
name|iarg
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
for|for
control|(
name|iarg
operator|=
literal|0
init|;
name|iarg
operator|<
literal|3
condition|;
name|iarg
operator|++
control|)
block|{
name|azargs
index|[
name|iarg
index|]
operator|=
name|strtok
argument_list|(
name|iarg
operator|==
literal|0
condition|?
name|zline
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|azargs
index|[
name|iarg
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|iarg
operator|==
literal|0
condition|)
block|{
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|iuuconf
operator|=
name|uuconf_cmd_args
argument_list|(
name|puuconf
argument_list|,
name|iarg
argument_list|,
name|azargs
argument_list|,
name|asCucmds
argument_list|,
operator|(
name|pointer
operator|)
name|qconn
argument_list|,
name|icuunrecogfn
argument_list|,
literal|0
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Warn about an unknown function.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icuunrecogfn
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|char
name|abescape
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
condition|)
name|sprintf
argument_list|(
name|abescape
argument_list|,
literal|"\\%03o"
argument_list|,
name|BUCHAR
argument_list|(
operator|*
name|zCuvar_escape
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|abescape
index|[
literal|0
index|]
operator|=
operator|*
name|zCuvar_escape
expr_stmt|;
name|abescape
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|uculist_fns
argument_list|(
name|abescape
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unknown (%s%%? lists choices)"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|abescape
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Send a break.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icubreak
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|sconnection
modifier|*
name|qconn
init|=
operator|(
expr|struct
name|sconnection
operator|*
operator|)
name|pinfo
decl_stmt|;
if|if
condition|(
operator|!
name|fconn_break
argument_list|(
name|qconn
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Change directories.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icuchdir
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zarg
decl_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|zarg
operator|=
name|NULL
expr_stmt|;
else|else
name|zarg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_chdir
argument_list|(
name|zarg
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Toggle debugging.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icudebug
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|iDebug
operator|!=
literal|0
condition|)
name|iDebug
operator|=
literal|0
expr_stmt|;
else|else
name|iDebug
operator|=
name|DEBUG_MAX
expr_stmt|;
else|#
directive|else
name|ucuputs
argument_list|(
literal|"[compiled without debugging]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Control whether the port does xon/xoff handshaking.  If pvar is not    NULL, this is "stop"; otherwise it is "nostop".  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icunostop
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|sconnection
modifier|*
name|qconn
init|=
operator|(
expr|struct
name|sconnection
operator|*
operator|)
name|pinfo
decl_stmt|;
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qconn
argument_list|,
name|PARITYSETTING_DEFAULT
argument_list|,
name|STRIPSETTING_DEFAULT
argument_list|,
name|pvar
operator|==
name|NULL
condition|?
name|XONXOFF_OFF
else|:
name|XONXOFF_ON
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Send a file to the remote system.  The first argument is the file    to send.  If that argument is not present, it is prompted for.  The    second argument is to file name to use on the remote system.  If    that argument is not present, the basename of the local filename is    used.  If pvar is not NULL, then this is ~>, which is used to send    a command to a non-Unix system.  We treat is the same as ~%put,    except that we assume the user has already entered the appropriate    command (for ~%put, we force ``cat>to'' to the other side).  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icuput
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|sconnection
modifier|*
name|qconn
init|=
operator|(
expr|struct
name|sconnection
operator|*
operator|)
name|pinfo
decl_stmt|;
name|char
modifier|*
name|zfrom
decl_stmt|;
name|char
modifier|*
name|zto
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
name|int
name|cline
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
name|size_t
name|cbuf
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|zfrom
operator|=
name|zbufcpy
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|zfrom
operator|=
name|zsysdep_terminal_line
argument_list|(
literal|"File to send: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfrom
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zfrom
index|[
name|strcspn
argument_list|(
name|zfrom
argument_list|,
literal|" \t\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zfrom
operator|==
literal|'\0'
condition|)
block|{
name|ubuffree
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
block|}
if|if
condition|(
name|pvar
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|zto
operator|=
name|zbufcpy
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|char
modifier|*
name|zprompt
decl_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zprompt
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"Remote file name []: "
operator|+
name|strlen
argument_list|(
name|zbase
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zprompt
argument_list|,
literal|"Remote file name [%s]: "
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zsysdep_terminal_line
argument_list|(
name|zprompt
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zprompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zto
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zto
index|[
name|strcspn
argument_list|(
name|zto
argument_list|,
literal|" \t\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zto
operator|!=
literal|'\0'
condition|)
name|ubuffree
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
else|else
block|{
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zbase
expr_stmt|;
block|}
block|}
block|}
name|e
operator|=
name|esysdep_user_fopen
argument_list|(
name|zfrom
argument_list|,
name|TRUE
argument_list|,
name|fCuvar_binary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zerrstr
decl_stmt|;
if|if
condition|(
name|pvar
operator|==
name|NULL
condition|)
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|zerrstr
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zfrom
argument_list|)
operator|+
sizeof|sizeof
expr|": "
operator|+
name|strlen
argument_list|(
name|zerrstr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"%s: %s"
argument_list|,
name|zfrom
argument_list|,
name|zerrstr
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
name|ubuffree
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
comment|/* Tell the system dependent layer to stop copying data from the      port to the terminal.  We want to read the echoes ourself.  Also      permit the local user to generate signals.  */
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|FALSE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_signals
argument_list|(
name|TRUE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
comment|/* If pvar is NULL, then we are sending a file to a Unix system.  We      send over the command "cat> TO" to prepare it to receive.  If      pvar is not NULL, the user is assumed to have set up whatever      action was needed to receive the file.  */
if|if
condition|(
name|pvar
operator|==
name|NULL
condition|)
block|{
name|boolean
name|fret
decl_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"cat> \n"
operator|+
name|strlen
argument_list|(
name|zto
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"cat> %s\n"
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|fret
operator|=
name|fcusend_buf
argument_list|(
name|qconn
argument_list|,
name|zalc
argument_list|,
name|strlen
argument_list|(
name|zalc
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|TRUE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_signals
argument_list|(
name|FALSE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
block|}
name|cline
operator|=
literal|0
expr_stmt|;
name|zbuf
operator|=
name|NULL
expr_stmt|;
name|cbuf
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
name|abbuf
index|[
literal|512
index|]
decl_stmt|;
name|size_t
name|c
decl_stmt|;
if|#
directive|if
name|USE_STDIO
if|if
condition|(
name|fCuvar_binary
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|ffileeof
argument_list|(
name|e
argument_list|)
condition|)
break|break;
name|c
operator|=
name|cfileread
argument_list|(
name|e
argument_list|,
name|abbuf
argument_list|,
sizeof|sizeof
name|abbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffileioerror
argument_list|(
name|e
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|ucuputs
argument_list|(
literal|"[file read error]"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|zbuf
operator|=
name|abbuf
expr_stmt|;
block|}
if|#
directive|if
name|USE_STDIO
else|else
block|{
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zbuf
argument_list|,
operator|&
name|cbuf
argument_list|,
name|e
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|strlen
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fCuvar_verbose
condition|)
block|{
operator|++
name|cline
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|cline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fcusend_buf
argument_list|(
name|qconn
argument_list|,
name|zbuf
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fCuvar_binary
condition|)
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|TRUE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_signals
argument_list|(
name|FALSE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
block|}
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvar
operator|==
name|NULL
condition|)
block|{
name|char
name|beof
decl_stmt|;
name|beof
operator|=
literal|'\004'
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
operator|&
name|beof
argument_list|,
literal|1
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|zCuvar_eofwrite
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
name|zCuvar_eofwrite
argument_list|,
name|strlen
argument_list|(
name|zCuvar_eofwrite
argument_list|)
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fCuvar_verbose
condition|)
name|ucuputs
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[file transfer complete]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|TRUE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_signals
argument_list|(
name|FALSE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Get a file from the remote side.  This is ~%take, or ~t, or ~<.    The first two are assumed to be taking the file from a Unix system,    so we force the command "cat FROM; echo  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|icutake
parameter_list|(
name|puuconf
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|sconnection
modifier|*
name|qconn
init|=
operator|(
expr|struct
name|sconnection
operator|*
operator|)
name|pinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|zeof
decl_stmt|;
name|char
modifier|*
name|zfrom
decl_stmt|,
modifier|*
name|zto
decl_stmt|,
modifier|*
name|zcmd
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
name|char
name|bcr
decl_stmt|;
name|size_t
name|ceoflen
decl_stmt|;
name|char
modifier|*
name|zlook
init|=
name|NULL
decl_stmt|;
name|size_t
name|ceofhave
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|zfrom
operator|=
name|zbufcpy
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|zfrom
operator|=
name|zsysdep_terminal_line
argument_list|(
literal|"Remote file to retreive: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfrom
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zfrom
index|[
name|strcspn
argument_list|(
name|zfrom
argument_list|,
literal|" \t\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zfrom
operator|==
literal|'\0'
condition|)
block|{
name|ubuffree
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|zto
operator|=
name|zbufcpy
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|char
modifier|*
name|zprompt
decl_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zprompt
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"Local file name []: "
operator|+
name|strlen
argument_list|(
name|zbase
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zprompt
argument_list|,
literal|"Local file name [%s]: "
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zsysdep_terminal_line
argument_list|(
name|zprompt
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zprompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zto
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zto
index|[
name|strcspn
argument_list|(
name|zto
argument_list|,
literal|" \t\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zto
operator|!=
literal|'\0'
condition|)
name|ubuffree
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
else|else
block|{
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zbase
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
block|{
name|zcmd
operator|=
name|zsysdep_terminal_line
argument_list|(
literal|"Remote command to execute: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd
operator|==
name|NULL
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zcmd
index|[
name|strcspn
argument_list|(
name|zcmd
argument_list|,
literal|"\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zeof
operator|=
name|zCuvar_eofread
expr_stmt|;
block|}
else|else
block|{
name|zcmd
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"cat ; echo; echo ////cuend////"
operator|+
name|strlen
argument_list|(
name|zfrom
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zcmd
argument_list|,
literal|"cat %s; echo; echo ////cuend////"
argument_list|,
name|zfrom
argument_list|)
expr_stmt|;
name|zeof
operator|=
literal|"\n////cuend////\n"
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
name|e
operator|=
name|esysdep_user_fopen
argument_list|(
name|zto
argument_list|,
name|FALSE
argument_list|,
name|fCuvar_binary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zerrstr
decl_stmt|;
name|ubuffree
argument_list|(
name|zcmd
argument_list|)
expr_stmt|;
name|zerrstr
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zto
argument_list|)
operator|+
sizeof|sizeof
expr|": "
operator|+
name|strlen
argument_list|(
name|zerrstr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|zto
argument_list|,
name|zerrstr
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|FALSE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_signals
argument_list|(
name|TRUE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
name|zcmd
argument_list|,
name|strlen
argument_list|(
name|zcmd
argument_list|)
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|bcr
operator|=
literal|'\r'
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
operator|&
name|bcr
argument_list|,
literal|1
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|ubuffree
argument_list|(
name|zcmd
argument_list|)
expr_stmt|;
comment|/* Eliminated any previously echoed data to avoid confusion.  */
name|iPrecstart
operator|=
literal|0
expr_stmt|;
name|iPrecend
operator|=
literal|0
expr_stmt|;
comment|/* If we're dealing with a Unix system, we can reliably discard the      command.  Otherwise, the command will probably wind up in the      file; too bad.  */
if|if
condition|(
name|pvar
operator|==
name|NULL
condition|)
block|{
name|int
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
name|cCuvar_timeout
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|b
operator|==
operator|-
literal|2
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|ucuputs
argument_list|(
literal|"[timed out waiting for newline]"
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
block|}
block|}
name|ceoflen
operator|=
name|strlen
argument_list|(
name|zeof
argument_list|)
expr_stmt|;
name|zlook
operator|=
name|zbufalc
argument_list|(
name|ceoflen
argument_list|)
expr_stmt|;
name|ceofhave
operator|=
literal|0
expr_stmt|;
name|ferr
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
comment|/* Make sure the signal is logged.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[file receive aborted]"
argument_list|)
expr_stmt|;
comment|/* Reset the SIGINT flag so that it does not confuse us in 	     the future.  */
name|afSignal
index|[
name|INDEXSIG_SIGINT
index|]
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|b
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
name|cCuvar_timeout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|2
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ceofhave
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|zlook
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|ceofhave
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[timed out]"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|b
operator|==
literal|'\r'
operator|&&
operator|!
name|fCuvar_binary
condition|)
continue|continue;
if|if
condition|(
name|ceoflen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cfilewrite
argument_list|(
name|e
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ferr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|zlook
index|[
name|ceofhave
index|]
operator|=
name|b
expr_stmt|;
operator|++
name|ceofhave
expr_stmt|;
if|if
condition|(
name|ceofhave
operator|==
name|ceoflen
condition|)
block|{
name|size_t
name|cmove
decl_stmt|;
name|char
modifier|*
name|zmove
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|zeof
argument_list|,
name|zlook
argument_list|,
name|ceoflen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ucuputs
argument_list|(
literal|"[file transfer complete]"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cfilewrite
argument_list|(
name|e
argument_list|,
name|zlook
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ferr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|zmove
operator|=
name|zlook
expr_stmt|;
for|for
control|(
name|cmove
operator|=
name|ceoflen
operator|-
literal|1
operator|,
name|zmove
operator|=
name|zlook
init|;
name|cmove
operator|>
literal|0
condition|;
name|cmove
operator|--
operator|,
name|zmove
operator|++
control|)
name|zmove
index|[
literal|0
index|]
operator|=
name|zmove
index|[
literal|1
index|]
expr_stmt|;
operator|--
name|ceofhave
expr_stmt|;
block|}
block|}
block|}
name|ubuffree
argument_list|(
name|zlook
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_sync
argument_list|(
name|e
argument_list|,
name|zto
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffileclose
argument_list|(
name|e
argument_list|)
condition|)
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ferr
condition|)
name|ucuputs
argument_list|(
literal|"[file write error]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_cu_copy
argument_list|(
name|TRUE
argument_list|)
operator|||
operator|!
name|fsysdep_terminal_signals
argument_list|(
name|FALSE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|ucuputs
argument_list|(
name|abCuconnected
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a buffer to the remote system.  If fCuvar_binary is FALSE,    each buffer passed in will be a single line; in this case we can    check the echoed characters and kill the line if they do not match.    This returns FALSE if an echo check fails.  If a port error    occurrs, it calls ucuabort.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcusend_buf
parameter_list|(
name|qconn
parameter_list|,
name|zbufarg
parameter_list|,
name|cbufarg
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zbufarg
decl_stmt|;
name|size_t
name|cbufarg
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zbuf
decl_stmt|;
name|size_t
name|cbuf
decl_stmt|;
name|int
name|ctries
decl_stmt|;
name|size_t
name|cbplen
decl_stmt|;
name|char
modifier|*
name|zsendbuf
decl_stmt|;
name|zbuf
operator|=
name|zbufarg
expr_stmt|;
name|cbuf
operator|=
name|cbufarg
expr_stmt|;
name|ctries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fCuvar_binary
condition|)
name|cbplen
operator|=
name|strlen
argument_list|(
name|zCuvar_binary_prefix
argument_list|)
expr_stmt|;
else|else
name|cbplen
operator|=
literal|1
expr_stmt|;
name|zsendbuf
operator|=
name|zbufalc
argument_list|(
literal|64
operator|*
operator|(
name|cbplen
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Loop while we still have characters to send.  The value of cbuf      will be reset to cbufarg if an echo failure occurs while sending      a line in non-binary mode.  */
while|while
condition|(
name|cbuf
operator|>
literal|0
condition|)
block|{
name|int
name|csend
decl_stmt|;
name|char
modifier|*
name|zput
decl_stmt|;
specifier|const
name|char
modifier|*
name|zget
decl_stmt|;
name|boolean
name|fnl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
comment|/* Make sure the signal is logged.  */
name|ubuffree
argument_list|(
name|zsendbuf
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[file send aborted]"
argument_list|)
expr_stmt|;
comment|/* Reset the SIGINT flag so that it does not confuse us in 	     the future.  */
name|afSignal
index|[
name|INDEXSIG_SIGINT
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Discard anything we've read from the port up to now, to avoid 	 confusing the echo checking.  */
name|iPrecstart
operator|=
literal|0
expr_stmt|;
name|iPrecend
operator|=
literal|0
expr_stmt|;
comment|/* Send all characters up to a newline before actually sending 	 the newline.  This makes it easier to handle the special 	 newline echo checking.  Send up to 64 characters at a time 	 before doing echo checking.  */
if|if
condition|(
operator|*
name|zbuf
operator|==
literal|'\n'
condition|)
name|csend
operator|=
literal|1
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|znl
decl_stmt|;
name|znl
operator|=
name|memchr
argument_list|(
name|zbuf
argument_list|,
literal|'\n'
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|znl
operator|==
name|NULL
condition|)
name|csend
operator|=
name|cbuf
expr_stmt|;
else|else
name|csend
operator|=
name|znl
operator|-
name|zbuf
expr_stmt|;
if|if
condition|(
name|csend
operator|>
literal|64
condition|)
name|csend
operator|=
literal|64
expr_stmt|;
block|}
comment|/* Translate this part of the buffer.  If we are not in binary 	 mode, we translate \n to \r, and ignore any nonprintable 	 characters.  */
name|zput
operator|=
name|zsendbuf
expr_stmt|;
name|fnl
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|zget
operator|=
name|zbuf
init|;
name|i
operator|<
name|csend
condition|;
name|i
operator|++
operator|,
name|zget
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|zget
argument_list|)
operator|||
operator|*
name|zget
operator|==
literal|'\t'
condition|)
operator|*
name|zput
operator|++
operator|=
operator|*
name|zget
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|zget
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|fCuvar_binary
condition|)
operator|*
name|zput
operator|++
operator|=
literal|'\n'
expr_stmt|;
else|else
operator|*
name|zput
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|fnl
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fCuvar_binary
condition|)
block|{
name|strcpy
argument_list|(
name|zput
argument_list|,
name|zCuvar_binary_prefix
argument_list|)
expr_stmt|;
name|zput
operator|+=
name|cbplen
expr_stmt|;
operator|*
name|zput
operator|++
operator|=
operator|*
name|zget
expr_stmt|;
block|}
block|}
name|zbuf
operator|+=
name|csend
expr_stmt|;
name|cbuf
operator|-=
name|csend
expr_stmt|;
if|if
condition|(
name|zput
operator|==
name|zsendbuf
condition|)
continue|continue;
comment|/* Send the data over the port.  */
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qconn
argument_list|,
name|zsendbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|zput
operator|-
name|zsendbuf
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
comment|/* We do echo checking if requested, unless we are in binary 	 mode.  Echo checking of a newline is different from checking 	 of normal characters; when we send a newline we look for 	 *zCuvar_echonl.  */
if|if
condition|(
operator|(
name|fCuvar_echocheck
operator|&&
operator|!
name|fCuvar_binary
operator|)
operator|||
operator|(
name|fnl
operator|&&
operator|*
name|zCuvar_echonl
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|long
name|iend
decl_stmt|;
name|iend
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
operator|+
operator|(
name|long
operator|)
name|cCuvar_timeout
expr_stmt|;
for|for
control|(
name|zget
operator|=
name|zsendbuf
init|;
name|zget
operator|<
name|zput
condition|;
name|zget
operator|++
control|)
block|{
name|int
name|bread
decl_stmt|;
name|int
name|bwant
decl_stmt|;
if|if
condition|(
name|fCuvar_binary
condition|?
operator|*
name|zget
operator|==
literal|'\n'
else|:
operator|*
name|zget
operator|==
literal|'\r'
condition|)
block|{
name|bwant
operator|=
operator|*
name|zCuvar_echonl
expr_stmt|;
if|if
condition|(
name|bwant
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fCuvar_echocheck
operator|||
operator|!
name|isprint
argument_list|(
operator|*
name|zget
argument_list|)
condition|)
continue|continue;
name|bwant
operator|=
operator|*
name|zget
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
comment|/* Make sure the signal is logged.  */
name|ubuffree
argument_list|(
name|zsendbuf
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[file send aborted]"
argument_list|)
expr_stmt|;
comment|/* Reset the SIGINT flag so that it does not 			 confuse us in the future.  */
name|afSignal
index|[
name|INDEXSIG_SIGINT
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bread
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
name|iend
operator|-
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bread
operator|==
operator|-
literal|2
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
comment|/* If we timed out, and we're not in binary 			 mode, we kill the line and try sending it 			 again from the beginning.  */
if|if
condition|(
operator|!
name|fCuvar_binary
operator|&&
operator|*
name|zCuvar_kill
operator|!=
literal|'\0'
condition|)
block|{
operator|++
name|ctries
expr_stmt|;
if|if
condition|(
name|ctries
operator|<
name|cCuvar_resend
condition|)
block|{
if|if
condition|(
name|fCuvar_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"R "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qconn
argument_list|,
name|zCuvar_kill
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
condition|)
name|ucuabort
argument_list|()
expr_stmt|;
name|zbuf
operator|=
name|zbufarg
expr_stmt|;
name|cbuf
operator|=
name|cbufarg
expr_stmt|;
break|break;
block|}
block|}
name|ubuffree
argument_list|(
name|zsendbuf
argument_list|)
expr_stmt|;
name|ucuputs
argument_list|(
literal|"[timed out looking for echo]"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
do|while
condition|(
name|bread
operator|!=
operator|*
name|zget
condition|)
do|;
if|if
condition|(
name|bread
operator|<
literal|0
condition|)
break|break;
block|}
block|}
block|}
name|ubuffree
argument_list|(
name|zsendbuf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

