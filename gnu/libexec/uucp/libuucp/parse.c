begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* parse.c    Parse a UUCP command string.     Copyright (C) 1991, 1992, 1993 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|parse_rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Parse a UUCP command string into an scmd structure.  This is called    by the 'g' protocol and the UNIX command file reading routines.  It    destroys the string it is passed, and the scmd string pointers are    left pointing into it.  For the convenience of the Unix work file    routines, it will parse "P" into a simple 'P' command (representing    a poll file).  It returns TRUE if the string is successfully    parsed, FALSE otherwise.  */
end_comment

begin_function
name|boolean
name|fparse_cmd
parameter_list|(
name|zcmd
parameter_list|,
name|qcmd
parameter_list|)
name|char
modifier|*
name|zcmd
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|zend
decl_stmt|;
name|z
operator|=
name|strtok
argument_list|(
name|zcmd
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|bcmd
operator|=
operator|*
name|z
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'S'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'R'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'X'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'E'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'H'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'P'
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|bgrade
operator|=
literal|'\0'
expr_stmt|;
name|qcmd
operator|->
name|pseq
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|zfrom
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|zto
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|zuser
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|zoptions
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|ztemp
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|imode
operator|=
literal|0666
expr_stmt|;
name|qcmd
operator|->
name|znotify
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|qcmd
operator|->
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|->
name|ipos
operator|=
literal|0
expr_stmt|;
comment|/* Handle hangup commands specially.  If it's just "H", return      the command 'H' to indicate a hangup request.  If it's "HY"      return 'Y' and if it's "HN" return 'N'.  */
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'H'
condition|)
block|{
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
name|qcmd
operator|->
name|bcmd
operator|=
literal|'Y'
expr_stmt|;
elseif|else
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
name|qcmd
operator|->
name|bcmd
operator|=
literal|'N'
expr_stmt|;
else|else
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'P'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zfrom
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zto
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zuser
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
operator|||
operator|*
name|z
operator|!=
literal|'-'
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zoptions
operator|=
name|z
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'X'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'R'
condition|)
block|{
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"dummy"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This may be the maximum number of bytes the remote 		 system wants to receive, if it using Taylor UUCP size 		 negotiation.  */
name|qcmd
operator|->
name|cbytes
operator|=
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
name|qcmd
operator|->
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is from an SVR4 system, and may include the 		 position at which to start sending the file.  The 		 next fields are the mode bits, the remote owner (?), 		 the remote temporary file name, and finally the 		 restart position.  */
if|if
condition|(
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
operator|!=
name|NULL
operator|&&
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
operator|!=
name|NULL
operator|&&
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|qcmd
operator|->
name|ipos
operator|=
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
name|qcmd
operator|->
name|ipos
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|ztemp
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|imode
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* As a magic special case, if the mode came out as the decimal      values 666 or 777, assume that they actually meant the octal      values.  Most systems use a leading zero, but a few do not.      Since both 666 and 777 are greater than the largest legal mode      value, which is 0777 == 511, this hack does not restrict any      legal values.  */
if|if
condition|(
name|qcmd
operator|->
name|imode
operator|==
literal|666
condition|)
name|qcmd
operator|->
name|imode
operator|=
literal|0666
expr_stmt|;
elseif|else
if|if
condition|(
name|qcmd
operator|->
name|imode
operator|==
literal|777
condition|)
name|qcmd
operator|->
name|imode
operator|=
literal|0777
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'E'
operator|&&
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|znotify
operator|=
name|z
expr_stmt|;
comment|/* SVR4 UUCP will send the string "dummy" after the notify string      but before the size.  I do not know when it sends anything other      than "dummy".  Fortunately, it doesn't really hurt to not get the      file size.  */
if|if
condition|(
name|z
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"dummy"
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|qcmd
operator|->
name|cbytes
operator|=
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
name|qcmd
operator|->
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'E'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
name|z
index|[
name|strcspn
argument_list|(
name|z
argument_list|,
literal|"\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'E'
operator|&&
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zcmd
operator|=
name|z
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

