begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* log.c    Routines to add entries to the log files.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|log_rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STDARG_H
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TM_IN_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
name|__inline__
specifier|static
name|char
modifier|*
name|zstpcpy
name|P
argument_list|(
operator|(
name|char
operator|*
name|zto
operator|,
specifier|const
name|char
operator|*
name|zfrom
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zldate_and_time
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Program name.  Set by main function.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zProgram
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Log file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zLogfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function to call when a LOG_FATAL error occurs.  */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*pfLfatal
argument_list|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Whether to go to a file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ID number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iLid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current user name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zLuser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current system name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zLsystem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current device name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zLdevice
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open log file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLlog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we have tried to open the log file.  We need this because    we don't want to keep trying to open the log file if we failed the    first time.  It can't be static because under HAVE_HDB_LOGGING we    may have to write to various different log files.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLlog_tried
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Debugging file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zLdebugfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open debugging file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've tried to open the debugging file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLdebug_tried
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Statistics file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zLstatsfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open statistics file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've tried to open the statistics file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLstats_tried
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of signals.  The elements are only set to TRUE by the    default signal handler.  They are only set to FALSE if we don't    care whether we got the signal or not.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|afSignal
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of signals to log.  The elements are only set to TRUE by    the default signal handler.  They are set to FALSE when the signal    is logged in ulog.  This means that if a signal comes in at just    the right time we won't log it (or, rather, we'll log it once    instead of twice), but that is not a catatrophe.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|afLog_signal
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag that indicates SIGHUP is worth logging.  */
end_comment

begin_decl_stmt
name|boolean
name|fLog_sighup
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal names to use when logging signals.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|azSignal_names
index|[
name|INDEXSIG_COUNT
index|]
init|=
name|INDEXSIG_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If not NULL, ulog calls this function before outputting anything.    This is used to support cu.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*pfLstart
argument_list|)
end_macro

begin_expr_stmt
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If not NULL, ulog calls this function after outputting everything.    This is used to support cu.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*pfLend
argument_list|)
end_macro

begin_expr_stmt
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Set the function to call on a LOG_FATAL error.  */
end_comment

begin_function_decl
name|void
name|ulog_fatal_fn
parameter_list|(
name|pfn
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*pfn
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|pfLfatal
operator|=
name|pfn
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Decide whether to send log message to the file or not.  */
end_comment

begin_function
name|void
name|ulog_to_file
parameter_list|(
name|puuconf
parameter_list|,
name|ffile
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|boolean
name|ffile
decl_stmt|;
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_logfile
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zLogfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iuuconf
operator|=
name|uuconf_debugfile
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zLdebugfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iuuconf
operator|=
name|uuconf_statsfile
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zLstatsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|fLfile
operator|=
name|ffile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the ID number.  This will be called by the usysdep_initialize    if there is something sensible to set it to.  */
end_comment

begin_function
name|void
name|ulog_id
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|iLid
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the user we are making log entries for.  The arguments will be    copied into memory.  */
end_comment

begin_function
name|void
name|ulog_user
parameter_list|(
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
name|ubuffree
argument_list|(
name|zLuser
argument_list|)
expr_stmt|;
name|zLuser
operator|=
name|zbufcpy
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the system name we are making log entries for.  The name is copied    into memory.  */
end_comment

begin_function
name|void
name|ulog_system
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
if|if
condition|(
name|zsystem
operator|==
name|NULL
operator|||
name|zLsystem
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|zLsystem
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ubuffree
argument_list|(
name|zLsystem
argument_list|)
expr_stmt|;
name|zLsystem
operator|=
name|zbufcpy
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_HDB_LOGGING
comment|/* Under HDB logging we now must write to a different log file.  */
name|ulog_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
block|}
block|}
end_function

begin_comment
comment|/* Set the device name.  This is copied into memory.  */
end_comment

begin_function
name|void
name|ulog_device
parameter_list|(
name|zdevice
parameter_list|)
specifier|const
name|char
modifier|*
name|zdevice
decl_stmt|;
block|{
name|ubuffree
argument_list|(
name|zLdevice
argument_list|)
expr_stmt|;
name|zLdevice
operator|=
name|zbufcpy
argument_list|(
name|zdevice
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A helper function for ulog.  */
end_comment

begin_function
name|__inline__
specifier|static
name|char
modifier|*
name|zstpcpy
parameter_list|(
name|zto
parameter_list|,
name|zfrom
parameter_list|)
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
return|return
name|zto
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make a log entry.  We make a token concession to non ANSI_C systems,    but it clearly won't always work.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_PROTOTYPES
operator|||
operator|!
name|HAVE_STDARG_H
end_if

begin_undef
undef|#
directive|undef
name|HAVE_VFPRINTF
end_undef

begin_define
define|#
directive|define
name|HAVE_VFPRINTF
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS2*/
end_comment

begin_if
if|#
directive|if
name|HAVE_VFPRINTF
end_if

begin_decl_stmt
name|void
name|ulog
argument_list|(
expr|enum
name|tlog
name|ttype
argument_list|,
specifier|const
name|char
operator|*
name|zmsg
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|void
name|ulog
argument_list|(
name|ttype
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
decl|enum
name|tlog
name|ttype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zmsg
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|#
directive|if
name|HAVE_VFPRINTF
name|va_list
name|parg
decl_stmt|;
endif|#
directive|endif
name|FILE
modifier|*
name|e
decl_stmt|,
modifier|*
name|edebug
decl_stmt|;
name|boolean
name|fstart
decl_stmt|,
name|fend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhdr
decl_stmt|;
name|char
modifier|*
name|zprefix
decl_stmt|;
specifier|register
name|char
modifier|*
name|zset
decl_stmt|;
name|char
modifier|*
name|zformat
decl_stmt|;
name|char
modifier|*
name|zfrom
decl_stmt|;
comment|/* Log any received signal.  We do it this way to avoid calling ulog      from the signal handler.  A few routines call ulog to get this      message out with zmsg == NULL.  */
block|{
specifier|static
name|boolean
name|fdoing_sigs
decl_stmt|;
if|if
condition|(
operator|!
name|fdoing_sigs
condition|)
block|{
name|int
name|isig
decl_stmt|;
name|fdoing_sigs
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|isig
operator|=
literal|0
init|;
name|isig
operator|<
name|INDEXSIG_COUNT
condition|;
name|isig
operator|++
control|)
block|{
if|if
condition|(
name|afLog_signal
index|[
name|isig
index|]
condition|)
block|{
name|afLog_signal
index|[
name|isig
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* Apparently SunOS sends SIGINT rather than SIGHUP 		   when hanging up, so we don't log either signal if 		   fLog_sighup is FALSE.  */
if|if
condition|(
operator|(
name|isig
operator|!=
name|INDEXSIG_SIGHUP
operator|&&
name|isig
operator|!=
name|INDEXSIG_SIGINT
operator|)
operator|||
name|fLog_sighup
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got %s signal"
argument_list|,
name|azSignal_names
index|[
name|isig
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fdoing_sigs
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* If we've had a debugging file open in the past, then we want to      write all log file entries to the debugging file even if it's      currently closed.  */
if|if
condition|(
name|fLfile
operator|&&
name|eLdebug
operator|==
name|NULL
operator|&&
operator|!
name|fLdebug_tried
operator|&&
name|iDebug
operator|!=
literal|0
condition|)
block|{
name|fLdebug_tried
operator|=
name|TRUE
expr_stmt|;
name|eLdebug
operator|=
name|esysdep_fopen
argument_list|(
name|zLdebugfile
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG> 1 */
if|if
condition|(
operator|!
name|fLfile
condition|)
name|e
operator|=
name|stderr
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|ttype
operator|>=
operator|(
name|int
operator|)
name|LOG_DEBUG
condition|)
block|{
name|e
operator|=
name|eLdebug
expr_stmt|;
comment|/* If we can't open the debugging file, don't output any 	 debugging messages.  */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* DEBUG> 1 */
else|else
block|{
if|if
condition|(
name|eLlog
operator|==
name|NULL
operator|&&
operator|!
name|fLlog_tried
condition|)
block|{
specifier|const
name|char
modifier|*
name|zprint
init|=
name|NULL
decl_stmt|;
name|fLlog_tried
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_HDB_LOGGING
name|eLlog
operator|=
name|esysdep_fopen
argument_list|(
name|zLogfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|zprint
operator|=
name|zLogfile
expr_stmt|;
else|#
directive|else
comment|/* HAVE_HDB_LOGGING */
block|{
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|char
modifier|*
name|zbase
decl_stmt|;
name|char
modifier|*
name|zlower
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
comment|/* We want to write to .Log/program/system, e.g.  	 	       .Log/uucico/uunet.  The system name may not be set.  */
if|if
condition|(
name|zLsystem
operator|==
name|NULL
condition|)
name|zsys
operator|=
literal|"ANY"
expr_stmt|;
else|else
name|zsys
operator|=
name|zLsystem
expr_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|zbase
operator|=
name|zbufcpy
argument_list|(
name|zProgram
argument_list|)
expr_stmt|;
comment|/* On some systems the native uusched will invoke uucico 	       with an upper case argv[0].  We work around that by 	       forcing the filename to lower case here.  */
for|for
control|(
name|zlower
operator|=
name|zbase
init|;
operator|*
name|zlower
operator|!=
literal|'\0'
condition|;
name|zlower
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|zlower
argument_list|)
condition|)
operator|*
name|zlower
operator|=
name|tolower
argument_list|(
operator|*
name|zlower
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zLogfile
argument_list|)
operator|+
name|strlen
argument_list|(
name|zbase
argument_list|)
operator|+
name|strlen
argument_list|(
name|zsys
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfile
argument_list|,
name|zLogfile
argument_list|,
name|zbase
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|esysdep_fopen
argument_list|(
name|zfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLlog
operator|!=
name|NULL
condition|)
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
else|else
name|zprint
operator|=
name|zfile
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
if|if
condition|(
name|eLlog
operator|==
name|NULL
condition|)
block|{
comment|/* We can't open the log file.  We report the problem to 		 stderr.  This is not ideal, since if this is uucico 		 running on an inbound call stderr is actually 		 connected to a remote system, but is better than 		 doing nothing.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: can not open log file: %s\n"
argument_list|,
name|zProgram
argument_list|,
name|zprint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfLfatal
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLfatal
call|)
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|=
name|eLlog
expr_stmt|;
comment|/* eLlog might be NULL here because we might try to open the log 	 file recursively via esysdep_fopen.  */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
name|zmsg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pfLstart
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLstart
call|)
argument_list|()
expr_stmt|;
name|edebug
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
operator|(
name|int
operator|)
name|ttype
operator|<
operator|(
name|int
operator|)
name|LOG_DEBUG
condition|)
name|edebug
operator|=
name|eLdebug
expr_stmt|;
endif|#
directive|endif
name|fstart
operator|=
name|TRUE
expr_stmt|;
name|fend
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ttype
condition|)
block|{
case|case
name|LOG_NORMAL
case|:
name|zhdr
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|LOG_ERROR
case|:
name|zhdr
operator|=
literal|"ERROR: "
expr_stmt|;
break|break;
case|case
name|LOG_FATAL
case|:
name|zhdr
operator|=
literal|"FATAL: "
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|1
case|case
name|LOG_DEBUG
case|:
name|zhdr
operator|=
literal|"DEBUG: "
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_START
case|:
name|zhdr
operator|=
literal|"DEBUG: "
expr_stmt|;
name|fend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_CONTINUE
case|:
name|zhdr
operator|=
name|NULL
expr_stmt|;
name|fstart
operator|=
name|FALSE
expr_stmt|;
name|fend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_END
case|:
name|zhdr
operator|=
name|NULL
expr_stmt|;
name|fstart
operator|=
name|FALSE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|zhdr
operator|=
literal|"???: "
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fstart
condition|)
name|zprefix
operator|=
name|zbufcpy
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fLfile
condition|)
block|{
name|zprefix
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zProgram
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zprefix
argument_list|,
literal|"%s: "
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zprefix
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zProgram
argument_list|)
operator|+
operator|(
name|zLsystem
operator|==
name|NULL
condition|?
literal|1
else|:
name|strlen
argument_list|(
name|zLsystem
argument_list|)
operator|)
operator|+
operator|(
name|zLuser
operator|==
name|NULL
condition|?
literal|4
else|:
name|strlen
argument_list|(
name|zLuser
argument_list|)
operator|)
operator|+
sizeof|sizeof
expr|"1991-12-31 12:00:00.00"
operator|+
name|strlen
argument_list|(
name|zhdr
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zprefix
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|zbase
operator|=
name|zbufcpy
argument_list|(
name|zProgram
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zstpcpy
argument_list|(
name|zset
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|' '
expr_stmt|;
name|ubuffree
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_TAYLOR_LOGGING */
name|zset
operator|=
name|zstpcpy
argument_list|(
name|zset
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"uucp"
else|:
name|zLuser
argument_list|)
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
name|zset
operator|=
name|zstpcpy
argument_list|(
name|zset
argument_list|,
name|zLsystem
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLsystem
argument_list|)
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|' '
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|zset
operator|=
name|zstpcpy
argument_list|(
name|zset
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLuser
argument_list|)
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
operator|*
name|zset
operator|++
operator|=
literal|'('
expr_stmt|;
name|zset
operator|=
name|zstpcpy
argument_list|(
name|zset
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iLid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|HAVE_HDB_LOGGING
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|" %d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TAYLOR_LOGGING */
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"-%d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_LOGGING */
else|#
directive|else
comment|/* HAVE_HDB_LOGGING */
comment|/* I assume that the second number here is meant to be 		 some sort of file sequence number, and that it should 		 correspond to the sequence number in the statistics 		 file.  I don't have any really convenient way to do 		 this, so I won't unless somebody thinks it's very 		 important.  */
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|",%d,%d"
argument_list|,
name|iLid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
name|zset
operator|+=
name|strlen
argument_list|(
name|zset
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|QNX_LOG_NODE_ID
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|" %ld"
argument_list|,
operator|(
name|long
operator|)
name|getnid
argument_list|()
argument_list|)
expr_stmt|;
name|zset
operator|+=
name|strlen
argument_list|(
name|zset
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|zset
operator|++
operator|=
literal|')'
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|zset
argument_list|,
name|zhdr
argument_list|)
expr_stmt|;
block|}
block|}
name|zformat
operator|=
name|zbufalc
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|zprefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|zmsg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zformat
expr_stmt|;
name|zfrom
operator|=
name|zprefix
expr_stmt|;
while|while
condition|(
operator|*
name|zfrom
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|zfrom
operator|==
literal|'%'
condition|)
operator|*
name|zset
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
operator|*
name|zfrom
operator|++
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zprefix
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zstpcpy
argument_list|(
name|zset
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fend
condition|)
block|{
operator|*
name|zset
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|zset
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_VFPRINTF
name|va_start
argument_list|(
name|parg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|e
argument_list|,
name|zformat
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
block|{
name|va_start
argument_list|(
name|parg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|edebug
argument_list|,
name|zformat
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|parg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_VFPRINTF */
name|fprintf
argument_list|(
name|e
argument_list|,
name|zformat
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
name|zformat
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_VFPRINTF */
name|ubuffree
argument_list|(
name|zformat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|edebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfLend
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLend
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|LOG_FATAL
condition|)
block|{
if|if
condition|(
name|pfLfatal
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLfatal
call|)
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|CLOSE_LOGFILES
name|ulog_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Log a uuconf error.  */
end_comment

begin_function
name|void
name|ulog_uuconf
parameter_list|(
name|ttype
parameter_list|,
name|puuconf
parameter_list|,
name|iuuconf
parameter_list|)
name|enum
name|tlog
name|ttype
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
block|{
name|char
name|ab
index|[
literal|512
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|uuconf_error_string
argument_list|(
name|puuconf
argument_list|,
name|iuuconf
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|ttype
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the log file.  There's nothing useful we can do with errors,    so we don't check for them.  */
end_comment

begin_function
name|void
name|ulog_close
parameter_list|()
block|{
comment|/* Make sure we logged any signal we received.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLlog
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLlog
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|NULL
expr_stmt|;
name|fLlog_tried
operator|=
name|FALSE
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|eLdebug
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLdebug
argument_list|)
expr_stmt|;
name|eLdebug
operator|=
name|NULL
expr_stmt|;
name|fLdebug_tried
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an entry to the statistics file.  We may eventually want to put    failed file transfers in here, but we currently do not.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|ustats
parameter_list|(
name|fsucceeded
parameter_list|,
name|zuser
parameter_list|,
name|zsystem
parameter_list|,
name|fsent
parameter_list|,
name|cbytes
parameter_list|,
name|csecs
parameter_list|,
name|cmicros
parameter_list|,
name|fcaller
parameter_list|)
name|boolean
name|fsucceeded
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|boolean
name|fsent
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|long
name|csecs
decl_stmt|;
name|long
name|cmicros
decl_stmt|;
name|boolean
name|fcaller
decl_stmt|;
block|{
name|long
name|cbps
decl_stmt|;
comment|/* The seconds and microseconds are now counted independently, so      they may be out of synch.  */
if|if
condition|(
name|cmicros
operator|<
literal|0
condition|)
block|{
name|csecs
operator|-=
operator|(
operator|(
operator|-
name|cmicros
operator|)
operator|/
literal|1000000L
operator|)
operator|+
literal|1
expr_stmt|;
name|cmicros
operator|=
literal|1000000L
operator|-
operator|(
operator|(
operator|-
name|cmicros
operator|)
operator|%
literal|1000000L
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cmicros
operator|>=
literal|1000000L
condition|)
block|{
name|csecs
operator|+=
name|cmicros
operator|/
literal|10000000L
expr_stmt|;
name|cmicros
operator|=
name|cmicros
operator|%
literal|1000000L
expr_stmt|;
block|}
comment|/* On a system which can determine microseconds we might very well      have both csecs == 0 and cmicros == 0.  */
if|if
condition|(
name|csecs
operator|==
literal|0
operator|&&
name|cmicros
operator|<
literal|1000
condition|)
name|cbps
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|long
name|cmillis
decl_stmt|,
name|cdiv
decl_stmt|,
name|crem
decl_stmt|;
comment|/* Compute ((csecs * 1000) / cmillis) using integer division. 	 Where DIV is integer division, we know 	     a = (a DIV b) * b + a % b 	 so 	     a / b = (a DIV b) + (a % b) / b 	 We compute the latter with a as csecs and b as cmillis, 	 mixing the multiplication by 1000.  */
name|cmillis
operator|=
name|csecs
operator|*
literal|1000
operator|+
name|cmicros
operator|/
literal|1000
expr_stmt|;
name|cdiv
operator|=
operator|(
name|cbytes
operator|/
name|cmillis
operator|)
operator|*
literal|1000
expr_stmt|;
name|crem
operator|=
operator|(
name|cbytes
operator|%
name|cmillis
operator|)
operator|*
literal|1000
expr_stmt|;
name|cbps
operator|=
name|cdiv
operator|+
operator|(
name|crem
operator|/
name|cmillis
operator|)
expr_stmt|;
if|if
condition|(
name|cmillis
operator|<
literal|0
operator|||
name|cdiv
operator|<
literal|0
operator|||
name|crem
operator|<
literal|0
operator|||
name|cbps
operator|<
literal|0
condition|)
block|{
comment|/* We overflowed using milliseconds, so use seconds.  */
name|cbps
operator|=
name|cbytes
operator|/
operator|(
name|csecs
operator|+
operator|(
operator|(
name|cmicros
operator|>
literal|500000L
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eLstats
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fLstats_tried
condition|)
return|return;
name|fLstats_tried
operator|=
name|TRUE
expr_stmt|;
name|eLstats
operator|=
name|esysdep_fopen
argument_list|(
name|zLstatsfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLstats
operator|==
name|NULL
condition|)
return|return;
block|}
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s %s (%s) %s%s %ld bytes in %ld.%03ld seconds (%ld bytes/sec) on port %s\n"
argument_list|,
name|zuser
argument_list|,
name|zsystem
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
name|fsucceeded
condition|?
literal|""
else|:
literal|"failed after "
argument_list|,
name|fsent
condition|?
literal|"sent"
else|:
literal|"received"
argument_list|,
name|cbytes
argument_list|,
name|csecs
argument_list|,
name|cmicros
operator|/
literal|1000
argument_list|,
name|cbps
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
if|#
directive|if
name|HAVE_V2_LOGGING
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s %s (%s) (%ld) %s %s %ld bytes %ld seconds\n"
argument_list|,
name|zuser
argument_list|,
name|zsystem
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fsent
condition|?
literal|"sent"
else|:
literal|"received"
argument_list|,
name|fsucceeded
condition|?
literal|"data"
else|:
literal|"failed after"
argument_list|,
name|cbytes
argument_list|,
name|csecs
operator|+
name|cmicros
operator|/
literal|500000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
if|#
directive|if
name|HAVE_HDB_LOGGING
block|{
specifier|static
name|int
name|iseq
decl_stmt|;
comment|/* I don't know what the 'C' means.  The sequence number should        probably correspond to the sequence number in the log file, but        that is currently always 0; using this fake sequence number        will still at least reveal which transfers are from different        calls.  */
operator|++
name|iseq
expr_stmt|;
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s!%s %c (%s) (C,%d,%d) [%s] %s %ld / %ld.%03ld secs, %ld%s%s\n"
argument_list|,
name|zsystem
argument_list|,
name|zuser
argument_list|,
name|fcaller
condition|?
literal|'M'
else|:
literal|'S'
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
name|iLid
argument_list|,
name|iseq
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|,
name|fsent
condition|?
literal|"->"
else|:
literal|"<-"
argument_list|,
name|cbytes
argument_list|,
name|csecs
argument_list|,
name|cmicros
operator|/
literal|1000
argument_list|,
name|cbps
argument_list|,
literal|" bytes/sec"
argument_list|,
name|fsucceeded
condition|?
literal|""
else|:
literal|" [PARTIAL FILE]"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|eLstats
argument_list|)
expr_stmt|;
if|#
directive|if
name|CLOSE_LOGFILES
name|ustats_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Close the statistics file.  */
end_comment

begin_function
name|void
name|ustats_close
parameter_list|()
block|{
if|if
condition|(
name|eLstats
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|eLstats
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|eLstats
operator|=
name|NULL
expr_stmt|;
name|fLstats_tried
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the date and time in a form used for a log entry.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zldate_and_time
parameter_list|()
block|{
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
name|struct
name|tm
name|s
decl_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"1991-12-31 12:00:00.00"]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V2_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"12/31-12:00"]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_HDB_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"12/31-12:00:00"]
expr_stmt|;
endif|#
directive|endif
name|isecs
operator|=
name|ixsysdep_time
argument_list|(
operator|&
name|imicros
argument_list|)
expr_stmt|;
name|usysdep_localtime
argument_list|(
name|isecs
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02d.%02d"
argument_list|,
name|s
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|,
name|s
operator|.
name|tm_sec
argument_list|,
call|(
name|int
call|)
argument_list|(
name|imicros
operator|/
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V2_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%d/%d-%02d:%02d"
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_HDB_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%d/%d-%d:%02d:%02d"
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|,
name|s
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ab
return|;
block|}
end_function

end_unit

