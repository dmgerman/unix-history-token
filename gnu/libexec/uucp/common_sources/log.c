begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* log.c    Routines to add entries to the log files.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o Infinity Development Systems, P.O. Box 520, Waltham, MA 02254.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|log_rcsid
index|[]
init|=
literal|"$Id: log.c,v 1.1 1993/08/04 19:30:50 jtc Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|ANSI_C
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zldate_and_time
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Log file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zLogfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function to call when a LOG_FATAL error occurs.  */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*pfLfatal
argument_list|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Whether to go to a file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ID number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iLid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current user name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zLuser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current system name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zLsystem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current device name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zLdevice
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open log file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLlog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we have tried to open the log file.  We need this because    we don't want to keep trying to open the log file if we failed the    first time.  It can't be static because under HAVE_HDB_LOGGING we    may have to write to various different log files.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLlog_tried
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Debugging file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zLdebugfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open debugging file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've tried to open the debugging file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLdebug_tried
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've written out any debugging information.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLdebugging
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Statistics file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zLstatsfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open statistics file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've tried to open the statistics file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLstats_tried
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of signals.  The elements are only set to TRUE by the    default signal handler.  They are only set to FALSE if we don't    care whether we got the signal or not.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|afSignal
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of signals to log.  The elements are only set to TRUE by    the default signal handler.  They are set to FALSE when the signal    is logged in ulog.  This means that if a signal comes in at just    the right time we won't log it (or, rather, we'll log it once    instead of twice), but that is not a catatrophe.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|afLog_signal
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag that indicates SIGHUP is worth logging.  */
end_comment

begin_decl_stmt
name|boolean
name|fLog_sighup
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal names to use when logging signals.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|azSignal_names
index|[
name|INDEXSIG_COUNT
index|]
init|=
name|INDEXSIG_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If not NULL, ulog calls this function before outputting anything.    This is used to support cu.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*pfLstart
argument_list|)
end_macro

begin_expr_stmt
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If not NULL, ulog calls this function after outputting everything.    This is used to support cu.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*pfLend
argument_list|)
end_macro

begin_expr_stmt
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Set the function to call on a LOG_FATAL error.  */
end_comment

begin_function_decl
name|void
name|ulog_fatal_fn
parameter_list|(
name|pfn
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*pfn
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|pfLfatal
operator|=
name|pfn
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Decide whether to send log message to the file or not.  */
end_comment

begin_function
name|void
name|ulog_to_file
parameter_list|(
name|puuconf
parameter_list|,
name|ffile
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|boolean
name|ffile
decl_stmt|;
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_logfile
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zLogfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iuuconf
operator|=
name|uuconf_debugfile
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zLdebugfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iuuconf
operator|=
name|uuconf_statsfile
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zLstatsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|fLfile
operator|=
name|ffile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the ID number.  This will be called by the usysdep_initialize    if there is something sensible to set it to.  */
end_comment

begin_function
name|void
name|ulog_id
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|iLid
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the user we are making log entries for.  The arguments will be    copied into memory.  */
end_comment

begin_function
name|void
name|ulog_user
parameter_list|(
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
name|ubuffree
argument_list|(
name|zLuser
argument_list|)
expr_stmt|;
name|zLuser
operator|=
name|zbufcpy
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the system name we are making log entries for.  The name is copied    into memory.  */
end_comment

begin_function
name|void
name|ulog_system
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
if|if
condition|(
name|zsystem
operator|==
name|NULL
operator|||
name|zLsystem
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|zLsystem
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ubuffree
argument_list|(
name|zLsystem
argument_list|)
expr_stmt|;
name|zLsystem
operator|=
name|zbufcpy
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_HDB_LOGGING
comment|/* Under HDB logging we now must write to a different log file.  */
name|ulog_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
block|}
block|}
end_function

begin_comment
comment|/* Set the device name.  This is copied into memory.  */
end_comment

begin_function
name|void
name|ulog_device
parameter_list|(
name|zdevice
parameter_list|)
specifier|const
name|char
modifier|*
name|zdevice
decl_stmt|;
block|{
name|ubuffree
argument_list|(
name|zLdevice
argument_list|)
expr_stmt|;
name|zLdevice
operator|=
name|zbufcpy
argument_list|(
name|zdevice
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a log entry.  We make a token concession to non ANSI_C systems,    but it clearly won't always work.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|ANSI_C
end_if

begin_undef
undef|#
directive|undef
name|HAVE_VFPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS2*/
end_comment

begin_if
if|#
directive|if
name|HAVE_VFPRINTF
end_if

begin_decl_stmt
name|void
name|ulog
argument_list|(
expr|enum
name|tlog
name|ttype
argument_list|,
specifier|const
name|char
operator|*
name|zmsg
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|void
name|ulog
argument_list|(
name|ttype
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
decl|enum
name|tlog
name|ttype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zmsg
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|#
directive|if
name|HAVE_VFPRINTF
name|va_list
name|parg
decl_stmt|;
endif|#
directive|endif
name|FILE
modifier|*
name|e
decl_stmt|,
modifier|*
name|edebug
decl_stmt|;
name|boolean
name|fstart
decl_stmt|,
name|fend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhdr
decl_stmt|,
modifier|*
name|zstr
decl_stmt|;
comment|/* Log any received signal.  We do it this way to avoid calling ulog      from the signal handler.  A few routines call ulog to get this      message out with zmsg == NULL.  */
block|{
specifier|static
name|boolean
name|fdoing_sigs
decl_stmt|;
if|if
condition|(
operator|!
name|fdoing_sigs
condition|)
block|{
name|int
name|isig
decl_stmt|;
name|fdoing_sigs
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|isig
operator|=
literal|0
init|;
name|isig
operator|<
name|INDEXSIG_COUNT
condition|;
name|isig
operator|++
control|)
block|{
if|if
condition|(
name|afLog_signal
index|[
name|isig
index|]
condition|)
block|{
name|afLog_signal
index|[
name|isig
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* Apparently SunOS sends SIGINT rather than SIGHUP 		   when hanging up, so we don't log either signal if 		   fLog_sighup is FALSE.  */
if|if
condition|(
operator|(
name|isig
operator|!=
name|INDEXSIG_SIGHUP
operator|&&
name|isig
operator|!=
name|INDEXSIG_SIGINT
operator|)
operator|||
name|fLog_sighup
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got %s signal"
argument_list|,
name|azSignal_names
index|[
name|isig
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fdoing_sigs
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zmsg
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* If we've had a debugging file open in the past, then we want to      write all log file entries to the debugging file even if it's      currently closed.  */
if|if
condition|(
name|fLfile
operator|&&
name|eLdebug
operator|==
name|NULL
operator|&&
operator|!
name|fLdebug_tried
operator|&&
operator|(
name|fLdebugging
operator|||
operator|(
name|int
operator|)
name|ttype
operator|>=
operator|(
name|int
operator|)
name|LOG_DEBUG
operator|)
condition|)
block|{
name|fLdebug_tried
operator|=
name|TRUE
expr_stmt|;
name|eLdebug
operator|=
name|esysdep_fopen
argument_list|(
name|zLdebugfile
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fLdebugging
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG> 1 */
if|if
condition|(
operator|!
name|fLfile
condition|)
name|e
operator|=
name|stderr
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|ttype
operator|>=
operator|(
name|int
operator|)
name|LOG_DEBUG
condition|)
block|{
name|e
operator|=
name|eLdebug
expr_stmt|;
comment|/* If we can't open the debugging file, don't output any 	 debugging messages.  */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* DEBUG> 1 */
else|else
block|{
if|if
condition|(
name|eLlog
operator|==
name|NULL
operator|&&
operator|!
name|fLlog_tried
condition|)
block|{
name|fLlog_tried
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_HDB_LOGGING
name|eLlog
operator|=
name|esysdep_fopen
argument_list|(
name|zLogfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_HDB_LOGGING */
block|{
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
comment|/* We want to write to .Log/program/system, e.g.  	 	       .Log/uucico/uunet.  The system name may not be set.  */
if|if
condition|(
name|zLsystem
operator|==
name|NULL
condition|)
name|zsys
operator|=
literal|"ANY"
expr_stmt|;
else|else
name|zsys
operator|=
name|zLsystem
expr_stmt|;
name|zfile
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zLogfile
argument_list|)
operator|+
name|strlen
argument_list|(
name|abProgram
argument_list|)
operator|+
name|strlen
argument_list|(
name|zsys
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfile
argument_list|,
name|zLogfile
argument_list|,
name|abProgram
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|esysdep_fopen
argument_list|(
name|zfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
if|if
condition|(
name|eLlog
operator|==
name|NULL
condition|)
block|{
comment|/* We can't open the log file.  We don't even have a 		 safe way to report this problem, since we may not be 		 able to write to stderr (it may, for example, be 		 attached to the incoming call).  */
if|if
condition|(
name|pfLfatal
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLfatal
call|)
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|=
name|eLlog
expr_stmt|;
comment|/* eLlog might be NULL here because we might try to open the log 	 file recursively via esysdep_fopen.  */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
name|pfLstart
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLstart
call|)
argument_list|()
expr_stmt|;
name|edebug
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
operator|(
name|int
operator|)
name|ttype
operator|<
operator|(
name|int
operator|)
name|LOG_DEBUG
condition|)
name|edebug
operator|=
name|eLdebug
expr_stmt|;
endif|#
directive|endif
name|fstart
operator|=
name|TRUE
expr_stmt|;
name|fend
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ttype
condition|)
block|{
case|case
name|LOG_NORMAL
case|:
name|zhdr
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|LOG_ERROR
case|:
name|zhdr
operator|=
literal|"ERROR: "
expr_stmt|;
break|break;
case|case
name|LOG_FATAL
case|:
name|zhdr
operator|=
literal|"FATAL: "
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|1
case|case
name|LOG_DEBUG
case|:
name|zhdr
operator|=
literal|"DEBUG: "
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_START
case|:
name|zhdr
operator|=
literal|"DEBUG: "
expr_stmt|;
name|fend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_CONTINUE
case|:
name|zhdr
operator|=
name|NULL
expr_stmt|;
name|fstart
operator|=
name|FALSE
expr_stmt|;
name|fend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_END
case|:
name|zhdr
operator|=
name|NULL
expr_stmt|;
name|fstart
operator|=
name|FALSE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|zhdr
operator|=
literal|"???: "
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fstart
condition|)
block|{
if|if
condition|(
operator|!
name|fLfile
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s: "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s: "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TAYLOR_LOGGING */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"uucp"
else|:
name|zLuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"uucp"
else|:
name|zLuser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|zLsystem
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLsystem
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|zLsystem
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLuser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
name|zstr
operator|=
name|zldate_and_time
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"(%s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"(%s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|iLid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|HAVE_HDB_LOGGING
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" %d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|" %d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TAYLOR_LOGGING */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"-%d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"-%d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_LOGGING */
else|#
directive|else
comment|/* HAVE_HDB_LOGGING */
comment|/* I assume that the second number here is meant to be 		 some sort of file sequence number, and that it should 		 correspond to the sequence number in the statistics 		 file.  I don't have any really convenient way to do 		 this, so I won't unless somebody thinks it's very 		 important.  */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|",%d,%d"
argument_list|,
name|iLid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|",%d,%d"
argument_list|,
name|iLid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|zhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s"
argument_list|,
name|zhdr
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HAVE_VFPRINTF
name|va_start
argument_list|(
name|parg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|e
argument_list|,
name|zmsg
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
block|{
name|va_start
argument_list|(
name|parg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|edebug
argument_list|,
name|zmsg
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|parg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_VFPRINTF */
name|fprintf
argument_list|(
name|e
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_VFPRINTF */
if|if
condition|(
name|fend
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|edebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfLend
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLend
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|LOG_FATAL
condition|)
block|{
if|if
condition|(
name|pfLfatal
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfLfatal
call|)
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|CLOSE_LOGFILES
name|ulog_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Log a uuconf error.  */
end_comment

begin_function
name|void
name|ulog_uuconf
parameter_list|(
name|ttype
parameter_list|,
name|puuconf
parameter_list|,
name|iuuconf
parameter_list|)
name|enum
name|tlog
name|ttype
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
block|{
name|char
name|ab
index|[
literal|512
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|uuconf_error_string
argument_list|(
name|puuconf
argument_list|,
name|iuuconf
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|ttype
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the log file.  There's nothing useful we can do with errors,    so we don't check for them.  */
end_comment

begin_function
name|void
name|ulog_close
parameter_list|()
block|{
comment|/* Make sure we logged any signal we received.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLlog
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLlog
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|NULL
expr_stmt|;
name|fLlog_tried
operator|=
name|FALSE
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|eLdebug
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLdebug
argument_list|)
expr_stmt|;
name|eLdebug
operator|=
name|NULL
expr_stmt|;
name|fLdebug_tried
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an entry to the statistics file.  We may eventually want to put    failed file transfers in here, but we currently do not.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|ustats
parameter_list|(
name|fsucceeded
parameter_list|,
name|zuser
parameter_list|,
name|zsystem
parameter_list|,
name|fsent
parameter_list|,
name|cbytes
parameter_list|,
name|csecs
parameter_list|,
name|cmicros
parameter_list|,
name|fmaster
parameter_list|)
name|boolean
name|fsucceeded
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|boolean
name|fsent
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|long
name|csecs
decl_stmt|;
name|long
name|cmicros
decl_stmt|;
name|boolean
name|fmaster
decl_stmt|;
block|{
name|long
name|cbps
decl_stmt|;
comment|/* The seconds and microseconds are now counted independently, so      they may be out of synch.  */
if|if
condition|(
name|cmicros
operator|<
literal|0
condition|)
block|{
name|csecs
operator|-=
operator|(
operator|(
operator|-
name|cmicros
operator|)
operator|/
literal|1000000L
operator|)
operator|+
literal|1
expr_stmt|;
name|cmicros
operator|=
literal|1000000L
operator|-
operator|(
operator|(
operator|-
name|cmicros
operator|)
operator|%
literal|1000000L
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cmicros
operator|>=
literal|1000000L
condition|)
block|{
name|csecs
operator|+=
name|cmicros
operator|/
literal|10000000L
expr_stmt|;
name|cmicros
operator|=
name|cmicros
operator|%
literal|1000000L
expr_stmt|;
block|}
comment|/* On a system which can determine microseconds we might very well      have both csecs == 0 and cmicros == 0.  */
if|if
condition|(
name|csecs
operator|==
literal|0
operator|&&
name|cmicros
operator|<
literal|1000
condition|)
name|cbps
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|long
name|cmillis
decl_stmt|;
comment|/* This computation will not overflow provided csecs< 2147483 	 and cbytes and cbps both fit in a long.  */
name|cmillis
operator|=
name|csecs
operator|*
literal|1000
operator|+
name|cmicros
operator|/
literal|1000
expr_stmt|;
name|cbps
operator|=
operator|(
operator|(
name|cbytes
operator|/
name|cmillis
operator|)
operator|*
literal|1000
operator|+
operator|(
operator|(
name|cbytes
operator|%
name|cmillis
operator|)
operator|*
literal|1000
operator|)
operator|/
name|cmillis
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|eLstats
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fLstats_tried
condition|)
return|return;
name|fLstats_tried
operator|=
name|TRUE
expr_stmt|;
name|eLstats
operator|=
name|esysdep_fopen
argument_list|(
name|zLstatsfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLstats
operator|==
name|NULL
condition|)
return|return;
block|}
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s %s (%s) %s%s %ld bytes in %ld.%03ld seconds (%ld bytes/sec)\n"
argument_list|,
name|zuser
argument_list|,
name|zsystem
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
name|fsucceeded
condition|?
literal|""
else|:
literal|"failed after "
argument_list|,
name|fsent
condition|?
literal|"sent"
else|:
literal|"received"
argument_list|,
name|cbytes
argument_list|,
name|csecs
argument_list|,
name|cmicros
operator|/
literal|1000
argument_list|,
name|cbps
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
if|#
directive|if
name|HAVE_V2_LOGGING
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s %s (%s) (%ld) %s %s %ld bytes %ld seconds\n"
argument_list|,
name|zuser
argument_list|,
name|zsystem
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fsent
condition|?
literal|"sent"
else|:
literal|"received"
argument_list|,
name|fsucceeded
condition|?
literal|"data"
else|:
literal|"failed after"
argument_list|,
name|cbytes
argument_list|,
name|csecs
operator|+
name|cmicros
operator|/
literal|500000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
if|#
directive|if
name|HAVE_HDB_LOGGING
block|{
specifier|static
name|int
name|iseq
decl_stmt|;
comment|/* I don't know what the 'C' means.  The sequence number should        probably correspond to the sequence number in the log file, but        that is currently always 0; using this fake sequence number        will still at least reveal which transfers are from different        calls.  We don't report a failed data transfer with this        format.  */
if|if
condition|(
operator|!
name|fsucceeded
condition|)
return|return;
operator|++
name|iseq
expr_stmt|;
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s!%s %c (%s) (C,%d,%d) [%s] %s %ld / %ld.%03ld secs, %ld %s\n"
argument_list|,
name|zsystem
argument_list|,
name|zuser
argument_list|,
name|fmaster
condition|?
literal|'M'
else|:
literal|'S'
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
name|iLid
argument_list|,
name|iseq
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|,
name|fsent
condition|?
literal|"->"
else|:
literal|"<-"
argument_list|,
name|cbytes
argument_list|,
name|csecs
argument_list|,
name|cmicros
operator|/
literal|1000
argument_list|,
name|cbps
argument_list|,
literal|"bytes/sec"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_HDB_LOGGING */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|eLstats
argument_list|)
expr_stmt|;
if|#
directive|if
name|CLOSE_LOGFILES
name|ustats_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Close the statistics file.  */
end_comment

begin_function
name|void
name|ustats_close
parameter_list|()
block|{
if|if
condition|(
name|eLstats
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|eLstats
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|eLstats
operator|=
name|NULL
expr_stmt|;
name|fLstats_tried
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the date and time in a form used for a log entry.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zldate_and_time
parameter_list|()
block|{
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
name|struct
name|tm
name|s
decl_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"1991-12-31 12:00:00.00"]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V2_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"12/31-12:00"]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_HDB_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"12/31-12:00:00"]
expr_stmt|;
endif|#
directive|endif
name|isecs
operator|=
name|ixsysdep_time
argument_list|(
operator|&
name|imicros
argument_list|)
expr_stmt|;
name|usysdep_localtime
argument_list|(
name|isecs
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02d.%02d"
argument_list|,
name|s
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|,
name|s
operator|.
name|tm_sec
argument_list|,
call|(
name|int
call|)
argument_list|(
name|imicros
operator|/
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V2_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%d/%d-%02d:%02d"
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_HDB_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%d/%d-%02d:%02d:%02d"
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|,
name|s
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ab
return|;
block|}
end_function

end_unit

