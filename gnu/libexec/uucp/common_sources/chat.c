begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* chat.c    Chat routine for the UUCP package.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|chat_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|icexpect
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|int
name|cstrings
operator|,
name|char
operator|*
operator|*
name|azstrings
operator|,
name|size_t
operator|*
name|aclens
operator|,
name|int
name|ctimeout
operator|,
name|boolean
name|fstrip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcsend
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
specifier|const
name|char
operator|*
name|zsend
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|uuconf_dialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
name|boolean
name|ftranslate
operator|,
name|boolean
name|fstrip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcecho_send_strip
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|z
operator|,
name|size_t
name|clen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcecho_send_nostrip
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|z
operator|,
name|size_t
name|clen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcecho_send
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|z
operator|,
name|size_t
name|clen
operator|,
name|boolean
name|fstrip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcphone
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
specifier|const
expr|struct
name|uuconf_dialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
name|boolean
argument_list|(
argument|*pfwrite
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qc
operator|,
specifier|const
name|char
operator|*
name|zwrite
operator|,
name|size_t
name|cwrite
operator|)
argument_list|)
operator|,
name|boolean
name|ftranslate
operator|,
name|boolean
operator|*
name|pfquote
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fctranslate
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
specifier|const
name|char
operator|*
operator|*
name|pzprefix
operator|,
specifier|const
name|char
operator|*
operator|*
name|pzsuffix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcprogram
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
name|char
operator|*
operator|*
name|pzprogram
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|uuconf_dialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
specifier|const
name|char
operator|*
name|zport
operator|,
name|long
name|ibaud
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Run a chat script with the other system.  The chat script is a    series of expect send pairs.  We wait for the expect string to show    up, and then we send the send string.  The chat string for a system    holds the expect and send strings separated by a single space.  */
end_comment

begin_function
name|boolean
name|fchat
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qchat
parameter_list|,
name|qsys
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|ftranslate
parameter_list|,
name|zport
parameter_list|,
name|ibaud
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_chat
modifier|*
name|qchat
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|uuconf_dialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|boolean
name|ftranslate
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
block|{
name|int
name|cstrings
decl_stmt|;
name|char
modifier|*
modifier|*
name|azstrings
decl_stmt|;
name|size_t
modifier|*
name|aclens
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzchat
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
name|size_t
name|cbuflen
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First run the program, if any.  */
if|if
condition|(
name|qchat
operator|->
name|uuconf_pzprogram
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fcprogram
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|qchat
operator|->
name|uuconf_pzprogram
argument_list|,
name|qsys
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|zport
argument_list|,
name|ibaud
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If there's no chat script, we're done.  */
if|if
condition|(
name|qchat
operator|->
name|uuconf_pzchat
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|qchat
operator|->
name|uuconf_pzfail
operator|==
name|NULL
condition|)
block|{
name|cstrings
operator|=
literal|1
expr_stmt|;
name|azstrings
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|aclens
operator|=
operator|(
name|size_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
comment|/* We leave string number 0 for the chat script.  */
name|cstrings
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|qchat
operator|->
name|uuconf_pzfail
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
operator|++
name|cstrings
expr_stmt|;
name|azstrings
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cstrings
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|aclens
operator|=
operator|(
name|size_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|cstrings
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the strings into the array, and handle all the escape 	 characters.  */
for|for
control|(
name|cstrings
operator|=
literal|1
operator|,
name|pz
operator|=
name|qchat
operator|->
name|uuconf_pzfail
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|cstrings
operator|++
operator|,
name|pz
operator|++
control|)
block|{
name|azstrings
index|[
name|cstrings
index|]
operator|=
name|zbufcpy
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
name|aclens
index|[
name|cstrings
index|]
operator|=
name|cescape
argument_list|(
name|azstrings
index|[
name|cstrings
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|cbuflen
operator|=
literal|0
expr_stmt|;
name|zbuf
operator|=
name|NULL
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
name|pzchat
operator|=
name|qchat
operator|->
name|uuconf_pzchat
expr_stmt|;
while|while
condition|(
operator|*
name|pzchat
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
comment|/* Loop over subexpects and subsends.  */
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|ztimeout
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
comment|/* Copy the expect string into the buffer so that we can 	     modify it in cescape.  */
name|clen
operator|=
name|strlen
argument_list|(
operator|*
name|pzchat
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>=
name|cbuflen
condition|)
block|{
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
name|zbuf
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cbuflen
operator|=
name|clen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zbuf
argument_list|,
operator|*
name|pzchat
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|azstrings
index|[
literal|0
index|]
operator|=
name|zbuf
expr_stmt|;
if|if
condition|(
name|azstrings
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
operator|++
name|azstrings
index|[
literal|0
index|]
expr_stmt|;
comment|/* \Wnum at the end of the string is a timeout.  */
name|ctimeout
operator|=
name|qchat
operator|->
name|uuconf_ctimeout
expr_stmt|;
name|ztimeout
operator|=
name|strrchr
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztimeout
operator|!=
name|NULL
operator|&&
name|ztimeout
index|[
literal|1
index|]
operator|==
literal|'W'
condition|)
block|{
name|char
modifier|*
name|zend
decl_stmt|;
name|int
name|cval
decl_stmt|;
name|cval
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|ztimeout
operator|+
literal|2
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|zend
operator|!=
name|ztimeout
operator|+
literal|2
operator|&&
operator|*
name|zend
operator|==
literal|'\0'
condition|)
block|{
name|ctimeout
operator|=
name|cval
expr_stmt|;
operator|*
name|ztimeout
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|aclens
index|[
literal|0
index|]
operator|=
name|cescape
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclens
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|aclens
index|[
literal|0
index|]
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* There is no subexpect sequence.  If there is a 		 subsend sequence we move on to it.  Otherwise we let 		 this expect succeed.  This is somewhat inconsistent, 		 but it seems to be the traditional approach.  */
if|if
condition|(
name|pzchat
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|pzchat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
block|}
else|else
block|{
name|int
name|istr
decl_stmt|;
name|istr
operator|=
name|icexpect
argument_list|(
name|qconn
argument_list|,
name|cstrings
argument_list|,
name|azstrings
argument_list|,
name|aclens
argument_list|,
name|ctimeout
argument_list|,
name|qchat
operator|->
name|uuconf_fstrip
argument_list|)
expr_stmt|;
comment|/* If we found the string, break out of the 		 subexpect/subsend loop.  */
if|if
condition|(
name|istr
operator|==
literal|0
condition|)
break|break;
comment|/* If we got an error, return FALSE.  */
if|if
condition|(
name|istr
operator|<
operator|-
literal|1
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* If we found a failure string, log it and get out.  */
if|if
condition|(
name|istr
operator|>
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Chat script failed: Got \"%s\""
argument_list|,
name|qchat
operator|->
name|uuconf_pzfail
index|[
name|istr
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* We timed out; look for a send subsequence.  If none, 		 the chat script has failed.  */
if|if
condition|(
name|pzchat
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|pzchat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out in chat script"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Send the send subsequence without the leading '-'.  A 	     \"\" will send nothing.  An empty string will send a 	     carriage return.  */
operator|++
name|pzchat
expr_stmt|;
if|if
condition|(
operator|!
name|fcsend
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
operator|*
name|pzchat
operator|+
literal|1
argument_list|,
name|qsys
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|ftranslate
argument_list|,
name|qchat
operator|->
name|uuconf_fstrip
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* If there is no expect subsequence, we are done.  */
if|if
condition|(
name|pzchat
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|pzchat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
comment|/* Move on to next expect subsequence.  */
operator|++
name|pzchat
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fret
condition|)
break|break;
comment|/* Move on to the send string.  If there is none, we have 	 succeeded.  */
do|do
block|{
operator|++
name|pzchat
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|pzchat
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pzchat
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
do|;
if|if
condition|(
operator|*
name|pzchat
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
operator|*
name|pzchat
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|fcsend
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
operator|*
name|pzchat
argument_list|,
name|qsys
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|ftranslate
argument_list|,
name|qchat
operator|->
name|uuconf_fstrip
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|pzchat
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cstrings
condition|;
name|i
operator|++
control|)
name|ubuffree
argument_list|(
name|azstrings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azstrings
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|aclens
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Read characters and wait for one of a set of memory strings to come    in.  This returns the index into the array of the string that    arrives, or -1 on timeout, or -2 on error.  */
end_comment

begin_function
specifier|static
name|int
name|icexpect
parameter_list|(
name|qconn
parameter_list|,
name|cstrings
parameter_list|,
name|azstrings
parameter_list|,
name|aclens
parameter_list|,
name|ctimeout
parameter_list|,
name|fstrip
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|int
name|cstrings
decl_stmt|;
name|char
modifier|*
modifier|*
name|azstrings
decl_stmt|;
name|size_t
modifier|*
name|aclens
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|cmax
decl_stmt|;
name|char
modifier|*
name|zhave
decl_stmt|;
name|size_t
name|chave
decl_stmt|;
name|long
name|iendtime
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cchars
decl_stmt|;
name|int
name|iolddebug
decl_stmt|;
endif|#
directive|endif
name|cmax
operator|=
name|aclens
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cstrings
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cmax
operator|<
name|aclens
index|[
name|i
index|]
condition|)
name|cmax
operator|=
name|aclens
index|[
name|i
index|]
expr_stmt|;
name|zhave
operator|=
name|zbufalc
argument_list|(
name|cmax
argument_list|)
expr_stmt|;
name|chave
operator|=
literal|0
expr_stmt|;
name|iendtime
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
operator|+
name|ctimeout
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|cchars
operator|=
literal|0
expr_stmt|;
name|iolddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|udebug_buffer
argument_list|(
literal|"icexpect: Looking for"
argument_list|,
name|azstrings
index|[
literal|0
index|]
argument_list|,
name|aclens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"icexpect: Got \""
argument_list|)
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_INCOMING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|bchar
decl_stmt|;
comment|/* If we have no more time, get out.  */
if|if
condition|(
name|ctimeout
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (timed out)"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zhave
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Read one character at a time.  We could use a more complex 	 algorithm to read in larger batches, but it's probably not 	 worth it.  If the buffer is full, shift it left; we already 	 know that no string matches, and the buffer holds the largest 	 string, so this can't lose a match.  */
if|if
condition|(
name|chave
operator|>=
name|cmax
condition|)
block|{
name|size_t
name|imove
decl_stmt|;
for|for
control|(
name|imove
operator|=
literal|0
init|;
name|imove
operator|<
name|cmax
operator|-
literal|1
condition|;
name|imove
operator|++
control|)
name|zhave
index|[
name|imove
index|]
operator|=
name|zhave
index|[
name|imove
operator|+
literal|1
index|]
expr_stmt|;
operator|--
name|chave
expr_stmt|;
block|}
comment|/* The timeout/error return values from breceive_char are the 	 same as for this function.  */
name|bchar
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
name|ctimeout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bchar
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
comment|/* If there was an error, it will probably be logged in 		 the middle of our string, but this is only debugging 		 so it's not a big deal.  */
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (%s)"
argument_list|,
name|bchar
operator|==
operator|-
literal|1
condition|?
literal|"timed out"
else|:
literal|"error"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zhave
argument_list|)
expr_stmt|;
return|return
name|bchar
return|;
block|}
comment|/* Strip the parity bit if desired.  */
if|if
condition|(
name|fstrip
condition|)
name|bchar
operator|&=
literal|0x7f
expr_stmt|;
name|zhave
index|[
name|chave
index|]
operator|=
operator|(
name|char
operator|)
name|bchar
expr_stmt|;
operator|++
name|chave
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|++
name|cchars
expr_stmt|;
if|if
condition|(
name|cchars
operator|>
literal|60
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"icexpect: Got \""
argument_list|)
expr_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|bchar
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* See if any of the strings can be found in the buffer.  Since 	 we read one character at a time, the string can only be found 	 at the end of the buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cstrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aclens
index|[
name|i
index|]
operator|<=
name|chave
operator|&&
name|memcmp
argument_list|(
name|zhave
operator|+
name|chave
operator|-
name|aclens
index|[
name|i
index|]
argument_list|,
name|azstrings
index|[
name|i
index|]
argument_list|,
name|aclens
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (found it)"
argument_list|)
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|udebug_buffer
argument_list|(
literal|"icexpect: Found"
argument_list|,
name|azstrings
index|[
name|i
index|]
argument_list|,
name|aclens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zhave
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
name|ctimeout
operator|=
call|(
name|int
call|)
argument_list|(
name|iendtime
operator|-
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Debugging function for fcsend.  This takes the fquote variable, the    length of the string (0 if this an informational string which can    be printed directly) and the string itself.  It returns the new    value for fquote.  The fquote variable is TRUE if the debugging    output is in the middle of a quoted string.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|cCsend_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iColddebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcsend_debug
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|size_t
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|fcsend_debug
parameter_list|(
name|fquote
parameter_list|,
name|clen
parameter_list|,
name|zbuf
parameter_list|)
name|boolean
name|fquote
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
specifier|const
name|char
modifier|*
name|zbuf
decl_stmt|;
block|{
name|size_t
name|cwas
decl_stmt|;
if|if
condition|(
operator|!
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|cwas
operator|=
name|cCsend_chars
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
name|cCsend_chars
operator|+=
name|clen
expr_stmt|;
else|else
name|cCsend_chars
operator|+=
name|strlen
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cCsend_chars
operator|>
literal|60
operator|&&
name|cwas
operator|>
literal|10
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"%s"
argument_list|,
name|fquote
condition|?
literal|"\""
else|:
literal|""
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|FALSE
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"fcsend: Writing"
argument_list|)
expr_stmt|;
name|cCsend_chars
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s %s"
argument_list|,
name|fquote
condition|?
literal|"\""
else|:
literal|""
argument_list|,
name|zbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fquote
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|" \""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clen
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|zbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the debugging information for fcsend.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ucsend_debug_end
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ucsend_debug_end
parameter_list|(
name|fquote
parameter_list|,
name|ferr
parameter_list|)
name|boolean
name|fquote
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fquote
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferr
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|" (error)"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iColddebug
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG<= 1 */
end_comment

begin_comment
comment|/* Use macro definitions to make fcsend look neater.  */
end_comment

begin_define
define|#
directive|define
name|fcsend_debug
parameter_list|(
name|fquote
parameter_list|,
name|clen
parameter_list|,
name|zbuf
parameter_list|)
value|TRUE
end_define

begin_define
define|#
directive|define
name|ucsend_debug_end
parameter_list|(
name|fquote
parameter_list|,
name|ferror
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG<= 1 */
end_comment

begin_comment
comment|/* Send a string out.  This has to parse escape sequences as it goes.    Note that it handles the dialer escape sequences (\e, \E, \D, \T)    although they make no sense for chatting with a system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcsend
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|z
parameter_list|,
name|qsys
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|ftranslate
parameter_list|,
name|fstrip
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|uuconf_dialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|boolean
name|ftranslate
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
block|{
name|boolean
name|fnocr
decl_stmt|;
name|boolean
argument_list|(
argument|*pfwrite
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|zcallout_login
decl_stmt|;
name|char
modifier|*
name|zcallout_pass
decl_stmt|;
name|boolean
name|fquote
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|fnocr
operator|=
name|FALSE
expr_stmt|;
name|pfwrite
operator|=
name|fconn_write
expr_stmt|;
name|zcallout_login
operator|=
name|NULL
expr_stmt|;
name|zcallout_pass
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"fcsend: Writing"
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|FALSE
expr_stmt|;
name|cCsend_chars
operator|=
literal|0
expr_stmt|;
name|iColddebug
operator|=
name|iDebug
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_OUTGOING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|zlook
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|char
name|bsend
decl_stmt|;
name|zlook
operator|=
name|z
operator|+
name|strcspn
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z
argument_list|,
literal|"\\BE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlook
operator|>
name|z
condition|)
block|{
name|size_t
name|c
decl_stmt|;
name|c
operator|=
name|zlook
operator|-
name|z
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
name|c
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|qconn
argument_list|,
name|z
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|*
name|zlook
operator|==
literal|'\0'
condition|)
break|break;
name|z
operator|=
name|zlook
expr_stmt|;
name|fsend
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
operator|*
name|z
condition|)
block|{
case|case
literal|'B'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|z
argument_list|,
literal|"BREAK"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"break"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_break
argument_list|(
name|qconn
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fnocr
operator|=
name|TRUE
expr_stmt|;
name|z
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'B'
expr_stmt|;
operator|++
name|z
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|z
argument_list|,
literal|"EOT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\004'
expr_stmt|;
name|fnocr
operator|=
name|TRUE
expr_stmt|;
name|z
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'E'
expr_stmt|;
operator|++
name|z
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
operator|++
name|z
expr_stmt|;
switch|switch
condition|(
operator|*
name|z
condition|)
block|{
case|case
literal|'-'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fnocr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"sleep"
argument_list|)
expr_stmt|;
name|usysdep_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"echo-check-off"
argument_list|)
expr_stmt|;
name|pfwrite
operator|=
name|fconn_write
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"echo-check-on"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstrip
condition|)
name|pfwrite
operator|=
name|fcecho_send_strip
expr_stmt|;
else|else
name|pfwrite
operator|=
name|fcecho_send_nostrip
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"break"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_break
argument_list|(
name|qconn
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'n'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"pause"
argument_list|)
expr_stmt|;
name|usysdep_pause
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|--
name|z
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\\'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
operator|*
name|z
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|8
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|8
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
name|BUCHAR
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'A'
operator|+
literal|10
argument_list|)
expr_stmt|;
else|else
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'a'
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
block|{
specifier|const
name|char
modifier|*
name|zlog
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\L"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zlog
operator|=
name|qsys
operator|->
name|uuconf_zcall_login
expr_stmt|;
if|if
condition|(
name|zlog
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No login defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zlog
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zlog
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_login
operator|==
name|NULL
condition|)
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_callout
argument_list|(
name|puuconf
argument_list|,
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
operator|||
name|zcallout_login
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No login defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zlog
operator|=
name|zcallout_login
expr_stmt|;
block|}
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zlog
argument_list|)
expr_stmt|;
name|clen
operator|=
name|cescape
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"login"
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
name|clen
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|qconn
argument_list|,
name|zcopy
argument_list|,
name|clen
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
block|{
specifier|const
name|char
modifier|*
name|zpass
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\P"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zpass
operator|=
name|qsys
operator|->
name|uuconf_zcall_password
expr_stmt|;
if|if
condition|(
name|zpass
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No password defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zpass
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zpass
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_pass
operator|==
name|NULL
condition|)
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_callout
argument_list|(
name|puuconf
argument_list|,
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
operator|||
name|zcallout_pass
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No password defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zpass
operator|=
name|zcallout_pass
expr_stmt|;
block|}
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zpass
argument_list|)
expr_stmt|;
name|clen
operator|=
name|cescape
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"password"
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
name|clen
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|qconn
argument_list|,
name|zcopy
argument_list|,
name|clen
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\D"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"\\D"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcphone
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|pfwrite
argument_list|,
name|ftranslate
argument_list|,
operator|&
name|fquote
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\T"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"\\T"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcphone
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|pfwrite
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fquote
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\M"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"ignore-carrier"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_carrier
argument_list|(
name|qconn
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\m"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|qdial
operator|->
name|uuconf_fcarrier
condition|)
block|{
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
literal|"need-carrier"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_carrier
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
default|default:
comment|/* This error message will screw up any debugging 		 information, but it's easily avoidable.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized escape sequence \\%c in send string"
argument_list|,
operator|*
name|z
argument_list|)
expr_stmt|;
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
operator|*
name|z
expr_stmt|;
break|break;
block|}
operator|++
name|z
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|0
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fcsend: Can't happen"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|fsend
condition|)
block|{
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
operator|&
name|bsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|qconn
argument_list|,
operator|&
name|bsend
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcallout_login
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcallout_pass
argument_list|)
expr_stmt|;
comment|/* Output a final carriage return, unless there was a \c.  Don't      bother to check for an echo.  */
if|if
condition|(
operator|!
name|fnocr
condition|)
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
literal|'\r'
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
operator|&
name|b
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a phone number with optional dialcode translation.  The    pfquote argument is only used for debugging.  */
end_comment

begin_function_decl
specifier|static
name|boolean
name|fcphone
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|pfwrite
parameter_list|,
name|ftranslate
parameter_list|,
name|pfquote
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_dialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*pfwrite
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qc
operator|,
specifier|const
name|char
operator|*
name|zwrite
operator|,
name|size_t
name|cwrite
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean
name|ftranslate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
modifier|*
name|pfquote
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|zprefix
decl_stmt|,
modifier|*
name|zsuffix
decl_stmt|;
if|if
condition|(
name|ftranslate
condition|)
block|{
if|if
condition|(
operator|!
name|fctranslate
argument_list|(
name|puuconf
argument_list|,
name|zphone
argument_list|,
operator|&
name|zprefix
argument_list|,
operator|&
name|zsuffix
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|zprefix
operator|=
name|zphone
expr_stmt|;
name|zsuffix
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|zprefix
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
name|zstr
decl_stmt|;
name|z
operator|=
name|zprefix
operator|+
name|strcspn
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zprefix
argument_list|,
literal|"=-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|>
name|zprefix
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
name|clen
operator|=
name|z
operator|-
name|zprefix
expr_stmt|;
operator|*
name|pfquote
operator|=
name|fcsend_debug
argument_list|(
operator|*
name|pfquote
argument_list|,
name|clen
argument_list|,
name|zprefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|qconn
argument_list|,
name|zprefix
argument_list|,
name|clen
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'='
condition|)
name|zstr
operator|=
name|qdial
operator|->
name|uuconf_zdialtone
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
condition|)
name|zstr
operator|=
name|qdial
operator|->
name|uuconf_zpause
expr_stmt|;
else|else
comment|/* *z == '\0' */
break|break;
if|if
condition|(
name|zstr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pfquote
operator|=
name|fcsend_debug
argument_list|(
operator|*
name|pfquote
argument_list|,
name|strlen
argument_list|(
name|zstr
argument_list|)
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|qconn
argument_list|,
name|zstr
argument_list|,
name|strlen
argument_list|(
name|zstr
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|zprefix
operator|=
name|z
operator|+
literal|1
expr_stmt|;
block|}
name|zprefix
operator|=
name|zsuffix
expr_stmt|;
name|zsuffix
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* Given a phone number, run it through dial code translation    returning two strings.  */
end_comment

begin_function
specifier|static
name|boolean
name|fctranslate
parameter_list|(
name|puuconf
parameter_list|,
name|zphone
parameter_list|,
name|pzprefix
parameter_list|,
name|pzsuffix
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzprefix
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzsuffix
decl_stmt|;
block|{
name|int
name|iuuconf
decl_stmt|;
name|char
modifier|*
name|zdialcode
decl_stmt|,
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
name|char
modifier|*
name|ztrans
decl_stmt|;
operator|*
name|pzprefix
operator|=
name|zphone
expr_stmt|;
operator|*
name|pzsuffix
operator|=
name|NULL
expr_stmt|;
name|zdialcode
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zphone
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zfrom
operator|=
name|zphone
expr_stmt|;
name|zto
operator|=
name|zdialcode
expr_stmt|;
while|while
condition|(
operator|*
name|zfrom
operator|!=
literal|'\0'
operator|&&
name|isalpha
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zfrom
argument_list|)
argument_list|)
condition|)
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
operator|++
expr_stmt|;
operator|*
name|zto
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zdialcode
operator|==
literal|'\0'
condition|)
block|{
name|ubuffree
argument_list|(
name|zdialcode
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|iuuconf
operator|=
name|uuconf_dialcode
argument_list|(
name|puuconf
argument_list|,
name|zdialcode
argument_list|,
operator|&
name|ztrans
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zdialcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* We really should figure out a way to free up ztrans here.  */
operator|*
name|pzprefix
operator|=
name|ztrans
expr_stmt|;
operator|*
name|pzsuffix
operator|=
name|zfrom
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a string making sure the each character is echoed back.    There are two versions of this function, one which strips the    parity bit from the characters and one which does not.  This is so    that I can use a single function pointer in fcsend, and to avoid    using any static variables so that I can put chat scripts in a    library some day.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcecho_send_strip
parameter_list|(
name|qconn
parameter_list|,
name|zwrite
parameter_list|,
name|cwrite
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|size_t
name|cwrite
decl_stmt|;
block|{
return|return
name|fcecho_send
argument_list|(
name|qconn
argument_list|,
name|zwrite
argument_list|,
name|cwrite
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|fcecho_send_nostrip
parameter_list|(
name|qconn
parameter_list|,
name|zwrite
parameter_list|,
name|cwrite
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|size_t
name|cwrite
decl_stmt|;
block|{
return|return
name|fcecho_send
argument_list|(
name|qconn
argument_list|,
name|zwrite
argument_list|,
name|cwrite
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|fcecho_send
parameter_list|(
name|qconn
parameter_list|,
name|zwrite
parameter_list|,
name|cwrite
parameter_list|,
name|fstrip
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|size_t
name|cwrite
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zend
decl_stmt|;
name|zend
operator|=
name|zwrite
operator|+
name|cwrite
expr_stmt|;
for|for
control|(
init|;
name|zwrite
operator|<
name|zend
condition|;
name|zwrite
operator|++
control|)
block|{
name|int
name|b
decl_stmt|;
name|char
name|bwrite
decl_stmt|;
name|bwrite
operator|=
operator|*
name|zwrite
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
operator|&
name|bwrite
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fstrip
condition|)
name|bwrite
operator|&=
literal|0x7f
expr_stmt|;
do|do
block|{
comment|/* We arbitrarily wait five seconds for the echo.  */
name|b
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
literal|5
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Now b == -1 on timeout, -2 on error.  */
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Character not echoed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fstrip
condition|)
name|b
operator|&=
literal|0x7f
expr_stmt|;
block|}
do|while
condition|(
name|b
operator|!=
name|BUCHAR
argument_list|(
name|bwrite
argument_list|)
condition|)
do|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Run a chat program.  Expand any escape sequences and call a system    dependent program to run it.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcprogram
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|pzprogram
parameter_list|,
name|qsys
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|zport
parameter_list|,
name|ibaud
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzprogram
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|uuconf_dialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
block|{
name|size_t
name|cargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzpass
decl_stmt|,
modifier|*
modifier|*
name|pzarg
decl_stmt|;
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|char
modifier|*
name|zcallout_login
decl_stmt|;
name|char
modifier|*
name|zcallout_pass
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|cargs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|pzprogram
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
operator|++
name|cargs
expr_stmt|;
name|pzpass
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cargs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|zcallout_login
operator|=
name|NULL
expr_stmt|;
name|zcallout_pass
operator|=
name|NULL
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
comment|/* Copy the string into memory expanding escape sequences.  */
for|for
control|(
name|pz
operator|=
name|pzprogram
operator|,
name|pzarg
operator|=
name|pzpass
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
operator|,
name|pzarg
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
name|size_t
name|calc
decl_stmt|,
name|clen
decl_stmt|;
name|char
modifier|*
name|zto
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
operator|*
name|pz
argument_list|,
literal|'\\'
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|pzarg
operator|=
name|zbufcpy
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|pzarg
operator|=
name|NULL
expr_stmt|;
name|zto
operator|=
name|NULL
expr_stmt|;
name|calc
operator|=
literal|0
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|zfrom
operator|=
operator|*
name|pz
init|;
operator|*
name|zfrom
operator|!=
literal|'\0'
condition|;
name|zfrom
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zadd
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|zfree
init|=
name|NULL
decl_stmt|;
name|size_t
name|cadd
decl_stmt|;
name|char
name|abadd
index|[
literal|15
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|zfrom
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
name|clen
operator|+
literal|2
operator|>
name|calc
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|calc
operator|=
name|clen
operator|+
literal|50
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|calc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
operator|*
name|pzarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|*
name|pzarg
argument_list|)
expr_stmt|;
operator|*
name|pzarg
operator|=
name|znew
expr_stmt|;
name|zto
operator|=
name|znew
operator|+
name|clen
expr_stmt|;
block|}
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
expr_stmt|;
operator|++
name|clen
expr_stmt|;
continue|continue;
block|}
operator|++
name|zfrom
expr_stmt|;
switch|switch
condition|(
operator|*
name|zfrom
condition|)
block|{
case|case
literal|'\0'
case|:
operator|--
name|zfrom
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\\'
case|:
name|zadd
operator|=
literal|"\\"
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
block|{
specifier|const
name|char
modifier|*
name|zlog
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\L"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|zlog
operator|=
name|qsys
operator|->
name|uuconf_zcall_login
expr_stmt|;
if|if
condition|(
name|zlog
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: No login defined"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zlog
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zlog
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_login
operator|==
name|NULL
condition|)
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_callout
argument_list|(
name|puuconf
argument_list|,
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
operator|||
name|zcallout_login
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: No login defined"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
name|zlog
operator|=
name|zcallout_login
expr_stmt|;
block|}
name|zfree
operator|=
name|zbufcpy
argument_list|(
name|zlog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cescape
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|zadd
operator|=
name|zfree
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
block|{
specifier|const
name|char
modifier|*
name|zpass
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\P"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|zpass
operator|=
name|qsys
operator|->
name|uuconf_zcall_password
expr_stmt|;
if|if
condition|(
name|zpass
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: No password defined"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zpass
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zpass
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_pass
operator|==
name|NULL
condition|)
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_callout
argument_list|(
name|puuconf
argument_list|,
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
operator|||
name|zcallout_pass
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: No password defined"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
name|zpass
operator|=
name|zcallout_pass
expr_stmt|;
block|}
name|zfree
operator|=
name|zbufcpy
argument_list|(
name|zpass
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cescape
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|zadd
operator|=
name|zfree
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\D"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|zadd
operator|=
name|zphone
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
block|{
specifier|const
name|char
modifier|*
name|zprefix
decl_stmt|,
modifier|*
name|zsuffix
decl_stmt|;
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\T"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fctranslate
argument_list|(
name|puuconf
argument_list|,
name|zphone
argument_list|,
operator|&
name|zprefix
argument_list|,
operator|&
name|zsuffix
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zsuffix
operator|==
name|NULL
condition|)
name|zadd
operator|=
name|zprefix
expr_stmt|;
else|else
block|{
name|size_t
name|cprefix
decl_stmt|;
name|cprefix
operator|=
name|strlen
argument_list|(
name|zprefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|+
name|cprefix
operator|+
literal|1
operator|>
name|calc
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|calc
operator|=
name|clen
operator|+
name|cprefix
operator|+
literal|20
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|calc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
operator|*
name|pzarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|*
name|pzarg
argument_list|)
expr_stmt|;
operator|*
name|pzarg
operator|=
name|znew
expr_stmt|;
name|zto
operator|=
name|znew
operator|+
name|clen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zto
argument_list|,
name|zprefix
argument_list|,
name|cprefix
argument_list|)
expr_stmt|;
name|zto
operator|+=
name|cprefix
expr_stmt|;
name|clen
operator|+=
name|cprefix
expr_stmt|;
name|zadd
operator|=
name|zsuffix
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|zLdevice
operator|==
name|NULL
operator|&&
name|zport
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\Y"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* zLdevice will generally make more sense than zport, but 		 it might not be set yet.  */
name|zadd
operator|=
name|zLdevice
expr_stmt|;
if|if
condition|(
name|zadd
operator|==
name|NULL
condition|)
name|zadd
operator|=
name|zport
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\Z"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|zadd
operator|=
name|qsys
operator|->
name|uuconf_zname
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
block|{
if|if
condition|(
name|ibaud
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\S"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|abadd
argument_list|,
literal|"%ld"
argument_list|,
name|ibaud
argument_list|)
expr_stmt|;
name|zadd
operator|=
name|abadd
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Unrecognized escape sequence \\%c"
argument_list|,
operator|*
name|zfrom
argument_list|)
expr_stmt|;
name|abadd
index|[
literal|0
index|]
operator|=
operator|*
name|zfrom
expr_stmt|;
name|abadd
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zadd
operator|=
name|abadd
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|fret
condition|)
break|break;
name|cadd
operator|=
name|strlen
argument_list|(
name|zadd
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|+
name|cadd
operator|+
literal|1
operator|>
name|calc
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|calc
operator|=
name|clen
operator|+
name|cadd
operator|+
literal|20
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|calc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
operator|*
name|pzarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|*
name|pzarg
argument_list|)
expr_stmt|;
operator|*
name|pzarg
operator|=
name|znew
expr_stmt|;
name|zto
operator|=
name|znew
operator|+
name|clen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zto
argument_list|,
name|zadd
argument_list|,
name|cadd
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zto
operator|+=
name|cadd
expr_stmt|;
name|clen
operator|+=
name|cadd
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fret
condition|)
break|break;
operator|*
name|zto
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|clen
expr_stmt|;
block|}
operator|*
name|pzarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fret
condition|)
name|fret
operator|=
name|fconn_run_chat
argument_list|(
name|qconn
argument_list|,
name|pzpass
argument_list|)
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|pzpass
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
name|ubuffree
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|pzpass
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcallout_login
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcallout_pass
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

end_unit

