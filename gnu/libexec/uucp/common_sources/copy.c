begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* copy.c    Copy one file to another for the UUCP package.     Copyright (C) 1991, 1992, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|copy_rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Copy one file to another.  */
end_comment

begin_if
if|#
directive|if
name|USE_STDIO
end_if

begin_function
name|boolean
name|fcopy_file
parameter_list|(
name|zfrom
parameter_list|,
name|zto
parameter_list|,
name|fpublic
parameter_list|,
name|fmkdirs
parameter_list|,
name|fsignals
parameter_list|)
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|boolean
name|fpublic
decl_stmt|;
name|boolean
name|fmkdirs
decl_stmt|;
name|boolean
name|fsignals
decl_stmt|;
block|{
name|FILE
modifier|*
name|efrom
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|efrom
operator|=
name|fopen
argument_list|(
name|zfrom
argument_list|,
name|BINREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|efrom
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|zfrom
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fret
operator|=
name|fcopy_open_file
argument_list|(
name|efrom
argument_list|,
name|zto
argument_list|,
name|fpublic
argument_list|,
name|fmkdirs
argument_list|,
name|fsignals
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|efrom
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_function
name|boolean
name|fcopy_open_file
parameter_list|(
name|efrom
parameter_list|,
name|zto
parameter_list|,
name|fpublic
parameter_list|,
name|fmkdirs
parameter_list|,
name|fsignals
parameter_list|)
name|FILE
modifier|*
name|efrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|boolean
name|fpublic
decl_stmt|;
name|boolean
name|fmkdirs
decl_stmt|;
name|boolean
name|fsignals
decl_stmt|;
block|{
name|FILE
modifier|*
name|eto
decl_stmt|;
name|char
name|ab
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|eto
operator|=
name|esysdep_fopen
argument_list|(
name|zto
argument_list|,
name|fpublic
argument_list|,
name|FALSE
argument_list|,
name|fmkdirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|eto
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|fread
argument_list|(
name|ab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
sizeof|sizeof
name|ab
argument_list|,
name|efrom
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|c
argument_list|,
name|eto
argument_list|)
operator|!=
name|c
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fwrite: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fsignals
operator|&&
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
comment|/* Log the signal.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fsysdep_sync
argument_list|(
name|eto
argument_list|,
name|zto
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|eto
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! USE_STDIO */
end_comment

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|boolean
name|fcopy_file
parameter_list|(
name|zfrom
parameter_list|,
name|zto
parameter_list|,
name|fpublic
parameter_list|,
name|fmkdirs
parameter_list|,
name|fsignals
parameter_list|)
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|boolean
name|fpublic
decl_stmt|;
name|boolean
name|fmkdirs
decl_stmt|;
name|boolean
name|fsignals
decl_stmt|;
block|{
name|int
name|ofrom
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|ofrom
operator|=
name|open
argument_list|(
name|zfrom
argument_list|,
name|O_RDONLY
operator||
name|O_NOCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofrom
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|zfrom
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fret
operator|=
name|fcopy_open_file
argument_list|(
name|ofrom
argument_list|,
name|zto
argument_list|,
name|fpublic
argument_list|,
name|fmkdirs
argument_list|,
name|fsignals
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ofrom
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_function
name|boolean
name|fcopy_open_file
parameter_list|(
name|ofrom
parameter_list|,
name|zto
parameter_list|,
name|fpublic
parameter_list|,
name|fmkdirs
parameter_list|,
name|fsignals
parameter_list|)
name|int
name|ofrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|boolean
name|fpublic
decl_stmt|;
name|boolean
name|fmkdirs
decl_stmt|;
name|boolean
name|fsignals
decl_stmt|;
block|{
name|int
name|oto
decl_stmt|;
name|char
name|ab
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* These file mode arguments are from the UNIX version of sysdep.h;      each system dependent header file will need their own      definitions.  */
name|oto
operator|=
name|creat
argument_list|(
name|zto
argument_list|,
name|fpublic
condition|?
name|IPUBLIC_FILE_MODE
else|:
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oto
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|fmkdirs
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zto
argument_list|,
name|fpublic
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|oto
operator|=
name|creat
argument_list|(
name|zto
argument_list|,
name|fpublic
condition|?
name|IPUBLIC_FILE_MODE
else|:
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oto
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|zto
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
name|ofrom
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|oto
argument_list|,
name|ab
argument_list|,
operator|(
name|size_t
operator|)
name|c
argument_list|)
operator|!=
name|c
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|oto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fsignals
operator|&&
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
comment|/* Log the signal.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fsysdep_sync
argument_list|(
name|oto
argument_list|,
name|zto
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|oto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|oto
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! USE_STDIO */
end_comment

end_unit

