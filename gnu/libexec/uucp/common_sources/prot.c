begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* prot.c    Protocol support routines to move commands and data around.     Copyright (C) 1991, 1992, 1994 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|prot_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Variables visible to the protocol-specific routines.  */
end_comment

begin_comment
comment|/* Buffer to hold received data.  */
end_comment

begin_decl_stmt
name|char
name|abPrecbuf
index|[
name|CRECBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of start of data in abPrecbuf.  */
end_comment

begin_decl_stmt
name|int
name|iPrecstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of end of data (first byte not included in data) in abPrecbuf.  */
end_comment

begin_decl_stmt
name|int
name|iPrecend
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* We want to output and input at the same time, if supported on this    machine.  If we have something to send, we send it all while    accepting a large amount of data.  Once we have sent everything we    look at whatever we have received.  If data comes in faster than we    can send it, we may run out of buffer space.  */
end_comment

begin_function
name|boolean
name|fsend_data
parameter_list|(
name|qconn
parameter_list|,
name|zsend
parameter_list|,
name|csend
parameter_list|,
name|fdoread
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsend
decl_stmt|;
name|size_t
name|csend
decl_stmt|;
name|boolean
name|fdoread
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fdoread
condition|)
return|return
name|fconn_write
argument_list|(
name|qconn
argument_list|,
name|zsend
argument_list|,
name|csend
argument_list|)
return|;
while|while
condition|(
name|csend
operator|>
literal|0
condition|)
block|{
name|size_t
name|crec
decl_stmt|,
name|csent
decl_stmt|;
if|if
condition|(
name|iPrecend
operator|<
name|iPrecstart
condition|)
name|crec
operator|=
name|iPrecstart
operator|-
name|iPrecend
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|crec
operator|=
name|CRECBUFLEN
operator|-
name|iPrecend
expr_stmt|;
if|if
condition|(
name|iPrecstart
operator|==
literal|0
condition|)
operator|--
name|crec
expr_stmt|;
block|}
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
return|return
name|fconn_write
argument_list|(
name|qconn
argument_list|,
name|zsend
argument_list|,
name|csend
argument_list|)
return|;
name|csent
operator|=
name|csend
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_io
argument_list|(
name|qconn
argument_list|,
name|zsend
argument_list|,
operator|&
name|csent
argument_list|,
name|abPrecbuf
operator|+
name|iPrecend
argument_list|,
operator|&
name|crec
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|csend
operator|-=
name|csent
expr_stmt|;
name|zsend
operator|+=
name|csent
expr_stmt|;
name|iPrecend
operator|=
operator|(
name|iPrecend
operator|+
name|crec
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read data from the other system when we have nothing to send.  The    argument cneed is the amount of data the caller wants, and ctimeout    is the timeout in seconds.  The function sets *pcrec to the amount    of data which was actually received, which may be less than cneed    if there isn't enough room in the receive buffer.  If no data is    received before the timeout expires, *pcrec will be returned as 0.    If an error occurs, the function returns FALSE.  If the freport    argument is FALSE, no error should be reported.  */
end_comment

begin_function
name|boolean
name|freceive_data
parameter_list|(
name|qconn
parameter_list|,
name|cneed
parameter_list|,
name|pcrec
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|size_t
name|cneed
decl_stmt|;
name|size_t
modifier|*
name|pcrec
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
comment|/* Set *pcrec to the maximum amount of data we can read.  fconn_read      expects *pcrec to be the buffer size, and sets it to the amount      actually received.  */
if|if
condition|(
name|iPrecend
operator|<
name|iPrecstart
condition|)
operator|*
name|pcrec
operator|=
name|iPrecstart
operator|-
name|iPrecend
operator|-
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|pcrec
operator|=
name|CRECBUFLEN
operator|-
name|iPrecend
expr_stmt|;
if|if
condition|(
name|iPrecstart
operator|==
literal|0
condition|)
operator|--
operator|(
operator|*
name|pcrec
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
comment|/* If we have no room in the buffer, we're in trouble.  The      protocols must be written to ensure that this can't happen.  */
if|if
condition|(
operator|*
name|pcrec
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"freceive_data: No room in buffer"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we don't have room for all the data the caller wants, we      simply have to expect less.  We'll get the rest later.  */
if|if
condition|(
operator|*
name|pcrec
operator|<
name|cneed
condition|)
name|cneed
operator|=
operator|*
name|pcrec
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_read
argument_list|(
name|qconn
argument_list|,
name|abPrecbuf
operator|+
name|iPrecend
argument_list|,
name|pcrec
argument_list|,
name|cneed
argument_list|,
name|ctimeout
argument_list|,
name|freport
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecend
operator|=
operator|(
name|iPrecend
operator|+
operator|*
name|pcrec
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a single character.  Get it out of the receive buffer if it's    there, otherwise ask freceive_data for at least one character.    This is used because as a protocol is shutting down freceive_data    may read ahead and eat characters that should be read outside the    protocol routines.  We call freceive_data rather than fconn_read    with an argument of 1 so that we can get all the available data in    a single system call.  The ctimeout argument is the timeout in    seconds; the freport argument is FALSE if no error should be    reported.  This returns a character, or -1 on timeout or -2 on    error.  */
end_comment

begin_function
name|int
name|breceive_char
parameter_list|(
name|qconn
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
name|char
name|b
decl_stmt|;
if|if
condition|(
name|iPrecstart
operator|==
name|iPrecend
condition|)
block|{
name|size_t
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qconn
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|&
name|crec
argument_list|,
name|ctimeout
argument_list|,
name|freport
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|b
operator|=
name|abPrecbuf
index|[
name|iPrecstart
index|]
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|BUCHAR
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send mail about a file transfer.  We send to the given mailing    address if there is one, otherwise to the user.  */
end_comment

begin_function
name|boolean
name|fmail_transfer
parameter_list|(
name|fsuccess
parameter_list|,
name|zuser
parameter_list|,
name|zmail
parameter_list|,
name|zwhy
parameter_list|,
name|zfromfile
parameter_list|,
name|zfromsys
parameter_list|,
name|ztofile
parameter_list|,
name|ztosys
parameter_list|,
name|zsaved
parameter_list|)
name|boolean
name|fsuccess
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwhy
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfromfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfromsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztofile
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztosys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsaved
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zsendto
decl_stmt|;
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|*
name|zmail
operator|!=
literal|'\0'
condition|)
name|zsendto
operator|=
name|zmail
expr_stmt|;
else|else
name|zsendto
operator|=
name|zuser
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"The file\n\t"
expr_stmt|;
if|if
condition|(
name|zfromsys
operator|!=
name|NULL
condition|)
block|{
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zfromsys
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"!"
expr_stmt|;
block|}
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zfromfile
expr_stmt|;
if|if
condition|(
name|fsuccess
condition|)
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nwas successfully transferred to\n\t"
expr_stmt|;
else|else
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\ncould not be transferred to\n\t"
expr_stmt|;
if|if
condition|(
name|ztosys
operator|!=
name|NULL
condition|)
block|{
name|az
index|[
name|i
operator|++
index|]
operator|=
name|ztosys
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"!"
expr_stmt|;
block|}
name|az
index|[
name|i
operator|++
index|]
operator|=
name|ztofile
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nas requested by\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zuser
expr_stmt|;
if|if
condition|(
operator|!
name|fsuccess
condition|)
block|{
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nfor the following reason:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zwhy
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|zsaved
operator|!=
name|NULL
condition|)
block|{
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zsaved
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
block|}
return|return
name|fsysdep_mail
argument_list|(
name|zsendto
argument_list|,
name|fsuccess
condition|?
literal|"UUCP succeeded"
else|:
literal|"UUCP failed"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
return|;
block|}
end_function

end_unit

