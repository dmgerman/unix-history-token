begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* send.c    Routines to send a file.     Copyright (C) 1991, 1992, 1993, 1994 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, Building 200, 1 Kendall Square, Cambridge, MA 02139.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|send_rcsid
index|[]
init|=
literal|"$Id: send.c,v 1.3 1994/11/06 10:17:13 davidg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* We keep this information in the pinfo field of the stransfer    structure.  */
end_comment

begin_struct
struct|struct
name|ssendinfo
block|{
comment|/* Local user to send mail to (may be NULL).  */
name|char
modifier|*
name|zmail
decl_stmt|;
comment|/* Full file name.  */
name|char
modifier|*
name|zfile
decl_stmt|;
comment|/* Number of bytes in file.  */
name|long
name|cbytes
decl_stmt|;
comment|/* TRUE if this was a local request.  */
name|boolean
name|flocal
decl_stmt|;
comment|/* TRUE if this is a spool directory file.  */
name|boolean
name|fspool
decl_stmt|;
comment|/* TRUE if the file has been completely sent.  Also used in      flocal_send_cancelled to mean that the file send will never      succeed.  */
name|boolean
name|fsent
decl_stmt|;
comment|/* Execution file for sending an unsupported E request.  */
name|char
modifier|*
name|zexec
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|usfree_send
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_send_fail
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|scmd
operator|*
name|qcmd
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zwhy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_send_request
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_send_await_reply
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_send_cancelled
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_send_open_file
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_rec_fail
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
expr|enum
name|tfailure
name|twhy
operator|,
name|int
name|iremote
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_rec_fail_send
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_rec_reply
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend_file_end
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend_await_confirm
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend_exec_file_init
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usadd_exec_line
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|pz
operator|,
name|size_t
operator|*
name|pcalc
operator|,
name|size_t
operator|*
name|pclen
operator|,
name|int
name|bcmd
operator|,
specifier|const
name|char
operator|*
name|z1
operator|,
specifier|const
name|char
operator|*
name|z2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend_exec_file
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Free up a send stransfer structure.  */
end_comment

begin_function
specifier|static
name|void
name|usfree_send
parameter_list|(
name|qtrans
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
if|if
condition|(
name|qinfo
operator|!=
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|qinfo
operator|->
name|zmail
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qinfo
operator|->
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qinfo
operator|->
name|zexec
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|qtrans
operator|->
name|pinfo
argument_list|)
expr_stmt|;
block|}
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up a local request to send a file.  This may be called before    we have even tried to call the remote system.     If we are using a traditional protocol, which doesn't support    channel numbers and doesn't permit the file to be sent until an    acknowledgement has been received, the sequence of function calls    looks like this:     flocal_send_file_init --> fqueue_local    flocal_send_request (sends S request) --> fqueue_receive    flocal_send_await_reply (waits for SY) --> fqueue_send    flocal_send_open_file (opens file, calls pffile) --> fqueue_send    send file    fsend_file_end (calls pffile) --> fqueue_receive    fsend_await_confirm (waits for CY)     If flocal_send_await_reply gets an SN, it deletes the request.  If    the SY reply contains a file position at which to start sending,    flocal_send_await_reply sets qinfo->ipos.     This gets more complex if the protocol supports channels.  In that    case, we want to start sending the file data immediately, to avoid    the round trip delay between flocal_send_request and    flocal_send_await_reply.  To do this, flocal_send_request calls    fqueue_send rather than fqueue_receive.  The main execution    sequence looks like this:     flocal_send_file_init --> fqueue_local    flocal_send_request (sends S request) --> fqueue_send    flocal_send_open_file (opens file, calls pffile) --> fqueue_send    send file    fsend_file_end (calls pffile) --> fqueue_receive    sometime: flocal_send_await_reply (waits for SY)    fsend_await_confirm (waits for CY)     In this case flocal_send_await_reply must be run before    fsend_await_confirm; it may be run anytime after    flocal_send_request.     If flocal_send_await_reply is called before the entire file has    been sent: if it gets an SN, it sets the file position to the end    and arranges to call flocal_send_cancelled.  If it gets a file    position request, it must adjust the file position accordingly.     If flocal_send_await_reply is called after the entire file has been    sent: if it gets an SN, it can simply delete the request.  It can    ignore any file position request.     If the request is not deleted, flocal_send_await_reply must arrange    for the next string to be passed to fsend_await_confirm.    Presumably fsend_await_confirm will only be called after the entire    file has been sent.     Just to make things even more complex, these same routines support    sending execution requests, since that is much like sending a file.    For an execution request, the bcmd character will be E rather than    S.  If an execution request is being sent to a system which does    not support them, it must be sent as two S requests instead.  The    second one will be the execution file, but no actual file is    created; instead the zexec and znext fields in the ssendinfo    structure are used.  So if the bcmd character is E, then if the    zexec field is NULL, the data file is being sent, otherwise the    fake execution file is being sent.  */
end_comment

begin_function
name|boolean
name|flocal_send_file_init
parameter_list|(
name|qdaemon
parameter_list|,
name|qcmd
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|boolean
name|fspool
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|struct
name|ssendinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|fcaller
condition|?
operator|!
name|qsys
operator|->
name|uuconf_fcall_transfer
else|:
operator|!
name|qsys
operator|->
name|uuconf_fcalled_transfer
condition|)
block|{
comment|/* uux or uucp should have already made sure that the transfer 	 is possible, but it might have changed since then.  */
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fcall_transfer
operator|&&
operator|!
name|qsys
operator|->
name|uuconf_fcalled_transfer
condition|)
return|return
name|flocal_send_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qdaemon
argument_list|,
literal|"not permitted to transfer files"
argument_list|)
return|;
comment|/* We can't do the request now, but it may get done later.  */
return|return
name|TRUE
return|;
block|}
comment|/* The 'C' option means that the file has been copied to the spool      directory.  */
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'C'
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|fspool_file
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
condition|)
block|{
name|fspool
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qsys
operator|->
name|uuconf_pzlocal_send
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|)
condition|)
return|return
name|flocal_send_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qdaemon
argument_list|,
literal|"not permitted to send"
argument_list|)
return|;
name|zfile
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fspool
operator|=
name|TRUE
expr_stmt|;
name|zfile
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|,
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Make sure we meet any local size restrictions.  The connection      may not have been opened at this point, so we can't check remote      size restrictions.  */
name|cbytes
operator|=
name|csysdep_size
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
literal|0
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
condition|)
return|return
name|flocal_send_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qdaemon
argument_list|,
literal|"can not get size"
argument_list|)
return|;
comment|/* A cbytes value of -1 means that the file does not exist. 	 This can happen legitimately if it has already been sent from 	 the spool directory.  */
if|if
condition|(
operator|!
name|fspool
condition|)
return|return
name|flocal_send_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qdaemon
argument_list|,
literal|"does not exist"
argument_list|)
return|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|clocal_size
operator|!=
operator|-
literal|1
operator|&&
name|qdaemon
operator|->
name|clocal_size
operator|<
name|cbytes
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|cmax_ever
operator|==
operator|-
literal|2
condition|)
block|{
name|long
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|c1
operator|=
name|cmax_size_ever
argument_list|(
name|qsys
operator|->
name|uuconf_qcall_local_size
argument_list|)
expr_stmt|;
name|c2
operator|=
name|cmax_size_ever
argument_list|(
name|qsys
operator|->
name|uuconf_qcalled_local_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
name|qdaemon
operator|->
name|cmax_ever
operator|=
name|c1
expr_stmt|;
else|else
name|qdaemon
operator|->
name|cmax_ever
operator|=
name|c2
expr_stmt|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|cmax_ever
operator|!=
operator|-
literal|1
operator|&&
name|qdaemon
operator|->
name|cmax_ever
operator|<
name|qcmd
operator|->
name|cbytes
condition|)
return|return
name|flocal_send_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qdaemon
argument_list|,
literal|"too large to send"
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
comment|/* We are now prepared to send the command to the remote system.  We      queue up a transfer request to send the command when we are      ready.  */
name|qinfo
operator|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssendinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'m'
argument_list|)
operator|==
name|NULL
condition|)
name|qinfo
operator|->
name|zmail
operator|=
name|NULL
expr_stmt|;
else|else
name|qinfo
operator|->
name|zmail
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|zfile
operator|=
name|zfile
expr_stmt|;
name|qinfo
operator|->
name|cbytes
operator|=
name|cbytes
expr_stmt|;
name|qinfo
operator|->
name|flocal
operator|=
name|strchr
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
expr_stmt|;
name|qinfo
operator|->
name|fspool
operator|=
name|fspool
expr_stmt|;
name|qinfo
operator|->
name|fsent
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|zexec
operator|=
name|NULL
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
name|qcmd
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|flocal_send_request
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
return|return
name|fqueue_local
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clean up after a failing local send request.  If zwhy is not NULL,    this reports an error to the log file and to the user.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_send_fail
parameter_list|(
name|qtrans
parameter_list|,
name|qcmd
parameter_list|,
name|qdaemon
parameter_list|,
name|zwhy
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwhy
decl_stmt|;
block|{
if|if
condition|(
name|zwhy
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'E'
condition|)
block|{
name|zfrom
operator|=
name|qcmd
operator|->
name|zfrom
expr_stmt|;
name|zfree
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|zfree
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
operator|+
sizeof|sizeof
expr|" (execution of \"\")"
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zcmd
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfree
argument_list|,
literal|"%s (execution of \"%s\")"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zcmd
argument_list|)
expr_stmt|;
name|zfrom
operator|=
name|zfree
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|zfrom
argument_list|,
name|zwhy
argument_list|)
expr_stmt|;
comment|/* We only save the temporary file if this is a request from the 	 local system; otherwise a remote system could launch a denial 	 of service attack by filling up the .Preserve directory 	 (local users have much simpler methods for this type of 	 denial of service attack, so there is little point to using a 	 more sophisticated scheme).  */
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
condition|)
name|ztemp
operator|=
name|zsysdep_save_temp_file
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
else|else
name|ztemp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|zwhy
argument_list|,
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when we are ready to send the request to the remote    system.  We form the request and send it over.  If the protocol    does not support multiple channels, we start waiting for the    response; otherwise we can start sending the file immediately.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_send_request
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
specifier|const
name|char
modifier|*
name|znotify
decl_stmt|;
name|char
name|absize
index|[
literal|20
index|]
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
comment|/* Make sure the file meets any remote size restrictions.  */
if|if
condition|(
name|qdaemon
operator|->
name|cmax_receive
operator|!=
operator|-
literal|1
operator|&&
name|qdaemon
operator|->
name|cmax_receive
operator|<
name|qinfo
operator|->
name|cbytes
condition|)
block|{
name|fret
operator|=
name|flocal_send_fail
argument_list|(
name|qtrans
argument_list|,
operator|&
name|qtrans
operator|->
name|s
argument_list|,
name|qdaemon
argument_list|,
literal|"too large for receiver"
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
comment|/* Make sure the file still exists--it may have been removed between      the conversation startup and now.  After we have sent over the S      command we must give an error if we can't find the file.  */
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|qinfo
operator|->
name|zfile
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If we are using a protocol which can make multiple channels, then      we can open and send the file whenever we are ready.  This is      because we will be able to distinguish the response by the      channel it is directed to.  This assumes that every protocol      which supports multiple channels also supports sending the file      position in mid-stream, since otherwise we would not be able to      restart files.  */
name|qtrans
operator|->
name|fcmd
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|flocal_send_open_file
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|flocal_send_await_reply
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|cchans
operator|>
literal|1
condition|)
name|fret
operator|=
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
expr_stmt|;
else|else
name|fret
operator|=
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
return|return
name|FALSE
return|;
comment|/* Construct the notify string to send.  If we are going to send a      size or an execution command, it must be non-empty.  */
name|znotify
operator|=
name|qtrans
operator|->
name|s
operator|.
name|znotify
expr_stmt|;
if|if
condition|(
name|znotify
operator|==
name|NULL
condition|)
name|znotify
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_SIZES
operator|)
operator|!=
literal|0
operator|||
operator|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|znotify
operator|==
literal|'\0'
condition|)
name|znotify
operator|=
literal|"\"\""
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't need a notify string.  Some crufty UUCP code can't 	 handle a pair of double quotes.  */
if|if
condition|(
name|strcmp
argument_list|(
name|znotify
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
condition|)
name|znotify
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Construct the size string to send.  */
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_SIZES
operator|)
operator|==
literal|0
operator|&&
operator|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|!=
literal|'E'
operator|||
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|==
literal|0
operator|)
condition|)
name|absize
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_V103
operator|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|absize
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|qinfo
operator|->
name|cbytes
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|absize
argument_list|,
literal|"%ld"
argument_list|,
name|qinfo
operator|->
name|cbytes
argument_list|)
expr_stmt|;
name|zsend
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|)
operator|+
name|strlen
argument_list|(
name|znotify
argument_list|)
operator|+
name|strlen
argument_list|(
name|absize
argument_list|)
operator|+
operator|(
name|qtrans
operator|->
name|s
operator|.
name|zcmd
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|50
argument_list|)
expr_stmt|;
comment|/* If this an execution request and the other side supports      execution requests, we send an E command.  Otherwise we send an S      command.  The case of an execution request when we are sending      the fake execution file is handled just like an S request at this      point.  */
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Send the string 	 E zfrom zto zuser zoptions ztemp imode znotify size zcmd 	 to the remote system.  We put a '-' in front of the (possibly 	 empty) options and a '0' in front of the mode.  */
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"E %s %s %s -%s %s 0%o %s %s %s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|imode
argument_list|,
name|znotify
argument_list|,
name|absize
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zoptions
decl_stmt|,
modifier|*
name|zdummy
decl_stmt|;
comment|/* Send the string 	 S zfrom zto zuser zoptions ztemp imode znotify 	 to the remote system.  We put a '-' in front of the (possibly 	 empty) options and a '0' in front of the mode.  If size 	 negotiation is supported, we also send the size; in this case 	 if znotify is empty we must send it as "".  If this is really 	 an execution request, we have to simplify the options string 	 to remove the various execution options which may confuse the 	 remote system.  SVR4 expects a string "dummy" between the 	 notify string and the size; I don't know why.  */
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|!=
literal|'E'
condition|)
name|zoptions
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zoptions
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'C'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* This should set zoptions to "C", but at least one UUCP 	     program gets confused by it.  That means that it will 	     fail in certain cases, but I suppose we might as well 	     kowtow to compatibility.  This shouldn't matter to any 	     other program, I hope.  */
name|zoptions
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|zoptions
operator|=
literal|"c"
expr_stmt|;
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_SVR4
operator|)
operator|!=
literal|0
condition|)
name|zdummy
operator|=
literal|" dummy "
expr_stmt|;
else|else
name|zdummy
operator|=
literal|" "
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S %s %s %s -%s %s 0%o %s%s%s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|zoptions
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|imode
argument_list|,
name|znotify
argument_list|,
name|zdummy
argument_list|,
name|absize
argument_list|)
expr_stmt|;
block|}
name|fret
operator|=
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|zsend
argument_list|,
name|qtrans
operator|->
name|ilocal
argument_list|,
name|qtrans
operator|->
name|iremote
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* This is called when a reply is received for the send request.  As    described at length above, if the protocol supports multiple    channels we may be in the middle of sending the file, or we may    even finished sending the file.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_send_await_reply
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
name|bcmd
decl_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|!=
literal|0
condition|)
name|bcmd
operator|=
literal|'E'
expr_stmt|;
else|else
name|bcmd
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|zdata
index|[
literal|0
index|]
operator|!=
name|bcmd
operator|||
operator|(
name|zdata
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zdata
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Bad response to %c request: \"%s\""
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|bcmd
argument_list|,
name|zdata
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zdata
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|boolean
name|fnever
decl_stmt|;
name|fnever
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'2'
condition|)
name|zerr
operator|=
literal|"permission denied by remote"
expr_stmt|;
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'4'
condition|)
block|{
name|zerr
operator|=
literal|"remote cannot create work files"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
name|zerr
operator|=
literal|"too large for remote now"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'7'
condition|)
block|{
comment|/* The file is too large to ever send.  */
name|zerr
operator|=
literal|"too large for remote"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'8'
condition|)
block|{
comment|/* The file was already received by the remote system.  This 	     is not an error, it just means that the ack from the 	     remote was lost in the previous conversation, and there 	     is no need to resend the file.  */
name|zerr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'9'
condition|)
block|{
comment|/* Remote has run out of channels.  */
name|zerr
operator|=
literal|"too many channels for remote"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
comment|/* Drop one channel; using exactly one channel causes 	     slightly different behahaviour in a few places, so don't 	     decrement to one.  */
if|if
condition|(
name|qdaemon
operator|->
name|cchans
operator|>
literal|2
condition|)
operator|--
name|qdaemon
operator|->
name|cchans
expr_stmt|;
block|}
else|else
name|zerr
operator|=
literal|"unknown reason"
expr_stmt|;
if|if
condition|(
operator|!
name|fnever
operator|||
operator|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|==
literal|0
operator|&&
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (execution of \"%s\"): %s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|flocal_send_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|qtrans
operator|->
name|s
argument_list|,
name|qdaemon
argument_list|,
name|zerr
argument_list|)
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If the protocol does not support multiple channels, we can 	 simply remove the transaction.  Otherwise we must make sure 	 the remote side knows that we have finished sending the file 	 data.  If we have already sent the entire file, there will be 	 no confusion.  */
if|if
condition|(
name|qdaemon
operator|->
name|cchans
operator|==
literal|1
operator|||
name|qinfo
operator|->
name|fsent
condition|)
block|{
comment|/* If we are breaking a 'E' command into two 'S' commands, 	     and that was for the first 'S' command, we still have to 	     send the second one.  */
if|if
condition|(
name|fnever
operator|&&
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|==
literal|0
operator|&&
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
condition|)
return|return
name|fsend_exec_file_init
argument_list|(
name|qtrans
argument_list|,
name|qdaemon
argument_list|)
return|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* Seek to the end of the file so that the next read will 	     send end of file.  We have to be careful here, because we 	     may have actually already sent end of file--we could be 	     being called because of data received while the end of 	     file block was sent.  */
if|if
condition|(
operator|!
name|ffileseekend
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek to end: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtrans
operator|->
name|psendfn
operator|=
name|flocal_send_cancelled
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|NULL
expr_stmt|;
comment|/* Reuse fsent to pass fnever to flocal_send_cancelled.  */
name|qinfo
operator|->
name|fsent
operator|=
name|fnever
expr_stmt|;
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
block|}
comment|/* A number following the SY or EY is the file position to start      sending from.  If we are already sending the file, we must set      the position accordingly.  */
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|long
name|cskip
decl_stmt|;
name|cskip
operator|=
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|zdata
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cskip
operator|>
literal|0
operator|&&
name|qtrans
operator|->
name|ipos
operator|<
name|cskip
condition|)
block|{
if|if
condition|(
name|qtrans
operator|->
name|fsendfile
operator|&&
operator|!
name|qinfo
operator|->
name|fsent
condition|)
block|{
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|qtrans
operator|->
name|e
argument_list|,
name|cskip
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|qtrans
operator|->
name|ipos
operator|=
name|cskip
expr_stmt|;
block|}
block|}
comment|/* Now queue up to send the file or to wait for the confirmation.      We already set psendfn at the end of flocal_send_request.  If the      protocol supports multiple channels, we have already called      fqueue_send; calling it again would move the request in the      queue, which would make the log file a bit confusing.  */
name|qtrans
operator|->
name|precfn
operator|=
name|fsend_await_confirm
expr_stmt|;
if|if
condition|(
name|qinfo
operator|->
name|fsent
condition|)
return|return
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
elseif|else
if|if
condition|(
name|qdaemon
operator|->
name|cchans
operator|<=
literal|1
condition|)
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
else|else
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Open the file, if any, and prepare to send it.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_send_open_file
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
comment|/* If this is not a fake execution file, open it.  */
if|if
condition|(
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
condition|)
block|{
comment|/* If there is an ! in the user name, this is a remote request 	 queued up by fremote_xcmd_init.  */
name|zuser
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zuser
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|zuser
argument_list|,
literal|'!'
argument_list|)
operator|!=
name|NULL
condition|)
name|zuser
operator|=
name|NULL
expr_stmt|;
name|qtrans
operator|->
name|e
operator|=
name|esysdep_open_send
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|qinfo
operator|->
name|zfile
argument_list|,
operator|!
name|qinfo
operator|->
name|fspool
argument_list|,
name|zuser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot open file"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
operator|(
name|qinfo
operator|->
name|flocal
condition|?
name|zsysdep_save_temp_file
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
comment|/* Unfortunately, there is no way to cancel a file send 	     after we've already put it in progress.  So we have to 	     return FALSE to drop the connection.  */
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If flocal_send_await_reply has received a reply with a file      position, it will have set qtrans->ipos to the position at which      to start.  */
if|if
condition|(
name|qtrans
operator|->
name|ipos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|qinfo
operator|->
name|zexec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qtrans
operator|->
name|ipos
operator|>
name|qtrans
operator|->
name|cbytes
condition|)
name|qtrans
operator|->
name|ipos
operator|=
name|qtrans
operator|->
name|cbytes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|qtrans
operator|->
name|e
argument_list|,
name|qtrans
operator|->
name|ipos
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
comment|/* We don't bother to log sending the execution file.  */
if|if
condition|(
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zsend
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|!=
literal|'E'
condition|)
block|{
name|zsend
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zfrom
expr_stmt|;
name|zalc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|zalc
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|)
operator|+
sizeof|sizeof
expr|" ()"
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"%s (%s)"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
name|zsend
operator|=
name|zalc
expr_stmt|;
block|}
name|qtrans
operator|->
name|zlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"Sending ( bytes resume at )"
operator|+
name|strlen
argument_list|(
name|zsend
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|"Sending %s (%ld bytes"
argument_list|,
name|zsend
argument_list|,
name|qinfo
operator|->
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|ipos
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|)
argument_list|,
literal|" resume at %ld"
argument_list|,
name|qtrans
operator|->
name|ipos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fhandled
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
call|)
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|qinfo
operator|->
name|cbytes
operator|-
name|qtrans
operator|->
name|ipos
argument_list|,
operator|&
name|fhandled
argument_list|)
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fhandled
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|qinfo
operator|->
name|zexec
operator|!=
name|NULL
condition|)
name|qtrans
operator|->
name|psendfn
operator|=
name|fsend_exec_file
expr_stmt|;
else|else
block|{
name|qtrans
operator|->
name|fsendfile
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|fsend_file_end
expr_stmt|;
block|}
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cancel a file send.  This is only called for a protocol which    supports multiple channels.  It is needed so that both systems    agree as to when a channel is no longer needed.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_send_cancelled
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
comment|/* If we are breaking a 'E' command into two 'S' commands, and that      was for the first 'S' command, and the first 'S' command will      never be sent (passed as qinfo->fsent), we still have to send the      second one.  */
if|if
condition|(
name|qinfo
operator|->
name|fsent
operator|&&
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|==
literal|0
operator|&&
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
condition|)
return|return
name|fsend_exec_file_init
argument_list|(
name|qtrans
argument_list|,
name|qdaemon
argument_list|)
return|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A remote request to receive a file (meaning that we have to send a    file).  The sequence of functions calls is as follows:     fremote_rec_file_init (open file) --> fqueue_remote    fremote_rec_reply (send RY, call pffile) --> fqueue_send    send file    fsend_file_end (calls pffile) --> fqueue_receive    fsend_await_confirm (waits for CY)    */
end_comment

begin_function
name|boolean
name|fremote_rec_file_init
parameter_list|(
name|qdaemon
parameter_list|,
name|qcmd
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
name|boolean
name|fbadname
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|unsigned
name|int
name|imode
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
name|struct
name|ssendinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fsend_request
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: not permitted to send files to remote"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
if|if
condition|(
name|fspool_file
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: not permitted to send"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
name|zfile
operator|=
name|zsysdep_local_file
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
operator|&
name|fbadname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
operator|&&
name|fbadname
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: bad local file name"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
if|if
condition|(
name|zfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zbased
decl_stmt|;
name|zbased
operator|=
name|zsysdep_add_base
argument_list|(
name|zfile
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zbased
expr_stmt|;
block|}
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|qsys
operator|->
name|uuconf_pzremote_send
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: not permitted to send"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
comment|/* If the file is larger than the amount of space the other side      reported, we can't send it.  Should we adjust this check based on      the restart position?  */
name|cbytes
operator|=
name|csysdep_size
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|qcmd
operator|->
name|cbytes
operator|!=
operator|-
literal|1
operator|&&
name|qcmd
operator|->
name|cbytes
operator|<
name|cbytes
operator|)
operator|||
operator|(
name|qdaemon
operator|->
name|cremote_size
operator|!=
operator|-
literal|1
operator|&&
name|qdaemon
operator|->
name|cremote_size
operator|<
name|cbytes
operator|)
operator|||
operator|(
name|qdaemon
operator|->
name|cmax_receive
operator|!=
operator|-
literal|1
operator|&&
name|qdaemon
operator|->
name|cmax_receive
operator|<
name|cbytes
operator|)
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: too large to send"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_SIZE
argument_list|,
name|iremote
argument_list|)
return|;
block|}
name|imode
operator|=
name|ixsysdep_file_mode
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|e
operator|=
name|esysdep_open_send
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_rec_fail
argument_list|(
name|qdaemon
argument_list|,
name|FAILURE_OPEN
argument_list|,
name|iremote
argument_list|)
return|;
block|}
comment|/* If the remote requested that the file send start from a      particular position, arrange to do so.  */
if|if
condition|(
name|qcmd
operator|->
name|ipos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|e
argument_list|,
name|qcmd
operator|->
name|ipos
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|qinfo
operator|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssendinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|zmail
operator|=
name|NULL
expr_stmt|;
name|qinfo
operator|->
name|zfile
operator|=
name|zfile
expr_stmt|;
name|qinfo
operator|->
name|cbytes
operator|=
name|cbytes
expr_stmt|;
name|qinfo
operator|->
name|flocal
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|fspool
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|fsent
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|zexec
operator|=
name|NULL
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
name|qcmd
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|fremote_rec_reply
expr_stmt|;
name|qtrans
operator|->
name|iremote
operator|=
name|iremote
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
name|qtrans
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|qtrans
operator|->
name|ipos
operator|=
name|qcmd
operator|->
name|ipos
expr_stmt|;
name|qtrans
operator|->
name|s
operator|.
name|imode
operator|=
name|imode
expr_stmt|;
return|return
name|fqueue_remote
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reply to a receive request from the remote system, and prepare to    start sending the file.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_rec_reply
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
name|absend
index|[
literal|50
index|]
decl_stmt|;
name|qtrans
operator|->
name|fsendfile
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|fsend_file_end
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|fsend_await_confirm
expr_stmt|;
if|if
condition|(
operator|!
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We send the file size because SVR4 UUCP does.  We don't look for      it.  We send a trailing M if we want to request a hangup.  We      send it both after the mode and at the end of the entire string;      I don't know where programs look for it.  */
if|if
condition|(
name|qdaemon
operator|->
name|frequest_hangup
condition|)
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fremote_rec_reply: Requesting remote to transfer control"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|absend
argument_list|,
literal|"RY 0%o%s 0x%lx%s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|imode
argument_list|,
name|qdaemon
operator|->
name|frequest_hangup
condition|?
literal|"M"
else|:
literal|""
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|qinfo
operator|->
name|cbytes
argument_list|,
name|qdaemon
operator|->
name|frequest_hangup
condition|?
literal|"M"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|absend
argument_list|,
name|qtrans
operator|->
name|ilocal
argument_list|,
name|qtrans
operator|->
name|iremote
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtrans
operator|->
name|zlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"Sending ( bytes) "
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|"Sending %s (%ld bytes)"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qinfo
operator|->
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fhandled
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
call|)
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|qinfo
operator|->
name|cbytes
argument_list|,
operator|&
name|fhandled
argument_list|)
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If we can't send a file as requested by the remote system, queue up    a failure reply which will be sent when possible.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_rec_fail
parameter_list|(
name|qdaemon
parameter_list|,
name|twhy
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|enum
name|tfailure
name|twhy
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|enum
name|tfailure
modifier|*
name|ptinfo
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|ptinfo
operator|=
operator|(
expr|enum
name|tfailure
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|enum
name|tfailure
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ptinfo
operator|=
name|twhy
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|fremote_rec_fail_send
expr_stmt|;
name|qtrans
operator|->
name|iremote
operator|=
name|iremote
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|ptinfo
expr_stmt|;
return|return
name|fqueue_remote
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a failure string for a receive command to the remote system;    this is called when we are ready to reply to the command.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_rec_fail_send
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|enum
name|tfailure
modifier|*
name|ptinfo
init|=
operator|(
expr|enum
name|tfailure
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|int
name|ilocal
init|=
name|qtrans
operator|->
name|ilocal
decl_stmt|;
name|int
name|iremote
init|=
name|qtrans
operator|->
name|iremote
decl_stmt|;
switch|switch
condition|(
operator|*
name|ptinfo
condition|)
block|{
case|case
name|FAILURE_PERM
case|:
case|case
name|FAILURE_OPEN
case|:
name|z
operator|=
literal|"RN2"
expr_stmt|;
break|break;
case|case
name|FAILURE_SIZE
case|:
name|z
operator|=
literal|"RN6"
expr_stmt|;
break|break;
default|default:
name|z
operator|=
literal|"RN"
expr_stmt|;
break|break;
block|}
name|xfree
argument_list|(
name|qtrans
operator|->
name|pinfo
argument_list|)
expr_stmt|;
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
name|fret
operator|=
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|z
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called when the main loop has finished sending a file.  It    prepares to wait for a response from the remote system.  Note that    if this is a local request and the protocol supports multiple    channels, we may not even have received a confirmation of the send    request.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsend_file_end
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fhandled
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
call|)
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|fhandled
argument_list|)
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fhandled
condition|)
return|return
name|TRUE
return|;
block|}
name|qinfo
operator|->
name|fsent
operator|=
name|TRUE
expr_stmt|;
comment|/* qtrans->precfn should have been set by a previous function.  */
name|qtrans
operator|->
name|fcmd
operator|=
name|TRUE
expr_stmt|;
return|return
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the confirmation string received after sending a file.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fsend_await_confirm
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|boolean
name|fnever
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
if|if
condition|(
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zdata
index|[
literal|0
index|]
operator|!=
literal|'C'
operator|||
operator|(
name|zdata
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zdata
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|zerr
operator|=
literal|"bad confirmation from remote"
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s \"%s\""
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zerr
argument_list|,
name|zdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zdata
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|fnever
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'5'
condition|)
block|{
name|zerr
operator|=
literal|"file could not be stored in final location"
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zerr
operator|=
literal|"file send failed for unknown reason"
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s \"%s\""
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zerr
argument_list|,
name|zdata
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zerr
operator|=
name|NULL
expr_stmt|;
comment|/* If we receive CYM, it means that the other side wants us to 	 hang up so that they can send us something.  The 	 fhangup_requested field is checked in the main loop.  */
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'M'
operator|&&
name|qdaemon
operator|->
name|fmaster
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fsend_await_confirm: Remote has requested transfer of control"
argument_list|)
expr_stmt|;
name|qdaemon
operator|->
name|fhangup_requested
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|ustats
argument_list|(
name|zerr
operator|==
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|TRUE
argument_list|,
name|qtrans
operator|->
name|cbytes
argument_list|,
name|qtrans
operator|->
name|isecs
argument_list|,
name|qtrans
operator|->
name|imicros
argument_list|,
name|qdaemon
operator|->
name|fmaster
argument_list|)
expr_stmt|;
name|qdaemon
operator|->
name|csent
operator|+=
name|qtrans
operator|->
name|cbytes
expr_stmt|;
if|if
condition|(
name|zerr
operator|==
name|NULL
condition|)
block|{
comment|/* If this is an execution request, and the remote system 	 doesn't support execution requests, we have to set up the 	 fake execution file and loop around again.  */
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_EXEC
operator|)
operator|==
literal|0
operator|&&
name|qinfo
operator|->
name|zexec
operator|==
name|NULL
condition|)
return|return
name|fsend_exec_file_init
argument_list|(
name|qtrans
argument_list|,
name|qdaemon
argument_list|)
return|;
comment|/* Send mail about the transfer if requested.  */
if|if
condition|(
name|qinfo
operator|->
name|zmail
operator|!=
name|NULL
operator|&&
operator|*
name|qinfo
operator|->
name|zmail
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|TRUE
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qinfo
operator|->
name|zmail
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the file send failed, we only try to save the file and 	 send mail if it was requested locally and it will never 	 succeed.  We send mail to qinfo->zmail if set, otherwise to 	 qtrans->s.zuser.  I hope this is reasonable.  */
if|if
condition|(
name|fnever
operator|&&
name|qinfo
operator|->
name|flocal
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qinfo
operator|->
name|zmail
argument_list|,
name|zerr
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|zsysdep_save_temp_file
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
block|}
block|}
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare to send an execution file to a system which does not    support execution requests.  We build the execution file in memory,    and then call flocal_send_request as though we were sending a real    file.  Instead of sending a file, the code in flocal_send_open_file    will arrange to call fsend_exec_file which will send data out of    the buffer we have created.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsend_exec_file_init
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
modifier|*
name|zxqtfile
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abxname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|size_t
name|calc
decl_stmt|,
name|clen
decl_stmt|;
name|z
operator|=
name|NULL
expr_stmt|;
name|calc
operator|=
literal|0
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'U'
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qdaemon
operator|->
name|zlocalname
argument_list|)
expr_stmt|;
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'F'
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'I'
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'N'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'Z'
argument_list|)
operator|!=
name|NULL
condition|)
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'Z'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'R'
argument_list|)
operator|!=
name|NULL
condition|)
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'R'
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|znotify
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'e'
argument_list|)
operator|!=
name|NULL
condition|)
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'e'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|usadd_exec_line
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|calc
argument_list|,
operator|&
name|clen
argument_list|,
literal|'C'
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|zexec
operator|=
name|z
expr_stmt|;
name|qinfo
operator|->
name|cbytes
operator|=
name|clen
expr_stmt|;
name|zxqtfile
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|qdaemon
operator|->
name|zlocalname
argument_list|,
name|BDEFAULT_UUX_GRADE
argument_list|,
name|TRUE
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|abxname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxqtfile
operator|==
name|NULL
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zxqtfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|s
operator|.
name|zfrom
operator|=
name|zbufcpy
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|s
operator|.
name|zto
operator|=
name|zbufcpy
argument_list|(
name|abxname
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|s
operator|.
name|zoptions
operator|=
name|zbufcpy
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|s
operator|.
name|ztemp
operator|=
name|zbufcpy
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|flocal_send_request
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|NULL
expr_stmt|;
name|qtrans
operator|->
name|ipos
operator|=
literal|0
expr_stmt|;
name|qtrans
operator|->
name|cbytes
operator|=
literal|0
expr_stmt|;
name|qtrans
operator|->
name|isecs
operator|=
literal|0
expr_stmt|;
name|qtrans
operator|->
name|imicros
operator|=
literal|0
expr_stmt|;
name|qinfo
operator|->
name|fsent
operator|=
name|FALSE
expr_stmt|;
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a line to the fake execution file.  */
end_comment

begin_function
specifier|static
name|void
name|usadd_exec_line
parameter_list|(
name|pz
parameter_list|,
name|pcalc
parameter_list|,
name|pclen
parameter_list|,
name|bcmd
parameter_list|,
name|z1
parameter_list|,
name|z2
parameter_list|)
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|size_t
modifier|*
name|pcalc
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
name|int
name|bcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|z1
decl_stmt|;
specifier|const
name|char
modifier|*
name|z2
decl_stmt|;
block|{
name|size_t
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|char
modifier|*
name|znew
decl_stmt|;
name|c1
operator|=
name|strlen
argument_list|(
name|z1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|strlen
argument_list|(
name|z2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pclen
operator|+
name|c1
operator|+
name|c2
operator|+
literal|4
operator|>=
operator|*
name|pcalc
condition|)
block|{
operator|*
name|pcalc
operator|+=
name|c1
operator|+
name|c2
operator|+
literal|100
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
operator|*
name|pcalc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pclen
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|znew
argument_list|,
operator|*
name|pz
argument_list|,
operator|*
name|pclen
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
block|}
operator|*
name|pz
operator|=
name|znew
expr_stmt|;
block|}
name|znew
operator|=
operator|*
name|pz
operator|+
operator|*
name|pclen
expr_stmt|;
operator|*
name|znew
operator|++
operator|=
name|bcmd
expr_stmt|;
if|if
condition|(
operator|*
name|z1
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|znew
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
name|z1
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|znew
operator|+=
name|c1
expr_stmt|;
if|if
condition|(
operator|*
name|z2
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|znew
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
name|z2
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|znew
operator|+=
name|c2
expr_stmt|;
block|}
block|}
comment|/* In some bizarre non-Unix case we might have to worry about the      newline here.  We don't know how a newline is normally written      out to a file, but whatever is written to a file is what we will      normally transfer.  If that is not simply \n then this fake      execution file will not look like other execution files.  */
operator|*
name|znew
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|pclen
operator|=
name|znew
operator|-
operator|*
name|pz
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is called to send the contents of the fake execution    file.  Normally file data is sent by the floop routine in trans.c,    but since we don't have an actual file we must do it here.  This    routine sends the complete buffer, followed by a zero length    packet, and then calls fsend_file_end.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsend_exec_file
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|ssendinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|ssendinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|size_t
name|csend
decl_stmt|;
name|zdata
operator|=
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pzgetspace
call|)
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|csend
operator|=
name|qinfo
operator|->
name|cbytes
operator|-
name|qtrans
operator|->
name|ipos
expr_stmt|;
if|if
condition|(
name|csend
operator|>
name|cdata
condition|)
name|csend
operator|=
name|cdata
expr_stmt|;
name|memcpy
argument_list|(
name|zdata
argument_list|,
name|qinfo
operator|->
name|zexec
operator|+
name|qtrans
operator|->
name|ipos
argument_list|,
name|csend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsenddata
call|)
argument_list|(
name|qdaemon
argument_list|,
name|zdata
argument_list|,
name|csend
argument_list|,
name|qtrans
operator|->
name|ilocal
argument_list|,
name|qtrans
operator|->
name|iremote
argument_list|,
name|qtrans
operator|->
name|ipos
argument_list|)
condition|)
block|{
name|usfree_send
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtrans
operator|->
name|cbytes
operator|+=
name|csend
expr_stmt|;
name|qtrans
operator|->
name|ipos
operator|+=
name|csend
expr_stmt|;
if|if
condition|(
name|csend
operator|==
literal|0
condition|)
return|return
name|fsend_file_end
argument_list|(
name|qtrans
argument_list|,
name|qdaemon
argument_list|)
return|;
comment|/* Leave the job on the send queue.  */
return|return
name|TRUE
return|;
block|}
end_function

end_unit

