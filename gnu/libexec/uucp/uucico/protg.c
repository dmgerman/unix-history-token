begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* protg.c    The 'g' protocol.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|protg_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Each 'g' protocol packet begins with six bytes.  They are:<DLE><k><c0><c1><C><x><DLE> is the ASCII DLE character (^P or '\020').    if 1<=<k><= 8, the packet is followed by 2 ** (k + 4) bytes of data;    if<k> == 9, these six bytes are a complete control packet;    other value of<k> are illegal.<c0> is the low byte of a checksum.<c1> is the high byte of a checksum.<C> is a control byte (see below).<x> is<k> ^<c0> ^<c1> ^<C>.     The control byte<C> is divided into three bitfields:     t t x x x y y y     The two bit field tt is the packet type.    The three bit field xxx is the control type for a control packet, or    the sequence number for a data packet.    The three bit field yyy is a value for a control packet, or the    sequence number of the last packet received for a data packet.     For all successfully recieved packets, the control byte is stored    into iGpacket_control.  */
end_comment

begin_comment
comment|/* Names for the bytes in the frame header.  */
end_comment

begin_define
define|#
directive|define
name|IFRAME_DLE
value|(0)
end_define

begin_define
define|#
directive|define
name|IFRAME_K
value|(1)
end_define

begin_define
define|#
directive|define
name|IFRAME_CHECKLOW
value|(2)
end_define

begin_define
define|#
directive|define
name|IFRAME_CHECKHIGH
value|(3)
end_define

begin_define
define|#
directive|define
name|IFRAME_CONTROL
value|(4)
end_define

begin_define
define|#
directive|define
name|IFRAME_XOR
value|(5)
end_define

begin_comment
comment|/* Length of the frame header.  */
end_comment

begin_define
define|#
directive|define
name|CFRAMELEN
value|(6)
end_define

begin_comment
comment|/* Macros to break apart the control bytes.  */
end_comment

begin_define
define|#
directive|define
name|CONTROL_TT
parameter_list|(
name|b
parameter_list|)
value|((int)(((b)>> 6)& 03))
end_define

begin_define
define|#
directive|define
name|CONTROL_XXX
parameter_list|(
name|b
parameter_list|)
value|((int)(((b)>> 3)& 07))
end_define

begin_define
define|#
directive|define
name|CONTROL_YYY
parameter_list|(
name|b
parameter_list|)
value|((int)((b)& 07))
end_define

begin_comment
comment|/* DLE value.  */
end_comment

begin_define
define|#
directive|define
name|DLE
value|('\020')
end_define

begin_comment
comment|/* Get the length of a packet given a pointer to the header.  */
end_comment

begin_define
define|#
directive|define
name|CPACKLEN
parameter_list|(
name|z
parameter_list|)
value|((size_t) (1<< ((z)[IFRAME_K] + 4)))
end_define

begin_comment
comment|/*<k> field value for a control message.  */
end_comment

begin_define
define|#
directive|define
name|KCONTROL
value|(9)
end_define

begin_comment
comment|/* Get the next sequence number given a sequence number.  */
end_comment

begin_define
define|#
directive|define
name|INEXTSEQ
parameter_list|(
name|i
parameter_list|)
value|((i + 1)& 07)
end_define

begin_comment
comment|/* Compute i1 - i2 modulo 8.  */
end_comment

begin_define
define|#
directive|define
name|CSEQDIFF
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
value|(((i1) + 8 - (i2))& 07)
end_define

begin_comment
comment|/* Packet types.  These are from the tt field.    CONTROL -- control packet    ALTCHAN -- alternate channel; not used by UUCP    DATA -- full data segment    SHORTDATA -- less than full data segment (all the bytes specified by    the packet length<k> are always transferred).  Let<u> be the number    of bytes in the data segment not to be used.  If<u><= 0x7f, the first    byte of the data segment is<u> and the data follows.  If<u>> 0x7f,    the first byte of the data segment is 0x80 | (<u>& 0x7f), the second    byte of the data segment is<u>>> 7, and the data follows.  The    maximum possible data segment size is 2**12, so this handles all    possible cases.  */
end_comment

begin_define
define|#
directive|define
name|CONTROL
value|(0)
end_define

begin_define
define|#
directive|define
name|ALTCHAN
value|(1)
end_define

begin_define
define|#
directive|define
name|DATA
value|(2)
end_define

begin_define
define|#
directive|define
name|SHORTDATA
value|(3)
end_define

begin_comment
comment|/* Control types.  These are from the xxx field if the type (tt field)    is CONTROL.     CLOSE -- close the connection    RJ -- reject; packet yyy last to be received correctly    SRJ -- selective reject; reject only packet yyy (not used by UUCP)    RR -- receiver ready; packet yyy received correctly    INITC -- third step of initialization; yyy holds window size    INITB -- second step of initialization; yyy holds maximum<k> value - 1    INITA -- first step of initialization; yyy holds window size.     The yyy value for RR is the same as the yyy value for an ordinary    data packet.  */
end_comment

begin_define
define|#
directive|define
name|CLOSE
value|(1)
end_define

begin_define
define|#
directive|define
name|RJ
value|(2)
end_define

begin_define
define|#
directive|define
name|SRJ
value|(3)
end_define

begin_define
define|#
directive|define
name|RR
value|(4)
end_define

begin_define
define|#
directive|define
name|INITC
value|(5)
end_define

begin_define
define|#
directive|define
name|INITB
value|(6)
end_define

begin_define
define|#
directive|define
name|INITA
value|(7)
end_define

begin_comment
comment|/* Maximum amount of data in a single packet.  This is set by the<k>    field in the header; the amount of data in a packet is    2 ** (<k> + 4).<k> ranges from 1 to 8.  */
end_comment

begin_define
define|#
directive|define
name|CMAXDATAINDEX
value|(8)
end_define

begin_define
define|#
directive|define
name|CMAXDATA
value|(1<< (CMAXDATAINDEX + 4))
end_define

begin_comment
comment|/* Maximum window size.  */
end_comment

begin_define
define|#
directive|define
name|CMAXWINDOW
value|(7)
end_define

begin_escape
end_escape

begin_comment
comment|/* Defaults for the protocol parameters.  These may all be changed by    using the ``protocol-parameter g'' command, so there is no    particular reason to change the values given here.  */
end_comment

begin_comment
comment|/* The desired window size.  This is what we tell the other system to    use.  It must be between 1 and 7, and there's no reason to use less    than 7.  Protocol parameter ``window''.  */
end_comment

begin_define
define|#
directive|define
name|IWINDOW
value|(7)
end_define

begin_comment
comment|/* The desired packet size.  Many implementations only support 64 byte    packets.  Protocol parameter ``packet-size''.  */
end_comment

begin_define
define|#
directive|define
name|IPACKSIZE
value|(64)
end_define

begin_comment
comment|/* The number of times to retry the exchange of INIT packets when    starting the protocol.  Protocol parameter ``startup-retries''.  */
end_comment

begin_define
define|#
directive|define
name|CSTARTUP_RETRIES
value|(8)
end_define

begin_comment
comment|/* The timeout to use when waiting for an INIT packet when starting up    the protocol.  Protocol parameter ``init-timeout''.  */
end_comment

begin_define
define|#
directive|define
name|CEXCHANGE_INIT_TIMEOUT
value|(10)
end_define

begin_comment
comment|/* The number of times to retry sending and waiting for a single INIT    packet when starting the protocol.  This controls a single INIT    packet, while CSTARTUP_RETRIES controls how many times to try the    entire INIT sequence.  Protocol parameter ``init-retries''.  */
end_comment

begin_define
define|#
directive|define
name|CEXCHANGE_INIT_RETRIES
value|(4)
end_define

begin_comment
comment|/* The timeout to use when waiting for a packet.  Protocol parameter    ``timeout''.  */
end_comment

begin_define
define|#
directive|define
name|CTIMEOUT
value|(10)
end_define

begin_comment
comment|/* The number of times to retry waiting for a packet.  Each time the    timeout fails we send a copy of our last data packet or a reject    message for the packet we expect from the other side, depending on    whether we are waiting for an acknowledgement or a data packet.    This is the number of times we try doing that and then waiting    again.  Protocol parameter ``retries''.   */
end_comment

begin_define
define|#
directive|define
name|CRETRIES
value|(6)
end_define

begin_comment
comment|/* If we see more than this much unrecognized data, we drop the    connection.  This must be larger than a single packet size, which    means it must be larger than 4096 (the largest possible packet    size).  Protocol parameter ``garbage''.  */
end_comment

begin_define
define|#
directive|define
name|CGARBAGE
value|(10000)
end_define

begin_comment
comment|/* If we see more than this many protocol errors, we drop the    connection.  Protocol parameter ``errors''.  */
end_comment

begin_define
define|#
directive|define
name|CERRORS
value|(100)
end_define

begin_comment
comment|/* Default decay rate.  Each time we send or receive this many packets    succesfully, we decrement the error level by one (protocol    parameter ``error-decay'').  */
end_comment

begin_define
define|#
directive|define
name|CERROR_DECAY
value|(10)
end_define

begin_comment
comment|/* If this value is non-zero, it will be used as the remote window    size regardless of what the other side requested.  This can be    useful for dealing with some particularly flawed packages.  This    default value should always be 0, and protocol parameter    ``remote-window'' should be used for the affected systems.  */
end_comment

begin_define
define|#
directive|define
name|IREMOTE_WINDOW
value|(0)
end_define

begin_comment
comment|/* If this value is non-zero, it will be used as the packet size to    send to the remote system regardless of what it requested.  It's    difficult to imagine any circumstances where you would want to set    this.  Protocol parameter ``remote-packet-size''.  */
end_comment

begin_define
define|#
directive|define
name|IREMOTE_PACKSIZE
value|(0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* Next sequence number to send.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGsendseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number that has been acked.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGremote_ack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number to be retransmitted.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGretransmit_seq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number we have received.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGrecseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number we have acked.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGlocal_ack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Window size to request (protocol parameter ``window'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGrequest_winsize
init|=
name|IWINDOW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet size to request (protocol parameter ``packet-size'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGrequest_packsize
init|=
name|IPACKSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote window size (set during handshake).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGremote_winsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forced remote window size (protocol parameter ``remote-window'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGforced_remote_winsize
init|=
name|IREMOTE_WINDOW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote segment size (set during handshake).  This is one less than    the value in a packet header.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGremote_segsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote packet size (set based on iGremote_segsize).  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|iGremote_packsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forced remote packet size (protocol parameter    ``remote-packet-size'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGforced_remote_packsize
init|=
name|IREMOTE_PACKSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Recieved control byte.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iGpacket_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times to retry the initial handshake.  Protocol parameter    ``startup-retries''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGstartup_retries
init|=
name|CSTARTUP_RETRIES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times to retry sending an initial control packet.    Protocol parameter ``init-retries''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGexchange_init_retries
init|=
name|CEXCHANGE_INIT_RETRIES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout (seconds) for receiving an initial control packet.    Protocol parameter ``init-timeout''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGexchange_init_timeout
init|=
name|CEXCHANGE_INIT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout (seconds) for receiving a data packet.  Protocol parameter    ``timeout''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGtimeout
init|=
name|CTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of timeouts when receiving a data packet or    acknowledgement.  Protocol parameter ``retries''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGretries
init|=
name|CRETRIES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of garbage data we are prepared to see before giving up.    Protocol parameter ``garbage''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGgarbage_data
init|=
name|CGARBAGE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of errors we are prepared to see before giving up.    Protocol parameter ``errors''.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGmax_errors
init|=
name|CERRORS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we receive this many packets succesfully, we decrement    the error level by one (protocol parameter ``error-decay'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGerror_decay
init|=
name|CERROR_DECAY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to use shorter packets when possible.  Protocol parameter    ``short-packets''.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fGshort_packets
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protocol parameter commands.  */
end_comment

begin_decl_stmt
name|struct
name|uuconf_cmdtab
name|asGproto_params
index|[]
init|=
block|{
block|{
literal|"window"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iGrequest_winsize
block|,
name|NULL
block|}
block|,
block|{
literal|"packet-size"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iGrequest_packsize
block|,
name|NULL
block|}
block|,
block|{
literal|"startup-retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGstartup_retries
block|,
name|NULL
block|}
block|,
block|{
literal|"init-timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGexchange_init_timeout
block|,
name|NULL
block|}
block|,
block|{
literal|"init-retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGexchange_init_retries
block|,
name|NULL
block|}
block|,
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGtimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGretries
block|,
name|NULL
block|}
block|,
block|{
literal|"garbage"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGgarbage_data
block|,
name|NULL
block|}
block|,
block|{
literal|"errors"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGmax_errors
block|,
name|NULL
block|}
block|,
block|{
literal|"error-decay"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cGerror_decay
block|,
name|NULL
block|}
block|,
block|{
literal|"remote-window"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iGforced_remote_winsize
block|,
name|NULL
block|}
block|,
block|{
literal|"remote-packet-size"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iGforced_remote_packsize
block|,
name|NULL
block|}
block|,
block|{
literal|"short-packets"
block|,
name|UUCONF_CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fGshort_packets
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics.  */
end_comment

begin_comment
comment|/* Number of packets we have sent.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGsent_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets we have resent (these are not included in    cGsent_packets).  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGresent_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets we have delayed sending (these should not be    counted in cGresent_packets).  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGdelayed_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets we have received.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGrec_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets rejected because the header was bad.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGbad_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets rejected because the checksum was bad.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGbad_checksum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets received out of order.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGbad_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets rejected by receiver (number of RJ packets    received).  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGremote_rejects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of duplicate RR packets treated as RJ packets.  Some UUCP    packages appear to never send RJ packets, but only RR packets.  If    no RJ has been seen, fgprocess_data treats a duplicate RR as an RJ    and increments this variable.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGremote_duprrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The error level.  This is the total number of errors as adjusted by    cGerror_decay.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cGerror_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we send an RJ, we can expect several out of order of    packets, because the other side will probably have sent a full    window by the time it sees the RJ.  This variable keeps track of    the number of out of order packets we expect to see.  We don't    count expected out of order packets against the error level.  This    is reset to 0 when an in order packet is received.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cGexpect_bad_order
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Control packet names used for debugging.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|azGcontrol
index|[]
init|=
block|{
literal|"?0?"
block|,
literal|"CLOSE"
block|,
literal|"RJ"
block|,
literal|"SRJ"
block|,
literal|"RR"
block|,
literal|"INITC"
block|,
literal|"INITB"
block|,
literal|"INITA"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fgexchange_init
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|ictl
operator|,
name|int
name|ival
operator|,
name|int
operator|*
name|piset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fgsend_control
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|ictl
operator|,
name|int
name|ival
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zgadjust_ack
name|P
argument_list|(
operator|(
name|int
name|iseq
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fgwait_for_packet
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
name|freturncontrol
operator|,
name|int
name|ctimeout
operator|,
name|int
name|cretries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fgsend_acks
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fggot_ack
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|iack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fgprocess_data
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
name|fdoacks
operator|,
name|boolean
name|freturncontrol
operator|,
name|boolean
operator|*
name|pfexit
operator|,
name|size_t
operator|*
name|pcneed
operator|,
name|boolean
operator|*
name|pffound
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fginit_sendbuffers
name|P
argument_list|(
operator|(
name|boolean
name|fallocate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fgcheck_errors
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|igchecksum
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|clen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|igchecksum2
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfirst
operator|,
name|size_t
name|cfirst
operator|,
specifier|const
name|char
operator|*
name|zsecond
operator|,
name|size_t
name|csecond
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start the protocol.  This requires a three way handshake.  Both sides    must send and receive an INITA packet, an INITB packet, and an INITC    packet.  The INITA and INITC packets contain the window size, and the    INITB packet contains the packet size.  */
end_comment

begin_function
name|boolean
name|fgstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
name|int
name|iseg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean
name|fgota
decl_stmt|,
name|fgotb
decl_stmt|;
operator|*
name|pzlog
operator|=
name|NULL
expr_stmt|;
comment|/* The 'g' protocol requires a full eight bit interface.  */
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|PARITYSETTING_NONE
argument_list|,
name|STRIPSETTING_EIGHTBITS
argument_list|,
name|XONXOFF_OFF
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iGsendseq
operator|=
literal|1
expr_stmt|;
name|iGremote_ack
operator|=
literal|0
expr_stmt|;
name|iGretransmit_seq
operator|=
operator|-
literal|1
expr_stmt|;
name|iGrecseq
operator|=
literal|0
expr_stmt|;
name|iGlocal_ack
operator|=
literal|0
expr_stmt|;
name|cGsent_packets
operator|=
literal|0
expr_stmt|;
name|cGresent_packets
operator|=
literal|0
expr_stmt|;
name|cGdelayed_packets
operator|=
literal|0
expr_stmt|;
name|cGrec_packets
operator|=
literal|0
expr_stmt|;
name|cGbad_hdr
operator|=
literal|0
expr_stmt|;
name|cGbad_checksum
operator|=
literal|0
expr_stmt|;
name|cGbad_order
operator|=
literal|0
expr_stmt|;
name|cGremote_rejects
operator|=
literal|0
expr_stmt|;
name|cGremote_duprrs
operator|=
literal|0
expr_stmt|;
name|cGerror_level
operator|=
literal|0
expr_stmt|;
name|cGexpect_bad_order
operator|=
literal|0
expr_stmt|;
comment|/* We must determine the segment size based on the packet size      which may have been modified by a protocol parameter command.      A segment size of 2^n is passed as n - 5.  */
name|i
operator|=
name|iGrequest_packsize
expr_stmt|;
name|iseg
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|++
name|iseg
expr_stmt|;
name|i
operator|>>=
literal|1
expr_stmt|;
block|}
name|iseg
operator|-=
literal|5
expr_stmt|;
if|if
condition|(
name|iseg
operator|<
literal|0
operator|||
name|iseg
operator|>
literal|7
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal packet size %d for '%c' protocol"
argument_list|,
name|iGrequest_packsize
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
name|iseg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iGrequest_winsize
operator|<=
literal|0
operator|||
name|iGrequest_winsize
operator|>
literal|7
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal window size %d for '%c' protocol"
argument_list|,
name|iGrequest_winsize
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
name|iGrequest_winsize
operator|=
name|IWINDOW
expr_stmt|;
block|}
name|fgota
operator|=
name|FALSE
expr_stmt|;
name|fgotb
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cGstartup_retries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fgota
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|INITA
argument_list|,
name|iGrequest_winsize
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fgexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|INITA
argument_list|,
name|iGrequest_winsize
argument_list|,
operator|&
name|iGremote_winsize
argument_list|)
condition|)
continue|continue;
block|}
name|fgota
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fgotb
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|INITB
argument_list|,
name|iseg
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fgexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|INITB
argument_list|,
name|iseg
argument_list|,
operator|&
name|iGremote_segsize
argument_list|)
condition|)
continue|continue;
block|}
name|fgotb
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fgexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|INITC
argument_list|,
name|iGrequest_winsize
argument_list|,
operator|&
name|iGremote_winsize
argument_list|)
condition|)
continue|continue;
comment|/* We have succesfully connected.  Determine the remote packet 	 size.  */
name|iGremote_packsize
operator|=
literal|1
operator|<<
operator|(
name|iGremote_segsize
operator|+
literal|5
operator|)
expr_stmt|;
comment|/* If the user requested us to force specific remote window and 	 packet sizes, do so now.  */
if|if
condition|(
name|iGforced_remote_winsize
operator|>
literal|0
operator|&&
name|iGforced_remote_winsize
operator|<=
name|CMAXWINDOW
condition|)
name|iGremote_winsize
operator|=
name|iGforced_remote_winsize
expr_stmt|;
if|if
condition|(
name|iGforced_remote_packsize
operator|>=
literal|32
operator|&&
name|iGforced_remote_packsize
operator|<=
literal|4096
condition|)
block|{
comment|/* Force the value to a power of two.  */
name|i
operator|=
name|iGforced_remote_packsize
expr_stmt|;
name|iseg
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|++
name|iseg
expr_stmt|;
name|i
operator|>>=
literal|1
expr_stmt|;
block|}
name|iGremote_packsize
operator|=
literal|1
operator|<<
name|iseg
expr_stmt|;
name|iGremote_segsize
operator|=
name|iseg
operator|-
literal|5
expr_stmt|;
block|}
comment|/* Set up packet buffers to use.  We don't do this until we know 	 the maximum packet size we are going to send.  */
if|if
condition|(
operator|!
name|fginit_sendbuffers
argument_list|(
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|pzlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"protocol '' sending packet/window / receiving /"
operator|+
literal|64
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|pzlog
argument_list|,
literal|"protocol '%c' sending packet/window %d/%d receiving %d/%d"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
operator|(
name|int
operator|)
name|iGremote_packsize
argument_list|,
operator|(
name|int
operator|)
name|iGremote_winsize
argument_list|,
operator|(
name|int
operator|)
name|iGrequest_packsize
argument_list|,
operator|(
name|int
operator|)
name|iGrequest_winsize
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgstart: Protocol startup failed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The 'G' protocol is identical to the 'g' protocol, except that    short packets are never supported.  */
end_comment

begin_function
name|boolean
name|fbiggstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
name|fGshort_packets
operator|=
name|FALSE
expr_stmt|;
return|return
name|fgstart
argument_list|(
name|qdaemon
argument_list|,
name|pzlog
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The 'v' protocol is identical to the 'g' protocol, except that the    packet size defaults to 512 bytes.  Rather than really get it    right, we automatically switch from the usual default of 64 to 512.    This won't work correctly if somebody does protocol-parameter v    packet-size 64.  */
end_comment

begin_function
name|boolean
name|fvstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
if|if
condition|(
name|iGrequest_packsize
operator|==
name|IPACKSIZE
condition|)
name|iGrequest_packsize
operator|=
literal|1024
expr_stmt|;
return|return
name|fgstart
argument_list|(
name|qdaemon
argument_list|,
name|pzlog
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Exchange initialization messages with the other system.     A problem:     We send INITA; it gets received    We receive INITA    We send INITB; it gets garbled    We receive INITB     We have seen and sent INITB, so we start to send INITC.  The other    side as sent INITB but not seen it, so it times out and resends    INITB.  We will continue sending INITC and the other side will    continue sending INITB until both sides give up and start again    with INITA.     It might seem as though if we are sending INITC and receive INITB,    we should resend our INITB, but this could cause infinite echoing    of INITB on a long-latency line.  Rather than risk that, I have    implemented a fast drop-back procedure.  If we are sending INITB and    receive INITC, the other side has gotten ahead of us.  We immediately    fail and begin again with INITA.  For the other side, if we are    sending INITC and see INITA, we also immediately fail back to INITA.     Unfortunately, this doesn't work for the other case, in which we    are sending INITB but the other side has not yet seen INITA.  As    far as I can see, if this happens we just have to wait until we    time out and resend INITA.  */
end_comment

begin_function
specifier|static
name|boolean
name|fgexchange_init
parameter_list|(
name|qdaemon
parameter_list|,
name|ictl
parameter_list|,
name|ival
parameter_list|,
name|piset
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|ictl
decl_stmt|;
name|int
name|ival
decl_stmt|;
name|int
modifier|*
name|piset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* The three-way handshake should be independent of who initializes      it, but it seems that some versions of uucico assume that the      caller sends first and the callee responds.  This only matters if      we are the callee and the first packet is garbled.  If we send a      packet, the other side will assume that we must have seen the      packet they sent and will never time out and send it again.      Therefore, if we are the callee we don't send a packet the first      time through the loop.  This can still fail, but should usually      work, and, after all, if the initialization packets are received      correctly there will be no problem no matter what we do.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cGexchange_init_retries
condition|;
name|i
operator|++
control|)
block|{
name|long
name|itime
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|fcaller
operator|||
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|ictl
argument_list|,
name|ival
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|itime
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ctimeout
operator|=
name|cGexchange_init_timeout
expr_stmt|;
do|do
block|{
name|long
name|inewtime
decl_stmt|;
comment|/* We pass 0 as the retry count to fgwait_for_packet because 	     we want to handle retries here and because if it retried 	     it would send a packet, which would be bad.  */
if|if
condition|(
operator|!
name|fgwait_for_packet
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|,
name|ctimeout
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|CONTROL_TT
argument_list|(
name|iGpacket_control
argument_list|)
operator|==
name|CONTROL
condition|)
block|{
if|if
condition|(
name|CONTROL_XXX
argument_list|(
name|iGpacket_control
argument_list|)
operator|==
name|ictl
condition|)
block|{
operator|*
name|piset
operator|=
name|CONTROL_YYY
argument_list|(
name|iGpacket_control
argument_list|)
expr_stmt|;
comment|/* If we didn't already send our initialization 		     packet, send it now.  */
if|if
condition|(
operator|!
name|qdaemon
operator|->
name|fcaller
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|ictl
argument_list|,
name|ival
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* If the other side is farther along than we are, 		 we have lost a packet.  Fail immediately back to 		 INITA (but don't fail if we are already doing INITA, 		 since that would count against cStart_retries more 		 than it should).  */
if|if
condition|(
name|CONTROL_XXX
argument_list|(
name|iGpacket_control
argument_list|)
operator|<
name|ictl
operator|&&
name|ictl
operator|!=
name|INITA
condition|)
return|return
name|FALSE
return|;
comment|/* If we are sending INITC and we receive an INITA, the other 		 side has failed back (we know this because we have 		 seen an INITB from them).  Fail back ourselves to 		 start the whole handshake over again.  */
if|if
condition|(
name|CONTROL_XXX
argument_list|(
name|iGpacket_control
argument_list|)
operator|==
name|INITA
operator|&&
name|ictl
operator|==
name|INITC
condition|)
return|return
name|FALSE
return|;
comment|/* As a special hack, if we are sending INITC and we 		 receive INITB, we update the segment size from the 		 packet.  This permits a second INITB to override the 		 first one.  It would be nice to do this in a cleaner 		 way.  */
if|if
condition|(
name|CONTROL_XXX
argument_list|(
name|iGpacket_control
argument_list|)
operator|==
name|INITB
operator|&&
name|ictl
operator|==
name|INITC
condition|)
name|iGremote_segsize
operator|=
name|CONTROL_YYY
argument_list|(
name|iGpacket_control
argument_list|)
expr_stmt|;
block|}
name|inewtime
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ctimeout
operator|-=
name|inewtime
operator|-
name|itime
expr_stmt|;
block|}
do|while
condition|(
name|ctimeout
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shut down the protocol.  */
end_comment

begin_function
name|boolean
name|fgshutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|CLOSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|CLOSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fginit_sendbuffers
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* The count of sent packets may not be accurate, because some of      them may have not been sent yet if the connection failed in the      middle (the ones that counted for cGdelayed_packets).  I don't      think it's worth being precise.  */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol '%c' packets: sent %ld, resent %ld, received %ld"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|cGsent_packets
argument_list|,
name|cGresent_packets
operator|-
name|cGdelayed_packets
argument_list|,
name|cGrec_packets
argument_list|)
expr_stmt|;
if|if
condition|(
name|cGbad_hdr
operator|!=
literal|0
operator|||
name|cGbad_checksum
operator|!=
literal|0
operator|||
name|cGbad_order
operator|!=
literal|0
operator|||
name|cGremote_rejects
operator|!=
literal|0
operator|||
name|cGremote_duprrs
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Errors: header %ld, checksum %ld, order %ld, remote rejects %ld"
argument_list|,
name|cGbad_hdr
argument_list|,
name|cGbad_checksum
argument_list|,
name|cGbad_order
argument_list|,
name|cGremote_duprrs
operator|+
name|cGremote_rejects
argument_list|)
expr_stmt|;
comment|/* Reset all the parameters to their default values, so that the      protocol parameters used for this connection do not affect the      next one.  */
name|iGrequest_winsize
operator|=
name|IWINDOW
expr_stmt|;
name|iGrequest_packsize
operator|=
name|IPACKSIZE
expr_stmt|;
name|cGstartup_retries
operator|=
name|CSTARTUP_RETRIES
expr_stmt|;
name|cGexchange_init_timeout
operator|=
name|CEXCHANGE_INIT_TIMEOUT
expr_stmt|;
name|cGexchange_init_retries
operator|=
name|CEXCHANGE_INIT_RETRIES
expr_stmt|;
name|cGtimeout
operator|=
name|CTIMEOUT
expr_stmt|;
name|cGretries
operator|=
name|CRETRIES
expr_stmt|;
name|cGgarbage_data
operator|=
name|CGARBAGE
expr_stmt|;
name|cGmax_errors
operator|=
name|CERRORS
expr_stmt|;
name|cGerror_decay
operator|=
name|CERROR_DECAY
expr_stmt|;
name|iGforced_remote_winsize
operator|=
name|IREMOTE_WINDOW
expr_stmt|;
name|iGforced_remote_packsize
operator|=
name|IREMOTE_PACKSIZE
expr_stmt|;
name|fGshort_packets
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a command string.  We send packets containing the string until    the entire string has been sent.  Each packet is full.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fgsendcmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|size_t
name|clen
decl_stmt|;
name|boolean
name|fagain
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fgsendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|zpacket
decl_stmt|;
name|size_t
name|cdummy
decl_stmt|;
name|zpacket
operator|=
name|zggetspace
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|cdummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|iGremote_packsize
condition|)
block|{
name|size_t
name|csize
decl_stmt|;
comment|/* If the remote packet size is larger than 64 (the default, 	     which may indicate an older UUCP package), try to fit 	     this command into a smaller packet.  We still always send 	     a complete packet, though.  */
if|if
condition|(
name|iGremote_packsize
operator|<=
literal|64
operator|||
operator|!
name|fGshort_packets
condition|)
name|csize
operator|=
name|iGremote_packsize
expr_stmt|;
else|else
block|{
name|csize
operator|=
literal|32
expr_stmt|;
while|while
condition|(
name|csize
operator|<=
name|clen
condition|)
name|csize
operator|<<=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zpacket
argument_list|,
name|z
argument_list|,
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|>
name|clen
condition|)
name|bzero
argument_list|(
name|zpacket
operator|+
name|clen
argument_list|,
name|csize
operator|-
name|clen
argument_list|)
expr_stmt|;
name|fagain
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fgsenddata
argument_list|(
name|qdaemon
argument_list|,
name|zpacket
argument_list|,
name|csize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|zpacket
argument_list|,
name|z
argument_list|,
name|iGremote_packsize
argument_list|)
expr_stmt|;
name|z
operator|+=
name|iGremote_packsize
expr_stmt|;
name|clen
operator|-=
name|iGremote_packsize
expr_stmt|;
name|fagain
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fgsenddata
argument_list|(
name|qdaemon
argument_list|,
name|zpacket
argument_list|,
name|iGremote_packsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
do|while
condition|(
name|fagain
condition|)
do|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We keep an array of buffers to retransmit as necessary.  Rather    than waste static space on large buffer sizes, we allocate the    buffers once we know how large the other system expects them to be.    The sequence numbers used in the 'g' protocol are only three bits    long, so we allocate eight buffers and maintain a correspondence    between buffer index and sequence number.  This always wastes some    buffer space, but it's easy to implement.     We leave room at the front of the buffer for the frame header and    two additional bytes.  The two extra bytes are used for short    packets, which essentially use a longer header and shorter data.    We do this to avoid moving the data.  We zero out any unused bytes    before the frame, so we can locate the real header given a buffer    by finding the first non-zero byte (which will be one of the first    three bytes in the buffer).  */
end_comment

begin_define
define|#
directive|define
name|CSENDBUFFERS
value|(CMAXWINDOW + 1)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|azGsendbuffers
index|[
name|CSENDBUFFERS
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|fginit_sendbuffers
parameter_list|(
name|fallocate
parameter_list|)
name|boolean
name|fallocate
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Free up any remaining old buffers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSENDBUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azGsendbuffers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallocate
condition|)
block|{
name|azGsendbuffers
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|CFRAMELEN
operator|+
literal|2
operator|+
name|iGremote_packsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|azGsendbuffers
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* This bzero might not seem necessary, since before we send 	     out each packet we zero out any non-data bytes.  However, 	     if we receive an SRJ at the start of the conversation, we 	     will send out the packet before it has been set to 	     anything, thus sending the contents of our heap.  We 	     avoid this by using bzero.  */
name|bzero
argument_list|(
name|azGsendbuffers
index|[
name|i
index|]
argument_list|,
name|CFRAMELEN
operator|+
literal|2
operator|+
name|iGremote_packsize
argument_list|)
expr_stmt|;
block|}
else|else
name|azGsendbuffers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate a packet to send out.  The return value of this function    must be filled in and passed to fgsenddata, or discarded.  This    will ensure that the buffers and iGsendseq stay in synch.  Set    *pclen to the amount of data to place in the buffer.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|zggetspace
parameter_list|(
name|qdaemon
parameter_list|,
name|pclen
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|iGremote_packsize
expr_stmt|;
return|return
name|azGsendbuffers
index|[
name|iGsendseq
index|]
operator|+
name|CFRAMELEN
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Send out a data packet.  This computes the checksum, sets up the    header, and sends the packet out.  The argument zdata should point    to the return value of zggetspace.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
name|boolean
name|fgsenddata
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|itt
decl_stmt|,
name|iseg
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
name|int
name|iclr1
decl_stmt|,
name|iclr2
decl_stmt|;
name|unsigned
name|short
name|icheck
decl_stmt|;
comment|/* Set the initial length bytes.  See the description at the definition      of SHORTDATA, above.  */
name|itt
operator|=
name|DATA
expr_stmt|;
name|csize
operator|=
name|iGremote_packsize
expr_stmt|;
name|iseg
operator|=
name|iGremote_segsize
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|cdata
operator|>
name|csize
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fgsend_packet: Packet size too large"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iclr1
operator|=
operator|-
literal|1
expr_stmt|;
name|iclr2
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|cdata
operator|<
name|csize
condition|)
block|{
comment|/* If the remote packet size is larger than 64, the default, we 	 can assume they can handle a smaller packet as well, which 	 will be more efficient to send.  */
if|if
condition|(
name|iGremote_packsize
operator|>
literal|64
operator|&&
name|fGshort_packets
condition|)
block|{
comment|/* The packet size is 1<< (iseg + 4).  */
name|iseg
operator|=
literal|1
expr_stmt|;
name|csize
operator|=
literal|32
expr_stmt|;
while|while
condition|(
name|csize
operator|<
name|cdata
condition|)
block|{
name|csize
operator|<<=
literal|1
expr_stmt|;
operator|++
name|iseg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csize
operator|!=
name|cdata
condition|)
block|{
name|size_t
name|cshort
decl_stmt|;
comment|/* We have to add bytes which indicate how short the packet 	     is.  We do this by pushing the header backward, which we 	     can do because we allocated two extra bytes for this 	     purpose.  */
name|iclr2
operator|=
literal|0
expr_stmt|;
name|itt
operator|=
name|SHORTDATA
expr_stmt|;
name|cshort
operator|=
name|csize
operator|-
name|cdata
expr_stmt|;
if|if
condition|(
name|cshort
operator|<=
literal|127
condition|)
block|{
operator|--
name|zdata
expr_stmt|;
name|zdata
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|cshort
expr_stmt|;
name|zdata
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cshort
operator|>
literal|1
condition|)
name|bzero
argument_list|(
name|zdata
operator|+
name|cdata
operator|+
literal|1
argument_list|,
name|cshort
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zdata
operator|-=
literal|2
expr_stmt|;
name|zdata
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|cshort
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
name|zdata
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cshort
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zdata
operator|+
name|cdata
operator|+
literal|2
argument_list|,
name|cshort
operator|-
literal|2
argument_list|)
expr_stmt|;
name|iclr1
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|z
operator|=
name|zdata
operator|-
name|CFRAMELEN
expr_stmt|;
comment|/* Zero out the preceding bytes, in case the last time this buffer      was used those bytes were used.  We need to zero out the initial      bytes so that we can find the true start of the packet in      zgadjust_ack.  */
name|z
index|[
name|iclr1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|z
index|[
name|iclr2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|z
index|[
name|IFRAME_DLE
index|]
operator|=
name|DLE
expr_stmt|;
name|z
index|[
name|IFRAME_K
index|]
operator|=
operator|(
name|char
operator|)
name|iseg
expr_stmt|;
name|icheck
operator|=
operator|(
name|unsigned
name|short
operator|)
name|igchecksum
argument_list|(
name|zdata
argument_list|,
name|csize
argument_list|)
expr_stmt|;
comment|/* We're just about ready to go.  Wait until there is room in the      receiver's window for us to send the packet.  We do this now so      that we send the correct value for the last packet received.      Note that if iGsendseq == iGremote_ack, this means that the      sequence numbers are actually 8 apart, since the packet could not      have been acknowledged before it was sent; this can happen when      the window size is 7.  */
while|while
condition|(
name|iGsendseq
operator|==
name|iGremote_ack
operator|||
name|CSEQDIFF
argument_list|(
name|iGsendseq
argument_list|,
name|iGremote_ack
argument_list|)
operator|>
name|iGremote_winsize
condition|)
block|{
if|if
condition|(
operator|!
name|fgwait_for_packet
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|,
name|cGtimeout
argument_list|,
name|cGretries
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Ack all packets up to the next one, since the UUCP protocol      requires that all packets be acked in order.  */
while|while
condition|(
name|CSEQDIFF
argument_list|(
name|iGrecseq
argument_list|,
name|iGlocal_ack
argument_list|)
operator|>
literal|1
condition|)
block|{
name|iGlocal_ack
operator|=
name|INEXTSEQ
argument_list|(
name|iGlocal_ack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|RR
argument_list|,
name|iGlocal_ack
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|iGlocal_ack
operator|=
name|iGrecseq
expr_stmt|;
name|z
index|[
name|IFRAME_CONTROL
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|itt
operator|<<
literal|6
operator|)
operator||
operator|(
name|iGsendseq
operator|<<
literal|3
operator|)
operator||
name|iGrecseq
argument_list|)
expr_stmt|;
name|iGsendseq
operator|=
name|INEXTSEQ
argument_list|(
name|iGsendseq
argument_list|)
expr_stmt|;
name|icheck
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
literal|0xaaaa
operator|-
operator|(
name|icheck
operator|^
operator|(
name|z
index|[
name|IFRAME_CONTROL
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|)
operator|&
literal|0xffff
argument_list|)
operator|)
expr_stmt|;
name|z
index|[
name|IFRAME_CHECKLOW
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|icheck
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|z
index|[
name|IFRAME_CHECKHIGH
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|icheck
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|z
index|[
name|IFRAME_XOR
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|z
index|[
name|IFRAME_K
index|]
operator|^
name|z
index|[
name|IFRAME_CHECKLOW
index|]
operator|^
name|z
index|[
name|IFRAME_CHECKHIGH
index|]
operator|^
name|z
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
expr_stmt|;
comment|/* If we're waiting for acks of retransmitted packets, then don't      send this packet yet.  The other side may not be ready for it      yet.  Instead, code in fggot_ack will send the outstanding      packets when an ack is received.  */
operator|++
name|cGsent_packets
expr_stmt|;
if|if
condition|(
name|iGretransmit_seq
operator|!=
operator|-
literal|1
condition|)
block|{
operator|++
name|cGdelayed_packets
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fgsenddata: Sending packet %d (%d bytes)"
argument_list|,
name|CONTROL_XXX
argument_list|(
name|z
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|z
argument_list|,
name|CFRAMELEN
operator|+
name|csize
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recompute the control byte and checksum of a packet so that it    includes the correct packet acknowledgement.  This is called when a    packet is retransmitted to make sure the retransmission does not    confuse the other side.  It returns a pointer to the start of the    packet, skipping the bytes that may be unused at the start of    azGsendbuffers[iseq].  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zgadjust_ack
parameter_list|(
name|iseq
parameter_list|)
name|int
name|iseq
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|z
decl_stmt|;
name|unsigned
name|short
name|icheck
decl_stmt|;
name|z
operator|=
name|azGsendbuffers
index|[
name|iseq
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'\0'
condition|)
operator|++
name|z
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'\0'
condition|)
operator|++
name|z
expr_stmt|;
comment|/* If the received packet number is the same, there is nothing      to do.  */
if|if
condition|(
name|CONTROL_YYY
argument_list|(
name|z
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|iGrecseq
condition|)
return|return
name|z
return|;
comment|/* Get the old checksum.  */
name|icheck
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
name|z
index|[
name|IFRAME_CHECKHIGH
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|z
index|[
name|IFRAME_CHECKLOW
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|icheck
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
literal|0xaaaa
operator|-
name|icheck
operator|)
operator|^
operator|(
name|z
index|[
name|IFRAME_CONTROL
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|&
literal|0xffff
argument_list|)
operator|)
expr_stmt|;
comment|/* Update the control byte.  */
name|z
index|[
name|IFRAME_CONTROL
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|z
index|[
name|IFRAME_CONTROL
index|]
operator|&
operator|~
literal|07
operator|)
operator||
name|iGrecseq
argument_list|)
expr_stmt|;
comment|/* Create the new checksum.  */
name|icheck
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
literal|0xaaaa
operator|-
operator|(
name|icheck
operator|^
operator|(
name|z
index|[
name|IFRAME_CONTROL
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|)
operator|&
literal|0xffff
argument_list|)
operator|)
expr_stmt|;
name|z
index|[
name|IFRAME_CHECKLOW
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|icheck
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|z
index|[
name|IFRAME_CHECKHIGH
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|icheck
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Update the XOR byte.  */
name|z
index|[
name|IFRAME_XOR
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|z
index|[
name|IFRAME_K
index|]
operator|^
name|z
index|[
name|IFRAME_CHECKLOW
index|]
operator|^
name|z
index|[
name|IFRAME_CHECKHIGH
index|]
operator|^
name|z
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* Send a control packet.  These are fairly simple to construct.  It    seems reasonable to me that we should be able to send a control    packet at any time, even if the receive window is closed.  In    particular, we don't want to delay when sending a CLOSE control    message.  If I'm wrong, it can be changed easily enough.  */
end_comment

begin_function
specifier|static
name|boolean
name|fgsend_control
parameter_list|(
name|qdaemon
parameter_list|,
name|ixxx
parameter_list|,
name|iyyy
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|ixxx
decl_stmt|;
name|int
name|iyyy
decl_stmt|;
block|{
name|char
name|ab
index|[
name|CFRAMELEN
index|]
decl_stmt|;
name|int
name|ictl
decl_stmt|;
name|unsigned
name|short
name|icheck
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PROTO
argument_list|)
operator|||
operator|(
name|FDEBUGGING
argument_list|(
name|DEBUG_ABNORMAL
argument_list|)
operator|&&
name|ixxx
operator|!=
name|RR
operator|)
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fgsend_control: Sending control %s %d"
argument_list|,
name|azGcontrol
index|[
name|ixxx
index|]
argument_list|,
name|iyyy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ab
index|[
name|IFRAME_DLE
index|]
operator|=
name|DLE
expr_stmt|;
name|ab
index|[
name|IFRAME_K
index|]
operator|=
name|KCONTROL
expr_stmt|;
name|ictl
operator|=
operator|(
name|CONTROL
operator|<<
literal|6
operator|)
operator||
operator|(
name|ixxx
operator|<<
literal|3
operator|)
operator||
name|iyyy
expr_stmt|;
name|icheck
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|0xaaaa
operator|-
name|ictl
argument_list|)
expr_stmt|;
name|ab
index|[
name|IFRAME_CHECKLOW
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|icheck
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ab
index|[
name|IFRAME_CHECKHIGH
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|icheck
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ab
index|[
name|IFRAME_CONTROL
index|]
operator|=
operator|(
name|char
operator|)
name|ictl
expr_stmt|;
name|ab
index|[
name|IFRAME_XOR
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|ab
index|[
name|IFRAME_K
index|]
operator|^
name|ab
index|[
name|IFRAME_CHECKLOW
index|]
operator|^
name|ab
index|[
name|IFRAME_CHECKHIGH
index|]
operator|^
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|ab
argument_list|,
operator|(
name|size_t
operator|)
name|CFRAMELEN
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for data to come in.  This continues processing until a    complete file or command has been received.  */
end_comment

begin_function
name|boolean
name|fgwait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
return|return
name|fgwait_for_packet
argument_list|(
name|qdaemon
argument_list|,
name|FALSE
argument_list|,
name|cGtimeout
argument_list|,
name|cGretries
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get a packet.  This is called when we have nothing to send, but    want to wait for a packet to come in.  If freturncontrol is TRUE,    this will return after getting any control packet.  Otherwise, it    will continue to receive packets until a complete file or a    complete command has been received.  The timeout and the number of    retries are specified as arguments.  The function returns FALSE if    an error occurs or if cretries timeouts of ctimeout seconds were    exceeded.  */
end_comment

begin_function
specifier|static
name|boolean
name|fgwait_for_packet
parameter_list|(
name|qdaemon
parameter_list|,
name|freturncontrol
parameter_list|,
name|ctimeout
parameter_list|,
name|cretries
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
name|freturncontrol
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|int
name|cretries
decl_stmt|;
block|{
name|int
name|ctimeouts
decl_stmt|;
name|int
name|cgarbage
decl_stmt|;
name|int
name|cshort
decl_stmt|;
name|ctimeouts
operator|=
literal|0
expr_stmt|;
name|cgarbage
operator|=
literal|0
expr_stmt|;
name|cshort
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|fexit
decl_stmt|;
name|size_t
name|cneed
decl_stmt|;
name|boolean
name|ffound
decl_stmt|;
name|size_t
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|fgprocess_data
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|,
name|freturncontrol
argument_list|,
operator|&
name|fexit
argument_list|,
operator|&
name|cneed
argument_list|,
operator|&
name|ffound
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
condition|)
return|return
name|TRUE
return|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fgwait_for_packet: Need %lu bytes"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cneed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffound
condition|)
block|{
name|ctimeouts
operator|=
literal|0
expr_stmt|;
name|cgarbage
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cgarbage
operator|>
name|cGgarbage_data
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too much unrecognized data"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|ctimeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cgarbage
operator|+=
name|crec
expr_stmt|;
if|if
condition|(
name|crec
operator|!=
literal|0
condition|)
block|{
comment|/* If we don't get enough data twice in a row, we may have 	     dropped some data and still be looking for the end of a 	     large packet.  Incrementing iPrecstart will force 	     fgprocess_data to skip that packet and look through the 	     rest of the data.  In some situations, this will be a 	     mistake.  */
if|if
condition|(
name|crec
operator|>=
name|cneed
condition|)
name|cshort
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|cshort
expr_stmt|;
if|if
condition|(
name|cshort
operator|>
literal|1
condition|)
block|{
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|cshort
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The read timed out.  If we have an unacknowledged packet, 	     send it again.  Otherwise, send an RJ with the last 	     packet we received correctly.  */
operator|++
name|ctimeouts
expr_stmt|;
if|if
condition|(
name|ctimeouts
operator|>
name|cretries
condition|)
block|{
if|if
condition|(
name|cretries
operator|>
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for packet"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|INEXTSEQ
argument_list|(
name|iGremote_ack
argument_list|)
operator|!=
name|iGsendseq
condition|)
block|{
name|int
name|inext
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
name|inext
operator|=
name|INEXTSEQ
argument_list|(
name|iGremote_ack
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgwait_for_packet: Resending packet %d"
argument_list|,
name|inext
argument_list|)
expr_stmt|;
operator|++
name|cGresent_packets
expr_stmt|;
name|zsend
operator|=
name|zgadjust_ack
argument_list|(
name|inext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zsend
argument_list|,
name|CFRAMELEN
operator|+
name|CPACKLEN
argument_list|(
name|zsend
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iGretransmit_seq
operator|=
name|inext
expr_stmt|;
block|}
else|else
block|{
comment|/* Send all pending acks first, to avoid confusing 		 the other side.  */
if|if
condition|(
name|iGlocal_ack
operator|!=
name|iGrecseq
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_acks
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|RJ
argument_list|,
name|iGrecseq
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send acks for all packets we haven't acked yet.  */
end_comment

begin_function
specifier|static
name|boolean
name|fgsend_acks
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
while|while
condition|(
name|iGlocal_ack
operator|!=
name|iGrecseq
condition|)
block|{
name|iGlocal_ack
operator|=
name|INEXTSEQ
argument_list|(
name|iGlocal_ack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|RR
argument_list|,
name|iGlocal_ack
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle an ack of a packet.  According to Hanrahan's paper, this    acknowledges all previous packets.  If this is an ack for a    retransmitted packet, continue by resending up to two more packets    following the retransmitted one.  This should recover quickly from    a line glitch, while avoiding the problem of continual    retransmission.  */
end_comment

begin_function
specifier|static
name|boolean
name|fggot_ack
parameter_list|(
name|qdaemon
parameter_list|,
name|iack
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|iack
decl_stmt|;
block|{
name|int
name|inext
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
comment|/* We only decrement the error level if we are not retransmitting      packets.  We want to catch a sudden downgrade in line quality as      fast as possible.  */
if|if
condition|(
name|cGerror_level
operator|>
literal|0
operator|&&
name|iGretransmit_seq
operator|==
operator|-
literal|1
operator|&&
name|cGsent_packets
operator|%
name|cGerror_decay
operator|==
literal|0
condition|)
operator|--
name|cGerror_level
expr_stmt|;
name|cGexpect_bad_order
operator|=
literal|0
expr_stmt|;
comment|/* Each time packet 0 is acknowledged, we call uwindow_acked since a      new window has been acked.  */
if|if
condition|(
name|iack
operator|<
name|iGremote_ack
condition|)
name|uwindow_acked
argument_list|(
name|qdaemon
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|iGremote_ack
operator|=
name|iack
expr_stmt|;
if|if
condition|(
name|iGretransmit_seq
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
name|inext
operator|=
name|INEXTSEQ
argument_list|(
name|iGretransmit_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|inext
operator|==
name|iGsendseq
condition|)
name|iGretransmit_seq
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fggot_ack: Sending packet %d"
argument_list|,
name|inext
argument_list|)
expr_stmt|;
operator|++
name|cGresent_packets
expr_stmt|;
name|zsend
operator|=
name|zgadjust_ack
argument_list|(
name|inext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zsend
argument_list|,
name|CFRAMELEN
operator|+
name|CPACKLEN
argument_list|(
name|zsend
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|inext
operator|=
name|INEXTSEQ
argument_list|(
name|inext
argument_list|)
expr_stmt|;
if|if
condition|(
name|inext
operator|==
name|iGsendseq
condition|)
name|iGretransmit_seq
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fggot_ack: Sending packet %d"
argument_list|,
name|inext
argument_list|)
expr_stmt|;
operator|++
name|cGresent_packets
expr_stmt|;
name|zsend
operator|=
name|zgadjust_ack
argument_list|(
name|inext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zsend
argument_list|,
name|CFRAMELEN
operator|+
name|CPACKLEN
argument_list|(
name|zsend
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iGretransmit_seq
operator|=
name|inext
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if we've received more than the permitted number of errors.  If    we receive a bad packet, we can expect a window full (less one) of    out of order packets to follow, so we discount cGbad_order    accordingly.  */
end_comment

begin_function
specifier|static
name|boolean
name|fgcheck_errors
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
if|if
condition|(
name|cGerror_level
operator|>
name|cGmax_errors
operator|&&
name|cGmax_errors
operator|>=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many '%c' protocol errors"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Process the receive buffer into a data packet, if possible.  All    control packets are handled here.  When a data packet is received,    fgprocess_data calls fgot_data with the data; if that sets its    pfexit argument to TRUE fgprocess_data will set *pfexit to TRUE and    return TRUE.  Also, if the freturncontrol argument is TRUE    fgprocess_data will set *pfexit to TRUE and return TRUE.  Otherwise    fgprocess_data will continue trying to process data.  If some error    occurs, fgprocess_data will return FALSE.  If there is not enough    data to form a complete packet, then *pfexit will be set to FALSE,    *pcneed will be set to the number of bytes needed to form a    complete packet (unless pcneed is NULL) and fgprocess_data will    return TRUE.  If this function found a data packet, and pffound is    not NULL, it will set *pffound to TRUE; this can be used to tell    valid data from an endless stream of garbage and control packets.    If fdoacks is TRUE, received packets will be acknowledged;    otherwise they must be acknowledged later.  */
end_comment

begin_function
specifier|static
name|boolean
name|fgprocess_data
parameter_list|(
name|qdaemon
parameter_list|,
name|fdoacks
parameter_list|,
name|freturncontrol
parameter_list|,
name|pfexit
parameter_list|,
name|pcneed
parameter_list|,
name|pffound
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
name|fdoacks
decl_stmt|;
name|boolean
name|freturncontrol
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
name|size_t
modifier|*
name|pcneed
decl_stmt|;
name|boolean
modifier|*
name|pffound
decl_stmt|;
block|{
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pffound
operator|!=
name|NULL
condition|)
operator|*
name|pffound
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
name|char
name|ab
index|[
name|CFRAMELEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iget
decl_stmt|,
name|cwant
decl_stmt|;
name|unsigned
name|short
name|ihdrcheck
decl_stmt|,
name|idatcheck
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfirst
decl_stmt|,
modifier|*
name|zsecond
decl_stmt|;
name|int
name|cfirst
decl_stmt|,
name|csecond
decl_stmt|;
name|boolean
name|fduprr
decl_stmt|;
comment|/* Look for the DLE which must start a packet.  */
if|if
condition|(
name|abPrecbuf
index|[
name|iPrecstart
index|]
operator|!=
name|DLE
condition|)
block|{
name|char
modifier|*
name|zdle
decl_stmt|;
name|cfirst
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|<
literal|0
condition|)
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
name|zdle
operator|=
name|memchr
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|DLE
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdle
operator|==
name|NULL
condition|)
block|{
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|cfirst
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
comment|/* We don't need % CRECBUFLEN here because zdle - (abPrecbuf 	     + iPrecstart)< cfirst<= CRECBUFLEN - iPrecstart.  */
name|iPrecstart
operator|+=
name|zdle
operator|-
operator|(
name|abPrecbuf
operator|+
name|iPrecstart
operator|)
expr_stmt|;
block|}
comment|/* Get the first six bytes into ab.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iget
operator|=
name|iPrecstart
init|;
name|i
operator|<
name|CFRAMELEN
operator|&&
name|iget
operator|!=
name|iPrecend
condition|;
name|i
operator|++
operator|,
name|iget
operator|=
operator|(
name|iget
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
control|)
name|ab
index|[
name|i
index|]
operator|=
name|abPrecbuf
index|[
name|iget
index|]
expr_stmt|;
comment|/* If there aren't six bytes, there is no packet.  */
if|if
condition|(
name|i
operator|<
name|CFRAMELEN
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CFRAMELEN
operator|-
name|i
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Make sure these six bytes start a packet.  The check on 	 IFRAME_DLE is basically a debugging check, since the above 	 code should have ensured that it will never fail.  If this is 	 not the start of a packet, bump iPrecstart and loop around to 	 look for another DLE.  */
if|if
condition|(
name|ab
index|[
name|IFRAME_DLE
index|]
operator|!=
name|DLE
operator|||
name|ab
index|[
name|IFRAME_K
index|]
operator|<
literal|1
operator|||
name|ab
index|[
name|IFRAME_K
index|]
operator|>
literal|9
operator|||
name|ab
index|[
name|IFRAME_XOR
index|]
operator|!=
operator|(
name|ab
index|[
name|IFRAME_K
index|]
operator|^
name|ab
index|[
name|IFRAME_CHECKLOW
index|]
operator|^
name|ab
index|[
name|IFRAME_CHECKHIGH
index|]
operator|^
name|ab
index|[
name|IFRAME_CONTROL
index|]
operator|)
operator|||
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|ALTCHAN
condition|)
block|{
operator|++
name|cGbad_hdr
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Bad header: K %d TT %d XOR byte %d calc %d"
argument_list|,
name|ab
index|[
name|IFRAME_K
index|]
operator|&
literal|0xff
argument_list|,
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|,
name|ab
index|[
name|IFRAME_XOR
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|ab
index|[
name|IFRAME_K
index|]
operator|^
name|ab
index|[
name|IFRAME_CHECKLOW
index|]
operator|^
name|ab
index|[
name|IFRAME_CHECKHIGH
index|]
operator|^
name|ab
index|[
name|IFRAME_CONTROL
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgcheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
comment|/* The zfirst and cfirst pair point to the first set of data for 	 this packet; the zsecond and csecond point to the second set, 	 in case the packet wraps around the end of the buffer.  */
name|zfirst
operator|=
name|abPrecbuf
operator|+
name|iPrecstart
operator|+
name|CFRAMELEN
expr_stmt|;
name|cfirst
operator|=
literal|0
expr_stmt|;
name|zsecond
operator|=
name|NULL
expr_stmt|;
name|csecond
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ab
index|[
name|IFRAME_K
index|]
operator|==
name|KCONTROL
condition|)
block|{
comment|/* This is a control packet.  It should not have any data.  */
if|if
condition|(
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|!=
name|CONTROL
condition|)
block|{
operator|++
name|cGbad_hdr
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Bad header: control packet with data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgcheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
name|idatcheck
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|0xaaaa
operator|-
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
expr_stmt|;
name|cwant
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|cinbuf
decl_stmt|;
name|unsigned
name|short
name|icheck
decl_stmt|;
comment|/* This is a data packet.  It should not be type CONTROL.  */
if|if
condition|(
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|CONTROL
condition|)
block|{
operator|++
name|cGbad_hdr
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Bad header: data packet is type CONTROL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgcheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
name|cinbuf
operator|-=
name|CFRAMELEN
expr_stmt|;
comment|/* Make sure we have enough data.  If we don't, wait for 	     more.  */
name|cwant
operator|=
operator|(
name|int
operator|)
name|CPACKLEN
argument_list|(
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|cwant
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|cwant
operator|-
name|cinbuf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Set up the data pointers and compute the checksum.  */
if|if
condition|(
name|iPrecend
operator|>=
name|iPrecstart
condition|)
name|cfirst
operator|=
name|cwant
expr_stmt|;
else|else
block|{
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
operator|(
name|iPrecstart
operator|+
name|CFRAMELEN
operator|)
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>=
name|cwant
condition|)
name|cfirst
operator|=
name|cwant
expr_stmt|;
elseif|else
if|if
condition|(
name|cfirst
operator|>
literal|0
condition|)
block|{
name|zsecond
operator|=
name|abPrecbuf
expr_stmt|;
name|csecond
operator|=
name|cwant
operator|-
name|cfirst
expr_stmt|;
block|}
else|else
block|{
comment|/* Here cfirst is non-positive, so subtracting from 		     abPrecbuf will actually skip the appropriate number 		     of bytes at the start of abPrecbuf.  */
name|zfirst
operator|=
name|abPrecbuf
operator|-
name|cfirst
expr_stmt|;
name|cfirst
operator|=
name|cwant
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csecond
operator|==
literal|0
condition|)
name|icheck
operator|=
operator|(
name|unsigned
name|short
operator|)
name|igchecksum
argument_list|(
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|)
expr_stmt|;
else|else
name|icheck
operator|=
operator|(
name|unsigned
name|short
operator|)
name|igchecksum2
argument_list|(
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|,
name|zsecond
argument_list|,
operator|(
name|size_t
operator|)
name|csecond
argument_list|)
expr_stmt|;
name|idatcheck
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
literal|0xaaaa
operator|-
operator|(
name|icheck
operator|^
operator|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|)
operator|&
literal|0xffff
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|ihdrcheck
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
name|ab
index|[
name|IFRAME_CHECKHIGH
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ab
index|[
name|IFRAME_CHECKLOW
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ihdrcheck
operator|!=
name|idatcheck
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Bad checksum: header 0x%x, data 0x%x"
argument_list|,
name|ihdrcheck
argument_list|,
name|idatcheck
argument_list|)
expr_stmt|;
operator|++
name|cGbad_checksum
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
if|if
condition|(
operator|!
name|fgcheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the checksum failed for a data packet, then if it was 	     the one we were expecting send an RJ, otherwise ignore 	     it.  Previously if this code got the wrong packet number 	     it would send an RR, but that may confuse some Telebit 	     modems and it doesn't help in any case since the receiver 	     will probably just ignore the RR as a duplicate (that's 	     basically what this code does).  If we totally missed the 	     packet we will time out and send an RJ in the function 	     fgwait_for_packet above.  */
if|if
condition|(
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|!=
name|CONTROL
condition|)
block|{
comment|/* Make sure we've acked everything up to this point.  */
if|if
condition|(
name|iGrecseq
operator|!=
name|iGlocal_ack
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_acks
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If this is the packet we wanted, tell the sender that 		 it failed.  */
if|if
condition|(
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|INEXTSEQ
argument_list|(
name|iGrecseq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|RJ
argument_list|,
name|iGrecseq
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cGexpect_bad_order
operator|+=
name|iGrequest_winsize
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* We can't skip the packet data after this, because if we 	     have lost incoming bytes the next DLE will be somewhere 	     in what we thought was the packet data.  */
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
comment|/* We have a packet; remove the processed bytes from the receive 	 buffer.  */
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|cwant
operator|+
name|CFRAMELEN
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
comment|/* Store the control byte for the handshake routines.  */
name|iGpacket_control
operator|=
name|ab
index|[
name|IFRAME_CONTROL
index|]
operator|&
literal|0xff
expr_stmt|;
comment|/* Annoyingly, some UUCP packages appear to send an RR packet 	 rather than an RJ packet when they want a packet to be 	 resent.  If we get a duplicate RR and we've never seen an RJ, 	 we treat the RR as an RJ.  */
name|fduprr
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cGremote_rejects
operator|==
literal|0
operator|&&
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|CONTROL
operator|&&
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|RR
operator|&&
name|iGremote_ack
operator|==
name|CONTROL_YYY
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|&&
name|INEXTSEQ
argument_list|(
name|iGremote_ack
argument_list|)
operator|!=
name|iGsendseq
operator|&&
name|iGretransmit_seq
operator|==
operator|-
literal|1
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Treating duplicate RR as RJ"
argument_list|)
expr_stmt|;
name|fduprr
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Update the received sequence number from the yyy field of a 	 data packet (if it is the one we are expecting) or an RR 	 control packet.  If we've been delaying sending packets until 	 we received an ack, this may send out some packets.  */
if|if
condition|(
operator|(
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|!=
name|CONTROL
operator|&&
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|INEXTSEQ
argument_list|(
name|iGrecseq
argument_list|)
operator|)
operator|||
operator|(
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|RR
operator|&&
operator|!
name|fduprr
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fggot_ack
argument_list|(
name|qdaemon
argument_list|,
name|CONTROL_YYY
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If this isn't a control message, make sure we have received 	 the expected packet sequence number, acknowledge the packet 	 if it's the right one, and process the data.  */
if|if
condition|(
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|!=
name|CONTROL
condition|)
block|{
if|if
condition|(
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|!=
name|INEXTSEQ
argument_list|(
name|iGrecseq
argument_list|)
condition|)
block|{
comment|/* We got the wrong packet number.  */
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Got packet %d; expected %d"
argument_list|,
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|,
name|INEXTSEQ
argument_list|(
name|iGrecseq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cGexpect_bad_order
operator|>
literal|0
condition|)
operator|--
name|cGexpect_bad_order
expr_stmt|;
else|else
block|{
operator|++
name|cGbad_order
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
if|if
condition|(
operator|!
name|fgcheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* This code used to send an RR to encourage the other 		 side to get back in synch, but that may confuse some 		 Telebit modems and does little good in any case, 		 since the other side will probably just ignore it 		 anyhow (that's what this code does).  */
continue|continue;
block|}
comment|/* We got the packet we expected.  */
operator|++
name|cGrec_packets
expr_stmt|;
if|if
condition|(
name|cGerror_level
operator|>
literal|0
operator|&&
name|cGrec_packets
operator|%
name|cGerror_decay
operator|==
literal|0
condition|)
operator|--
name|cGerror_level
expr_stmt|;
name|cGexpect_bad_order
operator|=
literal|0
expr_stmt|;
name|iGrecseq
operator|=
name|INEXTSEQ
argument_list|(
name|iGrecseq
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fgprocess_data: Got packet %d"
argument_list|,
name|iGrecseq
argument_list|)
expr_stmt|;
comment|/* Tell the caller that we found something.  */
if|if
condition|(
name|pffound
operator|!=
name|NULL
condition|)
operator|*
name|pffound
operator|=
name|TRUE
expr_stmt|;
comment|/* If we are supposed to do acknowledgements here, send back 	     an RR packet.  */
if|if
condition|(
name|fdoacks
condition|)
block|{
if|if
condition|(
operator|!
name|fgsend_acks
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If this is a short data packet, adjust the data pointers 	     and lengths.  */
if|if
condition|(
name|CONTROL_TT
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|==
name|SHORTDATA
condition|)
block|{
name|int
name|cshort
decl_stmt|,
name|cmove
decl_stmt|;
if|if
condition|(
operator|(
name|zfirst
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|cshort
operator|=
name|zfirst
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
name|cmove
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|cbyte2
decl_stmt|;
if|if
condition|(
name|cfirst
operator|>
literal|1
condition|)
name|cbyte2
operator|=
name|zfirst
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
else|else
name|cbyte2
operator|=
name|zsecond
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
name|cshort
operator|=
operator|(
name|zfirst
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator|+
operator|(
name|cbyte2
operator|<<
literal|7
operator|)
expr_stmt|;
name|cmove
operator|=
literal|2
expr_stmt|;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fgprocess_data: Packet short by %d"
argument_list|,
name|cshort
argument_list|)
expr_stmt|;
comment|/* Adjust the start of the buffer for the bytes used 		 by the count.  */
if|if
condition|(
name|cfirst
operator|>
name|cmove
condition|)
block|{
name|zfirst
operator|+=
name|cmove
expr_stmt|;
name|cfirst
operator|-=
name|cmove
expr_stmt|;
block|}
else|else
block|{
name|zfirst
operator|=
name|zsecond
operator|+
operator|(
name|cmove
operator|-
name|cfirst
operator|)
expr_stmt|;
name|cfirst
operator|=
name|csecond
operator|-
operator|(
name|cmove
operator|-
name|cfirst
operator|)
expr_stmt|;
name|csecond
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Adjust the length of the buffer for the bytes we are 		 not supposed to consider.  */
name|cshort
operator|-=
name|cmove
expr_stmt|;
if|if
condition|(
name|csecond
operator|>=
name|cshort
condition|)
name|csecond
operator|-=
name|cshort
expr_stmt|;
else|else
block|{
name|cfirst
operator|-=
name|cshort
operator|-
name|csecond
expr_stmt|;
name|csecond
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
comment|/* This should not happen, but just in case.  */
if|if
condition|(
name|cfirst
operator|<
literal|0
condition|)
name|cfirst
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|,
name|zsecond
argument_list|,
operator|(
name|size_t
operator|)
name|csecond
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|INEXTSEQ
argument_list|(
name|iGremote_ack
argument_list|)
operator|==
name|iGsendseq
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If fgot_data told us that we were finished, get out.  */
if|if
condition|(
operator|*
name|pfexit
condition|)
return|return
name|TRUE
return|;
comment|/* If we've been asked to return control packets, get out 	     now.  */
if|if
condition|(
name|freturncontrol
condition|)
block|{
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
continue|continue;
block|}
comment|/* Handle control messages here. */
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PROTO
argument_list|)
operator|||
operator|(
name|FDEBUGGING
argument_list|(
name|DEBUG_ABNORMAL
argument_list|)
operator|&&
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
operator|!=
name|RR
operator|)
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fgprocess_data: Got control %s %d"
argument_list|,
name|azGcontrol
index|[
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
index|]
argument_list|,
name|CONTROL_YYY
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|CONTROL_XXX
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
condition|)
block|{
case|case
name|CLOSE
case|:
comment|/* The other side has closed the connection.  */
if|if
condition|(
name|fLog_sighup
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Received unexpected CLOSE packet"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgsend_control
argument_list|(
name|qdaemon
argument_list|,
name|CLOSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
case|case
name|RR
case|:
comment|/* Acknowledge receipt of a packet.  This was already handled 	     above, unless we are treating it as RJ.  */
if|if
condition|(
operator|!
name|fduprr
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|RJ
case|:
comment|/* The other side dropped a packet.  Begin retransmission with 	     the packet following the one acknowledged.  We don't 	     retransmit the packets immediately, but instead wait 	     for the first one to be acked.  This prevents us from 	     sending an entire window several times if we get several 	     RJ packets.  */
name|iGremote_ack
operator|=
name|CONTROL_YYY
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
expr_stmt|;
name|iGretransmit_seq
operator|=
name|INEXTSEQ
argument_list|(
name|iGremote_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|iGretransmit_seq
operator|==
name|iGsendseq
condition|)
name|iGretransmit_seq
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zpack
decl_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Remote reject: next %d resending %d"
argument_list|,
name|iGsendseq
argument_list|,
name|iGretransmit_seq
argument_list|)
expr_stmt|;
operator|++
name|cGresent_packets
expr_stmt|;
if|if
condition|(
name|fduprr
condition|)
operator|++
name|cGremote_duprrs
expr_stmt|;
else|else
operator|++
name|cGremote_rejects
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
if|if
condition|(
operator|!
name|fgcheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zpack
operator|=
name|zgadjust_ack
argument_list|(
name|iGretransmit_seq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zpack
argument_list|,
name|CFRAMELEN
operator|+
name|CPACKLEN
argument_list|(
name|zpack
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|SRJ
case|:
comment|/* Selectively reject a particular packet.  This is not used 	     by UUCP, but it's easy to support.  */
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgprocess_data: Selective reject of %d"
argument_list|,
name|CONTROL_YYY
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|zpack
decl_stmt|;
operator|++
name|cGresent_packets
expr_stmt|;
operator|++
name|cGremote_rejects
expr_stmt|;
operator|++
name|cGerror_level
expr_stmt|;
name|zpack
operator|=
name|zgadjust_ack
argument_list|(
name|CONTROL_YYY
argument_list|(
name|ab
index|[
name|IFRAME_CONTROL
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zpack
argument_list|,
name|CFRAMELEN
operator|+
name|CPACKLEN
argument_list|(
name|zpack
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|INITC
case|:
case|case
name|INITB
case|:
case|case
name|INITA
case|:
comment|/* Ignore attempts to reinitialize.  */
break|break;
block|}
comment|/* If we've been asked to return control packets, get out.  */
if|if
condition|(
name|freturncontrol
condition|)
block|{
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Loop around to look for the next packet, if any.  */
block|}
comment|/* There is no data left in the receive buffer.  */
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CFRAMELEN
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the 'g' protocol checksum.  This is unfortunately rather    awkward.  This is the most time consuming code in the entire    program.  It's also not a great checksum, since it can be fooled    by some single bit errors.  */
end_comment

begin_comment
comment|/* Sorry about this knavery, but it speeds up the VAX code    significantly.  It would be better to rewrite the whole routine in    assembler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__vax__
end_ifdef

begin_define
define|#
directive|define
name|VAX_ASM
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX_ASM
end_if

begin_define
define|#
directive|define
name|ROTATE
parameter_list|(
name|i
parameter_list|)
define|\
value|asm ("cvtwl %1,%0\n\trotl $1,%0,%0" : "=g" (i) : "g" (i))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ROTATE
parameter_list|(
name|i
parameter_list|)
value|i += i + ((i& 0x8000)>> 15)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ITERATION
define|\
comment|/* Rotate ichk1 left.  */
define|\
value|ROTATE (ichk1); \  \
comment|/* The guts of the checksum.  */
value|\       b = BUCHAR (*z++); \       if (b != 0) \ 	{ \ 	  ichk1&= 0xffff; \ 	  ichk1 += b; \ 	  ichk2 += ichk1 ^ c; \ 	  if ((ichk1>> 16) != 0) \ 	    ichk1 ^= ichk2; \ 	} \       else \ 	{ \ 	  ichk2 += ichk1 ^ c; \ 	  ichk1 ^= ichk2; \ 	} \  \       --c
end_define

begin_function
specifier|static
name|int
name|igchecksum
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|register
name|size_t
name|c
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|ichk1
decl_stmt|,
name|ichk2
decl_stmt|;
name|ichk1
operator|=
literal|0xffff
expr_stmt|;
name|ichk2
operator|=
literal|0
expr_stmt|;
do|do
block|{
specifier|register
name|unsigned
name|int
name|b
decl_stmt|;
name|ITERATION
expr_stmt|;
name|ITERATION
expr_stmt|;
name|ITERATION
expr_stmt|;
name|ITERATION
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>
literal|0
condition|)
do|;
return|return
name|ichk1
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* We use a separate function compute the checksum if the block is    split around the end of the receive buffer since it occurs much    less frequently and the checksum is already high up in the    profiles.  These functions are almost identical, and this one    actually only has a few more instructions in the inner loop.  */
end_comment

begin_function
specifier|static
name|int
name|igchecksum2
parameter_list|(
name|zfirst
parameter_list|,
name|cfirst
parameter_list|,
name|zsecond
parameter_list|,
name|csecond
parameter_list|)
specifier|const
name|char
modifier|*
name|zfirst
decl_stmt|;
name|size_t
name|cfirst
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsecond
decl_stmt|;
name|size_t
name|csecond
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|ichk1
decl_stmt|,
name|ichk2
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|register
name|size_t
name|c
decl_stmt|;
name|z
operator|=
name|zfirst
expr_stmt|;
name|c
operator|=
name|cfirst
operator|+
name|csecond
expr_stmt|;
name|ichk1
operator|=
literal|0xffff
expr_stmt|;
name|ichk2
operator|=
literal|0
expr_stmt|;
do|do
block|{
specifier|register
name|unsigned
name|int
name|b
decl_stmt|;
name|ITERATION
expr_stmt|;
comment|/* If the first buffer has been finished, switch to the second.  */
operator|--
name|cfirst
expr_stmt|;
if|if
condition|(
name|cfirst
operator|==
literal|0
condition|)
name|z
operator|=
name|zsecond
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>
literal|0
condition|)
do|;
return|return
name|ichk1
operator|&
literal|0xffff
return|;
block|}
end_function

end_unit

