begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* prote.c    The 'e' protocol.     Copyright (C) 1991, 1992, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|prote_rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This implementation is based on my implementation of the 't'    protocol, which is fairly similar.  The main difference between the    protocols seems to be that 't' breaks the file into packets and    transmits the size of the packet with each packet, whereas 'e'    sends the size of the entire file and then sends all the data in a    single enormous packet.     The 'e' protocol does no error checking whatsoever and thus    requires an end-to-end verified eight bit communication line, such    as is provided by TCP.  Using it with a modem is inadvisable, since    errors can occur between the modem and the computer.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The buffer size we use.  */
end_comment

begin_define
define|#
directive|define
name|CEBUFSIZE
value|(CRECBUFLEN / 2)
end_define

begin_comment
comment|/* The size of the initial file size message.  */
end_comment

begin_define
define|#
directive|define
name|CEFRAMELEN
value|(20)
end_define

begin_comment
comment|/* A pointer to the buffer we will use.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zEbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are receiving a file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fEfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of bytes we have left to send or receive.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cEbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The timeout we use.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cEtimeout
init|=
literal|120
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uuconf_cmdtab
name|asEproto_params
index|[]
init|=
block|{
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cEtimeout
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|feprocess_data
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
operator|*
name|pfexit
operator|,
name|size_t
operator|*
name|pcneed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start the protocol.  */
end_comment

begin_function
name|boolean
name|festart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
operator|*
name|pzlog
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|PARITYSETTING_NONE
argument_list|,
name|STRIPSETTING_EIGHTBITS
argument_list|,
name|XONXOFF_OFF
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zEbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CEBUFSIZE
argument_list|)
expr_stmt|;
name|fEfile
operator|=
name|FALSE
expr_stmt|;
name|usysdep_sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stop the protocol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|feshutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zEbuf
argument_list|)
expr_stmt|;
name|zEbuf
operator|=
name|NULL
expr_stmt|;
name|cEtimeout
operator|=
literal|120
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a command string.  We send everything up to and including the    null byte.   */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fesendcmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fesendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|z
argument_list|,
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get space to be filled with data.  We provide a buffer which has    20 bytes at the start available to hold the length.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|zegetspace
parameter_list|(
name|qdaemon
parameter_list|,
name|pclen
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|CEBUFSIZE
expr_stmt|;
return|return
name|zEbuf
return|;
block|}
end_function

begin_comment
comment|/* Send out some data.  We are allowed to modify the 20 bytes    preceding the buffer.  This allows us to send the entire block with    header bytes in a single call.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
name|boolean
name|fesenddata
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
comment|/* Keep track of the number of bytes we send out to make sure it all      adds up.  */
name|cEbytes
operator|-=
name|cdata
expr_stmt|;
if|if
condition|(
name|cEbytes
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Protocol 'e' internal error"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* We pass FALSE to fsend_data since we don't expect the other side      to be sending us anything just now.  */
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process data and return the amount we need in *pfneed.  */
end_comment

begin_function
specifier|static
name|boolean
name|feprocess_data
parameter_list|(
name|qdaemon
parameter_list|,
name|pfexit
parameter_list|,
name|pcneed
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
name|size_t
modifier|*
name|pcneed
decl_stmt|;
block|{
name|int
name|cinbuf
decl_stmt|,
name|cfirst
decl_stmt|,
name|clen
decl_stmt|;
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
operator|!
name|fEfile
condition|)
block|{
comment|/* We are not receiving a file.  Commands continue up to a null 	 byte.  */
while|while
condition|(
name|cinbuf
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|pnull
decl_stmt|;
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
name|cinbuf
condition|)
name|cfirst
operator|=
name|cinbuf
expr_stmt|;
name|pnull
operator|=
name|memchr
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnull
operator|!=
name|NULL
condition|)
name|cfirst
operator|=
name|pnull
operator|-
operator|(
name|abPrecbuf
operator|+
name|iPrecstart
operator|)
operator|+
literal|1
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"feprocess_data: Got %d command bytes"
argument_list|,
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|cfirst
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
operator|*
name|pfexit
condition|)
return|return
name|TRUE
return|;
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
block|}
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Here we are receiving a file.  We want cEbytes in total.  If we      don't have cEbytes yet, we have to get it first.  */
if|if
condition|(
name|cEbytes
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|ab
index|[
name|CEFRAMELEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|CEFRAMELEN
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CEFRAMELEN
operator|-
name|cinbuf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>=
name|CEFRAMELEN
condition|)
name|memcpy
argument_list|(
name|ab
argument_list|,
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
operator|(
name|size_t
operator|)
name|CEFRAMELEN
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|ab
argument_list|,
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ab
operator|+
name|cfirst
argument_list|,
name|abPrecbuf
argument_list|,
operator|(
name|size_t
operator|)
name|CEFRAMELEN
operator|-
name|cfirst
argument_list|)
expr_stmt|;
block|}
name|ab
index|[
name|CEFRAMELEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cEbytes
operator|=
name|strtol
argument_list|(
name|ab
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|CEFRAMELEN
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|cEbytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|pfexit
condition|)
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Here we can read real data for the file.  */
while|while
condition|(
name|cinbuf
operator|>
literal|0
condition|)
block|{
name|clen
operator|=
name|cinbuf
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|clen
operator|>
name|cEbytes
condition|)
name|clen
operator|=
operator|(
name|int
operator|)
name|cEbytes
expr_stmt|;
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
name|clen
condition|)
name|cfirst
operator|=
name|clen
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"feprocess_data: Got %d data bytes"
argument_list|,
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|,
name|abPrecbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|clen
operator|-
name|cfirst
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|clen
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|cEbytes
operator|-=
name|clen
expr_stmt|;
if|if
condition|(
name|cEbytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|pfexit
condition|)
return|return
name|TRUE
return|;
block|}
name|cinbuf
operator|-=
name|clen
expr_stmt|;
block|}
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cEbytes
operator|>
name|CRECBUFLEN
operator|/
literal|2
condition|)
operator|*
name|pcneed
operator|=
name|CRECBUFLEN
operator|/
literal|2
expr_stmt|;
else|else
operator|*
name|pcneed
operator|=
operator|(
name|int
operator|)
name|cEbytes
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for data to come in and process it until we've reached the end    of a command or a file.  */
end_comment

begin_function
name|boolean
name|fewait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|fexit
decl_stmt|;
name|size_t
name|cneed
decl_stmt|,
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|feprocess_data
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|fexit
argument_list|,
operator|&
name|cneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|cEtimeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for data"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File level routine, to handle transferring the amount of data and    to set fEfile correctly.  */
end_comment

begin_function
name|boolean
name|fefile
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|,
name|fstart
parameter_list|,
name|fsend
parameter_list|,
name|cbytes
parameter_list|,
name|pfhandled
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|boolean
name|fstart
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|boolean
modifier|*
name|pfhandled
decl_stmt|;
block|{
operator|*
name|pfhandled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fstart
condition|)
block|{
if|if
condition|(
name|fsend
condition|)
block|{
name|char
name|ab
index|[
name|CEFRAMELEN
index|]
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"Protocol 'e' starting to send %ld bytes"
argument_list|,
name|cbytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ab
argument_list|,
operator|(
name|size_t
operator|)
name|CEFRAMELEN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%ld"
argument_list|,
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|ab
argument_list|,
operator|(
name|size_t
operator|)
name|CEFRAMELEN
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cEbytes
operator|=
name|cbytes
expr_stmt|;
block|}
else|else
block|{
name|cEbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|fEfile
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fsend
condition|)
name|fEfile
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|cEbytes
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Protocol 'e' internal error: %ld bytes left over"
argument_list|,
name|cEbytes
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

