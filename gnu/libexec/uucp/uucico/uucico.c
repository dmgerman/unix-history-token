begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uucico.c    This is the main UUCP communication program.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|uucico_rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONG_MAX
value|2147483647L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_if
if|#
directive|if
name|HAVE_ENCRYPTED_PASSWORDS
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|crypt
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Coherent already had a different meaning for the -c option.  What a    pain.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__COHERENT__
end_ifdef

begin_define
define|#
directive|define
name|COHERENT_C_OPTION
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COHERENT_C_OPTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Define the known protocols.  */
end_comment

begin_define
define|#
directive|define
name|TCP_PROTO
define|\
value|(UUCONF_RELIABLE_ENDTOEND \    | UUCONF_RELIABLE_RELIABLE \    | UUCONF_RELIABLE_EIGHT)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sprotocol
name|asProtocols
index|[]
init|=
block|{
block|{
literal|'t'
block|,
name|TCP_PROTO
block|,
literal|1
block|,
name|TRUE
block|,
name|asTproto_params
block|,
name|ftstart
block|,
name|ftshutdown
block|,
name|ftsendcmd
block|,
name|ztgetspace
block|,
name|ftsenddata
block|,
name|ftwait
block|,
name|ftfile
block|}
block|,
block|{
literal|'e'
block|,
name|TCP_PROTO
block|,
literal|1
block|,
name|TRUE
block|,
name|asEproto_params
block|,
name|festart
block|,
name|feshutdown
block|,
name|fesendcmd
block|,
name|zegetspace
block|,
name|fesenddata
block|,
name|fewait
block|,
name|fefile
block|}
block|,
block|{
literal|'i'
block|,
name|UUCONF_RELIABLE_EIGHT
block|,
literal|7
block|,
name|TRUE
block|,
name|asIproto_params
block|,
name|fistart
block|,
name|fishutdown
block|,
name|fisendcmd
block|,
name|zigetspace
block|,
name|fisenddata
block|,
name|fiwait
block|,
name|NULL
block|}
block|,
block|{
literal|'a'
block|,
name|UUCONF_RELIABLE_EIGHT
block|,
literal|1
block|,
name|TRUE
block|,
name|asZproto_params
block|,
name|fzstart
block|,
name|fzshutdown
block|,
name|fzsendcmd
block|,
name|zzgetspace
block|,
name|fzsenddata
block|,
name|fzwait
block|,
name|fzfile
block|}
block|,
block|{
literal|'g'
block|,
name|UUCONF_RELIABLE_EIGHT
block|,
literal|1
block|,
name|TRUE
block|,
name|asGproto_params
block|,
name|fgstart
block|,
name|fgshutdown
block|,
name|fgsendcmd
block|,
name|zggetspace
block|,
name|fgsenddata
block|,
name|fgwait
block|,
name|NULL
block|}
block|,
block|{
literal|'G'
block|,
name|UUCONF_RELIABLE_EIGHT
block|,
literal|1
block|,
name|TRUE
block|,
name|asGproto_params
block|,
name|fbiggstart
block|,
name|fgshutdown
block|,
name|fgsendcmd
block|,
name|zggetspace
block|,
name|fgsenddata
block|,
name|fgwait
block|,
name|NULL
block|}
block|,
block|{
literal|'j'
block|,
name|UUCONF_RELIABLE_EIGHT
block|,
literal|7
block|,
name|TRUE
block|,
name|asIproto_params
block|,
name|fjstart
block|,
name|fjshutdown
block|,
name|fisendcmd
block|,
name|zigetspace
block|,
name|fisenddata
block|,
name|fiwait
block|,
name|NULL
block|}
block|,
block|{
literal|'f'
block|,
name|UUCONF_RELIABLE_RELIABLE
block|,
literal|1
block|,
name|FALSE
block|,
name|asFproto_params
block|,
name|ffstart
block|,
name|ffshutdown
block|,
name|ffsendcmd
block|,
name|zfgetspace
block|,
name|ffsenddata
block|,
name|ffwait
block|,
name|fffile
block|}
block|,
block|{
literal|'v'
block|,
name|UUCONF_RELIABLE_EIGHT
block|,
literal|1
block|,
name|TRUE
block|,
name|asGproto_params
block|,
name|fvstart
block|,
name|fgshutdown
block|,
name|fgsendcmd
block|,
name|zggetspace
block|,
name|fgsenddata
block|,
name|fgwait
block|,
name|NULL
block|}
block|,
block|{
literal|'y'
block|,
name|UUCONF_RELIABLE_RELIABLE
operator||
name|UUCONF_RELIABLE_EIGHT
block|,
literal|1
block|,
name|TRUE
block|,
name|asYproto_params
block|,
name|fystart
block|,
name|fyshutdown
block|,
name|fysendcmd
block|,
name|zygetspace
block|,
name|fysenddata
block|,
name|fywait
block|,
name|fyfile
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPROTOCOLS
value|(sizeof asProtocols / sizeof asProtocols[0])
end_define

begin_comment
comment|/* Locked system.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLocked_system
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuconf_system
name|sLocked_system
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Daemon structure holding information about the remote system (must    be global so the error handler can see it.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sdaemon
name|sDaemon
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open connection.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sconnection
modifier|*
name|qConn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uuconf global pointer; need to close the connection after a fatal    error.  */
end_comment

begin_decl_stmt
specifier|static
name|pointer
name|pUuconf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is passed to iuport_lock via uuconf_find_port.  */
end_comment

begin_struct
struct|struct
name|spass
block|{
name|boolean
name|fmatched
decl_stmt|;
name|boolean
name|flocked
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uhelp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcall
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
specifier|const
name|char
operator|*
name|zconfig
operator|,
name|boolean
name|fuuxqt
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
expr|struct
name|uuconf_port
operator|*
name|qport
operator|,
name|boolean
name|fifwork
operator|,
name|boolean
name|fforce
operator|,
name|boolean
name|fdetach
operator|,
name|boolean
name|fquiet
operator|,
name|boolean
name|ftrynext
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fconn_call
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
expr|struct
name|uuconf_port
operator|*
name|qport
operator|,
expr|struct
name|sstatus
operator|*
name|qstat
operator|,
name|int
name|cretry
operator|,
name|boolean
operator|*
name|pfcalled
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fdo_call
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
expr|struct
name|sstatus
operator|*
name|qstat
operator|,
specifier|const
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
operator|*
name|pfcalled
operator|,
expr|enum
name|tstatus_type
operator|*
name|pterr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iuport_lock
name|P
argument_list|(
operator|(
expr|struct
name|uuconf_port
operator|*
name|qport
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flogin_prompt
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
specifier|const
name|char
operator|*
name|zconfig
operator|,
name|boolean
name|fuuxqt
operator|,
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|zlogin
operator|,
specifier|const
name|char
operator|*
operator|*
name|pzsystem
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icallin_cmp
name|P
argument_list|(
operator|(
name|int
name|iwhich
operator|,
name|pointer
name|pinfo
operator|,
specifier|const
name|char
operator|*
name|zfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|faccept_call
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
specifier|const
name|char
operator|*
name|zconfig
operator|,
name|boolean
name|fuuxqt
operator|,
specifier|const
name|char
operator|*
name|zlogin
operator|,
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
operator|*
name|pzsystem
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uaccept_call_cleanup
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_system
operator|*
name|qfreesys
operator|,
expr|struct
name|uuconf_port
operator|*
name|qport
operator|,
expr|struct
name|uuconf_port
operator|*
name|qfreeport
operator|,
name|char
operator|*
name|zloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uapply_proto_params
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
name|int
name|bproto
operator|,
expr|struct
name|uuconf_cmdtab
operator|*
name|qcmds
operator|,
expr|struct
name|uuconf_proto_param
operator|*
name|pas
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend_uucp_cmd
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|z
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zget_uucp_cmd
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|boolean
name|frequired
operator|,
name|boolean
name|fstrip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zget_typed_line
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|boolean
name|fstrip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asLongopts
index|[]
init|=
block|{
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|2
block|}
block|,
block|{
literal|"ifwork"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"nodetach"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"loop"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"force"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"stdin"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"prompt"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"port"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"nouuxqt"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"master"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|3
block|}
block|,
block|{
literal|"slave"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|4
block|}
block|,
block|{
literal|"system"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"login"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"wait"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|"try-next"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"config"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"debug"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* -c: Whether to be quiet.  */
name|boolean
name|fquiet
init|=
name|FALSE
decl_stmt|;
comment|/* -C: Only call the system if there is work.  */
name|boolean
name|fifwork
init|=
name|FALSE
decl_stmt|;
comment|/* -D: don't detach from controlling terminal.  */
name|boolean
name|fdetach
init|=
name|TRUE
decl_stmt|;
comment|/* -e: Whether to do an endless loop of accepting calls.  */
name|boolean
name|fendless
init|=
name|FALSE
decl_stmt|;
comment|/* -f: Whether to force a call despite status of previous call.  */
name|boolean
name|fforce
init|=
name|FALSE
decl_stmt|;
comment|/* -i type: type of port to use for stdin.  */
name|enum
name|uuconf_porttype
name|tstdintype
init|=
name|UUCONF_PORTTYPE_STDIN
decl_stmt|;
comment|/* -I file: configuration file name.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
comment|/* -l: Whether to give a single login prompt.  */
name|boolean
name|flogin
init|=
name|FALSE
decl_stmt|;
comment|/* -P port: port to use; in master mode, call out on this port.  In      slave mode, accept logins on this port.  If port not specified,      then in master mode figure it out for each system, and in slave      mode use stdin and stdout.  */
specifier|const
name|char
modifier|*
name|zport
init|=
name|NULL
decl_stmt|;
comment|/* -q: Whether to start uuxqt when done.  */
name|boolean
name|fuuxqt
init|=
name|TRUE
decl_stmt|;
comment|/* -r1: Whether we are the master.  */
name|boolean
name|fmaster
init|=
name|FALSE
decl_stmt|;
comment|/* -s,-S system: system to call.  */
specifier|const
name|char
modifier|*
name|zsystem
init|=
name|NULL
decl_stmt|;
comment|/* -u: Login name to use.  */
specifier|const
name|char
modifier|*
name|zlogin
init|=
name|NULL
decl_stmt|;
comment|/* -w: Whether to wait for a call after doing one.  */
name|boolean
name|fwait
init|=
name|FALSE
decl_stmt|;
comment|/* -z: Try next alternate if call fails.  */
name|boolean
name|ftrynext
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|zopts
decl_stmt|;
name|int
name|iopt
decl_stmt|;
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|struct
name|uuconf_port
name|sport
decl_stmt|;
name|boolean
name|fret
init|=
name|TRUE
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|iholddebug
decl_stmt|;
endif|#
directive|endif
name|zProgram
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* When uucico is invoked by login, the first character of the      program will be a dash.  We don't want that.  */
if|if
condition|(
operator|*
name|zProgram
operator|==
literal|'-'
condition|)
operator|++
name|zProgram
expr_stmt|;
if|#
directive|if
name|COHERENT_C_OPTION
name|zopts
operator|=
literal|"c:CDefi:I:lp:qr:s:S:u:x:X:vwz"
expr_stmt|;
else|#
directive|else
name|zopts
operator|=
literal|"cCDefi:I:lp:qr:s:S:u:x:X:vwz"
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|zopts
argument_list|,
name|asLongopts
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|#
directive|if
name|COHERENT_C_OPTION
if|if
condition|(
name|iopt
operator|==
literal|'c'
condition|)
block|{
name|iopt
operator|=
literal|'s'
expr_stmt|;
name|fifwork
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|'c'
case|:
comment|/* Don't warn if a call is attempted at a bad time, and 	     don't print the "No work" message.  */
name|fquiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fifwork
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Don't detach from controlling terminal.  */
name|fdetach
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Do an endless loop of accepting calls.  */
name|fendless
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Force a call even if it hasn't been long enough since the last 	     failed call.  */
name|fforce
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Type of port to use for standard input.  Only TLI is 	     supported here, and only if HAVE_TLI is true.  This 	     permits the Network Listener to tell uucico to use TLI 	     I/O calls.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"tli"
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unsupported port type \"%s\"\n"
argument_list|,
name|zProgram
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|HAVE_TLI
name|tstdintype
operator|=
name|UUCONF_PORTTYPE_TLI
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: not compiled with TLI support\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* Prompt for login name and password.  */
name|flogin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Port to use  */
name|zport
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Don't start uuxqt.  */
name|fuuxqt
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Set mode: -r1 for master, -r0 for slave (default)  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
name|fmaster
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
name|fmaster
operator|=
name|FALSE
expr_stmt|;
else|else
name|uusage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Set system name  */
name|zsystem
operator|=
name|optarg
expr_stmt|;
name|fmaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Set system name and force call like -f  */
name|zsystem
operator|=
name|optarg
expr_stmt|;
name|fforce
operator|=
name|TRUE
expr_stmt|;
name|fmaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Some versions of uucpd invoke uucico with a -u argument 	     specifying the login name.  If invoked by a privileged 	     user, we use it instead of the result of 	     zsysdep_login_name.  */
if|if
condition|(
name|fsysdep_privileged
argument_list|()
condition|)
name|zlogin
operator|=
name|optarg
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ignoring command line login name: not a privileged user\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Call out and then wait for a call in  */
name|fwait
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Try next alternate if call fails.  */
name|ftrynext
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Set configuration file name (default is in sysdep.h).  */
if|if
condition|(
name|fsysdep_other_config
argument_list|(
name|optarg
argument_list|)
condition|)
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'v'
case|:
comment|/* Print version and exit.  */
name|printf
argument_list|(
literal|"%s: Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|zProgram
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|4
case|:
comment|/* --slave.  */
name|fmaster
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* --master.  */
name|fmaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* --help.  */
name|uhelp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* Long option found, and flag value set.  */
break|break;
default|default:
name|uusage
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|uusage
argument_list|()
expr_stmt|;
if|if
condition|(
name|fwait
operator|&&
name|zport
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -w requires -p"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|uusage
argument_list|()
expr_stmt|;
block|}
name|iuuconf
operator|=
name|uuconf_init
argument_list|(
operator|&
name|puuconf
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|pUuconf
operator|=
name|puuconf
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
block|{
specifier|const
name|char
modifier|*
name|zdebug
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_debuglevel
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zdebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdebug
operator|!=
name|NULL
condition|)
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|zdebug
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If a port was named, get its information.  */
if|if
condition|(
name|zport
operator|==
name|NULL
condition|)
name|qport
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|iuuconf
operator|=
name|uuconf_find_port
argument_list|(
name|puuconf
argument_list|,
name|zport
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|uuconf_port
operator|*
operator|,
name|pointer
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|&
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: port not found"
argument_list|,
name|zport
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|qport
operator|=
operator|&
name|sport
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|puuconf
argument_list|,
name|INIT_SUID
argument_list|)
expr_stmt|;
name|ulog_to_file
argument_list|(
name|puuconf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|uabort
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmaster
condition|)
block|{
if|if
condition|(
name|zsystem
operator|!=
name|NULL
condition|)
block|{
comment|/* A system was named.  Call it.  */
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zsystem
argument_list|,
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: System not found"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
comment|/* Detach from the controlling terminal for the call.  This 	     probably makes sense only on Unix.  We want the modem 	     line to become the controlling terminal.  */
if|if
condition|(
name|fdetach
operator|&&
operator|(
name|qport
operator|==
name|NULL
operator|||
name|qport
operator|->
name|uuconf_ttype
operator|!=
name|UUCONF_PORTTYPE_STDIN
operator|)
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
name|ulog_system
argument_list|(
name|sLocked_system
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|sLocked_system
operator|.
name|uuconf_zdebug
operator|!=
name|NULL
condition|)
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|sLocked_system
operator|.
name|uuconf_zdebug
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System already locked"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
name|fret
operator|=
name|fcall
argument_list|(
name|puuconf
argument_list|,
name|zconfig
argument_list|,
name|fuuxqt
argument_list|,
operator|&
name|sLocked_system
argument_list|,
name|qport
argument_list|,
name|fifwork
argument_list|,
name|fforce
argument_list|,
name|fdetach
argument_list|,
name|fquiet
argument_list|,
name|ftrynext
argument_list|)
expr_stmt|;
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|pznames
decl_stmt|,
modifier|*
modifier|*
name|pz
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|boolean
name|fdidone
decl_stmt|;
comment|/* Call all systems which have work to do.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
name|fdidone
operator|=
name|FALSE
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_system_names
argument_list|(
name|puuconf
argument_list|,
operator|&
name|pznames
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
comment|/* Randomize the order in which we call the systems.  */
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|pznames
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
name|c
operator|++
expr_stmt|;
name|srand
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|iuse
decl_stmt|;
name|char
modifier|*
name|zhold
decl_stmt|;
name|iuse
operator|=
name|rand
argument_list|()
operator|%
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|zhold
operator|=
name|pznames
index|[
name|i
index|]
expr_stmt|;
name|pznames
index|[
name|i
index|]
operator|=
name|pznames
index|[
name|iuse
index|]
expr_stmt|;
name|pznames
index|[
name|iuse
index|]
operator|=
name|zhold
expr_stmt|;
block|}
for|for
control|(
name|pz
operator|=
name|pznames
init|;
operator|*
name|pz
operator|!=
name|NULL
operator|&&
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|;
name|pz
operator|++
control|)
block|{
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
operator|*
name|pz
argument_list|,
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|pz
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fsysdep_has_work
argument_list|(
operator|&
name|sLocked_system
argument_list|)
condition|)
block|{
name|fdidone
operator|=
name|TRUE
expr_stmt|;
comment|/* Detach from the controlling terminal.  On Unix 		     this means that we will wind up forking a new 		     process for each system we call.  */
if|if
condition|(
name|fdetach
operator|&&
operator|(
name|qport
operator|==
name|NULL
operator|||
name|qport
operator|->
name|uuconf_ttype
operator|!=
name|UUCONF_PORTTYPE_STDIN
operator|)
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
name|ulog_system
argument_list|(
name|sLocked_system
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|sLocked_system
operator|.
name|uuconf_zdebug
operator|!=
name|NULL
condition|)
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|sLocked_system
operator|.
name|uuconf_zdebug
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System already locked"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fcall
argument_list|(
name|puuconf
argument_list|,
name|zconfig
argument_list|,
name|fuuxqt
argument_list|,
operator|&
name|sLocked_system
argument_list|,
name|qport
argument_list|,
name|TRUE
argument_list|,
name|fforce
argument_list|,
name|fdetach
argument_list|,
name|fquiet
argument_list|,
name|ftrynext
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
comment|/* Now ignore any SIGHUP that we got.  */
name|afSignal
index|[
name|INDEXSIG_SIGHUP
index|]
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|pz
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|pznames
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdidone
operator|&&
operator|!
name|fquiet
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"No work"
argument_list|)
expr_stmt|;
block|}
comment|/* If requested, wait for calls after dialing out.  */
if|if
condition|(
name|fwait
condition|)
block|{
name|fendless
operator|=
name|TRUE
expr_stmt|;
name|fmaster
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fmaster
condition|)
block|{
name|struct
name|sconnection
name|sconn
decl_stmt|;
name|boolean
name|flocked
decl_stmt|;
comment|/* If a port was specified by name, we go into endless loop 	 mode.  In this mode, we wait for calls and prompt them with 	 "login:" and "Password:", so that they think we are a regular 	 UNIX system.  If we aren't in endless loop mode, we have been 	 called by some other system.  If flogin is TRUE, we prompt 	 with "login:" and "Password:" a single time.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
name|zsystem
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_init
argument_list|(
name|qport
argument_list|,
operator|&
name|sconn
argument_list|,
name|tstdintype
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
comment|/* We are not using standard input.  Detach from the 	     controlling terminal, so that the port we are about to 	     use becomes our controlling terminal.  */
if|if
condition|(
name|fdetach
operator|&&
name|qport
operator|->
name|uuconf_ttype
operator|!=
name|UUCONF_PORTTYPE_STDIN
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fconn_lock
argument_list|(
operator|&
name|sconn
argument_list|,
name|TRUE
argument_list|)
condition|)
name|flocked
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|flocked
operator|=
name|FALSE
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Port already locked"
argument_list|,
name|qport
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|fret
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_open
argument_list|(
operator|&
name|sconn
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
name|qConn
operator|=
operator|&
name|sconn
expr_stmt|;
block|}
if|if
condition|(
name|fret
condition|)
block|{
if|if
condition|(
name|fendless
condition|)
block|{
while|while
condition|(
operator|!
name|FGOT_SIGNAL
argument_list|()
operator|&&
name|flogin_prompt
argument_list|(
name|puuconf
argument_list|,
name|zconfig
argument_list|,
name|fuuxqt
argument_list|,
operator|&
name|sconn
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
comment|/* Close and reopen the port in between calls.  */
if|if
condition|(
operator|!
name|fconn_close
argument_list|(
operator|&
name|sconn
argument_list|,
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_dialer
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|)
operator|||
operator|!
name|fconn_open
argument_list|(
operator|&
name|sconn
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
break|break;
block|}
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flogin
condition|)
name|fret
operator|=
name|flogin_prompt
argument_list|(
name|puuconf
argument_list|,
name|zconfig
argument_list|,
name|fuuxqt
argument_list|,
operator|&
name|sconn
argument_list|,
name|zlogin
argument_list|,
operator|&
name|zsystem
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zlogin
operator|==
name|NULL
condition|)
name|zlogin
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
name|fret
operator|=
name|faccept_call
argument_list|(
name|puuconf
argument_list|,
name|zconfig
argument_list|,
name|fuuxqt
argument_list|,
name|zlogin
argument_list|,
operator|&
name|sconn
argument_list|,
operator|&
name|zsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
if|if
condition|(
name|qConn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_close
argument_list|(
operator|&
name|sconn
argument_list|,
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_dialer
operator|*
operator|)
name|NULL
argument_list|,
name|fret
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
name|qConn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flocked
condition|)
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
block|}
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
comment|/* If we got a SIGTERM, perhaps because the system is going down,      don't run uuxqt.  We go ahead and run it for any other signal,      since I think they indicate more temporary conditions.  */
if|if
condition|(
name|afSignal
index|[
name|INDEXSIG_SIGTERM
index|]
condition|)
name|fuuxqt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fuuxqt
condition|)
block|{
name|int
name|irunuuxqt
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_runuuxqt
argument_list|(
name|puuconf
argument_list|,
operator|&
name|irunuuxqt
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|irunuuxqt
operator|==
name|UUCONF_RUNUUXQT_ONCE
condition|)
block|{
comment|/* Detach from the controlling terminal before starting up uuxqt, 	     so that it runs as a true daemon.  */
if|if
condition|(
name|fdetach
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fspawn_uuxqt
argument_list|(
name|FALSE
argument_list|,
name|zsystem
argument_list|,
name|zconfig
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|usysdep_exit
argument_list|(
name|fret
argument_list|)
expr_stmt|;
comment|/* Avoid complaints about not returning.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print out a usage message and die.  */
end_comment

begin_function
specifier|static
name|void
name|uusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options]\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use %s --help for help\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a help message.  */
end_comment

begin_function
specifier|static
name|void
name|uhelp
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Usage: %s [options]\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -s,-S,--system system: Call system (-S implies -f)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -f,--force: Force call despite system status\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -r state: 1 for master, 0 for slave (default)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" --master: Act as master\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" --slave: Act as slave (default)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -p,--port port: Specify port\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -l,--prompt: prompt for login name and password\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -e,--loop: Endless loop of login prompts and daemon execution\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -w,--wait: After calling out, wait for incoming calls\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -q,--nouuxqt: Don't start uuxqt when done\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -c,--quiet: Don't log bad time or no work warnings\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -C,--ifwork: Only call named system if there is work\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -D,--nodetach: Don't detach from controlling terminal\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -u,--login: Set login name (privileged users only)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -i,--stdin type: Type of standard input (only TLI supported)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -z,--try-next: If a call fails, try the next alternate\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -x,-X,--debug debug: Set debugging level\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|printf
argument_list|(
literal|" -I,--config file: Set configuration file to use\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|printf
argument_list|(
literal|" -v,--version: Print version and exit\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" --help: Print help and exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when a LOG_FATAL error occurs.  */
end_comment

begin_function
specifier|static
name|void
name|uabort
parameter_list|()
block|{
if|if
condition|(
name|fLocked_system
condition|)
name|ufailed
argument_list|(
operator|&
name|sDaemon
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qConn
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fconn_close
argument_list|(
name|qConn
argument_list|,
name|pUuconf
argument_list|,
operator|(
expr|struct
name|uuconf_dialer
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
name|qConn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
name|qConn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The number of seconds in one day.  We must cast to long for this    to be calculated correctly on a machine with 16 bit ints.  */
end_comment

begin_define
define|#
directive|define
name|SECS_PER_DAY
value|((long) 24 * (long) 60 * (long) 60)
end_define

begin_comment
comment|/* Call another system, trying all the possible sets of calling    instructions.  The qsys argument is the system to call.  The qport    argument is the port to use, and may be NULL.  If the fifwork    argument is TRUE, the call is only placed if there is work to be    done.  If the fforce argument is TRUE, a call is forced even if not    enough time has passed since the last failed call.  If the fquiet    argument is FALSE (the normal case), then a warning is given if    calls are not permitted at this time.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcall
parameter_list|(
name|puuconf
parameter_list|,
name|zconfig
parameter_list|,
name|fuuxqt
parameter_list|,
name|qorigsys
parameter_list|,
name|qport
parameter_list|,
name|fifwork
parameter_list|,
name|fforce
parameter_list|,
name|fdetach
parameter_list|,
name|fquiet
parameter_list|,
name|ftrynext
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zconfig
decl_stmt|;
name|boolean
name|fuuxqt
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qorigsys
decl_stmt|;
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|boolean
name|fifwork
decl_stmt|;
name|boolean
name|fforce
decl_stmt|;
name|boolean
name|fdetach
decl_stmt|;
name|boolean
name|fquiet
decl_stmt|;
name|boolean
name|ftrynext
decl_stmt|;
block|{
name|struct
name|sstatus
name|sstat
decl_stmt|;
name|long
name|inow
decl_stmt|;
name|boolean
name|fbadtime
decl_stmt|,
name|fnevertime
decl_stmt|,
name|ffoundwork
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_status
argument_list|(
name|qorigsys
argument_list|,
operator|&
name|sstat
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ubuffree
argument_list|(
name|sstat
operator|.
name|zstring
argument_list|)
expr_stmt|;
comment|/* Make sure it's been long enough since the last failed call, and      that we haven't exceeded the maximum number of retries.  Even if      we are over the limit on retries, we permit a call to be made if      24 hours have passed.  This 24 hour limit is still controlled by      the retry time.  We ignore times in the future, presumably the      result of some sort of error.  */
name|inow
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fforce
condition|)
block|{
if|if
condition|(
name|qorigsys
operator|->
name|uuconf_cmax_retries
operator|>
literal|0
operator|&&
name|sstat
operator|.
name|cretries
operator|>=
name|qorigsys
operator|->
name|uuconf_cmax_retries
operator|&&
name|sstat
operator|.
name|ilast
operator|<=
name|inow
operator|&&
name|sstat
operator|.
name|ilast
operator|+
name|SECS_PER_DAY
operator|>
name|inow
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many retries"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|sstat
operator|.
name|ttype
operator|==
name|STATUS_COMPLETE
condition|?
name|sstat
operator|.
name|ilast
operator|+
name|qorigsys
operator|->
name|uuconf_csuccess_wait
operator|>
name|inow
else|:
name|sstat
operator|.
name|ilast
operator|+
name|sstat
operator|.
name|cwait
operator|>
name|inow
operator|)
operator|&&
name|sstat
operator|.
name|ilast
operator|<=
name|inow
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Retry time not reached"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|sDaemon
operator|.
name|puuconf
operator|=
name|puuconf
expr_stmt|;
name|sDaemon
operator|.
name|zconfig
operator|=
name|zconfig
expr_stmt|;
if|if
condition|(
operator|!
name|fuuxqt
condition|)
name|sDaemon
operator|.
name|irunuuxqt
operator|=
name|UUCONF_RUNUUXQT_NEVER
expr_stmt|;
else|else
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_runuuxqt
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sDaemon
operator|.
name|irunuuxqt
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
block|}
name|fbadtime
operator|=
name|TRUE
expr_stmt|;
name|fnevertime
operator|=
name|TRUE
expr_stmt|;
name|ffoundwork
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|qsys
operator|=
name|qorigsys
init|;
name|qsys
operator|!=
name|NULL
condition|;
name|qsys
operator|=
name|qsys
operator|->
name|uuconf_qalternate
control|)
block|{
name|int
name|cretry
decl_stmt|;
name|boolean
name|fany
decl_stmt|,
name|fret
decl_stmt|,
name|fcalled
decl_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fcall
operator|||
name|qsys
operator|->
name|uuconf_qtimegrade
operator|==
name|NULL
condition|)
continue|continue;
name|fnevertime
operator|=
name|FALSE
expr_stmt|;
comment|/* Make sure this is a legal time to call.  */
if|if
condition|(
operator|!
name|ftimespan_match
argument_list|(
name|qsys
operator|->
name|uuconf_qtimegrade
argument_list|,
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|cretry
argument_list|)
condition|)
continue|continue;
name|fbadtime
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|qsys
operator|=
name|qsys
expr_stmt|;
name|sDaemon
operator|.
name|zlocalname
operator|=
name|NULL
expr_stmt|;
name|sDaemon
operator|.
name|qconn
operator|=
name|NULL
expr_stmt|;
name|sDaemon
operator|.
name|qproto
operator|=
name|NULL
expr_stmt|;
name|sDaemon
operator|.
name|cchans
operator|=
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|clocal_size
operator|=
operator|-
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|cremote_size
operator|=
operator|-
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|cmax_ever
operator|=
operator|-
literal|2
expr_stmt|;
name|sDaemon
operator|.
name|cmax_receive
operator|=
operator|-
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|csent
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|creceived
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|cxfiles_received
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|ifeatures
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|frequest_hangup
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fhangup_requested
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fhangup
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fmaster
operator|=
name|TRUE
expr_stmt|;
name|sDaemon
operator|.
name|fcaller
operator|=
name|TRUE
expr_stmt|;
name|sDaemon
operator|.
name|ireliable
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|bgrade
operator|=
literal|'\0'
expr_stmt|;
comment|/* Queue up any work there is to do.  */
if|if
condition|(
operator|!
name|fqueue
argument_list|(
operator|&
name|sDaemon
argument_list|,
operator|&
name|fany
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we are only supposed to call if there is work, and there 	 isn't any work, check the next alternates.  We can't give up 	 at this point because there might be some other alternates 	 with fewer restrictions on grade or file transfer size.  */
if|if
condition|(
name|fifwork
operator|&&
operator|!
name|fany
condition|)
block|{
name|uclear_queue
argument_list|(
operator|&
name|sDaemon
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ffoundwork
operator|=
name|TRUE
expr_stmt|;
name|fret
operator|=
name|fconn_call
argument_list|(
operator|&
name|sDaemon
argument_list|,
name|qport
argument_list|,
operator|&
name|sstat
argument_list|,
name|cretry
argument_list|,
operator|&
name|fcalled
argument_list|)
expr_stmt|;
name|uclear_queue
argument_list|(
operator|&
name|sDaemon
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fcalled
operator|&&
operator|!
name|ftrynext
condition|)
return|return
name|FALSE
return|;
comment|/* Now we have to dump that port so that we can aquire a new 	 one.  On Unix this means that we will fork and get a new 	 process ID, so we must unlock and relock the system.  */
if|if
condition|(
name|fdetach
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
name|usysdep_detach
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* We only get here if no call succeeded.  If fbadtime is TRUE it      was the wrong time for all the alternates.  Otherwise, if      ffoundwork is FALSE there was no work for any of the alternates.      Otherwise, we attempted a call and fconn_call logged an error      message.  */
if|if
condition|(
name|fbadtime
condition|)
block|{
if|if
condition|(
operator|!
name|fquiet
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Wrong time to call"
argument_list|)
expr_stmt|;
comment|/* Update the status, unless the system can never be called.  If 	 the system can never be called, there is little point to 	 putting in a ``wrong time to call'' message.  We don't change 	 the number of retries, although we do set the wait until the 	 next retry to 0.  */
if|if
condition|(
operator|!
name|fnevertime
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_WRONG_TIME
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|inow
expr_stmt|;
name|sstat
operator|.
name|cwait
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qorigsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ffoundwork
condition|)
block|{
if|if
condition|(
operator|!
name|fquiet
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"No work"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Find a port to use when calling a system, open a connection, and    dial the system.  The actual call is done in fdo_call.  This    routine is responsible for opening and closing the connection.  */
end_comment

begin_function
specifier|static
name|boolean
name|fconn_call
parameter_list|(
name|qdaemon
parameter_list|,
name|qport
parameter_list|,
name|qstat
parameter_list|,
name|cretry
parameter_list|,
name|pfcalled
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|struct
name|sstatus
modifier|*
name|qstat
decl_stmt|;
name|int
name|cretry
decl_stmt|;
name|boolean
modifier|*
name|pfcalled
decl_stmt|;
block|{
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|struct
name|uuconf_port
name|sport
decl_stmt|;
name|struct
name|sconnection
name|sconn
decl_stmt|;
name|enum
name|tstatus_type
name|terr
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|puuconf
operator|=
name|qdaemon
operator|->
name|puuconf
expr_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
operator|*
name|pfcalled
operator|=
name|FALSE
expr_stmt|;
comment|/* Ignore any SIGHUP signal we may have received up to this point.      This is needed on Unix because we may have gotten one from the      shell before we detached from the controlling terminal.  */
name|afSignal
index|[
name|INDEXSIG_SIGHUP
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* If no port was specified on the command line, use any port      defined for the system.  To select the system port: 1) see if      port information was specified directly; 2) see if a port was      named; 3) get an available port given the baud rate.  We don't      change the system status if a port is unavailable; i.e. we don't      force the system to wait for the retry time.  */
if|if
condition|(
name|qport
operator|==
name|NULL
condition|)
name|qport
operator|=
name|qsys
operator|->
name|uuconf_qport
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_init
argument_list|(
name|qport
argument_list|,
operator|&
name|sconn
argument_list|,
name|UUCONF_PORTTYPE_UNKNOWN
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fconn_lock
argument_list|(
operator|&
name|sconn
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Port already locked"
argument_list|,
name|qport
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|struct
name|spass
name|s
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
name|s
operator|.
name|fmatched
operator|=
name|FALSE
expr_stmt|;
name|s
operator|.
name|flocked
operator|=
name|FALSE
expr_stmt|;
name|s
operator|.
name|qconn
operator|=
operator|&
name|sconn
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_find_port
argument_list|(
name|puuconf
argument_list|,
name|qsys
operator|->
name|uuconf_zport
argument_list|,
name|qsys
operator|->
name|uuconf_ibaud
argument_list|,
name|qsys
operator|->
name|uuconf_ihighbaud
argument_list|,
name|iuport_lock
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|s
argument_list|,
operator|&
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|fmatched
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"All matching ports in use"
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No matching ports"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|flocked
condition|)
block|{
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fconn_open
argument_list|(
operator|&
name|sconn
argument_list|,
name|qsys
operator|->
name|uuconf_ibaud
argument_list|,
name|qsys
operator|->
name|uuconf_ihighbaud
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|terr
operator|=
name|STATUS_PORT_FAILED
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|struct
name|uuconf_dialer
name|sdialer
decl_stmt|;
name|enum
name|tdialerfound
name|tdialer
decl_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_zalternate
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Calling system %s (port %s)"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Calling system %s (alternate %s, port %s)"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qsys
operator|->
name|uuconf_zalternate
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
name|qdialer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_dial
argument_list|(
operator|&
name|sconn
argument_list|,
name|puuconf
argument_list|,
name|qsys
argument_list|,
name|qsys
operator|->
name|uuconf_zphone
argument_list|,
operator|&
name|sdialer
argument_list|,
operator|&
name|tdialer
argument_list|)
condition|)
block|{
name|tdialer
operator|=
name|DIALERFOUND_FALSE
expr_stmt|;
name|terr
operator|=
name|STATUS_DIAL_FAILED
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|qdaemon
operator|->
name|qconn
operator|=
operator|&
name|sconn
expr_stmt|;
if|if
condition|(
name|tdialer
operator|==
name|DIALERFOUND_FALSE
condition|)
name|qdialer
operator|=
name|NULL
expr_stmt|;
else|else
name|qdialer
operator|=
operator|&
name|sdialer
expr_stmt|;
name|fret
operator|=
name|fdo_call
argument_list|(
name|qdaemon
argument_list|,
name|qstat
argument_list|,
name|qdialer
argument_list|,
name|pfcalled
argument_list|,
operator|&
name|terr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fconn_close
argument_list|(
operator|&
name|sconn
argument_list|,
name|puuconf
argument_list|,
name|qdialer
argument_list|,
name|fret
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdialer
operator|==
name|DIALERFOUND_FREE
condition|)
operator|(
name|void
operator|)
name|uuconf_dialer_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sdialer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fret
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"Call failed: %d (%s)"
argument_list|,
operator|(
name|int
operator|)
name|terr
argument_list|,
name|azStatus
index|[
operator|(
name|int
operator|)
name|terr
index|]
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|ttype
operator|=
name|terr
expr_stmt|;
name|qstat
operator|->
name|cretries
operator|++
expr_stmt|;
name|qstat
operator|->
name|ilast
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cretry
operator|==
literal|0
condition|)
name|qstat
operator|->
name|cwait
operator|=
name|CRETRY_WAIT
argument_list|(
name|qstat
operator|->
name|cretries
argument_list|)
expr_stmt|;
else|else
name|qstat
operator|->
name|cwait
operator|=
name|cretry
operator|*
literal|60
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fconn_unlock
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
name|uconn_free
argument_list|(
operator|&
name|sconn
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|uuconf_port_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sport
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Do the actual work of calling another system.  The qsys argument is    the system to call, the qconn argument is the connection to use,    the qstat argument holds the current status of the ssystem, and the    qdialer argument holds the dialer being used (it may be NULL).  If    we log in successfully, set *pfcalled to TRUE; this is used to    distinguish a failed dial from a failure during the call.  If an    error occurs *pterr is set to the status type to record.  */
end_comment

begin_function
specifier|static
name|boolean
name|fdo_call
parameter_list|(
name|qdaemon
parameter_list|,
name|qstat
parameter_list|,
name|qdialer
parameter_list|,
name|pfcalled
parameter_list|,
name|pterr
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|sstatus
modifier|*
name|qstat
decl_stmt|;
specifier|const
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
modifier|*
name|pfcalled
decl_stmt|;
name|enum
name|tstatus_type
modifier|*
name|pterr
decl_stmt|;
block|{
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
name|int
name|istrip
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|char
modifier|*
name|zstr
decl_stmt|;
name|long
name|istart_time
decl_stmt|;
name|char
modifier|*
name|zlog
decl_stmt|;
name|puuconf
operator|=
name|qdaemon
operator|->
name|puuconf
expr_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
name|qconn
operator|=
name|qdaemon
operator|->
name|qconn
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_strip
argument_list|(
name|puuconf
argument_list|,
operator|&
name|istrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fstrip
operator|=
operator|(
name|istrip
operator|&
name|UUCONF_STRIP_PROTO
operator|)
operator|!=
literal|0
expr_stmt|;
operator|*
name|pterr
operator|=
name|STATUS_LOGIN_FAILED
expr_stmt|;
if|if
condition|(
name|qconn
operator|->
name|qport
operator|==
name|NULL
condition|)
name|zport
operator|=
literal|"unknown"
expr_stmt|;
else|else
name|zport
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zname
expr_stmt|;
if|if
condition|(
operator|!
name|fchat
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
operator|&
name|qsys
operator|->
name|uuconf_schat
argument_list|,
name|qsys
argument_list|,
operator|(
specifier|const
expr|struct
name|uuconf_dialer
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|zport
argument_list|,
name|iconn_baud
argument_list|(
name|qconn
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|pfcalled
operator|=
name|TRUE
expr_stmt|;
name|istart_time
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pterr
operator|=
name|STATUS_HANDSHAKE_FAILED
expr_stmt|;
comment|/* We should now see "Shere" from the other system.  Newer systems      send "Shere=foo" where foo is the remote name.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|zstr
argument_list|,
literal|"Shere"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad startup string (expected \"Shere\" got \"%s\")"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Login successful"
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|ttype
operator|=
name|STATUS_TALKING
expr_stmt|;
name|qstat
operator|->
name|ilast
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|cretries
operator|=
literal|0
expr_stmt|;
name|qstat
operator|->
name|cwait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zstr
index|[
literal|5
index|]
operator|==
literal|'='
condition|)
block|{
specifier|const
name|char
modifier|*
name|zheresys
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|int
name|icmp
decl_stmt|;
comment|/* Some UUCP packages only provide seven characters in the Shere 	 machine name.  Others only provide fourteen.  */
name|zheresys
operator|=
name|zstr
operator|+
literal|6
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zheresys
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|==
literal|7
operator|||
name|clen
operator|==
literal|14
condition|)
name|icmp
operator|=
name|strncmp
argument_list|(
name|zheresys
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|else
name|icmp
operator|=
name|strcmp
argument_list|(
name|zheresys
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|uuconf_pzalias
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
for|for
control|(
name|pz
operator|=
name|qsys
operator|->
name|uuconf_pzalias
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
if|if
condition|(
name|clen
operator|==
literal|7
operator|||
name|clen
operator|==
literal|14
condition|)
name|icmp
operator|=
name|strncmp
argument_list|(
name|zheresys
argument_list|,
operator|*
name|pz
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|else
name|icmp
operator|=
name|strcmp
argument_list|(
name|zheresys
argument_list|,
operator|*
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|icmp
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Called wrong system (%s)"
argument_list|,
name|zheresys
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
elseif|else
if|if
condition|(
name|zstr
index|[
literal|5
index|]
operator|!=
literal|'\0'
condition|)
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"fdo_call: Strange Shere: %s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
comment|/* We now send "S" name switches, where name is our UUCP name.  If      we are using sequence numbers with this system, we send a -Q      argument with the sequence number.  If the call-timegrade command      was used, we send a -p argument and a -vgrade= argument with the      grade to send us (we send both argument to make it more likely      that one is recognized).  We always send a -N (for new) switch      indicating what new features we support.  */
block|{
name|long
name|ival
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
comment|/* Determine the grade we should request of the other system.  A        '\0' means that no restrictions have been made.  */
if|if
condition|(
operator|!
name|ftimespan_match
argument_list|(
name|qsys
operator|->
name|uuconf_qcalltimegrade
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|bgrade
operator|=
literal|'\0'
expr_stmt|;
else|else
name|bgrade
operator|=
operator|(
name|char
operator|)
name|ival
expr_stmt|;
comment|/* Determine the name we will call ourselves.  */
if|if
condition|(
name|qsys
operator|->
name|uuconf_zlocalname
operator|!=
name|NULL
condition|)
name|qdaemon
operator|->
name|zlocalname
operator|=
name|qsys
operator|->
name|uuconf_zlocalname
expr_stmt|;
else|else
block|{
name|iuuconf
operator|=
name|uuconf_localname
argument_list|(
name|puuconf
argument_list|,
operator|&
name|qdaemon
operator|->
name|zlocalname
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|qdaemon
operator|->
name|zlocalname
operator|=
name|zsysdep_localname
argument_list|()
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|zlocalname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zsend
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|qdaemon
operator|->
name|zlocalname
argument_list|)
operator|+
literal|70
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fsequence
condition|)
block|{
if|if
condition|(
name|bgrade
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -R -N0%o"
argument_list|,
name|qdaemon
operator|->
name|zlocalname
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|FEATURE_SIZES
operator||
name|FEATURE_EXEC
operator||
name|FEATURE_RESTART
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -p%c -vgrade=%c -R -N0%o"
argument_list|,
name|qdaemon
operator|->
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|bgrade
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|FEATURE_SIZES
operator||
name|FEATURE_EXEC
operator||
name|FEATURE_RESTART
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|iseq
decl_stmt|;
name|iseq
operator|=
name|ixsysdep_get_sequence
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iseq
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bgrade
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -Q%ld -R -N0%o"
argument_list|,
name|qdaemon
operator|->
name|zlocalname
argument_list|,
name|iseq
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|FEATURE_SIZES
operator||
name|FEATURE_EXEC
operator||
name|FEATURE_RESTART
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -Q%ld -p%c -vgrade=%c -R -N0%o"
argument_list|,
name|qdaemon
operator|->
name|zlocalname
argument_list|,
name|iseq
argument_list|,
name|bgrade
argument_list|,
name|bgrade
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|FEATURE_SIZES
operator||
name|FEATURE_EXEC
operator||
name|FEATURE_RESTART
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fret
operator|=
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|zsend
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Now we should see ROK or Rreason where reason gives a cryptic      reason for failure.  If we are talking to a counterpart, we will      get back ROKN, possibly with a feature bitfield attached.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'R'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad response to handshake string (%s)"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
literal|"OKN"
argument_list|,
sizeof|sizeof
expr|"OKN"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zstr
index|[
sizeof|sizeof
expr|"ROKN"
operator|-
literal|1
expr|]
operator|==
literal|'\0'
condition|)
name|qdaemon
operator|->
name|ifeatures
operator||=
name|FEATURE_SIZES
operator||
name|FEATURE_V103
expr_stmt|;
else|else
name|qdaemon
operator|->
name|ifeatures
operator||=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|zstr
operator|+
sizeof|sizeof
expr|"ROKN"
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
literal|"OK"
argument_list|,
sizeof|sizeof
expr|"OK"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zstr
index|[
sizeof|sizeof
expr|"ROK"
operator|-
literal|1
expr|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|zopt
decl_stmt|;
comment|/* SVR4 UUCP returns options following the ROK string.  */
name|zopt
operator|=
name|zstr
operator|+
sizeof|sizeof
expr|"ROK"
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|zopt
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|b
decl_stmt|;
name|long
name|c
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
name|b
operator|=
operator|*
name|zopt
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|b
argument_list|)
operator|||
name|b
operator|!=
literal|'-'
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|zopt
condition|)
block|{
case|case
literal|'R'
case|:
name|qdaemon
operator|->
name|ifeatures
operator||=
operator|(
name|FEATURE_RESTART
operator||
name|FEATURE_SVR4
operator||
name|FEATURE_SIZES
operator|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|c
operator|=
name|strtol
argument_list|(
name|zopt
argument_list|,
operator|&
name|zend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<=
name|LONG_MAX
operator|/
operator|(
name|long
operator|)
literal|512
condition|)
name|qdaemon
operator|->
name|cmax_receive
operator|=
name|c
operator|*
operator|(
name|long
operator|)
literal|512
expr_stmt|;
name|zopt
operator|=
name|zend
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|zopt
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|zopt
argument_list|)
condition|)
operator|++
name|zopt
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
literal|"CB"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Remote system will call back"
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Handshake failed (%s)"
argument_list|,
name|zstr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
comment|/* The slave should now send \020Pprotos\0 where protos is a list of      supported protocols.  Each protocol is a single character.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'P'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad protocol handshake (%s)"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Determine the reliability characteristics of the connection by      combining information for the port and the dialer.  If we have no      information, default to a reliable eight-bit full-duplex      connection.  */
if|if
condition|(
name|qconn
operator|->
name|qport
operator|!=
name|NULL
operator|&&
operator|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_ireliable
operator|&
name|UUCONF_RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
name|qdaemon
operator|->
name|ireliable
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_ireliable
expr_stmt|;
if|if
condition|(
name|qdialer
operator|!=
name|NULL
operator|&&
operator|(
name|qdialer
operator|->
name|uuconf_ireliable
operator|&
name|UUCONF_RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|qdaemon
operator|->
name|ireliable
operator|!=
literal|0
condition|)
name|qdaemon
operator|->
name|ireliable
operator|&=
name|qdialer
operator|->
name|uuconf_ireliable
expr_stmt|;
else|else
name|qdaemon
operator|->
name|ireliable
operator|=
name|qdialer
operator|->
name|uuconf_ireliable
expr_stmt|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|ireliable
operator|==
literal|0
condition|)
name|qdaemon
operator|->
name|ireliable
operator|=
operator|(
name|UUCONF_RELIABLE_RELIABLE
operator||
name|UUCONF_RELIABLE_EIGHT
operator||
name|UUCONF_RELIABLE_FULLDUPLEX
operator||
name|UUCONF_RELIABLE_SPECIFIED
operator|)
expr_stmt|;
comment|/* Now decide which protocol to use.  The system and the port may      have their own list of protocols.  */
block|{
name|int
name|i
decl_stmt|;
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
name|i
operator|=
name|CPROTOCOLS
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_zprotocols
operator|!=
name|NULL
operator|||
operator|(
name|qconn
operator|->
name|qport
operator|!=
name|NULL
operator|&&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zprotocols
operator|!=
name|NULL
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zproto
decl_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_zprotocols
operator|!=
name|NULL
condition|)
name|zproto
operator|=
name|qsys
operator|->
name|uuconf_zprotocols
expr_stmt|;
else|else
name|zproto
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zprotocols
expr_stmt|;
for|for
control|(
init|;
operator|*
name|zproto
operator|!=
literal|'\0'
condition|;
name|zproto
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
operator|*
name|zproto
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
operator|==
operator|*
name|zproto
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|CPROTOCOLS
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* If neither the system nor the port specified a list of 	   protocols, we want only protocols that match the known 	   reliability of the dialer and the port.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ipr
decl_stmt|;
name|ipr
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|ireliable
expr_stmt|;
if|if
condition|(
operator|(
name|ipr
operator|&
name|qdaemon
operator|->
name|ireliable
operator|)
operator|!=
name|ipr
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|CPROTOCOLS
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"UN"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No mutually supported protocols"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qdaemon
operator|->
name|qproto
operator|=
operator|&
name|asProtocols
index|[
name|i
index|]
expr_stmt|;
comment|/* If we are using a half-duplex line, act as though we have only        a single channel; otherwise we might start a send and a receive        at the same time.  */
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ireliable
operator|&
name|UUCONF_RELIABLE_FULLDUPLEX
operator|)
operator|==
literal|0
condition|)
name|qdaemon
operator|->
name|cchans
operator|=
literal|1
expr_stmt|;
else|else
name|qdaemon
operator|->
name|cchans
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|cchans
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"U%c"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|ab
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Run any protocol parameter commands.  */
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|qcmds
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|uuconf_qproto_params
operator|!=
name|NULL
condition|)
name|uapply_proto_params
argument_list|(
name|puuconf
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|qcmds
argument_list|,
name|qsys
operator|->
name|uuconf_qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qconn
operator|->
name|qport
operator|!=
name|NULL
operator|&&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_qproto_params
operator|!=
name|NULL
condition|)
name|uapply_proto_params
argument_list|(
name|puuconf
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|qcmds
argument_list|,
name|qconn
operator|->
name|qport
operator|->
name|uuconf_qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdialer
operator|!=
name|NULL
operator|&&
name|qdialer
operator|->
name|uuconf_qproto_params
operator|!=
name|NULL
condition|)
name|uapply_proto_params
argument_list|(
name|puuconf
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|qcmds
argument_list|,
name|qdialer
operator|->
name|uuconf_qproto_params
argument_list|)
expr_stmt|;
block|}
comment|/* Turn on the selected protocol.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfstart
call|)
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|zlog
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zlog
operator|==
name|NULL
condition|)
block|{
name|zlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"protocol ''"
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zlog
argument_list|,
literal|"protocol '%c'"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful (%s)"
argument_list|,
name|zlog
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zlog
argument_list|)
expr_stmt|;
operator|*
name|pterr
operator|=
name|STATUS_FAILED
expr_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|long
name|iend_time
decl_stmt|;
name|fret
operator|=
name|floop
argument_list|(
name|qdaemon
argument_list|)
expr_stmt|;
comment|/* Now send the hangup message.  As the caller, we send six O's        and expect to receive seven O's.  We send the six O's twice to        help the other side.  We don't worry about errors here.  */
if|if
condition|(
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"OOOOOO"
argument_list|)
operator|&&
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"OOOOOO"
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fdone
decl_stmt|;
comment|/* We look for the remote hangup string to ensure that the 	   modem has sent out our hangup string.  This is only 	   necessary because some versions of UUCP complain if they 	   don't get the hangup string.  The remote site should send 7 	   O's, but some versions of UUCP only send 6.  We look for 	   the string several times because supposedly some 	   implementations send some garbage after the last packet but 	   before the hangup string.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|FALSE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
break|break;
name|fdone
operator|=
name|strstr
argument_list|(
name|zstr
argument_list|,
literal|"OOOOOO"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdone
condition|)
break|break;
block|}
block|}
name|iend_time
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Call complete (%ld seconds %ld bytes %ld bps)"
argument_list|,
name|iend_time
operator|-
name|istart_time
argument_list|,
name|qdaemon
operator|->
name|csent
operator|+
name|qdaemon
operator|->
name|creceived
argument_list|,
operator|(
name|iend_time
operator|!=
name|istart_time
condition|?
operator|(
name|qdaemon
operator|->
name|csent
operator|+
name|qdaemon
operator|->
name|creceived
operator|)
operator|/
operator|(
name|iend_time
operator|-
name|istart_time
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
block|{
name|qstat
operator|->
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
name|qstat
operator|->
name|ilast
operator|=
name|iend_time
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|irunuuxqt
operator|==
name|UUCONF_RUNUUXQT_PERCALL
operator|||
operator|(
name|qdaemon
operator|->
name|irunuuxqt
operator|>
literal|0
operator|&&
name|qdaemon
operator|->
name|cxfiles_received
operator|>
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|fspawn_uuxqt
argument_list|(
name|TRUE
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qdaemon
operator|->
name|zconfig
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called via uuconf_find_port when a matching port is    found.  It tries to lock the port.  If it fails, it returns    UUCONF_NOT_FOUND to force uuconf_find_port to continue searching    for the next matching port.  */
end_comment

begin_function
specifier|static
name|int
name|iuport_lock
parameter_list|(
name|qport
parameter_list|,
name|pinfo
parameter_list|)
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|spass
modifier|*
name|q
init|=
operator|(
expr|struct
name|spass
operator|*
operator|)
name|pinfo
decl_stmt|;
name|q
operator|->
name|fmatched
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_init
argument_list|(
name|qport
argument_list|,
name|q
operator|->
name|qconn
argument_list|,
name|UUCONF_PORTTYPE_UNKNOWN
argument_list|)
condition|)
return|return
name|UUCONF_NOT_FOUND
return|;
elseif|else
if|if
condition|(
operator|!
name|fconn_lock
argument_list|(
name|q
operator|->
name|qconn
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|uconn_free
argument_list|(
name|q
operator|->
name|qconn
argument_list|)
expr_stmt|;
return|return
name|UUCONF_NOT_FOUND
return|;
block|}
else|else
block|{
name|q
operator|->
name|flocked
operator|=
name|TRUE
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The information structure used for the uuconf_callin comparison    function.  */
end_comment

begin_struct
struct|struct
name|scallin_info
block|{
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpass
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Prompt for a login name and a password, and run as the slave.  */
end_comment

begin_function
specifier|static
name|boolean
name|flogin_prompt
parameter_list|(
name|puuconf
parameter_list|,
name|zconfig
parameter_list|,
name|fuuxqt
parameter_list|,
name|qconn
parameter_list|,
name|zlogin
parameter_list|,
name|pzsystem
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zconfig
decl_stmt|;
name|boolean
name|fuuxqt
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlogin
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzsystem
decl_stmt|;
block|{
name|int
name|iuuconf
decl_stmt|;
name|int
name|istrip
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
name|char
modifier|*
name|zuser
decl_stmt|,
modifier|*
name|zpass
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|struct
name|scallin_info
name|s
decl_stmt|;
if|if
condition|(
name|pzsystem
operator|!=
name|NULL
condition|)
operator|*
name|pzsystem
operator|=
name|NULL
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"flogin_prompt: Waiting for login"
argument_list|)
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_strip
argument_list|(
name|puuconf
argument_list|,
operator|&
name|istrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fstrip
operator|=
operator|(
name|istrip
operator|&
name|UUCONF_STRIP_LOGIN
operator|)
operator|!=
literal|0
expr_stmt|;
name|zuser
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zlogin
operator|==
name|NULL
condition|)
block|{
do|do
block|{
name|ubuffree
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
literal|"login: "
argument_list|,
sizeof|sizeof
expr|"login: "
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zuser
operator|=
name|zget_typed_line
argument_list|(
name|qconn
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|zuser
operator|!=
name|NULL
operator|&&
operator|*
name|zuser
operator|==
literal|'\0'
condition|)
do|;
if|if
condition|(
name|zuser
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|zlogin
operator|=
name|zuser
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
literal|"Password:"
argument_list|,
sizeof|sizeof
expr|"Password:"
operator|-
literal|1
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zpass
operator|=
name|zget_typed_line
argument_list|(
name|qconn
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpass
operator|==
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|fret
operator|=
name|TRUE
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zlogin
expr_stmt|;
name|s
operator|.
name|zpass
operator|=
name|zpass
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_callin
argument_list|(
name|puuconf
argument_list|,
name|icallin_cmp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zpass
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad login"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|iholddebug
decl_stmt|;
endif|#
directive|endif
comment|/* We ignore the return value of faccept_call because we really 	 don't care whether the call succeeded or not.  We are going 	 to reset the port anyhow.  */
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|faccept_call
argument_list|(
name|puuconf
argument_list|,
name|zconfig
argument_list|,
name|fuuxqt
argument_list|,
name|zlogin
argument_list|,
name|qconn
argument_list|,
name|pzsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
block|}
name|ubuffree
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* The comparison function which we pass to uuconf_callin.  This    expands escape sequences in the login name, and either encrypts or    expands escape sequences in the password.  */
end_comment

begin_function
specifier|static
name|int
name|icallin_cmp
parameter_list|(
name|iwhich
parameter_list|,
name|pinfo
parameter_list|,
name|zfile
parameter_list|)
name|int
name|iwhich
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|struct
name|scallin_info
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|scallin_info
operator|*
operator|)
name|pinfo
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|int
name|icmp
decl_stmt|;
if|#
directive|if
name|HAVE_ENCRYPTED_PASSWORDS
if|if
condition|(
name|iwhich
operator|!=
literal|0
condition|)
return|return
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|qinfo
operator|->
name|zpass
argument_list|,
name|zfile
argument_list|)
argument_list|,
name|zfile
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cescape
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwhich
operator|==
literal|0
condition|)
name|icmp
operator|=
name|strcmp
argument_list|(
name|qinfo
operator|->
name|zuser
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
else|else
name|icmp
operator|=
name|strcmp
argument_list|(
name|qinfo
operator|->
name|zpass
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|icmp
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Accept a call from a remote system.  If pqsys is not NULL, *pqsys    will be set to the system that called in if known.  */
end_comment

begin_function
specifier|static
name|boolean
name|faccept_call
parameter_list|(
name|puuconf
parameter_list|,
name|zconfig
parameter_list|,
name|fuuxqt
parameter_list|,
name|zlogin
parameter_list|,
name|qconn
parameter_list|,
name|pzsystem
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zconfig
decl_stmt|;
name|boolean
name|fuuxqt
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlogin
decl_stmt|;
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzsystem
decl_stmt|;
block|{
name|long
name|istart_time
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
name|int
name|istrip
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|struct
name|uuconf_port
name|sport
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|struct
name|uuconf_dialer
name|sdialer
decl_stmt|;
name|boolean
name|ftcp_port
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|,
modifier|*
name|zspace
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|char
modifier|*
name|zstr
decl_stmt|;
name|struct
name|uuconf_system
name|ssys
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qany
decl_stmt|;
name|char
modifier|*
name|zloc
decl_stmt|;
name|struct
name|sstatus
name|sstat
decl_stmt|;
name|boolean
name|fgotseq
decl_stmt|,
name|fgotn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zlog
decl_stmt|;
name|char
modifier|*
name|zgrade
decl_stmt|;
if|if
condition|(
name|pzsystem
operator|!=
name|NULL
condition|)
operator|*
name|pzsystem
operator|=
name|NULL
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Incoming call (login %s port %s)"
argument_list|,
name|zlogin
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
name|istart_time
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_strip
argument_list|(
name|puuconf
argument_list|,
operator|&
name|istrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|uuconf_port
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|sport
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fstrip
operator|=
operator|(
name|istrip
operator|&
name|UUCONF_STRIP_PROTO
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Figure out protocol parameters determined by the port.  If no      port was specified we're reading standard input, so try to get      the port name and read information from the port file.  We only      use the port information to get protocol parameters; we don't      want to start treating the port as though it were a modem, for      example.  */
if|if
condition|(
name|qconn
operator|->
name|qport
operator|!=
name|NULL
condition|)
block|{
name|qport
operator|=
name|qconn
operator|->
name|qport
expr_stmt|;
name|zport
operator|=
name|qport
operator|->
name|uuconf_zname
expr_stmt|;
name|ftcp_port
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|zport
operator|=
name|zsysdep_port_name
argument_list|(
operator|&
name|ftcp_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|zport
operator|==
name|NULL
condition|)
block|{
name|qport
operator|=
name|NULL
expr_stmt|;
name|zport
operator|=
literal|"unknown"
expr_stmt|;
block|}
else|else
block|{
name|iuuconf
operator|=
name|uuconf_find_port
argument_list|(
name|puuconf
argument_list|,
name|zport
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|uuconf_port
operator|*
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|&
name|sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
name|qport
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|uuconf_port
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|sport
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
name|qport
operator|=
operator|&
name|sport
expr_stmt|;
block|}
block|}
comment|/* If we've managed to figure out that this is a modem port, now try      to get protocol parameters from the dialer.  */
name|qdialer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|uuconf_ttype
operator|==
name|UUCONF_PORTTYPE_MODEM
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_pzdialer
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zdialer
decl_stmt|;
name|zdialer
operator|=
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_pzdialer
index|[
literal|0
index|]
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_dialer_info
argument_list|(
name|puuconf
argument_list|,
name|zdialer
argument_list|,
operator|&
name|sdialer
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_SUCCESS
condition|)
name|qdialer
operator|=
operator|&
name|sdialer
expr_stmt|;
block|}
else|else
name|qdialer
operator|=
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_qdialer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qport
operator|->
name|uuconf_ttype
operator|==
name|UUCONF_PORTTYPE_TCP
operator|||
operator|(
name|qport
operator|->
name|uuconf_ttype
operator|==
name|UUCONF_PORTTYPE_TLI
operator|&&
operator|(
name|qport
operator|->
name|uuconf_ireliable
operator|&
name|UUCONF_RELIABLE_SPECIFIED
operator|)
operator|==
literal|0
operator|)
condition|)
name|ftcp_port
operator|=
name|TRUE
expr_stmt|;
block|}
name|sDaemon
operator|.
name|puuconf
operator|=
name|puuconf
expr_stmt|;
name|sDaemon
operator|.
name|zconfig
operator|=
name|zconfig
expr_stmt|;
if|if
condition|(
operator|!
name|fuuxqt
condition|)
name|sDaemon
operator|.
name|irunuuxqt
operator|=
name|UUCONF_RUNUUXQT_NEVER
expr_stmt|;
else|else
block|{
name|iuuconf
operator|=
name|uuconf_runuuxqt
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sDaemon
operator|.
name|irunuuxqt
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
block|}
name|sDaemon
operator|.
name|qsys
operator|=
name|NULL
expr_stmt|;
name|sDaemon
operator|.
name|zlocalname
operator|=
name|NULL
expr_stmt|;
name|sDaemon
operator|.
name|qconn
operator|=
name|qconn
expr_stmt|;
name|sDaemon
operator|.
name|qproto
operator|=
name|NULL
expr_stmt|;
name|sDaemon
operator|.
name|cchans
operator|=
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|clocal_size
operator|=
operator|-
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|cremote_size
operator|=
operator|-
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|cmax_ever
operator|=
operator|-
literal|2
expr_stmt|;
name|sDaemon
operator|.
name|cmax_receive
operator|=
operator|-
literal|1
expr_stmt|;
name|sDaemon
operator|.
name|csent
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|creceived
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|cxfiles_received
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|ifeatures
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|frequest_hangup
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fhangup_requested
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fhangup
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fmaster
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|fcaller
operator|=
name|FALSE
expr_stmt|;
name|sDaemon
operator|.
name|ireliable
operator|=
literal|0
expr_stmt|;
name|sDaemon
operator|.
name|bgrade
operator|=
name|UUCONF_GRADE_LOW
expr_stmt|;
comment|/* Get the local name to use.  If uuconf_login_localname returns a      value, it is not always freed up, although it should be.  */
name|iuuconf
operator|=
name|uuconf_login_localname
argument_list|(
name|puuconf
argument_list|,
name|zlogin
argument_list|,
operator|&
name|zloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_SUCCESS
condition|)
name|sDaemon
operator|.
name|zlocalname
operator|=
name|zloc
expr_stmt|;
elseif|else
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|sDaemon
operator|.
name|zlocalname
operator|=
name|zsysdep_localname
argument_list|()
expr_stmt|;
if|if
condition|(
name|sDaemon
operator|.
name|zlocalname
operator|==
name|NULL
condition|)
block|{
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Tell the remote system who we are.   */
name|zsend
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|sDaemon
operator|.
name|zlocalname
argument_list|)
operator|+
sizeof|sizeof
expr|"Shere="
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"Shere=%s"
argument_list|,
name|sDaemon
operator|.
name|zlocalname
argument_list|)
expr_stmt|;
name|fret
operator|=
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|zsend
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
block|{
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
block|{
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'S'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad introduction string"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zspace
operator|=
name|strchr
argument_list|(
name|zstr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|zspace
operator|!=
name|NULL
condition|)
operator|*
name|zspace
operator|=
literal|'\0'
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zstr
operator|+
literal|1
argument_list|,
operator|&
name|ssys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|char
modifier|*
name|zscript
decl_stmt|;
comment|/* Run the remote.unknown script, if appropriate.  */
name|iuuconf
operator|=
name|uuconf_remote_unknown
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zscript
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_unknown_caller
argument_list|(
name|zscript
argument_list|,
name|zstr
operator|+
literal|1
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zscript
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RYou are unknown to me"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zscript
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|funknown_system
argument_list|(
name|puuconf
argument_list|,
name|zstr
operator|+
literal|1
argument_list|,
operator|&
name|ssys
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RYou are unknown to me"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Call from unknown system %s"
argument_list|,
name|zstr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qany
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|qsys
operator|=
operator|&
name|ssys
init|;
name|qsys
operator|!=
name|NULL
condition|;
name|qsys
operator|=
name|qsys
operator|->
name|uuconf_qalternate
control|)
block|{
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fcalled
condition|)
continue|continue;
if|if
condition|(
name|qsys
operator|->
name|uuconf_zcalled_login
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|qsys
operator|->
name|uuconf_zcalled_login
argument_list|,
literal|"ANY"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|qany
operator|==
name|NULL
condition|)
name|qany
operator|=
name|qsys
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|qsys
operator|->
name|uuconf_zcalled_login
argument_list|,
name|zlogin
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|qsys
operator|==
name|NULL
operator|&&
name|qany
operator|!=
name|NULL
condition|)
block|{
name|iuuconf
operator|=
name|uuconf_validate
argument_list|(
name|puuconf
argument_list|,
name|qany
argument_list|,
name|zlogin
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_SUCCESS
condition|)
name|qsys
operator|=
name|qany
expr_stmt|;
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RLOGIN"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System %s used wrong login name %s"
argument_list|,
name|zstr
operator|+
literal|1
argument_list|,
name|zlogin
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sDaemon
operator|.
name|qsys
operator|=
name|qsys
expr_stmt|;
if|if
condition|(
name|pzsystem
operator|!=
name|NULL
condition|)
operator|*
name|pzsystem
operator|=
name|zbufcpy
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
name|ulog_system
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|qsys
operator|->
name|uuconf_zdebug
operator|!=
name|NULL
condition|)
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|qsys
operator|->
name|uuconf_zdebug
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if we are supposed to call the system back.  This will queue      up an empty command.  It would be better to actually call back      directly at this point as well.  */
if|if
condition|(
name|qsys
operator|->
name|uuconf_fcallback
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RCB"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Will call back"
argument_list|)
expr_stmt|;
comment|/* Clear any existing status.  */
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
name|sstat
operator|.
name|cretries
operator|=
literal|0
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|cwait
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsysdep_spool_commands
argument_list|(
name|qsys
argument_list|,
name|UUCONF_GRADE_HIGH
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
expr|struct
name|scmd
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We only permit one call at a time from a remote system.  Lock it.  */
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
name|qsys
argument_list|)
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|uuconf_fsequence
condition|)
block|{
comment|/* At this point the calling system has already incremented 	     its sequence number, so we increment ours.  This will 	     only cause a mismatch if the other system is not what it 	     says it is.  */
operator|(
name|void
operator|)
name|ixsysdep_get_sequence
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RLCK"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System already locked"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sLocked_system
operator|=
operator|*
name|qsys
expr_stmt|;
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
comment|/* Set the system status.  We don't care what the status was before.      We also don't want to kill the conversation just because we can't      output the .Status file, so we ignore any errors.  */
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_TALKING
expr_stmt|;
name|sstat
operator|.
name|cretries
operator|=
literal|0
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|cwait
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
comment|/* Check the arguments of the remote system, if any.  */
name|fgotseq
operator|=
name|FALSE
expr_stmt|;
name|fgotn
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zspace
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|paz
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzset
decl_stmt|;
operator|++
name|zspace
expr_stmt|;
comment|/* Break the introduction line up into arguments.  */
name|paz
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|zspace
argument_list|)
operator|/
literal|2
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pzset
operator|=
name|paz
expr_stmt|;
operator|*
name|pzset
operator|++
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
while|while
condition|(
operator|*
name|zspace
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zspace
argument_list|)
argument_list|)
condition|)
operator|++
name|zspace
expr_stmt|;
if|if
condition|(
operator|*
name|zspace
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|pzset
operator|++
operator|=
name|zspace
expr_stmt|;
operator|++
name|zspace
expr_stmt|;
while|while
condition|(
operator|*
name|zspace
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zspace
argument_list|)
argument_list|)
condition|)
operator|++
name|zspace
expr_stmt|;
if|if
condition|(
operator|*
name|zspace
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|zspace
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|pzset
operator|!=
name|paz
operator|+
literal|1
condition|)
block|{
name|int
name|iopt
decl_stmt|;
operator|*
name|pzset
operator|=
name|NULL
expr_stmt|;
comment|/* We are going to use getopt to parse the arguments.  We 	     must clear optind to force getopt to reinitialize, and 	     clear opterr to prevent getopt from printing an error 	     message.  This approach assumes we are using the GNU 	     getopt, which is distributed with the program anyhow.  */
name|optind
operator|=
literal|0
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|pzset
operator|-
name|paz
argument_list|,
name|paz
argument_list|,
literal|"N::p:Q:RU:v:x:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|long
name|iseq
decl_stmt|;
name|long
name|c
decl_stmt|;
name|char
name|b
decl_stmt|;
name|int
name|iwant
decl_stmt|;
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* This is used to indicate support for Taylor UUCP 		     extensions.  An plain -N mean support for size 		     negotiation.  If -N is followed by a number (with 		     no intervening space), the number is a bit field 		     of feature flags as defined in trans.h.  Note 		     that the argument may start with 0x for hex or 0 		     for octal.  */
name|fgotn
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
name|sDaemon
operator|.
name|ifeatures
operator||=
name|FEATURE_SIZES
operator||
name|FEATURE_V103
expr_stmt|;
else|else
name|sDaemon
operator|.
name|ifeatures
operator||=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* The argument is the lowest grade of work the 		     local system should send.  */
if|if
condition|(
name|UUCONF_GRADE_LEGAL
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|sDaemon
operator|.
name|bgrade
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* The conversation sequence number.  */
name|iseq
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_fsequence
operator|&&
name|iseq
operator|!=
name|ixsysdep_get_sequence
argument_list|(
name|qsys
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RBADSEQ"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Out of sequence call rejected"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|paz
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fgotseq
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* The remote system supports file restart.  */
name|sDaemon
operator|.
name|ifeatures
operator||=
name|FEATURE_RESTART
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* The maximum file size the remote system is 		     prepared to received, in blocks where each block 		     is 512 bytes.  */
name|c
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
name|LONG_MAX
operator|/
operator|(
name|long
operator|)
literal|512
condition|)
name|sDaemon
operator|.
name|cmax_receive
operator|=
name|c
operator|*
operator|(
name|long
operator|)
literal|512
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -vgrade=X can be used to set the lowest grade of 		     work the local system should send.  */
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"grade="
argument_list|,
sizeof|sizeof
expr|"grade="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|optarg
index|[
sizeof|sizeof
expr|"grade="
operator|-
literal|1
expr|]
expr_stmt|;
if|if
condition|(
name|UUCONF_GRADE_LEGAL
argument_list|(
name|b
argument_list|)
condition|)
name|sDaemon
operator|.
name|bgrade
operator|=
name|b
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
name|iwant
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|iwant
operator|<=
literal|9
condition|)
name|iwant
operator|=
operator|(
literal|1
operator|<<
name|iwant
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_zmax_remote_debug
operator|!=
name|NULL
condition|)
name|iwant
operator|&=
name|idebug_parse
argument_list|(
name|qsys
operator|->
name|uuconf_zmax_remote_debug
argument_list|)
expr_stmt|;
else|else
name|iwant
operator|&=
name|DEBUG_ABNORMAL
operator||
name|DEBUG_CHAT
operator||
name|DEBUG_HANDSHAKE
expr_stmt|;
if|if
condition|(
operator|(
name|iDebug
operator||
name|iwant
operator|)
operator|!=
name|iDebug
condition|)
block|{
name|iDebug
operator||=
name|iwant
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Setting debugging mode to 0%o"
argument_list|,
name|iDebug
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|paz
argument_list|)
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_fsequence
operator|&&
operator|!
name|fgotseq
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"RBADSEQ"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No sequence number (call rejected)"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We recognized the system, and the sequence number (if any) was      OK.  Send an ROK, and send a list of protocols.  If we got the -N      switch, send ROKN to confirm it; if the -N switch was followed by      a feature bitfield, return our own feature bitfield.  */
block|{
name|char
name|ab
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zreply
decl_stmt|;
if|if
condition|(
operator|!
name|fgotn
condition|)
block|{
if|if
condition|(
operator|(
name|sDaemon
operator|.
name|ifeatures
operator|&
name|FEATURE_RESTART
operator|)
operator|==
literal|0
condition|)
name|zreply
operator|=
literal|"ROK"
expr_stmt|;
else|else
block|{
comment|/* We got -R without -N, so assume that this is SVR4 UUCP. 	       SVR4 UUCP expects ROK -R to signal support for file 	       restart.  */
name|sDaemon
operator|.
name|ifeatures
operator||=
name|FEATURE_SVR4
operator||
name|FEATURE_SIZES
expr_stmt|;
name|zreply
operator|=
literal|"ROK -R"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sDaemon
operator|.
name|ifeatures
operator|&
name|FEATURE_V103
operator|)
operator|!=
literal|0
condition|)
name|zreply
operator|=
literal|"ROKN"
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"ROKN0%o"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|FEATURE_SIZES
operator||
name|FEATURE_EXEC
operator||
name|FEATURE_RESTART
argument_list|)
argument_list|)
expr_stmt|;
name|zreply
operator|=
name|ab
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|zreply
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Determine the reliability of the connection based on the      reliability of the port and the dialer.  If we have no      information, default to a reliable eight-bit full-duplex      connection.  */
if|if
condition|(
name|ftcp_port
condition|)
name|sDaemon
operator|.
name|ireliable
operator|=
operator|(
name|UUCONF_RELIABLE_SPECIFIED
operator||
name|UUCONF_RELIABLE_ENDTOEND
operator||
name|UUCONF_RELIABLE_RELIABLE
operator||
name|UUCONF_RELIABLE_EIGHT
operator||
name|UUCONF_RELIABLE_FULLDUPLEX
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|qport
operator|!=
name|NULL
operator|&&
operator|(
name|qport
operator|->
name|uuconf_ireliable
operator|&
name|UUCONF_RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
name|sDaemon
operator|.
name|ireliable
operator|=
name|qport
operator|->
name|uuconf_ireliable
expr_stmt|;
if|if
condition|(
name|qdialer
operator|!=
name|NULL
operator|&&
operator|(
name|qdialer
operator|->
name|uuconf_ireliable
operator|&
name|UUCONF_RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sDaemon
operator|.
name|ireliable
operator|!=
literal|0
condition|)
name|sDaemon
operator|.
name|ireliable
operator|&=
name|qdialer
operator|->
name|uuconf_ireliable
expr_stmt|;
else|else
name|sDaemon
operator|.
name|ireliable
operator|=
name|qdialer
operator|->
name|uuconf_ireliable
expr_stmt|;
block|}
if|if
condition|(
name|sDaemon
operator|.
name|ireliable
operator|==
literal|0
condition|)
name|sDaemon
operator|.
name|ireliable
operator|=
operator|(
name|UUCONF_RELIABLE_RELIABLE
operator||
name|UUCONF_RELIABLE_EIGHT
operator||
name|UUCONF_RELIABLE_FULLDUPLEX
operator||
name|UUCONF_RELIABLE_SPECIFIED
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|qsys
operator|->
name|uuconf_zprotocols
operator|!=
name|NULL
operator|||
operator|(
name|qport
operator|!=
name|NULL
operator|&&
name|qport
operator|->
name|uuconf_zprotocols
operator|!=
name|NULL
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zprotos
decl_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_zprotocols
operator|!=
name|NULL
condition|)
name|zprotos
operator|=
name|qsys
operator|->
name|uuconf_zprotocols
expr_stmt|;
else|else
name|zprotos
operator|=
name|qport
operator|->
name|uuconf_zprotocols
expr_stmt|;
name|zsend
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zprotos
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"P%s"
argument_list|,
name|zprotos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zsend
operator|=
name|zbufalc
argument_list|(
name|CPROTOCOLS
operator|+
literal|2
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zsend
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|'P'
expr_stmt|;
comment|/* If the system did not specify a list of protocols, we want 	 only protocols that match the known reliability of the dialer 	 and the port.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ipr
decl_stmt|;
name|ipr
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|ireliable
expr_stmt|;
if|if
condition|(
operator|(
name|ipr
operator|&
name|sDaemon
operator|.
name|ireliable
operator|)
operator|!=
name|ipr
condition|)
continue|continue;
operator|*
name|zset
operator|++
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
expr_stmt|;
block|}
operator|*
name|zset
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fret
operator|=
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|zsend
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The master will now send back the selected protocol.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'U'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad protocol response string"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No supported protocol"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
operator|==
name|zstr
index|[
literal|1
index|]
condition|)
break|break;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|CPROTOCOLS
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No supported protocol"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sDaemon
operator|.
name|qproto
operator|=
operator|&
name|asProtocols
index|[
name|i
index|]
expr_stmt|;
comment|/* If we are using a half-duplex line, act as though we have only a      single channel; otherwise we might start a send and a receive at      the same time.  */
if|if
condition|(
operator|(
name|sDaemon
operator|.
name|ireliable
operator|&
name|UUCONF_RELIABLE_FULLDUPLEX
operator|)
operator|==
literal|0
condition|)
name|sDaemon
operator|.
name|cchans
operator|=
literal|1
expr_stmt|;
else|else
name|sDaemon
operator|.
name|cchans
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|cchans
expr_stmt|;
comment|/* Run the chat script for when a call is received.  */
if|if
condition|(
operator|!
name|fchat
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
operator|&
name|qsys
operator|->
name|uuconf_scalled_chat
argument_list|,
name|qsys
argument_list|,
operator|(
specifier|const
expr|struct
name|uuconf_dialer
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|zport
argument_list|,
name|iconn_baud
argument_list|(
name|qconn
argument_list|)
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Run any protocol parameter commands.  */
if|if
condition|(
name|sDaemon
operator|.
name|qproto
operator|->
name|qcmds
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|uuconf_qproto_params
operator|!=
name|NULL
condition|)
name|uapply_proto_params
argument_list|(
name|puuconf
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|bname
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|qcmds
argument_list|,
name|qsys
operator|->
name|uuconf_qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
operator|&&
name|qport
operator|->
name|uuconf_qproto_params
operator|!=
name|NULL
condition|)
name|uapply_proto_params
argument_list|(
name|puuconf
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|bname
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|qcmds
argument_list|,
name|qport
operator|->
name|uuconf_qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdialer
operator|!=
name|NULL
operator|&&
name|qdialer
operator|->
name|uuconf_qproto_params
operator|!=
name|NULL
condition|)
name|uapply_proto_params
argument_list|(
name|puuconf
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|bname
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|qcmds
argument_list|,
name|qdialer
operator|->
name|uuconf_qproto_params
argument_list|)
expr_stmt|;
block|}
comment|/* We don't need the dialer information any more.  */
if|if
condition|(
name|qdialer
operator|==
operator|&
name|sdialer
condition|)
operator|(
name|void
operator|)
name|uuconf_dialer_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sdialer
argument_list|)
expr_stmt|;
comment|/* Turn on the selected protocol and get any jobs queued for the      system.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|sDaemon
operator|.
name|qproto
operator|->
name|pfstart
call|)
argument_list|(
operator|&
name|sDaemon
argument_list|,
operator|&
name|zlog
argument_list|)
operator|||
operator|!
name|fqueue
argument_list|(
operator|&
name|sDaemon
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|uclear_queue
argument_list|(
operator|&
name|sDaemon
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zlog
operator|==
name|NULL
condition|)
block|{
name|zlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"protocol ''"
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zlog
argument_list|,
literal|"protocol '%c'"
argument_list|,
name|sDaemon
operator|.
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
block|}
name|zgrade
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"grade  "
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sDaemon
operator|.
name|bgrade
operator|==
name|UUCONF_GRADE_LOW
condition|)
operator|*
name|zgrade
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zgrade
argument_list|,
literal|"grade %c "
argument_list|,
name|sDaemon
operator|.
name|bgrade
argument_list|)
expr_stmt|;
comment|/* If we are using HAVE_HDB_LOGGING, then the previous ``incoming      call'' message went to the general log, since we didn't know the      system name at that point.  In that case, we repeat the port and      login names.  */
if|#
directive|if
name|HAVE_HDB_LOGGING
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful (login %s port %s %s%s)"
argument_list|,
name|zlogin
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|,
name|zgrade
argument_list|,
name|zlog
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_HDB_LOGGING */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful (%s%s)"
argument_list|,
name|zgrade
argument_list|,
name|zlog
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_HDB_LOGGING */
name|ubuffree
argument_list|(
name|zlog
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zgrade
argument_list|)
expr_stmt|;
block|{
name|long
name|iend_time
decl_stmt|;
name|fret
operator|=
name|floop
argument_list|(
operator|&
name|sDaemon
argument_list|)
expr_stmt|;
comment|/* Hangup.  As the answerer, we send seven O's and expect to        receive six O's.  We send the seven O's twice to help the other        side.  We don't worry about errors here.  */
if|if
condition|(
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"OOOOOOO"
argument_list|)
operator|&&
name|fsend_uucp_cmd
argument_list|(
name|qconn
argument_list|,
literal|"OOOOOOO"
argument_list|)
condition|)
block|{
name|int
name|fdone
decl_stmt|;
comment|/* We look for the remote hangup string to ensure that the 	   modem has sent out our hangup string.  This is only 	   necessary because some versions of UUCP complain if they 	   don't get the hangup string.  We look for the string 	   several times because supposedly some implementations send 	   some garbage after the last packet but before the hangup 	   string.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|qconn
argument_list|,
name|FALSE
argument_list|,
name|fstrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
break|break;
name|fdone
operator|=
name|strstr
argument_list|(
name|zstr
argument_list|,
literal|"OOOOOO"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|ubuffree
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdone
condition|)
break|break;
block|}
block|}
name|iend_time
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Call complete (%ld seconds %ld bytes %ld bps)"
argument_list|,
name|iend_time
operator|-
name|istart_time
argument_list|,
name|sDaemon
operator|.
name|csent
operator|+
name|sDaemon
operator|.
name|creceived
argument_list|,
operator|(
name|iend_time
operator|!=
name|istart_time
condition|?
operator|(
name|sDaemon
operator|.
name|csent
operator|+
name|sDaemon
operator|.
name|creceived
operator|)
operator|/
operator|(
name|iend_time
operator|-
name|istart_time
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|uclear_queue
argument_list|(
operator|&
name|sDaemon
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
else|else
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|iend_time
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sDaemon
operator|.
name|irunuuxqt
operator|==
name|UUCONF_RUNUUXQT_PERCALL
operator|||
operator|(
name|sDaemon
operator|.
name|irunuuxqt
operator|>
literal|0
operator|&&
name|sDaemon
operator|.
name|cxfiles_received
operator|>
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|fspawn_uuxqt
argument_list|(
name|TRUE
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
name|uaccept_call_cleanup
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|,
name|qport
argument_list|,
operator|&
name|sport
argument_list|,
name|zloc
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
block|}
end_function

begin_comment
comment|/* Clean up after faccept_call.  */
end_comment

begin_function
specifier|static
name|void
name|uaccept_call_cleanup
parameter_list|(
name|puuconf
parameter_list|,
name|qfreesys
parameter_list|,
name|qport
parameter_list|,
name|qfreeport
parameter_list|,
name|zloc
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qfreesys
decl_stmt|;
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
name|struct
name|uuconf_port
modifier|*
name|qfreeport
decl_stmt|;
name|char
modifier|*
name|zloc
decl_stmt|;
block|{
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|qfreesys
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
name|qfreesys
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|==
name|qfreeport
condition|)
operator|(
name|void
operator|)
name|uuconf_port_free
argument_list|(
name|puuconf
argument_list|,
name|qfreeport
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zloc
argument_list|)
expr_stmt|;
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Apply protocol parameters, once we know the protocol.  */
end_comment

begin_function
specifier|static
name|void
name|uapply_proto_params
parameter_list|(
name|puuconf
parameter_list|,
name|bproto
parameter_list|,
name|qcmds
parameter_list|,
name|pas
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
name|int
name|bproto
decl_stmt|;
name|struct
name|uuconf_cmdtab
modifier|*
name|qcmds
decl_stmt|;
name|struct
name|uuconf_proto_param
modifier|*
name|pas
decl_stmt|;
block|{
name|struct
name|uuconf_proto_param
modifier|*
name|qp
decl_stmt|;
for|for
control|(
name|qp
operator|=
name|pas
init|;
name|qp
operator|->
name|uuconf_bproto
operator|!=
literal|'\0'
condition|;
name|qp
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|uuconf_bproto
operator|==
name|bproto
condition|)
block|{
name|struct
name|uuconf_proto_param_entry
modifier|*
name|qe
decl_stmt|;
for|for
control|(
name|qe
operator|=
name|qp
operator|->
name|uuconf_qentries
init|;
name|qe
operator|->
name|uuconf_cargs
operator|>
literal|0
condition|;
name|qe
operator|++
control|)
block|{
name|int
name|iuuconf
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_cmd_args
argument_list|(
name|puuconf
argument_list|,
name|qe
operator|->
name|uuconf_cargs
argument_list|,
name|qe
operator|->
name|uuconf_pzargs
argument_list|,
name|qcmds
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|(
name|uuconf_cmdtabfn
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|UUCONF_ERROR_VALUE
argument_list|(
name|iuuconf
argument_list|)
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Error in %c protocol parameters"
argument_list|,
name|bproto
argument_list|)
expr_stmt|;
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a string to the other system beginning with a DLE    character and terminated with a null byte.  This is only    used when no protocol is in force.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsend_uucp_cmd
parameter_list|(
name|qconn
parameter_list|,
name|z
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|size_t
name|cwrite
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"fsend_uucp_cmd: Sending \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|cwrite
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|2
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
name|cwrite
argument_list|)
expr_stmt|;
name|zalc
index|[
literal|0
index|]
operator|=
literal|'\020'
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
operator|+
literal|1
argument_list|,
name|z
argument_list|,
name|cwrite
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fret
operator|=
name|fconn_write
argument_list|(
name|qconn
argument_list|,
name|zalc
argument_list|,
name|cwrite
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Get a UUCP command beginning with a DLE character and ending with a    null byte.  This is only used when no protocol is in force.  This    implementation has the potential of being seriously slow.  It also    doesn't have any real error recovery.  The frequired argument is    passed as TRUE if we need the string; we don't care that much if    we're closing down the connection anyhow.  */
end_comment

begin_define
define|#
directive|define
name|CTIMEOUT
value|(120)
end_define

begin_define
define|#
directive|define
name|CSHORTTIMEOUT
value|(10)
end_define

begin_define
define|#
directive|define
name|CINCREMENT
value|(100)
end_define

begin_function
specifier|static
name|char
modifier|*
name|zget_uucp_cmd
parameter_list|(
name|qconn
parameter_list|,
name|frequired
parameter_list|,
name|fstrip
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|boolean
name|frequired
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
block|{
name|char
modifier|*
name|zalc
decl_stmt|;
name|size_t
name|calc
decl_stmt|;
name|size_t
name|cgot
decl_stmt|;
name|boolean
name|fintro
decl_stmt|;
name|long
name|iendtime
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cchars
decl_stmt|;
name|int
name|iolddebug
decl_stmt|;
endif|#
directive|endif
name|iendtime
operator|=
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|frequired
condition|)
name|iendtime
operator|+=
name|CTIMEOUT
expr_stmt|;
else|else
name|iendtime
operator|+=
name|CSHORTTIMEOUT
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|cchars
operator|=
literal|0
expr_stmt|;
name|iolddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_uucp_cmd: Got \""
argument_list|)
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_INCOMING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|zalc
operator|=
name|NULL
expr_stmt|;
name|calc
operator|=
literal|0
expr_stmt|;
name|cgot
operator|=
literal|0
expr_stmt|;
name|fintro
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|ctimeout
operator|=
call|(
name|int
call|)
argument_list|(
name|iendtime
operator|-
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
name|b
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
name|ctimeout
argument_list|,
name|frequired
argument_list|)
expr_stmt|;
comment|/* Now b == -1 on timeout, -2 on error.  */
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (%s)"
argument_list|,
name|b
operator|==
operator|-
literal|1
condition|?
literal|"timeout"
else|:
literal|"error"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|b
operator|==
operator|-
literal|1
operator|&&
name|frequired
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Apparently some systems use parity on these strings, so we 	 optionally strip the parity bit.  */
if|if
condition|(
name|fstrip
condition|)
name|b
operator|&=
literal|0x7f
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|++
name|cchars
expr_stmt|;
if|if
condition|(
name|cchars
operator|>
literal|60
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_uucp_cmd: Got \""
argument_list|)
expr_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|fintro
condition|)
block|{
if|if
condition|(
name|b
operator|==
literal|'\020'
condition|)
name|fintro
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* If we see another DLE, something has gone wrong; continue 	 as though this were the first one we saw.  */
if|if
condition|(
name|b
operator|==
literal|'\020'
condition|)
block|{
name|cgot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Some systems send a trailing \n on the Shere line.  As far as 	 I can tell this line can never contain a \n, so this 	 modification should be safe enough.  */
if|if
condition|(
name|b
operator|==
literal|'\r'
operator|||
name|b
operator|==
literal|'\n'
condition|)
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cgot
operator|>=
name|calc
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|calc
operator|+=
name|CINCREMENT
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|calc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|znew
argument_list|,
name|zalc
argument_list|,
name|cgot
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|znew
expr_stmt|;
block|}
name|zalc
index|[
name|cgot
index|]
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
operator|++
name|cgot
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|zalc
return|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (timeout)"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
if|if
condition|(
name|frequired
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read a sequence of characters up to a newline or carriage return,    and return the line without the line terminating character.    Remember whether the last string we returned ended in \r; if it    did, ignore a leading \n to account for \r\n pairs.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zget_typed_line
parameter_list|(
name|qconn
parameter_list|,
name|fstrip
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
block|{
specifier|static
name|boolean
name|flastcr
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|size_t
name|calc
decl_stmt|;
name|size_t
name|cgot
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cchars
decl_stmt|;
name|int
name|iolddebug
decl_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
name|iolddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_typed_line: Got \""
argument_list|)
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_INCOMING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|zalc
operator|=
name|NULL
expr_stmt|;
name|calc
operator|=
literal|0
expr_stmt|;
name|cgot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|b
decl_stmt|;
name|b
operator|=
name|breceive_char
argument_list|(
name|qconn
argument_list|,
name|CTIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Now b == -1 on timeout, -2 on error.  */
if|if
condition|(
name|b
operator|==
operator|-
literal|2
operator|||
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (error)"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|flastcr
operator|=
name|FALSE
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
name|flastcr
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Optionally strip the parity bit.  */
if|if
condition|(
name|fstrip
condition|)
name|b
operator|&=
literal|0x7f
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|++
name|cchars
expr_stmt|;
if|if
condition|(
name|cchars
operator|>
literal|60
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_typed_line: Got \""
argument_list|)
expr_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|b
operator|==
literal|'\n'
operator|&&
name|cgot
operator|==
literal|0
operator|&&
name|flastcr
condition|)
block|{
comment|/* Ignore \n in \r\n pair.  */
name|flastcr
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|flastcr
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cgot
operator|>=
name|calc
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|calc
operator|+=
name|CINCREMENT
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|calc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|znew
argument_list|,
name|zalc
argument_list|,
name|cgot
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|znew
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|'\n'
condition|)
name|b
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|'\r'
condition|)
block|{
name|flastcr
operator|=
name|TRUE
expr_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
block|}
name|zalc
index|[
name|cgot
index|]
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
operator|++
name|cgot
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|zalc
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Spawn a uuxqt job.  This probably belongs in some other file, but I    don't have a good place for it.  */
end_comment

begin_function
name|boolean
name|fspawn_uuxqt
parameter_list|(
name|ffork
parameter_list|,
name|zsys
parameter_list|,
name|zconfig
parameter_list|)
name|boolean
name|ffork
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zconfig
decl_stmt|;
block|{
name|char
modifier|*
name|zsysarg
decl_stmt|;
name|char
modifier|*
name|zconfigarg
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
name|zsys
operator|==
name|NULL
condition|)
name|zsysarg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|zsysarg
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"-s"
operator|+
name|strlen
argument_list|(
name|zsys
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zsysarg
argument_list|,
literal|"-s%s"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zconfig
operator|==
name|NULL
condition|)
name|zconfigarg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|zconfigarg
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"-I"
operator|+
name|strlen
argument_list|(
name|zconfig
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zconfigarg
argument_list|,
literal|"-I%s"
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsysarg
operator|==
name|NULL
condition|)
block|{
name|zsysarg
operator|=
name|zconfigarg
expr_stmt|;
name|zconfigarg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|fret
operator|=
name|fsysdep_run
argument_list|(
name|ffork
argument_list|,
literal|"uuxqt"
argument_list|,
name|zsysarg
argument_list|,
name|zconfigarg
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsysarg
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zconfigarg
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

end_unit

