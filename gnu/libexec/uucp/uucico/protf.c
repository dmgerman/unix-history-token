begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* protf.c    The 'f' protocol.     Copyright (C) 1991, 1992, 1993 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|protf_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This implementation is based on code by Piet Beertema, CWI,    Amsterdam, Sep 1984.     This code implements the 'f' protocol, which requires a    flow-controlled error-free seven-bit data path.  It does check for    errors, but only at the end of each file transmission, so a noisy    line without error correcting modems will be unusable.     The conversion to seven bit data is done as follows, where b    represents the character to convert:        0<= b<=  037: 0172, b + 0100 (0100 to 0137)     040<= b<= 0171:       b        ( 040 to 0171)    0172<= b<= 0177: 0173, b - 0100 ( 072 to 077)    0200<= b<= 0237: 0174, b - 0100 (0100 to 0137)    0240<= b<= 0371: 0175, b - 0200 ( 040 to 0171)    0372<= b<= 0377: 0176, b - 0300 ( 072 to 077)     This causes all output bytes to be in the range 040 to 0176; these    are the printable ASCII characters.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This structure is used to hold information when dealing with the    end of file acknowledgement.  */
end_comment

begin_struct
struct|struct
name|sfinfo
block|{
comment|/* The functions from the generic code.  */
name|boolean
argument_list|(
argument|*psendfn
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*precfn
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
expr_stmt|;
comment|/* The info pointer from the generic code.  */
name|pointer
name|pinfo
decl_stmt|;
comment|/* The character to send after receiving the checksum.  */
name|char
name|bsend
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ffprocess_data
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
operator|*
name|pfexit
operator|,
name|size_t
operator|*
name|pcneed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ffawait_ack
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ffawait_cksum
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ffsend_ack
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The size of the buffer we allocate to store outgoing data in.  */
end_comment

begin_define
define|#
directive|define
name|CFBUFSIZE
value|(256)
end_define

begin_comment
comment|/* The timeout to wait for data to arrive before giving up.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cFtimeout
init|=
literal|120
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of retries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cFmaxretries
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The buffer we allocate for outgoing data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zFbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we are receiving a file rather than a command.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fFfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The checksum so far.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|iFcheck
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last special byte (0172 to 0176) or 0 if none.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bFspecial
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times we have retried this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cFretries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether this file has been acknowledged.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fFacked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uuconf_cmdtab
name|asFproto_params
index|[]
init|=
block|{
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cFtimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cFmaxretries
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics.  */
end_comment

begin_comment
comment|/* The number of data bytes sent in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFsent_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of actual bytes sent in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFsent_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of data bytes received in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFrec_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of actual bytes received in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFrec_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of file retries when sending.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFsend_retries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of file retries when receiving.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFrec_retries
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start the protocol.  */
end_comment

begin_function
name|boolean
name|ffstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
operator|*
name|pzlog
operator|=
name|NULL
expr_stmt|;
name|cFsent_data
operator|=
literal|0
expr_stmt|;
name|cFsent_bytes
operator|=
literal|0
expr_stmt|;
name|cFrec_data
operator|=
literal|0
expr_stmt|;
name|cFrec_bytes
operator|=
literal|0
expr_stmt|;
name|cFsend_retries
operator|=
literal|0
expr_stmt|;
name|cFrec_retries
operator|=
literal|0
expr_stmt|;
comment|/* Use XON/XOFF handshaking.  */
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|PARITYSETTING_DEFAULT
argument_list|,
name|STRIPSETTING_SEVENBITS
argument_list|,
name|XONXOFF_ON
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We sleep to allow the other side to reset the terminal; this is      what Mr. Beertema's code does.  */
name|usysdep_sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shutdown the protocol.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
name|boolean
name|ffshutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zFbuf
argument_list|)
expr_stmt|;
name|zFbuf
operator|=
name|NULL
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'f': sent %ld bytes for %ld, received %ld bytes for %ld"
argument_list|,
name|cFsent_bytes
argument_list|,
name|cFsent_data
argument_list|,
name|cFrec_bytes
argument_list|,
name|cFrec_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cFsend_retries
operator|!=
literal|0
operator|||
name|cFrec_retries
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'f' file retries: %ld sending, %ld receiving"
argument_list|,
name|cFsend_retries
argument_list|,
name|cFrec_retries
argument_list|)
expr_stmt|;
name|cFtimeout
operator|=
literal|120
expr_stmt|;
name|cFmaxretries
operator|=
literal|2
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a command string.  We just send the string followed by a carriage    return.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|ffsendcmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|size_t
name|clen
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"ffsendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
argument_list|,
name|z
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zalc
index|[
name|clen
index|]
operator|=
literal|'\r'
expr_stmt|;
name|zalc
index|[
name|clen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fret
operator|=
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zalc
argument_list|,
name|clen
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get space to be filled with data.  We allocate the space from the    heap.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
name|char
modifier|*
name|zfgetspace
parameter_list|(
name|qdaemon
parameter_list|,
name|pclen
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|CFBUFSIZE
expr_stmt|;
if|if
condition|(
name|zFbuf
operator|==
name|NULL
condition|)
name|zFbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CFBUFSIZE
argument_list|)
expr_stmt|;
return|return
name|zFbuf
return|;
block|}
end_function

begin_comment
comment|/* Send out a data packet.  We have to encode the data into seven bits    and accumulate a checksum.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
name|boolean
name|ffsenddata
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
block|{
name|char
name|ab
index|[
name|CFBUFSIZE
operator|*
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|ze
decl_stmt|;
specifier|register
name|unsigned
name|int
name|itmpchk
decl_stmt|;
name|cFsent_data
operator|+=
name|cdata
expr_stmt|;
name|ze
operator|=
name|ab
expr_stmt|;
name|itmpchk
operator|=
name|iFcheck
expr_stmt|;
while|while
condition|(
name|cdata
operator|--
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|b
decl_stmt|;
comment|/* Rotate the checksum left.  */
if|if
condition|(
operator|(
name|itmpchk
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
operator|++
name|itmpchk
expr_stmt|;
block|}
comment|/* Add the next byte into the checksum.  */
name|b
operator|=
operator|*
name|zdata
operator|++
operator|&
literal|0xff
expr_stmt|;
name|itmpchk
operator|+=
name|b
expr_stmt|;
comment|/* Encode the byte.  */
if|if
condition|(
name|b
operator|<=
literal|0177
condition|)
block|{
if|if
condition|(
name|b
operator|<=
literal|037
condition|)
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\172'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|+
literal|0100
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|<=
literal|0171
condition|)
operator|*
name|ze
operator|++
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
else|else
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\173'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|<=
literal|0237
condition|)
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\174'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0100
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|<=
literal|0371
condition|)
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\175'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0200
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\176'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0300
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|iFcheck
operator|=
name|itmpchk
expr_stmt|;
name|cFsent_bytes
operator|+=
name|ze
operator|-
name|ab
expr_stmt|;
comment|/* Passing FALSE tells fsend_data not to bother looking for incoming      information, since we really don't expect any.  */
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|ab
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|ze
operator|-
name|ab
argument_list|)
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process data and return the amount of data we are looking for in    *pcneed.  The 'f' protocol doesn't really reveal this, but when    transferring file we know that we need at least seven characters    for the checksum.  */
end_comment

begin_function
specifier|static
name|boolean
name|ffprocess_data
parameter_list|(
name|qdaemon
parameter_list|,
name|pfexit
parameter_list|,
name|pcneed
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
name|size_t
modifier|*
name|pcneed
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|itmpchk
decl_stmt|;
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fFfile
condition|)
block|{
comment|/* A command continues until a '\r' character, which we turn 	 into '\0' before calling fgot_data.  */
while|while
condition|(
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
for|for
control|(
name|i
operator|=
name|iPrecstart
init|;
name|i
operator|<
name|CRECBUFLEN
operator|&&
name|i
operator|!=
name|iPrecend
condition|;
name|i
operator|++
control|)
block|{
comment|/* Some systems seem to send characters with parity, so 		 strip the parity bit.  */
name|abPrecbuf
index|[
name|i
index|]
operator|&=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|abPrecbuf
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
block|{
name|int
name|istart
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"ffprocess_data: Got %d command bytes"
argument_list|,
name|i
operator|-
name|iPrecstart
operator|+
literal|1
argument_list|)
expr_stmt|;
name|abPrecbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|istart
operator|=
name|iPrecstart
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
literal|0
expr_stmt|;
return|return
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
operator|+
name|istart
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|i
operator|-
name|istart
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
return|;
block|}
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"ffprocess_data: Got %d command bytes"
argument_list|,
name|i
operator|-
name|iPrecstart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|i
operator|-
name|iPrecstart
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
name|i
operator|%
name|CRECBUFLEN
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Here the data is destined for a file, and we must decode it.  */
name|itmpchk
operator|=
name|iFcheck
expr_stmt|;
while|while
condition|(
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
name|char
modifier|*
name|zstart
decl_stmt|,
modifier|*
name|zto
decl_stmt|,
modifier|*
name|zfrom
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zto
operator|=
name|zfrom
operator|=
name|zstart
operator|=
name|abPrecbuf
operator|+
name|iPrecstart
expr_stmt|;
name|c
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
comment|/* Some systems seem to send characters with parity, so 	     strip the parity bit.  */
name|b
operator|=
operator|*
name|zfrom
operator|++
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|040
operator|||
name|b
operator|>
literal|0176
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal byte %d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Characters>= 0172 are always special characters.  The 	     only legal pair of consecutive special characters 	     are 0176 0176 which immediately precede the four 	     digit checksum.  */
if|if
condition|(
name|b
operator|>=
literal|0172
condition|)
block|{
if|if
condition|(
name|bFspecial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bFspecial
operator|!=
literal|0176
operator|||
name|b
operator|!=
literal|0176
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal bytes %d %d"
argument_list|,
name|bFspecial
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|bFspecial
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Pass any initial data.  */
if|if
condition|(
name|zto
operator|!=
name|zstart
condition|)
block|{
comment|/* Don't count the checksum in the received bytes.  */
name|cFrec_bytes
operator|+=
name|zfrom
operator|-
name|zstart
operator|-
literal|2
expr_stmt|;
name|cFrec_data
operator|+=
name|zto
operator|-
name|zstart
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zstart
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|zto
operator|-
name|zstart
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The next characters we want to read are the 		     checksum, so skip the second 0176.  */
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|zfrom
operator|-
name|zstart
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|iFcheck
operator|=
name|itmpchk
expr_stmt|;
comment|/* Tell fgot_data that we've read the entire file by 		     passing 0 length data.  This will wind up calling 		     fffile to verify the checksum.  We set *pcneed to 		     0 because we don't want to read any more data 		     from the port, since we may have already read the 		     checksum.  */
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
literal|0
expr_stmt|;
return|return
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
return|;
block|}
comment|/* Here we have encountered a special character that 		 does not follow another special character.  */
name|bFspecial
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
block|}
else|else
block|{
name|int
name|bnext
decl_stmt|;
comment|/* Here we have encountered a nonspecial character.  */
switch|switch
condition|(
name|bFspecial
condition|)
block|{
default|default:
name|bnext
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|0172
case|:
name|bnext
operator|=
name|b
operator|-
literal|0100
expr_stmt|;
break|break;
case|case
literal|0173
case|:
case|case
literal|0174
case|:
name|bnext
operator|=
name|b
operator|+
literal|0100
expr_stmt|;
break|break;
case|case
literal|0175
case|:
name|bnext
operator|=
name|b
operator|+
literal|0200
expr_stmt|;
break|break;
case|case
literal|0176
case|:
name|bnext
operator|=
name|b
operator|+
literal|0300
expr_stmt|;
break|break;
block|}
operator|*
name|zto
operator|++
operator|=
operator|(
name|char
operator|)
name|bnext
expr_stmt|;
name|bFspecial
operator|=
literal|0
expr_stmt|;
comment|/* Rotate the checksum left.  */
if|if
condition|(
operator|(
name|itmpchk
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
operator|++
name|itmpchk
expr_stmt|;
block|}
comment|/* Add the next byte into the checksum.  */
name|itmpchk
operator|+=
name|bnext
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zto
operator|!=
name|zstart
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"ffprocess_data: Got %d bytes"
argument_list|,
name|zto
operator|-
name|zstart
argument_list|)
expr_stmt|;
name|cFrec_data
operator|+=
name|zto
operator|-
name|zstart
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zstart
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|zto
operator|-
name|zstart
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|cFrec_bytes
operator|+=
name|zfrom
operator|-
name|zstart
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|zfrom
operator|-
name|zstart
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
block|}
name|iFcheck
operator|=
name|itmpchk
expr_stmt|;
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
block|{
comment|/* At this point we may have seen the first 0176 in the checksum 	 but not the second.  The checksum is at least seven 	 characters long (0176 0176 a b c d \r).  This won't help 	 much, but reading seven characters is a lot better than 	 reading two, which is what I saw in a 2400 baud log file.  */
if|if
condition|(
name|bFspecial
operator|==
literal|0176
condition|)
operator|*
name|pcneed
operator|=
literal|6
expr_stmt|;
else|else
operator|*
name|pcneed
operator|=
literal|7
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for data to come in and process it until we've finished a    command or a file.  */
end_comment

begin_function
name|boolean
name|ffwait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|fexit
decl_stmt|;
name|size_t
name|cneed
decl_stmt|,
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|ffprocess_data
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|fexit
argument_list|,
operator|&
name|cneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|cneed
operator|>
literal|0
condition|)
block|{
comment|/* We really want to do something like get all available 	     characters, then sleep for half a second and get all 	     available characters again, and keep this up until we 	     don't get anything after sleeping.  */
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|cFtimeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for data"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File level operations.  Reset the checksums when starting to send    or receive a file, and output the checksum when we've finished    sending a file.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fffile
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|,
name|fstart
parameter_list|,
name|fsend
parameter_list|,
name|cbytes
parameter_list|,
name|pfhandled
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|boolean
name|fstart
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|boolean
modifier|*
name|pfhandled
decl_stmt|;
block|{
name|DEBUG_MESSAGE3
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fffile: fstart %s; fsend %s; fFacked %s"
argument_list|,
name|fstart
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
name|fsend
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
name|fFacked
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
operator|*
name|pfhandled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fstart
condition|)
block|{
name|iFcheck
operator|=
literal|0xffff
expr_stmt|;
name|cFretries
operator|=
literal|0
expr_stmt|;
name|fFacked
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsend
condition|)
block|{
name|bFspecial
operator|=
literal|0
expr_stmt|;
name|fFfile
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|struct
name|sfinfo
modifier|*
name|qinfo
decl_stmt|;
comment|/* We need to handle the checksum and the acknowledgement.  If 	 we get a successful ACK, we set fFacked to TRUE and call the 	 send or receive function by hand.  This will wind up calling 	 here again, so if fFacked is TRUE we just return out and let 	 the send or receive function do whatever it does.  This is a 	 bit of a hack.  */
if|if
condition|(
name|fFacked
condition|)
block|{
name|fFacked
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|fsend
condition|)
block|{
name|char
name|ab
index|[
sizeof|sizeof
expr|"\176\176ABCD\r"]
expr_stmt|;
comment|/* Send the final checksum.  */
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"\176\176%04x\r"
argument_list|,
name|iFcheck
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|ab
argument_list|,
operator|(
name|size_t
operator|)
literal|7
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now wait for the acknowledgement.  */
name|fFfile
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|sfinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|psendfn
operator|=
name|qtrans
operator|->
name|psendfn
expr_stmt|;
name|qinfo
operator|->
name|precfn
operator|=
name|qtrans
operator|->
name|precfn
expr_stmt|;
name|qinfo
operator|->
name|pinfo
operator|=
name|qtrans
operator|->
name|pinfo
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|NULL
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|ffawait_ack
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
name|qtrans
operator|->
name|fcmd
operator|=
name|TRUE
expr_stmt|;
operator|*
name|pfhandled
operator|=
name|TRUE
expr_stmt|;
return|return
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Wait for the checksum.  */
name|fFfile
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|sfinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|psendfn
operator|=
name|qtrans
operator|->
name|psendfn
expr_stmt|;
name|qinfo
operator|->
name|precfn
operator|=
name|qtrans
operator|->
name|precfn
expr_stmt|;
name|qinfo
operator|->
name|pinfo
operator|=
name|qtrans
operator|->
name|pinfo
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|NULL
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|ffawait_cksum
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
name|qtrans
operator|->
name|fcmd
operator|=
name|TRUE
expr_stmt|;
operator|*
name|pfhandled
operator|=
name|TRUE
expr_stmt|;
return|return
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Wait for the ack after sending a file and the checksum.  */
end_comment

begin_function
specifier|static
name|boolean
name|ffawait_ack
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|sfinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|sfinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|NULL
expr_stmt|;
comment|/* An R means to retry sending the file.  */
if|if
condition|(
operator|*
name|zdata
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Request to resent non-file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|++
name|cFretries
expr_stmt|;
if|if
condition|(
name|cFretries
operator|>
name|cFmaxretries
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many retries"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Resending file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffilerewind
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"rewind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtrans
operator|->
name|ipos
operator|=
operator|(
name|long
operator|)
literal|0
expr_stmt|;
name|iFcheck
operator|=
literal|0xffff
expr_stmt|;
operator|++
name|cFsend_retries
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|qinfo
operator|->
name|psendfn
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|qinfo
operator|->
name|precfn
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
name|qinfo
operator|->
name|pinfo
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qinfo
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|fsendfile
operator|=
name|TRUE
expr_stmt|;
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
if|if
condition|(
operator|*
name|zdata
operator|!=
literal|'G'
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fffile: Got \"%s\""
argument_list|,
name|zdata
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"File send failed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtrans
operator|->
name|psendfn
operator|=
name|qinfo
operator|->
name|psendfn
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|qinfo
operator|->
name|precfn
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
name|qinfo
operator|->
name|pinfo
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qinfo
argument_list|)
expr_stmt|;
comment|/* Now call the send function by hand after setting fFacked to TRUE.      Since fFacked is true fffile will simply return out, and the send      function can do whatever it what was going to do.  */
name|fFacked
operator|=
name|TRUE
expr_stmt|;
return|return
call|(
modifier|*
name|qtrans
operator|->
name|psendfn
call|)
argument_list|(
name|qtrans
argument_list|,
name|qdaemon
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is called when the checksum arrives.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ffawait_cksum
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|sfinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|sfinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|unsigned
name|int
name|icheck
decl_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|zdata
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|zdata
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|zdata
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|zdata
index|[
literal|3
index|]
argument_list|)
operator|||
name|zdata
index|[
literal|4
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad checksum format"
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|qtrans
operator|->
name|pinfo
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|icheck
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zdata
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|icheck
operator|!=
operator|(
name|iFcheck
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"Checksum failed; calculated 0x%x, got 0x%x"
argument_list|,
name|iFcheck
operator|&
literal|0xffff
argument_list|,
name|icheck
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Failed to get non-file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|++
name|cFretries
expr_stmt|;
if|if
condition|(
name|cFretries
operator|>
name|cFmaxretries
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many retries"
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|bsend
operator|=
literal|'Q'
expr_stmt|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"File being resent"
argument_list|)
expr_stmt|;
comment|/* This bit of code relies on the receive code setting 	     qtrans->s.ztemp to the full name of the temporary file 	     being used.  */
name|qtrans
operator|->
name|e
operator|=
name|esysdep_truncate
argument_list|(
name|qtrans
operator|->
name|e
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|qtrans
operator|->
name|ipos
operator|=
operator|(
name|long
operator|)
literal|0
expr_stmt|;
name|iFcheck
operator|=
literal|0xffff
expr_stmt|;
name|bFspecial
operator|=
literal|0
expr_stmt|;
name|fFfile
operator|=
name|TRUE
expr_stmt|;
operator|++
name|cFrec_retries
expr_stmt|;
comment|/* Send an R to tell the other side to resend the file.  */
name|qinfo
operator|->
name|bsend
operator|=
literal|'R'
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Send a G to tell the other side the file was received 	 correctly.  */
name|qinfo
operator|->
name|bsend
operator|=
literal|'G'
expr_stmt|;
block|}
name|qtrans
operator|->
name|psendfn
operator|=
name|ffsend_ack
expr_stmt|;
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send the acknowledgement, and then possible wait for the resent    file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ffsend_ack
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|sfinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|sfinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
name|ab
index|[
literal|2
index|]
decl_stmt|;
name|ab
index|[
literal|0
index|]
operator|=
name|qinfo
operator|->
name|bsend
expr_stmt|;
name|ab
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|ffsendcmd
argument_list|(
name|qdaemon
argument_list|,
name|ab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|qtrans
operator|->
name|psendfn
operator|=
name|qinfo
operator|->
name|psendfn
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|qinfo
operator|->
name|precfn
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
name|qinfo
operator|->
name|pinfo
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ab
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
block|{
name|qtrans
operator|->
name|frecfile
operator|=
name|TRUE
expr_stmt|;
return|return
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
name|fFacked
operator|=
name|TRUE
expr_stmt|;
return|return
call|(
modifier|*
name|qtrans
operator|->
name|precfn
call|)
argument_list|(
name|qtrans
argument_list|,
name|qdaemon
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

