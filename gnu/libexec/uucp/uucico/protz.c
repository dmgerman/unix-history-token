begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* protz.c		Version 1.5, 92Apr24 */
end_comment

begin_comment
comment|/* Modified by Ian Lance Taylor for Taylor UUCP 1.04 92Aug4.  */
end_comment

begin_comment
comment|/*  * Doug Evans, dje@sspiff.UUCP or dje@ersys.edmonton.ab.ca  *  * This file provides the Zmodem protocol (by Chuck Forsberg) for  * Ian Taylor's UUCP package.  *  * It was originally developed to establish a uucp link between myself and my  * employer: Ivation Datasystems, Inc. of Ottawa.   *  * My thanks to Ivation for letting me release this to the public. Given that  * Zmodem is in the public domain, no additional copyrights have been added.  *  *****************************************************************************  *  * It's been difficult fitting Zmodem into the UUCP world. I have been guided  * mostly by trying to plug it into Taylor UUCP. Where "the Zmodem way of doing  * things" conflicted with "the UUCP way of doing things", I have err'd on the  * side of UUCP. At the end of it all, I have achieved something that will plug  * into Taylor UUCP very easily, but some might argue that I have corrupted Z  * too much. At any rate, compatibility with sz/rz was sacrificed to achieve a  * clean UUCP protocol. Given that, I took the opportunity to start from  * scratch when defining protocol constants (EG: ZBIN).  *  * 1) I wasn't quite sure how to enhance Zmodem to handle send+receive in one  *    session, so I added a 'g' protocol like initialization sequence. This  *    also gets this stuff out of the way, in case we ever try to support  *    full-duplex.  *  *	Caller			    Callee  *	------			    ------  *	ZINIT		--><-- ZINIT  *	ZDATA (ZCRCF)	--><-- ZDATA (ZCRCF)  *	ZACK		--><-- ZACK  *	ZINITEND	--><-- ZINITEND  *  *    ZINIT is a combination of ZRINIT and ZSINIT and is intended to exchange  *    simple protocol information (flags) and the protocol version number.  *    ZDATA is intended to include window size information as well as the  *    "Myattn" string (although at the moment it doesn't contain anything).  *    ZDATA may contain at most 1k bytes of data and is sent out as one ZCRCF  *    packet. Two ack's (ZACK + ZINITEND) are needed to ensure both sides have  *    received ZDATA.  *  * 2) I've hardcoded several protocol parameters, like 32 bit CRC's for data.  *    Others are not supported (we don't need them).  *  * 3) ZHEX headers use 32 bit CRC's.  *  * 4) Zmodem sends the ZFILE message "in one chunk". If there are errors, the  *    entire string is resent. I have continued this practice. All UUCP  *    commands are sent "in one chunk". This can be changed down the road if  *    necessary.  *  * 5) The ZEOF message has been replaced with a new ZCRCx value: ZCRCF. ZCRCF  *    is identical to ZCRCW except that it indicates the end of the message.  *    The protocol here is *not* a file transfer protocol. It is an end to end  *    transport protocol (that preserves message boundaries).  *  * 6) Zmodem handles restarting a file transfer, but as best as I can tell UUCP  *    does not. At least Taylor UUCP doesn't. And if UUCP does start handling  *    file restart, can it be plugged into the existing Zmodem way with zero  *    changes? Beats me. Therefore I have removed this part of the code. One  *    can always put it back in if and when UUCP handles it. Ditto for other  *    pieces of removed code: there's no point in overly complicating this code  *    when supporting all the bells and whistles requires enhancements to UUCP  *    itself.  *  *    *** It is easier to put code back in in an upward compatible manner ***  *    *** than it is to correct for misunderstood code or poorly merged   ***  *    *** (Zmodem vs UUCP) code.                                          ***  *  * 7) For the character in the initial "protocol selection" sequence, I have  *    chosen 'a'. I'm told 'z' is already in use for something that isn't  *    Zmodem. It's entirely reasonable to believe that if Zmodem ever becomes a  *    standard UUCP protocol, this won't be it (so I'll leave z/Z for them).  *    Publicly, this is the 'a' protocol. Internally, it is refered to as 'z'.  *    A little confusing, I know. Maybe in time I'll refer to it internally as  *    'a', or maybe in time this will be *the* 'z' protocol.  *  * 8) Since we are writing a transport protocol, which isn't supposed to know  *    anything about what is being transfered or where it is coming from, the  *    header data value has changed meaning. It no longer means "file position"  *    but instead means "window position". It is a running counter of the bytes  *    transfered. Each "message" begins on a 1k boundary so the count isn't a  *    precise byte count. The counter wraps every 4 gigabytes, although this  *    wrapping isn't supported yet.  *  *    FIXME: At present the max data transfered per session is 4 gigabytes.  *  ****************************************************************************  *  * A typical message sequence is (master sending file to slave):  *  *      Master                          Slave  *      ------                          -----  *	ZDATA (S, ZCRCF)	-->  *<--	ZACK  *<--	ZDATA (SY, ZCRCF)  *	ZACK			-->  *	ZDATA			-->  *                        ...<--	ZACK/ZRPOS  *	ZDATA (ZCRCF)		-->  *<--	ZACK  *<--	ZDATA (CY, ZCRCF)  *	ZACK			-->  *  * A typical message sequence is (master receiving file from slave):  *  *	Master				Slave  *	------				-----  *	ZDATA (R, ZCRCF)	-->  *<--	ZACK  *<--	ZDATA (RY, ZCRCF)  *	ZACK			-->  *<--	ZDATA  *	ZACK/ZRPOS	...	-->  *<--	ZDATA (ZCRCF)  *	ZACK			-->  *	ZDATA (CY, ZCRCF)	-->  *<--	ZACK  *  *****************************************************************************  *  * Notes:  * 1) For future bidirectional concerns, keep packet types "unidirectional".  *	Sender always uses:	ZDATA, ZNAK  *	Receiver always uses:	ZRPOS, ZACK  *	There is no intersection.  *  *    I'm not sure if this is necessary or even useful, but it seems to be.  *  * 2) I use to store the byte count / 32 in the data header. This left 5 bits  *    unused for future concerns. I removed this because of the following  *    situation when sending a file:  *  *	ZDATA (ZCRCG, xx bytes) - received ok  *	ZDATA (ZCRCF, 0 bytes)  - corrupted  *  *    At this point the receiver would like to send back a ZRPOS with a value   *    of the size of the file. However, it can't because the value is divided  *    by 32, and it would have to round up to the next multiple of 32. This  *    seemed a little ugly, so I went with using the entire header to store  *    the byte count.  *  *****************************************************************************  *  * Source version:  *   * 1.1,2,3  *	Protocol version 0  *	Early attempts, completely rewritten later.  *  * 1.4	Protocol version 1  *	Beta test sent to Ian for analysis 92Apr18.  *  * 1.5	Protocol version 1  *	Released 92Apr24.  *  *****************************************************************************  *  * Protocol version:  *  * A version number is exchanged in the ZINIT message, so it is possible to  * correct or enhance the protocol, without breaking existing versions.  * The purpose of this section is to document these versions as they come out.  * Remember, this is the protocol version, not the source version.  *  * 0	Initial version.  *	Zmodem controlled file transfer. This was more of a "plug Z  *	into UUCP as is" port.  *  * 1	Complete rewrite.  *	Made Z more of a transport protocol. UUCP now controls transfer and Z  *	is on the same footing as the other UUCP protocols.  *	Theoretically, there will be little pain when UUCP goes bidirectional.  */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|protz_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_define
define|#
directive|define
name|ZPROTOCOL_VERSION
value|1
end_define

begin_comment
comment|/*  * Control message characters ...  */
end_comment

begin_define
define|#
directive|define
name|ZPAD
value|'*'
end_define

begin_comment
comment|/* Padding character begins frames */
end_comment

begin_define
define|#
directive|define
name|ZDLE
value|030
end_define

begin_comment
comment|/* Ctrl-X Zmodem escape - `ala BISYNC DLE */
end_comment

begin_define
define|#
directive|define
name|ZBIN
value|'A'
end_define

begin_comment
comment|/* Binary frame indicator */
end_comment

begin_define
define|#
directive|define
name|ZHEX
value|'B'
end_define

begin_comment
comment|/* HEX frame indicator */
end_comment

begin_comment
comment|/*  * Frame types (see array "frametypes" in zm.c) ...  *  * Note that the numbers here have been reorganized, as we don't support  * all of them (nor do we need to).  *  * WARNING: The init sequence assumes ZINIT< ZDATA< ZACK< ZINITEND.  */
end_comment

begin_define
define|#
directive|define
name|ZINIT
value|0
end_define

begin_comment
comment|/* Init (contains protocol version, flags) */
end_comment

begin_define
define|#
directive|define
name|ZDATA
value|1
end_define

begin_comment
comment|/* Data packet(s) follow */
end_comment

begin_define
define|#
directive|define
name|ZRPOS
value|2
end_define

begin_comment
comment|/* Resume data trans at this position */
end_comment

begin_define
define|#
directive|define
name|ZACK
value|3
end_define

begin_comment
comment|/* ACK to above */
end_comment

begin_define
define|#
directive|define
name|ZNAK
value|4
end_define

begin_comment
comment|/* Last packet was garbled */
end_comment

begin_define
define|#
directive|define
name|Zreserved
value|5
end_define

begin_comment
comment|/* reserved (for future concerns) */
end_comment

begin_define
define|#
directive|define
name|ZINITEND
value|6
end_define

begin_comment
comment|/* end of init sequence */
end_comment

begin_define
define|#
directive|define
name|ZFIN
value|7
end_define

begin_comment
comment|/* Finish session */
end_comment

begin_comment
comment|/*  * ZDLE sequences ...  *  * Note addition of ZCRCF: "end of message".  */
end_comment

begin_define
define|#
directive|define
name|ZCRCE
value|'h'
end_define

begin_comment
comment|/* CRC next, frame ends, header packet follows */
end_comment

begin_define
define|#
directive|define
name|ZCRCG
value|'i'
end_define

begin_comment
comment|/* CRC next, frame continues nonstop */
end_comment

begin_define
define|#
directive|define
name|ZCRCQ
value|'j'
end_define

begin_comment
comment|/* CRC next, frame continues, ZACK expected */
end_comment

begin_define
define|#
directive|define
name|ZCRCW
value|'k'
end_define

begin_comment
comment|/* CRC next, ZACK expected, end of frame */
end_comment

begin_define
define|#
directive|define
name|ZCRCF
value|'l'
end_define

begin_comment
comment|/* CRC next, ZACK expected, end of message */
end_comment

begin_define
define|#
directive|define
name|ZRUB0
value|'m'
end_define

begin_comment
comment|/* Translate to rubout 0177 */
end_comment

begin_define
define|#
directive|define
name|ZRUB1
value|'n'
end_define

begin_comment
comment|/* Translate to rubout 0377 */
end_comment

begin_comment
comment|/*  * zdlread return values (internal) ...  * Other values are ZM_ERROR, ZM_TIMEOUT, ZM_RCDO.  */
end_comment

begin_define
define|#
directive|define
name|GOTOR
value|0400
end_define

begin_define
define|#
directive|define
name|GOTCRCE
value|(ZCRCE | GOTOR)
end_define

begin_comment
comment|/* ZDLE-ZCRCE received */
end_comment

begin_define
define|#
directive|define
name|GOTCRCG
value|(ZCRCG | GOTOR)
end_define

begin_comment
comment|/* ZDLE-ZCRCG received */
end_comment

begin_define
define|#
directive|define
name|GOTCRCQ
value|(ZCRCQ | GOTOR)
end_define

begin_comment
comment|/* ZDLE-ZCRCQ received */
end_comment

begin_define
define|#
directive|define
name|GOTCRCW
value|(ZCRCW | GOTOR)
end_define

begin_comment
comment|/* ZDLE-ZCRCW received */
end_comment

begin_define
define|#
directive|define
name|GOTCRCF
value|(ZCRCF | GOTOR)
end_define

begin_comment
comment|/* ZDLE-ZCRCF received */
end_comment

begin_comment
comment|/*  * Byte positions within header array ...  */
end_comment

begin_define
define|#
directive|define
name|ZF0
value|3
end_define

begin_comment
comment|/* First flags byte */
end_comment

begin_define
define|#
directive|define
name|ZF1
value|2
end_define

begin_define
define|#
directive|define
name|ZF2
value|1
end_define

begin_define
define|#
directive|define
name|ZF3
value|0
end_define

begin_define
define|#
directive|define
name|ZP0
value|0
end_define

begin_comment
comment|/* Low order 8 bits of position */
end_comment

begin_define
define|#
directive|define
name|ZP1
value|1
end_define

begin_define
define|#
directive|define
name|ZP2
value|2
end_define

begin_define
define|#
directive|define
name|ZP3
value|3
end_define

begin_comment
comment|/* High order 8 bits of position */
end_comment

begin_comment
comment|/*  * Bit Masks for ZRQINIT flags byte ZF0 ...  */
end_comment

begin_define
define|#
directive|define
name|TX_ESCCTL
value|1
end_define

begin_comment
comment|/* Tx will escape control chars */
end_comment

begin_comment
comment|/*  * Possible errors when running ZMODEM ...  */
end_comment

begin_define
define|#
directive|define
name|ZM_ERROR
value|(-1)
end_define

begin_comment
comment|/* crc error, etc. */
end_comment

begin_define
define|#
directive|define
name|ZM_TIMEOUT
value|(-2)
end_define

begin_define
define|#
directive|define
name|ZM_RCDO
value|(-3)
end_define

begin_comment
comment|/* Carrier Lost */
end_comment

begin_comment
comment|/*  * ASCII characters ...  */
end_comment

begin_define
define|#
directive|define
name|LF
value|012
end_define

begin_define
define|#
directive|define
name|CR
value|015
end_define

begin_define
define|#
directive|define
name|XON
value|021
end_define

begin_define
define|#
directive|define
name|XOFF
value|023
end_define

begin_define
define|#
directive|define
name|XON_WAIT
value|10
end_define

begin_comment
comment|/* seconds */
end_comment

begin_comment
comment|/*  * Packet sizes ...  *  * FIXME: CPACKETSIZE is hardcoded in a lot of places.  *	It's not clear to me whether changing it's value would be a  *	"good thing" or not. But of course that doesn't excuse the hardcoding.  */
end_comment

begin_define
define|#
directive|define
name|CPACKETSIZE
value|1024
end_define

begin_comment
comment|/* max packet size (data only) */
end_comment

begin_define
define|#
directive|define
name|CFRAMELEN
value|12
end_define

begin_comment
comment|/* header size */
end_comment

begin_define
define|#
directive|define
name|CSUFFIXLEN
value|10
end_define

begin_comment
comment|/* suffix at end of data packets */
end_comment

begin_define
define|#
directive|define
name|CEXCHANGE_INIT_RETRIES
value|4
end_define

begin_comment
comment|/* The header CRC value.  */
end_comment

begin_if
if|#
directive|if
name|ANSI_C
end_if

begin_define
define|#
directive|define
name|IHDRCRC
value|0xDEBB20E3UL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IHDRCRC
value|((unsigned long) 0xDEBB20E3L)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* packet buffer size */
end_comment

begin_define
define|#
directive|define
name|CPACKBUFSIZE
value|(CFRAMELEN + 2 * CPACKETSIZE + CSUFFIXLEN + 42
comment|/*slop*/
value|)
end_define

begin_comment
comment|/*  * Data types ...  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|char
name|achdrval_t
index|[
literal|4
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|hdrval_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|winpos_t
typedef|;
end_typedef

begin_comment
comment|/*  * Configurable parms ...  *  * FIXME:<cZrx_buf_len> isn't used yet. It may not be needed.  */
end_comment

begin_define
define|#
directive|define
name|CTIMEOUT
value|10
end_define

begin_define
define|#
directive|define
name|CRETRIES
value|10
end_define

begin_define
define|#
directive|define
name|CSTARTUP_RETRIES
value|4
end_define

begin_define
define|#
directive|define
name|CGARBAGE
value|2400
end_define

begin_define
define|#
directive|define
name|CSEND_WINDOW
value|16384
end_define

begin_define
define|#
directive|define
name|FESCAPE_CONTROL
value|FALSE
end_define

begin_decl_stmt
specifier|static
name|int
name|cZtimeout
init|=
name|CTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (seconds) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cZretries
init|=
name|CRETRIES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cZstartup_retries
init|=
name|CSTARTUP_RETRIES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cZmax_garbage
init|=
name|CGARBAGE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max garbage before header */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cZtx_window
init|=
name|CSEND_WINDOW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our transmission window */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cZrx_buf_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our reception buffer size */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fZesc_ctl
init|=
name|FESCAPE_CONTROL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* escape control chars */
end_comment

begin_decl_stmt
name|struct
name|uuconf_cmdtab
name|asZproto_params
index|[]
init|=
block|{
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cZtimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cZretries
block|,
name|NULL
block|}
block|,
block|{
literal|"startup-retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cZstartup_retries
block|,
name|NULL
block|}
block|,
block|{
literal|"garbage"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cZmax_garbage
block|,
name|NULL
block|}
block|,
block|{
literal|"send-window"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cZtx_window
block|,
name|NULL
block|}
block|,
block|{
literal|"escape-control"
block|,
name|UUCONF_CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fZesc_ctl
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variables for statistic gathering ...  *  * We use<wpZtxpos, wpZrxbytes> to record the number of "packets"  * sent/received. Packets is in double quotes because some of them aren't full.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cZheaders_sent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cZheaders_received
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cZbytes_resent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cZtimeouts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cZerrors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data buffers ...  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zZtx_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* transmit buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zZtx_packet_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw outgoing packet data */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zZrx_packet_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw incoming packet data */
end_comment

begin_comment
comment|/*  * Transmitter state variables ...  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cZblklen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data length in sent/received packets */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cZtxwspac
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spacing between ZCRCQ requests */
end_comment

begin_comment
comment|/*static unsigned cZblklen_override;*/
end_comment

begin_comment
comment|/* override value for<cZblklen> */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cZtxwcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter used to space ack requests */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cZrxwcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter used to watch receiver's buf size */
end_comment

begin_decl_stmt
specifier|static
name|winpos_t
name|wpZtxstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<wpZtxpos> when message started */
end_comment

begin_decl_stmt
specifier|static
name|winpos_t
name|wpZtxpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* transmitter position */
end_comment

begin_decl_stmt
specifier|static
name|winpos_t
name|wpZlastsync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last offset to which we got a ZRPOS */
end_comment

begin_decl_stmt
specifier|static
name|winpos_t
name|wpZlrxpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receiver's last reported offset */
end_comment

begin_decl_stmt
specifier|static
name|winpos_t
name|wpZrxpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receiver file position */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iZlast_tx_data_packet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of last ZDATA packet (ZCRCx) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iZjunk_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amount of garbage characters received */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iZtleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for dynamic packet resizing */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iZbeenhereb4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* times we've been ZRPOS'd to same place */
end_comment

begin_comment
comment|/*  * Receiver state variables ...  */
end_comment

begin_decl_stmt
specifier|static
name|winpos_t
name|wpZrxbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receiver byte count */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iZlast_rx_data_packet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last successfully received ZCRCx packet */
end_comment

begin_comment
comment|/*  * Misc. globals ...  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|xon
init|=
name|XON
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DJE_TESTING
end_ifdef

begin_decl_stmt
name|int
name|uucptest
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uucptest2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uucptestseed
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Kludge!!!  * See fzfinish_tx(). Basically the next two globals are used to record the  * fact that we got a ZDATA, but aren't quite ready to process it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iZpkt_rcvd_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -1 if not valid */
end_comment

begin_decl_stmt
specifier|static
name|hdrval_t
name|hvZpkt_hdrval_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Packet types ...  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|azZframe_types
index|[]
init|=
block|{
literal|"Carrier Lost"
block|,
comment|/* -3 */
literal|"Timeout"
block|,
comment|/* -2 */
literal|"Error"
block|,
comment|/* -1 */
define|#
directive|define
name|FTOFFSET
value|3
literal|"ZINIT"
block|,
literal|"ZDATA"
block|,
literal|"ZRPOS"
block|,
literal|"ZACK"
block|,
literal|"ZNAK"
block|,
literal|"Zreserved"
block|,
literal|"ZINITEND"
block|,
literal|"ZFIN"
block|,
literal|"UNKNOWN!!!"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FTNUMBER
value|(sizeof(azZframe_types) / sizeof(char *))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZZHEADER_NAME
parameter_list|(
name|itype
parameter_list|)
define|\
value|azZframe_types[min((itype) + FTOFFSET, FTNUMBER - 1)]
end_define

begin_comment
comment|/*  * Local functions ...  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fzsend_data
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|,
name|boolean
name|fendofmessage
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzprocess
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzstart_proto
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|izexchange_init
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|send_type
operator|,
name|achdrval_t
name|send_val
operator|,
name|achdrval_t
name|recv_val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzshutdown_proto
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzstart_tx
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzfinish_tx
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|long
operator|*
name|plredo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzstart_rx
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzfinish_rx
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzsend_hdr
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|ipkttype
operator|,
name|int
name|ihdrtype
operator|,
name|hdrval_t
name|hdrval
operator|,
name|boolean
name|fcheckreceive
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzsend_data_packet
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|,
name|int
name|frameend
operator|,
name|boolean
name|fcheckreceive
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|czbuild_header
name|P
argument_list|(
operator|(
name|char
operator|*
name|zresult
operator|,
name|int
name|ipkttype
operator|,
name|int
name|ihdrtype
operator|,
name|hdrval_t
name|hdrval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|czbuild_data_packet
name|P
argument_list|(
operator|(
name|char
operator|*
name|zresult
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|,
name|int
name|frameend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The rest of the functions do not follow Ian's naming style. I have left  * the names the same as the original zm source. Over time, they may change.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|izrecv_hdr
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|achdrval_t
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zrbhdr32
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|achdrval_t
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zrhhdr
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|achdrval_t
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zrdat32
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|length
operator|,
name|int
operator|*
name|iprxcount
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getinsync
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zputhex
name|P
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|int
name|ch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zputchar
name|P
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|int
name|ch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zgethex
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zdlread
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noxrd7
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|realreadchar
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fzreceive_ready
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stohdr
name|P
argument_list|(
operator|(
name|hdrval_t
name|pos
operator|,
name|achdrval_t
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hdrval_t
name|rclhdr
name|P
argument_list|(
operator|(
name|achdrval_t
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hdrval_t
name|hvzencode_data_hdr
name|P
argument_list|(
operator|(
name|winpos_t
name|cbytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zdecode_data_hdr
name|P
argument_list|(
operator|(
name|hdrval_t
name|hdrval
operator|,
name|winpos_t
operator|*
name|pcbytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|winpos_t
name|lzupdate_rxpos
name|P
argument_list|(
operator|(
name|achdrval_t
name|rx_hdr
operator|,
name|winpos_t
name|rxpos
operator|,
name|winpos_t
name|lrxpos
operator|,
name|winpos_t
name|txpos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This macro replaces readchar() because it achieves a noticable speed up. The  * readchar() function has been renamed realreadchar(). Thanks to Ian for  * running this stuff through a profiler to find this out. Ian suggests further  * speed ups may be obtained by doing a similar thing in zrdat32().  */
end_comment

begin_comment
comment|/* Assign the next character to b. */
end_comment

begin_define
define|#
directive|define
name|READCHAR
parameter_list|(
name|qdaemon
parameter_list|,
name|b
parameter_list|,
name|i
parameter_list|)
define|\
value|(iPrecstart != iPrecend \    ? ((b) = BUCHAR (abPrecbuf[iPrecstart]), \       iPrecstart = (iPrecstart + 1) % CRECBUFLEN) \    : ((b) = realreadchar ((qdaemon), (i))))
end_define

begin_comment
comment|/************************************************************************/
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Start the protocol ...  */
end_comment

begin_function
name|boolean
name|fzstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
operator|*
name|pzlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"protocol 'a' starting: , , , , , "
operator|+
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|pzlog
argument_list|,
literal|"protocol 'a' starting: %d, %d, %d, %d, %d, %d"
argument_list|,
name|cZtimeout
argument_list|,
name|cZretries
argument_list|,
name|cZstartup_retries
argument_list|,
name|cZmax_garbage
argument_list|,
name|cZtx_window
argument_list|,
name|fZesc_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|PARITYSETTING_NONE
argument_list|,
name|STRIPSETTING_EIGHTBITS
argument_list|,
name|XONXOFF_OFF
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * For now, we place tight restrictions on the size of the transmit 	 * window. This might be relaxed in the future. If it is relaxed, 	 * some of these tests will stay, some will go. That is why it is 	 * coded like it is. 	 */
if|if
condition|(
name|cZtx_window
operator|%
literal|1024
operator|!=
literal|0
operator|||
name|cZtx_window
operator|<
literal|4096
operator|||
name|cZtx_window
operator|>
literal|65536
operator|||
literal|65536
operator|%
name|cZtx_window
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzstart: cZtx_window not one of 4096, 8192, 16384, 32768, 65536"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zZtx_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CPACKETSIZE
argument_list|)
expr_stmt|;
name|zZtx_packet_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CPACKBUFSIZE
argument_list|)
expr_stmt|;
name|zZrx_packet_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CPACKBUFSIZE
argument_list|)
expr_stmt|;
name|iZlast_tx_data_packet
operator|=
operator|-
literal|1
expr_stmt|;
name|iZlast_rx_data_packet
operator|=
operator|-
literal|1
expr_stmt|;
name|wpZtxpos
operator|=
name|wpZlrxpos
operator|=
name|wpZrxpos
operator|=
name|wpZrxbytes
operator|=
literal|0
expr_stmt|;
name|cZtxwspac
operator|=
name|cZtx_window
operator|/
literal|4
expr_stmt|;
name|cZheaders_sent
operator|=
name|cZheaders_received
operator|=
name|cZbytes_resent
operator|=
literal|0
expr_stmt|;
name|cZtimeouts
operator|=
name|cZerrors
operator|=
literal|0
expr_stmt|;
name|iZpkt_rcvd_kludge
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * We ensure<cZtx_window> is at least 4k, so the following is 	 * unnecessary. It can be put back in later if needed. 	 */
block|if (cZblklen_override> cZtxwspac 	    || (!cZblklen_override&& cZtxwspac< 1024)) 		cZblklen_override = cZtxwspac;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DJE_TESTING
block|{
specifier|extern
name|int
name|uucptest
decl_stmt|,
name|uucptest2
decl_stmt|,
name|uucptestseed
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|uucptest
operator|==
operator|-
literal|1
condition|)
block|{
name|f
operator|=
name|fopen
argument_list|(
literal|"/usr/local/src/bin/uucp/uucptest"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|uucptestseed
argument_list|,
operator|&
name|uucptest
argument_list|,
operator|&
name|uucptest2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|srand
argument_list|(
name|uucptestseed
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Fire up the protocol (exchange init messages) ... 	 */
if|if
condition|(
operator|!
name|fzstart_proto
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Stop the protocol ...  */
end_comment

begin_function
name|boolean
name|fzshutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fzshutdown_proto
argument_list|(
name|qdaemon
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zZtx_buf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zZtx_packet_buf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zZrx_packet_buf
argument_list|)
expr_stmt|;
name|zZtx_buf
operator|=
name|NULL
expr_stmt|;
name|zZtx_packet_buf
operator|=
name|NULL
expr_stmt|;
name|zZrx_packet_buf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Print some informative statistics ... 	 * 	 * I use the word "messages" here instead of "headers" because the 	 * latter is jargonese. 	 */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'a' messages: sent %lu, received %lu"
argument_list|,
name|cZheaders_sent
argument_list|,
name|cZheaders_received
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'a' packets: sent %lu, received %lu"
argument_list|,
name|wpZtxpos
operator|/
literal|1024
argument_list|,
name|wpZrxbytes
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|cZbytes_resent
operator|!=
literal|0
operator|||
name|cZtimeouts
operator|!=
literal|0
operator|||
name|cZerrors
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'a' errors: bytes resent %lu, timeouts %lu, errors %lu"
argument_list|,
name|cZbytes_resent
argument_list|,
name|cZtimeouts
argument_list|,
name|cZerrors
argument_list|)
expr_stmt|;
comment|/* 	 * Reset all the parameters to their default values, so that the 	 * protocol parameters used for this connection do not affect the 	 * next one. 	 */
name|cZtimeout
operator|=
name|CTIMEOUT
expr_stmt|;
name|cZretries
operator|=
name|CRETRIES
expr_stmt|;
name|cZstartup_retries
operator|=
name|CSTARTUP_RETRIES
expr_stmt|;
name|cZmax_garbage
operator|=
name|CGARBAGE
expr_stmt|;
name|cZtx_window
operator|=
name|CSEND_WINDOW
expr_stmt|;
name|fZesc_ctl
operator|=
name|FESCAPE_CONTROL
expr_stmt|;
name|cZheaders_sent
operator|=
name|cZheaders_received
operator|=
name|cZbytes_resent
operator|=
literal|0
expr_stmt|;
name|cZtimeouts
operator|=
name|cZerrors
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command string ...  * We send everything up to and including the null byte.  *  * We assume the command will fit in the outgoing data buffer.  * FIXME: A valid assumption?  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fzsendcmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|size_t
name|n
decl_stmt|,
name|clen
decl_stmt|;
name|long
name|lredo
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzsendcmd: sending command %s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fzstart_tx
argument_list|()
condition|)
comment|/* must be called before zzgetspace() */
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|zbuf
operator|=
name|zzgetspace
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|clen
operator|>
name|n
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fzsendcmd: clen> n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|zbuf
argument_list|,
name|z
argument_list|)
expr_stmt|;
comment|/* 	 * Send it out ... 	 */
do|do
block|{
if|if
condition|(
operator|!
name|fzsend_data
argument_list|(
name|qdaemon
argument_list|,
name|zbuf
argument_list|,
name|clen
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fzfinish_tx
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|lredo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
do|while
condition|(
name|lredo
operator|>=
literal|0
condition|)
do|;
return|return
name|fzprocess
argument_list|(
name|qdaemon
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a packet to send out ...  *  * Note that 'z' has dynamic packet resizing and that<cZblklen> will range  * from 32 to 1024, in multiples of 2.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|zzgetspace
parameter_list|(
name|qdaemon
parameter_list|,
name|pclen
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|cZblklen
expr_stmt|;
return|return
name|zZtx_buf
return|;
block|}
end_function

begin_comment
comment|/*  * Send a block of data ...  *  * If (cdata == 0) then the end of the file has been reached.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fzsenddata
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzsenddata: %d bytes"
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fzsend_data
argument_list|(
name|qdaemon
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|,
name|cdata
operator|==
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|fzprocess
argument_list|(
name|qdaemon
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a block of data (command or file) ...  */
end_comment

begin_comment
comment|/* This should buffer the data internally.  Until it does, it needs to    be able to reset the file position when it is called.  This is    really ugly.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|stransfer
modifier|*
name|qTsend
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|fzsend_data
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|fendofmessage
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|boolean
name|fendofmessage
decl_stmt|;
block|{
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|iZlast_tx_data_packet
operator|==
operator|-
literal|1
operator|||
name|iZlast_tx_data_packet
operator|==
name|ZCRCW
condition|)
block|{
name|cZtxwcnt
operator|=
name|cZrxwcnt
operator|=
literal|0
expr_stmt|;
name|iZjunk_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZBIN
argument_list|,
name|ZDATA
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZtxpos
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|n
operator|=
name|cdata
expr_stmt|;
if|if
condition|(
name|fendofmessage
condition|)
name|iZlast_tx_data_packet
operator|=
name|ZCRCF
expr_stmt|;
elseif|else
if|if
condition|(
name|iZjunk_count
operator|>
literal|3
condition|)
name|iZlast_tx_data_packet
operator|=
name|ZCRCW
expr_stmt|;
elseif|else
if|if
condition|(
name|wpZtxpos
operator|==
name|wpZlastsync
condition|)
name|iZlast_tx_data_packet
operator|=
name|ZCRCW
expr_stmt|;
elseif|else
if|if
condition|(
name|cZrx_buf_len
operator|&&
operator|(
name|cZrxwcnt
operator|+=
name|n
operator|)
operator|>=
name|cZrx_buf_len
condition|)
name|iZlast_tx_data_packet
operator|=
name|ZCRCW
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cZtxwcnt
operator|+=
name|n
operator|)
operator|>=
name|cZtxwspac
condition|)
block|{
name|iZlast_tx_data_packet
operator|=
name|ZCRCQ
expr_stmt|;
name|cZtxwcnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|iZlast_tx_data_packet
operator|=
name|ZCRCG
expr_stmt|;
if|if
condition|(
operator|++
name|iZtleft
operator|>
literal|3
condition|)
block|{
name|iZtleft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cZblklen
operator|<
literal|1024
condition|)
name|cZblklen
operator|*=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/*<cZblklen_override> is currently unnecessary */
block|if (cZblklen_override&& cZblklen> cZblklen_override) 			cZblklen = cZblklen_override;
endif|#
directive|endif
if|if
condition|(
name|cZblklen
operator|>
literal|1024
condition|)
name|cZblklen
operator|=
literal|1024
expr_stmt|;
if|if
condition|(
name|cZrx_buf_len
operator|&&
name|cZblklen
operator|>
name|cZrx_buf_len
condition|)
name|cZblklen
operator|=
name|cZrx_buf_len
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PROTO
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|iZlast_tx_data_packet
condition|)
block|{
case|case
name|ZCRCW
case|:
name|type
operator|=
literal|"ZCRCW"
expr_stmt|;
break|break;
case|case
name|ZCRCG
case|:
name|type
operator|=
literal|"ZCRCG"
expr_stmt|;
break|break;
case|case
name|ZCRCQ
case|:
name|type
operator|=
literal|"ZCRCQ"
expr_stmt|;
break|break;
case|case
name|ZCRCE
case|:
name|type
operator|=
literal|"ZCRCE"
expr_stmt|;
break|break;
case|case
name|ZCRCF
case|:
name|type
operator|=
literal|"ZCRCF"
expr_stmt|;
break|break;
default|default :
name|type
operator|=
literal|"UNKNOWN!!!"
expr_stmt|;
break|break;
block|}
name|DEBUG_MESSAGE3
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzsend_data: %s, pos 0x%lx, %d bytes"
argument_list|,
name|type
argument_list|,
name|wpZtxpos
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|fzsend_data_packet
argument_list|(
name|qdaemon
argument_list|,
name|zdata
argument_list|,
name|n
argument_list|,
name|iZlast_tx_data_packet
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|wpZtxpos
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|iZlast_tx_data_packet
operator|==
name|ZCRCW
condition|)
block|{
comment|/* 		 * FIXME: Ideally this would be done in fzprocess. However, it 		 *	is only called if there is data pending which there 		 *	may not be yet. I could have patched fploop() a bit but 		 *	for now, I've done it like this. 		 */
switch|switch
condition|(
name|getinsync
argument_list|(
name|qdaemon
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
case|case
name|ZACK
case|:
break|break;
case|case
name|ZRPOS
case|:
if|if
condition|(
name|qTsend
operator|==
name|NULL
operator|||
operator|!
name|ffileisopen
argument_list|(
name|qTsend
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't reset non-file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|iZlast_tx_data_packet
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* trigger ZDATA */
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzsend_data: Seeking to %ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|wpZrxpos
operator|-
name|wpZtxstart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|qTsend
operator|->
name|e
argument_list|,
name|wpZrxpos
operator|-
name|wpZtxstart
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* 	 * If we've reached the maximum transmit window size, let the 	 * receiver catch up ... 	 * 	 * I use (cZtx_window - 2048) to play it safe. 	 */
while|while
condition|(
name|wpZtxpos
operator|-
name|wpZlrxpos
operator|>=
name|cZtx_window
operator|-
literal|2048
condition|)
block|{
if|if
condition|(
name|iZlast_tx_data_packet
operator|!=
name|ZCRCQ
condition|)
block|{
if|if
condition|(
operator|!
name|fzsend_data_packet
argument_list|(
name|qdaemon
argument_list|,
name|zdata
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|iZlast_tx_data_packet
operator|=
name|ZCRCQ
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* 		 * FIXME: I'd rather not call ffileseek() in this file. When we 		 *	start buffering the outgoing data, the following 		 *	ffileseek() will disappear. 		 */
switch|switch
condition|(
name|getinsync
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|ZACK
case|:
break|break;
case|case
name|ZRPOS
case|:
if|if
condition|(
name|qTsend
operator|==
name|NULL
operator|||
operator|!
name|ffileisopen
argument_list|(
name|qTsend
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't reset non-file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|iZlast_tx_data_packet
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* trigger ZDATA */
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzsend_data: Seeking to %ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|wpZrxpos
operator|-
name|wpZtxstart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|qTsend
operator|->
name|e
argument_list|,
name|wpZrxpos
operator|-
name|wpZtxstart
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Process existing data ...  */
end_comment

begin_function
specifier|static
name|boolean
name|fzprocess
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|ch
decl_stmt|;
while|while
condition|(
name|fzreceive_ready
argument_list|()
condition|)
block|{
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|ZPAD
case|:
comment|/* see if we're detecting ZRPOS packets quickly */
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzprocess: possible ZRPOS packet"
argument_list|)
expr_stmt|;
comment|/* We just ate the ZPAD char that getinsync 			   expects, so put it back.  */
name|iPrecstart
operator|=
operator|(
operator|(
name|iPrecstart
operator|+
name|CRECBUFLEN
operator|-
literal|1
operator|)
operator|%
name|CRECBUFLEN
operator|)
expr_stmt|;
name|c
operator|=
name|getinsync
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ZACK
condition|)
break|break;
comment|/* FIXME: sz does a TCFLSH here */
if|#
directive|if
literal|0
comment|/* FIXME: Not sure if this is needed, or where to put it. */
comment|/* ZCRCE - dinna wanna starta ping-pong game */
block|if (!fzsend_data_packet (qdaemon, zZtx_packet_buf, 						 0, ZCRCE, TRUE)) 				return FALSE;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|ZRPOS
condition|)
block|{
if|if
condition|(
name|qTsend
operator|==
name|NULL
operator|||
operator|!
name|ffileisopen
argument_list|(
name|qTsend
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Attempt to back up non-file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|qTsend
operator|->
name|e
argument_list|,
name|wpZrxpos
operator|-
name|wpZtxstart
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|iZlast_tx_data_packet
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* trigger ZDATA */
break|break;
comment|/* not returning is intentional */
block|}
return|return
name|FALSE
return|;
case|case
name|XOFF
case|:
case|case
name|XOFF
operator||
literal|0200
case|:
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|ch
argument_list|,
name|XON_WAIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CR
case|:
break|break;
default|default:
name|iZjunk_count
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for data to come in.  *  * This continues processing until a complete file or command has been  * received.  */
end_comment

begin_function
name|boolean
name|fzwait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|cerr
decl_stmt|,
name|rxcount
decl_stmt|;
name|boolean
name|fexit
decl_stmt|;
name|achdrval_t
name|rx_hdr
decl_stmt|;
if|if
condition|(
operator|!
name|fzstart_rx
argument_list|()
condition|)
return|return
name|FALSE
return|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
goto|goto
name|nxthdr
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZRPOS
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZrxbytes
argument_list|)
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|nxthdr
label|:
name|c
operator|=
name|izrecv_hdr
argument_list|(
name|qdaemon
argument_list|,
name|rx_hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZM_TIMEOUT
case|:
case|case
name|ZNAK
case|:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzwait: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
continue|continue;
case|case
name|ZM_ERROR
case|:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzwait: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*fport_break ();*/
continue|continue;
case|case
name|ZM_RCDO
case|:
case|case
name|ZFIN
case|:
return|return
name|FALSE
return|;
case|case
name|ZRPOS
case|:
case|case
name|ZACK
case|:
goto|goto
name|nxthdr
goto|;
comment|/* ignore, partner is out of sync */
case|case
name|ZDATA
case|:
block|{
name|winpos_t
name|rx_bytes
decl_stmt|;
name|zdecode_data_hdr
argument_list|(
name|rclhdr
argument_list|(
name|rx_hdr
argument_list|)
argument_list|,
operator|&
name|rx_bytes
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzwait: bytes(us,them) 0x%lx,0x%lx"
argument_list|,
name|wpZrxbytes
argument_list|,
name|rx_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_bytes
operator|!=
name|wpZrxbytes
condition|)
block|{
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzwait: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|zrdat32
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
literal|1024
argument_list|,
operator|&
name|rxcount
argument_list|)
expr_stmt|;
comment|/*fport_break ();*/
comment|/* 				 * FIXME: Seems to me we should ignore this one 				 *	and go for a timeout, the theory being 				 *	that the appropriate ZRPOS has already 				 *	been sent. We're obviously out of sync. 				 *	/dje 92Mar10 				 */
continue|continue;
comment|/* goto nxthdr? */
block|}
name|moredata
label|:
comment|/* 			 * Do not call fgot_data() with (rxcount == 0) if it's 			 * not ZCRCF. fgot_data() will erroneously think this 			 * is the end of the message. 			 */
name|c
operator|=
name|zrdat32
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
literal|1024
argument_list|,
operator|&
name|rxcount
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PROTO
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|msg
operator|=
name|ZZHEADER_NAME
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|GOTCRCW
case|:
name|msg
operator|=
literal|"ZCRCW"
expr_stmt|;
break|break;
case|case
name|GOTCRCG
case|:
name|msg
operator|=
literal|"ZCRCG"
expr_stmt|;
break|break;
case|case
name|GOTCRCQ
case|:
name|msg
operator|=
literal|"ZCRCQ"
expr_stmt|;
break|break;
case|case
name|GOTCRCE
case|:
name|msg
operator|=
literal|"ZCRCE"
expr_stmt|;
break|break;
case|case
name|GOTCRCF
case|:
name|msg
operator|=
literal|"ZCRCF"
expr_stmt|;
break|break;
default|default :
name|msg
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzwait: zrdat32: %s, %d bytes"
argument_list|,
name|msg
argument_list|,
name|rxcount
argument_list|)
expr_stmt|;
else|else
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzwait: zrdat32: %d, %d bytes"
argument_list|,
name|c
argument_list|,
name|rxcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZM_ERROR
case|:
comment|/* CRC error */
name|cZerrors
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzwait: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*fport_break ();*/
continue|continue;
case|case
name|ZM_TIMEOUT
case|:
name|cZtimeouts
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzwait: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
continue|continue;
case|case
name|ZM_RCDO
case|:
return|return
name|FALSE
return|;
case|case
name|GOTCRCW
case|:
name|iZlast_rx_data_packet
operator|=
name|ZCRCW
expr_stmt|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
if|if
condition|(
name|rxcount
operator|!=
literal|0
operator|&&
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|rxcount
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|wpZrxbytes
operator|+=
name|rxcount
expr_stmt|;
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZACK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZrxbytes
argument_list|)
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
operator|&
name|xon
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
goto|goto
name|nxthdr
goto|;
case|case
name|GOTCRCQ
case|:
name|iZlast_rx_data_packet
operator|=
name|ZCRCQ
expr_stmt|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
if|if
condition|(
name|rxcount
operator|!=
literal|0
operator|&&
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|rxcount
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|wpZrxbytes
operator|+=
name|rxcount
expr_stmt|;
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZACK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZrxbytes
argument_list|)
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
goto|goto
name|moredata
goto|;
case|case
name|GOTCRCG
case|:
name|iZlast_rx_data_packet
operator|=
name|ZCRCG
expr_stmt|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
if|if
condition|(
name|rxcount
operator|!=
literal|0
operator|&&
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|rxcount
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|wpZrxbytes
operator|+=
name|rxcount
expr_stmt|;
goto|goto
name|moredata
goto|;
case|case
name|GOTCRCE
case|:
name|iZlast_rx_data_packet
operator|=
name|ZCRCE
expr_stmt|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
if|if
condition|(
name|rxcount
operator|!=
literal|0
operator|&&
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|rxcount
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|wpZrxbytes
operator|+=
name|rxcount
expr_stmt|;
goto|goto
name|nxthdr
goto|;
case|case
name|GOTCRCF
case|:
name|iZlast_rx_data_packet
operator|=
name|ZCRCF
expr_stmt|;
comment|/* 				 * fzfinish_rx() must be called before 				 * fgot_data() because fgot_data() will send 				 * out a UUCP-command but the sender won't be 				 * ready for it until it receives our final 				 * ZACK. 				 */
name|cerr
operator|=
name|cZretries
expr_stmt|;
name|wpZrxbytes
operator|+=
name|rxcount
expr_stmt|;
if|if
condition|(
operator|!
name|fzfinish_rx
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|rxcount
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* 				 * FIXME: Examine<fexit>? 				 * Or maybe ensure it's TRUE? 				 */
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fzwait: received header %s"
argument_list|,
name|ZZHEADER_NAME
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * File level routine. Called when initiating/terminating file transfers.  *  * When starting to send a file:	(TRUE, TRUE, cbytes)  * When starting to receive a file:	(TRUE, FALSE, -1)  * When send EOF, check resend:		(FALSE, TRUE, -1)  * When receive EOF, check re-receive:	(FALSE, FALSE, -1)  */
end_comment

begin_function
name|boolean
name|fzfile
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|,
name|fstart
parameter_list|,
name|fsend
parameter_list|,
name|cbytes
parameter_list|,
name|pfhandled
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|boolean
name|fstart
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|boolean
modifier|*
name|pfhandled
decl_stmt|;
block|{
name|long
name|iredo
decl_stmt|;
operator|*
name|pfhandled
operator|=
name|FALSE
expr_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzfile: fstart=%d, fsend=%d"
argument_list|,
name|fstart
argument_list|,
name|fsend
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsend
condition|)
block|{
if|if
condition|(
name|fstart
condition|)
return|return
name|fzstart_tx
argument_list|()
return|;
if|if
condition|(
operator|!
name|fzfinish_tx
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|iredo
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|iredo
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Attempt to back up non-file"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|qtrans
operator|->
name|e
argument_list|,
name|iredo
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|pfhandled
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|fsendfile
operator|=
name|TRUE
expr_stmt|;
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not used, we only use 32 bit crc's */
end_comment

begin_comment
comment|/*  * crctab calculated by Mark G. Mendel, Network Systems Corporation  */
end_comment

begin_endif
unit|static unsigned short crctab[256] = {     0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,     0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,     0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,     0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,     0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,     0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,     0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,     0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,     0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,     0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,     0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,     0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,     0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,     0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,     0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,     0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,     0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,     0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,     0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,     0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,     0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,     0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,     0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,     0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,     0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,     0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,     0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,     0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,     0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,     0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,     0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,     0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0 };
endif|#
directive|endif
end_endif

begin_comment
comment|/* crctab */
end_comment

begin_comment
comment|/*  * Copyright (C) 1986 Gary S. Brown.  You may use this program, or  * code or tables extracted from it, as desired without restriction.  */
end_comment

begin_comment
comment|/* First, the polynomial itself and its table of feedback terms.  The  */
end_comment

begin_comment
comment|/* polynomial is                                                       */
end_comment

begin_comment
comment|/* X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 */
end_comment

begin_comment
comment|/* Note that we take it "backwards" and put the highest-order term in  */
end_comment

begin_comment
comment|/* the lowest-order bit.  The X^32 term is "implied"; the LSB is the   */
end_comment

begin_comment
comment|/* X^31 term, etc.  The X^0 term (usually shown as "+1") results in    */
end_comment

begin_comment
comment|/* the MSB being 1.                                                    */
end_comment

begin_comment
comment|/* Note that the usual hardware shift register implementation, which   */
end_comment

begin_comment
comment|/* is what we're using (we're merely optimizing it by doing eight-bit  */
end_comment

begin_comment
comment|/* chunks at a time) shifts bits into the lowest-order term.  In our   */
end_comment

begin_comment
comment|/* implementation, that means shifting towards the right.  Why do we   */
end_comment

begin_comment
comment|/* do it this way?  Because the calculated CRC must be transmitted in  */
end_comment

begin_comment
comment|/* order from highest-order term to lowest-order term.  UARTs transmit */
end_comment

begin_comment
comment|/* characters in order from LSB to MSB.  By storing the CRC this way,  */
end_comment

begin_comment
comment|/* we hand it to the UART in the order low-byte to high-byte; the UART */
end_comment

begin_comment
comment|/* sends each low-bit to hight-bit; and the result is transmission bit */
end_comment

begin_comment
comment|/* by bit from highest- to lowest-order term without requiring any bit */
end_comment

begin_comment
comment|/* shuffling on our part.  Reception works similarly.                  */
end_comment

begin_comment
comment|/* The feedback terms table consists of 256, 32-bit entries.  Notes:   */
end_comment

begin_comment
comment|/*                                                                     */
end_comment

begin_comment
comment|/*     The table can be generated at runtime if desired; code to do so */
end_comment

begin_comment
comment|/*     is shown later.  It might not be obvious, but the feedback      */
end_comment

begin_comment
comment|/*     terms simply represent the results of eight shift/xor opera-    */
end_comment

begin_comment
comment|/*     tions for all combinations of data and CRC register values.     */
end_comment

begin_comment
comment|/*                                                                     */
end_comment

begin_comment
comment|/*     The values must be right-shifted by eight bits by the "updcrc"  */
end_comment

begin_comment
comment|/*     logic; the shift must be unsigned (bring in zeroes).  On some   */
end_comment

begin_comment
comment|/*     hardware you could probably optimize the shift in assembler by  */
end_comment

begin_comment
comment|/*     using byte-swap instructions.                                   */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|crc_32_tab
index|[]
init|=
block|{
comment|/* CRC polynomial 0xedb88320 */
literal|0x00000000L
block|,
literal|0x77073096L
block|,
literal|0xee0e612cL
block|,
literal|0x990951baL
block|,
literal|0x076dc419L
block|,
literal|0x706af48fL
block|,
literal|0xe963a535L
block|,
literal|0x9e6495a3L
block|,
literal|0x0edb8832L
block|,
literal|0x79dcb8a4L
block|,
literal|0xe0d5e91eL
block|,
literal|0x97d2d988L
block|,
literal|0x09b64c2bL
block|,
literal|0x7eb17cbdL
block|,
literal|0xe7b82d07L
block|,
literal|0x90bf1d91L
block|,
literal|0x1db71064L
block|,
literal|0x6ab020f2L
block|,
literal|0xf3b97148L
block|,
literal|0x84be41deL
block|,
literal|0x1adad47dL
block|,
literal|0x6ddde4ebL
block|,
literal|0xf4d4b551L
block|,
literal|0x83d385c7L
block|,
literal|0x136c9856L
block|,
literal|0x646ba8c0L
block|,
literal|0xfd62f97aL
block|,
literal|0x8a65c9ecL
block|,
literal|0x14015c4fL
block|,
literal|0x63066cd9L
block|,
literal|0xfa0f3d63L
block|,
literal|0x8d080df5L
block|,
literal|0x3b6e20c8L
block|,
literal|0x4c69105eL
block|,
literal|0xd56041e4L
block|,
literal|0xa2677172L
block|,
literal|0x3c03e4d1L
block|,
literal|0x4b04d447L
block|,
literal|0xd20d85fdL
block|,
literal|0xa50ab56bL
block|,
literal|0x35b5a8faL
block|,
literal|0x42b2986cL
block|,
literal|0xdbbbc9d6L
block|,
literal|0xacbcf940L
block|,
literal|0x32d86ce3L
block|,
literal|0x45df5c75L
block|,
literal|0xdcd60dcfL
block|,
literal|0xabd13d59L
block|,
literal|0x26d930acL
block|,
literal|0x51de003aL
block|,
literal|0xc8d75180L
block|,
literal|0xbfd06116L
block|,
literal|0x21b4f4b5L
block|,
literal|0x56b3c423L
block|,
literal|0xcfba9599L
block|,
literal|0xb8bda50fL
block|,
literal|0x2802b89eL
block|,
literal|0x5f058808L
block|,
literal|0xc60cd9b2L
block|,
literal|0xb10be924L
block|,
literal|0x2f6f7c87L
block|,
literal|0x58684c11L
block|,
literal|0xc1611dabL
block|,
literal|0xb6662d3dL
block|,
literal|0x76dc4190L
block|,
literal|0x01db7106L
block|,
literal|0x98d220bcL
block|,
literal|0xefd5102aL
block|,
literal|0x71b18589L
block|,
literal|0x06b6b51fL
block|,
literal|0x9fbfe4a5L
block|,
literal|0xe8b8d433L
block|,
literal|0x7807c9a2L
block|,
literal|0x0f00f934L
block|,
literal|0x9609a88eL
block|,
literal|0xe10e9818L
block|,
literal|0x7f6a0dbbL
block|,
literal|0x086d3d2dL
block|,
literal|0x91646c97L
block|,
literal|0xe6635c01L
block|,
literal|0x6b6b51f4L
block|,
literal|0x1c6c6162L
block|,
literal|0x856530d8L
block|,
literal|0xf262004eL
block|,
literal|0x6c0695edL
block|,
literal|0x1b01a57bL
block|,
literal|0x8208f4c1L
block|,
literal|0xf50fc457L
block|,
literal|0x65b0d9c6L
block|,
literal|0x12b7e950L
block|,
literal|0x8bbeb8eaL
block|,
literal|0xfcb9887cL
block|,
literal|0x62dd1ddfL
block|,
literal|0x15da2d49L
block|,
literal|0x8cd37cf3L
block|,
literal|0xfbd44c65L
block|,
literal|0x4db26158L
block|,
literal|0x3ab551ceL
block|,
literal|0xa3bc0074L
block|,
literal|0xd4bb30e2L
block|,
literal|0x4adfa541L
block|,
literal|0x3dd895d7L
block|,
literal|0xa4d1c46dL
block|,
literal|0xd3d6f4fbL
block|,
literal|0x4369e96aL
block|,
literal|0x346ed9fcL
block|,
literal|0xad678846L
block|,
literal|0xda60b8d0L
block|,
literal|0x44042d73L
block|,
literal|0x33031de5L
block|,
literal|0xaa0a4c5fL
block|,
literal|0xdd0d7cc9L
block|,
literal|0x5005713cL
block|,
literal|0x270241aaL
block|,
literal|0xbe0b1010L
block|,
literal|0xc90c2086L
block|,
literal|0x5768b525L
block|,
literal|0x206f85b3L
block|,
literal|0xb966d409L
block|,
literal|0xce61e49fL
block|,
literal|0x5edef90eL
block|,
literal|0x29d9c998L
block|,
literal|0xb0d09822L
block|,
literal|0xc7d7a8b4L
block|,
literal|0x59b33d17L
block|,
literal|0x2eb40d81L
block|,
literal|0xb7bd5c3bL
block|,
literal|0xc0ba6cadL
block|,
literal|0xedb88320L
block|,
literal|0x9abfb3b6L
block|,
literal|0x03b6e20cL
block|,
literal|0x74b1d29aL
block|,
literal|0xead54739L
block|,
literal|0x9dd277afL
block|,
literal|0x04db2615L
block|,
literal|0x73dc1683L
block|,
literal|0xe3630b12L
block|,
literal|0x94643b84L
block|,
literal|0x0d6d6a3eL
block|,
literal|0x7a6a5aa8L
block|,
literal|0xe40ecf0bL
block|,
literal|0x9309ff9dL
block|,
literal|0x0a00ae27L
block|,
literal|0x7d079eb1L
block|,
literal|0xf00f9344L
block|,
literal|0x8708a3d2L
block|,
literal|0x1e01f268L
block|,
literal|0x6906c2feL
block|,
literal|0xf762575dL
block|,
literal|0x806567cbL
block|,
literal|0x196c3671L
block|,
literal|0x6e6b06e7L
block|,
literal|0xfed41b76L
block|,
literal|0x89d32be0L
block|,
literal|0x10da7a5aL
block|,
literal|0x67dd4accL
block|,
literal|0xf9b9df6fL
block|,
literal|0x8ebeeff9L
block|,
literal|0x17b7be43L
block|,
literal|0x60b08ed5L
block|,
literal|0xd6d6a3e8L
block|,
literal|0xa1d1937eL
block|,
literal|0x38d8c2c4L
block|,
literal|0x4fdff252L
block|,
literal|0xd1bb67f1L
block|,
literal|0xa6bc5767L
block|,
literal|0x3fb506ddL
block|,
literal|0x48b2364bL
block|,
literal|0xd80d2bdaL
block|,
literal|0xaf0a1b4cL
block|,
literal|0x36034af6L
block|,
literal|0x41047a60L
block|,
literal|0xdf60efc3L
block|,
literal|0xa867df55L
block|,
literal|0x316e8eefL
block|,
literal|0x4669be79L
block|,
literal|0xcb61b38cL
block|,
literal|0xbc66831aL
block|,
literal|0x256fd2a0L
block|,
literal|0x5268e236L
block|,
literal|0xcc0c7795L
block|,
literal|0xbb0b4703L
block|,
literal|0x220216b9L
block|,
literal|0x5505262fL
block|,
literal|0xc5ba3bbeL
block|,
literal|0xb2bd0b28L
block|,
literal|0x2bb45a92L
block|,
literal|0x5cb36a04L
block|,
literal|0xc2d7ffa7L
block|,
literal|0xb5d0cf31L
block|,
literal|0x2cd99e8bL
block|,
literal|0x5bdeae1dL
block|,
literal|0x9b64c2b0L
block|,
literal|0xec63f226L
block|,
literal|0x756aa39cL
block|,
literal|0x026d930aL
block|,
literal|0x9c0906a9L
block|,
literal|0xeb0e363fL
block|,
literal|0x72076785L
block|,
literal|0x05005713L
block|,
literal|0x95bf4a82L
block|,
literal|0xe2b87a14L
block|,
literal|0x7bb12baeL
block|,
literal|0x0cb61b38L
block|,
literal|0x92d28e9bL
block|,
literal|0xe5d5be0dL
block|,
literal|0x7cdcefb7L
block|,
literal|0x0bdbdf21L
block|,
literal|0x86d3d2d4L
block|,
literal|0xf1d4e242L
block|,
literal|0x68ddb3f8L
block|,
literal|0x1fda836eL
block|,
literal|0x81be16cdL
block|,
literal|0xf6b9265bL
block|,
literal|0x6fb077e1L
block|,
literal|0x18b74777L
block|,
literal|0x88085ae6L
block|,
literal|0xff0f6a70L
block|,
literal|0x66063bcaL
block|,
literal|0x11010b5cL
block|,
literal|0x8f659effL
block|,
literal|0xf862ae69L
block|,
literal|0x616bffd3L
block|,
literal|0x166ccf45L
block|,
literal|0xa00ae278L
block|,
literal|0xd70dd2eeL
block|,
literal|0x4e048354L
block|,
literal|0x3903b3c2L
block|,
literal|0xa7672661L
block|,
literal|0xd06016f7L
block|,
literal|0x4969474dL
block|,
literal|0x3e6e77dbL
block|,
literal|0xaed16a4aL
block|,
literal|0xd9d65adcL
block|,
literal|0x40df0b66L
block|,
literal|0x37d83bf0L
block|,
literal|0xa9bcae53L
block|,
literal|0xdebb9ec5L
block|,
literal|0x47b2cf7fL
block|,
literal|0x30b5ffe9L
block|,
literal|0xbdbdf21cL
block|,
literal|0xcabac28aL
block|,
literal|0x53b39330L
block|,
literal|0x24b4a3a6L
block|,
literal|0xbad03605L
block|,
literal|0xcdd70693L
block|,
literal|0x54de5729L
block|,
literal|0x23d967bfL
block|,
literal|0xb3667a2eL
block|,
literal|0xc4614ab8L
block|,
literal|0x5d681b02L
block|,
literal|0x2a6f2b94L
block|,
literal|0xb40bbe37L
block|,
literal|0xc30c8ea1L
block|,
literal|0x5a05df1bL
block|,
literal|0x2d02ef8dL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell.   *  NOTE: First argument must be in range 0 to 255.  *        Second argument is referenced twice.  *   * Programmers may incorporate any or all code into their programs,   * giving proper credit within the source. Publication of the   * source routines is permitted so long as proper credit is given   * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg,   * Omen Technology.  */
end_comment

begin_define
define|#
directive|define
name|updcrc
parameter_list|(
name|cp
parameter_list|,
name|crc
parameter_list|)
value|(crctab[((crc>> 8)& 255)] ^ (crc<< 8) ^ cp)
end_define

begin_define
define|#
directive|define
name|UPDC32
parameter_list|(
name|b
parameter_list|,
name|crc
parameter_list|)
define|\
value|(crc_32_tab[((unsigned)(crc) ^ (unsigned)(b))& 0xff] \    ^ (((crc)>> 8)& 0x00ffffffL))
end_define

begin_comment
comment|/****************************************************************************/
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * This section contains the guts of the Zmodem protocol. The intention  * is to leave as much of it alone as possible at the start. Overtime it  * will be cleaned up (EG: I'd like to clean up the naming of the globals).  * Also, Zmodem has a different coding style. Over time this will be converted  * to the Taylor UUCP coding style.  */
end_comment

begin_comment
comment|/*  * Start the protocol (exchange init packets) ...  *  * UUCP can transfer files in both directions in one session. Therefore the  * init sequence is a little different.  *  * 1) ZINIT packets are exchanged  *    - contains protocol version and protocol flags  * 2) ZDATA packets are exchanged  *    - is intended to contain various numeric and string information  * 3) ZACK packets are exchanged  * 4) ZINITEND packets are exchanged  */
end_comment

begin_function
specifier|static
name|boolean
name|fzstart_proto
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|achdrval_t
name|tx_hdr
decl_stmt|,
name|rx_hdr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cZstartup_retries
condition|;
name|i
operator|++
control|)
block|{
name|stohdr
argument_list|(
literal|0L
argument_list|,
name|tx_hdr
argument_list|)
expr_stmt|;
name|tx_hdr
index|[
name|ZF0
index|]
operator|=
name|ZPROTOCOL_VERSION
expr_stmt|;
if|if
condition|(
name|fZesc_ctl
condition|)
name|tx_hdr
index|[
name|ZF1
index|]
operator||=
name|TX_ESCCTL
expr_stmt|;
switch|switch
condition|(
name|izexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|ZINIT
argument_list|,
name|tx_hdr
argument_list|,
name|rx_hdr
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|FALSE
return|;
case|case
literal|0
case|:
continue|continue;
case|case
literal|1
case|:
break|break;
block|}
if|#
directive|if
literal|0
comment|/* can't work, but kept for documentation */
block|if (rx_hdr[ZF0] == 0) { 			ulog (LOG_ERROR, "Old protocol version, init failed"); 			return FALSE; 		}
endif|#
directive|endif
name|fZesc_ctl
operator|=
name|fZesc_ctl
operator|||
operator|(
name|rx_hdr
index|[
name|ZF1
index|]
operator|&
name|TX_ESCCTL
operator|)
operator|!=
literal|0
expr_stmt|;
name|stohdr
argument_list|(
literal|0L
argument_list|,
name|tx_hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|izexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|ZDATA
argument_list|,
name|tx_hdr
argument_list|,
name|rx_hdr
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|FALSE
return|;
case|case
literal|0
case|:
continue|continue;
case|case
literal|1
case|:
break|break;
block|}
name|stohdr
argument_list|(
literal|0L
argument_list|,
name|tx_hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|izexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|ZACK
argument_list|,
name|tx_hdr
argument_list|,
name|rx_hdr
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|FALSE
return|;
case|case
literal|0
case|:
continue|continue;
case|case
literal|1
case|:
break|break;
block|}
name|stohdr
argument_list|(
literal|0L
argument_list|,
name|tx_hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|izexchange_init
argument_list|(
name|qdaemon
argument_list|,
name|ZINITEND
argument_list|,
name|tx_hdr
argument_list|,
name|rx_hdr
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|FALSE
return|;
case|case
literal|0
case|:
continue|continue;
case|case
literal|1
case|:
break|break;
block|}
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzstart_proto: Protocol started"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* FIXME: see protg.c regarding sequencing here. */
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Protocol init failed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Exchange init messages. This is based on 'g'.  * See the comments concerning fgexchange_init() in protg.c.  *  * We return 1 for success, 0 for restart, -1 for comm failure (terminate).  */
end_comment

begin_function
specifier|static
name|int
name|izexchange_init
parameter_list|(
name|qdaemon
parameter_list|,
name|send_type
parameter_list|,
name|send_val
parameter_list|,
name|recv_val
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|send_type
decl_stmt|;
name|achdrval_t
name|send_val
decl_stmt|;
name|achdrval_t
name|recv_val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|recv_type
decl_stmt|,
name|count
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CEXCHANGE_INIT_RETRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|send_type
operator|==
name|ZDATA
condition|?
name|ZBIN
else|:
name|ZHEX
argument_list|,
name|send_type
argument_list|,
name|rclhdr
argument_list|(
name|send_val
argument_list|)
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 		 * The ZDATA packet is intended to contain the<Attn> string 		 * (eventually, if it's ever usable) and allow for anything 		 * else that will need to be thrown in. 		 */
if|if
condition|(
name|send_type
operator|==
name|ZDATA
condition|)
block|{
name|count
operator|=
name|czbuild_data_packet
argument_list|(
name|zZtx_packet_buf
argument_list|,
literal|""
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|ZCRCF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zZtx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|recv_type
operator|=
name|izrecv_hdr
argument_list|(
name|qdaemon
argument_list|,
name|recv_val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|recv_type
condition|)
block|{
case|case
name|ZM_TIMEOUT
case|:
case|case
name|ZM_ERROR
case|:
continue|continue;
case|case
name|ZM_RCDO
case|:
case|case
name|ZFIN
case|:
return|return
operator|-
literal|1
return|;
case|case
name|ZINIT
case|:
case|case
name|ZACK
case|:
case|case
name|ZINITEND
case|:
break|break;
case|case
name|ZDATA
case|:
if|if
condition|(
name|zrdat32
argument_list|(
name|qdaemon
argument_list|,
name|zZrx_packet_buf
argument_list|,
literal|1024
argument_list|,
operator|&
name|count
argument_list|)
operator|==
name|GOTCRCF
condition|)
break|break;
continue|continue;
default|default:
continue|continue;
block|}
if|if
condition|(
name|recv_type
operator|==
name|send_type
condition|)
return|return
literal|1
return|;
comment|/* 		 * If the other side is farther along than we are, we have lost 		 * a packet.  Fall immediately back to ZINIT (but don't fail 		 * if we are already doing ZINIT, since that would count 		 * against cStart_retries more than it should). 		 * 		 * FIXME: The ">" test is "<" in protg.c. Check who's right. 		 */
if|if
condition|(
name|recv_type
operator|>
name|send_type
operator|&&
name|send_type
operator|!=
name|ZINIT
condition|)
return|return
literal|0
return|;
comment|/* 		 * If we are sending ZINITEND and we receive an ZINIT, the 		 * other side has falled back (we know this because we have 		 * seen a ZINIT from them).  Fall back ourselves to start 		 * the whole handshake over again. 		 */
if|if
condition|(
name|recv_type
operator|==
name|ZINIT
operator|&&
name|send_type
operator|==
name|ZINITEND
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Shut down the protocol ...  */
end_comment

begin_function
specifier|static
name|boolean
name|fzshutdown_proto
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZFIN
argument_list|,
literal|0L
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the transmitter side for sending a new message ...  */
end_comment

begin_function
specifier|static
name|boolean
name|fzstart_tx
parameter_list|()
block|{
name|iZlast_tx_data_packet
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 *<wpZlastsync> is set to -1L to suppress ZCRCW request otherwise 	 * triggered by (wpZlastsync == wpZtxpos). 	 */
name|cZblklen
operator|=
literal|1024
expr_stmt|;
name|wpZlastsync
operator|=
operator|-
literal|1L
expr_stmt|;
name|iZbeenhereb4
operator|=
literal|0
expr_stmt|;
name|iZtleft
operator|=
literal|0
expr_stmt|;
name|iZjunk_count
operator|=
literal|0
expr_stmt|;
name|wpZtxpos
operator|=
operator|(
name|wpZtxpos
operator|+
literal|1024L
operator|)
operator|&
operator|~
literal|1023L
expr_stmt|;
comment|/* next packet boundary */
name|wpZlrxpos
operator|=
name|wpZrxpos
operator|=
name|wpZtxpos
expr_stmt|;
name|wpZtxstart
operator|=
name|wpZtxpos
expr_stmt|;
comment|/* so we can compute the "file offset" */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Finish the sending of a message ...  *  * Basically, we wait for some indication that the receiver received our last  * message. If the receiver tells us to restart from some point, we set  * *plredo to that point.  *  * FIXME: This function is a major kludge at the moment. It is taken from  *	getinsync(). It is necessary because I don't yet buffer outgoing data.  *	It will go away when we do (buffer outgoing data).  */
end_comment

begin_function
specifier|static
name|boolean
name|fzfinish_tx
parameter_list|(
name|qdaemon
parameter_list|,
name|plredo
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|long
modifier|*
name|plredo
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|cerr
decl_stmt|,
name|ctimeouts
decl_stmt|;
name|achdrval_t
name|rx_hdr
decl_stmt|;
name|winpos_t
name|rx_bytes
decl_stmt|;
operator|*
name|plredo
operator|=
operator|-
literal|1
expr_stmt|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
name|ctimeouts
operator|=
literal|0
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzfinish_tx: txpos=0x%lx, rxpos=0x%lx, lrxpos=0x%lx, rxbytes=0x%lx"
argument_list|,
name|wpZtxpos
argument_list|,
name|wpZrxpos
argument_list|,
name|wpZlrxpos
argument_list|,
name|wpZrxbytes
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|izrecv_hdr
argument_list|(
name|qdaemon
argument_list|,
name|rx_hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZRPOS
case|:
name|wpZrxpos
operator|=
name|lzupdate_rxpos
argument_list|(
name|rx_hdr
argument_list|,
name|wpZrxpos
argument_list|,
name|wpZlrxpos
argument_list|,
name|wpZtxpos
argument_list|)
expr_stmt|;
comment|/* 			 * If the receiver sends a ZRPOS for the 1k block after 			 * the one we're currently at, we lost the final ZACK. 			 * We cheat and ignore this ZRPOS. Remember: the theory 			 * is that this entire function will go away when we 			 * begin buffering the outgoing data. Of course, one 			 * can reword the protocol definition and say this 			 * isn't cheating at all. 			 */
if|if
condition|(
operator|(
operator|(
name|wpZtxpos
operator|+
literal|1024
operator|)
operator|&
operator|~
literal|1023
operator|)
operator|==
name|wpZrxpos
condition|)
return|return
name|TRUE
return|;
name|cZbytes_resent
operator|+=
name|wpZtxpos
operator|-
name|wpZrxpos
expr_stmt|;
name|wpZlrxpos
operator|=
name|wpZtxpos
operator|=
name|wpZrxpos
expr_stmt|;
if|if
condition|(
name|wpZlastsync
operator|==
name|wpZrxpos
condition|)
block|{
if|if
condition|(
operator|++
name|iZbeenhereb4
operator|>
literal|4
condition|)
if|if
condition|(
name|cZblklen
operator|>
literal|32
condition|)
name|cZblklen
operator|/=
literal|2
expr_stmt|;
comment|/* FIXME: shouldn't we reset iZbeenhereb4? */
block|}
name|wpZlastsync
operator|=
name|wpZrxpos
expr_stmt|;
name|iZlast_tx_data_packet
operator|=
name|ZCRCW
expr_stmt|;
comment|/* force a timeout */
operator|*
name|plredo
operator|=
name|wpZrxpos
operator|-
name|wpZtxstart
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|ZACK
case|:
name|wpZrxpos
operator|=
name|lzupdate_rxpos
argument_list|(
name|rx_hdr
argument_list|,
name|wpZrxpos
argument_list|,
name|wpZlrxpos
argument_list|,
name|wpZtxpos
argument_list|)
expr_stmt|;
name|wpZlrxpos
operator|=
name|wpZrxpos
expr_stmt|;
if|if
condition|(
name|wpZtxpos
operator|==
name|wpZrxpos
condition|)
comment|/* the ACK we want? */
return|return
name|TRUE
return|;
break|break;
case|case
name|ZDATA
case|:
comment|/* 			 * We cheat here and take advantage of UUCP's current 			 * half duplex nature. If we get a ZDATA starting on 			 * the next 1k boundary, we lost the ZACK. We cheat and 			 * tuck it away so that izrecv_hdr() can later detect 			 * it. Remember: see above. 			 */
name|zdecode_data_hdr
argument_list|(
name|rclhdr
argument_list|(
name|rx_hdr
argument_list|)
argument_list|,
operator|&
name|rx_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|wpZrxbytes
operator|+
literal|1024L
operator|)
operator|&
operator|~
literal|1023L
operator|)
operator|==
name|rx_bytes
condition|)
block|{
name|iZpkt_rcvd_kludge
operator|=
name|ZDATA
expr_stmt|;
name|hvZpkt_hdrval_kludge
operator|=
name|rclhdr
argument_list|(
name|rx_hdr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
break|break;
comment|/* ignore, out of sync (old) */
case|case
name|ZNAK
case|:
comment|/* 			 * We cheat here and take advantage of UUCP's current 			 * half duplex nature. If we get a ZNAK starting on 			 * the next 1k boundary, we lost the ZACK. We cheat and 			 * throw the ZNAK away. Remember: see above. 			 * 			 * On the other hand, if (rx_bytes == wpZrxbytes) then 			 * the other side is also in fzfinish_tx(). He must 			 * have lost our ZACK, so we send him another. 			 */
name|zdecode_data_hdr
argument_list|(
name|rclhdr
argument_list|(
name|rx_hdr
argument_list|)
argument_list|,
operator|&
name|rx_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|wpZrxbytes
operator|+
literal|1024L
operator|)
operator|&
operator|~
literal|1023L
operator|)
operator|==
name|rx_bytes
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|rx_bytes
operator|==
name|wpZrxbytes
condition|)
block|{
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZACK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZrxbytes
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
comment|/* ignore, out of sync (old) */
case|case
name|ZFIN
case|:
case|case
name|ZM_RCDO
case|:
return|return
name|FALSE
return|;
case|case
name|ZM_TIMEOUT
case|:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzfinish_tx: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 			 * Normally the sender doesn't send NAK's for timeouts. 			 * We have to here because of the following scenario: 			 * 			 * - We send ZDATA/ZCRCF 			 * - They send ZACK (corrupted) 			 * - They send ZDATA/ZCRCF (corrupted) 			 * 			 * At this point, both sides are in fzfinish_tx(). 			 * We only send ZNAK every second timeout to increase 			 * our timeout delay vs. our partner. This tries to 			 * avoid ZRPOS and ZNAK "passing in transit". 			 */
if|if
condition|(
operator|++
name|ctimeouts
operator|%
literal|2
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZNAK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZtxpos
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|ZM_ERROR
case|:
default|default:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fzfinish_tx: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZNAK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZtxpos
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the receiver ...  */
end_comment

begin_function
specifier|static
name|boolean
name|fzstart_rx
parameter_list|()
block|{
name|wpZrxbytes
operator|=
operator|(
name|wpZrxbytes
operator|+
literal|1024L
operator|)
operator|&
operator|~
literal|1023L
expr_stmt|;
comment|/* next packet boundary */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate the receiver ...  *  * Acknowledge the last packet received.  */
end_comment

begin_function
specifier|static
name|boolean
name|fzfinish_rx
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzfinish_rx: message/file received"
argument_list|)
expr_stmt|;
return|return
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZACK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZrxbytes
argument_list|)
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a Zmodem header to our partner ...  */
end_comment

begin_function
specifier|static
name|boolean
name|fzsend_hdr
parameter_list|(
name|qdaemon
parameter_list|,
name|ipkttype
parameter_list|,
name|ihdrtype
parameter_list|,
name|hdrval
parameter_list|,
name|fcheckreceive
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|ipkttype
decl_stmt|;
name|int
name|ihdrtype
decl_stmt|;
name|hdrval_t
name|hdrval
decl_stmt|;
name|boolean
name|fcheckreceive
decl_stmt|;
block|{
name|int
name|cpacketlen
decl_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fzsend_hdr: %s, data = 0x%lx"
argument_list|,
name|ZZHEADER_NAME
argument_list|(
name|ihdrtype
argument_list|)
argument_list|,
name|hdrval
argument_list|)
expr_stmt|;
name|cpacketlen
operator|=
name|czbuild_header
argument_list|(
name|zZtx_packet_buf
argument_list|,
name|ipkttype
argument_list|,
name|ihdrtype
argument_list|,
name|hdrval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DJE_TESTING
if|#
directive|if
literal|0
block|if (ihdrtype == ZACK&& rand () % 100< uucptest2) { 		cZheaders_sent++; 		return TRUE; 	}
else|#
directive|else
if|if
condition|(
name|ihdrtype
operator|==
name|ZACK
operator|||
name|ihdrtype
operator|==
name|ZDATA
condition|)
block|{
name|boolean
name|fresult
decl_stmt|;
name|int
name|old
decl_stmt|;
specifier|extern
name|int
name|uucptest
decl_stmt|,
name|uucptest2
decl_stmt|;
name|old
operator|=
name|uucptest
expr_stmt|;
name|uucptest
operator|=
name|uucptest2
expr_stmt|;
name|cZheaders_sent
operator|++
expr_stmt|;
name|fresult
operator|=
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zZtx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|cpacketlen
argument_list|,
name|fcheckreceive
argument_list|)
expr_stmt|;
name|uucptest
operator|=
name|old
expr_stmt|;
return|return
name|fresult
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|cZheaders_sent
operator|++
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zZtx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|cpacketlen
argument_list|,
name|fcheckreceive
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a data packet to our partner ...  *<frameend> is one of ZCRCx.  */
end_comment

begin_function
specifier|static
name|boolean
name|fzsend_data_packet
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|frameend
parameter_list|,
name|fcheckreceive
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|frameend
decl_stmt|;
name|boolean
name|fcheckreceive
decl_stmt|;
block|{
name|int
name|cpacketlen
decl_stmt|;
name|cpacketlen
operator|=
name|czbuild_data_packet
argument_list|(
name|zZtx_packet_buf
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|,
name|frameend
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zZtx_packet_buf
argument_list|,
operator|(
name|size_t
operator|)
name|cpacketlen
argument_list|,
name|fcheckreceive
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build Zmodem headers ...  *  * Note that we use 32 bit CRC's for ZHEX headers.  *  * This function is a combination of zm fns: zsbhdr(), zsbh32(), and zshhdr().  */
end_comment

begin_function
specifier|static
name|int
name|czbuild_header
parameter_list|(
name|zresult
parameter_list|,
name|ipkttype
parameter_list|,
name|ihdrtype
parameter_list|,
name|hdrval
parameter_list|)
name|char
modifier|*
name|zresult
decl_stmt|;
name|int
name|ipkttype
decl_stmt|;
name|int
name|ihdrtype
decl_stmt|;
name|hdrval_t
name|hdrval
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
name|achdrval_t
name|achdrval
decl_stmt|;
name|p
operator|=
name|zresult
expr_stmt|;
switch|switch
condition|(
name|ipkttype
condition|)
block|{
case|case
name|ZBIN
case|:
operator|*
name|p
operator|++
operator|=
name|ZPAD
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ZDLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ZBIN
expr_stmt|;
name|p
operator|=
name|zputchar
argument_list|(
name|p
argument_list|,
name|ihdrtype
argument_list|)
expr_stmt|;
name|crc
operator|=
name|ICRCINIT
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|ihdrtype
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|stohdr
argument_list|(
name|hdrval
argument_list|,
name|achdrval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|zputchar
argument_list|(
name|p
argument_list|,
name|achdrval
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|achdrval
index|[
name|i
index|]
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|zputchar
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|)
name|crc
argument_list|)
expr_stmt|;
name|crc
operator|>>=
literal|8
expr_stmt|;
block|}
break|break;
case|case
name|ZHEX
case|:
comment|/* build hex header */
operator|*
name|p
operator|++
operator|=
name|ZPAD
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ZPAD
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ZDLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ZHEX
expr_stmt|;
name|p
operator|=
name|zputhex
argument_list|(
name|p
argument_list|,
name|ihdrtype
argument_list|)
expr_stmt|;
name|crc
operator|=
name|ICRCINIT
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|ihdrtype
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|stohdr
argument_list|(
name|hdrval
argument_list|,
name|achdrval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|zputhex
argument_list|(
name|p
argument_list|,
name|achdrval
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|achdrval
index|[
name|i
index|]
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|zputhex
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|)
name|crc
argument_list|)
expr_stmt|;
name|crc
operator|>>=
literal|8
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|CR
expr_stmt|;
comment|/* 		 * Uncork the remote in case a fake XOFF has stopped data flow. 		 */
if|if
condition|(
name|ihdrtype
operator|!=
name|ZFIN
operator|&&
name|ihdrtype
operator|!=
name|ZACK
condition|)
comment|/* FIXME: why? */
operator|*
name|p
operator|++
operator|=
name|XON
expr_stmt|;
break|break;
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"czbuild_header: ipkttype == %d"
argument_list|,
name|ipkttype
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|p
operator|-
name|zresult
return|;
block|}
end_function

begin_comment
comment|/*  * Build Zmodem data packets ...  *  * This function is zsdata() and zsda32() from the zm source.  */
end_comment

begin_function
specifier|static
name|int
name|czbuild_data_packet
parameter_list|(
name|zresult
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|frameend
parameter_list|)
name|char
modifier|*
name|zresult
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|frameend
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
name|p
operator|=
name|zresult
expr_stmt|;
name|crc
operator|=
name|ICRCINIT
expr_stmt|;
for|for
control|(
init|;
name|cdata
operator|--
operator|!=
literal|0
condition|;
name|zdata
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|zdata
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0140
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
else|else
name|p
operator|=
name|zputchar
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|ZDLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|frameend
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|frameend
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
for|for
control|(
name|cdata
operator|=
literal|0
init|;
name|cdata
operator|<
literal|4
condition|;
name|cdata
operator|++
control|)
block|{
name|p
operator|=
name|zputchar
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|)
name|crc
argument_list|)
expr_stmt|;
name|crc
operator|>>=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|frameend
operator|==
name|ZCRCW
operator|||
name|frameend
operator|==
name|ZCRCE
operator|||
name|frameend
operator|==
name|ZCRCF
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|CR
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|XON
expr_stmt|;
block|}
return|return
name|p
operator|-
name|zresult
return|;
block|}
end_function

begin_comment
comment|/*  * Read in a header ...  *  * This is function zgethdr() from the Zmodem source.  */
end_comment

begin_function
specifier|static
name|int
name|izrecv_hdr
parameter_list|(
name|qdaemon
parameter_list|,
name|hdr
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|achdrval_t
name|hdr
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|cerr
decl_stmt|;
comment|/* 	 * Kludge alert! If another part of the program received a packet but 	 * wasn't ready to handle it, it is tucked away for us to handle now. 	 */
if|if
condition|(
name|iZpkt_rcvd_kludge
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|iZpkt_rcvd_kludge
expr_stmt|;
name|iZpkt_rcvd_kludge
operator|=
operator|-
literal|1
expr_stmt|;
name|stohdr
argument_list|(
name|hvZpkt_hdrval_kludge
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"izrecv_hdr: queued %s, data = 0x%lx"
argument_list|,
name|ZZHEADER_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|rclhdr
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|cZheaders_received
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
name|cerr
operator|=
name|cZmax_garbage
expr_stmt|;
comment|/* Max bytes before start of frame */
name|again
label|:
switch|switch
condition|(
name|c
operator|=
name|noxrd7
argument_list|(
name|qdaemon
argument_list|)
condition|)
block|{
case|case
name|ZM_TIMEOUT
case|:
case|case
name|ZM_ERROR
case|:
case|case
name|ZM_RCDO
case|:
goto|goto
name|fifi
goto|;
case|case
name|ZPAD
case|:
comment|/* This is what we want */
break|break;
case|case
name|CR
case|:
comment|/* padding at end of previous header */
default|default:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|ZM_ERROR
expr_stmt|;
goto|goto
name|fifi
goto|;
block|}
goto|goto
name|again
goto|;
block|}
name|splat
label|:
switch|switch
condition|(
name|c
operator|=
name|noxrd7
argument_list|(
name|qdaemon
argument_list|)
condition|)
block|{
case|case
name|ZPAD
case|:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|ZM_ERROR
expr_stmt|;
goto|goto
name|fifi
goto|;
block|}
goto|goto
name|splat
goto|;
case|case
name|ZM_TIMEOUT
case|:
case|case
name|ZM_RCDO
case|:
goto|goto
name|fifi
goto|;
case|case
name|ZDLE
case|:
comment|/* This is what we want */
break|break;
default|default:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|ZM_ERROR
expr_stmt|;
goto|goto
name|fifi
goto|;
block|}
goto|goto
name|again
goto|;
block|}
switch|switch
condition|(
name|c
operator|=
name|noxrd7
argument_list|(
name|qdaemon
argument_list|)
condition|)
block|{
case|case
name|ZM_TIMEOUT
case|:
case|case
name|ZM_RCDO
case|:
goto|goto
name|fifi
goto|;
case|case
name|ZBIN
case|:
name|c
operator|=
name|zrbhdr32
argument_list|(
name|qdaemon
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZHEX
case|:
name|c
operator|=
name|zrhhdr
argument_list|(
name|qdaemon
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|ZM_ERROR
expr_stmt|;
goto|goto
name|fifi
goto|;
block|}
goto|goto
name|again
goto|;
block|}
name|fifi
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZM_TIMEOUT
case|:
name|cZtimeouts
operator|++
expr_stmt|;
break|break;
case|case
name|ZM_ERROR
case|:
name|cZerrors
operator|++
expr_stmt|;
break|break;
case|case
name|ZM_RCDO
case|:
break|break;
default|default:
name|cZheaders_received
operator|++
expr_stmt|;
break|break;
block|}
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"izrecv_hdr: %s, data = 0x%lx"
argument_list|,
name|ZZHEADER_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|rclhdr
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a binary style header (type and position) with 32 bit FCS ...  */
end_comment

begin_function
specifier|static
name|int
name|zrbhdr32
parameter_list|(
name|qdaemon
parameter_list|,
name|hdr
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|achdrval_t
name|hdr
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|type
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
return|return
name|c
return|;
name|type
operator|=
name|c
expr_stmt|;
name|crc
operator|=
name|ICRCINIT
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
return|return
name|c
return|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|hdr
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
return|return
name|c
return|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crc
operator|!=
name|IHDRCRC
condition|)
return|return
name|ZM_ERROR
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a hex style header (type and position) ...  */
end_comment

begin_function
specifier|static
name|int
name|zrhhdr
parameter_list|(
name|qdaemon
parameter_list|,
name|hdr
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|achdrval_t
name|hdr
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|type
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|zgethex
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|c
return|;
name|type
operator|=
name|c
expr_stmt|;
name|crc
operator|=
name|ICRCINIT
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|zgethex
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|c
return|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|hdr
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|zgethex
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|c
return|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crc
operator|!=
name|IHDRCRC
condition|)
return|return
name|ZM_ERROR
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a data packet ...  */
end_comment

begin_function
specifier|static
name|int
name|zrdat32
parameter_list|(
name|qdaemon
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|,
name|iprxcount
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
modifier|*
name|iprxcount
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|crc
operator|=
name|ICRCINIT
expr_stmt|;
operator|*
name|iprxcount
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|length
expr_stmt|;
while|while
condition|(
name|buf
operator|<=
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
block|{
name|crcfoo
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|GOTCRCE
case|:
case|case
name|GOTCRCG
case|:
case|case
name|GOTCRCQ
case|:
case|case
name|GOTCRCW
case|:
case|case
name|GOTCRCF
case|:
name|d
operator|=
name|c
expr_stmt|;
name|c
operator|&=
literal|0377
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
goto|goto
name|crcfoo
goto|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
goto|goto
name|crcfoo
goto|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
goto|goto
name|crcfoo
goto|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|zdlread
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|&
operator|~
literal|0377
condition|)
goto|goto
name|crcfoo
goto|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|IHDRCRC
condition|)
return|return
name|ZM_ERROR
return|;
operator|*
name|iprxcount
operator|=
name|length
operator|-
operator|(
name|end
operator|-
name|buf
operator|)
expr_stmt|;
return|return
name|d
return|;
case|case
name|ZM_TIMEOUT
case|:
case|case
name|ZM_RCDO
case|:
return|return
name|c
return|;
default|default:
return|return
name|ZM_ERROR
return|;
block|}
block|}
operator|*
name|buf
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
return|return
name|ZM_ERROR
return|;
comment|/* bad packet, too long */
block|}
end_function

begin_comment
comment|/*  * Respond to receiver's complaint, get back in sync with receiver ...  */
end_comment

begin_function
specifier|static
name|int
name|getinsync
parameter_list|(
name|qdaemon
parameter_list|,
name|flag
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
name|flag
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|cerr
decl_stmt|;
name|achdrval_t
name|rx_hdr
decl_stmt|;
name|cerr
operator|=
name|cZretries
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|izrecv_hdr
argument_list|(
name|qdaemon
argument_list|,
name|rx_hdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZRPOS
case|:
name|wpZrxpos
operator|=
name|lzupdate_rxpos
argument_list|(
name|rx_hdr
argument_list|,
name|wpZrxpos
argument_list|,
name|wpZlrxpos
argument_list|,
name|wpZtxpos
argument_list|)
expr_stmt|;
name|cZbytes_resent
operator|+=
name|wpZtxpos
operator|-
name|wpZrxpos
expr_stmt|;
name|wpZlrxpos
operator|=
name|wpZtxpos
operator|=
name|wpZrxpos
expr_stmt|;
if|if
condition|(
name|wpZlastsync
operator|==
name|wpZrxpos
condition|)
block|{
if|if
condition|(
operator|++
name|iZbeenhereb4
operator|>
literal|4
condition|)
if|if
condition|(
name|cZblklen
operator|>
literal|32
condition|)
name|cZblklen
operator|/=
literal|2
expr_stmt|;
comment|/* FIXME: shouldn't we reset iZbeenhereb4? */
block|}
name|wpZlastsync
operator|=
name|wpZrxpos
expr_stmt|;
return|return
name|ZRPOS
return|;
case|case
name|ZACK
case|:
name|wpZrxpos
operator|=
name|lzupdate_rxpos
argument_list|(
name|rx_hdr
argument_list|,
name|wpZrxpos
argument_list|,
name|wpZlrxpos
argument_list|,
name|wpZtxpos
argument_list|)
expr_stmt|;
name|wpZlrxpos
operator|=
name|wpZrxpos
expr_stmt|;
if|if
condition|(
name|flag
operator|||
name|wpZtxpos
operator|==
name|wpZrxpos
condition|)
return|return
name|ZACK
return|;
break|break;
case|case
name|ZNAK
case|:
block|{
name|winpos_t
name|rx_bytes
decl_stmt|;
comment|/* 			 * Our partner is in fzfinish_tx() and is waiting 			 * for ZACK ... 			 */
name|zdecode_data_hdr
argument_list|(
name|rclhdr
argument_list|(
name|rx_hdr
argument_list|)
argument_list|,
operator|&
name|rx_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_bytes
operator|==
name|wpZrxbytes
condition|)
block|{
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZACK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZrxbytes
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
block|}
case|case
name|ZFIN
case|:
case|case
name|ZM_RCDO
case|:
return|return
name|c
return|;
case|case
name|ZM_TIMEOUT
case|:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"getinsync: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|ZM_ERROR
return|;
block|}
break|break;
comment|/* sender doesn't send ZNAK for timeout */
case|case
name|ZM_ERROR
case|:
default|default:
if|if
condition|(
operator|--
name|cerr
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"getinsync: retries exhausted"
argument_list|)
expr_stmt|;
return|return
name|ZM_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|fzsend_hdr
argument_list|(
name|qdaemon
argument_list|,
name|ZHEX
argument_list|,
name|ZNAK
argument_list|,
name|hvzencode_data_hdr
argument_list|(
name|wpZtxpos
argument_list|)
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|ZM_ERROR
return|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a byte as two hex digits ...  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zputhex
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|digits
index|[
operator|(
name|ch
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|digits
index|[
name|ch
operator|&
literal|0xF
index|]
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Send character c with ZMODEM escape sequence encoding ...  *  * Escape XON, XOFF.  * FIXME: Escape CR following @ (Telenet net escape) ... disabled for now  *	Will need to put back references to<lastsent>.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zputchar
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
name|char
name|c
init|=
name|ch
decl_stmt|;
comment|/* Quick check for non control characters */
if|if
condition|(
name|c
operator|&
literal|0140
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
operator|&
literal|0377
condition|)
block|{
case|case
name|ZDLE
case|:
operator|*
name|p
operator|++
operator|=
name|ZDLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
break|break;
case|case
name|CR
case|:
if|#
directive|if
literal|0
block|if (!fZesc_ctl&& (lastsent& 0177) != '@') 				goto sendit;
endif|#
directive|endif
comment|/* fall through */
case|case
literal|020
case|:
comment|/* ^P */
case|case
name|XON
case|:
case|case
name|XOFF
case|:
operator|*
name|p
operator|++
operator|=
name|ZDLE
expr_stmt|;
name|c
operator|^=
literal|0100
expr_stmt|;
comment|/*sendit:*/
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fZesc_ctl
operator|&&
operator|!
operator|(
name|c
operator|&
literal|0140
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|ZDLE
expr_stmt|;
name|c
operator|^=
literal|0100
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Decode two lower case hex digits into an 8 bit byte value ...  */
end_comment

begin_function
specifier|static
name|int
name|zgethex
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|noxrd7
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|c
return|;
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|9
condition|)
name|n
operator|-=
operator|(
literal|'a'
operator|-
literal|':'
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|&
operator|~
literal|0xF
condition|)
return|return
name|ZM_ERROR
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|noxrd7
argument_list|(
name|qdaemon
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|c
return|;
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|9
condition|)
name|c
operator|-=
operator|(
literal|'a'
operator|-
literal|':'
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
operator|~
literal|0xF
condition|)
return|return
name|ZM_ERROR
return|;
name|c
operator|+=
operator|(
name|n
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Read a byte, checking for ZMODEM escape encoding ...  */
end_comment

begin_function
specifier|static
name|int
name|zdlread
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|again
label|:
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|c
argument_list|,
name|cZtimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|&
literal|0140
condition|)
comment|/* quick check for non control characters */
return|return
name|c
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZDLE
case|:
break|break;
case|case
name|XON
case|:
goto|goto
name|again
goto|;
case|case
name|XOFF
case|:
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|c
argument_list|,
name|XON_WAIT
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
default|default:
if|if
condition|(
name|fZesc_ctl
operator|&&
operator|!
operator|(
name|c
operator|&
literal|0140
operator|)
condition|)
goto|goto
name|again
goto|;
return|return
name|c
return|;
block|}
name|again2
label|:
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|c
argument_list|,
name|cZtimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZCRCE
case|:
case|case
name|ZCRCG
case|:
case|case
name|ZCRCQ
case|:
case|case
name|ZCRCW
case|:
case|case
name|ZCRCF
case|:
return|return
name|c
operator||
name|GOTOR
return|;
case|case
name|ZRUB0
case|:
comment|/* FIXME: This is never generated. */
return|return
literal|0177
return|;
case|case
name|ZRUB1
case|:
comment|/* FIXME: This is never generated. */
return|return
literal|0377
return|;
case|case
name|XON
case|:
goto|goto
name|again2
goto|;
case|case
name|XOFF
case|:
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|c
argument_list|,
name|XON_WAIT
argument_list|)
expr_stmt|;
goto|goto
name|again2
goto|;
default|default:
if|if
condition|(
name|fZesc_ctl
operator|&&
operator|!
operator|(
name|c
operator|&
literal|0140
operator|)
condition|)
goto|goto
name|again2
goto|;
comment|/* FIXME: why again2? */
if|if
condition|(
operator|(
name|c
operator|&
literal|0140
operator|)
operator|==
literal|0100
condition|)
return|return
name|c
operator|^
literal|0100
return|;
break|break;
block|}
return|return
name|ZM_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Read a character from the modem line with timeout ...  * Eat parity bit, XON and XOFF characters.  */
end_comment

begin_function
specifier|static
name|int
name|noxrd7
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|c
argument_list|,
name|cZtimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|c
operator|&=
literal|0177
condition|)
block|{
case|case
name|XON
case|:
continue|continue;
case|case
name|XOFF
case|:
name|READCHAR
argument_list|(
name|qdaemon
argument_list|,
name|c
argument_list|,
name|XON_WAIT
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CR
case|:
case|case
name|ZDLE
case|:
return|return
name|c
return|;
default|default:
if|if
condition|(
name|fZesc_ctl
operator|&&
operator|!
operator|(
name|c
operator|&
literal|0140
operator|)
condition|)
continue|continue;
return|return
name|c
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read a character from the receive buffer, or from the line if empty ...  *  *<timeout> is in seconds (maybe make it tenths of seconds like in Zmodem?)  */
end_comment

begin_function
specifier|static
name|int
name|realreadchar
parameter_list|(
name|qdaemon
parameter_list|,
name|timeout
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|breceive_char
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|timeout
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|ZM_TIMEOUT
return|;
case|case
operator|-
literal|2
case|:
return|return
name|ZM_RCDO
return|;
block|}
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"realreadchar: breceive_char() returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ZM_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the receive channel has any characters in it.  *  * At present we can only test the receive buffer. No mechanism is available  * to go to the hardware. This should not be a problem though, as long as all  * appropriate calls to fsend_data() set<fdoread> to TRUE.  */
end_comment

begin_function
specifier|static
name|boolean
name|fzreceive_ready
parameter_list|()
block|{
return|return
name|iPrecstart
operator|!=
name|iPrecend
return|;
block|}
end_function

begin_comment
comment|/*  * Store integer value in an achdrval_t ...  */
end_comment

begin_function
specifier|static
name|void
name|stohdr
parameter_list|(
name|val
parameter_list|,
name|hdr
parameter_list|)
name|hdrval_t
name|val
decl_stmt|;
name|achdrval_t
name|hdr
decl_stmt|;
block|{
name|hdr
index|[
name|ZP0
index|]
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
name|hdr
index|[
name|ZP1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|hdr
index|[
name|ZP2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|hdr
index|[
name|ZP3
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|val
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recover an integer from a header ...  */
end_comment

begin_function
specifier|static
name|hdrval_t
name|rclhdr
parameter_list|(
name|hdr
parameter_list|)
name|achdrval_t
name|hdr
decl_stmt|;
block|{
name|hdrval_t
name|v
decl_stmt|;
name|v
operator|=
name|hdr
index|[
name|ZP3
index|]
operator|&
literal|0377
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|<<
literal|8
operator|)
operator||
operator|(
name|hdr
index|[
name|ZP2
index|]
operator|&
literal|0377
operator|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|<<
literal|8
operator|)
operator||
operator|(
name|hdr
index|[
name|ZP1
index|]
operator|&
literal|0377
operator|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|<<
literal|8
operator|)
operator||
operator|(
name|hdr
index|[
name|ZP0
index|]
operator|&
literal|0377
operator|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a<hdrval_t> from the byte count ...  *  * We use to store the byte count / 32 and a message sequence number which  * made this function very useful. Don't remove it.  * FIXME: Well, maybe remove it later.  */
end_comment

begin_function
specifier|static
name|hdrval_t
name|hvzencode_data_hdr
parameter_list|(
name|cbytes
parameter_list|)
name|winpos_t
name|cbytes
decl_stmt|;
block|{
return|return
operator|(
name|hdrval_t
operator|)
name|cbytes
return|;
block|}
end_function

begin_comment
comment|/*  * Decode a<hdrval_t> into a byte count ...  *  * We use to store the byte count / 32 and a message sequence number which  * made this function very useful. Don't remove it.  * FIXME: Well, maybe remove it later.  */
end_comment

begin_function
specifier|static
name|void
name|zdecode_data_hdr
parameter_list|(
name|hdrval
parameter_list|,
name|pcbytes
parameter_list|)
name|hdrval_t
name|hdrval
decl_stmt|;
name|winpos_t
modifier|*
name|pcbytes
decl_stmt|;
block|{
operator|*
name|pcbytes
operator|=
name|hdrval
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update<wpZrxpos> from the received data header value ...  *  * FIXME: Here is where we'd handle wrapping around at 4 gigabytes.  */
end_comment

begin_function
specifier|static
name|winpos_t
name|lzupdate_rxpos
parameter_list|(
name|rx_hdr
parameter_list|,
name|rxpos
parameter_list|,
name|lrxpos
parameter_list|,
name|txpos
parameter_list|)
name|achdrval_t
name|rx_hdr
decl_stmt|;
name|winpos_t
name|rxpos
decl_stmt|,
name|lrxpos
decl_stmt|,
name|txpos
decl_stmt|;
block|{
name|winpos_t
name|rx_pktpos
decl_stmt|;
name|zdecode_data_hdr
argument_list|(
name|rclhdr
argument_list|(
name|rx_hdr
argument_list|)
argument_list|,
operator|&
name|rx_pktpos
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"lzupdate_rxpos: rx_pktpos=0x%lx, rxpos=0x%lx, lrxpos=0x%lx, txpos=0x%lx"
argument_list|,
name|rx_pktpos
argument_list|,
name|rxpos
argument_list|,
name|lrxpos
argument_list|,
name|txpos
argument_list|)
expr_stmt|;
comment|/* 	 * Check if<rx_pktpos> valid. It could be old. 	 */
if|if
condition|(
name|rx_pktpos
operator|<
name|wpZlrxpos
operator|||
name|rx_pktpos
operator|>
operator|(
operator|(
name|wpZtxpos
operator|+
literal|1024L
operator|)
operator|&
operator|~
literal|1023L
operator|)
condition|)
return|return
name|rxpos
return|;
return|return
name|rx_pktpos
return|;
block|}
end_function

end_unit

