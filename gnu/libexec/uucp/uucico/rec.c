begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rec.c    Routines to receive a file.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|rec_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* If the other side does not tell us the size of a file it wants to    send us, we assume it is this long.  This is only used for free    space checking.  */
end_comment

begin_define
define|#
directive|define
name|CASSUMED_FILE_SIZE
value|(10240)
end_define

begin_comment
comment|/* We keep this information in the pinfo field of the stransfer    structure.  */
end_comment

begin_struct
struct|struct
name|srecinfo
block|{
comment|/* Local user to send mail to (may be NULL).  */
name|char
modifier|*
name|zmail
decl_stmt|;
comment|/* Full file name.  */
name|char
modifier|*
name|zfile
decl_stmt|;
comment|/* Temporary file name.  */
name|char
modifier|*
name|ztemp
decl_stmt|;
comment|/* TRUE if this is a spool directory file.  */
name|boolean
name|fspool
decl_stmt|;
comment|/* TRUE if this was a local request.  */
name|boolean
name|flocal
decl_stmt|;
comment|/* TRUE if the file has been completely received.  */
name|boolean
name|freceived
decl_stmt|;
comment|/* TRUE if remote request has been replied to.  */
name|boolean
name|freplied
decl_stmt|;
comment|/* TRUE if we moved the file to the final destination.  */
name|boolean
name|fmoved
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is kept in the pinfo field if we are refusing a    remote request.  */
end_comment

begin_struct
struct|struct
name|srecfailinfo
block|{
comment|/* Reason for refusal.  */
name|enum
name|tfailure
name|twhy
decl_stmt|;
comment|/* TRUE if we have sent the reason for refusal.  */
name|boolean
name|fsent
decl_stmt|;
comment|/* TRUE if we have seen the end of the file.  */
name|boolean
name|freceived
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|urrec_free
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_rec_fail
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|scmd
operator|*
name|qcmd
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zwhy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_rec_send_request
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_rec_await_reply
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_send_reply
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_send_fail
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
expr|struct
name|scmd
operator|*
name|qcmd
operator|,
expr|enum
name|tfailure
name|twhy
operator|,
name|int
name|iremote
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_send_fail_send
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_discard
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|frec_file_end
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|frec_file_send_confirm
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Free up a receive stransfer structure.  */
end_comment

begin_function
specifier|static
name|void
name|urrec_free
parameter_list|(
name|qtrans
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
if|if
condition|(
name|qinfo
operator|!=
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|qinfo
operator|->
name|zmail
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qinfo
operator|->
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|qtrans
operator|->
name|pinfo
argument_list|)
expr_stmt|;
block|}
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up a request for a file from the remote system.  This may be    called before the remote system has been called.     This is the order of function calls:     flocal_rec_file_init --> fqueue_local    flocal_rec_send_request (send R ...) --> fqueue_receive    flocal_rec_await_reply (open file, call pffile) --> fqueue_receive    receive file    frec_file_end (close and move file, call pffile) --> fqueue_send    frec_file_send_confirm (send CY)    */
end_comment

begin_function
name|boolean
name|flocal_rec_file_init
parameter_list|(
name|qdaemon
parameter_list|,
name|qcmd
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|boolean
name|fspool
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
name|struct
name|srecinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
comment|/* Make sure we are permitted to transfer files.  */
if|if
condition|(
name|qdaemon
operator|->
name|fcaller
condition|?
operator|!
name|qsys
operator|->
name|uuconf_fcall_transfer
else|:
operator|!
name|qsys
operator|->
name|uuconf_fcalled_transfer
condition|)
block|{
comment|/* This case will have been checked by uucp or uux, but it could 	 have changed.  */
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_fcall_transfer
operator|&&
operator|!
name|qsys
operator|->
name|uuconf_fcalled_transfer
condition|)
return|return
name|flocal_rec_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qsys
argument_list|,
literal|"not permitted to request files"
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
name|fspool
operator|=
name|fspool_file
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
if|if
condition|(
name|fspool
condition|)
block|{
name|pointer
name|puuconf
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|struct
name|uuconf_system
name|slocalsys
decl_stmt|;
comment|/* Normal users are not allowed to request files to be received 	 into the spool directory.  To support uux forwarding, we use 	 the special option '9'.  This permits a file to be received 	 into the spool directory for the local system only without 	 the usual checking.  This is only done for local requests, of 	 course.  */
if|if
condition|(
name|qcmd
operator|->
name|zto
index|[
literal|0
index|]
operator|!=
literal|'D'
operator|||
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'9'
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|flocal_rec_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qsys
argument_list|,
literal|"not permitted to receive"
argument_list|)
return|;
name|puuconf
operator|=
name|qdaemon
operator|->
name|puuconf
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_localname
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zlocalname
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|zlocalname
operator|=
name|zsysdep_localname
argument_list|()
expr_stmt|;
if|if
condition|(
name|zlocalname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zlocalname
argument_list|,
operator|&
name|slocalsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|iuuconf
operator|=
name|uuconf_system_local
argument_list|(
name|puuconf
argument_list|,
operator|&
name|slocalsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|slocalsys
operator|.
name|uuconf_zname
operator|=
operator|(
name|char
operator|*
operator|)
name|zlocalname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zfile
operator|=
name|zsysdep_spool_file_name
argument_list|(
operator|&
name|slocalsys
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|slocalsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|zfile
operator|=
name|zsysdep_add_base
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check permissions.  */
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|qsys
operator|->
name|uuconf_pzlocal_receive
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|flocal_rec_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qsys
argument_list|,
literal|"not permitted to receive"
argument_list|)
return|;
block|}
comment|/* The 'f' option means that directories should not 	 be created if they do not already exist.  */
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'f'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zfile
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|flocal_rec_fail
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
argument_list|,
name|qsys
argument_list|,
literal|"cannot create directories"
argument_list|)
return|;
block|}
block|}
block|}
name|qinfo
operator|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|srecinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'m'
argument_list|)
operator|==
name|NULL
condition|)
name|qinfo
operator|->
name|zmail
operator|=
name|NULL
expr_stmt|;
else|else
name|qinfo
operator|->
name|zmail
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|zfile
operator|=
name|zfile
expr_stmt|;
name|qinfo
operator|->
name|ztemp
operator|=
name|NULL
expr_stmt|;
name|qinfo
operator|->
name|fspool
operator|=
name|fspool
expr_stmt|;
name|qinfo
operator|->
name|flocal
operator|=
name|TRUE
expr_stmt|;
name|qinfo
operator|->
name|freceived
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|freplied
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
name|qcmd
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|flocal_rec_send_request
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
return|return
name|fqueue_local
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Report an error for a local receive request.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_rec_fail
parameter_list|(
name|qtrans
parameter_list|,
name|qcmd
parameter_list|,
name|qsys
parameter_list|,
name|zwhy
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwhy
decl_stmt|;
block|{
if|if
condition|(
name|zwhy
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|zwhy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|zwhy
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qtrans
operator|!=
name|NULL
condition|)
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when we are ready to send the actual request to the    other system.  */
end_comment

begin_function
specifier|static
name|boolean
name|flocal_rec_send_request
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|long
name|cbytes
decl_stmt|,
name|cbytes2
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qinfo
operator|->
name|ztemp
operator|=
name|zsysdep_receive_temp
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|qinfo
operator|->
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|qdaemon
operator|->
name|qproto
operator|->
name|frestart
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_RESTART
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qinfo
operator|->
name|ztemp
operator|==
name|NULL
condition|)
block|{
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtrans
operator|->
name|fcmd
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|flocal_rec_await_reply
expr_stmt|;
if|if
condition|(
operator|!
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Check the amount of free space available for both the temporary      file and the real file.  */
name|cbytes
operator|=
name|csysdep_bytes_free
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|cbytes2
operator|=
name|csysdep_bytes_free
argument_list|(
name|qinfo
operator|->
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
name|cbytes2
condition|)
name|cbytes
operator|=
name|cbytes2
expr_stmt|;
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|cbytes
operator|-=
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_cfree_space
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
literal|0
condition|)
name|cbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|clocal_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cbytes
operator|==
operator|-
literal|1
operator|||
name|qdaemon
operator|->
name|clocal_size
operator|<
name|cbytes
operator|)
condition|)
name|cbytes
operator|=
name|qdaemon
operator|->
name|clocal_size
expr_stmt|;
comment|/* We send the string      R from to user options       We put a dash in front of options.  If we are talking to a      counterpart, we also send the maximum size file we are prepared      to accept, as returned by esysdep_open_receive.  */
name|clen
operator|=
operator|(
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|)
operator|+
literal|30
operator|)
expr_stmt|;
name|zsend
operator|=
name|zbufalc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_SIZES
operator|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"R %s %s %s -%s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_V103
operator|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"R %s %s %s -%s 0x%lx"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cbytes
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"R %s %s %s -%s %ld"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
name|cbytes
argument_list|)
expr_stmt|;
name|fret
operator|=
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|zsend
argument_list|,
name|qtrans
operator|->
name|ilocal
argument_list|,
name|qtrans
operator|->
name|iremote
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
comment|/* There is a potential space leak here: if pfsendcmd fails, we      might need to free qtrans.  However, it is possible that by the      time pfsendcmd returns, a response will have been received which      led to the freeing of qtrans anyhow.  One way to fix this would      be some sort of counter in qtrans to track allocations, but since      the space leak is small, and the conversation has failed anyhow,      it doesn't seem worth it.  */
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* This is called when a reply is received for the request.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|flocal_rec_await_reply
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlog
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
if|if
condition|(
name|zdata
index|[
literal|0
index|]
operator|!=
literal|'R'
operator|||
operator|(
name|zdata
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zdata
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: bad response to receive request: \"%s\""
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zdata
argument_list|)
expr_stmt|;
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zdata
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|boolean
name|fnever
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|fnever
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'2'
condition|)
name|zerr
operator|=
literal|"no such file"
expr_stmt|;
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
comment|/* We sent over the maximum file size we were prepared to 	     receive, and the remote system is telling us that the 	     file is larger than that.  Try again later.  It would be 	     better if we could know whether there will ever be enough 	     room.  */
name|zerr
operator|=
literal|"too large to receive now"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zdata
index|[
literal|2
index|]
operator|==
literal|'9'
condition|)
block|{
comment|/* Remote has run out of channels.  */
name|zerr
operator|=
literal|"too many channels for remote"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
comment|/* Drop one channel; using exactly one channel causes 	     slightly different behahaviour in a few places, so don't 	     decrement to one.  */
if|if
condition|(
name|qdaemon
operator|->
name|cchans
operator|>
literal|2
condition|)
operator|--
name|qdaemon
operator|->
name|cchans
expr_stmt|;
block|}
else|else
name|zerr
operator|=
literal|"unknown reason"
expr_stmt|;
if|if
condition|(
name|fnever
condition|)
return|return
name|flocal_rec_fail
argument_list|(
name|qtrans
argument_list|,
operator|&
name|qtrans
operator|->
name|s
argument_list|,
name|qdaemon
operator|->
name|qsys
argument_list|,
name|zerr
argument_list|)
return|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* The mode should have been sent as "RY 0%o".  If it wasn't, we use      0666.  */
name|qtrans
operator|->
name|s
operator|.
name|imode
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|zdata
operator|+
literal|2
operator|)
argument_list|,
operator|&
name|zend
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|imode
operator|==
literal|0
condition|)
name|qtrans
operator|->
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
comment|/* If there is an M after the mode, the remote has requested a      hangup.  */
if|if
condition|(
operator|*
name|zend
operator|==
literal|'M'
operator|&&
name|qdaemon
operator|->
name|fmaster
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"flocal_rec_await_reply: Remote has requested transfer of control"
argument_list|)
expr_stmt|;
name|qdaemon
operator|->
name|fhangup_requested
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Open the file to receive into.  We just ignore any restart count,      since we have no way to tell it to the other side.  SVR4 may have      some way to do this, but I don't know what it is.  */
name|qtrans
operator|->
name|e
operator|=
name|esysdep_open_receive
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|qinfo
operator|->
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qinfo
operator|->
name|ztemp
argument_list|,
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
return|return
name|flocal_rec_fail
argument_list|(
name|qtrans
argument_list|,
operator|&
name|qtrans
operator|->
name|s
argument_list|,
name|qdaemon
operator|->
name|qsys
argument_list|,
literal|"cannot open file"
argument_list|)
return|;
if|if
condition|(
name|qinfo
operator|->
name|fspool
condition|)
name|zlog
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zto
expr_stmt|;
else|else
name|zlog
operator|=
name|qinfo
operator|->
name|zfile
expr_stmt|;
name|qtrans
operator|->
name|zlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"Receiving "
operator|+
name|strlen
argument_list|(
name|zlog
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|"Receiving %s"
argument_list|,
name|zlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fhandled
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
call|)
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|fhandled
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
return|return
name|flocal_rec_fail
argument_list|(
name|qtrans
argument_list|,
operator|&
name|qtrans
operator|->
name|s
argument_list|,
name|qdaemon
operator|->
name|qsys
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|fhandled
condition|)
return|return
name|TRUE
return|;
block|}
name|qtrans
operator|->
name|frecfile
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|frec_file_send_confirm
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|frec_file_end
expr_stmt|;
return|return
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure there is still enough disk space available to receive a    file.  */
end_comment

begin_function
name|boolean
name|frec_check_free
parameter_list|(
name|qtrans
parameter_list|,
name|cfree_space
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|long
name|cfree_space
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|long
name|cfree1
decl_stmt|,
name|cfree2
decl_stmt|;
name|cfree1
operator|=
name|csysdep_bytes_free
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|cfree2
operator|=
name|csysdep_bytes_free
argument_list|(
name|qinfo
operator|->
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfree1
operator|<
name|cfree2
condition|)
name|cfree1
operator|=
name|cfree2
expr_stmt|;
if|if
condition|(
name|cfree1
operator|!=
operator|-
literal|1
operator|&&
name|cfree1
operator|<
name|cfree_space
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: too big to receive now"
argument_list|,
name|qinfo
operator|->
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A remote request to send a file to the local system, meaning that    we are going to receive a file.     If we are using a protocol which does not support multiple    channels, the remote system will not start sending us the file    until it has received our confirmation.  In that case, the order of    functions is as follows:     fremote_send_file_init (open file) --> fqueue_remote    fremote_send_reply (send SY, call pffile) --> fqueue_receive    receive file    frec_file_end (close and move file, call pffile) --> fqueue_send    frec_file_send_confirm (send CY)     If the protocol supports multiple channels, then the remote system    will start sending the file immediately after the send request.    That means that the data may come in before remote_send_reply is    called, so frec_file_end may be called before fremote_send_reply.    Note that this means the pffile entry points may be called in    reverse order for such a protocol.     If the send request is rejected, via fremote_send_fail, and the    protocol supports multiple channels, we must accept and discard    data until a zero byte buffer is received from the other side,    indicating that it has received our rejection.     This code also handles execution requests, which are very similar    to send requests.  */
end_comment

begin_function
name|boolean
name|fremote_send_file_init
parameter_list|(
name|qdaemon
parameter_list|,
name|qcmd
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|boolean
name|fspool
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
name|char
modifier|*
name|ztemp
decl_stmt|;
name|long
name|cbytes
decl_stmt|,
name|cbytes2
decl_stmt|;
name|long
name|crestart
decl_stmt|;
name|struct
name|srecinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlog
decl_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
if|if
condition|(
operator|!
name|qsys
operator|->
name|uuconf_frec_request
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: not permitted to receive files from remote"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
name|fspool
operator|=
name|fspool_file
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
comment|/* We don't accept remote command files.  An execution request may      only send a simple data file.  */
if|if
condition|(
operator|(
name|fspool
operator|&&
name|qcmd
operator|->
name|zto
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|||
operator|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'E'
operator|&&
operator|(
operator|!
name|fspool
operator|||
name|qcmd
operator|->
name|zto
index|[
literal|0
index|]
operator|!=
literal|'D'
operator|)
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: not permitted to receive"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
comment|/* See if we have already received this file in a previous      conversation.  */
if|if
condition|(
name|fsysdep_already_received
argument_list|(
name|qsys
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|)
condition|)
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_RECEIVED
argument_list|,
name|iremote
argument_list|)
return|;
if|if
condition|(
name|fspool
condition|)
block|{
name|zfile
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|boolean
name|fbadname
decl_stmt|;
name|zfile
operator|=
name|zsysdep_local_file
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
operator|&
name|fbadname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
operator|&&
name|fbadname
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: bad local file name"
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
if|if
condition|(
name|zfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zadd
decl_stmt|;
name|zadd
operator|=
name|zsysdep_add_base
argument_list|(
name|zfile
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zadd
expr_stmt|;
block|}
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check permissions.  */
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|qsys
operator|->
name|uuconf_pzremote_receive
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: not permitted to receive"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_PERM
argument_list|,
name|iremote
argument_list|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'f'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zfile
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_OPEN
argument_list|,
name|iremote
argument_list|)
return|;
block|}
block|}
block|}
name|ztemp
operator|=
name|zsysdep_receive_temp
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|,
operator|(
name|qdaemon
operator|->
name|qproto
operator|->
name|frestart
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_RESTART
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Adjust the number of bytes we are prepared to receive according      to the amount of free space we are supposed to leave available      and the maximum file size we are permitted to transfer.  */
name|cbytes
operator|=
name|csysdep_bytes_free
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|cbytes2
operator|=
name|csysdep_bytes_free
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
name|cbytes2
condition|)
name|cbytes
operator|=
name|cbytes2
expr_stmt|;
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|cbytes
operator|-=
name|qsys
operator|->
name|uuconf_cfree_space
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
literal|0
condition|)
name|cbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|cremote_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cbytes
operator|==
operator|-
literal|1
operator|||
name|qdaemon
operator|->
name|cremote_size
operator|<
name|cbytes
operator|)
condition|)
name|cbytes
operator|=
name|qdaemon
operator|->
name|cremote_size
expr_stmt|;
comment|/* If the number of bytes we are prepared to receive is less than      the file size, we must fail.  If the remote did not tell us the      file size, arbitrarily assumed that it is 10240 bytes.  */
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|csize
decl_stmt|;
name|csize
operator|=
name|qcmd
operator|->
name|cbytes
expr_stmt|;
if|if
condition|(
name|csize
operator|==
operator|-
literal|1
condition|)
name|csize
operator|=
name|CASSUMED_FILE_SIZE
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
name|csize
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: too big to receive"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_SIZE
argument_list|,
name|iremote
argument_list|)
return|;
block|}
block|}
comment|/* Open the file to receive into.  This may find an old copy of the      file, which will be used for file restart if the other side      supports it.  */
name|crestart
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|=
name|esysdep_open_receive
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|,
name|ztemp
argument_list|,
operator|(
operator|(
name|qdaemon
operator|->
name|qproto
operator|->
name|frestart
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_RESTART
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|&
name|crestart
else|:
operator|(
name|long
operator|*
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fremote_send_fail
argument_list|(
name|qdaemon
argument_list|,
name|qcmd
argument_list|,
name|FAILURE_OPEN
argument_list|,
name|iremote
argument_list|)
return|;
block|}
if|if
condition|(
name|crestart
operator|>
literal|0
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fremote_send_file_init: Restarting receive from %ld"
argument_list|,
name|crestart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|e
argument_list|,
name|crestart
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|qinfo
operator|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|srecinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|,
literal|'n'
argument_list|)
operator|==
name|NULL
condition|)
name|qinfo
operator|->
name|zmail
operator|=
name|NULL
expr_stmt|;
else|else
name|qinfo
operator|->
name|zmail
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|znotify
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|zfile
operator|=
name|zfile
expr_stmt|;
name|qinfo
operator|->
name|ztemp
operator|=
name|ztemp
expr_stmt|;
name|qinfo
operator|->
name|fspool
operator|=
name|fspool
expr_stmt|;
name|qinfo
operator|->
name|flocal
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|freceived
operator|=
name|FALSE
expr_stmt|;
name|qinfo
operator|->
name|freplied
operator|=
name|FALSE
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
name|qcmd
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|fremote_send_reply
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|frec_file_end
expr_stmt|;
name|qtrans
operator|->
name|iremote
operator|=
name|iremote
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
name|qtrans
operator|->
name|frecfile
operator|=
name|TRUE
expr_stmt|;
name|qtrans
operator|->
name|e
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|crestart
operator|>
literal|0
condition|)
name|qtrans
operator|->
name|ipos
operator|=
name|crestart
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'E'
condition|)
name|zlog
operator|=
name|qcmd
operator|->
name|zcmd
expr_stmt|;
else|else
block|{
if|if
condition|(
name|qinfo
operator|->
name|fspool
condition|)
name|zlog
operator|=
name|qcmd
operator|->
name|zto
expr_stmt|;
else|else
name|zlog
operator|=
name|qinfo
operator|->
name|zfile
expr_stmt|;
block|}
name|qtrans
operator|->
name|zlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"Receiving ( bytes resume at )"
operator|+
name|strlen
argument_list|(
name|zlog
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|"Receiving %s"
argument_list|,
name|zlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|crestart
operator|>
literal|0
operator|||
name|qcmd
operator|->
name|cbytes
operator|>
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|cbytes
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|)
argument_list|,
literal|"%ld bytes"
argument_list|,
name|qcmd
operator|->
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|crestart
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crestart
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|qtrans
operator|->
name|zlog
operator|+
name|strlen
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|)
argument_list|,
literal|"resume at %ld"
argument_list|,
name|crestart
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|qtrans
operator|->
name|zlog
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|fqueue_remote
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reply to a send request, and prepare to receive the file.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_send_reply
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|char
name|ab
index|[
literal|50
index|]
decl_stmt|;
comment|/* If the file has been completely received, we just want to send      the final confirmation.  Otherwise, we must wait for the file      first.  */
name|qtrans
operator|->
name|psendfn
operator|=
name|frec_file_send_confirm
expr_stmt|;
if|if
condition|(
name|qinfo
operator|->
name|freceived
condition|)
name|fret
operator|=
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
expr_stmt|;
else|else
name|fret
operator|=
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
return|return
name|FALSE
return|;
name|ab
index|[
literal|0
index|]
operator|=
name|qtrans
operator|->
name|s
operator|.
name|bcmd
expr_stmt|;
name|ab
index|[
literal|1
index|]
operator|=
literal|'Y'
expr_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|ipos
operator|<=
literal|0
condition|)
name|ab
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ab
operator|+
literal|2
argument_list|,
literal|" 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|qtrans
operator|->
name|ipos
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|freplied
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|ab
argument_list|,
name|qtrans
operator|->
name|ilocal
argument_list|,
name|qtrans
operator|->
name|iremote
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
comment|/* Should probably free qtrans here, but see the comment at the          end of flocal_rec_send_request.  */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fhandled
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
call|)
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|fhandled
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If we can't receive a file, queue up a response to the remote    system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_send_fail
parameter_list|(
name|qdaemon
parameter_list|,
name|qcmd
parameter_list|,
name|twhy
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
name|enum
name|tfailure
name|twhy
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|struct
name|srecfailinfo
modifier|*
name|qinfo
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|srecfailinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|srecfailinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|twhy
operator|=
name|twhy
expr_stmt|;
name|qinfo
operator|->
name|fsent
operator|=
name|FALSE
expr_stmt|;
comment|/* If the protocol does not support multiple channels (cchans<= 1),      then we have essentially already received the entire file.  */
name|qinfo
operator|->
name|freceived
operator|=
name|qdaemon
operator|->
name|cchans
operator|<=
literal|1
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
name|qcmd
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|fremote_send_fail_send
expr_stmt|;
name|qtrans
operator|->
name|precfn
operator|=
name|fremote_discard
expr_stmt|;
name|qtrans
operator|->
name|iremote
operator|=
name|iremote
expr_stmt|;
name|qtrans
operator|->
name|pinfo
operator|=
operator|(
name|pointer
operator|)
name|qinfo
expr_stmt|;
return|return
name|fqueue_remote
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a failure string for a send command to the remote system;    this is called when we are ready to reply to the command.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_send_fail_send
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|srecfailinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecfailinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
name|ab
index|[
literal|4
index|]
decl_stmt|;
name|int
name|ilocal
decl_stmt|,
name|iremote
decl_stmt|;
name|ab
index|[
literal|0
index|]
operator|=
name|qtrans
operator|->
name|s
operator|.
name|bcmd
expr_stmt|;
name|ab
index|[
literal|1
index|]
operator|=
literal|'N'
expr_stmt|;
switch|switch
condition|(
name|qinfo
operator|->
name|twhy
condition|)
block|{
case|case
name|FAILURE_PERM
case|:
name|ab
index|[
literal|2
index|]
operator|=
literal|'2'
expr_stmt|;
break|break;
case|case
name|FAILURE_OPEN
case|:
name|ab
index|[
literal|2
index|]
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
name|FAILURE_SIZE
case|:
name|ab
index|[
literal|2
index|]
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
name|FAILURE_RECEIVED
case|:
comment|/* Remember this file as though we successfully received it; 	 when the other side acknowledges our rejection, we know that 	 we no longer have to remember that we received this file.  */
name|usent_receive_ack
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
expr_stmt|;
name|ab
index|[
literal|2
index|]
operator|=
literal|'8'
expr_stmt|;
break|break;
default|default:
name|ab
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|ab
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ilocal
operator|=
name|qtrans
operator|->
name|ilocal
expr_stmt|;
name|iremote
operator|=
name|qtrans
operator|->
name|iremote
expr_stmt|;
comment|/* Wait for the end of file marker if we haven't gotten it yet.  */
if|if
condition|(
operator|!
name|qinfo
operator|->
name|freceived
condition|)
block|{
name|qinfo
operator|->
name|fsent
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fqueue_receive
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|xfree
argument_list|(
name|qtrans
operator|->
name|pinfo
argument_list|)
expr_stmt|;
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
block|}
return|return
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|ab
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard data until we reach the end of the file.  This is used for    a protocol with multiple channels, since the remote system may    start sending the file before the confirmation is sent.  If we    refuse the file, the remote system will get us back in synch by    sending an empty buffer, which is what we look for here.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fremote_discard
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|srecfailinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecfailinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fremote_discard: Discarding %lu bytes"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdata
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|qinfo
operator|->
name|freceived
operator|=
name|TRUE
expr_stmt|;
comment|/* If we have already sent the denial, we are done.  */
if|if
condition|(
name|qinfo
operator|->
name|fsent
condition|)
block|{
name|xfree
argument_list|(
name|qtrans
operator|->
name|pinfo
argument_list|)
expr_stmt|;
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called when a file has been completely received.  It sends    a response to the remote system.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|frec_file_end
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|boolean
name|fnever
decl_stmt|;
name|DEBUG_MESSAGE3
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"frec_file_end: %s to %s (freplied %s)"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qinfo
operator|->
name|freplied
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fhandled
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pffile
call|)
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|fhandled
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fhandled
condition|)
return|return
name|TRUE
return|;
block|}
name|qinfo
operator|->
name|freceived
operator|=
name|TRUE
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
name|zalc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_sync
argument_list|(
name|qtrans
operator|->
name|e
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
condition|)
block|{
name|zerr
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ffileclose
argument_list|(
name|qtrans
operator|->
name|e
argument_list|)
condition|)
block|{
name|zerr
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: close: %s"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fsysdep_move_file
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|,
name|qinfo
operator|->
name|zfile
argument_list|,
name|qinfo
operator|->
name|fspool
argument_list|,
name|FALSE
argument_list|,
operator|!
name|qinfo
operator|->
name|fspool
argument_list|,
operator|(
name|qinfo
operator|->
name|flocal
condition|?
name|qtrans
operator|->
name|s
operator|.
name|zuser
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|)
argument_list|)
condition|)
block|{
name|long
name|cspace
decl_stmt|;
comment|/* Keep the temporary file if there is 1.5 times the amount of 	 required free space.  This is just a random guess, to make an 	 unusual situtation potentially less painful.  */
name|cspace
operator|=
name|csysdep_bytes_free
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cspace
operator|==
operator|-
literal|1
condition|)
name|cspace
operator|=
name|FREE_SPACE_DELTA
expr_stmt|;
name|cspace
operator|-=
operator|(
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_cfree_space
operator|+
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_cfree_space
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|cspace
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|zerr
operator|=
literal|"could not move to final location"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"could not move to final location (left as )"
operator|+
name|strlen
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"could not move to final location (left as %s)"
argument_list|,
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|zalc
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"The file\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|qinfo
operator|->
name|ztemp
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nwas saved because the move to the final location failed.\n"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"See the UUCP logs for more details.\n"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"The file transfer was from\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"!"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zfrom
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nto\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zto
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nand was requested by\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|qtrans
operator|->
name|s
operator|.
name|zuser
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|OWNER
argument_list|,
literal|"UUCP temporary file saved"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|qinfo
operator|->
name|zfile
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
name|fnever
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|qinfo
operator|->
name|fspool
condition|)
block|{
name|unsigned
name|int
name|imode
decl_stmt|;
comment|/* Unless we can change the ownership of the file, the only 	     choice to make about these bits is whether to set the 	     execute bit or not.  */
if|if
condition|(
operator|(
name|qtrans
operator|->
name|s
operator|.
name|imode
operator|&
literal|0111
operator|)
operator|!=
literal|0
condition|)
name|imode
operator|=
literal|0777
expr_stmt|;
else|else
name|imode
operator|=
literal|0666
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_change_mode
argument_list|(
name|qinfo
operator|->
name|zfile
argument_list|,
name|imode
argument_list|)
expr_stmt|;
block|}
name|zerr
operator|=
name|NULL
expr_stmt|;
block|}
name|ustats
argument_list|(
name|zerr
operator|==
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|FALSE
argument_list|,
name|qtrans
operator|->
name|cbytes
argument_list|,
name|qtrans
operator|->
name|isecs
argument_list|,
name|qtrans
operator|->
name|imicros
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|)
expr_stmt|;
name|qdaemon
operator|->
name|creceived
operator|+=
name|qtrans
operator|->
name|cbytes
expr_stmt|;
if|if
condition|(
name|zerr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|qinfo
operator|->
name|zmail
operator|!=
name|NULL
operator|&&
operator|*
name|qinfo
operator|->
name|zmail
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|TRUE
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qinfo
operator|->
name|zmail
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinfo
operator|->
name|flocal
condition|)
block|{
comment|/* Remember that we have received this file, so that if the 	     connection drops at this point we won't receive it again. 	     We could check the return value here, but if we return 	     FALSE we couldn't do anything but drop the connection, 	     which would hardly be reasonable.  Instead we trust that 	     the administrator will notice and handle any error 	     messages, which are very unlikely to occur if everything 	     is set up correctly.  */
operator|(
name|void
operator|)
name|fsysdep_remember_reception
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the transfer failed, we send mail if it was requested 	 locally and if it can never succeed.  */
if|if
condition|(
name|qinfo
operator|->
name|flocal
operator|&&
name|fnever
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qinfo
operator|->
name|zmail
argument_list|,
name|zerr
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
block|}
block|}
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
comment|/* If this is an execution request, we must create the execution      file itself.  */
if|if
condition|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|&&
name|zerr
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|zxqt
decl_stmt|,
modifier|*
name|zxqtfile
decl_stmt|,
modifier|*
name|ztemp
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|boolean
name|fbad
decl_stmt|;
comment|/* We get an execution file name by simply replacing the leading 	 D in the received file name with an X.  This pretty much 	 always has to work since we can always receive a file name 	 starting with X, so the system dependent code must be 	 prepared to see one.  */
name|zxqt
operator|=
name|zbufcpy
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|zxqt
index|[
literal|0
index|]
operator|=
literal|'X'
expr_stmt|;
name|zxqtfile
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|zxqt
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zxqt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxqtfile
operator|==
name|NULL
condition|)
block|{
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We have to write via a temporary file, because otherwise 	 uuxqt might pick up the file before we have finished writing 	 it.  */
name|e
operator|=
name|NULL
expr_stmt|;
name|ztemp
operator|=
name|zsysdep_receive_temp
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|zxqtfile
argument_list|,
literal|"D.0"
argument_list|,
operator|(
name|qdaemon
operator|->
name|qproto
operator|->
name|frestart
operator|&&
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_RESTART
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztemp
operator|!=
name|NULL
condition|)
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|ztemp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|zxqtfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"U %s %s\n"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"F %s\n"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"I %s\n"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"N\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'Z'
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"Z\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'R'
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"R %s\n"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|znotify
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'e'
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"e\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"C %s\n"
argument_list|,
name|qtrans
operator|->
name|s
operator|.
name|zcmd
argument_list|)
expr_stmt|;
name|fbad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fstdiosync
argument_list|(
name|e
argument_list|,
name|ztemp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|fbad
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fbad
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|fbad
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fbad
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_move_file
argument_list|(
name|ztemp
argument_list|,
name|zxqtfile
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|fbad
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|ubuffree
argument_list|(
name|zxqtfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbad
condition|)
block|{
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* See if we should spawn a uuxqt process.  */
if|if
condition|(
name|zerr
operator|==
name|NULL
operator|&&
operator|(
name|qtrans
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'E'
operator|||
operator|(
name|qinfo
operator|->
name|fspool
operator|&&
name|qtrans
operator|->
name|s
operator|.
name|zto
index|[
literal|0
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
operator|++
name|qdaemon
operator|->
name|cxfiles_received
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|irunuuxqt
operator|>
literal|0
operator|&&
name|qdaemon
operator|->
name|cxfiles_received
operator|>=
name|qdaemon
operator|->
name|irunuuxqt
condition|)
block|{
if|if
condition|(
name|fspawn_uuxqt
argument_list|(
name|TRUE
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qdaemon
operator|->
name|zconfig
argument_list|)
condition|)
name|qdaemon
operator|->
name|cxfiles_received
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Prepare to send the completion string to the remote system.  If      we have not yet replied to the remote send request, we leave the      transfer structure on the remote queue.  Otherwise we add it to      the send queue.  The psendfn field will already be set.  */
name|qinfo
operator|->
name|fmoved
operator|=
name|zerr
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
name|qinfo
operator|->
name|freplied
condition|)
return|return
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Send the final confirmation string to the remote system.  */
end_comment

begin_function
specifier|static
name|boolean
name|frec_file_send_confirm
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsend
decl_stmt|;
name|int
name|ilocal
decl_stmt|,
name|iremote
decl_stmt|;
if|if
condition|(
operator|!
name|qinfo
operator|->
name|fmoved
condition|)
name|zsend
operator|=
literal|"CN5"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|qdaemon
operator|->
name|frequest_hangup
condition|)
name|zsend
operator|=
literal|"CY"
expr_stmt|;
else|else
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|qdaemon
operator|->
name|fmaster
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"frec_file_send_confirm: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"frec_send_file_confirm: Requesting remote to transfer control"
argument_list|)
expr_stmt|;
name|zsend
operator|=
literal|"CYM"
expr_stmt|;
block|}
comment|/* If that was a remote command, then, when the confirmation message      is acked, we no longer have to remember that we received that      file.  */
if|if
condition|(
operator|!
name|qinfo
operator|->
name|flocal
operator|&&
name|qinfo
operator|->
name|fmoved
condition|)
name|usent_receive_ack
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
expr_stmt|;
name|ilocal
operator|=
name|qtrans
operator|->
name|ilocal
expr_stmt|;
name|iremote
operator|=
name|qtrans
operator|->
name|iremote
expr_stmt|;
name|urrec_free
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
name|zsend
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Discard a temporary file if it is not useful.  A temporary file is    useful if it could be used to restart a receive.  This is called if    the connection is lost.  It is only called if qtrans->frecfile is    TRUE.  */
end_comment

begin_function
name|boolean
name|frec_discard_temp
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
name|struct
name|srecinfo
modifier|*
name|qinfo
init|=
operator|(
expr|struct
name|srecinfo
operator|*
operator|)
name|qtrans
operator|->
name|pinfo
decl_stmt|;
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_RESTART
operator|)
operator|==
literal|0
operator|||
name|qtrans
operator|->
name|s
operator|.
name|ztemp
operator|==
name|NULL
operator|||
name|qtrans
operator|->
name|s
operator|.
name|ztemp
index|[
literal|0
index|]
operator|!=
literal|'D'
operator|||
name|strcmp
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|,
literal|"D.0"
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qinfo
operator|->
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

