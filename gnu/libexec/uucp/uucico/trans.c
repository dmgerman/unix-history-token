begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* trans.c    Routines to handle file transfers.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|trans_rcsid
index|[]
init|=
literal|"$Id: trans.c,v 1.40 1995/08/11 02:43:32 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|utqueue
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|*
operator|,
expr|struct
name|stransfer
operator|*
operator|,
name|boolean
name|fhead
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|utdequeue
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|utchanalc
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
expr|struct
name|stransfer
operator|*
name|qtrans
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__inline__
specifier|static
expr|struct
name|stransfer
operator|*
name|qtchan
name|P
argument_list|(
operator|(
name|int
name|ichan
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|__inline__
specifier|static
name|void
name|utchanfree
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fttime
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|long
operator|*
name|pisecs
operator|,
name|long
operator|*
name|pimicros
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcheck_queue
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftadd_cmd
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|z
operator|,
name|size_t
name|cdata
operator|,
name|int
name|iremote
operator|,
name|boolean
name|flast
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fremote_hangup_reply
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flocal_poll_file
name|P
argument_list|(
operator|(
expr|struct
name|stransfer
operator|*
name|qtrans
operator|,
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Queue of transfer structures that are ready to start which have    been requested by the local system.  These are only permitted to    start when the local system is the master.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|qTlocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of transfer structures that are ready to start which have    been requested by the remote system.  These are responses to    commands received from the remote system, and should be started as    soon as possible.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|qTremote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of transfer structures that have been started and want to    send information.  This should be static, but the 'a' protocol    looks at it, at least for now.  */
end_comment

begin_decl_stmt
name|struct
name|stransfer
modifier|*
name|qTsend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of transfer structures that have been started and are waiting    to receive information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|qTreceive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of free transfer structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|qTavail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of transfer structures indexed by local channel number.  This    is maintained for local jobs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|aqTchan
index|[
name|IMAX_CHAN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of local channel numbers currently allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cTchans
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next channel number to allocate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iTchan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of transfer structures indexed by remote channel number.    This is maintained for remote jobs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|aqTremote
index|[
name|IMAX_CHAN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The transaction we are currently receiving.  This is used to avoid    getting the time too frequently.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stransfer
modifier|*
name|qTtiming_rec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time from which to charge any received data.  This is either    the last time we charged for received data, or the last time    something was put on the empty receive queue.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|iTrecsecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|iTrecmicros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The minimum amount of time, in seconds, to wait between times we    check the spool directory, if we are busy transferring data.  If we    have nothing to do, we will check the spool directory regardless of    how long ago the last check was.  This should probably be    configurable.  */
end_comment

begin_define
define|#
directive|define
name|CCHECKWAIT
value|(600)
end_define

begin_comment
comment|/* The time we last checked the spool directory for work.  This is set    from the return value of ixsysdep_process_time, not ixsysdep_time,    for convenience in the routines which use it.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|iTchecktime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the command we have read so far in ftadd_cmd.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|cTcmdlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The structure we use when waiting for an acknowledgement of a    confirmed received file in fsent_receive_ack, and a list of those    structures.  */
end_comment

begin_struct
struct|struct
name|sreceive_ack
block|{
name|struct
name|sreceive_ack
modifier|*
name|qnext
decl_stmt|;
name|char
modifier|*
name|zto
decl_stmt|;
name|char
modifier|*
name|ztemp
decl_stmt|;
name|boolean
name|fmarked
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sreceive_ack
modifier|*
name|qTreceive_ack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Queue up a transfer structure before *pq.  This puts it at the head    or the tail of the list headed by *pq.  */
end_comment

begin_function
specifier|static
name|void
name|utqueue
parameter_list|(
name|pq
parameter_list|,
name|q
parameter_list|,
name|fhead
parameter_list|)
name|struct
name|stransfer
modifier|*
modifier|*
name|pq
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
name|boolean
name|fhead
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|pq
operator|==
name|NULL
condition|)
block|{
operator|*
name|pq
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|qprev
operator|=
name|q
operator|->
name|qnext
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|qnext
operator|=
operator|*
name|pq
expr_stmt|;
name|q
operator|->
name|qprev
operator|=
operator|(
operator|*
name|pq
operator|)
operator|->
name|qprev
expr_stmt|;
name|q
operator|->
name|qprev
operator|->
name|qnext
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|qnext
operator|->
name|qprev
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|fhead
condition|)
operator|*
name|pq
operator|=
name|q
expr_stmt|;
block|}
name|q
operator|->
name|pqqueue
operator|=
name|pq
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dequeue a transfer structure.  */
end_comment

begin_function
specifier|static
name|void
name|utdequeue
parameter_list|(
name|q
parameter_list|)
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
block|{
if|if
condition|(
name|q
operator|->
name|pqqueue
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|q
operator|->
name|pqqueue
operator|)
operator|==
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|qnext
operator|==
name|q
condition|)
operator|*
operator|(
name|q
operator|->
name|pqqueue
operator|)
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
operator|(
name|q
operator|->
name|pqqueue
operator|)
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
block|}
name|q
operator|->
name|pqqueue
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|qprev
operator|!=
name|NULL
condition|)
name|q
operator|->
name|qprev
operator|->
name|qnext
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|qnext
operator|!=
name|NULL
condition|)
name|q
operator|->
name|qnext
operator|->
name|qprev
operator|=
name|q
operator|->
name|qprev
expr_stmt|;
name|q
operator|->
name|qprev
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Queue up a transfer structure requested by the local system.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
name|boolean
name|fqueue_local
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
name|utdequeue
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
name|utqueue
argument_list|(
operator|&
name|qTlocal
argument_list|,
name|qtrans
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Queue up a transfer structure requested by the remote system.  The    stransfer structure should have the iremote field set.  We need to    record it, so that any subsequent data associated with this    channel can be routed to the right place.  */
end_comment

begin_function
name|boolean
name|fqueue_remote
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fqueue_remote: Channel %d"
argument_list|,
name|qtrans
operator|->
name|iremote
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtrans
operator|->
name|iremote
operator|>
literal|0
condition|)
name|aqTremote
index|[
name|qtrans
operator|->
name|iremote
index|]
operator|=
name|qtrans
expr_stmt|;
name|utdequeue
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
name|utqueue
argument_list|(
operator|&
name|qTremote
argument_list|,
name|qtrans
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Queue up a transfer with something to send.  */
end_comment

begin_function
name|boolean
name|fqueue_send
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|qtrans
operator|->
name|psendfn
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fqueue_send: Bad call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|utdequeue
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
comment|/* Sort the send queue to always send commands before files, and to      sort jobs by grade.  */
if|if
condition|(
name|qTsend
operator|==
name|NULL
condition|)
name|utqueue
argument_list|(
operator|&
name|qTsend
argument_list|,
name|qtrans
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
name|boolean
name|ffirst
decl_stmt|;
name|ffirst
operator|=
name|TRUE
expr_stmt|;
name|q
operator|=
name|qTsend
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|qtrans
operator|->
name|fsendfile
operator|&&
name|q
operator|->
name|fsendfile
condition|)
break|break;
if|if
condition|(
operator|(
operator|!
name|qtrans
operator|->
name|fsendfile
operator|||
name|q
operator|->
name|fsendfile
operator|)
operator|&&
name|UUCONF_GRADE_CMP
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|bgrade
argument_list|,
name|q
operator|->
name|s
operator|.
name|bgrade
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|ffirst
operator|=
name|FALSE
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|qTsend
condition|)
do|;
name|qtrans
operator|->
name|qnext
operator|=
name|q
expr_stmt|;
name|qtrans
operator|->
name|qprev
operator|=
name|q
operator|->
name|qprev
expr_stmt|;
name|q
operator|->
name|qprev
operator|=
name|qtrans
expr_stmt|;
name|qtrans
operator|->
name|qprev
operator|->
name|qnext
operator|=
name|qtrans
expr_stmt|;
if|if
condition|(
name|ffirst
condition|)
name|qTsend
operator|=
name|qtrans
expr_stmt|;
name|qtrans
operator|->
name|pqqueue
operator|=
operator|&
name|qTsend
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Queue up a transfer with something to receive.  */
end_comment

begin_function
name|boolean
name|fqueue_receive
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|qtrans
operator|->
name|precfn
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fqueue_receive: Bad call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is the only item on the receive queue, we do not want to      charge it for any time during which we have not been waiting for      anything, so update the receive timestamp.  */
if|if
condition|(
name|qTreceive
operator|==
name|NULL
condition|)
name|iTrecsecs
operator|=
name|ixsysdep_process_time
argument_list|(
operator|&
name|iTrecmicros
argument_list|)
expr_stmt|;
name|utdequeue
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
name|utqueue
argument_list|(
operator|&
name|qTreceive
argument_list|,
name|qtrans
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get a new local channel number.  */
end_comment

begin_function
specifier|static
name|void
name|utchanalc
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
do|do
block|{
operator|++
name|iTchan
expr_stmt|;
if|if
condition|(
name|iTchan
operator|>
name|qdaemon
operator|->
name|cchans
condition|)
name|iTchan
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|aqTchan
index|[
name|iTchan
index|]
operator|!=
name|NULL
condition|)
do|;
name|qtrans
operator|->
name|ilocal
operator|=
name|iTchan
expr_stmt|;
name|aqTchan
index|[
name|iTchan
index|]
operator|=
name|qtrans
expr_stmt|;
operator|++
name|cTchans
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the transfer for a channel number.  */
end_comment

begin_expr_stmt
name|__inline__
specifier|static
expr|struct
name|stransfer
operator|*
name|qtchan
argument_list|(
argument|ic
argument_list|)
name|int
name|ic
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|aqTchan
index|[
name|ic
index|]
return|;
block|}
end_block

begin_comment
comment|/* Clear the channel number for a transfer.  */
end_comment

begin_function
name|__inline__
specifier|static
name|void
name|utchanfree
parameter_list|(
name|qt
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qt
decl_stmt|;
block|{
if|if
condition|(
name|qt
operator|->
name|ilocal
operator|!=
literal|0
condition|)
block|{
name|aqTchan
index|[
name|qt
operator|->
name|ilocal
index|]
operator|=
name|NULL
expr_stmt|;
name|qt
operator|->
name|ilocal
operator|=
literal|0
expr_stmt|;
operator|--
name|cTchans
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a new transfer structure.  */
end_comment

begin_function
name|struct
name|stransfer
modifier|*
name|qtransalc
parameter_list|(
name|qcmd
parameter_list|)
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
specifier|register
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|qTavail
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|utdequeue
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
operator|(
expr|struct
name|stransfer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stransfer
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|qprev
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|pqqueue
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|psendfn
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|precfn
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|pinfo
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|fsendfile
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|frecfile
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|e
operator|=
name|EFILECLOSED
expr_stmt|;
name|q
operator|->
name|ipos
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|fcmd
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|ccmd
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|ilocal
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|iremote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qcmd
operator|!=
name|NULL
condition|)
block|{
name|q
operator|->
name|s
operator|=
operator|*
name|qcmd
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zfrom
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zto
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zuser
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zoptions
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|ztemp
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|znotify
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|znotify
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zcmd
operator|=
name|zbufcpy
argument_list|(
name|qcmd
operator|->
name|zcmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|s
operator|.
name|zfrom
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zto
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zuser
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zoptions
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|ztemp
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|znotify
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
block|}
name|q
operator|->
name|isecs
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|imicros
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|cbytes
operator|=
literal|0
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free a transfer structure.  This does not free any pinfo    information that may have been allocated.  */
end_comment

begin_function
name|void
name|utransfree
parameter_list|(
name|q
parameter_list|)
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
block|{
name|ubuffree
argument_list|(
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|zoptions
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|znotify
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|s
operator|.
name|zcmd
argument_list|)
expr_stmt|;
name|utchanfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|iremote
operator|>
literal|0
condition|)
block|{
name|aqTremote
index|[
name|q
operator|->
name|iremote
index|]
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|iremote
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
name|q
operator|->
name|e
operator|=
name|EFILECLOSED
expr_stmt|;
name|q
operator|->
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zfrom
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zto
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zuser
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zoptions
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|ztemp
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|znotify
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|psendfn
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|precfn
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* Avoid any possible confusion in the timing code.  */
if|if
condition|(
name|qTtiming_rec
operator|==
name|q
condition|)
name|qTtiming_rec
operator|=
name|NULL
expr_stmt|;
name|utdequeue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|utqueue
argument_list|(
operator|&
name|qTavail
argument_list|,
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the time.  This is a wrapper around ixsysdep_process_time.  If    enough time has elapsed since the last time we got the time, check    the work queue.  */
end_comment

begin_function
specifier|static
name|boolean
name|fttime
parameter_list|(
name|qdaemon
parameter_list|,
name|pisecs
parameter_list|,
name|pimicros
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|long
modifier|*
name|pisecs
decl_stmt|;
name|long
modifier|*
name|pimicros
decl_stmt|;
block|{
operator|*
name|pisecs
operator|=
name|ixsysdep_process_time
argument_list|(
name|pimicros
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pisecs
operator|-
name|iTchecktime
operator|>=
name|CCHECKWAIT
condition|)
block|{
if|if
condition|(
operator|!
name|fcheck_queue
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Gather local commands and queue them up for later processing.  Also    recompute time based control values.  */
end_comment

begin_function
name|boolean
name|fqueue
parameter_list|(
name|qdaemon
parameter_list|,
name|pfany
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
modifier|*
name|pfany
decl_stmt|;
block|{
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|struct
name|uuconf_timespan
modifier|*
name|qlocal_size
decl_stmt|,
modifier|*
name|qremote_size
decl_stmt|;
if|if
condition|(
name|pfany
operator|!=
name|NULL
condition|)
operator|*
name|pfany
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|=
name|qdaemon
operator|->
name|qsys
expr_stmt|;
comment|/* If we are not the caller, the grade will be set during the      initial handshake, although this may be overridden by the      calledtimegrade configuration option.  */
if|if
condition|(
operator|!
name|qdaemon
operator|->
name|fcaller
condition|)
block|{
if|if
condition|(
operator|!
name|ftimespan_match
argument_list|(
name|qsys
operator|->
name|uuconf_qcalledtimegrade
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|bgrade
operator|=
name|qdaemon
operator|->
name|bgrade
expr_stmt|;
else|else
name|bgrade
operator|=
operator|(
name|char
operator|)
name|ival
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ftimespan_match
argument_list|(
name|qsys
operator|->
name|uuconf_qtimegrade
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|bgrade
operator|=
literal|'\0'
expr_stmt|;
else|else
name|bgrade
operator|=
operator|(
name|char
operator|)
name|ival
expr_stmt|;
block|}
comment|/* Determine the maximum sizes we can send and receive.  */
if|if
condition|(
name|qdaemon
operator|->
name|fcaller
condition|)
block|{
name|qlocal_size
operator|=
name|qsys
operator|->
name|uuconf_qcall_local_size
expr_stmt|;
name|qremote_size
operator|=
name|qsys
operator|->
name|uuconf_qcall_remote_size
expr_stmt|;
block|}
else|else
block|{
name|qlocal_size
operator|=
name|qsys
operator|->
name|uuconf_qcalled_local_size
expr_stmt|;
name|qremote_size
operator|=
name|qsys
operator|->
name|uuconf_qcalled_remote_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ftimespan_match
argument_list|(
name|qlocal_size
argument_list|,
operator|&
name|qdaemon
operator|->
name|clocal_size
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|qdaemon
operator|->
name|clocal_size
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ftimespan_match
argument_list|(
name|qremote_size
argument_list|,
operator|&
name|qdaemon
operator|->
name|cremote_size
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|qdaemon
operator|->
name|cremote_size
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bgrade
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|fsysdep_get_work_init
argument_list|(
name|qsys
argument_list|,
name|bgrade
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_work
argument_list|(
name|qsys
argument_list|,
name|bgrade
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s
operator|.
name|bcmd
operator|==
literal|'H'
condition|)
block|{
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|.
name|bcmd
operator|==
literal|'P'
condition|)
block|{
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
comment|/* A poll file.  */
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|qtrans
operator|=
name|qtransalc
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|qtrans
operator|->
name|psendfn
operator|=
name|flocal_poll_file
expr_stmt|;
if|if
condition|(
operator|!
name|fqueue_local
argument_list|(
name|qdaemon
argument_list|,
name|qtrans
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
name|ulog_user
argument_list|(
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|.
name|bcmd
condition|)
block|{
case|case
literal|'S'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|flocal_send_file_init
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|flocal_rec_file_init
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
operator|!
name|flocal_xcmd_init
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|0
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fqueue: Can't happen"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|pfany
operator|!=
name|NULL
condition|)
operator|*
name|pfany
operator|=
name|qTlocal
operator|!=
name|NULL
expr_stmt|;
name|iTchecktime
operator|=
name|ixsysdep_process_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Clear everything off the work queue.  This is used when the call is    complete, or if the call is never made.  */
end_comment

begin_function
name|void
name|uclear_queue
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|usysdep_get_work_free
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|)
expr_stmt|;
name|qTlocal
operator|=
name|NULL
expr_stmt|;
name|qTremote
operator|=
name|NULL
expr_stmt|;
name|qTsend
operator|=
name|NULL
expr_stmt|;
name|qTreceive
operator|=
name|NULL
expr_stmt|;
name|cTchans
operator|=
literal|0
expr_stmt|;
name|iTchan
operator|=
literal|0
expr_stmt|;
name|qTtiming_rec
operator|=
name|NULL
expr_stmt|;
name|cTcmdlen
operator|=
literal|0
expr_stmt|;
name|qTreceive_ack
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IMAX_CHAN
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|aqTchan
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|aqTremote
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Recheck the work queue during a conversation.  This is only called    if it's been more than CCHECKWAIT seconds since the last time the    queue was checked.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcheck_queue
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
comment|/* Only check if we are the master, or if there are multiple      channels, or if we aren't already trying to get the other side to      hang up.  Otherwise, there's nothing we can do with any new jobs      we might find.  */
if|if
condition|(
name|qdaemon
operator|->
name|fmaster
operator|||
name|qdaemon
operator|->
name|cchans
operator|>
literal|1
operator|||
operator|!
name|qdaemon
operator|->
name|frequest_hangup
condition|)
block|{
name|boolean
name|fany
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fcheck_queue: Rechecking work queue"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fqueue
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|fany
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we found something to do, and we're not the master, and we 	 don't have multiple channels to send new jobs over, try to 	 get the other side to hang up.  */
if|if
condition|(
name|fany
operator|&&
operator|!
name|qdaemon
operator|->
name|fmaster
operator|&&
name|qdaemon
operator|->
name|cchans
operator|<=
literal|1
condition|)
name|qdaemon
operator|->
name|frequest_hangup
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The main transfer loop.  The uucico daemon spends essentially all    its time in this function.  */
end_comment

begin_function
name|boolean
name|floop
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|qdaemon
operator|->
name|fhangup
condition|)
block|{
specifier|register
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* If we're doing any debugging, close the log and debugging 	 files regularly.  This will let people copy them off and 	 remove them while the conversation is in progresss.  */
if|if
condition|(
name|iDebug
operator|!=
literal|0
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|qdaemon
operator|->
name|fmaster
condition|)
block|{
name|boolean
name|fhangup
decl_stmt|;
comment|/* We've managed to become the master, so we no longer want 	     to request a hangup.  */
name|qdaemon
operator|->
name|frequest_hangup
operator|=
name|FALSE
expr_stmt|;
name|fhangup
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|qdaemon
operator|->
name|fhangup_requested
operator|&&
name|qTsend
operator|==
name|NULL
condition|)
block|{
comment|/* The remote system has requested that we transfer 		 control by sending CYM after receiving a file.  */
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"floop: Transferring control at remote request"
argument_list|)
expr_stmt|;
name|fhangup
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qTremote
operator|==
name|NULL
operator|&&
name|qTlocal
operator|==
name|NULL
operator|&&
name|qTsend
operator|==
name|NULL
operator|&&
name|qTreceive
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have anything to do.  Try to find some new 		 jobs.  If we can't, transfer control.  */
if|if
condition|(
operator|!
name|fqueue
argument_list|(
name|qdaemon
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|qTlocal
operator|==
name|NULL
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"floop: No work for master"
argument_list|)
expr_stmt|;
name|fhangup
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fhangup
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
literal|"H"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|qdaemon
operator|->
name|fmaster
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* If we are no long the master, clear any requested hangup.  We 	 may have already hung up before checking this variable in the 	 block above.  */
if|if
condition|(
operator|!
name|qdaemon
operator|->
name|fmaster
condition|)
name|qdaemon
operator|->
name|fhangup_requested
operator|=
name|FALSE
expr_stmt|;
comment|/* Immediately queue up any remote jobs.  We don't need local 	 channel numbers for them, since we can disambiguate based on 	 the remote channel number.  */
while|while
condition|(
name|qTremote
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|qTremote
expr_stmt|;
name|utdequeue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|utqueue
argument_list|(
operator|&
name|qTsend
argument_list|,
name|q
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* If we are the master, or if we have multiple channels, try to 	 queue up additional local jobs.  */
if|if
condition|(
name|qdaemon
operator|->
name|fmaster
operator|||
name|qdaemon
operator|->
name|cchans
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|qTlocal
operator|!=
name|NULL
operator|&&
name|cTchans
operator|<
name|qdaemon
operator|->
name|cchans
condition|)
block|{
comment|/* We have room for an additional channel.  */
name|q
operator|=
name|qTlocal
expr_stmt|;
if|if
condition|(
operator|!
name|fqueue_send
argument_list|(
name|qdaemon
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|utchanalc
argument_list|(
name|qdaemon
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fret
condition|)
break|break;
block|}
name|q
operator|=
name|qTsend
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"floop: Waiting for data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfwait
call|)
argument_list|(
name|qdaemon
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ulog_user
argument_list|(
name|q
operator|->
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|fsendfile
condition|)
block|{
comment|/* Technically, we should add the time required for this                  call to q->isecs and q->imicros.  In practice, the                  amount of time required should be sufficiently small                  that it can be safely disregarded.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|q
operator|->
name|psendfn
call|)
argument_list|(
name|q
argument_list|,
name|qdaemon
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
name|boolean
name|fcharged
decl_stmt|;
name|long
name|inextsecs
init|=
literal|0
decl_stmt|,
name|inextmicros
decl_stmt|;
if|if
condition|(
operator|!
name|fttime
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|isecs
argument_list|,
operator|&
name|imicros
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|fcharged
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|zlog
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"%s"
argument_list|,
name|q
operator|->
name|zlog
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|q
operator|->
name|zlog
argument_list|)
expr_stmt|;
name|q
operator|->
name|zlog
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We can read the file in a tight loop until we have a 		 command to send, or the file send has been cancelled, 		 or we have a remote job to deal with.  We can 		 disregard any changes to qTlocal since we already 		 have something to send anyhow.  */
while|while
condition|(
name|q
operator|==
name|qTsend
operator|&&
name|q
operator|->
name|fsendfile
operator|&&
name|qTremote
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|long
name|ipos
decl_stmt|;
name|zdata
operator|=
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pzgetspace
call|)
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ffileeof
argument_list|(
name|q
operator|->
name|e
argument_list|)
condition|)
name|cdata
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cdata
operator|=
name|cfileread
argument_list|(
name|q
operator|->
name|e
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffileioerror
argument_list|(
name|q
operator|->
name|e
argument_list|,
name|cdata
argument_list|)
condition|)
block|{
comment|/* There is no way to report a file reading 			     error, so we just drop the connection.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
name|ipos
operator|=
name|q
operator|->
name|ipos
expr_stmt|;
name|q
operator|->
name|ipos
operator|+=
name|cdata
expr_stmt|;
name|q
operator|->
name|cbytes
operator|+=
name|cdata
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsenddata
call|)
argument_list|(
name|qdaemon
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|,
name|q
operator|->
name|ilocal
argument_list|,
name|q
operator|->
name|iremote
argument_list|,
name|ipos
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cdata
operator|==
literal|0
condition|)
block|{
comment|/* We must update the time now, because this 			 call may make an entry in the statistics 			 file.  */
name|inextsecs
operator|=
name|ixsysdep_process_time
argument_list|(
operator|&
name|inextmicros
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"floop: Charging %ld to %c %s %s"
argument_list|,
operator|(
operator|(
name|inextsecs
operator|-
name|isecs
operator|)
operator|*
literal|1000000
operator|+
name|inextmicros
operator|-
name|imicros
operator|)
argument_list|,
name|q
operator|->
name|s
operator|.
name|bcmd
argument_list|,
name|q
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|q
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|q
operator|->
name|isecs
operator|+=
name|inextsecs
operator|-
name|isecs
expr_stmt|;
name|q
operator|->
name|imicros
operator|+=
name|inextmicros
operator|-
name|imicros
expr_stmt|;
name|fcharged
operator|=
name|TRUE
expr_stmt|;
name|q
operator|->
name|fsendfile
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|q
operator|->
name|psendfn
call|)
argument_list|(
name|q
argument_list|,
name|qdaemon
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fret
condition|)
break|break;
if|if
condition|(
operator|!
name|fcharged
condition|)
block|{
name|inextsecs
operator|=
name|ixsysdep_process_time
argument_list|(
operator|&
name|inextmicros
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"floop: Charging %ld to %c %s %s"
argument_list|,
operator|(
operator|(
name|inextsecs
operator|-
name|isecs
operator|)
operator|*
literal|1000000
operator|+
name|inextmicros
operator|-
name|imicros
operator|)
argument_list|,
name|q
operator|->
name|s
operator|.
name|bcmd
argument_list|,
name|q
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|q
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|q
operator|->
name|isecs
operator|+=
name|inextsecs
operator|-
name|isecs
expr_stmt|;
name|q
operator|->
name|imicros
operator|+=
name|inextmicros
operator|-
name|imicros
expr_stmt|;
block|}
if|if
condition|(
name|inextsecs
operator|-
name|iTchecktime
operator|>=
name|CCHECKWAIT
condition|)
block|{
if|if
condition|(
operator|!
name|fcheck_queue
argument_list|(
name|qdaemon
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfshutdown
argument_list|)
argument_list|(
name|qdaemon
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
name|uwindow_acked
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|ufailed
argument_list|(
name|qdaemon
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called by the protocol routines when they have received    some data.  If pfexit is not NULL, *pfexit should be set to TRUE if    the protocol receive loop should exit back to the main floop    routine, above.  It is only important to set *pfexit to TRUE if the    main loop called the pfwait entry point, so we need never set it to    TRUE if we just receive data for a file.  This routine never sets    *pfexit to FALSE.  */
end_comment

begin_function
name|boolean
name|fgot_data
parameter_list|(
name|qdaemon
parameter_list|,
name|zfirst
parameter_list|,
name|cfirst
parameter_list|,
name|zsecond
parameter_list|,
name|csecond
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|,
name|fallacked
parameter_list|,
name|pfexit
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfirst
decl_stmt|;
name|size_t
name|cfirst
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsecond
decl_stmt|;
name|size_t
name|csecond
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
name|boolean
name|fallacked
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
block|{
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
name|int
name|cwrote
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
if|if
condition|(
name|fallacked
operator|&&
name|qTreceive_ack
operator|!=
name|NULL
condition|)
name|uwindow_acked
argument_list|(
name|qdaemon
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Now we have to decide which transfer structure gets the data.  If      ilocal is -1, it means that the protocol does not know where to      route the data.  In that case we route it to the first transfer      that is waiting for data, or, if none, as a new command.  If      ilocal is 0, we either select based on the remote channel number      or we have a new command.  */
if|if
condition|(
name|ilocal
operator|==
operator|-
literal|1
operator|&&
name|qTreceive
operator|!=
name|NULL
condition|)
name|q
operator|=
name|qTreceive
expr_stmt|;
elseif|else
if|if
condition|(
name|ilocal
operator|==
literal|0
operator|&&
name|iremote
operator|>
literal|0
operator|&&
name|aqTremote
index|[
name|iremote
index|]
operator|!=
name|NULL
condition|)
name|q
operator|=
name|aqTremote
index|[
name|iremote
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ilocal
operator|<=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|znull
decl_stmt|;
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* This data is part of a command.  If there is no null 	 character in the data, this string will be continued by the 	 next packet.  Otherwise this must be the last string in the 	 command, and we don't care about what comes after the null 	 byte.  */
name|znull
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|zfirst
argument_list|,
literal|'\0'
argument_list|,
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|znull
operator|!=
name|NULL
condition|)
name|fret
operator|=
name|ftadd_cmd
argument_list|(
name|qdaemon
argument_list|,
name|zfirst
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|znull
operator|-
name|zfirst
argument_list|)
argument_list|,
name|iremote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
name|fret
operator|=
name|ftadd_cmd
argument_list|(
name|qdaemon
argument_list|,
name|zfirst
argument_list|,
name|cfirst
argument_list|,
name|iremote
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
operator|&&
name|csecond
operator|>
literal|0
condition|)
block|{
name|znull
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|zsecond
argument_list|,
literal|'\0'
argument_list|,
name|csecond
argument_list|)
expr_stmt|;
if|if
condition|(
name|znull
operator|!=
name|NULL
condition|)
name|fret
operator|=
name|ftadd_cmd
argument_list|(
name|qdaemon
argument_list|,
name|zsecond
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|znull
operator|-
name|zsecond
argument_list|)
argument_list|,
name|iremote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|fret
operator|=
name|ftadd_cmd
argument_list|(
name|qdaemon
argument_list|,
name|zsecond
argument_list|,
name|csecond
argument_list|,
name|iremote
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pfexit
operator|!=
name|NULL
operator|&&
operator|(
name|qdaemon
operator|->
name|fhangup
operator|||
name|qTremote
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
comment|/* Time spent waiting for a new command is not charged to          anybody.  */
if|if
condition|(
operator|!
name|fttime
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|iTrecsecs
argument_list|,
operator|&
name|iTrecmicros
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
return|return
name|fret
return|;
block|}
else|else
block|{
comment|/* Get the transfer structure this data is intended for.  */
name|q
operator|=
name|qtchan
argument_list|(
name|ilocal
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|q
operator|==
name|NULL
operator|||
name|q
operator|->
name|precfn
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Protocol error: %lu bytes remote %d local %d"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|cfirst
operator|+
name|csecond
argument_list|)
argument_list|,
name|iremote
argument_list|,
name|ilocal
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
name|ulog_user
argument_list|(
name|q
operator|->
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|zlog
operator|!=
name|NULL
operator|&&
operator|!
name|q
operator|->
name|fsendfile
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"%s"
argument_list|,
name|q
operator|->
name|zlog
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|q
operator|->
name|zlog
argument_list|)
expr_stmt|;
name|q
operator|->
name|zlog
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cfirst
operator|==
literal|0
operator|||
name|q
operator|->
name|fcmd
operator|||
operator|!
name|q
operator|->
name|frecfile
operator|||
name|q
operator|!=
name|qTtiming_rec
condition|)
block|{
name|struct
name|stransfer
modifier|*
name|qcharge
decl_stmt|;
comment|/* Either we are receiving some sort of command, or we are          receiving data for a transfer other than the one we are          currently timing.  It we are currently timing a transfer,          charge any accumulated time to it.  Otherwise, if we          currently have something to send, just forget about the          accumulated time (when using a bidirectional protocol, it's          very difficult to charge this time correctly).  Otherwise,          charge it to whatever transfer receives it.  */
if|if
condition|(
operator|!
name|fttime
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|isecs
argument_list|,
operator|&
name|imicros
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|qTtiming_rec
operator|!=
name|NULL
condition|)
name|qcharge
operator|=
name|qTtiming_rec
expr_stmt|;
elseif|else
if|if
condition|(
name|qTsend
operator|!=
name|NULL
condition|)
name|qcharge
operator|=
name|NULL
expr_stmt|;
else|else
name|qcharge
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|qcharge
operator|!=
name|NULL
condition|)
block|{
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fgot_data: Charging %ld to %c %s %s"
argument_list|,
operator|(
operator|(
name|isecs
operator|-
name|iTrecsecs
operator|)
operator|*
literal|1000000
operator|+
name|imicros
operator|-
name|iTrecmicros
operator|)
argument_list|,
name|qcharge
operator|->
name|s
operator|.
name|bcmd
argument_list|,
name|qcharge
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qcharge
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|qcharge
operator|->
name|isecs
operator|+=
name|isecs
operator|-
name|iTrecsecs
expr_stmt|;
name|qcharge
operator|->
name|imicros
operator|+=
name|imicros
operator|-
name|iTrecmicros
expr_stmt|;
block|}
name|iTrecsecs
operator|=
name|isecs
expr_stmt|;
name|iTrecmicros
operator|=
name|imicros
expr_stmt|;
comment|/* If we received file data, start timing the new transfer.  */
if|if
condition|(
name|cfirst
operator|==
literal|0
operator|||
name|q
operator|->
name|fcmd
operator|||
operator|!
name|q
operator|->
name|frecfile
condition|)
name|qTtiming_rec
operator|=
name|NULL
expr_stmt|;
else|else
name|qTtiming_rec
operator|=
name|q
expr_stmt|;
block|}
comment|/* If we're receiving a command, then accumulate it up to the null      byte.  */
if|if
condition|(
name|q
operator|->
name|fcmd
condition|)
block|{
specifier|const
name|char
modifier|*
name|znull
decl_stmt|;
name|znull
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cfirst
operator|>
literal|0
condition|)
block|{
name|size_t
name|cnew
decl_stmt|;
name|char
modifier|*
name|znew
decl_stmt|;
name|znull
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|zfirst
argument_list|,
literal|'\0'
argument_list|,
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|znull
operator|!=
name|NULL
condition|)
name|cnew
operator|=
name|znull
operator|-
name|zfirst
expr_stmt|;
else|else
name|cnew
operator|=
name|cfirst
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|q
operator|->
name|ccmd
operator|+
name|cnew
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|ccmd
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|znew
argument_list|,
name|q
operator|->
name|zcmd
argument_list|,
name|q
operator|->
name|ccmd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|znew
operator|+
name|q
operator|->
name|ccmd
argument_list|,
name|zfirst
argument_list|,
name|cnew
argument_list|)
expr_stmt|;
name|znew
index|[
name|q
operator|->
name|ccmd
operator|+
name|cnew
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ubuffree
argument_list|(
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
name|q
operator|->
name|zcmd
operator|=
name|znew
expr_stmt|;
name|q
operator|->
name|ccmd
operator|+=
name|cnew
expr_stmt|;
if|if
condition|(
name|znull
operator|!=
name|NULL
condition|)
break|break;
name|zfirst
operator|=
name|zsecond
expr_stmt|;
name|cfirst
operator|=
name|csecond
expr_stmt|;
name|csecond
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|znull
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zcmd
decl_stmt|;
name|size_t
name|ccmd
decl_stmt|;
name|zcmd
operator|=
name|q
operator|->
name|zcmd
expr_stmt|;
name|ccmd
operator|=
name|q
operator|->
name|ccmd
expr_stmt|;
name|q
operator|->
name|fcmd
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|ccmd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|q
operator|->
name|precfn
call|)
argument_list|(
name|q
argument_list|,
name|qdaemon
argument_list|,
name|zcmd
argument_list|,
name|ccmd
operator|+
literal|1
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
name|ubuffree
argument_list|(
name|zcmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfexit
operator|!=
name|NULL
operator|&&
operator|(
name|qdaemon
operator|->
name|fhangup
operator|||
name|qdaemon
operator|->
name|fmaster
operator|||
name|qTsend
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|q
operator|->
name|frecfile
operator|||
name|cfirst
operator|==
literal|0
condition|)
block|{
comment|/* We're either not receiving a file or the file transfer is 	 complete.  */
name|q
operator|->
name|frecfile
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|q
operator|->
name|precfn
call|)
argument_list|(
name|q
argument_list|,
name|qdaemon
argument_list|,
name|zfirst
argument_list|,
name|cfirst
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fret
operator|&&
name|csecond
operator|>
literal|0
condition|)
return|return
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zsecond
argument_list|,
name|csecond
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|,
name|ipos
operator|+
operator|(
name|long
operator|)
name|cfirst
argument_list|,
name|FALSE
argument_list|,
name|pfexit
argument_list|)
return|;
if|if
condition|(
name|pfexit
operator|!=
name|NULL
operator|&&
operator|(
name|qdaemon
operator|->
name|fhangup
operator|||
name|qdaemon
operator|->
name|fmaster
operator|||
name|qTsend
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ipos
operator|!=
operator|-
literal|1
operator|&&
name|ipos
operator|!=
name|q
operator|->
name|ipos
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fgot_data: Seeking to %ld"
argument_list|,
name|ipos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileseek
argument_list|(
name|q
operator|->
name|e
argument_list|,
name|ipos
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"seek: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|q
operator|->
name|ipos
operator|=
name|ipos
expr_stmt|;
block|}
if|if
condition|(
name|fret
condition|)
block|{
while|while
condition|(
name|cfirst
operator|>
literal|0
condition|)
block|{
name|cwrote
operator|=
name|cfilewrite
argument_list|(
name|q
operator|->
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zfirst
argument_list|,
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrote
operator|==
name|cfirst
condition|)
block|{
if|#
directive|if
name|FREE_SPACE_DELTA
operator|>
literal|0
name|long
name|cfree_space
decl_stmt|;
comment|/* Check that there is still enough space on the 		     disk.  If there isn't, we drop the connection, 		     because we have no way to abort a file transfer 		     in progress.  */
name|cfree_space
operator|=
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_cfree_space
expr_stmt|;
if|if
condition|(
name|cfree_space
operator|>
literal|0
operator|&&
operator|(
operator|(
name|q
operator|->
name|cbytes
operator|/
name|FREE_SPACE_DELTA
operator|)
operator|!=
operator|(
name|q
operator|->
name|cbytes
operator|+
name|cfirst
operator|)
operator|/
name|FREE_SPACE_DELTA
operator|)
operator|&&
operator|!
name|frec_check_free
argument_list|(
name|q
argument_list|,
name|cfree_space
argument_list|)
condition|)
block|{
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|q
operator|->
name|cbytes
operator|+=
name|cfirst
expr_stmt|;
name|q
operator|->
name|ipos
operator|+=
name|cfirst
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffileioerror
argument_list|(
name|q
operator|->
name|e
argument_list|,
name|cwrote
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Wrote %d to file when trying to write %lu"
argument_list|,
name|cwrote
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cfirst
argument_list|)
expr_stmt|;
comment|/* Any write error is almost certainly a temporary 		     condition, or else UUCP would not be functioning 		     at all.  If we continue to accept the file, we 		     will wind up rejecting it at the end (what else 		     could we do?)  and the remote system will throw 		     away the request.  We're better off just dropping 		     the connection, which is what happens when we 		     return FALSE, and trying again later.  */
name|fret
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|zfirst
operator|=
name|zsecond
expr_stmt|;
name|cfirst
operator|=
name|csecond
expr_stmt|;
name|csecond
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pfexit
operator|!=
name|NULL
operator|&&
name|qdaemon
operator|->
name|fhangup
condition|)
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Accumulate a string into a command.  If the command is complete,    start up a new transfer.  */
end_comment

begin_function
specifier|static
name|boolean
name|ftadd_cmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|clen
parameter_list|,
name|iremote
parameter_list|,
name|flast
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|boolean
name|flast
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|zbuf
decl_stmt|;
specifier|static
name|size_t
name|cbuf
decl_stmt|;
name|size_t
name|cneed
decl_stmt|;
name|struct
name|scmd
name|s
decl_stmt|;
name|cneed
operator|=
name|cTcmdlen
operator|+
name|clen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cneed
operator|>
name|cbuf
condition|)
block|{
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|,
name|cneed
argument_list|)
expr_stmt|;
name|cbuf
operator|=
name|cneed
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zbuf
operator|+
name|cTcmdlen
argument_list|,
name|z
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zbuf
index|[
name|cTcmdlen
operator|+
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|flast
condition|)
block|{
name|cTcmdlen
operator|+=
name|clen
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Don't save this string for next time.  */
name|cTcmdlen
operator|=
literal|0
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"ftadd_cmd: Got command \"%s\""
argument_list|,
name|zbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fparse_cmd
argument_list|(
name|zbuf
argument_list|,
operator|&
name|s
argument_list|)
operator|||
name|s
operator|.
name|bcmd
operator|==
literal|'P'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Received garbled command \"%s\""
argument_list|,
name|zbuf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Some systems seem to sometimes send garbage at the end of the      command.  Avoid interpreting it as a size if sizes are not      supported.  */
if|if
condition|(
operator|(
name|qdaemon
operator|->
name|ifeatures
operator|&
name|FEATURE_SIZES
operator|)
operator|==
literal|0
condition|)
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|bcmd
operator|!=
literal|'H'
operator|&&
name|s
operator|.
name|bcmd
operator|!=
literal|'Y'
operator|&&
name|s
operator|.
name|bcmd
operator|!=
literal|'N'
condition|)
name|ulog_user
argument_list|(
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
else|else
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|.
name|bcmd
condition|)
block|{
case|case
literal|'S'
case|:
case|case
literal|'E'
case|:
return|return
name|fremote_send_file_init
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|s
argument_list|,
name|iremote
argument_list|)
return|;
case|case
literal|'R'
case|:
return|return
name|fremote_rec_file_init
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|s
argument_list|,
name|iremote
argument_list|)
return|;
case|case
literal|'X'
case|:
return|return
name|fremote_xcmd_init
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|s
argument_list|,
name|iremote
argument_list|)
return|;
case|case
literal|'H'
case|:
comment|/* This is a remote request for a hangup.  We close the log 	 files so that they may be moved at this point.  */
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
block|{
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|qtransalc
argument_list|(
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|psendfn
operator|=
name|fremote_hangup_reply
expr_stmt|;
name|q
operator|->
name|iremote
operator|=
name|iremote
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|bcmd
operator|=
literal|'H'
expr_stmt|;
return|return
name|fqueue_remote
argument_list|(
name|qdaemon
argument_list|,
name|q
argument_list|)
return|;
block|}
case|case
literal|'N'
case|:
comment|/* This means a hangup request is being denied; we just ignore 	 this and wait for further commands.  */
return|return
name|TRUE
return|;
case|case
literal|'Y'
case|:
comment|/* This is a remote confirmation of a hangup.  We reconfirm.  */
if|if
condition|(
name|qdaemon
operator|->
name|fhangup
condition|)
return|return
name|TRUE
return|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|qdaemon
operator|->
name|fmaster
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got hangup reply as master"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't check errors rigorously here, since the other side 	 might jump the gun and hang up.  The fLog_sighup variable 	 will get set TRUE again when the port is closed.  */
name|fLog_sighup
operator|=
name|FALSE
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
argument_list|)
argument_list|(
name|qdaemon
argument_list|,
literal|"HY"
argument_list|,
literal|0
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
name|qdaemon
operator|->
name|fhangup
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"ftadd_cmd: Can't happen"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The remote system is requesting a hang up.  If we have something to    do, send an HN.  Otherwise send two HY commands (the other side is    presumed to send an HY command between the first and second, but we    don't bother to wait for it) and hang up.  */
end_comment

begin_function
specifier|static
name|boolean
name|fremote_hangup_reply
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
if|if
condition|(
name|qTremote
operator|==
name|NULL
operator|&&
name|qTlocal
operator|==
name|NULL
operator|&&
name|qTsend
operator|==
name|NULL
operator|&&
name|qTreceive
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fqueue
argument_list|(
name|qdaemon
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|qTlocal
operator|==
name|NULL
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fremote_hangup_reply: No work"
argument_list|)
expr_stmt|;
name|fret
operator|=
operator|(
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
literal|"HY"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&&
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
literal|"HY"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|qdaemon
operator|->
name|fhangup
operator|=
name|TRUE
expr_stmt|;
return|return
name|fret
return|;
block|}
block|}
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fremote_hangup_reply: Found work"
argument_list|)
expr_stmt|;
name|fret
operator|=
call|(
modifier|*
name|qdaemon
operator|->
name|qproto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|qdaemon
argument_list|,
literal|"HN"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qdaemon
operator|->
name|fmaster
operator|=
name|TRUE
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* As described in system.h, we need to keep track of which files have    been successfully received for which we do not know that the other    system has received our acknowledgement.  This routine is called to    keep a list of such files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sreceive_ack
modifier|*
name|qTfree_receive_ack
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usent_receive_ack
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
block|{
name|struct
name|sreceive_ack
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|qTfree_receive_ack
operator|==
name|NULL
condition|)
name|q
operator|=
operator|(
expr|struct
name|sreceive_ack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sreceive_ack
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|q
operator|=
name|qTfree_receive_ack
expr_stmt|;
name|qTfree_receive_ack
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
block|}
name|q
operator|->
name|qnext
operator|=
name|qTreceive_ack
expr_stmt|;
name|q
operator|->
name|zto
operator|=
name|zbufcpy
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
name|q
operator|->
name|ztemp
operator|=
name|zbufcpy
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
name|q
operator|->
name|fmarked
operator|=
name|FALSE
expr_stmt|;
name|qTreceive_ack
operator|=
name|q
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is called by the protocol code when either all    outstanding data has been acknowledged or one complete window has    passed.  It may be called directly by the protocol, or it may be    called via fgot_data.  If one complete window has passed, then all    unmarked receives are marked, and we know that all marked ones have    been acked.  */
end_comment

begin_function
name|void
name|uwindow_acked
parameter_list|(
name|qdaemon
parameter_list|,
name|fallacked
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
name|fallacked
decl_stmt|;
block|{
specifier|register
name|struct
name|sreceive_ack
modifier|*
modifier|*
name|pq
decl_stmt|;
name|pq
operator|=
operator|&
name|qTreceive_ack
expr_stmt|;
while|while
condition|(
operator|*
name|pq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fallacked
operator|||
operator|(
operator|*
name|pq
operator|)
operator|->
name|fmarked
condition|)
block|{
name|struct
name|sreceive_ack
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|*
name|pq
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_forget_reception
argument_list|(
name|qdaemon
operator|->
name|qsys
argument_list|,
name|q
operator|->
name|zto
argument_list|,
name|q
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|q
operator|->
name|zto
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|q
operator|->
name|ztemp
argument_list|)
expr_stmt|;
operator|*
name|pq
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|qTfree_receive_ack
expr_stmt|;
name|qTfree_receive_ack
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|fmarked
operator|=
name|TRUE
expr_stmt|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine is called when an error occurred and we are crashing    out of the connection.  It is used to report statistics on failed    transfers to the statistics file, and it also discards useless    temporary files for file receptions.  Note that the number of bytes    we report as having been sent has little or nothing to do with the    number of bytes the remote site actually received.  */
end_comment

begin_function
name|void
name|ufailed
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
specifier|register
name|struct
name|stransfer
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|qTsend
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|qTsend
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|fsendfile
operator|||
name|q
operator|->
name|frecfile
operator|)
operator|&&
name|q
operator|->
name|cbytes
operator|>
literal|0
condition|)
block|{
name|ustats
argument_list|(
name|FALSE
argument_list|,
name|q
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|q
operator|->
name|fsendfile
argument_list|,
name|q
operator|->
name|cbytes
argument_list|,
name|q
operator|->
name|isecs
argument_list|,
name|q
operator|->
name|imicros
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|fsendfile
condition|)
name|qdaemon
operator|->
name|csent
operator|+=
name|q
operator|->
name|cbytes
expr_stmt|;
else|else
name|qdaemon
operator|->
name|creceived
operator|+=
name|q
operator|->
name|cbytes
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|frecfile
condition|)
operator|(
name|void
operator|)
name|frec_discard_temp
argument_list|(
name|qdaemon
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|qTsend
condition|)
do|;
block|}
if|if
condition|(
name|qTreceive
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|qTreceive
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|fsendfile
operator|||
name|q
operator|->
name|frecfile
operator|)
operator|&&
name|q
operator|->
name|cbytes
operator|>
literal|0
condition|)
block|{
name|ustats
argument_list|(
name|FALSE
argument_list|,
name|q
operator|->
name|s
operator|.
name|zuser
argument_list|,
name|qdaemon
operator|->
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|q
operator|->
name|fsendfile
argument_list|,
name|q
operator|->
name|cbytes
argument_list|,
name|q
operator|->
name|isecs
argument_list|,
name|q
operator|->
name|imicros
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|fsendfile
condition|)
name|qdaemon
operator|->
name|csent
operator|+=
name|q
operator|->
name|cbytes
expr_stmt|;
else|else
name|qdaemon
operator|->
name|creceived
operator|+=
name|q
operator|->
name|cbytes
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|frecfile
condition|)
operator|(
name|void
operator|)
name|frec_discard_temp
argument_list|(
name|qdaemon
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|qTreceive
condition|)
do|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When a local poll file is found, it is entered on the queue like    any other job.  When it is pulled off the queue, this function is    called.  It just calls fsysdep_did_work, which will remove the poll    file.  This ensures that poll files are only removed if the system    is actually called.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|flocal_poll_file
parameter_list|(
name|qtrans
parameter_list|,
name|qdaemon
parameter_list|)
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|fret
operator|=
name|fsysdep_did_work
argument_list|(
name|qtrans
operator|->
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
name|utransfree
argument_list|(
name|qtrans
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

end_unit

