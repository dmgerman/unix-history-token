begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* proti.c    The 'i' protocol.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|proti_rcsid
index|[]
init|=
literal|"$Id: proti.c,v 1.33 1995/06/21 19:15:28 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The 'i' protocol is a simple sliding window protocol, created by    me.  It is in many ways similar to the 'g' protocol.  Several ideas    are also taken from the paper ``A High-Throughput Message Transport    System'' by P. Lauder.  I don't know where the paper was published,    but the author's e-mail address is piers@cs.su.oz.au.  However, I    haven't adopted his main idea, which is to dispense with windows    entirely.  This is because some links still do require flow control    and, more importantly, because I want to have a limit to the amount    of data I must be able to resend upon request.  To reduce the costs    of window acknowledgements, I use a large window and only require    an ack at the halfway point.     Each packet starts with a header containing the following    information:     Intro byte           8 bits          byte 1    Packet number        5 bits          byte 2    Local channel        3 bits    Packet ack           5 bits          byte 3    Remote channel       3 bits    Packet type          3 bits          bytes 4-5    Direction            1 bit    Data length         12 bits    Header check         8 bits          byte 6     If the data length is not 0, this is followed by the data and a 32    bit CRC checksum.     The following packet types are defined:     SYNC  Initialize the connection    DATA  Data packet    ACK   Simple acknowledgement with no data    NAK   Negative acknowledgement; requests resend of single packet    SPOS  Set file position    CLOSE Close the connection    */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The offsets of the bytes in the packet header.  */
end_comment

begin_define
define|#
directive|define
name|IHDR_INTRO
value|(0)
end_define

begin_define
define|#
directive|define
name|IHDR_LOCAL
value|(1)
end_define

begin_define
define|#
directive|define
name|IHDR_REMOTE
value|(2)
end_define

begin_define
define|#
directive|define
name|IHDR_CONTENTS1
value|(3)
end_define

begin_define
define|#
directive|define
name|IHDR_CONTENTS2
value|(4)
end_define

begin_define
define|#
directive|define
name|IHDR_CHECK
value|(5)
end_define

begin_comment
comment|/* Macros to set and extract values of IHDR_LOCAL and IHDR_REMOTE.  */
end_comment

begin_define
define|#
directive|define
name|IHDRWIN_SET
parameter_list|(
name|iseq
parameter_list|,
name|ichan
parameter_list|)
value|(((iseq)<< 3) | (ichan))
end_define

begin_define
define|#
directive|define
name|IHDRWIN_GETSEQ
parameter_list|(
name|ival
parameter_list|)
value|(((ival)>> 3)& 0x1f)
end_define

begin_define
define|#
directive|define
name|IHDRWIN_GETCHAN
parameter_list|(
name|ival
parameter_list|)
value|((ival)& 0x07)
end_define

begin_comment
comment|/* Macros to set and extract values of IHDR_CONTENTS fields.  */
end_comment

begin_define
define|#
directive|define
name|IHDRCON_SET1
parameter_list|(
name|ttype
parameter_list|,
name|fcaller
parameter_list|,
name|cbytes
parameter_list|)
define|\
value|(((ttype)<< 5) | ((fcaller) ? (1<< 4) : 0) | (((cbytes)>> 8)& 0x0f))
end_define

begin_define
define|#
directive|define
name|IHDRCON_SET2
parameter_list|(
name|ttype
parameter_list|,
name|fcaller
parameter_list|,
name|cbytes
parameter_list|)
value|((cbytes)& 0xff)
end_define

begin_define
define|#
directive|define
name|THDRCON_GETTYPE
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
value|(((i1)>> 5)& 0x07)
end_define

begin_define
define|#
directive|define
name|FHDRCON_GETCALLER
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
value|(((i1)& (1<< 4)) != 0)
end_define

begin_define
define|#
directive|define
name|CHDRCON_GETBYTES
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
value|((((i1)& 0x0f)<< 8) | ((i2)& 0xff))
end_define

begin_comment
comment|/* Macros for the IHDR_CHECK field.  */
end_comment

begin_define
define|#
directive|define
name|IHDRCHECK_VAL
parameter_list|(
name|zhdr
parameter_list|)
define|\
value|((zhdr[IHDR_LOCAL] \     ^ zhdr[IHDR_REMOTE] \     ^ zhdr[IHDR_CONTENTS1] \     ^ zhdr[IHDR_CONTENTS2]) \& 0xff)
end_define

begin_comment
comment|/* Length of the packet header.  */
end_comment

begin_define
define|#
directive|define
name|CHDRLEN
value|(6)
end_define

begin_comment
comment|/* Amount of space to skip between start of packet and actual data.    This is used to make the actual data longword aligned, to encourage    good performance when copying data into the buffer.  */
end_comment

begin_define
define|#
directive|define
name|CHDRSKIPLEN
value|(CHDRLEN + (sizeof (long) - CHDRLEN % sizeof (long)))
end_define

begin_comment
comment|/* Amount of space to skip between memory buffer and header.  */
end_comment

begin_define
define|#
directive|define
name|CHDROFFSET
value|(CHDRSKIPLEN - CHDRLEN)
end_define

begin_comment
comment|/* Length of the trailing checksum.  */
end_comment

begin_define
define|#
directive|define
name|CCKSUMLEN
value|(4)
end_define

begin_comment
comment|/* Macros to set and get the checksum.  These multiply evaluate their    arguments.  */
end_comment

begin_define
define|#
directive|define
name|ICKSUM_GET
parameter_list|(
name|z
parameter_list|)
define|\
value|((((((((unsigned long) ((z)[0]& 0xff))<< 8) \        | (unsigned long) ((z)[1]& 0xff))<< 8) \      | (unsigned long) ((z)[2]& 0xff))<< 8) \    | (unsigned long) ((z)[3]& 0xff))
end_define

begin_define
define|#
directive|define
name|UCKSUM_SET
parameter_list|(
name|z
parameter_list|,
name|i
parameter_list|)
define|\
value|(void) ((z)[0] = (((i)>> 24)& 0xff), \ 	  (z)[1] = (((i)>> 16)& 0xff), \ 	  (z)[2] = (((i)>> 8)& 0xff), \ 	  (z)[3] = ((i)& 0xff))
end_define

begin_comment
comment|/* The header introduction character.  */
end_comment

begin_define
define|#
directive|define
name|IINTRO
value|('\007')
end_define

begin_comment
comment|/* The packet types.  */
end_comment

begin_define
define|#
directive|define
name|DATA
value|(0)
end_define

begin_define
define|#
directive|define
name|SYNC
value|(1)
end_define

begin_define
define|#
directive|define
name|ACK
value|(2)
end_define

begin_define
define|#
directive|define
name|NAK
value|(3)
end_define

begin_define
define|#
directive|define
name|SPOS
value|(4)
end_define

begin_define
define|#
directive|define
name|CLOSE
value|(5)
end_define

begin_comment
comment|/* Largest possible packet size.  */
end_comment

begin_define
define|#
directive|define
name|IMAXPACKSIZE
value|((1<< 12) - 1)
end_define

begin_comment
comment|/* Largest possible sequence number (plus 1).  */
end_comment

begin_define
define|#
directive|define
name|IMAXSEQ
value|32
end_define

begin_comment
comment|/* Get the next sequence number given a sequence number.  */
end_comment

begin_define
define|#
directive|define
name|INEXTSEQ
parameter_list|(
name|i
parameter_list|)
value|(((i) + 1)& (IMAXSEQ - 1))
end_define

begin_comment
comment|/* Get the previous sequence number given a sequence number.  */
end_comment

begin_define
define|#
directive|define
name|IPREVSEQ
parameter_list|(
name|i
parameter_list|)
value|(((i) + IMAXSEQ - 1)& (IMAXSEQ - 1))
end_define

begin_comment
comment|/* Compute i1 - i2 in sequence space (i.e., the number of packets from    i2 to i1).  */
end_comment

begin_define
define|#
directive|define
name|CSEQDIFF
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
value|(((i1) + IMAXSEQ - (i2))& (IMAXSEQ - 1))
end_define

begin_comment
comment|/* Largest possible channel number (plus 1).  */
end_comment

begin_define
define|#
directive|define
name|IMAXICHAN
value|(8)
end_define

begin_escape
end_escape

begin_comment
comment|/* Default packet size to request (protocol parameter    ``packet-size'').  */
end_comment

begin_define
define|#
directive|define
name|IREQUEST_PACKSIZE
value|(1024)
end_define

begin_comment
comment|/* Default window size to request (protocol parameter ``window'').  */
end_comment

begin_define
define|#
directive|define
name|IREQUEST_WINSIZE
value|(16)
end_define

begin_comment
comment|/* Default timeout to use when sending the SYNC packet (protocol    parameter ``sync-timeout'').  */
end_comment

begin_define
define|#
directive|define
name|CSYNC_TIMEOUT
value|(10)
end_define

begin_comment
comment|/* Default number of times to retry sending the SYNC packet (protocol    parameter ``sync-retries'').  */
end_comment

begin_define
define|#
directive|define
name|CSYNC_RETRIES
value|(6)
end_define

begin_comment
comment|/* Default timeout to use when waiting for a packet (protocol    parameter ``timeout'').  */
end_comment

begin_define
define|#
directive|define
name|CTIMEOUT
value|(10)
end_define

begin_comment
comment|/* Default number of times to retry sending a packet before giving up    (protocol parameter ``retries'').  */
end_comment

begin_define
define|#
directive|define
name|CRETRIES
value|(6)
end_define

begin_comment
comment|/* Default maximum level of errors to accept before giving up    (protocol parameter ``errors'').  */
end_comment

begin_define
define|#
directive|define
name|CERRORS
value|(100)
end_define

begin_comment
comment|/* Default decay rate.  Each time we receive this many packets    succesfully, we decrement the error level by one (protocol    parameter ``error-decay'').  */
end_comment

begin_define
define|#
directive|define
name|CERROR_DECAY
value|(10)
end_define

begin_comment
comment|/* The default list of characters to avoid: XON and XOFF.  This string    is processed as an escape sequence.  This is 'j' protocol parameter    ``avoid''; it is defined in this file because the 'i' and 'j'    protocols share protocol parameters.  */
end_comment

begin_define
define|#
directive|define
name|ZAVOID
value|"\\021\\023"
end_define

begin_escape
end_escape

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* Packet size to request (protocol parameter ``packet-size'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIrequest_packsize
init|=
name|IREQUEST_PACKSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Window size to request (protocol parameter ``window'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIrequest_winsize
init|=
name|IREQUEST_WINSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote packet size (set from SYNC packet or from    iIforced_remote_packsize).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIremote_packsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size which buffers were allocated for.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIalc_packsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forced remote packet size, used if non-zero (protocol parameter    ``remote-packet-size'').  There is no forced remote window size    because the ACK strategy requires that both sides agree on the    window size.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIforced_remote_packsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote window size (set from SYNC packet).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIremote_winsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout to use when sending the SYNC packet (protocol    parameter ``sync-timeout'').  */
end_comment

begin_decl_stmt
name|int
name|cIsync_timeout
init|=
name|CSYNC_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times to retry sending the SYNC packet (protocol    parameter ``sync-retries'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIsync_retries
init|=
name|CSYNC_RETRIES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout to use when waiting for a packet (protocol parameter    ``timeout'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cItimeout
init|=
name|CTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timeout to use when waiting for an acknowledgement to open up space    in the window.  This is computed based on the window size and the    connection speed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIwindow_timeout
init|=
name|CTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times to retry sending a packet before giving up    (protocol parameter ``retries'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIretries
init|=
name|CRETRIES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum level of errors to accept before giving up (protocol    parameter ``errors'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIerrors
init|=
name|CERRORS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we receive this many packets succesfully, we decrement    the error level by one (protocol parameter ``error-decay'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIerror_decay
init|=
name|CERROR_DECAY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of packets we should wait to receive before sending an    ACK; this is set by default to half the window size we have    requested (protocol parameter ``ack-frequency'').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIack_frequency
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The set of characters to avoid (protocol parameter ``avoid'').    This is actually part of the 'j' protocol; it is defined in this    file because the 'i' and 'j' protocols use the same protocol    parameters.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zJavoid_parameter
init|=
name|ZAVOID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to use when sending data.  This is a hook for the 'j'    protocol.  */
end_comment

begin_expr_stmt
specifier|static
name|boolean
argument_list|(
argument|*pfIsend
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|zsend
operator|,
name|size_t
name|csend
operator|,
name|boolean
name|fdoread
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Routine to use to use when reading data.  This is a hook for the    'j' protocol.  */
end_comment

begin_expr_stmt
specifier|static
name|boolean
argument_list|(
argument|*pfIreceive
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|size_t
name|cneed
operator|,
name|size_t
operator|*
name|pcrec
operator|,
name|int
name|ctimeout
operator|,
name|boolean
name|freport
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Next sequence number to send.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIsendseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number received.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIrecseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number we have acknowledged.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIlocal_ack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last sequence number remote system has acknowledged.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iIremote_ack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File position we are sending from.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|iIsendpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File position we are receiving to.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|iIrecpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if closing the connection.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fIclosing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of sent packets indexed by packet number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|azIsendbuffers
index|[
name|IMAXSEQ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of received packets that we aren't ready to process yet,    indexed by packet number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|azIrecbuffers
index|[
name|IMAXSEQ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each packet sequence number, record whether we sent a NAK for    the packet.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|afInaked
index|[
name|IMAXSEQ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of SYNC packets received (used only to detect whether one    was received).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cIsyncs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets sent.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIsent_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets received.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIreceived_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets resent.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIresent_packets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bad packet headers received.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIbad_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of out of order packets received.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIbad_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bad checksums received.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIbad_cksum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets rejected by remote system.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cIremote_rejects
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Protocol parameter commands.  */
end_comment

begin_decl_stmt
name|struct
name|uuconf_cmdtab
name|asIproto_params
index|[]
init|=
block|{
block|{
literal|"packet-size"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iIrequest_packsize
block|,
name|NULL
block|}
block|,
block|{
literal|"window"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iIrequest_winsize
block|,
name|NULL
block|}
block|,
block|{
literal|"remote-packet-size"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iIforced_remote_packsize
block|,
name|NULL
block|}
block|,
block|{
literal|"sync-timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cIsync_timeout
block|,
name|NULL
block|}
block|,
block|{
literal|"sync-retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cIsync_retries
block|,
name|NULL
block|}
block|,
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cItimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"retries"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cIretries
block|,
name|NULL
block|}
block|,
block|{
literal|"errors"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cIerrors
block|,
name|NULL
block|}
block|,
block|{
literal|"error-decay"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cIerror_decay
block|,
name|NULL
block|}
block|,
block|{
literal|"ack-frequency"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cIack_frequency
block|,
name|NULL
block|}
block|,
comment|/* The ``avoid'' protocol parameter is part of the 'j' protocol, but      it is convenient for the 'i' and 'j' protocols to share the same      protocol parameter table.  */
block|{
literal|"avoid"
block|,
name|UUCONF_CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zJavoid_parameter
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|finak
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|iseq
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|firesend
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fiwindow_wait
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fiwait_for_packet
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|ctimeout
operator|,
name|int
name|cretries
operator|,
name|boolean
name|fone
operator|,
name|boolean
operator|*
name|ftimedout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ficheck_errors
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fiprocess_data
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
operator|*
name|pfexit
operator|,
name|boolean
operator|*
name|pffound
operator|,
name|size_t
operator|*
name|pcneed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fiprocess_packet
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|char
operator|*
name|zhdr
operator|,
specifier|const
name|char
operator|*
name|zfirst
operator|,
name|int
name|cfirst
operator|,
specifier|const
name|char
operator|*
name|zsecond
operator|,
name|int
name|csecond
operator|,
name|boolean
operator|*
name|pfexit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The 'i' protocol start routine.  The work is done in a routine    which is also called by the 'j' protocol start routine.  */
end_comment

begin_function
name|boolean
name|fistart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
return|return
name|fijstart
argument_list|(
name|qdaemon
argument_list|,
name|pzlog
argument_list|,
name|IMAXPACKSIZE
argument_list|,
name|fsend_data
argument_list|,
name|freceive_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start the protocol.  This routine is called by both the 'i' and 'j'    protocol start routines.  We keep transmitting a SYNC packet    containing the window and packet size we would like to receive    until we receive a SYNC packet from the remote system.  The first    two bytes of the data contents of a SYNC packet are the maximum    packet size we want to receive (high byte, low byte), and the next    byte is the maximum window size we want to use.  */
end_comment

begin_function_decl
name|boolean
name|fijstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|,
name|imaxpacksize
parameter_list|,
name|pfsend
parameter_list|,
name|pfreceive
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
name|int
name|imaxpacksize
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*pfsend
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|zsend
operator|,
name|size_t
name|csend
operator|,
name|boolean
name|fdoread
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|boolean
argument_list|(
argument|*pfreceive
argument_list|)
end_macro

begin_expr_stmt
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|size_t
name|cneed
operator|,
name|size_t
operator|*
name|pcrec
operator|,
name|int
name|ctimeout
operator|,
name|boolean
name|freport
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|ab
index|[
name|CHDRLEN
operator|+
literal|4
operator|+
name|CCKSUMLEN
index|]
decl_stmt|;
name|unsigned
name|long
name|icksum
decl_stmt|;
name|int
name|ctries
decl_stmt|;
name|int
name|csyncs
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
operator|*
name|pzlog
operator|=
name|NULL
expr_stmt|;
name|pfIsend
operator|=
name|pfsend
expr_stmt|;
name|pfIreceive
operator|=
name|pfreceive
expr_stmt|;
if|if
condition|(
name|iIforced_remote_packsize
operator|<=
literal|0
operator|||
name|iIforced_remote_packsize
operator|>
name|imaxpacksize
condition|)
name|iIforced_remote_packsize
operator|=
literal|0
expr_stmt|;
else|else
name|iIremote_packsize
operator|=
name|iIforced_remote_packsize
expr_stmt|;
name|iIalc_packsize
operator|=
literal|0
expr_stmt|;
name|iIsendseq
operator|=
literal|1
expr_stmt|;
name|iIrecseq
operator|=
literal|0
expr_stmt|;
name|iIlocal_ack
operator|=
literal|0
expr_stmt|;
name|iIremote_ack
operator|=
literal|0
expr_stmt|;
name|iIsendpos
operator|=
literal|0
expr_stmt|;
name|iIrecpos
operator|=
literal|0
expr_stmt|;
name|fIclosing
operator|=
name|FALSE
expr_stmt|;
name|cIsent_packets
operator|=
literal|0
expr_stmt|;
name|cIreceived_packets
operator|=
literal|0
expr_stmt|;
name|cIresent_packets
operator|=
literal|0
expr_stmt|;
name|cIbad_hdr
operator|=
literal|0
expr_stmt|;
name|cIbad_order
operator|=
literal|0
expr_stmt|;
name|cIbad_cksum
operator|=
literal|0
expr_stmt|;
name|cIremote_rejects
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iIrequest_packsize
operator|<
literal|0
operator|||
name|iIrequest_packsize
operator|>
name|imaxpacksize
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal protocol '%c' packet size; using %d"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|imaxpacksize
argument_list|)
expr_stmt|;
name|iIrequest_packsize
operator|=
name|imaxpacksize
expr_stmt|;
block|}
comment|/* The maximum permissible window size is 16.  Otherwise the      protocol can get confused because a duplicated packet may arrive      out of order.  If the window size is large in such a case, the      duplicate packet may be treated as a packet in the upcoming      window, causing the protocol to assume that all intermediate      packets have been lost, leading to immense confusion.  */
if|if
condition|(
name|iIrequest_winsize
operator|<
literal|0
operator|||
name|iIrequest_winsize
operator|>
name|IMAXSEQ
operator|/
literal|2
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal protocol '%c' window size; using %d"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|IREQUEST_WINSIZE
argument_list|)
expr_stmt|;
name|iIrequest_winsize
operator|=
name|IREQUEST_WINSIZE
expr_stmt|;
block|}
comment|/* The default for the ACK frequency is half the window size.  */
if|if
condition|(
name|cIack_frequency
operator|<=
literal|0
operator|||
name|cIack_frequency
operator|>=
name|iIrequest_winsize
condition|)
name|cIack_frequency
operator|=
name|iIrequest_winsize
operator|/
literal|2
expr_stmt|;
name|ab
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|ab
index|[
name|IHDR_LOCAL
index|]
operator|=
name|ab
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ab
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|SYNC
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ab
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|SYNC
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ab
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|ab
index|[
name|CHDRLEN
operator|+
literal|0
index|]
operator|=
operator|(
name|iIrequest_packsize
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ab
index|[
name|CHDRLEN
operator|+
literal|1
index|]
operator|=
name|iIrequest_packsize
operator|&
literal|0xff
expr_stmt|;
name|ab
index|[
name|CHDRLEN
operator|+
literal|2
index|]
operator|=
name|iIrequest_winsize
expr_stmt|;
name|ab
index|[
name|CHDRLEN
operator|+
literal|3
index|]
operator|=
name|qdaemon
operator|->
name|cchans
expr_stmt|;
name|icksum
operator|=
name|icrc
argument_list|(
name|ab
operator|+
name|CHDRLEN
argument_list|,
literal|4
argument_list|,
name|ICRCINIT
argument_list|)
expr_stmt|;
name|UCKSUM_SET
argument_list|(
name|ab
operator|+
name|CHDRLEN
operator|+
literal|4
argument_list|,
name|icksum
argument_list|)
expr_stmt|;
comment|/* The static cIsyncs is incremented each time a SYNC packet is      received.  */
name|csyncs
operator|=
name|cIsyncs
expr_stmt|;
name|ctries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|ftimedout
decl_stmt|;
name|DEBUG_MESSAGE3
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fistart: Sending SYNC packsize %d winsize %d channels %d"
argument_list|,
name|iIrequest_packsize
argument_list|,
name|iIrequest_winsize
argument_list|,
name|qdaemon
operator|->
name|cchans
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|ab
argument_list|,
name|CHDRLEN
operator|+
literal|4
operator|+
name|CCKSUMLEN
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fiwait_for_packet
argument_list|(
name|qdaemon
argument_list|,
name|cIsync_timeout
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|ftimedout
argument_list|)
condition|)
block|{
if|if
condition|(
name|csyncs
operator|!=
name|cIsyncs
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ftimedout
condition|)
return|return
name|FALSE
return|;
operator|++
name|ctries
expr_stmt|;
if|if
condition|(
name|ctries
operator|>
name|cIsync_retries
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Protocol startup failed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
comment|/* Calculate the window timeout.  */
name|ibaud
operator|=
name|iconn_baud
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibaud
operator|==
literal|0
condition|)
name|cIwindow_timeout
operator|=
name|cItimeout
expr_stmt|;
else|else
block|{
comment|/* We expect to receive an ACK about halfway through each 	 window.  In principle, an entire window might be sitting in a 	 modem buffer while we are waiting for an ACK.  Therefore, the 	 minimum time we should wait for an ACK is 	   (1/2 window size) * (seconds / byte) + (roundtrip time) == 	   (1/2 window size) * (1 / (baud / 10)) + (roundtrip time) == 	   (1/2 window size) * (10 / baud) + (roundtrip time) == 	   (5 * (window size)) / baud + (roundtrip time)  	 The window size is iIremote_packsize * iIremote_winsize.  For 	 typical settings of packsize == 1024, winsize == 16, baud == 	 9600, this equation works out to 	   (5 * 1024 * 16) / 9600 == 8 seconds 	 We then take cItimeout as the round trip time, which gives us 	 some flexibility.  We get more flexibility because it is 	 quite likely that by the time we have finished sending out 	 the last packet in a window, the first one has already been 	 received by the remote system.  */
name|cIwindow_timeout
operator|=
operator|(
operator|(
literal|5
operator|*
name|iIremote_packsize
operator|*
name|iIremote_winsize
operator|)
operator|/
name|ibaud
operator|+
name|cItimeout
operator|)
expr_stmt|;
block|}
comment|/* If we are the callee, bump both timeouts by one, to make it less      likely that both systems will timeout simultaneously.  */
if|if
condition|(
operator|!
name|qdaemon
operator|->
name|fcaller
condition|)
block|{
operator|++
name|cItimeout
expr_stmt|;
operator|++
name|cIwindow_timeout
expr_stmt|;
block|}
comment|/* We got a SYNC packet; set up packet buffers to use.  */
if|if
condition|(
name|iIremote_packsize
operator|>
name|imaxpacksize
condition|)
name|iIremote_packsize
operator|=
name|imaxpacksize
expr_stmt|;
do|do
block|{
name|int
name|iseq
decl_stmt|;
for|for
control|(
name|iseq
operator|=
literal|0
init|;
name|iseq
operator|<
name|IMAXSEQ
condition|;
name|iseq
operator|++
control|)
block|{
name|azIrecbuffers
index|[
name|iseq
index|]
operator|=
name|NULL
expr_stmt|;
name|afInaked
index|[
name|iseq
index|]
operator|=
name|FALSE
expr_stmt|;
name|azIsendbuffers
index|[
name|iseq
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|iIremote_packsize
operator|+
name|CHDRSKIPLEN
operator|+
name|CCKSUMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|azIsendbuffers
index|[
name|iseq
index|]
operator|==
name|NULL
condition|)
block|{
name|int
name|ifree
decl_stmt|;
for|for
control|(
name|ifree
operator|=
literal|0
init|;
name|ifree
operator|<
name|iseq
condition|;
name|ifree
operator|++
control|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|azIsendbuffers
index|[
name|ifree
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|iseq
operator|>=
name|IMAXSEQ
condition|)
block|{
operator|*
name|pzlog
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"protocol '' sending packet/window / receiving /"
operator|+
literal|64
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|pzlog
argument_list|,
literal|"protocol '%c' sending packet/window %d/%d receiving %d/%d"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
operator|(
name|int
operator|)
name|iIremote_packsize
argument_list|,
operator|(
name|int
operator|)
name|iIremote_winsize
argument_list|,
operator|(
name|int
operator|)
name|iIrequest_packsize
argument_list|,
operator|(
name|int
operator|)
name|iIrequest_winsize
argument_list|)
expr_stmt|;
name|iIalc_packsize
operator|=
name|iIremote_packsize
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|iIremote_packsize
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|iIremote_packsize
operator|>
literal|200
condition|)
do|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"'%c' protocol startup failed; insufficient memory for packets"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Shut down the protocol.  We can be fairly informal about this,    since we know that the upper level protocol has already exchanged    hangup messages.  If we didn't know that, we would have to make    sure that all packets before the CLOSE had been received.  */
end_comment

begin_function
name|boolean
name|fishutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|fIclosing
operator|=
name|TRUE
expr_stmt|;
name|z
operator|=
name|zigetspace
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|clen
argument_list|)
operator|-
name|CHDRLEN
expr_stmt|;
name|z
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|z
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIsendseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|z
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|CLOSE
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|CLOSE
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fishutdown: Sending CLOSE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|z
argument_list|,
name|CHDRLEN
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol '%c' packets: sent %ld, resent %ld, received %ld"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|,
name|cIsent_packets
argument_list|,
name|cIresent_packets
argument_list|,
name|cIreceived_packets
argument_list|)
expr_stmt|;
if|if
condition|(
name|cIbad_hdr
operator|!=
literal|0
operator|||
name|cIbad_cksum
operator|!=
literal|0
operator|||
name|cIbad_order
operator|!=
literal|0
operator|||
name|cIremote_rejects
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Errors: header %ld, checksum %ld, order %ld, remote rejects %ld"
argument_list|,
name|cIbad_hdr
argument_list|,
name|cIbad_cksum
argument_list|,
name|cIbad_order
argument_list|,
name|cIremote_rejects
argument_list|)
expr_stmt|;
comment|/* Reset the protocol parameters to their default values.  */
name|iIrequest_packsize
operator|=
name|IREQUEST_PACKSIZE
expr_stmt|;
name|iIrequest_winsize
operator|=
name|IREQUEST_WINSIZE
expr_stmt|;
name|iIforced_remote_packsize
operator|=
literal|0
expr_stmt|;
name|cIsync_timeout
operator|=
name|CSYNC_TIMEOUT
expr_stmt|;
name|cIsync_retries
operator|=
name|CSYNC_RETRIES
expr_stmt|;
name|cItimeout
operator|=
name|CTIMEOUT
expr_stmt|;
name|cIwindow_timeout
operator|=
name|CTIMEOUT
expr_stmt|;
name|cIretries
operator|=
name|CRETRIES
expr_stmt|;
name|cIerrors
operator|=
name|CERRORS
expr_stmt|;
name|cIerror_decay
operator|=
name|CERROR_DECAY
expr_stmt|;
name|cIack_frequency
operator|=
literal|0
expr_stmt|;
name|zJavoid_parameter
operator|=
name|ZAVOID
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a command string.  These are just sent as normal packets,    ending in a packet containing a null byte.  */
end_comment

begin_function
name|boolean
name|fisendcmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|size_t
name|clen
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fisendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|zpacket
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
name|zpacket
operator|=
name|zigetspace
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|csize
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|csize
condition|)
block|{
name|memcpy
argument_list|(
name|zpacket
argument_list|,
name|z
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|fisenddata
argument_list|(
name|qdaemon
argument_list|,
name|zpacket
argument_list|,
name|clen
operator|+
literal|1
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
return|;
block|}
name|memcpy
argument_list|(
name|zpacket
argument_list|,
name|z
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|z
operator|+=
name|csize
expr_stmt|;
name|clen
operator|-=
name|csize
expr_stmt|;
if|if
condition|(
operator|!
name|fisenddata
argument_list|(
name|qdaemon
argument_list|,
name|zpacket
argument_list|,
name|csize
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a NAK.  */
end_comment

begin_function
specifier|static
name|boolean
name|finak
parameter_list|(
name|qdaemon
parameter_list|,
name|iseq
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|iseq
decl_stmt|;
block|{
name|char
name|abnak
index|[
name|CHDRLEN
index|]
decl_stmt|;
name|abnak
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|abnak
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abnak
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|abnak
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|NAK
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abnak
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|NAK
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abnak
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|abnak
argument_list|)
expr_stmt|;
name|afInaked
index|[
name|iseq
index|]
operator|=
name|TRUE
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"finak: Sending NAK %d"
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|abnak
argument_list|,
name|CHDRLEN
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Resend the latest packet the remote has not acknowledged.  */
end_comment

begin_function
specifier|static
name|boolean
name|firesend
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|int
name|iseq
decl_stmt|;
name|char
modifier|*
name|zhdr
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|iseq
operator|=
name|INEXTSEQ
argument_list|(
name|iIremote_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|iseq
operator|==
name|iIsendseq
condition|)
block|{
comment|/* Everything has been ACKed and there is nothing to resend.  */
return|return
name|TRUE
return|;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"firesend: Resending packet %d"
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
comment|/* Update the received sequence number.  */
name|zhdr
operator|=
name|azIsendbuffers
index|[
name|iseq
index|]
operator|+
name|CHDROFFSET
expr_stmt|;
if|if
condition|(
name|IHDRWIN_GETSEQ
argument_list|(
name|zhdr
index|[
name|IHDR_REMOTE
index|]
argument_list|)
operator|!=
name|iIrecseq
condition|)
block|{
name|int
name|iremote
decl_stmt|;
name|iremote
operator|=
name|IHDRWIN_GETCHAN
argument_list|(
name|zhdr
index|[
name|IHDR_REMOTE
index|]
argument_list|)
expr_stmt|;
name|zhdr
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
name|zhdr
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|zhdr
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
block|}
operator|++
name|cIresent_packets
expr_stmt|;
name|clen
operator|=
name|CHDRCON_GETBYTES
argument_list|(
name|zhdr
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|zhdr
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zhdr
argument_list|,
name|CHDRLEN
operator|+
name|clen
operator|+
operator|(
name|clen
operator|>
literal|0
condition|?
name|CCKSUMLEN
else|:
literal|0
operator|)
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait until there is an opening in the receive window of the remote    system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fiwindow_wait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
comment|/* iIsendseq is the sequence number we are sending, and iIremote_ack      is the last sequence number acknowledged by the remote. */
while|while
condition|(
name|CSEQDIFF
argument_list|(
name|iIsendseq
argument_list|,
name|iIremote_ack
argument_list|)
operator|>
name|iIremote_winsize
condition|)
block|{
comment|/* If a NAK is lost, it is possible for the other side to be 	 sending a stream of packets while we are waiting for an ACK. 	 This should be caught in fiprocess_data; if it is about to 	 send an ACK, but it has an unacknowledged packet to send, it 	 sends the entire packet.  Hopefully that will trigger an ACK 	 or a NAK and get us going again.  */
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiwindow_wait: Waiting for ACK"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fiwait_for_packet
argument_list|(
name|qdaemon
argument_list|,
name|cIwindow_timeout
argument_list|,
name|cIretries
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get buffer space to use for packet data.  We return a pointer to    the space to be used for the actual data, leaving room for the    header.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|zigetspace
parameter_list|(
name|qdaemon
parameter_list|,
name|pclen
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|iIremote_packsize
expr_stmt|;
return|return
name|azIsendbuffers
index|[
name|iIsendseq
index|]
operator|+
name|CHDRSKIPLEN
return|;
block|}
end_function

begin_comment
comment|/* Send a data packet.  The zdata argument will always point to value    returned by zigetspace, so we know that we have room before it for    the header information.  */
end_comment

begin_function
name|boolean
name|fisenddata
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
block|{
name|char
modifier|*
name|zhdr
decl_stmt|;
name|unsigned
name|long
name|icksum
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|ilocal
operator|<
literal|0
operator|||
name|ilocal
operator|>=
name|IMAXICHAN
operator|||
name|iremote
operator|<
literal|0
operator|||
name|iremote
operator|>=
name|IMAXICHAN
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fisenddata: ilocal %d iremote %d"
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are changing the file position, we must send an SPOS      packet.  */
if|if
condition|(
name|ipos
operator|!=
name|iIsendpos
operator|&&
name|ipos
operator|!=
operator|(
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|int
name|inext
decl_stmt|;
name|char
modifier|*
name|zspos
decl_stmt|;
comment|/* We need to get a buffer to hold the SPOS packet, and it needs 	 to be next sequence number.  However, the data we have been 	 given is currently in the next sequence number buffer.  So we 	 shuffle the buffers around.  */
name|inext
operator|=
name|INEXTSEQ
argument_list|(
name|iIsendseq
argument_list|)
expr_stmt|;
name|zspos
operator|=
name|azIsendbuffers
index|[
name|inext
index|]
expr_stmt|;
name|azIsendbuffers
index|[
name|inext
index|]
operator|=
name|zdata
operator|-
name|CHDRSKIPLEN
expr_stmt|;
name|azIsendbuffers
index|[
name|iIsendseq
index|]
operator|=
name|zspos
expr_stmt|;
name|zspos
operator|+=
name|CHDROFFSET
expr_stmt|;
name|zspos
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|zspos
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIsendseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zspos
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|zspos
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|SPOS
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
name|CCKSUMLEN
argument_list|)
expr_stmt|;
name|zspos
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|SPOS
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
name|CCKSUMLEN
argument_list|)
expr_stmt|;
name|zspos
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|zspos
argument_list|)
expr_stmt|;
name|UCKSUM_SET
argument_list|(
name|zspos
operator|+
name|CHDRLEN
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ipos
argument_list|)
expr_stmt|;
name|icksum
operator|=
name|icrc
argument_list|(
name|zspos
operator|+
name|CHDRLEN
argument_list|,
name|CCKSUMLEN
argument_list|,
name|ICRCINIT
argument_list|)
expr_stmt|;
name|UCKSUM_SET
argument_list|(
name|zspos
operator|+
name|CHDRLEN
operator|+
name|CCKSUMLEN
argument_list|,
name|icksum
argument_list|)
expr_stmt|;
comment|/* Wait for an opening in the window.  */
if|if
condition|(
name|iIremote_winsize
operator|>
literal|0
operator|&&
name|CSEQDIFF
argument_list|(
name|iIsendseq
argument_list|,
name|iIremote_ack
argument_list|)
operator|>
name|iIremote_winsize
condition|)
block|{
if|if
condition|(
operator|!
name|fiwindow_wait
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fisenddata: Sending SPOS %ld"
argument_list|,
name|ipos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zspos
argument_list|,
name|CHDRLEN
operator|+
name|CCKSUMLEN
operator|+
name|CCKSUMLEN
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iIsendseq
operator|=
name|INEXTSEQ
argument_list|(
name|iIsendseq
argument_list|)
expr_stmt|;
name|iIsendpos
operator|=
name|ipos
expr_stmt|;
block|}
name|zhdr
operator|=
name|zdata
operator|-
name|CHDRLEN
expr_stmt|;
name|zhdr
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|zhdr
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIsendseq
argument_list|,
name|ilocal
argument_list|)
expr_stmt|;
name|zhdr
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|DATA
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
name|zhdr
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|DATA
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
comment|/* Compute and set the checksum.  */
if|if
condition|(
name|cdata
operator|>
literal|0
condition|)
block|{
name|icksum
operator|=
name|icrc
argument_list|(
name|zdata
argument_list|,
name|cdata
argument_list|,
name|ICRCINIT
argument_list|)
expr_stmt|;
name|UCKSUM_SET
argument_list|(
name|zdata
operator|+
name|cdata
argument_list|,
name|icksum
argument_list|)
expr_stmt|;
block|}
comment|/* Wait until there is an opening in the window (we hope to not have      to wait here at all, actually; ideally the window should be large      enough to avoid a wait).  */
if|if
condition|(
name|iIremote_winsize
operator|>
literal|0
operator|&&
name|CSEQDIFF
argument_list|(
name|iIsendseq
argument_list|,
name|iIremote_ack
argument_list|)
operator|>
name|iIremote_winsize
condition|)
block|{
if|if
condition|(
operator|!
name|fiwindow_wait
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We only fill in IHDR_REMOTE now, since only now do know the      correct value of iIrecseq.  */
name|zhdr
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|zhdr
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|zhdr
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fisenddata: Sending packet %d size %d local %d remote %d"
argument_list|,
name|iIsendseq
argument_list|,
operator|(
name|int
operator|)
name|cdata
argument_list|,
name|ilocal
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
name|iIsendseq
operator|=
name|INEXTSEQ
argument_list|(
name|iIsendseq
argument_list|)
expr_stmt|;
operator|++
name|cIsent_packets
expr_stmt|;
name|fret
operator|=
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zhdr
argument_list|,
name|cdata
operator|+
name|CHDRLEN
operator|+
operator|(
name|cdata
operator|>
literal|0
condition|?
name|CCKSUMLEN
else|:
literal|0
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|iIsendpos
operator|+=
name|cdata
expr_stmt|;
if|if
condition|(
name|fret
operator|&&
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
name|boolean
name|fexit
decl_stmt|;
name|fret
operator|=
name|fiprocess_data
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|fexit
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for data to come in.  */
end_comment

begin_function
name|boolean
name|fiwait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
return|return
name|fiwait_for_packet
argument_list|(
name|qdaemon
argument_list|,
name|cItimeout
argument_list|,
name|cIretries
argument_list|,
name|FALSE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for a packet.  Either there is no data to send, or the remote    window is full.  */
end_comment

begin_function
specifier|static
name|boolean
name|fiwait_for_packet
parameter_list|(
name|qdaemon
parameter_list|,
name|ctimeout
parameter_list|,
name|cretries
parameter_list|,
name|fone
parameter_list|,
name|pftimedout
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|int
name|cretries
decl_stmt|;
name|boolean
name|fone
decl_stmt|;
name|boolean
modifier|*
name|pftimedout
decl_stmt|;
block|{
name|int
name|cshort
decl_stmt|;
name|int
name|ctimeouts
decl_stmt|;
if|if
condition|(
name|pftimedout
operator|!=
name|NULL
condition|)
operator|*
name|pftimedout
operator|=
name|FALSE
expr_stmt|;
name|cshort
operator|=
literal|0
expr_stmt|;
name|ctimeouts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|fexit
decl_stmt|,
name|ffound
decl_stmt|;
name|size_t
name|cneed
decl_stmt|;
name|size_t
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|fiprocess_data
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|fexit
argument_list|,
operator|&
name|ffound
argument_list|,
operator|&
name|cneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
operator|||
operator|(
name|fone
operator|&&
name|ffound
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|cneed
operator|==
literal|0
condition|)
continue|continue;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiwait_for_packet: Need %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|cneed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfIreceive
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|ctimeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|crec
operator|!=
literal|0
condition|)
block|{
comment|/* If we didn't get enough data twice in a row, we may have 	     dropped some data and be waiting for the end of a large 	     packet.  Incrementing iPrecstart will force 	     fiprocess_data to skip the current packet and try to find 	     the next one.  */
if|if
condition|(
name|crec
operator|>=
name|cneed
condition|)
name|cshort
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|cshort
expr_stmt|;
if|if
condition|(
name|cshort
operator|>
literal|1
condition|)
block|{
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|cshort
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* We timed out on the read.  */
operator|++
name|ctimeouts
expr_stmt|;
if|if
condition|(
name|ctimeouts
operator|>
name|cretries
condition|)
block|{
if|if
condition|(
name|cretries
operator|>
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for packet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pftimedout
operator|!=
name|NULL
condition|)
operator|*
name|pftimedout
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Clear out the list of packets we have sent NAKs for.  We 	     should have seen some sort of response by now.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IMAXSEQ
condition|;
name|i
operator|++
control|)
name|afInaked
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* Send a NAK for the packet we want, and, if we have an 	     unacknowledged packet, send it again.  */
if|if
condition|(
operator|!
name|finak
argument_list|(
name|qdaemon
argument_list|,
name|INEXTSEQ
argument_list|(
name|iIrecseq
argument_list|)
argument_list|)
operator|||
operator|!
name|firesend
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure we haven't overflowed the permissible error level.  */
end_comment

begin_function
specifier|static
name|boolean
name|ficheck_errors
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
if|if
condition|(
name|cIerrors
operator|<
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
operator|(
name|cIbad_order
operator|+
name|cIbad_hdr
operator|+
name|cIbad_cksum
operator|+
name|cIremote_rejects
operator|)
operator|-
operator|(
name|cIreceived_packets
operator|/
name|cIerror_decay
operator|)
operator|)
operator|>
name|cIerrors
condition|)
block|{
comment|/* Try shrinking the packet size.  */
if|if
condition|(
name|iIrequest_packsize
operator|>
literal|400
condition|)
block|{
name|char
name|absync
index|[
name|CHDRLEN
operator|+
literal|3
operator|+
name|CCKSUMLEN
index|]
decl_stmt|;
name|unsigned
name|long
name|icksum
decl_stmt|;
comment|/* Don't bother sending the number of channels in this 	     packet.  */
name|iIrequest_packsize
operator|/=
literal|2
expr_stmt|;
name|absync
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|absync
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|absync
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|absync
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|SYNC
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|absync
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|SYNC
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|absync
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|absync
argument_list|)
expr_stmt|;
name|absync
index|[
name|CHDRLEN
operator|+
literal|0
index|]
operator|=
operator|(
name|iIrequest_packsize
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|absync
index|[
name|CHDRLEN
operator|+
literal|1
index|]
operator|=
name|iIrequest_packsize
operator|&
literal|0xff
expr_stmt|;
name|absync
index|[
name|CHDRLEN
operator|+
literal|2
index|]
operator|=
name|iIrequest_winsize
expr_stmt|;
name|icksum
operator|=
name|icrc
argument_list|(
name|absync
operator|+
name|CHDRLEN
argument_list|,
literal|3
argument_list|,
name|ICRCINIT
argument_list|)
expr_stmt|;
name|UCKSUM_SET
argument_list|(
name|absync
operator|+
name|CHDRLEN
operator|+
literal|3
argument_list|,
name|icksum
argument_list|)
expr_stmt|;
name|cIerrors
operator|*=
literal|2
expr_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"ficheck_errors: Sending SYNC packsize %d winsize %d"
argument_list|,
name|iIrequest_packsize
argument_list|,
name|iIrequest_winsize
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|absync
argument_list|,
name|CHDRLEN
operator|+
literal|3
operator|+
name|CCKSUMLEN
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many '%c' protocol errors"
argument_list|,
name|qdaemon
operator|->
name|qproto
operator|->
name|bname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process data waiting in the receive buffer, passing to the    fgot_data function.  */
end_comment

begin_function
specifier|static
name|boolean
name|fiprocess_data
parameter_list|(
name|qdaemon
parameter_list|,
name|pfexit
parameter_list|,
name|pffound
parameter_list|,
name|pcneed
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
name|boolean
modifier|*
name|pffound
decl_stmt|;
name|size_t
modifier|*
name|pcneed
decl_stmt|;
block|{
name|boolean
name|fbadhdr
decl_stmt|;
if|if
condition|(
name|pfexit
operator|!=
name|NULL
condition|)
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pffound
operator|!=
name|NULL
condition|)
operator|*
name|pffound
operator|=
name|FALSE
expr_stmt|;
name|fbadhdr
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
name|char
name|ab
index|[
name|CHDRLEN
index|]
decl_stmt|;
name|int
name|cfirst
decl_stmt|,
name|csecond
decl_stmt|;
name|char
modifier|*
name|zfirst
decl_stmt|,
modifier|*
name|zsecond
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|iget
decl_stmt|;
name|int
name|ttype
decl_stmt|;
name|int
name|iseq
decl_stmt|;
name|int
name|csize
decl_stmt|;
name|int
name|iack
decl_stmt|;
comment|/* If we're closing the connection, ignore any data remaining in 	 the input buffer.  */
if|if
condition|(
name|fIclosing
condition|)
block|{
if|if
condition|(
name|pfexit
operator|!=
name|NULL
condition|)
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Look for the IINTRO character.  */
if|if
condition|(
name|abPrecbuf
index|[
name|iPrecstart
index|]
operator|!=
name|IINTRO
condition|)
block|{
name|char
modifier|*
name|zintro
decl_stmt|;
name|int
name|cintro
decl_stmt|;
name|cintro
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cintro
operator|<
literal|0
condition|)
name|cintro
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
name|zintro
operator|=
name|memchr
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|IINTRO
argument_list|,
operator|(
name|size_t
operator|)
name|cintro
argument_list|)
expr_stmt|;
if|if
condition|(
name|zintro
operator|==
name|NULL
condition|)
block|{
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|cintro
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
comment|/* We don't need % CRECBUFLEN here because zintro - (abPrecbuf 	     + iPrecstart)< cintro<= CRECBUFLEN - iPrecstart.  */
name|iPrecstart
operator|+=
name|zintro
operator|-
operator|(
name|abPrecbuf
operator|+
name|iPrecstart
operator|)
expr_stmt|;
block|}
comment|/* Get the header into ab.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iget
operator|=
name|iPrecstart
init|;
name|i
operator|<
name|CHDRLEN
operator|&&
name|iget
operator|!=
name|iPrecend
condition|;
name|i
operator|++
operator|,
name|iget
operator|=
operator|(
name|iget
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
control|)
name|ab
index|[
name|i
index|]
operator|=
name|abPrecbuf
index|[
name|iget
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|CHDRLEN
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CHDRLEN
operator|-
name|i
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|ab
index|[
name|IHDR_CHECK
index|]
operator|&
literal|0xff
operator|)
operator|!=
name|IHDRCHECK_VAL
argument_list|(
name|ab
argument_list|)
operator|||
operator|(
name|FHDRCON_GETCALLER
argument_list|(
name|ab
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|ab
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
condition|?
name|qdaemon
operator|->
name|fcaller
else|:
operator|!
name|qdaemon
operator|->
name|fcaller
operator|)
condition|)
block|{
comment|/* We only report a single bad header message per call, to 	     avoid generating many errors if we get many INTRO bytes 	     in a row.  */
if|if
condition|(
operator|!
name|fbadhdr
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_data: Bad header"
argument_list|)
expr_stmt|;
operator|++
name|cIbad_hdr
expr_stmt|;
if|if
condition|(
operator|!
name|ficheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fbadhdr
operator|=
name|TRUE
expr_stmt|;
block|}
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
name|zfirst
operator|=
name|zsecond
operator|=
name|NULL
expr_stmt|;
name|cfirst
operator|=
name|csecond
operator|=
literal|0
expr_stmt|;
name|ttype
operator|=
name|THDRCON_GETTYPE
argument_list|(
name|ab
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|ab
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|DATA
operator|||
name|ttype
operator|==
name|SPOS
operator|||
name|ttype
operator|==
name|CLOSE
condition|)
name|iseq
operator|=
name|IHDRWIN_GETSEQ
argument_list|(
name|ab
index|[
name|IHDR_LOCAL
index|]
argument_list|)
expr_stmt|;
else|else
name|iseq
operator|=
operator|-
literal|1
expr_stmt|;
name|csize
operator|=
name|CHDRCON_GETBYTES
argument_list|(
name|ab
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|ab
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iseq
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Make sure this packet is in our receive window.  The last 	     packet we have acked is iIlocal_ack.  */
if|if
condition|(
name|iIrequest_winsize
operator|>
literal|0
operator|&&
name|CSEQDIFF
argument_list|(
name|iseq
argument_list|,
name|iIlocal_ack
argument_list|)
operator|>
name|iIrequest_winsize
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_data: Out of order packet %d (ack %d)"
argument_list|,
name|iseq
argument_list|,
name|iIlocal_ack
argument_list|)
expr_stmt|;
operator|++
name|cIbad_order
expr_stmt|;
if|if
condition|(
operator|!
name|ficheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|csize
operator|>
literal|0
condition|)
block|{
name|int
name|cinbuf
decl_stmt|;
name|char
name|abcksum
index|[
name|CCKSUMLEN
index|]
decl_stmt|;
name|unsigned
name|long
name|ickdata
decl_stmt|;
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|CHDRLEN
operator|+
name|csize
operator|+
name|CCKSUMLEN
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CHDRLEN
operator|+
name|csize
operator|+
name|CCKSUMLEN
operator|-
name|cinbuf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|iPrecend
operator|>
name|iPrecstart
condition|)
block|{
name|cfirst
operator|=
name|csize
expr_stmt|;
name|zfirst
operator|=
name|abPrecbuf
operator|+
name|iPrecstart
operator|+
name|CHDRLEN
expr_stmt|;
block|}
else|else
block|{
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
operator|(
name|iPrecstart
operator|+
name|CHDRLEN
operator|)
expr_stmt|;
if|if
condition|(
name|cfirst
operator|<=
literal|0
condition|)
block|{
comment|/* Here cfirst is non-positive, so subtracting from 		     abPrecbuf will actually skip the appropriate number 		     of bytes at the start of abPrecbuf.  */
name|zfirst
operator|=
name|abPrecbuf
operator|-
name|cfirst
expr_stmt|;
name|cfirst
operator|=
name|csize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cfirst
operator|>=
name|csize
condition|)
name|cfirst
operator|=
name|csize
expr_stmt|;
else|else
block|{
name|zsecond
operator|=
name|abPrecbuf
expr_stmt|;
name|csecond
operator|=
name|csize
operator|-
name|cfirst
expr_stmt|;
block|}
name|zfirst
operator|=
name|abPrecbuf
operator|+
name|iPrecstart
operator|+
name|CHDRLEN
expr_stmt|;
block|}
block|}
comment|/* Get the checksum into abcksum.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iget
operator|=
operator|(
name|iPrecstart
operator|+
name|CHDRLEN
operator|+
name|csize
operator|)
operator|%
name|CRECBUFLEN
init|;
name|i
operator|<
name|CCKSUMLEN
condition|;
name|i
operator|++
operator|,
name|iget
operator|=
operator|(
name|iget
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
control|)
name|abcksum
index|[
name|i
index|]
operator|=
name|abPrecbuf
index|[
name|iget
index|]
expr_stmt|;
name|ickdata
operator|=
name|icrc
argument_list|(
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|,
name|ICRCINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|csecond
operator|>
literal|0
condition|)
name|ickdata
operator|=
name|icrc
argument_list|(
name|zsecond
argument_list|,
operator|(
name|size_t
operator|)
name|csecond
argument_list|,
name|ickdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICKSUM_GET
argument_list|(
name|abcksum
argument_list|)
operator|!=
name|ickdata
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_data: Bad checksum; data %lu, frame %lu"
argument_list|,
name|ickdata
argument_list|,
name|ICKSUM_GET
argument_list|(
name|abcksum
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|cIbad_cksum
expr_stmt|;
if|if
condition|(
operator|!
name|ficheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If this sequence number is in our receive window, 		 send a NAK.  iIrecseq is the last sequence number we 		 have succesfully received.  */
if|if
condition|(
name|iseq
operator|!=
operator|-
literal|1
operator|&&
name|iseq
operator|!=
name|iIrecseq
operator|&&
operator|(
name|iIrequest_winsize
operator|<=
literal|0
operator|||
name|CSEQDIFF
argument_list|(
name|iseq
argument_list|,
name|iIrecseq
argument_list|)
operator|<=
name|iIrequest_winsize
operator|)
operator|&&
name|azIrecbuffers
index|[
name|iseq
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|finak
argument_list|(
name|qdaemon
argument_list|,
name|iseq
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Here we know that this is a valid packet, so we can adjust 	 iPrecstart accordingly.  */
if|if
condition|(
name|csize
operator|==
literal|0
condition|)
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|CHDRLEN
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
else|else
block|{
name|iPrecstart
operator|=
operator|(
operator|(
name|iPrecstart
operator|+
name|CHDRLEN
operator|+
name|csize
operator|+
name|CCKSUMLEN
operator|)
operator|%
name|CRECBUFLEN
operator|)
expr_stmt|;
operator|++
name|cIreceived_packets
expr_stmt|;
block|}
comment|/* Get the ack from the packet, if appropriate.  iIsendseq is 	 the next sequence number we are going to send, and 	 iIremote_ack is the last sequence number acknowledged by the 	 remote system.  */
name|iack
operator|=
name|IHDRWIN_GETSEQ
argument_list|(
name|ab
index|[
name|IHDR_REMOTE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iIremote_winsize
operator|>
literal|0
operator|&&
name|iack
operator|!=
name|iIsendseq
operator|&&
name|CSEQDIFF
argument_list|(
name|iack
argument_list|,
name|iIremote_ack
argument_list|)
operator|<=
name|iIremote_winsize
operator|&&
name|CSEQDIFF
argument_list|(
name|iIsendseq
argument_list|,
name|iack
argument_list|)
operator|<=
name|iIremote_winsize
condition|)
block|{
comment|/* Call uwindow_acked each time packet 0 is acked.  */
if|if
condition|(
name|iack
operator|<
name|iIremote_ack
condition|)
name|uwindow_acked
argument_list|(
name|qdaemon
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|iIremote_ack
operator|=
name|iack
expr_stmt|;
block|}
if|if
condition|(
name|iseq
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If we already sent a NAK for this packet, and we have not 	     seen the previous packet, then forget that we sent a NAK 	     for this and any preceding packets.  This is to handle 	     the following sequence: 	         receive packet 0 		 packets 1 and 2 lost 		 receive packet 3 		 send NAK 1 		 send NAK 2 		 packet 1 lost 		 receive packet 2 	     At this point we want to send NAK 1.  */
if|if
condition|(
name|afInaked
index|[
name|iseq
index|]
operator|&&
name|azIrecbuffers
index|[
name|IPREVSEQ
argument_list|(
name|iseq
argument_list|)
index|]
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|INEXTSEQ
argument_list|(
name|iIrecseq
argument_list|)
init|;
name|i
operator|!=
name|iseq
condition|;
name|i
operator|=
name|INEXTSEQ
argument_list|(
name|i
argument_list|)
control|)
name|afInaked
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|afInaked
index|[
name|iseq
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* If we haven't handled all previous packets, we must save 	     off this packet and deal with it later.  */
if|if
condition|(
name|iseq
operator|!=
name|INEXTSEQ
argument_list|(
name|iIrecseq
argument_list|)
condition|)
block|{
if|if
condition|(
name|iseq
operator|==
name|iIrecseq
operator|||
operator|(
name|iIrequest_winsize
operator|>
literal|0
operator|&&
name|CSEQDIFF
argument_list|(
name|iseq
argument_list|,
name|iIrecseq
argument_list|)
operator|>
name|iIrequest_winsize
operator|)
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_data: Ignoring out of order packet %d (recseq %d)"
argument_list|,
name|iseq
argument_list|,
name|iIrecseq
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_data: Saving unexpected packet %d (recseq %d)"
argument_list|,
name|iseq
argument_list|,
name|iIrecseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|azIrecbuffers
index|[
name|iseq
index|]
operator|==
name|NULL
condition|)
block|{
name|azIrecbuffers
index|[
name|iseq
index|]
operator|=
name|zbufalc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|CHDRLEN
operator|+
name|csize
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|azIrecbuffers
index|[
name|iseq
index|]
argument_list|,
name|ab
argument_list|,
name|CHDRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|azIrecbuffers
index|[
name|iseq
index|]
operator|+
name|CHDRLEN
argument_list|,
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|csecond
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|azIrecbuffers
index|[
name|iseq
index|]
operator|+
name|CHDRLEN
operator|+
name|cfirst
argument_list|,
name|zsecond
argument_list|,
operator|(
name|size_t
operator|)
name|csecond
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Send NAK's for each packet between the last one we 		 received and this one, avoiding any packets for which 		 we've already sent NAK's or which we've already 		 received.  */
for|for
control|(
name|i
operator|=
name|INEXTSEQ
argument_list|(
name|iIrecseq
argument_list|)
init|;
name|i
operator|!=
name|iseq
condition|;
name|i
operator|=
name|INEXTSEQ
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|afInaked
index|[
name|i
index|]
operator|&&
name|azIrecbuffers
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|finak
argument_list|(
name|qdaemon
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
continue|continue;
block|}
name|iIrecseq
operator|=
name|iseq
expr_stmt|;
block|}
if|if
condition|(
name|pffound
operator|!=
name|NULL
condition|)
operator|*
name|pffound
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fiprocess_packet
argument_list|(
name|qdaemon
argument_list|,
name|ab
argument_list|,
name|zfirst
argument_list|,
name|cfirst
argument_list|,
name|zsecond
argument_list|,
name|csecond
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|iseq
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|inext
decl_stmt|;
comment|/* If we've already received the next packet(s), process 	     them.  */
name|inext
operator|=
name|INEXTSEQ
argument_list|(
name|iIrecseq
argument_list|)
expr_stmt|;
while|while
condition|(
name|azIrecbuffers
index|[
name|inext
index|]
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
name|z
operator|=
name|azIrecbuffers
index|[
name|inext
index|]
expr_stmt|;
name|c
operator|=
name|CHDRCON_GETBYTES
argument_list|(
name|z
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|z
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
expr_stmt|;
name|iIrecseq
operator|=
name|inext
expr_stmt|;
if|if
condition|(
operator|!
name|fiprocess_packet
argument_list|(
name|qdaemon
argument_list|,
name|z
argument_list|,
name|z
operator|+
name|CHDRLEN
argument_list|,
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ubuffree
argument_list|(
name|azIrecbuffers
index|[
name|inext
index|]
argument_list|)
expr_stmt|;
name|azIrecbuffers
index|[
name|inext
index|]
operator|=
name|NULL
expr_stmt|;
name|inext
operator|=
name|INEXTSEQ
argument_list|(
name|inext
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have received half of our window size or more since the 	 last ACK, send one now.  Sending an ACK for half the window 	 at a time should significantly cut the acknowledgement 	 traffic when only one side is sending.  We should normally 	 not have to send an ACK if we have data to send, since each 	 packet sent will ACK the most recently received packet. 	 However, it can happen if we receive a burst of short 	 packets, such as a set of command acknowledgements.  */
if|if
condition|(
name|iIrequest_winsize
operator|>
literal|0
operator|&&
name|CSEQDIFF
argument_list|(
name|iIrecseq
argument_list|,
name|iIlocal_ack
argument_list|)
operator|>=
name|cIack_frequency
condition|)
block|{
name|char
name|aback
index|[
name|CHDRLEN
index|]
decl_stmt|;
name|aback
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|aback
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aback
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|aback
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|ACK
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aback
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|ACK
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aback
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|aback
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_data: Sending ACK %d"
argument_list|,
name|iIrecseq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|aback
argument_list|,
name|CHDRLEN
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CHDRLEN
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Process a single packet.  */
end_comment

begin_function
specifier|static
name|boolean
name|fiprocess_packet
parameter_list|(
name|qdaemon
parameter_list|,
name|zhdr
parameter_list|,
name|zfirst
parameter_list|,
name|cfirst
parameter_list|,
name|zsecond
parameter_list|,
name|csecond
parameter_list|,
name|pfexit
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfirst
decl_stmt|;
name|int
name|cfirst
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsecond
decl_stmt|;
name|int
name|csecond
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
block|{
name|int
name|ttype
decl_stmt|;
name|ttype
operator|=
name|THDRCON_GETTYPE
argument_list|(
name|zhdr
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|zhdr
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ttype
condition|)
block|{
case|case
name|DATA
case|:
block|{
name|int
name|iseq
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|iseq
operator|=
name|IHDRWIN_GETSEQ
argument_list|(
name|zhdr
index|[
name|IHDR_LOCAL
index|]
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Got DATA packet %d size %d local %d remote %d"
argument_list|,
name|iseq
argument_list|,
name|cfirst
operator|+
name|csecond
argument_list|,
name|IHDRWIN_GETCHAN
argument_list|(
name|zhdr
index|[
name|IHDR_REMOTE
index|]
argument_list|)
argument_list|,
name|IHDRWIN_GETCHAN
argument_list|(
name|zhdr
index|[
name|IHDR_LOCAL
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|,
name|zsecond
argument_list|,
operator|(
name|size_t
operator|)
name|csecond
argument_list|,
name|IHDRWIN_GETCHAN
argument_list|(
name|zhdr
index|[
name|IHDR_REMOTE
index|]
argument_list|)
argument_list|,
name|IHDRWIN_GETCHAN
argument_list|(
name|zhdr
index|[
name|IHDR_LOCAL
index|]
argument_list|)
argument_list|,
name|iIrecpos
argument_list|,
name|INEXTSEQ
argument_list|(
name|iIremote_ack
argument_list|)
operator|==
name|iIsendseq
argument_list|,
name|pfexit
argument_list|)
expr_stmt|;
name|iIrecpos
operator|+=
name|cfirst
operator|+
name|csecond
expr_stmt|;
return|return
name|fret
return|;
block|}
case|case
name|SYNC
case|:
block|{
name|int
name|ipack
decl_stmt|,
name|iwin
decl_stmt|,
name|cchans
decl_stmt|;
comment|/* We accept a SYNC packet to adjust the packet and window 	   sizes at any time.  */
if|if
condition|(
name|cfirst
operator|+
name|csecond
operator|<
literal|3
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad SYNC packet"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ipack
operator|=
operator|(
name|zfirst
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
literal|1
condition|)
name|ipack
operator||=
name|zfirst
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
else|else
name|ipack
operator||=
name|zsecond
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
literal|2
condition|)
name|iwin
operator|=
name|zfirst
index|[
literal|2
index|]
expr_stmt|;
else|else
name|iwin
operator|=
name|zsecond
index|[
literal|2
operator|-
name|cfirst
index|]
expr_stmt|;
comment|/* The fourth byte in a SYNC packet is the number of channels 	   to use.  This is optional.  Switching the number of 	   channels in the middle of a conversation may cause 	   problems.  */
if|if
condition|(
name|cfirst
operator|+
name|csecond
operator|<=
literal|3
condition|)
name|cchans
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cfirst
operator|>
literal|3
condition|)
name|cchans
operator|=
name|zfirst
index|[
literal|3
index|]
expr_stmt|;
else|else
name|cchans
operator|=
name|zsecond
index|[
literal|3
operator|-
name|cfirst
index|]
expr_stmt|;
if|if
condition|(
name|cchans
operator|>
literal|0
operator|&&
name|cchans
operator|<
literal|8
condition|)
name|qdaemon
operator|->
name|cchans
operator|=
name|cchans
expr_stmt|;
block|}
name|DEBUG_MESSAGE3
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Got SYNC packsize %d winsize %d channels %d"
argument_list|,
name|ipack
argument_list|,
name|iwin
argument_list|,
name|cchans
argument_list|)
expr_stmt|;
if|if
condition|(
name|iIforced_remote_packsize
operator|==
literal|0
operator|&&
operator|(
name|iIalc_packsize
operator|==
literal|0
operator|||
name|ipack
operator|<=
name|iIalc_packsize
operator|)
condition|)
name|iIremote_packsize
operator|=
name|ipack
expr_stmt|;
name|iIremote_winsize
operator|=
name|iwin
expr_stmt|;
comment|/* We increment a static variable to tell the initialization 	   code that a SYNC was received, and we set *pfexit to TRUE 	   to get out to the initialization code (this will do no harm 	   if we are called from elsewhere).  */
operator|++
name|cIsyncs
expr_stmt|;
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
case|case
name|ACK
case|:
comment|/* There is nothing to do here, since the ack was already 	 handled in fiprocess_data.  */
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Got ACK %d"
argument_list|,
name|IHDRWIN_GETSEQ
argument_list|(
name|zhdr
index|[
name|IHDR_REMOTE
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|NAK
case|:
comment|/* We must resend the requested packet.  */
block|{
name|int
name|iseq
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
operator|++
name|cIremote_rejects
expr_stmt|;
if|if
condition|(
operator|!
name|ficheck_errors
argument_list|(
name|qdaemon
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iseq
operator|=
name|IHDRWIN_GETSEQ
argument_list|(
name|zhdr
index|[
name|IHDR_LOCAL
index|]
argument_list|)
expr_stmt|;
comment|/* If the remote side times out while waiting for a packet, it 	   will send a NAK for the next packet it wants to see.  If we 	   have not sent that packet yet, and we have no 	   unacknowledged data, it implies that the remote side has a 	   window full of data to send, which implies that our ACK has 	   been lost.  Therefore, we send an ACK.  */
if|if
condition|(
name|iseq
operator|==
name|iIsendseq
operator|&&
name|INEXTSEQ
argument_list|(
name|iIremote_ack
argument_list|)
operator|==
name|iIsendseq
condition|)
block|{
name|char
name|aback
index|[
name|CHDRLEN
index|]
decl_stmt|;
name|aback
index|[
name|IHDR_INTRO
index|]
operator|=
name|IINTRO
expr_stmt|;
name|aback
index|[
name|IHDR_LOCAL
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aback
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
name|aback
index|[
name|IHDR_CONTENTS1
index|]
operator|=
name|IHDRCON_SET1
argument_list|(
name|ACK
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aback
index|[
name|IHDR_CONTENTS2
index|]
operator|=
name|IHDRCON_SET2
argument_list|(
name|ACK
argument_list|,
name|qdaemon
operator|->
name|fcaller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aback
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|aback
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Sending ACK %d"
argument_list|,
name|iIrecseq
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|aback
argument_list|,
name|CHDRLEN
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|iseq
operator|==
name|iIsendseq
operator|||
operator|(
name|iIremote_winsize
operator|>
literal|0
operator|&&
operator|(
name|CSEQDIFF
argument_list|(
name|iseq
argument_list|,
name|iIremote_ack
argument_list|)
operator|>
name|iIremote_winsize
operator|||
name|CSEQDIFF
argument_list|(
name|iIsendseq
argument_list|,
name|iseq
argument_list|)
operator|>
name|iIremote_winsize
operator|)
operator|)
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_packet: Ignoring out of order NAK %d (sendseq %d)"
argument_list|,
name|iseq
argument_list|,
name|iIsendseq
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fiprocess_packet: Got NAK %d; resending packet"
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
comment|/* Update the received sequence number.  */
name|zsend
operator|=
name|azIsendbuffers
index|[
name|iseq
index|]
operator|+
name|CHDROFFSET
expr_stmt|;
if|if
condition|(
name|IHDRWIN_GETSEQ
argument_list|(
name|zsend
index|[
name|IHDR_REMOTE
index|]
argument_list|)
operator|!=
name|iIrecseq
condition|)
block|{
name|int
name|iremote
decl_stmt|;
name|iremote
operator|=
name|IHDRWIN_GETCHAN
argument_list|(
name|zsend
index|[
name|IHDR_REMOTE
index|]
argument_list|)
expr_stmt|;
name|zsend
index|[
name|IHDR_REMOTE
index|]
operator|=
name|IHDRWIN_SET
argument_list|(
name|iIrecseq
argument_list|,
name|iremote
argument_list|)
expr_stmt|;
name|zsend
index|[
name|IHDR_CHECK
index|]
operator|=
name|IHDRCHECK_VAL
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
name|iIlocal_ack
operator|=
name|iIrecseq
expr_stmt|;
block|}
operator|++
name|cIresent_packets
expr_stmt|;
name|clen
operator|=
name|CHDRCON_GETBYTES
argument_list|(
name|zsend
index|[
name|IHDR_CONTENTS1
index|]
argument_list|,
name|zsend
index|[
name|IHDR_CONTENTS2
index|]
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|pfIsend
call|)
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zsend
argument_list|,
name|CHDRLEN
operator|+
name|clen
operator|+
operator|(
name|clen
operator|>
literal|0
condition|?
name|CCKSUMLEN
else|:
literal|0
operator|)
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
block|}
case|case
name|SPOS
case|:
comment|/* Set the file position.  */
block|{
name|char
name|abpos
index|[
name|CCKSUMLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpos
decl_stmt|;
if|if
condition|(
name|cfirst
operator|>=
name|CCKSUMLEN
condition|)
name|zpos
operator|=
name|zfirst
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|abpos
argument_list|,
name|zfirst
argument_list|,
operator|(
name|size_t
operator|)
name|cfirst
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|abpos
operator|+
name|cfirst
argument_list|,
name|zsecond
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|CCKSUMLEN
operator|-
name|cfirst
argument_list|)
argument_list|)
expr_stmt|;
name|zpos
operator|=
name|abpos
expr_stmt|;
block|}
name|iIrecpos
operator|=
operator|(
name|long
operator|)
name|ICKSUM_GET
argument_list|(
name|zpos
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Got SPOS %ld"
argument_list|,
name|iIrecpos
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
case|case
name|CLOSE
case|:
block|{
name|boolean
name|fexpected
decl_stmt|;
name|fexpected
operator|=
operator|!
name|fLog_sighup
operator|||
name|fIclosing
expr_stmt|;
if|if
condition|(
operator|!
name|fexpected
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Received unexpected CLOSE packet"
argument_list|)
expr_stmt|;
else|else
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Got CLOSE packet"
argument_list|)
expr_stmt|;
name|fIclosing
operator|=
name|TRUE
expr_stmt|;
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
return|return
name|fexpected
return|;
block|}
default|default:
comment|/* Just ignore unrecognized packet types, for future protocol 	 enhancements.  */
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fiprocess_packet: Got packet type %d"
argument_list|,
name|ttype
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

end_unit

