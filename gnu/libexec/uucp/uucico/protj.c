begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* protj.c    The 'j' protocol.     Copyright (C) 1992, 1994 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|protj_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The 'j' protocol.     The 'j' protocol is a wrapper around the 'i' protocol, which avoids    the use of certain characters, such as XON and XOFF.     Each 'j' protocol packet begins with a '^' character, followed by a    two byte encoded size giving the total number of bytes in the    packet.  The first byte is HIGH, the second byte is LOW, and the    number of bytes is (HIGH - 32) * 64 + (LOW - 32), where 32<= HIGH< 127 and 32<= LOW< 96 (i.e., HIGH and LOW are printable ASCII    characters).  This is followed by a '=' character.  The next two    bytes are the number of data bytes in the packet, using the same    encoding.  This is followed by a '@' character, and then that    number of data bytes.  The remaining bytes in the packet are    indices of bytes which must be transformed, followed by a trailing    '~' character.  The indices are encoded in the following overly    complex format.     Each byte index is two bytes long.  The first byte in the index is    INDEX-HIGH and the second is INDEX-LOW.  If 32<= INDEX-HIGH< 126,    the byte index refers to the byte at position (INDEX-HIGH - 32) *    32 + INDEX-LOW % 32 in the actual data, where 32<= INDEX-LOW<    127.  If 32<= INDEX-LOW< 64, then 128 must be added to the    indexed byte.  If 64<= INDEX-LOW< 96, then the indexed byte must    be exclusive or'red with 32.  If 96<= INDEX-LOW< 127, both    operations must be performed.  If INDEX-HIGH == 126, then the byte    index refers to the byte at position (INDEX-LOW - 32) * 32 + 31,    where 32<= INDEX-LOW< 126.  128 must be added to the byte, and it    must be exclusive or'red with 32.  This unfortunately requires a    special test (when encoding INDEX-LOW must be checked for 127; when    decoding INDEX-HIGH must be checked for 126).  It does, however,    permit the byte indices field to consist exclusively of printable    ASCII characters.     The maximum value for a byte index is (125 - 32) * 32 + 31 == 3007,    so the is the maximum number of data bytes permitted.  Since it is    convenient to have each 'j' protocol packet correspond to each 'i'    protocol packet, we restrict the 'i' protocol accordingly.     Note that this encoding method assumes that we can send all    printable ASCII characters.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The first byte of each packet.  I just picked these values    randomly, trying to get characters that were perhaps slightly less    likely to appear in normal text.  */
end_comment

begin_define
define|#
directive|define
name|FIRST
value|'\136'
end_define

begin_comment
comment|/* The fourth byte of each packet.  */
end_comment

begin_define
define|#
directive|define
name|FOURTH
value|'\075'
end_define

begin_comment
comment|/* The seventh byte of each packet.  */
end_comment

begin_define
define|#
directive|define
name|SEVENTH
value|'\100'
end_define

begin_comment
comment|/* The trailing byte of each packet.  */
end_comment

begin_define
define|#
directive|define
name|TRAILER
value|'\176'
end_define

begin_comment
comment|/* The length of the header.  */
end_comment

begin_define
define|#
directive|define
name|CHDRLEN
value|(7)
end_define

begin_comment
comment|/* Get a number of bytes encoded in a two byte length at the start of    a packet.  */
end_comment

begin_define
define|#
directive|define
name|CGETLENGTH
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
value|(((b1) - 32) * 64 + ((b2) - 32))
end_define

begin_comment
comment|/* Set the high and low bytes of a two byte length at the start of a    packet.  */
end_comment

begin_define
define|#
directive|define
name|ISETLENGTH_FIRST
parameter_list|(
name|i
parameter_list|)
value|((i) / 64 + 32)
end_define

begin_define
define|#
directive|define
name|ISETLENGTH_SECOND
parameter_list|(
name|i
parameter_list|)
value|((i) % 64 + 32)
end_define

begin_comment
comment|/* The maximum packet size we support, as determined by the byte    indices.  */
end_comment

begin_define
define|#
directive|define
name|IMAXPACKSIZE
value|((125 - 32) * 32 + 31)
end_define

begin_comment
comment|/* Amount to offset the bytes in the byte index by.  */
end_comment

begin_define
define|#
directive|define
name|INDEX_OFFSET
value|(32)
end_define

begin_comment
comment|/* Maximum value of INDEX-LOW, before offsetting.  */
end_comment

begin_define
define|#
directive|define
name|INDEX_MAX_LOW
value|(32)
end_define

begin_comment
comment|/* Maximum value of INDEX-HIGH, before offsetting. */
end_comment

begin_define
define|#
directive|define
name|INDEX_MAX_HIGH
value|(94)
end_define

begin_comment
comment|/* The set of characters to avoid.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zJavoid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters to avoid.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|cJavoid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A buffer used when sending data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zJbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The end of the undecoded data in abPrecbuf.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iJrecend
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fjsend_data
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
name|char
operator|*
name|zsend
operator|,
name|size_t
name|csend
operator|,
name|boolean
name|fdoread
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fjreceive_data
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|size_t
name|cneed
operator|,
name|size_t
operator|*
name|pcrec
operator|,
name|int
name|ctimeout
operator|,
name|boolean
name|freport
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fjprocess_data
name|P
argument_list|(
operator|(
name|size_t
operator|*
name|pcneed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start the protocol.  We first send over the list of characters to    avoid as an escape sequence, starting with FIRST and ending with    TRAILER.  There is no error checking done on this string.  */
end_comment

begin_function
name|boolean
name|fjstart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
name|size_t
name|clen
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
name|int
name|b
decl_stmt|;
name|size_t
name|cbuf
decl_stmt|,
name|cgot
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Send the characters we want to avoid to the other side.  */
name|clen
operator|=
name|strlen
argument_list|(
name|zJavoid_parameter
argument_list|)
expr_stmt|;
name|zsend
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|zsend
index|[
literal|0
index|]
operator|=
name|FIRST
expr_stmt|;
name|memcpy
argument_list|(
name|zsend
operator|+
literal|1
argument_list|,
name|zJavoid_parameter
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zsend
index|[
name|clen
operator|+
literal|1
index|]
operator|=
name|TRAILER
expr_stmt|;
name|zsend
index|[
name|clen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zsend
argument_list|,
name|clen
operator|+
literal|2
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zsend
argument_list|)
expr_stmt|;
comment|/* Read the characters the other side wants to avoid.  */
while|while
condition|(
operator|(
name|b
operator|=
name|breceive_char
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|cIsync_timeout
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|FIRST
condition|)
block|{
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out in 'j' protocol startup"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|cbuf
operator|=
literal|20
expr_stmt|;
name|zbuf
operator|=
name|zbufalc
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|cgot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|breceive_char
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|cIsync_timeout
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|TRAILER
condition|)
block|{
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out in 'j' protocol startup"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|cgot
operator|+
literal|1
operator|>=
name|cbuf
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|cbuf
operator|+=
literal|20
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
name|zbuf
argument_list|,
name|cgot
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
name|zbuf
operator|=
name|znew
expr_stmt|;
block|}
name|zbuf
index|[
name|cgot
index|]
operator|=
name|b
expr_stmt|;
operator|++
name|cgot
expr_stmt|;
block|}
name|zbuf
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Merge the local and remote avoid bytes into one list, translated      into bytes.  */
name|cgot
operator|=
name|cescape
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zJavoid_parameter
argument_list|)
expr_stmt|;
name|zJavoid
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
name|cgot
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zJavoid
argument_list|,
name|zJavoid_parameter
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cJavoid
operator|=
name|cescape
argument_list|(
name|zJavoid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cgot
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memchr
argument_list|(
name|zJavoid
argument_list|,
name|zbuf
index|[
name|i
index|]
argument_list|,
name|cJavoid
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zJavoid
index|[
name|cJavoid
index|]
operator|=
name|zbuf
index|[
name|i
index|]
expr_stmt|;
operator|++
name|cJavoid
expr_stmt|;
block|}
block|}
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
comment|/* We can't avoid ASCII printable characters, since the encoding      method assumes that they can always be sent.  If it ever turns      out to be important, a different encoding method could be used,      perhaps keyed by a different FIRST character.  */
if|if
condition|(
name|cJavoid
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No characters to avoid in 'j' protocol"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cJavoid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zJavoid
index|[
name|i
index|]
operator|>=
literal|32
operator|&&
name|zJavoid
index|[
name|i
index|]
operator|<=
literal|126
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"'j' protocol can't avoid character '\\%03o'"
argument_list|,
name|zJavoid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If we are avoiding XON and XOFF, use XON/XOFF handshaking.  */
if|if
condition|(
name|memchr
argument_list|(
name|zJavoid
argument_list|,
literal|'\021'
argument_list|,
name|cJavoid
argument_list|)
operator|!=
name|NULL
operator|&&
name|memchr
argument_list|(
name|zJavoid
argument_list|,
literal|'\023'
argument_list|,
name|cJavoid
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|PARITYSETTING_NONE
argument_list|,
name|STRIPSETTING_EIGHTBITS
argument_list|,
name|XONXOFF_ON
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Let the port settle.  */
name|usysdep_sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Allocate a buffer we use when sending data.  We will probably      never actually need one this big; if this code is ported to a      computer with small amounts of memory, this should be changed to      increase the buffer size as needed.  */
name|zJbuf
operator|=
name|zbufalc
argument_list|(
name|CHDRLEN
operator|+
name|IMAXPACKSIZE
operator|*
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zJbuf
index|[
literal|0
index|]
operator|=
name|FIRST
expr_stmt|;
name|zJbuf
index|[
literal|3
index|]
operator|=
name|FOURTH
expr_stmt|;
name|zJbuf
index|[
literal|6
index|]
operator|=
name|SEVENTH
expr_stmt|;
comment|/* iJrecend is the end of the undecoded data, and iPrecend is the      end of the decoded data.  At this point there is no decoded data,      and we must initialize the variables accordingly.  */
name|iJrecend
operator|=
name|iPrecend
expr_stmt|;
name|iPrecend
operator|=
name|iPrecstart
expr_stmt|;
comment|/* Now do the 'i' protocol startup.  */
return|return
name|fijstart
argument_list|(
name|qdaemon
argument_list|,
name|pzlog
argument_list|,
name|IMAXPACKSIZE
argument_list|,
name|fjsend_data
argument_list|,
name|fjreceive_data
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shut down the protocol.  */
end_comment

begin_function
name|boolean
name|fjshutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|fret
operator|=
name|fishutdown
argument_list|(
name|qdaemon
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zJavoid
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zJbuf
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Encode a packet of data and send it.  This copies the data, which    is a waste of time, but calling fsend_data three times (for the    header, the body, and the trailer) would waste even more time.  */
end_comment

begin_function
specifier|static
name|boolean
name|fjsend_data
parameter_list|(
name|qconn
parameter_list|,
name|zsend
parameter_list|,
name|csend
parameter_list|,
name|fdoread
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsend
decl_stmt|;
name|size_t
name|csend
decl_stmt|;
name|boolean
name|fdoread
decl_stmt|;
block|{
name|char
modifier|*
name|zput
decl_stmt|,
modifier|*
name|zindex
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|,
modifier|*
name|zend
decl_stmt|;
name|char
name|bfirst
decl_stmt|,
name|bsecond
decl_stmt|;
name|int
name|iprecendhold
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zput
operator|=
name|zJbuf
operator|+
name|CHDRLEN
expr_stmt|;
name|zindex
operator|=
name|zput
operator|+
name|csend
expr_stmt|;
name|zfrom
operator|=
name|zsend
expr_stmt|;
name|zend
operator|=
name|zsend
operator|+
name|csend
expr_stmt|;
comment|/* Optimize for the common case of avoiding two characters.  */
name|bfirst
operator|=
name|zJavoid
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cJavoid
operator|<=
literal|1
condition|)
name|bsecond
operator|=
name|bfirst
expr_stmt|;
else|else
name|bsecond
operator|=
name|zJavoid
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|zfrom
operator|<
name|zend
condition|)
block|{
name|char
name|b
decl_stmt|;
name|boolean
name|f128
decl_stmt|,
name|f32
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ihigh
decl_stmt|,
name|ilow
decl_stmt|;
name|b
operator|=
operator|*
name|zfrom
operator|++
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|bfirst
operator|&&
name|b
operator|!=
name|bsecond
condition|)
block|{
name|int
name|ca
decl_stmt|;
name|char
modifier|*
name|za
decl_stmt|;
if|if
condition|(
name|cJavoid
operator|<=
literal|2
condition|)
block|{
operator|*
name|zput
operator|++
operator|=
name|b
expr_stmt|;
continue|continue;
block|}
name|ca
operator|=
name|cJavoid
operator|-
literal|2
expr_stmt|;
name|za
operator|=
name|zJavoid
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|ca
operator|--
operator|!=
literal|0
condition|)
if|if
condition|(
operator|*
name|za
operator|++
operator|==
name|b
condition|)
break|break;
if|if
condition|(
name|ca
operator|<
literal|0
condition|)
block|{
operator|*
name|zput
operator|++
operator|=
name|b
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|f128
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|b
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|f128
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|>=
literal|32
operator|&&
name|b
operator|!=
literal|127
condition|)
name|f32
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|b
operator|^=
literal|0x20
expr_stmt|;
name|f32
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We must now put the byte index into the buffer.  The byte 	 index is encoded similarly to the length of the actual data, 	 but the byte index also encodes the operations that must be 	 performed on the byte.  The first byte in the index is the 	 most significant bits.  If we only had to subtract 128 from 	 the byte, we use the second byte directly.  If we had to xor 	 the byte with 32, we add 32 to the second byte index.  If we 	 had to perform both operations, we add 64 to the second byte 	 index.  However, if we had to perform both operations, and 	 the second byte index was 31, then after adding 64 and 	 offsetting by 32 we would come up with 127, which we are not 	 permitted to use.  Therefore, in this special case we set the 	 first byte of the index to 126 and put the original first 	 byte into the second byte position instead.  This is why we 	 could not permit the high byte of the length of the actual 	 data to be 126.  We can get away with the switch because both 	 the value of the second byte index (31) and the operations to 	 perform (both) are known.  */
name|i
operator|=
name|zput
operator|-
operator|(
name|zJbuf
operator|+
name|CHDRLEN
operator|)
expr_stmt|;
name|ihigh
operator|=
name|i
operator|/
name|INDEX_MAX_LOW
expr_stmt|;
name|ilow
operator|=
name|i
operator|%
name|INDEX_MAX_LOW
expr_stmt|;
if|if
condition|(
name|f128
operator|&&
operator|!
name|f32
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|f32
operator|&&
operator|!
name|f128
condition|)
name|ilow
operator|+=
name|INDEX_MAX_LOW
expr_stmt|;
else|else
block|{
comment|/* Both operations had to be performed.  */
if|if
condition|(
name|ilow
operator|!=
name|INDEX_MAX_LOW
operator|-
literal|1
condition|)
name|ilow
operator|+=
literal|2
operator|*
name|INDEX_MAX_LOW
expr_stmt|;
else|else
block|{
name|ilow
operator|=
name|ihigh
expr_stmt|;
name|ihigh
operator|=
name|INDEX_MAX_HIGH
expr_stmt|;
block|}
block|}
operator|*
name|zindex
operator|++
operator|=
name|ihigh
operator|+
name|INDEX_OFFSET
expr_stmt|;
operator|*
name|zindex
operator|++
operator|=
name|ilow
operator|+
name|INDEX_OFFSET
expr_stmt|;
operator|*
name|zput
operator|++
operator|=
name|b
expr_stmt|;
block|}
operator|*
name|zindex
operator|++
operator|=
name|TRAILER
expr_stmt|;
comment|/* Set the lengths into the buffer.  zJbuf[0,3,6] were set when      zJbuf was allocated, and are never changed thereafter.  */
name|zJbuf
index|[
literal|1
index|]
operator|=
name|ISETLENGTH_FIRST
argument_list|(
name|zindex
operator|-
name|zJbuf
argument_list|)
expr_stmt|;
name|zJbuf
index|[
literal|2
index|]
operator|=
name|ISETLENGTH_SECOND
argument_list|(
name|zindex
operator|-
name|zJbuf
argument_list|)
expr_stmt|;
name|zJbuf
index|[
literal|4
index|]
operator|=
name|ISETLENGTH_FIRST
argument_list|(
name|csend
argument_list|)
expr_stmt|;
name|zJbuf
index|[
literal|5
index|]
operator|=
name|ISETLENGTH_SECOND
argument_list|(
name|csend
argument_list|)
expr_stmt|;
comment|/* Send the data over the line.  We must preserve iPrecend as      discussed in fjreceive_data.  */
name|iprecendhold
operator|=
name|iPrecend
expr_stmt|;
name|iPrecend
operator|=
name|iJrecend
expr_stmt|;
name|fret
operator|=
name|fsend_data
argument_list|(
name|qconn
argument_list|,
name|zJbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|zindex
operator|-
name|zJbuf
argument_list|)
argument_list|,
name|fdoread
argument_list|)
expr_stmt|;
name|iJrecend
operator|=
name|iPrecend
expr_stmt|;
name|iPrecend
operator|=
name|iprecendhold
expr_stmt|;
comment|/* Process any bytes that may have been placed in abPrecbuf.  */
if|if
condition|(
name|fret
operator|&&
name|iPrecend
operator|!=
name|iJrecend
condition|)
block|{
if|if
condition|(
operator|!
name|fjprocess_data
argument_list|(
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Receive and decode data.  This is called by fiwait_for_packet.  We    need to be able to return decoded data between iPrecstart and    iPrecend, while not losing any undecoded partial packets we may    have read.  We use iJrecend as a pointer to the end of the    undecoded data, and set iPrecend for the decoded data.  iPrecend    points to the start of the undecoded data.  */
end_comment

begin_function
specifier|static
name|boolean
name|fjreceive_data
parameter_list|(
name|qconn
parameter_list|,
name|cineed
parameter_list|,
name|pcrec
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|size_t
name|cineed
decl_stmt|;
name|size_t
modifier|*
name|pcrec
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
name|int
name|iprecendstart
decl_stmt|;
name|size_t
name|cjneed
decl_stmt|;
name|size_t
name|crec
decl_stmt|;
name|int
name|cnew
decl_stmt|;
name|iprecendstart
operator|=
name|iPrecend
expr_stmt|;
comment|/* Figure out how many bytes we need to decode the next packet.  */
if|if
condition|(
operator|!
name|fjprocess_data
argument_list|(
operator|&
name|cjneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* As we long as we read some data but don't have enough to decode a      packet, we try to read some more.  We decrease the timeout each      time so that we will not wait forever if the connection starts      dribbling data.  */
do|do
block|{
name|int
name|iprecendhold
decl_stmt|;
name|size_t
name|cneed
decl_stmt|;
if|if
condition|(
name|cjneed
operator|>
name|cineed
condition|)
name|cneed
operator|=
name|cjneed
expr_stmt|;
else|else
name|cneed
operator|=
name|cineed
expr_stmt|;
comment|/* We are setting iPrecend to the end of the decoded data for 	 the 'i' protocol.  When we do the actual read, we have to set 	 it to the end of the undecoded data so that any undecoded 	 data we have received is not overwritten.  */
name|iprecendhold
operator|=
name|iPrecend
expr_stmt|;
name|iPrecend
operator|=
name|iJrecend
expr_stmt|;
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qconn
argument_list|,
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|ctimeout
argument_list|,
name|freport
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iJrecend
operator|=
name|iPrecend
expr_stmt|;
name|iPrecend
operator|=
name|iprecendhold
expr_stmt|;
comment|/* Process any data we have received.  This will set iPrecend to 	 the end of the new decoded data.  */
if|if
condition|(
operator|!
name|fjprocess_data
argument_list|(
operator|&
name|cjneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cnew
operator|=
name|iPrecend
operator|-
name|iprecendstart
expr_stmt|;
if|if
condition|(
name|cnew
operator|<
literal|0
condition|)
name|cnew
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|cnew
operator|>
name|cineed
condition|)
name|cineed
operator|=
literal|0
expr_stmt|;
else|else
name|cineed
operator|-=
name|cnew
expr_stmt|;
operator|--
name|ctimeout
expr_stmt|;
block|}
do|while
condition|(
name|cnew
operator|==
literal|0
operator|&&
name|crec
operator|>
literal|0
operator|&&
name|ctimeout
operator|>
literal|0
condition|)
do|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fjreceive_data: Got %d decoded bytes"
argument_list|,
name|cnew
argument_list|)
expr_stmt|;
operator|*
name|pcrec
operator|=
name|cnew
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Decode the data in the buffer, optionally returning the number of    bytes needed to complete the next packet.  */
end_comment

begin_function
specifier|static
name|boolean
name|fjprocess_data
parameter_list|(
name|pcneed
parameter_list|)
name|size_t
modifier|*
name|pcneed
decl_stmt|;
block|{
name|int
name|istart
decl_stmt|;
name|istart
operator|=
name|iPrecend
expr_stmt|;
while|while
condition|(
name|istart
operator|!=
name|iJrecend
condition|)
block|{
name|int
name|i
decl_stmt|,
name|iget
decl_stmt|;
name|char
name|ab
index|[
name|CHDRLEN
index|]
decl_stmt|;
name|int
name|cpacket
decl_stmt|,
name|cdata
decl_stmt|,
name|chave
decl_stmt|;
name|int
name|iindex
decl_stmt|,
name|iendindex
decl_stmt|;
comment|/* Find the next occurrence of FIRST.  If we have to skip some 	 garbage bytes to get to it, zero them out (so they don't 	 confuse the 'i' protocol) and advance iPrecend.  This will 	 save us from looking at them again.  */
if|if
condition|(
name|abPrecbuf
index|[
name|istart
index|]
operator|!=
name|FIRST
condition|)
block|{
name|int
name|cintro
decl_stmt|;
name|char
modifier|*
name|zintro
decl_stmt|;
name|size_t
name|cskipped
decl_stmt|;
name|cintro
operator|=
name|iJrecend
operator|-
name|istart
expr_stmt|;
if|if
condition|(
name|cintro
operator|<
literal|0
condition|)
name|cintro
operator|=
name|CRECBUFLEN
operator|-
name|istart
expr_stmt|;
name|zintro
operator|=
name|memchr
argument_list|(
name|abPrecbuf
operator|+
name|istart
argument_list|,
name|FIRST
argument_list|,
operator|(
name|size_t
operator|)
name|cintro
argument_list|)
expr_stmt|;
if|if
condition|(
name|zintro
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|abPrecbuf
operator|+
name|istart
argument_list|,
operator|(
name|size_t
operator|)
name|cintro
argument_list|)
expr_stmt|;
name|istart
operator|=
operator|(
name|istart
operator|+
name|cintro
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|iPrecend
operator|=
name|istart
expr_stmt|;
continue|continue;
block|}
name|cskipped
operator|=
name|zintro
operator|-
operator|(
name|abPrecbuf
operator|+
name|istart
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|abPrecbuf
operator|+
name|istart
argument_list|,
name|cskipped
argument_list|)
expr_stmt|;
name|istart
operator|+=
name|cskipped
expr_stmt|;
name|iPrecend
operator|=
name|istart
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iget
operator|=
name|istart
init|;
name|i
operator|<
name|CHDRLEN
operator|&&
name|iget
operator|!=
name|iJrecend
condition|;
operator|++
name|i
operator|,
name|iget
operator|=
operator|(
name|iget
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
control|)
name|ab
index|[
name|i
index|]
operator|=
name|abPrecbuf
index|[
name|iget
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|CHDRLEN
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CHDRLEN
operator|-
name|i
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|cpacket
operator|=
name|CGETLENGTH
argument_list|(
name|ab
index|[
literal|1
index|]
argument_list|,
name|ab
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cdata
operator|=
name|CGETLENGTH
argument_list|(
name|ab
index|[
literal|4
index|]
argument_list|,
name|ab
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* Make sure the header has the right magic characters, that the 	 data is not larger than the packet, and that we have an even 	 number of byte index characters.  */
if|if
condition|(
name|ab
index|[
literal|3
index|]
operator|!=
name|FOURTH
operator|||
name|ab
index|[
literal|6
index|]
operator|!=
name|SEVENTH
operator|||
name|cdata
operator|>
name|cpacket
operator|-
name|CHDRLEN
operator|-
literal|1
operator|||
operator|(
name|cpacket
operator|-
name|cdata
operator|-
name|CHDRLEN
operator|-
literal|1
operator|)
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
name|istart
operator|=
operator|(
name|istart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
name|chave
operator|=
name|iJrecend
operator|-
name|istart
expr_stmt|;
if|if
condition|(
name|chave
operator|<
literal|0
condition|)
name|chave
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|chave
operator|<
name|cpacket
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|cpacket
operator|-
name|chave
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Figure out where the byte indices start and end.  */
name|iindex
operator|=
operator|(
name|istart
operator|+
name|CHDRLEN
operator|+
name|cdata
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|iendindex
operator|=
operator|(
name|istart
operator|+
name|cpacket
operator|-
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
comment|/* Make sure the magic trailer character is there.  */
if|if
condition|(
name|abPrecbuf
index|[
name|iendindex
index|]
operator|!=
name|TRAILER
condition|)
block|{
name|istart
operator|=
operator|(
name|istart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
continue|continue;
block|}
comment|/* We have a packet to decode.  The decoding process is simpler 	 than the encoding process, since all we have to do is examine 	 the byte indices.  We zero out the byte indices as we go, so 	 that they will not confuse the 'i' protocol.  */
while|while
condition|(
name|iindex
operator|!=
name|iendindex
condition|)
block|{
name|int
name|ihigh
decl_stmt|,
name|ilow
decl_stmt|;
name|boolean
name|f32
decl_stmt|,
name|f128
decl_stmt|;
name|int
name|iset
decl_stmt|;
name|ihigh
operator|=
name|abPrecbuf
index|[
name|iindex
index|]
operator|-
name|INDEX_OFFSET
expr_stmt|;
name|abPrecbuf
index|[
name|iindex
index|]
operator|=
literal|0
expr_stmt|;
name|iindex
operator|=
operator|(
name|iindex
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|ilow
operator|=
name|abPrecbuf
index|[
name|iindex
index|]
operator|-
name|INDEX_OFFSET
expr_stmt|;
name|abPrecbuf
index|[
name|iindex
index|]
operator|=
literal|0
expr_stmt|;
name|iindex
operator|=
operator|(
name|iindex
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
comment|/* Now we must undo the encoding, by adding 128 and xoring 	     with 32 as appropriate.  Which to do is encoded in the 	     low byte, except that if the high byte is the special 	     value 126, then the low byte is actually the high byte 	     and both operations are performed.  */
name|f128
operator|=
name|TRUE
expr_stmt|;
name|f32
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ihigh
operator|==
name|INDEX_MAX_HIGH
condition|)
name|iset
operator|=
name|ilow
operator|*
name|INDEX_MAX_LOW
operator|+
name|INDEX_MAX_LOW
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|iset
operator|=
name|ihigh
operator|*
name|INDEX_MAX_LOW
operator|+
name|ilow
operator|%
name|INDEX_MAX_LOW
expr_stmt|;
if|if
condition|(
name|ilow
operator|<
name|INDEX_MAX_LOW
condition|)
name|f32
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|ilow
operator|<
literal|2
operator|*
name|INDEX_MAX_LOW
condition|)
name|f128
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Now iset is the index from the start of the data to the 	     byte to modify; adjust it to an index in abPrecbuf.  */
name|iset
operator|=
operator|(
name|istart
operator|+
name|CHDRLEN
operator|+
name|iset
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|f128
condition|)
name|abPrecbuf
index|[
name|iset
index|]
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|f32
condition|)
name|abPrecbuf
index|[
name|iset
index|]
operator|^=
literal|0x20
expr_stmt|;
block|}
comment|/* Zero out the header and trailer to avoid confusing the 'i' 	 protocol, and update iPrecend to the end of decoded data.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|iget
operator|=
name|istart
init|;
name|i
operator|<
name|CHDRLEN
operator|&&
name|iget
operator|!=
name|iJrecend
condition|;
operator|++
name|i
operator|,
name|iget
operator|=
operator|(
name|iget
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
control|)
name|abPrecbuf
index|[
name|iget
index|]
operator|=
literal|0
expr_stmt|;
name|abPrecbuf
index|[
name|iendindex
index|]
operator|=
literal|0
expr_stmt|;
name|iPrecend
operator|=
operator|(
name|iendindex
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|istart
operator|=
name|iPrecend
expr_stmt|;
block|}
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CHDRLEN
operator|+
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

