begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* proty.c    The 'y' protocol.     Copyright (C) 1994, 1995 Jorge Cwik and Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|proty_id
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"trans.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The 'y' protocol, and this implementation, was written and designed    by Jorge Cwik<jorge@satlink.net>.  Some of the routines, and the    coding style in general, were taken verbatim or adapted from other    Taylor UUCP modules.  Mark Delany made the initial testings and    helped in portability issues.     This protocol does not perform any kind of error correction or flow    control.  It does do error checking.  It does not require an end to    end reliable link.  It is recommended for error-free (also called    semi-reliable) connections as provided by error correcting modems.    It needs an eight bit clean channel and some kind of flow control    at the lower layers, typically RTS/CTS hardware flow control.     The flow of the file transmission is completely unidirectional.    There are no ACKs or NAKs outside file boundaries. This makes it    very suitable for half duplex modulations (like PEP) and    connections with very long delays, like multihop satellite links.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This protocol uses 16 bit little-endian ints in the packet header.  */
end_comment

begin_define
define|#
directive|define
name|FROMLITTLE
parameter_list|(
name|p
parameter_list|)
value|(((p)[0]& 0xff) + (((p)[1]& 0xff)<< 8))
end_define

begin_define
define|#
directive|define
name|TOLITTLE
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
value|((p)[0] = (i)& 0xff, (p)[1] = ((i)>> 8)& 0xff)
end_define

begin_comment
comment|/* The buffer and packet size we use.  */
end_comment

begin_define
define|#
directive|define
name|CYBUFSIZE
value|(1024)
end_define

begin_define
define|#
directive|define
name|IYPACKSIZE
value|(1024)
end_define

begin_comment
comment|/* The offset in the buffer to the data.  */
end_comment

begin_define
define|#
directive|define
name|CYFRAMELEN
value|(6)
end_define

begin_comment
comment|/* Offsets in a packet header.  */
end_comment

begin_define
define|#
directive|define
name|YFRAME_SEQ_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|YFRAME_LEN_OFF
value|(2)
end_define

begin_define
define|#
directive|define
name|YFRAME_CTL_OFF
value|(2)
end_define

begin_define
define|#
directive|define
name|YFRAME_CHK_OFF
value|(4)
end_define

begin_comment
comment|/* Offsets in a packet header viewed as an array of shorts.  */
end_comment

begin_define
define|#
directive|define
name|YFRAME_SEQ
value|(0)
end_define

begin_define
define|#
directive|define
name|YFRAME_LEN
value|(1)
end_define

begin_define
define|#
directive|define
name|YFRAME_CTL
value|(1)
end_define

begin_define
define|#
directive|define
name|YFRAME_CHK
value|(2)
end_define

begin_comment
comment|/* The default timeout.  */
end_comment

begin_define
define|#
directive|define
name|CYTIMEOUT
value|(60)
end_define

begin_comment
comment|/* Control packet types.  */
end_comment

begin_define
define|#
directive|define
name|YPKT_ACK
value|(0xFFFE)
end_define

begin_define
define|#
directive|define
name|YPKT_ERR
value|(0xFFFD)
end_define

begin_define
define|#
directive|define
name|YPKT_BAD
value|(0xFFFC)
end_define

begin_comment
comment|/* The protocol version number.  */
end_comment

begin_define
define|#
directive|define
name|Y_VERSION
value|(1)
end_define

begin_comment
comment|/* When the protocol starts up, it transmit the following information:      1 byte version      1 byte packet size      2 byte flags (none currently defined)    Future revision may expand the structure as long as these members    keep their current offset.  */
end_comment

begin_define
define|#
directive|define
name|Y_INIT_HDR_LEN
value|(4)
end_define

begin_define
define|#
directive|define
name|Y_INIT_HDR_VERSION_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|Y_INIT_HDR_PKTSIZE_OFF
value|(1)
end_define

begin_define
define|#
directive|define
name|Y_INIT_HDR_FLAGS_OFF
value|(2)
end_define

begin_comment
comment|/* The initialization length of the lowest accepted version.  */
end_comment

begin_define
define|#
directive|define
name|MIN_Y_SYNC
value|(4)
end_define

begin_comment
comment|/* Not strictly needed, but I would not want to accept a 32k sync pkt.  */
end_comment

begin_define
define|#
directive|define
name|MAX_Y_SYNC
value|IYPACKSIZE
end_define

begin_comment
comment|/* Local and remote packet sizes (we actually use the same value for    both).  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|iYlocal_packsize
init|=
name|IYPACKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|iYremote_packsize
init|=
name|IYPACKSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local and remote packet sequence numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|iYlocal_pktnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|iYremote_pktnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The timeout.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cYtimeout
init|=
name|CYTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transmitter buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zYbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protocol parameters.  */
end_comment

begin_decl_stmt
name|struct
name|uuconf_cmdtab
name|asYproto_params
index|[]
init|=
block|{
block|{
literal|"timeout"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cYtimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"packet-size"
block|,
name|UUCONF_CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|iYlocal_packsize
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fywait_for_packet
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|boolean
operator|*
name|pfexit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|iychecksum
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|z
operator|,
name|size_t
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|iychecksum2
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfirst
operator|,
name|size_t
name|cfirst
operator|,
specifier|const
name|char
operator|*
name|zsecond
operator|,
name|size_t
name|csecond
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fywait_for_header
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|unsigned
name|short
name|header
index|[
literal|3
index|]
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fysend_pkt
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
specifier|const
name|void
operator|*
name|zdata
operator|,
name|size_t
name|cdata
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fysend_control
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|int
name|itype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fyread_data
name|P
argument_list|(
operator|(
expr|struct
name|sdaemon
operator|*
name|qdaemon
operator|,
name|size_t
name|clen
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Exchange sync packets at protocol startup.  */
end_comment

begin_function
specifier|static
name|boolean
name|fyxchg_syncs
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|char
name|inithdr
index|[
name|Y_INIT_HDR_LEN
index|]
decl_stmt|;
name|unsigned
name|short
name|header
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|short
name|ichk
decl_stmt|;
name|size_t
name|clen
decl_stmt|,
name|cfirst
decl_stmt|;
name|int
name|rpktsize
decl_stmt|;
comment|/* Send our configuration.  We could use only one array (for local      and remote).  But this is safer in case the code changes and      depend on separate ones.  */
name|inithdr
index|[
name|Y_INIT_HDR_VERSION_OFF
index|]
operator|=
name|Y_VERSION
expr_stmt|;
name|inithdr
index|[
name|Y_INIT_HDR_PKTSIZE_OFF
index|]
operator|=
name|iYlocal_packsize
operator|>>
literal|8
expr_stmt|;
name|TOLITTLE
argument_list|(
name|inithdr
operator|+
name|Y_INIT_HDR_FLAGS_OFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fysend_pkt
argument_list|(
name|qdaemon
argument_list|,
name|inithdr
argument_list|,
name|Y_INIT_HDR_LEN
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fywait_for_header
argument_list|(
name|qdaemon
argument_list|,
name|header
argument_list|,
name|cYtimeout
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fyxchg_syncs: Got sync header"
argument_list|)
expr_stmt|;
name|clen
operator|=
name|header
index|[
name|YFRAME_LEN
index|]
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|MIN_Y_SYNC
operator|||
name|clen
operator|>
name|MAX_Y_SYNC
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad 'y' protocol sync packet length"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* It may be better to integrate this code with fywait_for_packet.  */
if|if
condition|(
operator|!
name|fyread_data
argument_list|(
name|qdaemon
argument_list|,
name|clen
argument_list|,
name|cYtimeout
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
name|ichk
operator|=
name|iychecksum2
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|cfirst
argument_list|,
name|abPrecbuf
argument_list|,
name|clen
operator|-
name|cfirst
argument_list|)
expr_stmt|;
name|rpktsize
operator|=
name|BUCHAR
argument_list|(
name|abPrecbuf
index|[
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
index|]
argument_list|)
expr_stmt|;
comment|/* Future versions of the protocol may need to check and react      according to the version number.  */
if|if
condition|(
name|rpktsize
operator|==
literal|0
operator|||
name|header
index|[
name|YFRAME_CHK
index|]
operator|!=
name|ichk
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad 'y' protocol sync packet"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|iYremote_packsize
operator|=
name|rpktsize
operator|<<
literal|8
expr_stmt|;
comment|/* Some may want to do this different and in effect the protocol      support this.  But I like the idea that the packet size would be      the same in both directions.  This allows the caller to select      both packet sizes without changing the configuration at the      server.  */
if|if
condition|(
name|iYremote_packsize
operator|>
name|iYlocal_packsize
condition|)
name|iYremote_packsize
operator|=
name|iYlocal_packsize
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|clen
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Start the protocol.  */
end_comment

begin_function
name|boolean
name|fystart
parameter_list|(
name|qdaemon
parameter_list|,
name|pzlog
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
block|{
operator|*
name|pzlog
operator|=
name|NULL
expr_stmt|;
comment|/* This should force, or at least enable if available, RTS/CTS      hardware flow control !! */
comment|/* The 'y' protocol requires an eight bit clean link */
if|if
condition|(
operator|!
name|fconn_set
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|PARITYSETTING_NONE
argument_list|,
name|STRIPSETTING_EIGHTBITS
argument_list|,
name|XONXOFF_OFF
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iYlocal_pktnum
operator|=
name|iYremote_pktnum
operator|=
literal|0
expr_stmt|;
comment|/* Only multiple of 256 sizes are allowed */
name|iYlocal_packsize
operator|&=
operator|~
literal|0xff
expr_stmt|;
if|if
condition|(
name|iYlocal_packsize
operator|<
literal|256
operator|||
name|iYlocal_packsize
operator|>
operator|(
literal|16
operator|*
literal|1024
operator|)
condition|)
name|iYlocal_packsize
operator|=
name|IYPACKSIZE
expr_stmt|;
comment|/* Exhange SYNC packets */
if|if
condition|(
operator|!
name|fyxchg_syncs
argument_list|(
name|qdaemon
argument_list|)
condition|)
block|{
comment|/* Restore defaults */
name|cYtimeout
operator|=
name|CYTIMEOUT
expr_stmt|;
name|iYlocal_packsize
operator|=
name|IYPACKSIZE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zYbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CYBUFSIZE
operator|+
name|CYFRAMELEN
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Shutdown the protocol.  */
end_comment

begin_function
name|boolean
name|fyshutdown
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zYbuf
argument_list|)
expr_stmt|;
name|zYbuf
operator|=
name|NULL
expr_stmt|;
name|cYtimeout
operator|=
name|CYTIMEOUT
expr_stmt|;
name|iYlocal_packsize
operator|=
name|IYPACKSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Send a command string.  We send packets containing the string until    the entire string has been sent, including the zero terminator.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fysendcmd
parameter_list|(
name|qdaemon
parameter_list|,
name|z
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
block|{
name|size_t
name|clen
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fysendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|size_t
name|csize
decl_stmt|;
name|csize
operator|=
name|clen
expr_stmt|;
if|if
condition|(
name|csize
operator|>
name|iYremote_packsize
condition|)
name|csize
operator|=
name|iYremote_packsize
expr_stmt|;
if|if
condition|(
operator|!
name|fysend_pkt
argument_list|(
name|qdaemon
argument_list|,
name|z
argument_list|,
name|csize
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|z
operator|+=
name|csize
expr_stmt|;
name|clen
operator|-=
name|csize
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get space to be filled with data.  We always use zYbuf, which was    allocated from the heap.  */
end_comment

begin_function
name|char
modifier|*
name|zygetspace
parameter_list|(
name|qdaemon
parameter_list|,
name|pclen
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|iYremote_packsize
expr_stmt|;
return|return
name|zYbuf
operator|+
name|CYFRAMELEN
return|;
block|}
end_function

begin_comment
comment|/* Send out a data packet.  */
end_comment

begin_function
name|boolean
name|fysenddata
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|ilocal
parameter_list|,
name|iremote
parameter_list|,
name|ipos
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
name|int
name|ilocal
decl_stmt|;
name|int
name|iremote
decl_stmt|;
name|long
name|ipos
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|cdata
operator|>
name|iYremote_packsize
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fysend_packet: Packet size too large"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TOLITTLE
argument_list|(
name|zYbuf
operator|+
name|YFRAME_SEQ_OFF
argument_list|,
name|iYlocal_pktnum
argument_list|)
expr_stmt|;
operator|++
name|iYlocal_pktnum
expr_stmt|;
name|TOLITTLE
argument_list|(
name|zYbuf
operator|+
name|YFRAME_LEN_OFF
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
name|TOLITTLE
argument_list|(
name|zYbuf
operator|+
name|YFRAME_CHK_OFF
argument_list|,
name|iychecksum
argument_list|(
name|zdata
argument_list|,
name|cdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We pass FALSE to fsend_data since we don't expect the other side      to be sending us anything just now.  */
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zYbuf
argument_list|,
name|cdata
operator|+
name|CYFRAMELEN
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for data to come in and process it until we've finished a    command or a file.  */
end_comment

begin_function
name|boolean
name|fywait
parameter_list|(
name|qdaemon
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
block|{
name|boolean
name|fexit
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|!
name|fexit
condition|)
block|{
if|if
condition|(
operator|!
name|fywait_for_packet
argument_list|(
name|qdaemon
argument_list|,
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* File level routines    We could handle this inside the other public routines,    but this is cleaner and better for future expansions */
end_comment

begin_function
name|boolean
name|fyfile
parameter_list|(
name|qdaemon
parameter_list|,
name|qtrans
parameter_list|,
name|fstart
parameter_list|,
name|fsend
parameter_list|,
name|cbytes
parameter_list|,
name|pfhandled
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|struct
name|stransfer
modifier|*
name|qtrans
decl_stmt|;
name|boolean
name|fstart
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|boolean
modifier|*
name|pfhandled
decl_stmt|;
block|{
name|unsigned
name|short
name|header
index|[
literal|3
index|]
decl_stmt|;
operator|*
name|pfhandled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fstart
condition|)
block|{
if|if
condition|(
name|fsend
condition|)
block|{
comment|/* It is critical that the timeout here would be long 	     enough.  We have just sent a full file without any kind 	     of flow control at the protocol level.  The traffic may 	     be buffered in many places of the link, and the remote 	     may take a while until cathing up.  */
if|if
condition|(
operator|!
name|fywait_for_header
argument_list|(
name|qdaemon
argument_list|,
name|header
argument_list|,
name|cYtimeout
operator|*
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|header
index|[
name|YFRAME_CTL
index|]
operator|!=
operator|(
name|unsigned
name|short
operator|)
name|YPKT_ACK
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fyfile: Error from remote: 0x%04X"
argument_list|,
name|header
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Received 'y' protocol error from remote"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* This is technically not requireed.  But I've put this in 	     the protocol to allow easier expansions.  */
return|return
name|fysend_control
argument_list|(
name|qdaemon
argument_list|,
name|YPKT_ACK
argument_list|)
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Send a control packet, not used during the normal file    transmission.  */
end_comment

begin_function
specifier|static
name|boolean
name|fysend_control
parameter_list|(
name|qdaemon
parameter_list|,
name|itype
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|int
name|itype
decl_stmt|;
block|{
name|char
name|header
index|[
name|CYFRAMELEN
index|]
decl_stmt|;
name|TOLITTLE
argument_list|(
name|header
operator|+
name|YFRAME_SEQ_OFF
argument_list|,
name|iYlocal_pktnum
argument_list|)
expr_stmt|;
name|iYlocal_pktnum
operator|++
expr_stmt|;
name|TOLITTLE
argument_list|(
name|header
operator|+
name|YFRAME_CTL_OFF
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|TOLITTLE
argument_list|(
name|header
operator|+
name|YFRAME_CHK_OFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|header
argument_list|,
name|CYFRAMELEN
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Private function to send a packet.  This one doesn't need the data    to be in the buffer provided by zygetspace.  I've found it worth    for avoiding memory copies.  Somebody may want to do it otherwise */
end_comment

begin_function
specifier|static
name|boolean
name|fysend_pkt
parameter_list|(
name|qdaemon
parameter_list|,
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
specifier|const
name|void
modifier|*
name|zdata
decl_stmt|;
name|size_t
name|cdata
decl_stmt|;
block|{
name|char
name|header
index|[
name|CYFRAMELEN
index|]
decl_stmt|;
name|TOLITTLE
argument_list|(
name|header
operator|+
name|YFRAME_SEQ_OFF
argument_list|,
name|iYlocal_pktnum
argument_list|)
expr_stmt|;
name|iYlocal_pktnum
operator|++
expr_stmt|;
name|TOLITTLE
argument_list|(
name|header
operator|+
name|YFRAME_LEN_OFF
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
name|TOLITTLE
argument_list|(
name|header
operator|+
name|YFRAME_CHK_OFF
argument_list|,
name|iychecksum
argument_list|(
name|zdata
argument_list|,
name|cdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|header
argument_list|,
name|CYFRAMELEN
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|fsend_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wait until enough data arrived from the comm line.  This protocol    doesn't need to perform any kind of action while waiting.  */
end_comment

begin_function
specifier|static
name|boolean
name|fyread_data
parameter_list|(
name|qdaemon
parameter_list|,
name|clen
parameter_list|,
name|timeout
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|cinbuf
decl_stmt|;
name|size_t
name|crec
decl_stmt|;
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|clen
condition|)
block|{
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|clen
operator|-
name|cinbuf
argument_list|,
operator|&
name|crec
argument_list|,
name|timeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cinbuf
operator|+=
name|crec
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|clen
condition|)
block|{
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|qdaemon
operator|->
name|qconn
argument_list|,
name|clen
operator|-
name|cinbuf
argument_list|,
operator|&
name|crec
argument_list|,
name|timeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|cinbuf
operator|+=
name|crec
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|clen
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for data"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Receive a remote packet header, check for correct sequence number.  */
end_comment

begin_function
specifier|static
name|boolean
name|fywait_for_header
parameter_list|(
name|qdaemon
parameter_list|,
name|header
parameter_list|,
name|timeout
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|unsigned
name|short
name|header
index|[
literal|3
index|]
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fyread_data
argument_list|(
name|qdaemon
argument_list|,
name|CYFRAMELEN
argument_list|,
name|timeout
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Somebody may want to optimize this in a portable way.  I'm not      sure it's worth, but the output by gcc for the portable construct      is so bad (even with optimization), that I couldn't resist.  */
if|if
condition|(
name|iPrecstart
operator|<=
operator|(
name|CRECBUFLEN
operator|-
name|CYFRAMELEN
operator|)
condition|)
block|{
name|header
index|[
literal|0
index|]
operator|=
name|FROMLITTLE
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|)
expr_stmt|;
name|header
index|[
literal|1
index|]
operator|=
name|FROMLITTLE
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
operator|+
literal|2
argument_list|)
expr_stmt|;
name|header
index|[
literal|2
index|]
operator|=
name|FROMLITTLE
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CYFRAMELEN
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
name|header
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|abPrecbuf
index|[
operator|(
name|iPrecstart
operator|+
name|j
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|abPrecbuf
index|[
operator|(
name|iPrecstart
operator|+
name|j
operator|)
operator|%
name|CRECBUFLEN
index|]
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|CYFRAMELEN
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|DEBUG_MESSAGE3
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fywait_for_header: Got header: 0x%04X, 0x%04X, 0x%04X"
argument_list|,
name|header
index|[
literal|0
index|]
argument_list|,
name|header
index|[
literal|1
index|]
argument_list|,
name|header
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
index|[
name|YFRAME_SEQ
index|]
operator|!=
name|iYremote_pktnum
operator|++
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Incorrect 'y' packet sequence"
argument_list|)
expr_stmt|;
name|fysend_control
argument_list|(
name|qdaemon
argument_list|,
name|YPKT_BAD
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Receive a remote data packet */
end_comment

begin_function
specifier|static
name|boolean
name|fywait_for_packet
parameter_list|(
name|qdaemon
parameter_list|,
name|pfexit
parameter_list|)
name|struct
name|sdaemon
modifier|*
name|qdaemon
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
block|{
name|unsigned
name|short
name|header
index|[
literal|3
index|]
decl_stmt|,
name|ichk
decl_stmt|;
name|size_t
name|clen
decl_stmt|,
name|cfirst
decl_stmt|;
if|if
condition|(
operator|!
name|fywait_for_header
argument_list|(
name|qdaemon
argument_list|,
name|header
argument_list|,
name|cYtimeout
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|clen
operator|=
name|header
index|[
name|YFRAME_LEN
index|]
expr_stmt|;
if|if
condition|(
name|clen
operator|==
literal|0
operator|&&
name|pfexit
operator|!=
name|NULL
condition|)
block|{
comment|/* I Suppose the pointers could be NULL ??? */
return|return
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
argument_list|,
literal|0
argument_list|,
name|abPrecbuf
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
return|;
block|}
if|if
condition|(
name|clen
operator|&
literal|0x8000
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fywait_for_packet: Error from remote: 0x%04X"
argument_list|,
name|header
index|[
name|YFRAME_CTL
index|]
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Remote error packet"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* This is really not neccessary.  But if this check is removed,      take in mind that the packet may be up to 32k long.  */
if|if
condition|(
name|clen
operator|>
name|iYlocal_packsize
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Packet too large"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|fyread_data
argument_list|(
name|qdaemon
argument_list|,
name|clen
argument_list|,
name|cYtimeout
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
name|clen
condition|)
name|cfirst
operator|=
name|clen
expr_stmt|;
if|if
condition|(
name|cfirst
operator|==
name|clen
condition|)
name|ichk
operator|=
name|iychecksum
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|else
name|ichk
operator|=
name|iychecksum2
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|cfirst
argument_list|,
name|abPrecbuf
argument_list|,
name|clen
operator|-
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
index|[
name|YFRAME_CHK
index|]
operator|!=
name|ichk
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fywait_for_packet: Bad checksum 0x%x != 0x%x"
argument_list|,
name|header
index|[
name|YFRAME_CHK
index|]
argument_list|,
name|ichk
argument_list|)
expr_stmt|;
name|fysend_control
argument_list|(
name|qdaemon
argument_list|,
name|YPKT_ERR
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Checksum error"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pfexit
operator|!=
name|NULL
operator|&&
operator|!
name|fgot_data
argument_list|(
name|qdaemon
argument_list|,
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|cfirst
argument_list|,
name|abPrecbuf
argument_list|,
name|clen
operator|-
name|cfirst
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|clen
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compute 16 bit checksum */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|I386_ASM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I386_ASM
end_ifdef

begin_define
define|#
directive|define
name|ROTATE
parameter_list|(
name|i
parameter_list|)
define|\
value|asm ("rolw $1,%0" : "=g" (i) : "g" (i))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ROTATE
parameter_list|(
name|i
parameter_list|)
value|i += i + ((i& 0x8000)>> 15)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|short
name|iychecksum
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|register
name|size_t
name|c
decl_stmt|;
block|{
specifier|register
name|unsigned
name|short
name|ichk
decl_stmt|;
name|ichk
operator|=
literal|0xffff
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
block|{
name|ROTATE
argument_list|(
name|ichk
argument_list|)
expr_stmt|;
name|ichk
operator|+=
name|BUCHAR
argument_list|(
operator|*
name|z
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|ichk
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|short
name|iychecksum2
parameter_list|(
name|zfirst
parameter_list|,
name|cfirst
parameter_list|,
name|zsecond
parameter_list|,
name|csecond
parameter_list|)
specifier|const
name|char
modifier|*
name|zfirst
decl_stmt|;
name|size_t
name|cfirst
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsecond
decl_stmt|;
name|size_t
name|csecond
decl_stmt|;
block|{
specifier|register
name|unsigned
name|short
name|ichk
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|register
name|size_t
name|c
decl_stmt|;
name|z
operator|=
name|zfirst
expr_stmt|;
name|c
operator|=
name|cfirst
operator|+
name|csecond
expr_stmt|;
name|ichk
operator|=
literal|0xffff
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
block|{
name|ROTATE
argument_list|(
name|ichk
argument_list|)
expr_stmt|;
name|ichk
operator|+=
name|BUCHAR
argument_list|(
operator|*
name|z
operator|++
argument_list|)
expr_stmt|;
comment|/* If the first buffer has been finished, switch to the second.  */
if|if
condition|(
operator|--
name|cfirst
operator|==
literal|0
condition|)
name|z
operator|=
name|zsecond
expr_stmt|;
block|}
return|return
name|ichk
return|;
block|}
end_function

end_unit

