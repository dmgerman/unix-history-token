begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uux.c    Prepare to execute a command on a remote system.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|uux_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* These character lists should, perhaps, be in sysdep.h.  */
end_comment

begin_comment
comment|/* This is the list of shell metacharacters that we check for.  If one    of these is present, we request uuxqt to execute the command with    /bin/sh.  Otherwise we let it execute using execve.  */
end_comment

begin_define
define|#
directive|define
name|ZSHELLCHARS
value|"\"'`*?[;&()|<>\\$"
end_define

begin_comment
comment|/* This is the list of word separators.  We break filename arguments    at these characters.  */
end_comment

begin_define
define|#
directive|define
name|ZSHELLSEPS
value|";&*|<> \t"
end_define

begin_comment
comment|/* This is the list of word separators without the redirection    operators.  */
end_comment

begin_define
define|#
directive|define
name|ZSHELLNONREDIRSEPS
value|";&*| \t"
end_define

begin_escape
end_escape

begin_comment
comment|/* Whether this execution is occurring on the local system.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fXxqtlocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The execution system.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uuconf_system
name|sXxqtsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of local system from the point of view of the execution    system.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zXxqtloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The job grade to use.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bXgrade
init|=
name|BDEFAULT_UUX_GRADE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The temporary file name of the execute file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|abXxqt_tname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the execute file on the remote system.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|abXxqt_xname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The execute file we are creating.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eXxqt_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of commands to be spooled.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scmd
modifier|*
name|pasXcmds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cXcmds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A file to close if we're forced to exit.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eXclose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of file names which will match the file names which appear    in the uucico logs.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zXnames
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uxusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxhelp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxadd_xqt_line
name|P
argument_list|(
operator|(
name|int
name|bchar
operator|,
specifier|const
name|char
operator|*
name|z1
operator|,
specifier|const
name|char
operator|*
name|z2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxadd_send_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfrom
operator|,
specifier|const
name|char
operator|*
name|zto
operator|,
specifier|const
name|char
operator|*
name|zoptions
operator|,
specifier|const
name|char
operator|*
name|ztemp
operator|,
specifier|const
name|char
operator|*
name|zforward
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxcopy_stdin
name|P
argument_list|(
operator|(
name|FILE
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxrecord_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxadd_name
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asXlongopts
index|[]
init|=
block|{
block|{
literal|"requestor"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"return-stdin"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"nocopy"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"copy"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"grade"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"jobid"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'j'
block|}
block|,
block|{
literal|"link"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"notification"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|2
block|}
block|,
block|{
literal|"stdin"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"nouucico"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"status"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"noexpand"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'W'
block|}
block|,
block|{
literal|"config"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"debug"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The main routine.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* -a: requestor address for status reports.  */
specifier|const
name|char
modifier|*
name|zrequestor
init|=
name|NULL
decl_stmt|;
comment|/* -b: if true, return standard input on error.  */
name|boolean
name|fretstdin
init|=
name|FALSE
decl_stmt|;
comment|/* -c,-C: if true, copy to spool directory.  */
name|boolean
name|fcopy
init|=
name|FALSE
decl_stmt|;
comment|/* -c: set if -c appears explicitly; if it and -l appear, then if the      link fails we don't copy the file.  */
name|boolean
name|fdontcopy
init|=
name|FALSE
decl_stmt|;
comment|/* -I: configuration file name.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
comment|/* -j: output job id.  */
name|boolean
name|fjobid
init|=
name|FALSE
decl_stmt|;
comment|/* -l: link file to spool directory.  */
name|boolean
name|flink
init|=
name|FALSE
decl_stmt|;
comment|/* -n: do not notify upon command completion.  */
name|boolean
name|fno_ack
init|=
name|FALSE
decl_stmt|;
comment|/* -p: read standard input for command standard input.  */
name|boolean
name|fread_stdin
init|=
name|FALSE
decl_stmt|;
comment|/* -r: do not start uucico when finished.  */
name|boolean
name|fuucico
init|=
name|TRUE
decl_stmt|;
comment|/* -s: report status to named file.  */
specifier|const
name|char
modifier|*
name|zstatus_file
init|=
name|NULL
decl_stmt|;
comment|/* -W: only expand local file names.  */
name|boolean
name|fexpand
init|=
name|TRUE
decl_stmt|;
comment|/* -z: report status only on error.  */
name|boolean
name|ferror_ack
init|=
name|FALSE
decl_stmt|;
name|int
name|iopt
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|char
modifier|*
name|zargs
decl_stmt|;
name|char
modifier|*
name|zarg
decl_stmt|;
name|char
modifier|*
name|zcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|char
modifier|*
name|zexclam
decl_stmt|;
name|boolean
name|fgetcwd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
name|char
modifier|*
name|zforward
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzargs
decl_stmt|;
name|int
name|calloc_args
decl_stmt|;
name|int
name|cargs
decl_stmt|;
specifier|const
name|char
modifier|*
name|zinput_from
decl_stmt|;
specifier|const
name|char
modifier|*
name|zinput_to
decl_stmt|;
specifier|const
name|char
modifier|*
name|zinput_temp
decl_stmt|;
name|boolean
name|finputcopied
decl_stmt|;
name|char
modifier|*
name|zcall_system
decl_stmt|;
name|boolean
name|fcall_any
decl_stmt|;
name|struct
name|uuconf_system
name|slocalsys
decl_stmt|;
name|boolean
name|fneedshell
decl_stmt|;
name|char
modifier|*
name|zfullcmd
decl_stmt|;
name|boolean
name|fpoll
decl_stmt|;
name|char
name|aboptions
index|[
literal|10
index|]
decl_stmt|;
name|boolean
name|fexit
decl_stmt|;
name|zProgram
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* We need to be able to read a single - as an option, which getopt      won't do.  We handle this by using getopt to scan the argument      list multiple times, replacing any single "-" with "-p".  */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+a:bcCg:I:jlnprs:Wvx:z"
argument_list|,
name|asXlongopts
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
name|EOF
condition|)
empty_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|argv
index|[
name|optind
index|]
operator|=
name|zbufcpy
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
block|}
name|opterr
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
comment|/* The leading + in the getopt string means to stop processing      options as soon as a non-option argument is seen.  */
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+a:bcCg:I:jlnprs:Wvx:z"
argument_list|,
name|asXlongopts
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Set requestor name: mail address to which status reports 	     should be sent.  */
name|zrequestor
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Return standard input on error.  */
name|fretstdin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Do not copy local files to spool directory.  */
name|fcopy
operator|=
name|FALSE
expr_stmt|;
name|fdontcopy
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Copy local files to spool directory.  */
name|fcopy
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Configuration file name.  */
if|if
condition|(
name|fsysdep_other_config
argument_list|(
name|optarg
argument_list|)
condition|)
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Output jobid.  */
name|fjobid
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Set job grade.  */
name|bXgrade
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Link file to spool directory.  */
name|flink
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Do not notify upon command completion.  */
name|fno_ack
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Read standard input for command standard input.  */
name|fread_stdin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Do not start uucico when finished.  */
name|fuucico
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Report status to named file.  */
name|zstatus_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Only expand local file names.  */
name|fexpand
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'z'
case|:
comment|/* Report status only on error.  */
name|ferror_ack
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* --notify={true,false,error}.  */
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'t'
operator|||
operator|*
name|optarg
operator|==
literal|'T'
operator|||
operator|*
name|optarg
operator|==
literal|'y'
operator|||
operator|*
name|optarg
operator|==
literal|'Y'
operator|||
operator|*
name|optarg
operator|==
literal|'e'
operator|||
operator|*
name|optarg
operator|==
literal|'E'
condition|)
block|{
name|ferror_ack
operator|=
name|TRUE
expr_stmt|;
name|fno_ack
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'f'
operator|||
operator|*
name|optarg
operator|==
literal|'F'
operator|||
operator|*
name|optarg
operator|==
literal|'n'
operator|||
operator|*
name|optarg
operator|==
literal|'N'
condition|)
block|{
name|ferror_ack
operator|=
name|FALSE
expr_stmt|;
name|fno_ack
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* Print version and exit.  */
name|printf
argument_list|(
literal|"%s: Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|zProgram
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|1
case|:
comment|/* --help.  */
name|uxhelp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* Long option found and flag set.  */
break|break;
default|default:
name|uxusage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|UUCONF_GRADE_LEGAL
argument_list|(
name|bXgrade
argument_list|)
operator|||
operator|(
operator|(
name|bXgrade
operator|<
literal|'0'
operator|||
name|bXgrade
operator|>
literal|'9'
operator|)
operator|&&
operator|(
name|bXgrade
operator|<
literal|'a'
operator|||
name|bXgrade
operator|>
literal|'z'
operator|)
operator|&&
operator|(
name|bXgrade
operator|<
literal|'A'
operator|||
name|bXgrade
operator|>
literal|'Z'
operator|)
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Ignoring illegal grade"
argument_list|)
expr_stmt|;
name|bXgrade
operator|=
name|BDEFAULT_UUX_GRADE
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|uxusage
argument_list|()
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_init
argument_list|(
operator|&
name|puuconf
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
block|{
specifier|const
name|char
modifier|*
name|zdebug
decl_stmt|;
name|iuuconf
operator|=
name|uuconf_debuglevel
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zdebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdebug
operator|!=
name|NULL
condition|)
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|zdebug
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The command and files arguments could be quoted in any number of      ways, so we split them apart ourselves.  We do this before      calling usysdep_initialize because we want to set fgetcwd      correctly.  */
name|clen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|clen
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|zargs
operator|=
name|zbufalc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
operator|*
name|zargs
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|zargs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zargs
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* The first argument is the command to execute.  */
name|clen
operator|=
name|strcspn
argument_list|(
name|zargs
argument_list|,
name|ZSHELLSEPS
argument_list|)
expr_stmt|;
name|zcmd
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcmd
argument_list|,
name|zargs
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcmd
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zargs
operator|+=
name|clen
expr_stmt|;
comment|/* Split the arguments out into an array.  We break the arguments      into alternating sequences of characters not in ZSHELLSEPS      and characters in ZSHELLSEPS.  We remove whitespace.  We      separate the redirection characters '>' and '<' into their      own arguments to make them easier to process below.  */
name|calloc_args
operator|=
literal|10
expr_stmt|;
name|pzargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|calloc_args
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|zarg
operator|=
name|strtok
argument_list|(
name|zargs
argument_list|,
literal|" \t"
argument_list|)
init|;
name|zarg
operator|!=
name|NULL
condition|;
name|zarg
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
while|while
condition|(
operator|*
name|zarg
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cargs
operator|+
literal|1
operator|>=
name|calloc_args
condition|)
block|{
name|calloc_args
operator|+=
literal|10
expr_stmt|;
name|pzargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pzargs
argument_list|,
name|calloc_args
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|zarg
operator|==
literal|'('
condition|)
name|clen
operator|=
name|strlen
argument_list|(
name|zarg
argument_list|)
expr_stmt|;
else|else
name|clen
operator|=
name|strcspn
argument_list|(
name|zarg
argument_list|,
name|ZSHELLSEPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pzargs
index|[
name|cargs
index|]
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pzargs
index|[
name|cargs
index|]
argument_list|,
name|zarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|cargs
index|]
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|cargs
expr_stmt|;
name|zarg
operator|+=
name|clen
expr_stmt|;
block|}
comment|/* We deliberately separate '>' and '<' out.  */
if|if
condition|(
operator|*
name|zarg
operator|!=
literal|'\0'
condition|)
block|{
name|clen
operator|=
name|strspn
argument_list|(
name|zarg
argument_list|,
name|ZSHELLNONREDIRSEPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
name|clen
operator|=
literal|1
expr_stmt|;
name|pzargs
index|[
name|cargs
index|]
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pzargs
index|[
name|cargs
index|]
argument_list|,
name|zarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|cargs
index|]
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|cargs
expr_stmt|;
name|zarg
operator|+=
name|clen
expr_stmt|;
block|}
block|}
block|}
comment|/* Now look through the arguments to see if we are going to need the      current working directory.  We don't try to make a precise      determination, just a conservative one.  The basic idea is that      we don't want to get the cwd for 'foo!rmail - user' (note that we      don't examine the command itself).  */
name|fgetcwd
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
continue|continue;
name|zexclam
operator|=
name|strrchr
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|!=
name|NULL
operator|&&
name|fsysdep_needs_cwd
argument_list|(
name|zexclam
operator|+
literal|1
argument_list|)
condition|)
block|{
name|fgetcwd
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
operator|||
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|i
operator|+
literal|1
operator|<
name|cargs
operator|&&
name|strchr
argument_list|(
name|pzargs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|&&
name|fsysdep_needs_cwd
argument_list|(
name|pzargs
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|fgetcwd
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|puuconf
argument_list|,
name|INIT_SUID
operator||
operator|(
name|fgetcwd
condition|?
name|INIT_GETCWD
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|uxabort
argument_list|)
expr_stmt|;
name|zuser
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
comment|/* Get the local system name.  */
name|iuuconf
operator|=
name|uuconf_localname
argument_list|(
name|puuconf
argument_list|,
operator|&
name|zlocalname
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
name|zlocalname
operator|=
name|zsysdep_localname
argument_list|()
expr_stmt|;
if|if
condition|(
name|zlocalname
operator|==
name|NULL
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
comment|/* Get the local system information.  */
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zlocalname
argument_list|,
operator|&
name|slocalsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_system_local
argument_list|(
name|puuconf
argument_list|,
operator|&
name|slocalsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|slocalsys
operator|.
name|uuconf_zname
operator|=
operator|(
name|char
operator|*
operator|)
name|zlocalname
expr_stmt|;
block|}
comment|/* Figure out which system the command is to be executed on.  */
name|zcmd
operator|=
name|zremove_local_sys
argument_list|(
operator|&
name|slocalsys
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|zexclam
operator|=
name|strchr
argument_list|(
name|zcmd
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
block|{
name|zsys
operator|=
name|zlocalname
expr_stmt|;
name|fXxqtlocal
operator|=
name|TRUE
expr_stmt|;
name|zforward
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zexclam
operator|=
literal|'\0'
expr_stmt|;
name|zsys
operator|=
name|zcmd
expr_stmt|;
name|zcmd
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
name|fXxqtlocal
operator|=
name|FALSE
expr_stmt|;
comment|/* See if we must forward this command through other systems 	 (e.g. uux a!b!cmd).  */
name|zexclam
operator|=
name|strrchr
argument_list|(
name|zcmd
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
name|zforward
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|clen
operator|=
name|zexclam
operator|-
name|zcmd
expr_stmt|;
name|zforward
operator|=
name|zbufalc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zforward
argument_list|,
name|zcmd
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zforward
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zcmd
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fXxqtlocal
condition|)
name|sXxqtsys
operator|=
name|slocalsys
expr_stmt|;
else|else
block|{
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zsys
argument_list|,
operator|&
name|sXxqtsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|funknown_system
argument_list|(
name|puuconf
argument_list|,
name|zsys
argument_list|,
operator|&
name|sXxqtsys
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: System not found"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the local name the remote system know us as.  */
name|zXxqtloc
operator|=
name|sXxqtsys
operator|.
name|uuconf_zlocalname
expr_stmt|;
if|if
condition|(
name|zXxqtloc
operator|==
name|NULL
condition|)
name|zXxqtloc
operator|=
name|zlocalname
expr_stmt|;
comment|/* Look through the arguments.  Any argument containing an      exclamation point character is interpreted as a file name, and is      sent to the appropriate system.  */
name|zinput_from
operator|=
name|NULL
expr_stmt|;
name|zinput_to
operator|=
name|NULL
expr_stmt|;
name|zinput_temp
operator|=
name|NULL
expr_stmt|;
name|finputcopied
operator|=
name|FALSE
expr_stmt|;
name|zcall_system
operator|=
name|NULL
expr_stmt|;
name|fcall_any
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
name|char
modifier|*
name|zforw
decl_stmt|;
name|boolean
name|finput
decl_stmt|,
name|foutput
decl_stmt|;
name|boolean
name|flocal
decl_stmt|,
name|fonxqt
decl_stmt|;
comment|/* Check for a parenthesized argument; remove the parentheses 	 and otherwise ignore it (this is how an exclamation point is 	 quoted).  */
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
name|clen
operator|=
name|strlen
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
name|clen
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Mismatched parentheses"
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
index|[
name|clen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|pzargs
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* Check whether we are doing a redirection.  */
name|finput
operator|=
name|FALSE
expr_stmt|;
name|foutput
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|cargs
condition|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|finput
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'>'
condition|)
name|foutput
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|finput
operator|||
name|foutput
condition|)
block|{
name|pzargs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|zexclam
operator|=
name|strchr
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
comment|/* If there is no exclamation point and no redirection, this 	 argument is left untouched.  */
if|if
condition|(
name|zexclam
operator|==
name|NULL
operator|&&
operator|!
name|finput
operator|&&
operator|!
name|foutput
condition|)
continue|continue;
if|if
condition|(
name|zexclam
operator|!=
name|NULL
condition|)
block|{
name|pzargs
index|[
name|i
index|]
operator|=
name|zremove_local_sys
argument_list|(
operator|&
name|slocalsys
argument_list|,
name|pzargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zexclam
operator|=
name|strchr
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
block|}
comment|/* Get the system name and file name for this file.  */
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
block|{
name|zsystem
operator|=
name|zlocalname
expr_stmt|;
name|zfile
operator|=
name|pzargs
index|[
name|i
index|]
expr_stmt|;
name|flocal
operator|=
name|TRUE
expr_stmt|;
name|zforw
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zexclam
operator|=
literal|'\0'
expr_stmt|;
name|zsystem
operator|=
name|pzargs
index|[
name|i
index|]
expr_stmt|;
name|zfile
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
name|flocal
operator|=
name|FALSE
expr_stmt|;
name|zexclam
operator|=
name|strrchr
argument_list|(
name|zfile
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
name|zforw
operator|=
name|NULL
expr_stmt|;
else|else
block|{
operator|*
name|zexclam
operator|=
literal|'\0'
expr_stmt|;
name|zforw
operator|=
name|zfile
expr_stmt|;
name|zfile
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check if the file is already on the execution system.  */
if|if
condition|(
name|flocal
condition|)
name|fonxqt
operator|=
name|fXxqtlocal
expr_stmt|;
elseif|else
if|if
condition|(
name|fXxqtlocal
condition|)
name|fonxqt
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|zforward
operator|==
name|NULL
condition|?
name|zforw
operator|!=
name|NULL
else|:
name|zforw
operator|==
name|NULL
condition|)
name|fonxqt
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|zforward
operator|!=
name|NULL
operator|&&
name|zforw
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zforward
argument_list|,
name|zforw
argument_list|)
operator|!=
literal|0
condition|)
name|fonxqt
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_zname
argument_list|)
operator|==
literal|0
condition|)
name|fonxqt
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|sXxqtsys
operator|.
name|uuconf_pzalias
operator|==
name|NULL
condition|)
name|fonxqt
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|char
modifier|*
modifier|*
name|pzal
decl_stmt|;
name|fonxqt
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|pzal
operator|=
name|sXxqtsys
operator|.
name|uuconf_pzalias
init|;
operator|*
name|pzal
operator|!=
name|NULL
condition|;
name|pzal
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zsystem
argument_list|,
operator|*
name|pzal
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fonxqt
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Turn the file into an absolute path.  */
if|if
condition|(
name|flocal
condition|)
name|zfile
operator|=
name|zsysdep_local_file_cwd
argument_list|(
name|zfile
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_zpubdir
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fexpand
condition|)
name|zfile
operator|=
name|zsysdep_add_cwd
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* Check for output redirection.  */
if|if
condition|(
name|foutput
condition|)
block|{
if|if
condition|(
name|flocal
condition|)
block|{
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_pzremote_receive
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to create %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
block|}
comment|/* There are various cases of output redirection.  	     uux cmd>out: The command is executed on the local 		 system, and the output file is placed on the local 		 system (fonxqt is TRUE).  	     uux cmd>a!out: The command is executed on the local 		 system, and the output file is sent to a.  	     uux a!cmd>out: The command is executed on a, and the 		 output file is returned to the local system (flocal 		 is TRUE).  	     uux a!cmd>a!out: The command is executed on a, and the 		 output file is left on a (fonxqt is TRUE).  	     uux a!cmd>b!out: The command is executed on a, and the 		 output file is sent to b; traditionally, I believe 		 that b is relative to a, rather than to the local 		 system.  However, this essentially contradicts the 		 previous two cases, in which the output file is 		 relative to the local system.  	     Now, the cases that we don't handle.  	     uux cmd>a!b!out: The command is executed on the local 		 system, and the output file is sent to b via a.  This 		 requires the local uuxqt to support forwarding of the 		 output file.  	     uux a!b!cmd>out: The command is executed on b, which is 		 reached via a.  Probably the output file is intended 		 for the local system, in which case the uuxqt on b 		 must support forwarding of the output file.  	     uux a!b!cmd>c!out: Is c relative to b or to the local 		 system?  If it's relative to b this is easy to 		 handle.  Otherwise, we must arrange for the file to 		 be sent back to the local system and for the local 		 system to send it on to c.  	     There are many variations of the last case.  It's not at 	     all clear to me how they should be handled.  */
if|if
condition|(
name|zforward
operator|!=
name|NULL
operator|||
name|zforw
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"May not forward standard output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fonxqt
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'O'
argument_list|,
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flocal
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'O'
argument_list|,
name|zfile
argument_list|,
name|zXxqtloc
argument_list|)
expr_stmt|;
else|else
name|uxadd_xqt_line
argument_list|(
literal|'O'
argument_list|,
name|zfile
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|finput
condition|)
block|{
if|if
condition|(
name|fread_stdin
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Standard input specified twice"
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flocal
condition|)
block|{
name|char
modifier|*
name|zuse
decl_stmt|;
name|char
modifier|*
name|zdata
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
comment|/* It's a local file.  If requested by -C, copy the file to 	     the spool directory.  If requested by -l, link the file 	     to the spool directory; if the link fails, we copy the 	     file, unless -c was explictly used.  If the execution is 	     occurring on the local system, we force the copy as well, 	     because otherwise we would have to have some way to tell 	     uuxqt not to move the file.  If the file is being shipped 	     to another system, we must set up a transfer request. 	     First make sure the user has legitimate access, since we 	     are running setuid.  */
if|if
condition|(
operator|!
name|fsysdep_access
argument_list|(
name|zfile
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|sXxqtsys
argument_list|,
name|zXxqtloc
argument_list|,
name|bXgrade
argument_list|,
name|FALSE
argument_list|,
name|abtname
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fcopy
operator|||
name|flink
operator|||
name|fXxqtlocal
condition|)
block|{
name|boolean
name|fdid
decl_stmt|;
name|uxrecord_file
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
name|fdid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|flink
condition|)
block|{
name|boolean
name|fworked
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_link
argument_list|(
name|zfile
argument_list|,
name|zdata
argument_list|,
operator|&
name|fworked
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fworked
condition|)
name|fdid
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fdontcopy
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: Can't link to spool directory"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fdid
condition|)
block|{
name|openfile_t
name|efile
decl_stmt|;
name|efile
operator|=
name|esysdep_user_fopen
argument_list|(
name|zfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|efile
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fcopy_open_file
argument_list|(
name|efile
argument_list|,
name|zdata
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|efile
argument_list|)
expr_stmt|;
block|}
name|zuse
operator|=
name|abtname
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't actually use the spool file name, but we 		 need a name to use as the destination.  */
name|ubuffree
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
comment|/* Make sure the daemon can access the file.  */
if|if
condition|(
operator|!
name|fsysdep_daemon_access
argument_list|(
name|zfile
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_pzlocal_send
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|zuser
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to send from %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|zuse
operator|=
name|zfile
expr_stmt|;
block|}
if|if
condition|(
name|fXxqtlocal
condition|)
block|{
if|if
condition|(
name|finput
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|zuse
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
operator|=
name|zuse
expr_stmt|;
block|}
else|else
block|{
name|finputcopied
operator|=
name|fcopy
operator|||
name|flink
expr_stmt|;
if|if
condition|(
name|finput
condition|)
block|{
name|zinput_from
operator|=
name|zuse
expr_stmt|;
name|zinput_to
operator|=
name|zbufcpy
argument_list|(
name|abdname
argument_list|)
expr_stmt|;
name|zinput_temp
operator|=
name|zbufcpy
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|uxadd_send_file
argument_list|(
name|zuse
argument_list|,
name|abdname
argument_list|,
name|finputcopied
condition|?
literal|"C"
else|:
literal|"c"
argument_list|,
name|abtname
argument_list|,
name|zforward
argument_list|)
expr_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abdname
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|zbase
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fonxqt
condition|)
block|{
comment|/* The file is already on the system where the command is to 	     be executed.  */
if|if
condition|(
name|finput
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
operator|=
name|zfile
expr_stmt|;
block|}
else|else
block|{
name|struct
name|uuconf_system
name|sfromsys
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|scmd
name|s
decl_stmt|;
name|char
modifier|*
name|zjobid
decl_stmt|;
comment|/* We need to request a remote file.  */
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zsystem
argument_list|,
operator|&
name|sfromsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_NOT_FOUND
condition|)
name|ulog_uuconf
argument_list|(
name|LOG_FATAL
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|funknown_system
argument_list|(
name|puuconf
argument_list|,
name|zsystem
argument_list|,
operator|&
name|sfromsys
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: System not found"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fonxqt
condition|)
block|{
comment|/* The file is already on the system where the command is to 		 be executed.  */
if|if
condition|(
name|finput
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
operator|=
name|zfile
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zdata
decl_stmt|;
if|if
condition|(
operator|!
name|sfromsys
operator|.
name|uuconf_fcall_transfer
operator|&&
operator|!
name|sfromsys
operator|.
name|uuconf_fcalled_transfer
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to transfer files to or from %s"
argument_list|,
name|sfromsys
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zforw
operator|!=
name|NULL
condition|)
block|{
comment|/* This is ``uux cmd a!b!file''.  To make this work, 		     we would have to be able to set up a request to a 		     to fetch file from b and send it to us.  But it 		     turns out that that will not work, because when a 		     sends us the file we will put it in a's spool 		     directory, not the local system spool directory. 		     So we won't have any way to find it.  This is not 		     a conceptual problem, and it could doubtless be 		     solved.  Please feel free to solve it and send me 		     the solution.  */
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"File forwarding not supported"
argument_list|)
expr_stmt|;
block|}
comment|/* We must request the file from the remote system to 		 this one.  */
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|slocalsys
argument_list|,
name|zXxqtloc
argument_list|,
name|bXgrade
argument_list|,
name|FALSE
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|ubuffree
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
comment|/* Request the file.  The special option '9' is a signal 		 to uucico that it's OK to receive a file into the 		 spool directory; normally such requests are rejected. 		 This privilege is easy to abuse.  */
name|s
operator|.
name|bcmd
operator|=
literal|'R'
expr_stmt|;
name|s
operator|.
name|bgrade
operator|=
name|bXgrade
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zfile
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zbufcpy
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
literal|"9"
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0600
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|ipos
operator|=
literal|0
expr_stmt|;
name|zjobid
operator|=
name|zsysdep_spool_commands
argument_list|(
operator|&
name|sfromsys
argument_list|,
name|bXgrade
argument_list|,
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|zjobid
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fjobid
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zjobid
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zjobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcall_any
condition|)
block|{
name|ubuffree
argument_list|(
name|zcall_system
argument_list|)
expr_stmt|;
name|zcall_system
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|fcall_any
operator|=
name|TRUE
expr_stmt|;
name|zcall_system
operator|=
name|zbufcpy
argument_list|(
name|sfromsys
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fXxqtlocal
condition|)
block|{
comment|/* Tell the command execution to wait until the file 		     has been received, and tell it the real file 		     name.  */
if|if
condition|(
name|finput
condition|)
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abtname
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|zbase
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|abxtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|zbase
decl_stmt|;
name|char
modifier|*
name|zxqt
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
comment|/* Now we must arrange to forward the file on to the 		     execution system.  We need to get a name to give 		     the file on the execution system (abxtname).  */
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|sXxqtsys
argument_list|,
name|zXxqtloc
argument_list|,
name|bXgrade
argument_list|,
name|TRUE
argument_list|,
name|abxtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|ubuffree
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|zxqt
operator|=
name|zsysdep_xqt_file_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|zxqt
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zxqt
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxrecord_file
argument_list|(
name|zxqt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"U %s %s\n"
argument_list|,
name|zsysdep_login_name
argument_list|()
argument_list|,
name|zlocalname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"F %s %s\n"
argument_list|,
name|abtname
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"C uucp -C -W -d -g %c %s %s!"
argument_list|,
name|bXgrade
argument_list|,
name|zbase
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zforward
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s!"
argument_list|,
name|zforward
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s\n"
argument_list|,
name|abxtname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fstdiosync
argument_list|(
name|e
argument_list|,
name|zxqt
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsync failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
condition|)
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abxtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|abxtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abxtname
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|zbase
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sfromsys
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If standard input is to be read from the stdin of uux, we read it      here into a temporary file and send it to the execute system.  */
if|if
condition|(
name|fread_stdin
condition|)
block|{
name|char
modifier|*
name|zdata
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|sXxqtsys
argument_list|,
name|zXxqtloc
argument_list|,
name|bXgrade
argument_list|,
name|FALSE
argument_list|,
name|abtname
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zdata
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|eXclose
operator|=
name|e
expr_stmt|;
name|uxrecord_file
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
name|uxcopy_stdin
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fstdiosync
argument_list|(
name|e
argument_list|,
name|zdata
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsync failed"
argument_list|)
expr_stmt|;
name|eXclose
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fXxqtlocal
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|abtname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|zinput_from
operator|=
name|zbufcpy
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
name|zinput_to
operator|=
name|zbufcpy
argument_list|(
name|abdname
argument_list|)
expr_stmt|;
name|zinput_temp
operator|=
name|zinput_from
expr_stmt|;
name|finputcopied
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* If we are returning standard input, or we're putting the status      in a file, we can't use an E command.  */
if|if
condition|(
name|fretstdin
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'B'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus_file
operator|!=
name|NULL
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'M'
argument_list|,
name|zstatus_file
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the complete command line, and decide whether the command      needs to be executed by the shell.  */
name|fneedshell
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zcmd
index|[
name|strcspn
argument_list|(
name|zcmd
argument_list|,
name|ZSHELLCHARS
argument_list|)
index|]
operator|!=
literal|'\0'
condition|)
name|fneedshell
operator|=
name|TRUE
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zcmd
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|clen
operator|+=
name|strlen
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
name|strcspn
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
name|ZSHELLCHARS
argument_list|)
index|]
operator|!=
literal|'\0'
condition|)
name|fneedshell
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|zfullcmd
operator|=
name|zbufalc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zfullcmd
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|zfullcmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zfullcmd
argument_list|,
name|pzargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fpoll
operator|=
name|FALSE
expr_stmt|;
comment|/* If we haven't written anything to the execution file yet, and we      have a standard input file, and we're not forwarding, then every      other option can be handled in an E command.  */
if|if
condition|(
name|eXxqt_file
operator|==
name|NULL
operator|&&
name|zinput_from
operator|!=
name|NULL
operator|&&
name|zforward
operator|==
name|NULL
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
name|char
modifier|*
name|zoptions
decl_stmt|;
comment|/* Set up an E command.  */
name|s
operator|.
name|bcmd
operator|=
literal|'E'
expr_stmt|;
name|s
operator|.
name|bgrade
operator|=
name|bXgrade
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zinput_from
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zinput_to
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
name|aboptions
expr_stmt|;
name|zoptions
operator|=
name|aboptions
expr_stmt|;
operator|*
name|zoptions
operator|++
operator|=
name|finputcopied
condition|?
literal|'C'
else|:
literal|'c'
expr_stmt|;
if|if
condition|(
name|fno_ack
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'N'
expr_stmt|;
if|if
condition|(
name|ferror_ack
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'Z'
expr_stmt|;
if|if
condition|(
name|zrequestor
operator|!=
name|NULL
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'R'
expr_stmt|;
if|if
condition|(
name|fneedshell
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'e'
expr_stmt|;
operator|*
name|zoptions
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
name|zinput_temp
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
if|if
condition|(
name|zrequestor
operator|==
name|NULL
condition|)
name|zrequestor
operator|=
literal|"\"\""
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
name|zrequestor
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|.
name|zcmd
operator|=
name|zfullcmd
expr_stmt|;
name|s
operator|.
name|ipos
operator|=
literal|0
expr_stmt|;
operator|++
name|cXcmds
expr_stmt|;
name|pasXcmds
operator|=
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasXcmds
argument_list|,
name|cXcmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|pasXcmds
index|[
name|cXcmds
operator|-
literal|1
index|]
operator|=
name|s
expr_stmt|;
name|uxadd_name
argument_list|(
name|zinput_from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|zfullcmd
operator|==
literal|'\0'
operator|&&
name|eXxqt_file
operator|==
name|NULL
operator|&&
name|zinput_from
operator|==
name|NULL
operator|&&
name|cXcmds
operator|==
literal|0
condition|)
block|{
comment|/* As a special case, if we are asked to execute an empty          command, we create a poll file instead.  */
name|fpoll
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Finish up the execute file.  */
name|uxadd_xqt_line
argument_list|(
literal|'U'
argument_list|,
name|zuser
argument_list|,
name|zXxqtloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|zinput_from
operator|!=
name|NULL
condition|)
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|zinput_to
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|zinput_to
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_send_file
argument_list|(
name|zinput_from
argument_list|,
name|zinput_to
argument_list|,
name|finputcopied
condition|?
literal|"C"
else|:
literal|"c"
argument_list|,
name|zinput_temp
argument_list|,
name|zforward
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fno_ack
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'N'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror_ack
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'Z'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zrequestor
operator|!=
name|NULL
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'R'
argument_list|,
name|zrequestor
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fneedshell
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'e'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'C'
argument_list|,
name|zfullcmd
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fstdiosync
argument_list|(
name|eXxqt_file
argument_list|,
literal|"execution file"
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsync failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|eXxqt_file
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|eXxqt_file
operator|=
name|NULL
expr_stmt|;
comment|/* If the execution is to occur on another system, we must now 	 arrange to copy the execute file to this system.  */
if|if
condition|(
operator|!
name|fXxqtlocal
condition|)
name|uxadd_send_file
argument_list|(
name|abXxqt_tname
argument_list|,
name|abXxqt_xname
argument_list|,
literal|"C"
argument_list|,
name|abXxqt_tname
argument_list|,
name|zforward
argument_list|)
expr_stmt|;
block|}
comment|/* If we got a signal, get out before spooling anything.  */
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* From here on in, it's too late.  We don't call uxabort.  */
if|if
condition|(
name|cXcmds
operator|>
literal|0
operator|||
name|fpoll
condition|)
block|{
name|char
modifier|*
name|zjobid
decl_stmt|;
if|if
condition|(
operator|!
name|fpoll
operator|&&
operator|!
name|sXxqtsys
operator|.
name|uuconf_fcall_transfer
operator|&&
operator|!
name|sXxqtsys
operator|.
name|uuconf_fcalled_transfer
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to transfer files to or from %s"
argument_list|,
name|sXxqtsys
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
name|zjobid
operator|=
name|zsysdep_spool_commands
argument_list|(
operator|&
name|sXxqtsys
argument_list|,
name|bXgrade
argument_list|,
name|cXcmds
argument_list|,
name|pasXcmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|zjobid
operator|==
name|NULL
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fjobid
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zjobid
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zjobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcall_any
condition|)
block|{
name|ubuffree
argument_list|(
name|zcall_system
argument_list|)
expr_stmt|;
name|zcall_system
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|fcall_any
operator|=
name|TRUE
expr_stmt|;
name|zcall_system
operator|=
name|zbufcpy
argument_list|(
name|sXxqtsys
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fpoll
condition|)
block|{
comment|/* If all that worked, make a log file entry.  All log file 	 reports up to this point went to stderr.  */
name|ulog_to_file
argument_list|(
name|puuconf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_system
argument_list|(
name|sXxqtsys
operator|.
name|uuconf_zname
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|zXnames
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Queuing %s"
argument_list|,
name|zfullcmd
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Queuing %s (%s)"
argument_list|,
name|zfullcmd
argument_list|,
name|zXnames
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fuucico
operator|||
operator|(
name|zcall_system
operator|==
name|NULL
operator|&&
operator|!
name|fcall_any
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fXxqtlocal
operator|||
operator|!
name|fuucico
condition|)
name|fexit
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zconfigarg
decl_stmt|;
if|if
condition|(
name|zconfig
operator|==
name|NULL
condition|)
name|zconfigarg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|zconfigarg
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"-I"
operator|+
name|strlen
argument_list|(
name|zconfig
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zconfigarg
argument_list|,
literal|"-I%s"
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
block|}
name|fexit
operator|=
name|fsysdep_run
argument_list|(
name|FALSE
argument_list|,
literal|"uuxqt"
argument_list|,
name|zconfigarg
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zcicoarg
decl_stmt|;
name|char
modifier|*
name|zconfigarg
decl_stmt|;
if|if
condition|(
name|zcall_system
operator|==
name|NULL
condition|)
name|zcicoarg
operator|=
literal|"-r1"
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"-Cs"
operator|+
name|strlen
argument_list|(
name|zcall_system
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"-Cs%s"
argument_list|,
name|zcall_system
argument_list|)
expr_stmt|;
name|zcicoarg
operator|=
name|z
expr_stmt|;
block|}
if|if
condition|(
name|zconfig
operator|==
name|NULL
condition|)
name|zconfigarg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|zconfigarg
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"-I"
operator|+
name|strlen
argument_list|(
name|zconfig
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zconfigarg
argument_list|,
literal|"-I%s"
argument_list|,
name|zconfig
argument_list|)
expr_stmt|;
block|}
name|fexit
operator|=
name|fsysdep_run
argument_list|(
name|FALSE
argument_list|,
literal|"uucico"
argument_list|,
name|zcicoarg
argument_list|,
name|zconfigarg
argument_list|)
expr_stmt|;
block|}
name|usysdep_exit
argument_list|(
name|fexit
argument_list|)
expr_stmt|;
comment|/* Avoid error about not returning a value.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Report command usage.  */
end_comment

begin_function
specifier|static
name|void
name|uxhelp
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995 Ian Lance Taylor\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Usage: %s [options] [-] command\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -,-p,--stdin: Read standard input for standard input of command\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -c,--nocopy: Do not copy local files to spool directory (default)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -C,--copy: Copy local files to spool directory\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -l,--link: link local files to spool directory\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -g,--grade grade: Set job grade (must be alphabetic)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -n,--notification=no: Do not report completion status\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -z,--notification=error: Report completion status only on error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -r,--nouucico: Do not start uucico daemon\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -a,--requestor address: Address to mail status report to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -b,--return-stdin: Return standard input with status report\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -s,--status file: Report completion status to file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -j,--jobid: Report job id\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -x,--debug debug: Set debugging level\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|printf
argument_list|(
literal|" -I,--config file: Set configuration file to use\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|printf
argument_list|(
literal|" -v,--version: Print version and exit\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" --help: Print help and exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uxusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options] [-] command\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use %s --help for help\n"
argument_list|,
name|zProgram
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a line to the execute file.  */
end_comment

begin_function
specifier|static
name|void
name|uxadd_xqt_line
parameter_list|(
name|bchar
parameter_list|,
name|z1
parameter_list|,
name|z2
parameter_list|)
name|int
name|bchar
decl_stmt|;
specifier|const
name|char
modifier|*
name|z1
decl_stmt|;
specifier|const
name|char
modifier|*
name|z2
decl_stmt|;
block|{
if|if
condition|(
name|eXxqt_file
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zxqt_name
decl_stmt|;
if|if
condition|(
name|fXxqtlocal
condition|)
name|zxqt_name
operator|=
name|zsysdep_xqt_file_name
argument_list|()
expr_stmt|;
else|else
name|zxqt_name
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|sXxqtsys
argument_list|,
name|zXxqtloc
argument_list|,
name|bXgrade
argument_list|,
name|TRUE
argument_list|,
name|abXxqt_tname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|abXxqt_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxqt_name
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxrecord_file
argument_list|(
name|zxqt_name
argument_list|)
expr_stmt|;
name|eXxqt_file
operator|=
name|esysdep_fopen
argument_list|(
name|zxqt_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eXxqt_file
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|z1
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"%c\n"
argument_list|,
name|bchar
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|z2
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"%c %s\n"
argument_list|,
name|bchar
argument_list|,
name|z1
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"%c %s %s\n"
argument_list|,
name|bchar
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a file to be sent to the execute system.  */
end_comment

begin_function
specifier|static
name|void
name|uxadd_send_file
parameter_list|(
name|zfrom
parameter_list|,
name|zto
parameter_list|,
name|zoptions
parameter_list|,
name|ztemp
parameter_list|,
name|zforward
parameter_list|)
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zoptions
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
specifier|const
name|char
modifier|*
name|zforward
decl_stmt|;
block|{
name|struct
name|scmd
name|s
decl_stmt|;
if|if
condition|(
name|zforward
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|char
modifier|*
name|zxqt
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abxname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
comment|/* We want to forward this file through the first execution 	 system to other systems.  We set up a remote execution of 	 uucp to forward the file.  */
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|zxqt
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|sXxqtsys
argument_list|,
name|zXxqtloc
argument_list|,
name|bXgrade
argument_list|,
name|TRUE
argument_list|,
name|abtname
argument_list|,
name|abdname
argument_list|,
name|abxname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxqt
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zxqt
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxrecord_file
argument_list|(
name|zxqt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"U %s %s\n"
argument_list|,
name|zsysdep_login_name
argument_list|()
argument_list|,
name|zXxqtloc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"F %s %s\n"
argument_list|,
name|abdname
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"C uucp -C -W -d -g %c %s %s!%s\n"
argument_list|,
name|bXgrade
argument_list|,
name|zbase
argument_list|,
name|zforward
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fstdiosync
argument_list|(
name|e
argument_list|,
name|zxqt
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsync failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send the execution file.  */
name|s
operator|.
name|bcmd
operator|=
literal|'S'
expr_stmt|;
name|s
operator|.
name|bgrade
operator|=
name|bXgrade
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zbufcpy
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zbufcpy
argument_list|(
name|abxname
argument_list|)
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
literal|"C"
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
name|s
operator|.
name|zfrom
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|ipos
operator|=
literal|0
expr_stmt|;
operator|++
name|cXcmds
expr_stmt|;
name|pasXcmds
operator|=
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasXcmds
argument_list|,
name|cXcmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|pasXcmds
index|[
name|cXcmds
operator|-
literal|1
index|]
operator|=
name|s
expr_stmt|;
name|uxadd_name
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
comment|/* Send the data file to abdname where the execution file will 	 expect it.  */
name|zto
operator|=
name|abdname
expr_stmt|;
block|}
name|s
operator|.
name|bcmd
operator|=
literal|'S'
expr_stmt|;
name|s
operator|.
name|bgrade
operator|=
name|bXgrade
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zbufcpy
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zbufcpy
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
name|zbufcpy
argument_list|(
name|zoptions
argument_list|)
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
name|zbufcpy
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|ipos
operator|=
literal|0
expr_stmt|;
operator|++
name|cXcmds
expr_stmt|;
name|pasXcmds
operator|=
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasXcmds
argument_list|,
name|cXcmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|pasXcmds
index|[
name|cXcmds
operator|-
literal|1
index|]
operator|=
name|s
expr_stmt|;
name|uxadd_name
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy stdin to a file.  This is a separate function because it may    call setjmp.  */
end_comment

begin_function
specifier|static
name|void
name|uxcopy_stdin
parameter_list|(
name|e
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
block|{
name|CATCH_PROTECT
name|size_t
name|cread
decl_stmt|;
name|char
name|ab
index|[
literal|1024
index|]
decl_stmt|;
do|do
block|{
name|size_t
name|cwrite
decl_stmt|;
comment|/* I want to use fread here, but there is a bug in some versions 	 of SVR4 which causes fread to return less than a complete 	 buffer even if EOF has not been reached.  This is not online 	 time, so speed is not critical, but it's still quite annoying 	 to have to use an inefficient algorithm.  */
name|cread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
name|usysdep_start_catch
argument_list|()
expr_stmt|;
while|while
condition|(
name|cread
operator|<
sizeof|sizeof
argument_list|(
name|ab
argument_list|)
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* There's an unimportant race here.  If the user hits 		 ^C between the FGOT_SIGNAL we just did and the time 		 we enter getchar, we won't know about the signal 		 (unless we're doing a longjmp, but we normally 		 aren't).  It's not a big problem, because the user 		 can just hit ^C again.  */
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|EOF
condition|)
break|break;
name|ab
index|[
name|cread
index|]
operator|=
name|b
expr_stmt|;
operator|++
name|cread
expr_stmt|;
block|}
block|}
name|usysdep_end_catch
argument_list|()
expr_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cread
operator|>
literal|0
condition|)
block|{
name|cwrite
operator|=
name|fwrite
argument_list|(
name|ab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cread
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrite
operator|!=
name|cread
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fwrite: Wrote %d when attempted %d"
argument_list|,
operator|(
name|int
operator|)
name|cwrite
argument_list|,
operator|(
name|int
operator|)
name|cread
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cread
operator|==
sizeof|sizeof
name|ab
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of all files we have created so that we can delete them    if we get a signal.  The argument will be on the heap.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cXfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|pXaz
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|uxrecord_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|pXaz
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pXaz
argument_list|,
operator|(
name|cXfiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pXaz
index|[
name|cXfiles
index|]
operator|=
name|zfile
expr_stmt|;
operator|++
name|cXfiles
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files we have recorded and exit.  */
end_comment

begin_function
specifier|static
name|void
name|uxabort
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|eXxqt_file
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eXxqt_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|eXclose
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eXclose
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cXfiles
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|pXaz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a name to the list of file names we are going to log.  We log    all the file names which will appear in the uucico log file.  This    permits people to associate the file send in the uucico log with    the uux entry which created the file.  Normally only one file name    will appear.  */
end_comment

begin_function
specifier|static
name|void
name|uxadd_name
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
if|if
condition|(
name|zXnames
operator|==
name|NULL
condition|)
name|zXnames
operator|=
name|zbufcpy
argument_list|(
name|z
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|cold
decl_stmt|,
name|cadd
decl_stmt|;
name|char
modifier|*
name|znew
decl_stmt|;
name|cold
operator|=
name|strlen
argument_list|(
name|zXnames
argument_list|)
expr_stmt|;
name|cadd
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|cold
operator|+
literal|2
operator|+
name|cadd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|znew
argument_list|,
name|zXnames
argument_list|,
name|cold
argument_list|)
expr_stmt|;
name|znew
index|[
name|cold
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|znew
operator|+
name|cold
operator|+
literal|1
argument_list|,
name|z
argument_list|,
name|cadd
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zXnames
argument_list|)
expr_stmt|;
name|zXnames
operator|=
name|znew
expr_stmt|;
block|}
block|}
end_function

end_unit

