begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* split.c    Split a string into tokens.     Copyright (C) 1992 Ian Lance Taylor     This file is part of the Taylor UUCP uuconf library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License    as published by the Free Software Foundation; either version 2 of    the License, or (at your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucnfi.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|_uuconf_split_rcsid
index|[]
init|=
literal|"$Id: split.c,v 1.5 1995/06/21 19:24:09 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Split a string into tokens.  The bsep argument is the separator to    use.  If it is the null byte, white space is used as the separator,    and leading white space is discarded.  Otherwise, each occurrence    of the separator character delimits a field (and thus some fields    may be empty).  The array and size arguments may be used to reuse    the same memory.  This function is not tied to uuconf; the only way    it can fail is if malloc or realloc fails.  */
end_comment

begin_function
name|int
name|_uuconf_istrsplit
parameter_list|(
name|zline
parameter_list|,
name|bsep
parameter_list|,
name|ppzsplit
parameter_list|,
name|pcsplit
parameter_list|)
specifier|register
name|char
modifier|*
name|zline
decl_stmt|;
name|int
name|bsep
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|ppzsplit
decl_stmt|;
name|size_t
modifier|*
name|pcsplit
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|bsep
operator|==
literal|'\0'
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zline
argument_list|)
argument_list|)
condition|)
operator|++
name|zline
expr_stmt|;
if|if
condition|(
operator|*
name|zline
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
operator|*
name|pcsplit
condition|)
block|{
name|char
modifier|*
modifier|*
name|pznew
decl_stmt|;
name|size_t
name|cnew
decl_stmt|;
if|if
condition|(
operator|*
name|pcsplit
operator|==
literal|0
condition|)
block|{
name|cnew
operator|=
literal|8
expr_stmt|;
name|pznew
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|cnew
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cnew
operator|=
operator|*
name|pcsplit
operator|*
literal|2
expr_stmt|;
name|pznew
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|ppzsplit
argument_list|,
name|cnew
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pznew
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|ppzsplit
operator|=
name|pznew
expr_stmt|;
operator|*
name|pcsplit
operator|=
name|cnew
expr_stmt|;
block|}
operator|(
operator|*
name|ppzsplit
operator|)
index|[
name|i
index|]
operator|=
name|zline
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|bsep
operator|==
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|zline
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zline
argument_list|)
argument_list|)
condition|)
operator|++
name|zline
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|zline
operator|!=
literal|'\0'
operator|&&
operator|*
name|zline
operator|!=
name|bsep
condition|)
operator|++
name|zline
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|zline
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|zline
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

end_unit

