begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* callin.c    Check a login name and password against the UUCP password file.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP uuconf library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License    as published by the Free Software Foundation; either version 2 of    the License, or (at your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucnfi.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|_uuconf_callin_rcsid
index|[]
init|=
literal|"$Id: callin.c,v 1.4 1995/08/19 21:26:43 ache Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|ipcheck
name|P
argument_list|(
operator|(
name|pointer
name|pglobal
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
name|pointer
name|pinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sinfo
block|{
name|int
argument_list|(
argument|*pcmpfn
argument_list|)
name|P
argument_list|(
operator|(
name|int
operator|,
name|pointer
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|pointer
name|pinfo
decl_stmt|;
name|boolean
name|ffound
decl_stmt|;
name|boolean
name|fmatched
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Check a login name and password against the UUCP password file.    This looks at the Taylor UUCP password file, but will work even if    uuconf_taylor_init was not called.  It accepts either spaces or    colons as field delimiters.  */
end_comment

begin_function_decl
name|int
name|uuconf_callin
parameter_list|(
name|pglobal
parameter_list|,
name|pcmpfn
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|pglobal
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*pcmpfn
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|int
operator|,
name|pointer
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pointer
name|pinfo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sglobal
modifier|*
name|qglobal
init|=
operator|(
expr|struct
name|sglobal
operator|*
operator|)
name|pglobal
decl_stmt|;
name|int
name|iret
decl_stmt|;
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|struct
name|uuconf_cmdtab
name|as
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|sinfo
name|s
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|size_t
name|cline
decl_stmt|;
comment|/* If we have no password file names, fill in the default name.  */
if|if
condition|(
name|qglobal
operator|->
name|qprocess
operator|->
name|pzpwdfiles
operator|==
name|NULL
condition|)
block|{
name|char
name|ab
index|[
sizeof|sizeof
name|NEWCONFIGLIB
operator|+
sizeof|sizeof
name|PASSWDFILE
operator|-
literal|1
index|]
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|pointer
operator|)
name|ab
argument_list|,
operator|(
name|pointer
operator|)
name|NEWCONFIGLIB
argument_list|,
sizeof|sizeof
name|NEWCONFIGLIB
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
call|(
name|pointer
call|)
argument_list|(
name|ab
operator|+
sizeof|sizeof
name|NEWCONFIGLIB
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|pointer
operator|)
name|PASSWDFILE
argument_list|,
sizeof|sizeof
name|PASSWDFILE
argument_list|)
expr_stmt|;
name|iret
operator|=
name|_uuconf_iadd_string
argument_list|(
name|qglobal
argument_list|,
name|ab
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|qglobal
operator|->
name|qprocess
operator|->
name|pzpwdfiles
argument_list|,
name|qglobal
operator|->
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
name|as
index|[
literal|0
index|]
operator|.
name|uuconf_zcmd
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|pcmpfn
operator|=
name|pcmpfn
expr_stmt|;
name|s
operator|.
name|pinfo
operator|=
name|pinfo
expr_stmt|;
name|s
operator|.
name|ffound
operator|=
name|FALSE
expr_stmt|;
name|s
operator|.
name|fmatched
operator|=
name|FALSE
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|pzpwdfiles
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|fopen
argument_list|(
operator|*
name|pz
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|FNO_SUCH_FILE
argument_list|()
condition|)
continue|continue;
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_FOPEN_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|qglobal
operator|->
name|ilineno
operator|=
literal|0
expr_stmt|;
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|z0
decl_stmt|,
modifier|*
name|z1
decl_stmt|;
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
comment|/* We have a few hacks to make Unix style passwd files work. 	     1) We turn the first two colon characters into spaces. 	     2) If the colon characters are adjacent, we assume there 	        is no password, and we skip the entry. 	     3) If the password between colon characters contains a 	        space, we assume that it has been disabled, and we 		skip the entry.  */
name|z0
operator|=
name|strchr
argument_list|(
name|zline
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|z0
operator|!=
name|NULL
condition|)
block|{
operator|*
name|z0
operator|=
literal|' '
expr_stmt|;
name|z1
operator|=
name|strchr
argument_list|(
name|z0
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|z1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|z1
operator|-
name|z0
operator|==
literal|1
condition|)
continue|continue;
operator|*
name|z1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|z0
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
block|}
block|}
name|iret
operator|=
name|uuconf_cmd_line
argument_list|(
name|pglobal
argument_list|,
name|zline
argument_list|,
name|as
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|s
argument_list|,
name|ipcheck
argument_list|,
literal|0
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iret
operator|&
name|UUCONF_CMDTABRET_EXIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|iret
operator|&=
operator|~
name|UUCONF_CMDTABRET_EXIT
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
name|iret
operator||=
name|UUCONF_ERROR_LINENO
expr_stmt|;
break|break;
block|}
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
operator|||
name|s
operator|.
name|ffound
condition|)
break|break;
block|}
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|qglobal
operator|->
name|zfilename
operator|=
operator|*
name|pz
expr_stmt|;
name|iret
operator||=
name|UUCONF_ERROR_FILENAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|s
operator|.
name|ffound
operator|||
operator|!
name|s
operator|.
name|fmatched
condition|)
name|iret
operator|=
name|UUCONF_NOT_FOUND
expr_stmt|;
return|return
name|iret
return|;
block|}
end_block

begin_comment
comment|/* This is called on each line of the file.  It checks to see if the    login name from the file is the one we are looking for.  If it is,    it sets ffound, and then sets fmatched according to whether the    password matches or not.  */
end_comment

begin_function
specifier|static
name|int
name|ipcheck
parameter_list|(
name|pglobal
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|pinfo
parameter_list|)
name|pointer
name|pglobal
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
name|pointer
name|pinfo
decl_stmt|;
block|{
name|struct
name|sinfo
modifier|*
name|q
init|=
operator|(
expr|struct
name|sinfo
operator|*
operator|)
name|pinfo
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
return|return
name|UUCONF_SYNTAX_ERROR
operator||
name|UUCONF_CMDTABRET_EXIT
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|q
operator|->
name|pcmpfn
call|)
argument_list|(
literal|0
argument_list|,
name|q
operator|->
name|pinfo
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|UUCONF_CMDTABRET_CONTINUE
return|;
name|q
operator|->
name|ffound
operator|=
name|TRUE
expr_stmt|;
name|q
operator|->
name|fmatched
operator|=
call|(
modifier|*
name|q
operator|->
name|pcmpfn
call|)
argument_list|(
literal|1
argument_list|,
name|q
operator|->
name|pinfo
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
expr_stmt|;
return|return
name|UUCONF_CMDTABRET_EXIT
return|;
block|}
end_function

end_unit

