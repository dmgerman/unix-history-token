begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hsinfo.c    Get information about a system from the HDB configuration files.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP uuconf library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License    as published by the Free Software Foundation; either version 2 of    the License, or (at your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucnfi.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|_uuconf_hsinfo_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|ihadd_machine_perm
name|P
argument_list|(
operator|(
expr|struct
name|sglobal
operator|*
name|qglobal
operator|,
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
expr|struct
name|shpermissions
operator|*
name|qperm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ihadd_logname_perm
name|P
argument_list|(
operator|(
expr|struct
name|sglobal
operator|*
name|qglobal
operator|,
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
expr|struct
name|shpermissions
operator|*
name|qperm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Get the information for a particular system from the HDB    configuration files.  This does not make sure that all the default    values are set.  */
end_comment

begin_function
name|int
name|_uuconf_ihdb_system_internal
parameter_list|(
name|qglobal
parameter_list|,
name|zsystem
parameter_list|,
name|qsys
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
block|{
name|int
name|iret
decl_stmt|;
name|struct
name|shpermissions
modifier|*
name|qperm
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|size_t
name|cline
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzsplit
decl_stmt|;
name|size_t
name|csplit
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzcomma
decl_stmt|;
name|size_t
name|ccomma
decl_stmt|;
name|pointer
name|pblock
decl_stmt|;
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|boolean
name|ffound_machine
decl_stmt|,
name|ffound_login
decl_stmt|;
name|struct
name|shpermissions
modifier|*
name|qother_machine
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qalt
decl_stmt|;
if|if
condition|(
operator|!
name|qglobal
operator|->
name|qprocess
operator|->
name|fhdb_read_permissions
condition|)
block|{
name|iret
operator|=
name|_uuconf_ihread_permissions
argument_list|(
name|qglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
comment|/* First look through the Permissions information to see if this is      an alias for some system.  I assume that an alias applies to the      first name in the corresponding MACHINE entry.  */
for|for
control|(
name|qperm
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|qhdb_permissions
init|;
name|qperm
operator|!=
name|NULL
condition|;
name|qperm
operator|=
name|qperm
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|qperm
operator|->
name|pzalias
operator|==
name|NULL
operator|||
name|qperm
operator|->
name|pzmachine
operator|==
name|NULL
operator|||
name|qperm
operator|->
name|pzalias
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|||
name|qperm
operator|->
name|pzmachine
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
condition|)
continue|continue;
for|for
control|(
name|pz
operator|=
name|qperm
operator|->
name|pzalias
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
name|zsystem
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zsystem
operator|=
name|qperm
operator|->
name|pzmachine
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|pz
operator|!=
name|NULL
condition|)
break|break;
block|}
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
name|pzsplit
operator|=
name|NULL
expr_stmt|;
name|csplit
operator|=
literal|0
expr_stmt|;
name|pzcomma
operator|=
name|NULL
expr_stmt|;
name|ccomma
operator|=
literal|0
expr_stmt|;
name|pblock
operator|=
name|NULL
expr_stmt|;
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|pzhdb_systems
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|cchars
decl_stmt|;
name|qglobal
operator|->
name|ilineno
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
operator|*
name|pz
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|FNO_SUCH_FILE
argument_list|()
condition|)
continue|continue;
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_FOPEN_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|cchars
operator|=
name|_uuconf_getline
argument_list|(
name|qglobal
argument_list|,
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|ctoks
decl_stmt|,
name|ctimes
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qset
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|zretry
decl_stmt|;
name|int
name|cretry
decl_stmt|;
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
operator|--
name|cchars
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|cchars
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|cchars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
name|zline
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|zline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|ctoks
operator|=
name|_uuconf_istrsplit
argument_list|(
name|zline
argument_list|,
literal|'\0'
argument_list|,
operator|&
name|pzsplit
argument_list|,
operator|&
name|csplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
comment|/* If this isn't the system we're looking for, keep reading 	     the file.  */
if|if
condition|(
name|ctoks
operator|<
literal|1
operator|||
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|pzsplit
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If this is the first time we've found the system, we want 	     to set *qsys directly.  Otherwise, we allocate a new 	     alternate.  */
if|if
condition|(
name|pblock
operator|==
name|NULL
condition|)
block|{
name|pblock
operator|=
name|uuconf_malloc_block
argument_list|()
expr_stmt|;
if|if
condition|(
name|pblock
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|_uuconf_uclear_system
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
name|qsys
operator|->
name|uuconf_palloc
operator|=
name|pblock
expr_stmt|;
name|qset
operator|=
name|qsys
expr_stmt|;
block|}
else|else
block|{
name|struct
name|uuconf_system
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qset
operator|=
operator|(
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_system
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qset
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|_uuconf_uclear_system
argument_list|(
name|qset
argument_list|)
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qsys
operator|->
name|uuconf_qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qset
expr_stmt|;
block|}
comment|/* Add this line to the memory block we are building for the 	     system.  */
if|if
condition|(
name|uuconf_add_block
argument_list|(
name|pblock
argument_list|,
name|zline
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
comment|/* The format of a line in Systems is 	     system time device speed phone chat 	     For example, 	     airs Any ACU 9600 5551212 ogin: foo pass: bar 	     */
comment|/* Get the system name.  */
name|qset
operator|->
name|uuconf_zname
operator|=
name|pzsplit
index|[
literal|0
index|]
expr_stmt|;
name|qset
operator|->
name|uuconf_fcall
operator|=
name|TRUE
expr_stmt|;
name|qset
operator|->
name|uuconf_fcalled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|2
condition|)
continue|continue;
comment|/* A time string is "time/grade,time/grade;retry".  A 	     missing grade is taken as BGRADE_LOW.  */
name|zretry
operator|=
name|strchr
argument_list|(
name|pzsplit
index|[
literal|1
index|]
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zretry
operator|==
name|NULL
condition|)
name|cretry
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|zretry
operator|=
literal|'\0'
expr_stmt|;
name|cretry
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|zretry
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|ctimes
operator|=
name|_uuconf_istrsplit
argument_list|(
name|pzsplit
index|[
literal|1
index|]
argument_list|,
literal|','
argument_list|,
operator|&
name|pzcomma
argument_list|,
operator|&
name|ccomma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctimes
operator|<
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctimes
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|zslash
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
name|z
operator|=
name|pzcomma
index|[
name|i
index|]
expr_stmt|;
name|zslash
operator|=
name|strchr
argument_list|(
name|z
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
condition|)
name|bgrade
operator|=
name|UUCONF_GRADE_LOW
expr_stmt|;
else|else
block|{
operator|*
name|zslash
operator|=
literal|'\0'
expr_stmt|;
name|bgrade
operator|=
name|zslash
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|UUCONF_GRADE_LEGAL
argument_list|(
name|bgrade
argument_list|)
condition|)
name|bgrade
operator|=
name|UUCONF_GRADE_LOW
expr_stmt|;
block|}
name|iret
operator|=
name|_uuconf_itime_parse
argument_list|(
name|qglobal
argument_list|,
name|z
argument_list|,
operator|(
name|long
operator|)
name|bgrade
argument_list|,
name|cretry
argument_list|,
name|_uuconf_itime_grade_cmp
argument_list|,
operator|&
name|qset
operator|->
name|uuconf_qtimegrade
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
comment|/* We treat a syntax error in the time field as                  equivalent to ``never'', on the assumption that that                  is what HDB does.  */
if|if
condition|(
name|iret
operator|==
name|UUCONF_SYNTAX_ERROR
condition|)
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
comment|/* Treat any time/grade setting as both a timegrade and 		 a call-timegrade.  */
if|if
condition|(
name|bgrade
operator|!=
name|UUCONF_GRADE_LOW
condition|)
name|qset
operator|->
name|uuconf_qcalltimegrade
operator|=
name|qset
operator|->
name|uuconf_qtimegrade
expr_stmt|;
block|}
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
if|if
condition|(
name|ctoks
operator|<
literal|3
condition|)
continue|continue;
comment|/* Pick up the device name.  It can be followed by a comma 	     and a list of protocols.  */
name|qset
operator|->
name|uuconf_zport
operator|=
name|pzsplit
index|[
literal|2
index|]
expr_stmt|;
name|z
operator|=
name|strchr
argument_list|(
name|pzsplit
index|[
literal|2
index|]
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|qset
operator|->
name|uuconf_zprotocols
operator|=
name|z
operator|+
literal|1
expr_stmt|;
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ctoks
operator|<
literal|4
condition|)
continue|continue;
comment|/* The speed entry can be a numeric speed, or a range of 	     speeds, or "Any", or "-".  If it starts with a letter, 	     the initial nonnumeric prefix is a modem class, which 	     gets appended to the port name.  */
name|z
operator|=
name|pzsplit
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|z
argument_list|,
literal|"Any"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|zend
decl_stmt|;
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
operator|&&
operator|!
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
operator|++
name|z
expr_stmt|;
name|qset
operator|->
name|uuconf_ibaud
operator|=
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|==
literal|'-'
condition|)
name|qset
operator|->
name|uuconf_ihighbaud
operator|=
name|strtol
argument_list|(
name|zend
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|pzsplit
index|[
literal|3
index|]
condition|)
block|{
name|size_t
name|cport
decl_stmt|,
name|cclass
decl_stmt|;
name|cport
operator|=
name|strlen
argument_list|(
name|pzsplit
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cclass
operator|=
name|z
operator|-
name|pzsplit
index|[
literal|3
index|]
expr_stmt|;
name|qset
operator|->
name|uuconf_zport
operator|=
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
name|cport
operator|+
name|cclass
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qset
operator|->
name|uuconf_zport
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
operator|(
name|pointer
operator|)
name|qset
operator|->
name|uuconf_zport
argument_list|,
operator|(
name|pointer
operator|)
name|pzsplit
index|[
literal|2
index|]
argument_list|,
name|cport
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
call|(
name|pointer
call|)
argument_list|(
name|qset
operator|->
name|uuconf_zport
operator|+
name|cport
argument_list|)
argument_list|,
operator|(
name|pointer
operator|)
name|pzsplit
index|[
literal|3
index|]
argument_list|,
name|cclass
argument_list|)
expr_stmt|;
name|qset
operator|->
name|uuconf_zport
index|[
name|cport
operator|+
name|cclass
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctoks
operator|<
literal|5
condition|)
continue|continue;
comment|/* Get the phone number.  */
name|qset
operator|->
name|uuconf_zphone
operator|=
name|pzsplit
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|6
condition|)
continue|continue;
comment|/* Get the chat script.  We just hand this off to the chat 	     script processor, so that it will parse subsend and 	     subexpect strings correctly.  */
name|pzsplit
index|[
literal|4
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"chat"
expr_stmt|;
name|iret
operator|=
name|_uuconf_ichat_cmd
argument_list|(
name|qglobal
argument_list|,
name|ctoks
operator|-
literal|4
argument_list|,
name|pzsplit
operator|+
literal|4
argument_list|,
operator|&
name|qset
operator|->
name|uuconf_schat
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
name|iret
operator|&=
operator|~
name|UUCONF_CMDTABRET_KEEP
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzsplit
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzsplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzcomma
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzcomma
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|qglobal
operator|->
name|zfilename
operator|=
operator|*
name|pz
expr_stmt|;
return|return
name|iret
operator||
name|UUCONF_ERROR_FILENAME
operator||
name|UUCONF_ERROR_LINENO
return|;
block|}
if|if
condition|(
name|pblock
operator|==
name|NULL
condition|)
return|return
name|UUCONF_NOT_FOUND
return|;
comment|/* Now we have to put in the Permissions information.  The relevant      Permissions entries are those with this system in the MACHINE      list and (if this system does not have a VALIDATE entry) those      with a LOGNAME list but no MACHINE list.  If no entry is found      with this system in the MACHINE list, then we must look for an      entry with "OTHER" in the MACHINE list.  */
name|ffound_machine
operator|=
name|FALSE
expr_stmt|;
name|ffound_login
operator|=
name|FALSE
expr_stmt|;
name|qother_machine
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|qperm
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|qhdb_permissions
init|;
name|qperm
operator|!=
name|NULL
condition|;
name|qperm
operator|=
name|qperm
operator|->
name|qnext
control|)
block|{
name|boolean
name|fmachine
decl_stmt|;
comment|/* MACHINE=OTHER is recognized specially.  It appears that OTHER 	 need only be recognized by itself, not when combined with 	 other machine names.  */
if|if
condition|(
name|qother_machine
operator|==
name|NULL
operator|&&
name|qperm
operator|->
name|pzmachine
operator|!=
name|NULL
operator|&&
name|qperm
operator|->
name|pzmachine
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|&&
name|qperm
operator|->
name|pzmachine
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|strcmp
argument_list|(
name|qperm
operator|->
name|pzmachine
index|[
literal|0
index|]
argument_list|,
literal|"OTHER"
argument_list|)
operator|==
literal|0
condition|)
name|qother_machine
operator|=
name|qperm
expr_stmt|;
comment|/* If this system is named in a MACHINE entry, we must add the 	 appropriate information to every alternate that could be used 	 for calling out.  */
name|fmachine
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ffound_machine
operator|&&
name|qperm
operator|->
name|pzmachine
operator|!=
name|NULL
operator|&&
name|qperm
operator|->
name|pzmachine
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
condition|)
block|{
for|for
control|(
name|pz
operator|=
name|qperm
operator|->
name|pzmachine
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pz
operator|)
index|[
literal|0
index|]
operator|==
name|zsystem
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
name|zsystem
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|qalt
operator|=
name|qsys
init|;
name|qalt
operator|!=
name|NULL
condition|;
name|qalt
operator|=
name|qalt
operator|->
name|uuconf_qalternate
control|)
block|{
if|if
condition|(
name|qalt
operator|->
name|uuconf_fcall
condition|)
block|{
name|iret
operator|=
name|ihadd_machine_perm
argument_list|(
name|qglobal
argument_list|,
name|qalt
argument_list|,
name|qperm
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
block|}
name|fmachine
operator|=
name|TRUE
expr_stmt|;
name|ffound_machine
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* A LOGNAME line applies to this machine if it is listed in the 	 corresponding VALIDATE entry, or if it is not listed in any 	 VALIDATE entry.  On this pass through the Permissions entry 	 we pick up the information if the system appears in a 	 VALIDATE entry; if it does not, we make another pass to put 	 in all the LOGNAME lines.  */
if|if
condition|(
name|qperm
operator|->
name|pzlogname
operator|!=
name|NULL
operator|&&
name|qperm
operator|->
name|pzlogname
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|&&
name|qperm
operator|->
name|pzvalidate
operator|!=
name|NULL
operator|&&
name|qperm
operator|->
name|pzvalidate
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
condition|)
block|{
for|for
control|(
name|pz
operator|=
name|qperm
operator|->
name|pzvalidate
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
operator|++
name|pz
control|)
if|if
condition|(
operator|(
operator|*
name|pz
operator|)
index|[
literal|0
index|]
operator|==
name|zsystem
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
name|zsystem
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pz
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|pz
operator|=
name|qperm
operator|->
name|pzlogname
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
operator|++
name|pz
control|)
block|{
comment|/* If this LOGNAME line is also a matching MACHINE 		     line, we can add the LOGNAME permissions to the 		     first alternate.  Otherwise, we must create a new 		     alternate.  We cannot put a LOGNAME line in the 		     first alternate if MACHINE does not match, 		     because certain permissions (e.g. READ) may be 		     specified by both types of lines, and we must use 		     LOGNAME entries only when accepting calls and 		     MACHINE entries only when placing calls.  */
if|if
condition|(
name|fmachine
operator|&&
operator|(
name|qsys
operator|->
name|uuconf_zcalled_login
operator|==
name|NULL
operator|||
operator|(
name|qsys
operator|->
name|uuconf_zcalled_login
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|)
operator|)
condition|)
block|{
name|qsys
operator|->
name|uuconf_zcalled_login
operator|=
operator|*
name|pz
expr_stmt|;
name|iret
operator|=
name|ihadd_logname_perm
argument_list|(
name|qglobal
argument_list|,
name|qsys
argument_list|,
name|qperm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|uuconf_system
modifier|*
name|qnew
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qnew
operator|=
operator|(
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_system
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qnew
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
return|return
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
return|;
block|}
operator|*
name|qnew
operator|=
operator|*
name|qsys
expr_stmt|;
name|qnew
operator|->
name|uuconf_qalternate
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qsys
operator|->
name|uuconf_qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qnew
expr_stmt|;
name|qnew
operator|->
name|uuconf_zcalled_login
operator|=
operator|*
name|pz
expr_stmt|;
name|qnew
operator|->
name|uuconf_fcall
operator|=
name|FALSE
expr_stmt|;
name|iret
operator|=
name|ihadd_logname_perm
argument_list|(
name|qglobal
argument_list|,
name|qnew
argument_list|,
name|qperm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
name|ffound_login
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* If we didn't find an entry for the machine, we must use the      MACHINE=OTHER entry, if any.  */
if|if
condition|(
operator|!
name|ffound_machine
operator|&&
name|qother_machine
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|qalt
operator|=
name|qsys
init|;
name|qalt
operator|!=
name|NULL
condition|;
name|qalt
operator|=
name|qalt
operator|->
name|uuconf_qalternate
control|)
block|{
if|if
condition|(
name|qalt
operator|->
name|uuconf_fcall
condition|)
block|{
name|iret
operator|=
name|ihadd_machine_perm
argument_list|(
name|qglobal
argument_list|,
name|qalt
argument_list|,
name|qother_machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
block|}
block|}
comment|/* If this system was not listed in any VALIDATE entry, then we must      add a called-login for each LOGNAME entry in Permissions.  */
if|if
condition|(
operator|!
name|ffound_login
condition|)
block|{
for|for
control|(
name|qperm
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|qhdb_permissions
init|;
name|qperm
operator|!=
name|NULL
condition|;
name|qperm
operator|=
name|qperm
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|qperm
operator|->
name|pzlogname
operator|==
name|NULL
operator|||
name|qperm
operator|->
name|pzlogname
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
condition|)
continue|continue;
for|for
control|(
name|pz
operator|=
name|qperm
operator|->
name|pzlogname
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
name|struct
name|uuconf_system
modifier|*
name|qnew
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qnew
operator|=
operator|(
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_system
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qnew
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
return|return
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
return|;
block|}
operator|*
name|qnew
operator|=
operator|*
name|qsys
expr_stmt|;
name|qnew
operator|->
name|uuconf_qalternate
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qsys
operator|->
name|uuconf_qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qnew
expr_stmt|;
comment|/* We recognize LOGNAME=OTHER specially, although this 		 appears to be an SCO innovation.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
literal|"OTHER"
argument_list|)
operator|==
literal|0
condition|)
name|qnew
operator|->
name|uuconf_zcalled_login
operator|=
operator|(
name|char
operator|*
operator|)
literal|"ANY"
expr_stmt|;
else|else
name|qnew
operator|->
name|uuconf_zcalled_login
operator|=
operator|*
name|pz
expr_stmt|;
name|qnew
operator|->
name|uuconf_fcall
operator|=
name|FALSE
expr_stmt|;
name|iret
operator|=
name|ihadd_logname_perm
argument_list|(
name|qglobal
argument_list|,
name|qnew
argument_list|,
name|qperm
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
block|}
block|}
comment|/* HDB permits local requests to receive to any directory, which is      not the default put in by _uuconf_isystem_basic_default.  We set      it here instead.  */
for|for
control|(
name|qalt
operator|=
name|qsys
init|;
name|qalt
operator|!=
name|NULL
condition|;
name|qalt
operator|=
name|qalt
operator|->
name|uuconf_qalternate
control|)
block|{
name|iret
operator|=
name|_uuconf_iadd_string
argument_list|(
name|qglobal
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ZROOTDIR
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|qalt
operator|->
name|uuconf_pzlocal_receive
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
comment|/* HDB does not have a maximum number of retries if a retry time is      given in the time field.  */
if|if
condition|(
name|qsys
operator|->
name|uuconf_qtimegrade
operator|!=
name|NULL
operator|&&
name|qsys
operator|->
name|uuconf_qtimegrade
operator|!=
operator|(
expr|struct
name|uuconf_timespan
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|&&
name|qsys
operator|->
name|uuconf_qtimegrade
operator|->
name|uuconf_cretry
operator|>
literal|0
condition|)
name|qsys
operator|->
name|uuconf_cmax_retries
operator|=
literal|0
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add the settings of a MACHINE line in Permissions to a system.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
specifier|static
name|int
name|ihadd_machine_perm
parameter_list|(
name|qglobal
parameter_list|,
name|qsys
parameter_list|,
name|qperm
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|struct
name|shpermissions
modifier|*
name|qperm
decl_stmt|;
block|{
if|if
condition|(
name|qperm
operator|->
name|frequest
operator|>=
literal|0
condition|)
name|qsys
operator|->
name|uuconf_fsend_request
operator|=
name|qperm
operator|->
name|frequest
expr_stmt|;
else|else
name|qsys
operator|->
name|uuconf_fsend_request
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzremote_send
operator|=
name|qperm
operator|->
name|pzread
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzremote_receive
operator|=
name|qperm
operator|->
name|pzwrite
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzcmds
operator|=
name|qperm
operator|->
name|pzcommands
expr_stmt|;
name|qsys
operator|->
name|uuconf_zlocalname
operator|=
name|qperm
operator|->
name|zmyname
expr_stmt|;
name|qsys
operator|->
name|uuconf_zpubdir
operator|=
name|qperm
operator|->
name|zpubdir
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzalias
operator|=
name|qperm
operator|->
name|pzalias
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Add the settings of a LOGNAME line in Permissions to a system.  */
end_comment

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
specifier|static
name|int
name|ihadd_logname_perm
parameter_list|(
name|qglobal
parameter_list|,
name|qsys
parameter_list|,
name|qperm
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|struct
name|shpermissions
modifier|*
name|qperm
decl_stmt|;
block|{
name|qsys
operator|->
name|uuconf_fcalled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qperm
operator|->
name|frequest
operator|>=
literal|0
condition|)
name|qsys
operator|->
name|uuconf_fsend_request
operator|=
name|qperm
operator|->
name|frequest
expr_stmt|;
else|else
name|qsys
operator|->
name|uuconf_fsend_request
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|->
name|uuconf_fcalled_transfer
operator|=
name|qperm
operator|->
name|fsendfiles
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzremote_send
operator|=
name|qperm
operator|->
name|pzread
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzremote_receive
operator|=
name|qperm
operator|->
name|pzwrite
expr_stmt|;
name|qsys
operator|->
name|uuconf_fcallback
operator|=
name|qperm
operator|->
name|fcallback
expr_stmt|;
name|qsys
operator|->
name|uuconf_zlocalname
operator|=
name|qperm
operator|->
name|zmyname
expr_stmt|;
name|qsys
operator|->
name|uuconf_zpubdir
operator|=
name|qperm
operator|->
name|zpubdir
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
end_function

end_unit

