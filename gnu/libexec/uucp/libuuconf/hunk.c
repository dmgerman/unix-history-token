begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hunk.c    Get information about an unknown system from the HDB Permissions file.     Copyright (C) 1992 Ian Lance Taylor     This file is part of the Taylor UUCP uuconf library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License    as published by the Free Software Foundation; either version 2 of    the License, or (at your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucnfi.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|_uuconf_hunk_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Get information about an unknown system from the HDB Permissions    file.  This doesn't run the remote.unknown shell script, because    that's too system dependent.  */
end_comment

begin_function
name|int
name|uuconf_hdb_system_unknown
parameter_list|(
name|pglobal
parameter_list|,
name|qsys
parameter_list|)
name|pointer
name|pglobal
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
block|{
name|struct
name|sglobal
modifier|*
name|qglobal
init|=
operator|(
expr|struct
name|sglobal
operator|*
operator|)
name|pglobal
decl_stmt|;
name|int
name|iret
decl_stmt|;
name|boolean
name|ffirst
decl_stmt|;
name|struct
name|shpermissions
modifier|*
name|qperm
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qalt
decl_stmt|;
if|if
condition|(
operator|!
name|qglobal
operator|->
name|qprocess
operator|->
name|fhdb_read_permissions
condition|)
block|{
name|iret
operator|=
name|_uuconf_ihread_permissions
argument_list|(
name|qglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
name|_uuconf_uclear_system
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
name|qsys
operator|->
name|uuconf_palloc
operator|=
name|uuconf_malloc_block
argument_list|()
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|uuconf_palloc
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
return|return
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
return|;
block|}
name|ffirst
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|qperm
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|qhdb_permissions
init|;
name|qperm
operator|!=
name|NULL
condition|;
name|qperm
operator|=
name|qperm
operator|->
name|qnext
control|)
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|qperm
operator|->
name|pzlogname
operator|==
name|NULL
operator|||
name|qperm
operator|->
name|pzlogname
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
condition|)
continue|continue;
for|for
control|(
name|pz
operator|=
name|qperm
operator|->
name|pzlogname
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
if|if
condition|(
name|ffirst
condition|)
block|{
name|qalt
operator|=
name|qsys
expr_stmt|;
name|ffirst
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|uuconf_system
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qalt
operator|=
operator|(
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|qsys
operator|->
name|uuconf_palloc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_system
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qalt
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
return|return
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
return|;
block|}
name|_uuconf_uclear_system
argument_list|(
name|qalt
argument_list|)
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qsys
operator|->
name|uuconf_qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qalt
expr_stmt|;
block|}
comment|/* We recognize LOGNAME=OTHER specially, although this 	     appears to be an SCO innovation.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
literal|"OTHER"
argument_list|)
operator|==
literal|0
condition|)
name|qalt
operator|->
name|uuconf_zcalled_login
operator|=
operator|(
name|char
operator|*
operator|)
literal|"ANY"
expr_stmt|;
else|else
name|qalt
operator|->
name|uuconf_zcalled_login
operator|=
operator|*
name|pz
expr_stmt|;
name|qalt
operator|->
name|uuconf_fcall
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|->
name|uuconf_fcalled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qperm
operator|->
name|frequest
operator|>=
literal|0
condition|)
name|qsys
operator|->
name|uuconf_fsend_request
operator|=
name|qperm
operator|->
name|frequest
expr_stmt|;
else|else
name|qsys
operator|->
name|uuconf_fsend_request
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|->
name|uuconf_fcalled_transfer
operator|=
name|qperm
operator|->
name|fsendfiles
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzremote_send
operator|=
name|qperm
operator|->
name|pzread
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzremote_receive
operator|=
name|qperm
operator|->
name|pzwrite
expr_stmt|;
name|qsys
operator|->
name|uuconf_fcallback
operator|=
name|qperm
operator|->
name|fcallback
expr_stmt|;
name|qsys
operator|->
name|uuconf_zlocalname
operator|=
name|qperm
operator|->
name|zmyname
expr_stmt|;
name|qsys
operator|->
name|uuconf_zpubdir
operator|=
name|qperm
operator|->
name|zpubdir
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ffirst
condition|)
return|return
name|UUCONF_NOT_FOUND
return|;
comment|/* HDB permits local requests to receive to any directory, which is      not the default put in by _uuconf_isystem_basic_default.  We set      it here instead.  */
for|for
control|(
name|qalt
operator|=
name|qsys
init|;
name|qalt
operator|!=
name|NULL
condition|;
name|qalt
operator|=
name|qalt
operator|->
name|uuconf_qalternate
control|)
block|{
name|iret
operator|=
name|_uuconf_iadd_string
argument_list|(
name|qglobal
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ZROOTDIR
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|qalt
operator|->
name|uuconf_pzlocal_receive
argument_list|,
name|qsys
operator|->
name|uuconf_palloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
return|return
name|_uuconf_isystem_basic_default
argument_list|(
name|qglobal
argument_list|,
name|qsys
argument_list|)
return|;
block|}
end_function

end_unit

