begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* time.c    Parse a time string into a uuconf_timespan structure.     Copyright (C) 1992, 1993 Ian Lance Taylor     This file is part of the Taylor UUCP uuconf library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License    as published by the Free Software Foundation; either version 2 of    the License, or (at your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucnfi.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|_uuconf_time_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|itadd_span
name|P
argument_list|(
operator|(
expr|struct
name|sglobal
operator|*
name|qglobal
operator|,
name|int
name|istart
operator|,
name|int
name|iend
operator|,
name|long
name|ival
operator|,
name|int
name|cretry
operator|,
name|int
argument_list|(
argument|*picmp
argument_list|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
operator|,
expr|struct
name|uuconf_timespan
operator|*
operator|*
name|pqspan
operator|,
name|pointer
name|pblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itnew
name|P
argument_list|(
operator|(
expr|struct
name|sglobal
operator|*
name|qglobal
operator|,
expr|struct
name|uuconf_timespan
operator|*
operator|*
name|pqset
operator|,
expr|struct
name|uuconf_timespan
operator|*
name|qnext
operator|,
name|int
name|istart
operator|,
name|int
name|iend
operator|,
name|long
name|ival
operator|,
name|int
name|cretry
operator|,
name|pointer
name|pblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* An array of weekday abbreviations.  The code below assumes that    each one starts with a lower case letter.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
name|int
name|imin
decl_stmt|;
name|int
name|imax
decl_stmt|;
block|}
name|asTdays
index|[]
init|=
block|{
block|{
literal|"any"
block|,
literal|0
block|,
literal|6
block|}
block|,
block|{
literal|"wk"
block|,
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|"su"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mo"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"tu"
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|"we"
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|"th"
block|,
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|"fr"
block|,
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|"sa"
block|,
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|"never"
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|"none"
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Parse a time string and add it to a span list.  This function is    given the value, the retry time, and the comparison function to    use.  */
end_comment

begin_function_decl
name|int
name|_uuconf_itime_parse
parameter_list|(
name|qglobal
parameter_list|,
name|ztime
parameter_list|,
name|ival
parameter_list|,
name|cretry
parameter_list|,
name|picmp
parameter_list|,
name|pqspan
parameter_list|,
name|pblock
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
name|char
modifier|*
name|ztime
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|int
name|cretry
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*picmp
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uuconf_timespan
modifier|*
modifier|*
name|pqspan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pointer
name|pblock
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|uuconf_timespan
modifier|*
name|qlist
decl_stmt|;
name|char
name|bfirst
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|qlist
operator|=
operator|*
name|pqspan
expr_stmt|;
if|if
condition|(
name|qlist
operator|==
operator|(
expr|struct
name|uuconf_timespan
operator|*
operator|)
operator|&
name|_uuconf_unset
condition|)
name|qlist
operator|=
name|NULL
expr_stmt|;
comment|/* Expand the string using a timetable.  Keep rechecking the string      until it does not match.  */
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|char
modifier|*
name|zfound
decl_stmt|;
name|bfirst
operator|=
operator|*
name|ztime
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|bfirst
argument_list|)
argument_list|)
condition|)
name|bfirst
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|bfirst
argument_list|)
argument_list|)
expr_stmt|;
name|zfound
operator|=
name|NULL
expr_stmt|;
name|pz
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|pztimetables
expr_stmt|;
comment|/* We want the last timetable to have been defined with this 	 name, so we always look through the entire table.  */
while|while
condition|(
operator|*
name|pz
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|bfirst
operator|==
operator|(
operator|*
name|pz
operator|)
index|[
literal|0
index|]
operator|||
operator|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
operator|(
operator|*
name|pz
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|&&
operator|(
name|int
operator|)
name|bfirst
operator|==
operator|(
name|int
operator|)
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
operator|(
operator|*
name|pz
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|strcasecmp
argument_list|(
name|ztime
argument_list|,
operator|*
name|pz
argument_list|)
operator|==
literal|0
condition|)
name|zfound
operator|=
name|pz
index|[
literal|1
index|]
expr_stmt|;
name|pz
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|zfound
operator|==
name|NULL
condition|)
break|break;
name|ztime
operator|=
name|zfound
expr_stmt|;
block|}
comment|/* Look through the time string.  */
name|z
operator|=
name|ztime
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|iday
decl_stmt|;
name|boolean
name|afday
index|[
literal|7
index|]
decl_stmt|;
name|int
name|istart
decl_stmt|,
name|iend
decl_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|','
operator|||
operator|*
name|z
operator|==
literal|'|'
condition|)
operator|++
name|z
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'\0'
operator|||
operator|*
name|z
operator|==
literal|';'
condition|)
break|break;
for|for
control|(
name|iday
operator|=
literal|0
init|;
name|iday
operator|<
literal|7
condition|;
name|iday
operator|++
control|)
name|afday
index|[
name|iday
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* Get the days.  */
do|do
block|{
name|bfirst
operator|=
operator|*
name|z
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|bfirst
argument_list|)
argument_list|)
condition|)
name|bfirst
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|bfirst
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iday
operator|=
literal|0
init|;
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
operator|!=
name|NULL
condition|;
name|iday
operator|++
control|)
block|{
name|size_t
name|clen
decl_stmt|;
if|if
condition|(
name|bfirst
operator|!=
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
index|[
literal|0
index|]
condition|)
continue|continue;
name|clen
operator|=
name|strlen
argument_list|(
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|z
argument_list|,
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
argument_list|,
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|iset
decl_stmt|;
for|for
control|(
name|iset
operator|=
name|asTdays
index|[
name|iday
index|]
operator|.
name|imin
init|;
name|iset
operator|<=
name|asTdays
index|[
name|iday
index|]
operator|.
name|imax
condition|;
name|iset
operator|++
control|)
name|afday
index|[
name|iset
index|]
operator|=
name|TRUE
expr_stmt|;
name|z
operator|+=
name|clen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
operator|==
name|NULL
condition|)
return|return
name|UUCONF_SYNTAX_ERROR
return|;
block|}
do|while
condition|(
name|isalpha
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
do|;
comment|/* Get the hours.  */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
block|{
name|istart
operator|=
literal|0
expr_stmt|;
name|iend
operator|=
literal|24
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zendnum
decl_stmt|;
name|istart
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z
argument_list|,
operator|&
name|zendnum
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zendnum
operator|!=
literal|'-'
operator|||
operator|!
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|zendnum
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|UUCONF_SYNTAX_ERROR
return|;
name|z
operator|=
name|zendnum
operator|+
literal|1
expr_stmt|;
name|iend
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z
argument_list|,
operator|&
name|zendnum
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|z
operator|=
name|zendnum
expr_stmt|;
name|istart
operator|=
operator|(
name|istart
operator|/
literal|100
operator|)
operator|*
literal|60
operator|+
name|istart
operator|%
literal|100
expr_stmt|;
name|iend
operator|=
operator|(
name|iend
operator|/
literal|100
operator|)
operator|*
literal|60
operator|+
name|iend
operator|%
literal|100
expr_stmt|;
block|}
comment|/* Add the times we've found onto the list.  */
for|for
control|(
name|iday
operator|=
literal|0
init|;
name|iday
operator|<
literal|7
condition|;
name|iday
operator|++
control|)
block|{
if|if
condition|(
name|afday
index|[
name|iday
index|]
condition|)
block|{
name|int
name|iminute
decl_stmt|,
name|iret
decl_stmt|;
name|iminute
operator|=
name|iday
operator|*
literal|24
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|istart
operator|<
name|iend
condition|)
name|iret
operator|=
name|itadd_span
argument_list|(
name|qglobal
argument_list|,
name|iminute
operator|+
name|istart
argument_list|,
name|iminute
operator|+
name|iend
argument_list|,
name|ival
argument_list|,
name|cretry
argument_list|,
name|picmp
argument_list|,
operator|&
name|qlist
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Wrap around midnight.  */
name|iret
operator|=
name|itadd_span
argument_list|(
name|qglobal
argument_list|,
name|iminute
argument_list|,
name|iminute
operator|+
name|iend
argument_list|,
name|ival
argument_list|,
name|cretry
argument_list|,
name|picmp
argument_list|,
operator|&
name|qlist
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|==
name|UUCONF_SUCCESS
condition|)
name|iret
operator|=
name|itadd_span
argument_list|(
name|qglobal
argument_list|,
name|iminute
operator|+
name|istart
argument_list|,
name|iminute
operator|+
literal|24
operator|*
literal|60
argument_list|,
name|ival
argument_list|,
name|cretry
argument_list|,
name|picmp
argument_list|,
operator|&
name|qlist
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
block|}
block|}
operator|*
name|pqspan
operator|=
name|qlist
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* Add a time span to an existing list of time spans.  We keep the    list sorted by time to make this operation easier.  This modifies    the existing list, and returns the modified version.  It takes a    comparison function which should return< 0 if the first argument    should take precedence over the second argument and == 0 if they    are the same (for grades this is igradecmp; for sizes it is minus    (the binary operator)).  */
end_comment

begin_function_decl
specifier|static
name|int
name|itadd_span
parameter_list|(
name|qglobal
parameter_list|,
name|istart
parameter_list|,
name|iend
parameter_list|,
name|ival
parameter_list|,
name|cretry
parameter_list|,
name|picmp
parameter_list|,
name|pqspan
parameter_list|,
name|pblock
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
name|int
name|istart
decl_stmt|;
name|int
name|iend
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|int
name|cretry
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*picmp
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uuconf_timespan
modifier|*
modifier|*
name|pqspan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pointer
name|pblock
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|uuconf_timespan
modifier|*
modifier|*
name|pq
decl_stmt|;
name|int
name|iret
decl_stmt|;
comment|/* istart< iend  */
for|for
control|(
name|pq
operator|=
name|pqspan
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
control|)
block|{
name|int
name|icmp
decl_stmt|;
comment|/* Invariant: PREV (*pq) == NULL || PREV (*pq)->iend<= istart  */
comment|/* istart< iend&& (*pq)->istart< (*pq)->iend  */
if|if
condition|(
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
condition|)
block|{
comment|/* istart< iend<= (*pq)->istart< (*pq)->iend  */
comment|/* No overlap, and we're at the right spot.  See if we can 	     combine these spans.  */
if|if
condition|(
name|iend
operator|==
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
operator|&&
name|cretry
operator|==
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_cretry
operator|&&
call|(
modifier|*
name|picmp
call|)
argument_list|(
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_ival
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
operator|=
name|istart
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
comment|/* We couldn't combine them.  */
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|<=
name|istart
condition|)
block|{
comment|/* (*pq)->istart< (*pq)->iend<= istart< iend  */
comment|/* No overlap.  Try attaching this span.  */
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|==
name|istart
operator|&&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_cretry
operator|==
name|cretry
operator|&&
operator|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|==
name|NULL
operator|||
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|->
name|uuconf_istart
operator|)
operator|&&
call|(
modifier|*
name|picmp
call|)
argument_list|(
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_ival
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|=
name|iend
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
comment|/* Couldn't attach; keep looking for the right spot.  We 	     might be able to combine part of the new span onto an 	     existing span, but it's probably not worth it.  */
continue|continue;
block|}
comment|/* istart< iend&& (*pq)->istart< (*pq)->iend&& istart< (*pq)->iend&& (*pq)->istart< iend  */
comment|/* Overlap.  */
name|icmp
operator|=
call|(
modifier|*
name|picmp
call|)
argument_list|(
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_ival
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|==
literal|0
condition|)
block|{
comment|/* Just expand the old span to include the new span.  */
if|if
condition|(
name|istart
operator|<
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
condition|)
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
operator|=
name|istart
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|>=
name|iend
condition|)
return|return
name|UUCONF_SUCCESS
return|;
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|==
name|NULL
operator|||
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|->
name|uuconf_istart
condition|)
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|=
name|iend
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
comment|/* The span we are adding overlaps the next span as well. 	     Expand the old span up to the next old span, and keep 	     trying to add the new span.  */
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|->
name|uuconf_istart
expr_stmt|;
name|istart
operator|=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|icmp
operator|<
literal|0
condition|)
block|{
comment|/* Replace the old span with the new span.  */
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
operator|<
name|istart
condition|)
block|{
comment|/* Save the initial portion of the old span.  */
name|iret
operator|=
name|itnew
argument_list|(
name|qglobal
argument_list|,
name|pq
argument_list|,
operator|*
name|pq
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
argument_list|,
name|istart
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_cretry
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
expr_stmt|;
block|}
if|if
condition|(
name|iend
operator|<
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
condition|)
block|{
comment|/* Save the final portion of the old span.  */
name|iret
operator|=
name|itnew
argument_list|(
name|qglobal
argument_list|,
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
argument_list|,
name|iend
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_cretry
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
block|}
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_ival
operator|=
name|ival
expr_stmt|;
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
operator|=
name|istart
expr_stmt|;
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_cretry
operator|=
name|cretry
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|==
name|NULL
operator|||
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|->
name|uuconf_istart
condition|)
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|=
name|iend
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
comment|/* Move this span up to the next one, and keep trying to add 	     the new span.  */
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
operator|=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
operator|->
name|uuconf_istart
expr_stmt|;
name|istart
operator|=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave the old span untouched.  */
if|if
condition|(
name|istart
operator|<
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
condition|)
block|{
comment|/* Put in the initial portion of the new span.  */
name|iret
operator|=
name|itnew
argument_list|(
name|qglobal
argument_list|,
name|pq
argument_list|,
operator|*
name|pq
argument_list|,
name|istart
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_istart
argument_list|,
name|ival
argument_list|,
name|cretry
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
return|return
name|iret
return|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qnext
expr_stmt|;
block|}
if|if
condition|(
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
condition|)
return|return
name|UUCONF_SUCCESS
return|;
comment|/* Keep trying to add the new span.  */
name|istart
operator|=
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_iend
expr_stmt|;
block|}
block|}
comment|/* This is the spot for the new span, and there's no overlap.  */
return|return
name|itnew
argument_list|(
name|qglobal
argument_list|,
name|pq
argument_list|,
operator|*
name|pq
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|,
name|ival
argument_list|,
name|cretry
argument_list|,
name|pblock
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* A utility function to create a new uuconf_timespan structure.  */
end_comment

begin_function
specifier|static
name|int
name|itnew
parameter_list|(
name|qglobal
parameter_list|,
name|pqset
parameter_list|,
name|qnext
parameter_list|,
name|istart
parameter_list|,
name|iend
parameter_list|,
name|ival
parameter_list|,
name|cretry
parameter_list|,
name|pblock
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
name|struct
name|uuconf_timespan
modifier|*
modifier|*
name|pqset
decl_stmt|;
name|struct
name|uuconf_timespan
modifier|*
name|qnext
decl_stmt|;
name|int
name|istart
decl_stmt|;
name|int
name|iend
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|int
name|cretry
decl_stmt|;
name|pointer
name|pblock
decl_stmt|;
block|{
specifier|register
name|struct
name|uuconf_timespan
modifier|*
name|qnew
decl_stmt|;
name|qnew
operator|=
operator|(
operator|(
expr|struct
name|uuconf_timespan
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_timespan
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qnew
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
return|return
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
return|;
block|}
name|qnew
operator|->
name|uuconf_qnext
operator|=
name|qnext
expr_stmt|;
name|qnew
operator|->
name|uuconf_istart
operator|=
name|istart
expr_stmt|;
name|qnew
operator|->
name|uuconf_iend
operator|=
name|iend
expr_stmt|;
name|qnew
operator|->
name|uuconf_ival
operator|=
name|ival
expr_stmt|;
name|qnew
operator|->
name|uuconf_cretry
operator|=
name|cretry
expr_stmt|;
operator|*
name|pqset
operator|=
name|qnew
expr_stmt|;
return|return
name|UUCONF_SUCCESS
return|;
block|}
end_function

end_unit

