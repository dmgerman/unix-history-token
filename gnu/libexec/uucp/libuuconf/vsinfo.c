begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vsinfo.c    Get information about a system from the V2 configuration files.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP uuconf library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License    as published by the Free Software Foundation; either version 2 of    the License, or (at your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucnfi.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|_uuconf_vsinfo_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Get the information for a particular system from the V2    configuration files.  This does not make sure that all the default    values are set.  */
end_comment

begin_function
name|int
name|_uuconf_iv2_system_internal
parameter_list|(
name|qglobal
parameter_list|,
name|zsystem
parameter_list|,
name|qsys
parameter_list|)
name|struct
name|sglobal
modifier|*
name|qglobal
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
block|{
name|char
modifier|*
name|zline
decl_stmt|;
name|size_t
name|cline
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzsplit
decl_stmt|;
name|size_t
name|csplit
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzcomma
decl_stmt|;
name|size_t
name|ccomma
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|cchars
decl_stmt|;
name|pointer
name|pblock
decl_stmt|;
name|int
name|iret
decl_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2systems
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|FNO_SUCH_FILE
argument_list|()
condition|)
return|return
name|UUCONF_NOT_FOUND
return|;
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|qglobal
operator|->
name|zfilename
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2systems
expr_stmt|;
return|return
operator|(
name|UUCONF_FOPEN_FAILED
operator||
name|UUCONF_ERROR_ERRNO
operator||
name|UUCONF_ERROR_FILENAME
operator|)
return|;
block|}
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
name|pzsplit
operator|=
name|NULL
expr_stmt|;
name|csplit
operator|=
literal|0
expr_stmt|;
name|pzcomma
operator|=
name|NULL
expr_stmt|;
name|ccomma
operator|=
literal|0
expr_stmt|;
name|pblock
operator|=
name|NULL
expr_stmt|;
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
name|qglobal
operator|->
name|ilineno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cchars
operator|=
name|_uuconf_getline
argument_list|(
name|qglobal
argument_list|,
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|ctoks
decl_stmt|,
name|ctimes
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|qset
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|zretry
decl_stmt|;
name|int
name|cretry
decl_stmt|;
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
operator|--
name|cchars
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|cchars
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|cchars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ctoks
operator|=
name|_uuconf_istrsplit
argument_list|(
name|zline
argument_list|,
literal|'\0'
argument_list|,
operator|&
name|pzsplit
argument_list|,
operator|&
name|csplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
comment|/* If this isn't the system we're looking for, keep reading 	 the file.  */
if|if
condition|(
name|ctoks
operator|<
literal|1
operator|||
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|pzsplit
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If this is the first time we've found the system, we want 	 to set *qsys directly.  Otherwise, we allocate a new 	 alternate.  */
if|if
condition|(
name|pblock
operator|==
name|NULL
condition|)
block|{
name|pblock
operator|=
name|uuconf_malloc_block
argument_list|()
expr_stmt|;
if|if
condition|(
name|pblock
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|_uuconf_uclear_system
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
name|qsys
operator|->
name|uuconf_palloc
operator|=
name|pblock
expr_stmt|;
name|qset
operator|=
name|qsys
expr_stmt|;
block|}
else|else
block|{
name|struct
name|uuconf_system
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qset
operator|=
operator|(
operator|(
expr|struct
name|uuconf_system
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_system
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qset
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|_uuconf_uclear_system
argument_list|(
name|qset
argument_list|)
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qsys
operator|->
name|uuconf_qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|uuconf_qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qset
expr_stmt|;
block|}
comment|/* Add this line to the memory block we are building for the 	 system.  */
if|if
condition|(
name|uuconf_add_block
argument_list|(
name|pblock
argument_list|,
name|zline
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
comment|/* The format of a line in Systems is 	 system time device speed phone chat 	 For example, 	 airs Any ACU 9600 5551212 ogin: foo pass: bar 	 */
comment|/* Get the system name.  */
name|qset
operator|->
name|uuconf_zname
operator|=
name|pzsplit
index|[
literal|0
index|]
expr_stmt|;
name|qset
operator|->
name|uuconf_fcall
operator|=
name|TRUE
expr_stmt|;
name|qset
operator|->
name|uuconf_fcalled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|2
condition|)
continue|continue;
comment|/* A time string is "time/grade,time/grade;retry".  A missing 	 grade is taken as BGRADE_LOW.  On some versions the retry 	 time is actually separated by a comma, which won't work right 	 here.  */
name|zretry
operator|=
name|strchr
argument_list|(
name|pzsplit
index|[
literal|1
index|]
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zretry
operator|==
name|NULL
condition|)
name|cretry
operator|=
literal|55
expr_stmt|;
else|else
block|{
operator|*
name|zretry
operator|=
literal|'\0'
expr_stmt|;
name|cretry
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|zretry
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|ctimes
operator|=
name|_uuconf_istrsplit
argument_list|(
name|pzsplit
index|[
literal|1
index|]
argument_list|,
literal|','
argument_list|,
operator|&
name|pzcomma
argument_list|,
operator|&
name|ccomma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctimes
operator|<
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctimes
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|zslash
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
name|z
operator|=
name|pzcomma
index|[
name|i
index|]
expr_stmt|;
name|zslash
operator|=
name|strchr
argument_list|(
name|z
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
condition|)
name|bgrade
operator|=
name|UUCONF_GRADE_LOW
expr_stmt|;
else|else
block|{
operator|*
name|zslash
operator|=
literal|'\0'
expr_stmt|;
name|bgrade
operator|=
name|zslash
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|UUCONF_GRADE_LEGAL
argument_list|(
name|bgrade
argument_list|)
condition|)
name|bgrade
operator|=
name|UUCONF_GRADE_LOW
expr_stmt|;
block|}
name|iret
operator|=
name|_uuconf_itime_parse
argument_list|(
name|qglobal
argument_list|,
name|z
argument_list|,
operator|(
name|long
operator|)
name|bgrade
argument_list|,
name|cretry
argument_list|,
name|_uuconf_itime_grade_cmp
argument_list|,
operator|&
name|qset
operator|->
name|uuconf_qtimegrade
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
comment|/* We treat a syntax error in the time field as equivalent 	     to ``never'', on the assumption that that is what V2 	     does.  */
if|if
condition|(
name|iret
operator|==
name|UUCONF_SYNTAX_ERROR
condition|)
name|iret
operator|=
name|UUCONF_SUCCESS
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
comment|/* Treat any time/grade setting as both a timegrade and a 	     call-timegrade.  */
if|if
condition|(
name|bgrade
operator|!=
name|UUCONF_GRADE_LOW
condition|)
name|qset
operator|->
name|uuconf_qcalltimegrade
operator|=
name|qset
operator|->
name|uuconf_qtimegrade
expr_stmt|;
block|}
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
if|if
condition|(
name|ctoks
operator|<
literal|3
condition|)
continue|continue;
comment|/* Pick up the device name.  It can be followed by a comma and a 	 list of protocols (this is not actually supported by most V2 	 systems, but it should be compatible).  */
name|qset
operator|->
name|uuconf_zport
operator|=
name|pzsplit
index|[
literal|2
index|]
expr_stmt|;
name|z
operator|=
name|strchr
argument_list|(
name|pzsplit
index|[
literal|2
index|]
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|qset
operator|->
name|uuconf_zprotocols
operator|=
name|z
operator|+
literal|1
expr_stmt|;
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If the port is "TCP", we set up a system specific port.  The 	 baud rate becomes the service number and the phone number 	 becomes the address (still stored in qsys->zphone).  */
if|if
condition|(
name|strcmp
argument_list|(
name|qset
operator|->
name|uuconf_zport
argument_list|,
literal|"TCP"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qset
operator|->
name|uuconf_zport
operator|=
name|NULL
expr_stmt|;
name|qset
operator|->
name|uuconf_qport
operator|=
operator|(
operator|(
expr|struct
name|uuconf_port
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuconf_port
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qset
operator|->
name|uuconf_qport
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|_uuconf_uclear_port
argument_list|(
name|qset
operator|->
name|uuconf_qport
argument_list|)
expr_stmt|;
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_zname
operator|=
operator|(
name|char
operator|*
operator|)
literal|"TCP"
expr_stmt|;
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_ttype
operator|=
name|UUCONF_PORTTYPE_TCP
expr_stmt|;
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_ireliable
operator|=
operator|(
name|UUCONF_RELIABLE_ENDTOEND
operator||
name|UUCONF_RELIABLE_RELIABLE
operator||
name|UUCONF_RELIABLE_EIGHT
operator||
name|UUCONF_RELIABLE_FULLDUPLEX
operator||
name|UUCONF_RELIABLE_SPECIFIED
operator|)
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|4
condition|)
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zport
operator|=
operator|(
name|char
operator|*
operator|)
literal|"uucp"
expr_stmt|;
else|else
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zport
operator|=
name|pzsplit
index|[
literal|3
index|]
expr_stmt|;
comment|/* I leave with IPv4 only for compatibility reason.  If you 	     wish to use IPv6, please try Taylor UUCP configuration 	     instead.  If you still wish to use IPv6 with V2 	     configuration, re-make with INET6 defined.  In this case, 	     you cannot specify the protocol family in V2 	     configuration file.  */
ifdef|#
directive|ifdef
name|INET6
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zfamily
operator|=
name|PF_UNSPEC
expr_stmt|;
else|#
directive|else
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zfamily
operator|=
name|PF_INET
expr_stmt|;
endif|#
directive|endif
name|qset
operator|->
name|uuconf_qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_pzdialer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctoks
operator|<
literal|4
condition|)
continue|continue;
name|qset
operator|->
name|uuconf_ibaud
operator|=
name|strtol
argument_list|(
name|pzsplit
index|[
literal|3
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|5
condition|)
continue|continue;
comment|/* Get the phone number.  */
name|qset
operator|->
name|uuconf_zphone
operator|=
name|pzsplit
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|6
condition|)
continue|continue;
comment|/* Get the chat script.  We just hand this off to the chat 	 script processor, so that it will parse subsend and 	 subexpect strings correctly.  */
name|pzsplit
index|[
literal|4
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"chat"
expr_stmt|;
name|iret
operator|=
name|_uuconf_ichat_cmd
argument_list|(
name|qglobal
argument_list|,
name|ctoks
operator|-
literal|4
argument_list|,
name|pzsplit
operator|+
literal|4
argument_list|,
operator|&
name|qset
operator|->
name|uuconf_schat
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
name|iret
operator|&=
operator|~
name|UUCONF_CMDTABRET_KEEP
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzcomma
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzcomma
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzsplit
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzsplit
argument_list|)
expr_stmt|;
name|qglobal
operator|->
name|zfilename
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2systems
expr_stmt|;
return|return
name|iret
operator||
name|UUCONF_ERROR_FILENAME
operator||
name|UUCONF_ERROR_LINENO
return|;
block|}
if|if
condition|(
name|pblock
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzsplit
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzsplit
argument_list|)
expr_stmt|;
return|return
name|UUCONF_NOT_FOUND
return|;
block|}
comment|/* Now read USERFILE and L.cmds to get permissions.  We can't fully      handle USERFILE since that specifies permissions based on local      users which we do not support.  */
block|{
name|e
operator|=
name|fopen
argument_list|(
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2userfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|pzlocal
decl_stmt|,
modifier|*
modifier|*
name|pzremote
decl_stmt|;
name|boolean
name|fdefault_callback
decl_stmt|;
name|char
modifier|*
name|zdefault_login
decl_stmt|;
name|struct
name|uuconf_system
modifier|*
name|q
decl_stmt|;
name|pzlocal
operator|=
name|NULL
expr_stmt|;
name|pzremote
operator|=
name|NULL
expr_stmt|;
name|fdefault_callback
operator|=
name|FALSE
expr_stmt|;
name|zdefault_login
operator|=
name|NULL
expr_stmt|;
name|qglobal
operator|->
name|ilineno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cchars
operator|=
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|ctoks
decl_stmt|;
name|char
modifier|*
name|zcomma
decl_stmt|;
name|boolean
name|fcallback
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlist
decl_stmt|,
modifier|*
modifier|*
name|pznew
decl_stmt|;
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
operator|--
name|cchars
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|cchars
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|cchars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ctoks
operator|=
name|_uuconf_istrsplit
argument_list|(
name|zline
argument_list|,
literal|'\0'
argument_list|,
operator|&
name|pzsplit
argument_list|,
operator|&
name|csplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctoks
operator|==
literal|0
condition|)
continue|continue;
comment|/* The first field is username,machinename */
name|zcomma
operator|=
name|strchr
argument_list|(
name|pzsplit
index|[
literal|0
index|]
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcomma
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|zcomma
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* The rest of the line is the list of directories, except 	       that if the first directory is "c" we must call the 	       system back.  */
name|fcallback
operator|=
name|FALSE
expr_stmt|;
name|pzlist
operator|=
name|pzsplit
operator|+
literal|1
expr_stmt|;
operator|--
name|ctoks
expr_stmt|;
if|if
condition|(
name|ctoks
operator|>
literal|0
operator|&&
name|pzsplit
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|pzsplit
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|fcallback
operator|=
name|TRUE
expr_stmt|;
name|pzlist
operator|=
name|pzsplit
operator|+
literal|2
expr_stmt|;
operator|--
name|ctoks
expr_stmt|;
block|}
comment|/* Now pzsplit[0] is the user name, zcomma is the system 	       name, fcallback indicates whether a call back is 	       required, ctoks is the number of directories and pzlist 	       points to the directories.  If the system name matches, 	       then the user name is the name that the system must use 	       to log in, and the list of directories is what may be 	       transferred in by either local or remote request. 	       Otherwise, if no system name matches, then the first 	       line with no user name gives the list of directories 	       that may be transferred by local request, and the first 	       line with no system name gives the list of directories 	       that may be transferred by remote request.  */
if|if
condition|(
operator|(
name|pzsplit
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|pzlocal
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|zcomma
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|pzremote
operator|!=
name|NULL
operator|)
operator|&&
name|strcmp
argument_list|(
name|zcomma
argument_list|,
name|zsystem
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* NULL terminate the list of directories.  */
name|pznew
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
operator|(
name|ctoks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pznew
operator|==
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
operator|(
name|pointer
operator|)
name|pznew
argument_list|,
operator|(
name|pointer
operator|)
name|pzlist
argument_list|,
name|ctoks
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pznew
index|[
name|ctoks
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uuconf_add_block
argument_list|(
name|pblock
argument_list|,
name|zline
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
break|break;
block|}
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pzsplit
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|pzlocal
operator|=
name|pznew
expr_stmt|;
name|fdefault_callback
operator|=
name|fcallback
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zcomma
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|pzremote
operator|=
name|pznew
expr_stmt|;
name|zdefault_login
operator|=
name|pzsplit
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Both the login name and the machine name were 		   listed; require the machine to be logged in under 		   this name.  This is not fully backward compatible, 		   and perhaps should be changed.  On the other hand, 		   it is more useful.  */
for|for
control|(
name|q
operator|=
name|qsys
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|uuconf_qalternate
control|)
block|{
name|q
operator|->
name|uuconf_zcalled_login
operator|=
name|pzsplit
index|[
literal|0
index|]
expr_stmt|;
name|q
operator|->
name|uuconf_fcallback
operator|=
name|fcallback
expr_stmt|;
name|q
operator|->
name|uuconf_pzlocal_send
operator|=
name|pznew
expr_stmt|;
name|q
operator|->
name|uuconf_pzlocal_receive
operator|=
name|pznew
expr_stmt|;
name|q
operator|->
name|uuconf_pzremote_send
operator|=
name|pznew
expr_stmt|;
name|q
operator|->
name|uuconf_pzremote_receive
operator|=
name|pznew
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzsplit
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzsplit
argument_list|)
expr_stmt|;
name|qglobal
operator|->
name|zfilename
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2userfile
expr_stmt|;
return|return
name|iret
operator||
name|UUCONF_ERROR_FILENAME
operator||
name|UUCONF_ERROR_LINENO
return|;
block|}
if|if
condition|(
name|qsys
operator|->
name|uuconf_pzlocal_send
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|&&
name|pzlocal
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|q
operator|=
name|qsys
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|uuconf_qalternate
control|)
block|{
name|q
operator|->
name|uuconf_fcallback
operator|=
name|fdefault_callback
expr_stmt|;
name|q
operator|->
name|uuconf_pzlocal_send
operator|=
name|pzlocal
expr_stmt|;
name|q
operator|->
name|uuconf_pzlocal_receive
operator|=
name|pzlocal
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qsys
operator|->
name|uuconf_pzremote_send
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|_uuconf_unset
operator|&&
name|pzremote
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|q
operator|=
name|qsys
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|uuconf_qalternate
control|)
block|{
name|q
operator|->
name|uuconf_zcalled_login
operator|=
name|zdefault_login
expr_stmt|;
name|q
operator|->
name|uuconf_pzremote_send
operator|=
name|pzremote
expr_stmt|;
name|q
operator|->
name|uuconf_pzremote_receive
operator|=
name|pzremote
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now we must read L.cmds to determine which commands may be      executed.  */
block|{
name|e
operator|=
name|fopen
argument_list|(
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2cmds
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|qglobal
operator|->
name|ilineno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|zline
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zline
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|zline
argument_list|,
literal|"PATH="
argument_list|,
sizeof|sizeof
expr|"PATH="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ctoks
decl_stmt|;
name|char
modifier|*
modifier|*
name|pznew
decl_stmt|;
name|zline
operator|+=
sizeof|sizeof
expr|"PATH="
operator|-
literal|1
expr_stmt|;
name|ctoks
operator|=
name|_uuconf_istrsplit
argument_list|(
name|zline
argument_list|,
literal|':'
argument_list|,
operator|&
name|pzsplit
argument_list|,
operator|&
name|csplit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoks
operator|<
literal|0
condition|)
block|{
name|qglobal
operator|->
name|ierrno
operator|=
name|errno
expr_stmt|;
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
block|}
name|pznew
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iret
operator|==
name|UUCONF_SUCCESS
condition|)
block|{
name|pznew
operator|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|uuconf_malloc
argument_list|(
name|pblock
argument_list|,
operator|(
name|ctoks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pznew
operator|==
name|NULL
condition|)
name|iret
operator|=
name|UUCONF_MALLOC_FAILED
operator||
name|UUCONF_ERROR_ERRNO
expr_stmt|;
block|}
if|if
condition|(
name|iret
operator|==
name|UUCONF_SUCCESS
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|pointer
operator|)
name|pznew
argument_list|,
operator|(
name|pointer
operator|)
name|pzsplit
argument_list|,
name|ctoks
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pznew
index|[
name|ctoks
index|]
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|uuconf_pzpath
operator|=
name|pznew
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iret
operator|==
name|UUCONF_SUCCESS
operator|&&
name|zline
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#,\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zline
operator|!=
literal|'\0'
condition|)
block|{
name|iret
operator|=
name|_uuconf_iadd_string
argument_list|(
name|qglobal
argument_list|,
name|zline
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|qsys
operator|->
name|uuconf_pzcmds
argument_list|,
name|pblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|<
literal|0
condition|)
break|break;
operator|++
name|qglobal
operator|->
name|ilineno
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|qglobal
operator|->
name|zfilename
operator|=
name|qglobal
operator|->
name|qprocess
operator|->
name|zv2cmds
expr_stmt|;
name|iret
operator||=
name|UUCONF_ERROR_FILENAME
operator||
name|UUCONF_ERROR_LINENO
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzsplit
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|pzsplit
argument_list|)
expr_stmt|;
return|return
name|iret
return|;
block|}
end_function

end_unit

