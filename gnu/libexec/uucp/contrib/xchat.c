begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  ***********  *  * XCHAT.C *  *  ***********  *  * Extended chat processor for Taylor UUCP. See accompanying documentation.  *  * Written by:  *   Bob Denny (denny@alisa.com)  *   Based on code in DECUS UUCP (for VAX/VMS)  *  * Small modification by:  *   Daniel Hagerty (hag@eddie.mit.edu)  *  * History:  *   Version 1.0 shipped with Taylor 1.03. No configuration info inside.  *  *   Bob Denny - Sun Aug 30 18:41:30 1992  *     V1.1 - long overdue changes for other systems. Rip out interval  *            timer code, use timer code from Taylor UUCP, use select()  *            for timed reads. Use Taylor UUCP "conf.h" file to set  *            configuration for this program. Add defaulting of script  *            and log file paths.  *  *   Daniel Hagerty - Mon Nov 22 18:17:38 1993  *     V1.2 - Added a new opcode to xchat. "expectstr" is a cross between  *            sendstr and expect, looking for a parameter supplied string.  *            Useful where a prompt could change for different dial in  *            lines and such.  *  * Bugs:  *   Does not support BSD terminal I/O. Anyone care to add it?  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/termio.h>
end_include

begin_include
include|#
directive|include
file|"xc-conf.h"
end_include

begin_comment
comment|/*  * Pick a timing routine to use, as done in Taylor UUCP.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_USLEEP
operator|||
name|HAVE_NAP
operator|||
name|HAVE_NAPMS
operator|||
name|HAVE_POLL
end_if

begin_define
define|#
directive|define
name|USE_SELECT_TIMER
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_SELECT_TIMER
value|HAVE_SELECT
end_define

begin_if
if|#
directive|if
name|USE_SELECT_TIMER
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_USLEEP
operator|||
name|HAVE_NAP
operator|||
name|HAVE_NAPMS
end_if

begin_undef
undef|#
directive|undef
name|HAVE_POLL
end_undef

begin_define
define|#
directive|define
name|HAVE_POLL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_USLEEP
operator|||
name|HAVE_NAP
end_if

begin_undef
undef|#
directive|undef
name|HAVE_NAPMS
end_undef

begin_define
define|#
directive|define
name|HAVE_NAPMS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_USLEEP
end_if

begin_undef
undef|#
directive|undef
name|HAVE_NAP
end_undef

begin_define
define|#
directive|define
name|HAVE_NAP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ttblind
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ttcd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* script entry -- "compiled" form of dial, hangup, or login script */
end_comment

begin_struct
struct|struct
name|script
block|{
name|struct
name|script
modifier|*
name|next
decl_stmt|;
comment|/* pointer to next entry, or null */
name|int
name|opcode
decl_stmt|;
comment|/* numeric opcode */
name|char
modifier|*
name|strprm
decl_stmt|;
comment|/* pointer to string param */
name|long
name|intprm
decl_stmt|;
comment|/* integer parameter */
name|char
modifier|*
name|newstate
decl_stmt|;
comment|/* new state name */
block|}
struct|;
end_struct

begin_comment
comment|/* opcode definition array element -- one for each possible opcode */
end_comment

begin_struct
struct|struct
name|script_opdef
block|{
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|opcode
decl_stmt|;
comment|/* numeric opcode -- same as array index */
name|int
name|prmtype
decl_stmt|;
comment|/* one of SC_NONE, SC_STR, SC_XSTR, SC_INT */
name|int
name|newstate
decl_stmt|;
comment|/* one of SC_NONE, SC_NWST */
block|}
struct|;
end_struct

begin_comment
comment|/* values for opcode */
end_comment

begin_define
define|#
directive|define
name|SC_LABEL
value|0
end_define

begin_comment
comment|/* "label" (state name) */
end_comment

begin_define
define|#
directive|define
name|SC_CDLY
value|1
end_define

begin_comment
comment|/* set char output delay in msec */
end_comment

begin_define
define|#
directive|define
name|SC_PCHR
value|2
end_define

begin_comment
comment|/* pause char for dial string (from P in input) */
end_comment

begin_define
define|#
directive|define
name|SC_PTIM
value|3
end_define

begin_comment
comment|/* seconds to allow for pause char */
end_comment

begin_define
define|#
directive|define
name|SC_WCHR
value|4
end_define

begin_comment
comment|/* wait char for dial string (from W in input) */
end_comment

begin_define
define|#
directive|define
name|SC_WTIM
value|5
end_define

begin_comment
comment|/* seconds to allow for wait char */
end_comment

begin_define
define|#
directive|define
name|SC_ZERO
value|6
end_define

begin_comment
comment|/* zero counter */
end_comment

begin_define
define|#
directive|define
name|SC_INCR
value|7
end_define

begin_comment
comment|/* increment counter */
end_comment

begin_define
define|#
directive|define
name|SC_IFGT
value|8
end_define

begin_comment
comment|/* change state if counter> int param */
end_comment

begin_define
define|#
directive|define
name|SC_WAIT
value|9
end_define

begin_comment
comment|/* wait for int param seconds */
end_comment

begin_define
define|#
directive|define
name|SC_GOTO
value|10
end_define

begin_comment
comment|/* unconditional change to new state */
end_comment

begin_define
define|#
directive|define
name|SC_SEND
value|11
end_define

begin_comment
comment|/* send strparam (after sprintf substitutions) */
end_comment

begin_define
define|#
directive|define
name|SC_BRK
value|12
end_define

begin_comment
comment|/* send a break */
end_comment

begin_define
define|#
directive|define
name|SC_HANG
value|13
end_define

begin_comment
comment|/* drop DTR */
end_comment

begin_define
define|#
directive|define
name|SC_DIAL
value|14
end_define

begin_comment
comment|/* send telno string (after subst PCHR& WCHR) */
end_comment

begin_define
define|#
directive|define
name|SC_DTIM
value|15
end_define

begin_comment
comment|/* time in msec per digit (for timeout calculations) */
end_comment

begin_comment
comment|/* default = 100 (one tenth second) */
end_comment

begin_define
define|#
directive|define
name|SC_CTIM
value|16
end_define

begin_comment
comment|/* additional time (in seconds) to wait for carrier */
end_comment

begin_comment
comment|/* default = 45 seconds */
end_comment

begin_define
define|#
directive|define
name|SC_EXIT
value|17
end_define

begin_comment
comment|/* script done, success */
end_comment

begin_define
define|#
directive|define
name|SC_FAIL
value|18
end_define

begin_comment
comment|/* script done, failure */
end_comment

begin_define
define|#
directive|define
name|SC_LOG
value|19
end_define

begin_comment
comment|/* write strparam to uucp.log */
end_comment

begin_define
define|#
directive|define
name|SC_LOGE
value|20
end_define

begin_comment
comment|/* write strparam to uucp.log w/error ind */
end_comment

begin_define
define|#
directive|define
name|SC_DBG
value|21
end_define

begin_comment
comment|/* write strparam to debug log if debug lvl = LGI */
end_comment

begin_define
define|#
directive|define
name|SC_DBGE
value|22
end_define

begin_comment
comment|/* write strparam to debug log if debug lvl = LGIE */
end_comment

begin_define
define|#
directive|define
name|SC_DBST
value|23
end_define

begin_comment
comment|/* 'or' intparam into debug mask */
end_comment

begin_define
define|#
directive|define
name|SC_DBCL
value|24
end_define

begin_comment
comment|/* 'bicl' intparam into debug mask */
end_comment

begin_define
define|#
directive|define
name|SC_TIMO
value|25
end_define

begin_comment
comment|/* newstate if no match in intparam secs */
end_comment

begin_comment
comment|/* (uses calculated dial time if intparam is 0) */
end_comment

begin_define
define|#
directive|define
name|SC_XPCT
value|26
end_define

begin_comment
comment|/* wait for strparam, goto _newstate if found */
end_comment

begin_define
define|#
directive|define
name|SC_CARR
value|27
end_define

begin_comment
comment|/* goto _newstate if carrier detected */
end_comment

begin_define
define|#
directive|define
name|SC_FLSH
value|28
end_define

begin_comment
comment|/* flush typeahead buffer */
end_comment

begin_define
define|#
directive|define
name|SC_IFBL
value|29
end_define

begin_comment
comment|/* change state if controller is blind w/o CD */
end_comment

begin_define
define|#
directive|define
name|SC_IFBG
value|30
end_define

begin_comment
comment|/* chg state if ctlr is blind and counter> intprm */
end_comment

begin_define
define|#
directive|define
name|SC_SNDP
value|31
end_define

begin_comment
comment|/* send parameter n */
end_comment

begin_define
define|#
directive|define
name|SC_IF1P
value|32
end_define

begin_comment
comment|/* if parameter n present */
end_comment

begin_define
define|#
directive|define
name|SC_IF0P
value|33
end_define

begin_comment
comment|/* if parameter n absent */
end_comment

begin_define
define|#
directive|define
name|SC_DBOF
value|34
end_define

begin_comment
comment|/* open debugging file */
end_comment

begin_define
define|#
directive|define
name|SC_TELN
value|35
end_define

begin_comment
comment|/* Set telno from parameter n */
end_comment

begin_define
define|#
directive|define
name|SC_7BIT
value|36
end_define

begin_comment
comment|/* Set port to 7-bit stripping */
end_comment

begin_define
define|#
directive|define
name|SC_8BIT
value|37
end_define

begin_comment
comment|/* Set port for 8-bit characters */
end_comment

begin_define
define|#
directive|define
name|SC_PNON
value|38
end_define

begin_comment
comment|/* Set port for 8-bit, no parity */
end_comment

begin_define
define|#
directive|define
name|SC_PEVN
value|39
end_define

begin_comment
comment|/* Set port for 7-bit, even parity */
end_comment

begin_define
define|#
directive|define
name|SC_PODD
value|40
end_define

begin_comment
comment|/* Set port for 7-bit, odd parity */
end_comment

begin_define
define|#
directive|define
name|SC_HUPS
value|41
end_define

begin_comment
comment|/* Change state on HUP signal */
end_comment

begin_define
define|#
directive|define
name|SC_XPST
value|42
end_define

begin_comment
comment|/* Expect a param string */
end_comment

begin_define
define|#
directive|define
name|SC_END
value|43
end_define

begin_comment
comment|/* end of array */
end_comment

begin_comment
comment|/* values for prmtype, prm2type */
end_comment

begin_define
define|#
directive|define
name|SC_NONE
value|0
end_define

begin_comment
comment|/* no parameter */
end_comment

begin_define
define|#
directive|define
name|SC_STR
value|1
end_define

begin_comment
comment|/* simple string */
end_comment

begin_define
define|#
directive|define
name|SC_INT
value|2
end_define

begin_comment
comment|/* integer */
end_comment

begin_define
define|#
directive|define
name|SC_NWST
value|3
end_define

begin_comment
comment|/* new state name */
end_comment

begin_define
define|#
directive|define
name|SC_XSTR
value|4
end_define

begin_comment
comment|/* translated string */
end_comment

begin_comment
comment|/* opcode definition table for dial/login/hangup scripts */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|script_opdef
name|sc_opdef
index|[]
init|=
block|{
block|{
literal|"label"
block|,
name|SC_LABEL
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"chrdly"
block|,
name|SC_CDLY
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"pchar"
block|,
name|SC_PCHR
block|,
name|SC_STR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"ptime"
block|,
name|SC_PTIM
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"wchar"
block|,
name|SC_WCHR
block|,
name|SC_STR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"wtime"
block|,
name|SC_WTIM
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"zero"
block|,
name|SC_ZERO
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"count"
block|,
name|SC_INCR
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"ifgtr"
block|,
name|SC_IFGT
block|,
name|SC_INT
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"sleep"
block|,
name|SC_WAIT
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"goto"
block|,
name|SC_GOTO
block|,
name|SC_NONE
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"send"
block|,
name|SC_SEND
block|,
name|SC_XSTR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"break"
block|,
name|SC_BRK
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"hangup"
block|,
name|SC_HANG
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"7bit"
block|,
name|SC_7BIT
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"8bit"
block|,
name|SC_8BIT
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"nopar"
block|,
name|SC_PNON
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"evenpar"
block|,
name|SC_PEVN
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"oddpar"
block|,
name|SC_PODD
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"telno"
block|,
name|SC_TELN
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"dial"
block|,
name|SC_DIAL
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"dgttime"
block|,
name|SC_DTIM
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"ctime"
block|,
name|SC_CTIM
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"success"
block|,
name|SC_EXIT
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"failed"
block|,
name|SC_FAIL
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"log"
block|,
name|SC_LOG
block|,
name|SC_XSTR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"logerr"
block|,
name|SC_LOGE
block|,
name|SC_XSTR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"debug"
block|,
name|SC_DBG
block|,
name|SC_XSTR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"debuge"
block|,
name|SC_DBGE
block|,
name|SC_XSTR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"dbgset"
block|,
name|SC_DBST
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"dbgclr"
block|,
name|SC_DBCL
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"dbgfile"
block|,
name|SC_DBOF
block|,
name|SC_XSTR
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"timeout"
block|,
name|SC_TIMO
block|,
name|SC_INT
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"expect"
block|,
name|SC_XPCT
block|,
name|SC_XSTR
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"ifcarr"
block|,
name|SC_CARR
block|,
name|SC_NONE
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"ifhang"
block|,
name|SC_HUPS
block|,
name|SC_NONE
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"flush"
block|,
name|SC_FLSH
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"ifblind"
block|,
name|SC_IFBL
block|,
name|SC_NONE
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"ifblgtr"
block|,
name|SC_IFBG
block|,
name|SC_INT
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"sendstr"
block|,
name|SC_SNDP
block|,
name|SC_INT
block|,
name|SC_NONE
block|}
block|,
block|{
literal|"ifstr"
block|,
name|SC_IF1P
block|,
name|SC_INT
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"ifnstr"
block|,
name|SC_IF0P
block|,
name|SC_INT
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"expectstr"
block|,
name|SC_XPST
block|,
name|SC_INT
block|,
name|SC_NWST
block|}
block|,
block|{
literal|"table end"
block|,
name|SC_END
block|,
name|SC_NONE
block|,
name|SC_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|FAIL
value|1
end_define

begin_define
define|#
directive|define
name|ERROR
value|-1
end_define

begin_define
define|#
directive|define
name|MAX_SCLINE
value|255
end_define

begin_comment
comment|/* max length of a line in a script file */
end_comment

begin_define
define|#
directive|define
name|MAX_EXPCT
value|127
end_define

begin_comment
comment|/* max length of an expect string */
end_comment

begin_define
define|#
directive|define
name|CTL_DELIM
value|" \t\n\r"
end_define

begin_comment
comment|/* Delimiters for tokens */
end_comment

begin_define
define|#
directive|define
name|SAME
value|0
end_define

begin_comment
comment|/* if (strcmp(a,b) == SAME) ... */
end_comment

begin_define
define|#
directive|define
name|SLOP
value|10
end_define

begin_comment
comment|/* Slop space on arrays */
end_comment

begin_define
define|#
directive|define
name|MAX_STRING
value|200
end_define

begin_comment
comment|/* Max length string to send/expect */
end_comment

begin_define
define|#
directive|define
name|DEBUG_LEVEL
parameter_list|(
name|level
parameter_list|)
define|\
value|(Debug& (1<< level))
end_define

begin_define
define|#
directive|define
name|DB_LOG
value|0
end_define

begin_comment
comment|/* error messages and a copy of the LOGFILE output */
end_comment

begin_define
define|#
directive|define
name|DB_LGIE
value|1
end_define

begin_comment
comment|/* dial,login,init trace -- errors only */
end_comment

begin_define
define|#
directive|define
name|DB_LGI
value|2
end_define

begin_comment
comment|/* dial,login,init trace -- nonerrors (incl chr I/O) */
end_comment

begin_define
define|#
directive|define
name|DB_LGII
value|3
end_define

begin_comment
comment|/* script processing internals */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|EVEN
value|1
end_define

begin_define
define|#
directive|define
name|ODD
value|2
end_define

begin_define
define|#
directive|define
name|logit
parameter_list|(
name|m
parameter_list|,
name|p1
parameter_list|)
value|fprintf(stderr, "%s %s\n", m, p1)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|paramv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parameter vector */
end_comment

begin_decl_stmt
specifier|static
name|int
name|paramc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parameter count */
end_comment

begin_decl_stmt
specifier|static
name|char
name|telno
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Telephone number w/meta-chars */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fShangup
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if HUP signal received */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dbf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|termio
name|old
decl_stmt|,
name|new
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|usignal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|uhup
parameter_list|()
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|siglist
block|{
name|int
name|signal
decl_stmt|;
name|int
function_decl|(
modifier|*
name|o_catcher
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|n_catcher
function_decl|)
parameter_list|()
function_decl|;
block|}
name|sigtbl
index|[]
init|=
block|{
block|{
name|SIGHUP
block|,
name|NULL
block|,
name|uhup
block|}
block|,
block|{
name|SIGINT
block|,
name|NULL
block|,
name|usignal
block|}
block|,
block|{
name|SIGIOT
block|,
name|NULL
block|,
name|usignal
block|}
block|,
block|{
name|SIGQUIT
block|,
name|NULL
block|,
name|usignal
block|}
block|,
block|{
name|SIGTERM
block|,
name|NULL
block|,
name|usignal
block|}
block|,
block|{
name|SIGALRM
block|,
name|NULL
block|,
name|usignal
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
comment|/* Table end */
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|struct
name|script
modifier|*
name|read_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|msleep
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
name|xgetc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|charlog
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|setup_tty
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_tty
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ttoslow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ttflui
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tthang
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ttbreak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tt7bit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ttpar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|DEBUG
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * **********************************  * * BEGIN EXECUTION - MAIN PROGRAM *  * **********************************  *  * This program is called by Taylor UUCP with a list of  * arguments in argc/argv, and stdin/stdout mapped to the  * tty device, and stderr mapped to the Taylor logfile, where  * anything written to stdout will be logged as an error.  *  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
name|FILE
modifier|*
name|sf
decl_stmt|;
name|char
name|sfname
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|script
modifier|*
name|script
decl_stmt|;
name|struct
name|siglist
modifier|*
name|sigs
decl_stmt|;
comment|/*    * The following is needed because my cpp does not have the    * #error directive...    */
if|#
directive|if
operator|!
name|HAVE_SELECT
name|no_select_sorry
argument_list|()
expr_stmt|;
comment|/* Sad way to fail make */
endif|#
directive|endif
name|paramv
operator|=
operator|&
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/* Parameters start at 2nd arg */
name|paramc
operator|=
name|argc
operator|-
literal|2
expr_stmt|;
comment|/* Number of live parameters */
name|telno
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no script file supplied\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*    * If the script file argument begins with '/', then we assume    * it is an absolute pathname, otherwise, we prepend the    * SCRIPT_DIR path.    */
operator|*
name|sfname
operator|=
literal|'\0'
expr_stmt|;
comment|/* Empty name string */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
comment|/* If relative path */
name|strcat
argument_list|(
name|sfname
argument_list|,
name|SCRIPT_DIR
argument_list|)
expr_stmt|;
comment|/* Prepend the default dir. */
name|strcat
argument_list|(
name|sfname
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Add the script file name */
comment|/*    * Now open the script file.    */
if|if
condition|(
operator|(
name|sf
operator|=
name|fopen
argument_list|(
name|sfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Failed to open script %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|sfname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*    * COMPILE SCRIPT    */
if|if
condition|(
operator|(
name|script
operator|=
name|read_script
argument_list|(
name|sf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: script error in \"%s\"\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*    * Set up a signal catcher so the line can be returned to    * it's current state if something nasty happens.    */
name|sigs
operator|=
operator|&
name|sigtbl
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|sigs
operator|->
name|signal
condition|)
block|{
name|sigs
operator|->
name|o_catcher
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|sigs
operator|->
name|signal
argument_list|,
name|sigs
operator|->
name|n_catcher
argument_list|)
expr_stmt|;
name|sigs
operator|+=
literal|1
expr_stmt|;
block|}
comment|/*    * Save current tty settings, then set up raw, single    * character input processing, with 7-bit stripping.    */
name|setup_tty
argument_list|()
expr_stmt|;
comment|/*    * EXECUTE SCRIPT    */
if|if
condition|(
operator|(
name|stat
operator|=
name|do_script
argument_list|(
name|script
argument_list|)
operator|)
operator|!=
name|SUCCESS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: script %s failed.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*    * Clean up and exit.    */
name|restore_tty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXSIGS
name|sigs
operator|=
operator|&
name|sigtbl
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|sigs
operator|->
name|signal
condition|)
if|if
condition|(
name|sigs
operator|->
name|o_catcher
operator|!=
operator|-
literal|1
condition|)
name|signal
argument_list|(
name|sigs
operator|->
name|signal
argument_list|,
name|sigs
operator|->
name|o_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * deal_script - deallocate a script and all strings it points to  */
end_comment

begin_function
name|int
name|deal_script
parameter_list|(
name|loc
parameter_list|)
name|struct
name|script
modifier|*
name|loc
decl_stmt|;
block|{
comment|/*    * If pointer is null, just exit    */
if|if
condition|(
name|loc
operator|==
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
condition|)
return|return
name|SUCCESS
return|;
comment|/*    * Deallocate the rest of the script    */
name|deal_script
argument_list|(
name|loc
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/*    * Deallocate the string parameter, if any    */
if|if
condition|(
name|loc
operator|->
name|strprm
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|loc
operator|->
name|strprm
argument_list|)
expr_stmt|;
comment|/*    * Deallocate the new state name parameter, if any    */
if|if
condition|(
name|loc
operator|->
name|newstate
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|loc
operator|->
name|newstate
argument_list|)
expr_stmt|;
comment|/*    * Deallocate this entry    */
name|free
argument_list|(
name|loc
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * read_script  *  * Read& compile a script, return pointer to first entry, or null if bad  */
end_comment

begin_function
name|struct
name|script
modifier|*
name|read_script
parameter_list|(
name|fd
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
name|struct
name|script
modifier|*
name|this
init|=
name|NULL
decl_stmt|;
name|struct
name|script
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|script
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
name|long
name|len
decl_stmt|,
name|i
decl_stmt|;
name|char
name|inpline
index|[
name|MAX_SCLINE
index|]
decl_stmt|;
name|char
name|inpcopy
index|[
name|MAX_SCLINE
index|]
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|cln
decl_stmt|,
modifier|*
name|opc
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/*    * MAIN COMPILATION LOOP    */
while|while
condition|(
operator|(
name|c
operator|=
name|fgets
argument_list|(
name|inpline
argument_list|,
operator|(
sizeof|sizeof
name|inpline
operator|-
literal|1
operator|)
argument_list|,
name|fd
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*        * Skip comments and blank lines        */
if|if
condition|(
operator|*
name|c
operator|==
literal|'#'
operator|||
operator|*
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/*        * Get rid of the trailing newline, and copy the string        */
name|inpline
index|[
name|strlen
argument_list|(
name|inpline
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|inpcopy
argument_list|,
name|inpline
argument_list|)
expr_stmt|;
comment|/*        * Look for text starting in the first col (a label)        */
if|if
condition|(
operator|(
operator|!
name|isspace
argument_list|(
name|inpline
index|[
literal|0
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|cln
operator|=
name|strchr
argument_list|(
name|inpline
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|this
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|this
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
if|if
condition|(
name|first
operator|==
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
condition|)
name|first
operator|=
name|this
expr_stmt|;
name|this
operator|->
name|next
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
expr_stmt|;
name|this
operator|->
name|opcode
operator|=
name|SC_LABEL
expr_stmt|;
name|len
operator|=
name|cln
operator|-
name|c
expr_stmt|;
name|this
operator|->
name|strprm
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|this
operator|->
name|strprm
argument_list|,
name|c
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|this
operator|->
name|strprm
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|this
operator|->
name|intprm
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|newstate
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|c
operator|=
name|cln
operator|+
literal|1
expr_stmt|;
block|}
comment|/*        * Now handle the opcode. Fold it to lower case.        */
name|opc
operator|=
name|strtok
argument_list|(
name|c
argument_list|,
name|CTL_DELIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|opc
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
comment|/* If no opcode... */
continue|continue;
comment|/* ...read the next line */
name|cp
operator|=
name|opc
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|tolower
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*        * If we have an opcode but we haven't seen anything        * else (like a label) yet, i.e., this is the first        * entry, and there was no label.  We need to        * cobble up a label so that read_script is happy        */
if|if
condition|(
name|first
operator|==
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
condition|)
block|{
name|this
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
name|first
operator|=
name|this
expr_stmt|;
name|this
operator|->
name|next
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
expr_stmt|;
name|this
operator|->
name|opcode
operator|=
name|SC_LABEL
expr_stmt|;
name|this
operator|->
name|strprm
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|this
operator|->
name|strprm
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|this
operator|->
name|intprm
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|newstate
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/*        * Find opcode - ndex through the opcode definition table        */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|sc_opdef
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
name|SC_END
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opc
argument_list|,
name|sc_opdef
index|[
name|i
index|]
operator|.
name|opname
argument_list|)
operator|==
name|SAME
condition|)
break|break;
if|if
condition|(
operator|(
name|sc_opdef
index|[
name|i
index|]
operator|.
name|opcode
operator|)
operator|==
name|SC_END
condition|)
block|{
name|logit
argument_list|(
literal|"Bad opcode in script"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|deal_script
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
return|;
block|}
comment|/*        * Found opcode. Allocate a new command node and initialize        */
name|this
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|this
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
name|this
operator|->
name|next
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
expr_stmt|;
name|this
operator|->
name|opcode
operator|=
name|sc_opdef
index|[
name|i
index|]
operator|.
name|opcode
expr_stmt|;
name|this
operator|->
name|strprm
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|this
operator|->
name|intprm
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|newstate
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/*        * Pick up new state parameter, if any        */
if|if
condition|(
name|sc_opdef
index|[
name|i
index|]
operator|.
name|newstate
operator|==
name|SC_NWST
condition|)
block|{
name|c
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CTL_DELIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"Missing new state"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|deal_script
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
return|;
block|}
else|else
block|{
name|this
operator|->
name|newstate
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|c
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|this
operator|->
name|newstate
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*        * Pick up the string or integer parameter. Handle missing        * parameter gracefully.        */
switch|switch
condition|(
name|sc_opdef
index|[
name|i
index|]
operator|.
name|prmtype
condition|)
block|{
comment|/* 	 * INT parameter - convert and store in node 	 */
case|case
name|SC_INT
case|:
name|c
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CTL_DELIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"Missing script param"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|deal_script
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* 	   * If this is the parameter to DBST or DBCL, force            * base-10 conversion, else convert per parameter. 	   */
if|if
condition|(
name|sc_opdef
index|[
name|i
index|]
operator|.
name|opcode
operator|==
name|SC_DBST
operator|||
name|sc_opdef
index|[
name|i
index|]
operator|.
name|opcode
operator|==
name|SC_DBCL
condition|)
name|this
operator|->
name|intprm
operator|=
name|strtol
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|this
operator|->
name|intprm
operator|=
name|strtol
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * STR/XSTR strings. 	 */
case|case
name|SC_STR
case|:
case|case
name|SC_XSTR
case|:
name|c
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CTL_DELIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"Missing script param"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|deal_script
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* 	   * For XSTR opcode, use c to find out where 	   * the string param begins in the copy of the 	   * input line, and pick up all that's left of 	   * the line (to allow imbedded blanks, etc.). 	   */
if|if
condition|(
name|sc_opdef
index|[
name|i
index|]
operator|.
name|prmtype
operator|==
name|SC_XSTR
condition|)
name|c
operator|=
operator|&
name|inpcopy
index|[
literal|0
index|]
operator|+
operator|(
name|c
operator|-
operator|&
name|inpline
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 	   * Allocate a buffer for the string parameter 	   */
name|this
operator|->
name|strprm
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|c
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	   * For XSTR, Translate the string and store its 	   * length. Note that, after escape sequences are 	   * compressed, the resulting string may well be a 	   * few bytes shorter than the input string (whose 	   * length was the basis for the malloc above), 	   * but it will never be longer. 	   */
if|if
condition|(
name|sc_opdef
index|[
name|i
index|]
operator|.
name|prmtype
operator|==
name|SC_XSTR
condition|)
block|{
name|this
operator|->
name|intprm
operator|=
name|xlat_str
argument_list|(
name|this
operator|->
name|strprm
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|this
operator|->
name|strprm
index|[
name|this
operator|->
name|intprm
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|this
operator|->
name|strprm
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*    * EOF    */
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/*  * xlat_str  *  * Translate embedded escape characters in a "send" or "expect" string.  *  * Called by read_script(), above.  *  * Returns the actual length of the resulting string.  Note that imbedded  * nulls (specified by \000 in the input) ARE allowed in the result.  */
end_comment

begin_macro
name|xlat_str
argument_list|(
argument|out
argument_list|,
argument|in
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|k
decl_stmt|;
while|while
condition|(
name|in
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|in
index|[
name|i
index|]
operator|!=
literal|'\\'
condition|)
block|{
name|out
index|[
name|j
operator|++
index|]
operator|=
name|in
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|in
index|[
operator|++
name|i
index|]
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* EOT */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* null */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* line feed */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|0x0a
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* carriage return */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|0x0d
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* space */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* tab */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* hyphen */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* back slash */
name|out
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* '\nnn' format */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|byte
operator|=
name|in
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|3
operator|>
operator|++
name|k
condition|)
if|if
condition|(
operator|(
name|in
index|[
name|i
operator|+
literal|1
index|]
operator|<
literal|'0'
operator|)
operator|||
operator|(
name|in
index|[
name|i
operator|+
literal|1
index|]
operator|>
literal|'7'
operator|)
condition|)
break|break;
else|else
block|{
name|byte
operator|=
operator|(
name|byte
operator|<<
literal|3
operator|)
operator|+
name|in
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|out
index|[
name|j
operator|++
index|]
operator|=
name|byte
expr_stmt|;
break|break;
default|default:
comment|/* don't know so skip it */
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|j
return|;
block|}
end_block

begin_comment
comment|/* find a state within a script */
end_comment

begin_function
name|struct
name|script
modifier|*
name|find_state
parameter_list|(
name|begin
parameter_list|,
name|newstate
parameter_list|)
name|struct
name|script
modifier|*
name|begin
decl_stmt|;
name|char
modifier|*
name|newstate
decl_stmt|;
block|{
name|struct
name|script
modifier|*
name|here
decl_stmt|;
for|for
control|(
name|here
operator|=
name|begin
init|;
name|here
operator|!=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
condition|;
name|here
operator|=
name|here
operator|->
name|next
control|)
block|{
if|if
condition|(
name|here
operator|->
name|opcode
operator|==
name|SC_LABEL
operator|&&
name|strcmp
argument_list|(
name|here
operator|->
name|strprm
argument_list|,
name|newstate
argument_list|)
operator|==
name|SAME
condition|)
return|return
name|here
return|;
block|}
return|return
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * do_script() - execute a script  */
end_comment

begin_function
name|int
name|do_script
parameter_list|(
name|begin
parameter_list|)
name|struct
name|script
modifier|*
name|begin
decl_stmt|;
block|{
name|struct
name|script
modifier|*
name|curstate
decl_stmt|,
modifier|*
name|newstate
decl_stmt|,
modifier|*
name|curscr
decl_stmt|;
name|int
name|dbgsave
decl_stmt|;
name|char
name|tempstr
index|[
name|MAX_SCLINE
index|]
decl_stmt|;
name|char
name|dfname
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
name|chr
decl_stmt|;
name|int
name|prmlen
decl_stmt|;
name|int
name|dbfd
decl_stmt|;
name|time_t
name|sc_carrtime
init|=
literal|45000
decl_stmt|;
comment|/* time to wf carr after dial */
name|time_t
name|sc_chrdly
init|=
literal|100
decl_stmt|;
comment|/* delay time for ttoslow */
name|time_t
name|sc_ptime
init|=
literal|2000
decl_stmt|;
comment|/* time to allow for pause char */
name|time_t
name|sc_wtime
init|=
literal|10000
decl_stmt|;
comment|/* time to allow for wait char */
name|time_t
name|sc_dtime
init|=
literal|100
decl_stmt|;
comment|/* time to allow for each digit */
name|time_t
name|sc_dtmo
decl_stmt|;
comment|/* total time to dial number */
name|int
name|sc_counter
decl_stmt|;
comment|/* random counter */
name|char
name|sc_pchar
init|=
literal|','
decl_stmt|;
comment|/* modem pause character */
name|char
name|sc_wchar
init|=
literal|'W'
decl_stmt|;
comment|/* modem wait-for-dialtone character */
name|time_t
name|sc_begwait
decl_stmt|;
comment|/* time at beg of wait */
name|time_t
name|sc_secs
decl_stmt|;
comment|/* timeout period */
name|int
name|expcnt
decl_stmt|;
name|int
name|expin
decl_stmt|;
specifier|static
name|char
name|expbuf
index|[
name|MAX_EXPCT
index|]
decl_stmt|;
name|dbgsave
operator|=
name|Debug
expr_stmt|;
name|curstate
operator|=
name|begin
expr_stmt|;
if|if
condition|(
name|curstate
operator|==
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
condition|)
return|return
name|SUCCESS
return|;
name|_newstate
label|:
comment|/*    * do all of curstate's actions.  Enter with curstate pointing    * to a label entry    */
name|expin
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|curscr
operator|=
name|curstate
operator|->
name|next
init|;
comment|/* point to 1st scr after label */
operator|(
name|curscr
operator|!=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
operator|)
operator|&&
comment|/* do until end of scr */
operator|(
name|curscr
operator|->
name|opcode
operator|!=
name|SC_LABEL
operator|)
condition|;
comment|/* or next label */
name|curscr
operator|=
name|curscr
operator|->
name|next
control|)
block|{
name|expcnt
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|curscr
operator|->
name|opcode
condition|)
block|{
case|case
name|SC_LABEL
case|:
name|logit
argument_list|(
literal|"Script proc err"
argument_list|,
name|curstate
operator|->
name|strprm
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
case|case
name|SC_FLSH
case|:
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Flushing typeahead buffer\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttflui
argument_list|()
expr_stmt|;
break|break;
case|case
name|SC_CDLY
case|:
name|sc_chrdly
operator|=
name|curscr
operator|->
name|intprm
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Set chrdly to %d\n"
argument_list|,
name|sc_chrdly
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_PCHR
case|:
name|sc_pchar
operator|=
operator|*
operator|(
name|curscr
operator|->
name|strprm
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Set pause char to %c\n"
argument_list|,
name|sc_pchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_PTIM
case|:
name|sc_ptime
operator|=
name|curscr
operator|->
name|intprm
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Set pause time to %d\n"
argument_list|,
name|sc_ptime
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_WCHR
case|:
name|sc_wchar
operator|=
operator|*
operator|(
name|curscr
operator|->
name|strprm
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Set wait char to %c\n"
argument_list|,
name|sc_wchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_WTIM
case|:
name|sc_wtime
operator|=
name|curscr
operator|->
name|intprm
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Set wait time to %d\n"
argument_list|,
name|sc_wtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_ZERO
case|:
name|sc_counter
operator|=
literal|0
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Set counter to %d\n"
argument_list|,
name|sc_counter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_INCR
case|:
name|sc_counter
operator|++
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Incr counter to %d\n"
argument_list|,
name|sc_counter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_WAIT
case|:
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Sleeping %d tenth-secs\n"
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_DTIM
case|:
name|sc_dtime
operator|=
name|curscr
operator|->
name|intprm
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Digit time is %d\n"
argument_list|,
name|sc_dtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_CTIM
case|:
name|sc_carrtime
operator|=
name|curscr
operator|->
name|intprm
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Carrier time is %d\n"
argument_list|,
name|sc_carrtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_EXIT
case|:
name|Debug
operator|=
name|dbgsave
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Script ended successfully\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
case|case
name|SC_FAIL
case|:
name|Debug
operator|=
name|dbgsave
expr_stmt|;
if|if
condition|(
name|DEBUG_LEVEL
argument_list|(
name|DB_LGI
argument_list|)
operator|&&
name|dbf
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|dbf
argument_list|,
literal|"Script failed\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expin
condition|)
name|charlog
argument_list|(
name|expbuf
argument_list|,
name|expin
argument_list|,
name|DB_LOG
argument_list|,
literal|"Script failed.  Last received data"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
case|case
name|SC_LOG
case|:
name|logit
argument_list|(
name|curscr
operator|->
name|strprm
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_LOGE
case|:
name|logit
argument_list|(
literal|"ERROR: "
argument_list|,
name|curscr
operator|->
name|strprm
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_DBOF
case|:
comment|/* 	   * If the debug file name does not begin with "/", then 	   * we prepend the LOG_DIR to the string. Then CREATE the 	   * file. This WIPES OUT previous logs. 	   */
operator|*
name|dfname
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zero name string */
if|if
condition|(
name|curscr
operator|->
name|strprm
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|dfname
argument_list|,
name|LOG_DIR
argument_list|)
expr_stmt|;
comment|/* Prepend default directory */
name|strcat
argument_list|(
name|dfname
argument_list|,
name|curscr
operator|->
name|strprm
argument_list|)
expr_stmt|;
comment|/* Add given string */
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Open debug file %s\n"
argument_list|,
name|dfname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbfd
operator|=
name|creat
argument_list|(
name|dfname
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Failed to create debug log %s"
argument_list|,
name|dfname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|dbf
operator|=
name|fdopen
argument_list|(
name|dbfd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"Failed to open debug log fildes."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
case|case
name|SC_DBG
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"<%s>\n"
argument_list|,
name|curscr
operator|->
name|strprm
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_DBGE
case|:
name|DEBUG
argument_list|(
name|DB_LGIE
argument_list|,
literal|"ERROR:<%s>\n"
argument_list|,
name|curscr
operator|->
name|strprm
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_DBST
case|:
name|Debug
operator||=
name|curscr
operator|->
name|intprm
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Debug mask set to %04o (octal)\n"
argument_list|,
name|Debug
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_DBCL
case|:
name|Debug
operator|&=
operator|~
operator|(
name|curscr
operator|->
name|intprm
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"Debug mask set to %04o (octal)\n"
argument_list|,
name|Debug
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_BRK
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Sending break\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttbreak
argument_list|()
expr_stmt|;
break|break;
case|case
name|SC_HANG
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Dropping DTR\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tthang
argument_list|()
expr_stmt|;
break|break;
case|case
name|SC_7BIT
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Enabling 7-bit stripping\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt7bit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_8BIT
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Disabling 7-bit stripping\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt7bit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_PNON
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Setting 8-bit, no parity\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttpar
argument_list|(
name|NONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_PEVN
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Setting 7-bit, even parity\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttpar
argument_list|(
name|EVEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_PODD
case|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Setting 7-bit, odd parity\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttpar
argument_list|(
name|ODD
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_IFBL
case|:
if|if
condition|(
name|ttblind
argument_list|()
condition|)
block|{
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Blind mux,\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
case|case
name|SC_IFBG
case|:
if|if
condition|(
name|ttblind
argument_list|()
operator|&&
name|sc_counter
operator|>
name|curscr
operator|->
name|intprm
condition|)
block|{
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Blind mux& ctr> %d\n"
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
case|case
name|SC_IFGT
case|:
if|if
condition|(
name|sc_counter
operator|>
name|curscr
operator|->
name|intprm
condition|)
block|{
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Counter> %d\n"
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
case|case
name|SC_GOTO
case|:
name|_chgstate
label|:
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Changing to state %s\n"
argument_list|,
name|curscr
operator|->
name|newstate
argument_list|)
expr_stmt|;
name|curstate
operator|=
name|find_state
argument_list|(
name|begin
argument_list|,
name|curscr
operator|->
name|newstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstate
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"New state not found"
argument_list|,
name|curscr
operator|->
name|newstate
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
goto|goto
name|_newstate
goto|;
case|case
name|SC_SEND
case|:
name|ttoslow
argument_list|(
name|curscr
operator|->
name|strprm
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|,
name|sc_chrdly
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_TELN
case|:
if|if
condition|(
name|curscr
operator|->
name|intprm
operator|>
name|paramc
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|tempstr
argument_list|,
literal|"telno - param #%d"
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
name|logit
argument_list|(
name|tempstr
argument_list|,
literal|" not present"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|strcpy
argument_list|(
name|telno
argument_list|,
name|paramv
index|[
name|curscr
operator|->
name|intprm
index|]
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGII
argument_list|,
literal|"telno set to %s\n"
argument_list|,
name|telno
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_SNDP
case|:
if|if
condition|(
name|curscr
operator|->
name|intprm
operator|>
name|paramc
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|tempstr
argument_list|,
literal|"sendstr - param #%d"
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
name|logit
argument_list|(
name|tempstr
argument_list|,
literal|" not present"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|prmlen
operator|=
name|xlat_str
argument_list|(
name|tempstr
argument_list|,
name|paramv
index|[
name|curscr
operator|->
name|intprm
index|]
argument_list|)
expr_stmt|;
name|ttoslow
argument_list|(
name|tempstr
argument_list|,
name|prmlen
argument_list|,
name|sc_chrdly
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_IF1P
case|:
if|if
condition|(
name|curscr
operator|->
name|intprm
operator|<
name|paramc
condition|)
goto|goto
name|_chgstate
goto|;
break|break;
case|case
name|SC_IF0P
case|:
if|if
condition|(
name|curscr
operator|->
name|intprm
operator|>=
name|paramc
condition|)
goto|goto
name|_chgstate
goto|;
break|break;
case|case
name|SC_DIAL
case|:
if|if
condition|(
name|telno
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|logit
argument_list|(
literal|"telno not set"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* 	   * Compute and set a default timeout for the 'timeout' 	   * command. Some parameters in this computation may be 	   * changed by the script. See the man page xchat(8) for 	   * details. 	   */
name|sc_dtmo
operator|=
operator|(
name|sc_dtime
operator|+
name|sc_chrdly
operator|)
operator|*
name|strlen
argument_list|(
name|telno
argument_list|)
operator|+
name|sc_carrtime
expr_stmt|;
name|c
operator|=
name|strcpy
argument_list|(
name|tempstr
argument_list|,
name|telno
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'W'
condition|)
block|{
operator|*
name|c
operator|=
name|sc_wchar
expr_stmt|;
name|sc_dtmo
operator|+=
name|sc_wtime
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'P'
condition|)
block|{
operator|*
name|c
operator|=
name|sc_pchar
expr_stmt|;
name|sc_dtmo
operator|+=
name|sc_ptime
expr_stmt|;
block|}
block|}
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Dialing, default timeout is %d millisecs\n"
argument_list|,
name|sc_dtmo
argument_list|)
expr_stmt|;
name|ttoslow
argument_list|(
name|tempstr
argument_list|,
literal|0
argument_list|,
name|sc_chrdly
argument_list|)
expr_stmt|;
break|break;
case|case
name|SC_TIMO
case|:
comment|/* these are "expects", don't bother */
case|case
name|SC_XPCT
case|:
comment|/* with them yet, other than noting that */
case|case
name|SC_CARR
case|:
comment|/* they exist */
case|case
name|SC_XPST
case|:
name|expcnt
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* we've done the current state's actions, now do its expects, if any */
if|if
condition|(
name|expcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curscr
operator|!=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|curscr
operator|->
name|opcode
operator|==
name|SC_LABEL
operator|)
condition|)
block|{
name|curstate
operator|=
name|curscr
expr_stmt|;
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Fell through to state %s\n"
argument_list|,
name|curstate
operator|->
name|strprm
argument_list|)
expr_stmt|;
goto|goto
name|_newstate
goto|;
block|}
else|else
block|{
name|logit
argument_list|(
literal|"No way out of state"
argument_list|,
name|curstate
operator|->
name|strprm
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|time
argument_list|(
operator|&
name|sc_begwait
argument_list|)
expr_stmt|;
comment|/* log time at beg of expect */
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"Doing expects for state %s\n"
argument_list|,
name|curstate
operator|->
name|strprm
argument_list|)
expr_stmt|;
name|charlog
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|DB_LGI
argument_list|,
literal|"Received"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|chr
operator|=
name|xgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Returns upon char input or 1 sec. tmo */
name|charlog
argument_list|(
operator|&
name|chr
argument_list|,
literal|1
argument_list|,
name|DB_LGI
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chr
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|expin
operator|<
name|MAX_EXPCT
condition|)
block|{
name|expbuf
index|[
name|expin
operator|++
index|]
operator|=
name|chr
operator|&
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|expbuf
argument_list|,
operator|&
name|expbuf
index|[
literal|1
index|]
argument_list|,
name|MAX_EXPCT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|expbuf
index|[
name|MAX_EXPCT
operator|-
literal|1
index|]
operator|=
name|chr
operator|&
literal|0x7f
expr_stmt|;
block|}
block|}
comment|/* for each entry in the current state... */
for|for
control|(
name|curscr
operator|=
name|curstate
operator|->
name|next
init|;
operator|(
name|curscr
operator|!=
operator|(
expr|struct
name|script
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|curscr
operator|->
name|opcode
operator|!=
name|SC_LABEL
operator|)
condition|;
name|curscr
operator|=
name|curscr
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|curscr
operator|->
name|opcode
condition|)
block|{
case|case
name|SC_TIMO
case|:
name|sc_secs
operator|=
name|curscr
operator|->
name|intprm
expr_stmt|;
if|if
condition|(
name|sc_secs
operator|==
literal|0
condition|)
name|sc_secs
operator|=
name|sc_dtmo
expr_stmt|;
name|sc_secs
operator|/=
literal|1000
expr_stmt|;
if|if
condition|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|sc_begwait
operator|>
name|sc_secs
condition|)
block|{
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"\nTimed out (%d secs)\n"
argument_list|,
name|sc_secs
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
case|case
name|SC_CARR
case|:
if|if
condition|(
name|ttcd
argument_list|()
condition|)
block|{
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"\nGot carrier\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
case|case
name|SC_HUPS
case|:
if|if
condition|(
name|fShangup
condition|)
block|{
name|DEBUG
argument_list|(
name|DB_LGI
argument_list|,
literal|"\nGot data set hangup\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
case|case
name|SC_XPCT
case|:
if|if
condition|(
operator|(
name|expin
operator|>=
name|curscr
operator|->
name|intprm
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|curscr
operator|->
name|strprm
argument_list|,
operator|&
name|expbuf
index|[
name|expin
operator|-
name|curscr
operator|->
name|intprm
index|]
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
operator|==
name|SAME
operator|)
condition|)
block|{
name|charlog
argument_list|(
name|curscr
operator|->
name|strprm
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|,
name|DB_LGI
argument_list|,
literal|"Matched"
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* New opcode added by hag@eddie.mit.edu for expecting a 		 parameter supplied string */
end_comment

begin_case
case|case
name|SC_XPST
case|:
end_case

begin_if
if|if
condition|(
name|curscr
operator|->
name|intprm
operator|>
name|paramc
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|tempstr
argument_list|,
literal|"expectstr - param#%d"
argument_list|,
name|curscr
operator|->
name|intprm
argument_list|)
expr_stmt|;
name|logit
argument_list|(
name|tempstr
argument_list|,
literal|" not present"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|prmlen
operator|=
name|xlat_str
argument_list|(
name|tempstr
argument_list|,
name|paramv
index|[
name|curscr
operator|->
name|intprm
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|expin
operator|>=
name|prmlen
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|tempstr
argument_list|,
operator|&
name|expbuf
index|[
name|expin
operator|-
name|prmlen
index|]
argument_list|,
name|prmlen
argument_list|)
operator|==
name|SAME
operator|)
condition|)
block|{
name|charlog
argument_list|(
name|tempstr
argument_list|,
name|prmlen
argument_list|,
name|DB_LGI
argument_list|,
literal|"Matched"
argument_list|)
expr_stmt|;
goto|goto
name|_chgstate
goto|;
block|}
end_if

begin_break
break|break;
end_break

begin_comment
comment|/*  * SIGNAL HANDLERS  */
end_comment

begin_comment
comment|/*  * usignal - generic signal catcher  */
end_comment

begin_function
specifier|static
name|int
name|usignal
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
name|DEBUG
argument_list|(
name|DB_LOG
argument_list|,
literal|"Caught signal %d. Exiting...\n"
argument_list|,
name|isig
argument_list|)
expr_stmt|;
name|restore_tty
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * uhup - HUP catcher  */
end_comment

begin_function
specifier|static
name|int
name|uhup
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
name|DEBUG
argument_list|(
name|DB_LOG
argument_list|,
literal|"Data set hangup.\n"
argument_list|)
expr_stmt|;
name|fShangup
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TERMINAL I/O ROUTINES  */
end_comment

begin_comment
comment|/*  * xgetc - get a character with timeout  *  * Assumes that stdin is opened on a terminal or TCP socket  * with O_NONBLOCK.  */
end_comment

begin_function
specifier|static
name|char
name|xgetc
parameter_list|(
name|tmo
parameter_list|)
name|int
name|tmo
decl_stmt|;
comment|/* Timeout, seconds */
block|{
name|char
name|c
decl_stmt|;
name|struct
name|timeval
name|s
decl_stmt|;
name|int
name|f
init|=
literal|1
decl_stmt|;
comment|/* Select on stdin */
name|int
name|result
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
comment|/* If no data available */
block|{
name|s
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|tmo
expr_stmt|;
name|s
operator|.
name|tv_usec
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|f
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|1
condition|)
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
literal|'\377'
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pause for an interval in milliseconds  */
end_comment

begin_function
name|void
name|msleep
parameter_list|(
name|msec
parameter_list|)
name|long
name|msec
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_USLEEP
if|if
condition|(
name|msec
operator|==
literal|0
condition|)
comment|/* Skip all of this if delay = 0 */
return|return;
name|usleep
argument_list|(
name|msec
operator|*
operator|(
name|long
operator|)
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_USLEEP */
if|#
directive|if
name|HAVE_NAPMS
if|if
condition|(
name|msec
operator|==
literal|0
condition|)
comment|/* Skip all of this if delay = 0 */
return|return;
name|napms
argument_list|(
name|msec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NAPMS */
if|#
directive|if
name|HAVE_NAP
if|if
condition|(
name|msec
operator|==
literal|0
condition|)
comment|/* Skip all of this if delay = 0 */
return|return;
name|nap
argument_list|(
name|msec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NAP */
if|#
directive|if
name|HAVE_POLL
name|struct
name|pollfd
name|sdummy
decl_stmt|;
if|if
condition|(
name|msec
operator|==
literal|0
condition|)
return|return;
comment|/*    * We need to pass an unused pollfd structure because poll checks    * the address before checking the number of elements.    */
name|poll
argument_list|(
operator|&
name|sdummy
argument_list|,
literal|0
argument_list|,
name|msec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
if|#
directive|if
name|USE_SELECT_TIMER
name|struct
name|timeval
name|s
decl_stmt|;
if|if
condition|(
name|msec
operator|==
literal|0
condition|)
return|return;
name|s
operator|.
name|tv_sec
operator|=
name|msec
operator|/
literal|1000L
expr_stmt|;
name|s
operator|.
name|tv_usec
operator|=
operator|(
name|msec
operator|%
literal|1000L
operator|)
operator|*
literal|1000L
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SELECT_TIMER */
if|#
directive|if
operator|!
name|HAVE_NAPMS
operator|&&
operator|!
name|HAVE_NAP
operator|&&
operator|!
name|HAVE_USLEEP
operator|&&
expr|\
operator|!
name|HAVE_POLL
operator|&&
operator|!
name|USE_SELECT_TIMER
if|if
condition|(
name|msec
operator|==
literal|0
condition|)
return|return;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Sleep for a whole second (UGH!) */
endif|#
directive|endif
comment|/* HAVE_ and USE_ nothing */
block|}
end_function

begin_comment
comment|/*  * Debugging output  */
end_comment

begin_function
specifier|static
name|void
name|DEBUG
parameter_list|(
name|level
parameter_list|,
name|msg1
parameter_list|,
name|msg2
parameter_list|)
name|int
name|level
decl_stmt|;
name|char
modifier|*
name|msg1
decl_stmt|,
decl|*
name|msg2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|(
name|dbf
operator|!=
name|NULL
operator|)
operator|&&
name|DEBUG_LEVEL
argument_list|(
name|level
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dbf
argument_list|,
name|msg1
argument_list|,
name|msg2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * charlog - log a string of characters  *  * SPECIAL CASE: msg=NULL, len=1 and msg[0]='\377' gets logged  *               when read does its 1 sec. timeout. Log "<1 sec.>"  *               so user can see elapsed time  */
end_comment

begin_function
specifier|static
name|void
name|charlog
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|mask
parameter_list|,
name|msg
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
name|tbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|DEBUG_LEVEL
argument_list|(
name|mask
argument_list|)
operator|&&
name|dbf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|msg
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|msg
operator|=
literal|""
expr_stmt|;
name|strncpy
argument_list|(
name|tbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|tbuf
index|[
literal|0
index|]
operator|==
literal|'\377'
condition|)
name|strcpy
argument_list|(
name|tbuf
argument_list|,
literal|"<1 sec.>"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbf
argument_list|,
literal|"%s %s\n"
argument_list|,
name|msg
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * setup_tty()  *  * Save current tty settings, then set up raw, single  * character input processing, with 7-bit stripping.  */
end_comment

begin_function
specifier|static
name|void
name|setup_tty
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
name|new
operator|=
name|old
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|new
operator|.
name|c_cc
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
comment|/* MIN = 0, use requested count */
name|new
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|10
expr_stmt|;
comment|/* TIME = 1 sec. */
name|new
operator|.
name|c_iflag
operator|=
name|ISTRIP
expr_stmt|;
comment|/* Raw mode, 7-bit stripping */
name|new
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
comment|/* No special line discipline */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * restore_tty() - restore signal handlers and tty modes on exit.  */
end_comment

begin_function
specifier|static
name|void
name|restore_tty
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ttoslow() - Send characters with pacing delays  */
end_comment

begin_function
specifier|static
name|void
name|ttoslow
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|delay
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|time_t
name|delay
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|charlog
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|DB_LGI
argument_list|,
literal|"Sending slowly"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ttflui - flush input buffer  */
end_comment

begin_function
specifier|static
name|void
name|ttflui
parameter_list|()
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ttcd - Test if carrier is present  *  * NOT IMPLEMENTED. I don't know how!!!  */
end_comment

begin_function
specifier|static
name|int
name|ttcd
parameter_list|()
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * tthang - Force DTR low for 1-2 sec.  */
end_comment

begin_function
specifier|static
name|void
name|tthang
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isatty
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|TCCLRDTR
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCCLRDTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCSETDTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  * ttbreak - Send a "break" on the line  */
end_comment

begin_function
specifier|static
name|void
name|ttbreak
parameter_list|()
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCSBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ttblind - return TRUE if tty is "blind"  *  * NOT IMPLEMENTED - Don't know how!!!  */
end_comment

begin_function
specifier|static
name|int
name|ttblind
parameter_list|()
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * tt7bit - enable/disable 7-bit stripping on line  */
end_comment

begin_function
specifier|static
name|void
name|tt7bit
parameter_list|(
name|enable
parameter_list|)
name|int
name|enable
decl_stmt|;
block|{
if|if
condition|(
name|enable
condition|)
name|new
operator|.
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
else|else
name|new
operator|.
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ttpar - Set parity mode on line. Ignore parity errors on input.  */
end_comment

begin_function
specifier|static
name|void
name|ttpar
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|NONE
case|:
name|new
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INPCK
operator||
name|IGNPAR
operator|)
expr_stmt|;
name|new
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator||
name|PARODD
operator|)
expr_stmt|;
name|new
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
break|break;
case|case
name|EVEN
case|:
name|new
operator|.
name|c_iflag
operator||=
operator|(
name|INPCK
operator||
name|IGNPAR
operator|)
expr_stmt|;
name|new
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARODD
operator|)
expr_stmt|;
name|new
operator|.
name|c_cflag
operator||=
operator|(
name|CS7
operator||
name|PARENB
operator|)
expr_stmt|;
break|break;
case|case
name|ODD
case|:
name|new
operator|.
name|c_iflag
operator||=
operator|(
name|INPCK
operator||
name|IGNPAR
operator|)
expr_stmt|;
name|new
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator|)
expr_stmt|;
name|new
operator|.
name|c_cflag
operator||=
operator|(
name|CS7
operator||
name|PARENB
operator||
name|PARODD
operator|)
expr_stmt|;
break|break;
block|}
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

