begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uusnap.c    (c) 1992 Heiko W.Rupp hwr@pilhuhn.ka.sub.org    uusnap is a tool to display the activities of the connected    systems.     Put a file uusnap.systems in NEWCONFIGDIR (see Makefile), in which    the systems, you want to monitor are listed, one on a single line.    The sequence of the files there determine the sequence of the    listing.     At the moment it only works with taylor config and taylor dirs     compile it form the Makefile or:    cc -c -g -pipe -O  -I. -I. -DNEWCONFIGLIB=\"/usr/local/lib/uucp\" uusnap.c    cc  -o uusnap uusnap.o     For this, uusnap.[ch] must be in the same directory as uucp.h and so.     uusnap must have read access to SPOOLDIR/.Status in order to work. */
end_comment

begin_define
define|#
directive|define
name|MAXSYS
value|30
end_define

begin_comment
comment|/* maximum number of systems */
end_comment

begin_define
define|#
directive|define
name|WAIT_NORMAL
value|10
end_define

begin_comment
comment|/* wait period if noone is talking */
end_comment

begin_define
define|#
directive|define
name|WAIT_TALKING
value|2
end_define

begin_comment
comment|/* refresh display every second if */
end_comment

begin_comment
comment|/* someone is talking with us */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|uusnap_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|(
name|time_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|sysInfo
block|{
name|char
name|sysname
index|[
literal|10
index|]
decl_stmt|;
comment|/* name of the system to watch */
name|char
modifier|*
name|statfile
decl_stmt|;
comment|/* name of its status file */
name|char
modifier|*
name|spooldir
decl_stmt|;
comment|/* root of its spooldir */
name|int
name|in
decl_stmt|;
comment|/* number of unprocessed in-files */
name|int
name|out
decl_stmt|;
comment|/* number of files to send them */
name|time_t
name|last
decl_stmt|;
comment|/* last poll time */
name|time_t
name|next
decl_stmt|;
comment|/* time of next poll */
name|time_t
name|lastidir
decl_stmt|;
comment|/* time of last in-spooldir access */
name|time_t
name|lastodir
decl_stmt|;
comment|/* time of last outgoing spd acc */
name|time_t
name|laststat
decl_stmt|;
comment|/* time of last status file access */
name|int
name|status
decl_stmt|;
comment|/* status of the system */
name|int
name|num_retries
decl_stmt|;
comment|/* number of retries */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|sysInfo
name|Systems
index|[
name|MAXSYS
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  I have extend the system status. If time for the specified system     is Never, I say so. To get this to work, one also should extend     uucico.c. It is not important to do this. With the normal uucico,     one only gets no status. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|azStatus
index|[]
init|=
comment|/* Status codes as defined by uucico  */
block|{
comment|/* listing them here instead of       */
literal|"Conversation complete"
block|,
comment|/* including the appropriate file     */
literal|"Port unavailable"
block|,
comment|/* reduces the size of the executable */
literal|"Dial failed"
block|,
literal|"Login failed"
block|,
literal|"Handshake failed"
block|,
literal|"Call failed"
block|,
literal|"Talking"
block|,
literal|"Wrong time to call"
block|,
literal|"Time to call = Never !"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|get_systems
argument_list|()
expr_stmt|;
name|display_info
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_systems
parameter_list|()
block|{
name|char
name|filename
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|fn
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|struct
name|sysInfo
name|sys
decl_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|NEWCONFIGLIB
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/uusnap.systems"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|80
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|rindex
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|sys
operator|.
name|sysname
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* get the name of the system */
name|strcpy
argument_list|(
name|fn
argument_list|,
name|SPOOLDIR
argument_list|)
expr_stmt|;
comment|/* get the name of the statusfile */
name|strcat
argument_list|(
name|fn
argument_list|,
literal|"/.Status/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fn
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sys
operator|.
name|statfile
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sys
operator|.
name|statfile
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fn
argument_list|,
name|SPOOLDIR
argument_list|)
expr_stmt|;
comment|/* get the name of the spooldir */
name|strcat
argument_list|(
name|fn
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fn
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sys
operator|.
name|spooldir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sys
operator|.
name|spooldir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|sys
operator|.
name|laststat
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|lastidir
operator|=
name|sys
operator|.
name|lastodir
operator|=
literal|0
expr_stmt|;
name|Systems
index|[
name|i
index|]
operator|=
name|sys
expr_stmt|;
comment|/* get_stat_for_system needs it */
name|get_stat_for_system
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* now get the system status */
name|get_inq_num
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* number of unprocessed files */
name|get_outq_num
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* number of files to send */
name|i
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s \n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_macro
name|display_info
argument_list|(
argument|int numSys
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|sysnum
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|contentline
index|[
literal|80
index|]
decl_stmt|;
name|char
name|isTalking
init|=
name|FALSE
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|struct
name|sysInfo
name|sys
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't malloc 1024 bytes"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
name|display_headline
argument_list|()
expr_stmt|;
for|for
control|(
name|sysnum
operator|=
literal|0
init|;
name|sysnum
operator|<
name|numSys
condition|;
name|sysnum
operator|++
control|)
block|{
name|sys
operator|=
name|Systems
index|[
name|sysnum
index|]
expr_stmt|;
name|stat
argument_list|(
name|sys
operator|.
name|statfile
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|time
operator|=
name|stbuf
operator|.
name|st_atime
operator|)
operator|>
name|sys
operator|.
name|laststat
condition|)
block|{
name|get_stat_for_system
argument_list|(
name|sysnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_status_line
argument_list|(
name|sysnum
argument_list|)
operator|==
literal|1
condition|)
name|isTalking
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|isTalking
condition|)
block|{
name|sleep
argument_list|(
name|WAIT_TALKING
argument_list|)
expr_stmt|;
name|isTalking
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|sleep
argument_list|(
name|WAIT_NORMAL
argument_list|)
expr_stmt|;
comment|/* wait a bit */
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|display_status_line
parameter_list|(
name|int
name|sn
parameter_list|)
block|{
name|char
modifier|*
name|time_s
decl_stmt|;
name|int
name|sys_stat
decl_stmt|,
name|num_retries
decl_stmt|,
name|wait
decl_stmt|;
name|int
name|i
decl_stmt|;
name|time_t
name|last_time
decl_stmt|;
name|time_t
name|next_time
decl_stmt|;
name|struct
name|sysInfo
name|sys
decl_stmt|;
name|sys
operator|=
name|Systems
index|[
name|sn
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%10s  "
argument_list|,
name|sys
operator|.
name|sysname
argument_list|)
expr_stmt|;
name|get_inq_num
argument_list|(
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|in
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
name|sys
operator|.
name|in
argument_list|)
expr_stmt|;
name|get_outq_num
argument_list|(
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|out
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
name|sys
operator|.
name|out
argument_list|)
expr_stmt|;
name|time_s
operator|=
name|ctime
argument_list|(
operator|&
name|sys
operator|.
name|last
argument_list|)
expr_stmt|;
name|time_s
operator|=
name|time_s
operator|+
literal|11
expr_stmt|;
operator|*
operator|(
name|time_s
operator|+
literal|8
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%8s "
argument_list|,
name|time_s
argument_list|)
expr_stmt|;
comment|/* time of last poll */
name|time_s
operator|=
name|ctime
argument_list|(
operator|&
name|sys
operator|.
name|next
argument_list|)
expr_stmt|;
name|time_s
operator|=
name|time_s
operator|+
literal|11
expr_stmt|;
operator|*
operator|(
name|time_s
operator|+
literal|8
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|last
operator|==
name|sys
operator|.
name|next
condition|)
name|printf
argument_list|(
literal|"           "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%8s   "
argument_list|,
name|time_s
argument_list|)
expr_stmt|;
comment|/* time of next poll */
if|if
condition|(
name|sys
operator|.
name|num_retries
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%2d "
argument_list|,
name|sys
operator|.
name|num_retries
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_stat
operator|==
literal|6
condition|)
comment|/* system is talking */
name|printf
argument_list|(
literal|"\E[7m"
argument_list|)
expr_stmt|;
comment|/* reverse video on */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|azStatus
index|[
name|sys
operator|.
name|status
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|status
operator|==
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"\E[m\n"
argument_list|)
expr_stmt|;
comment|/* reverse video off */
return|return
literal|1
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_macro
name|display_headline
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"\E[;H\E[2J"
argument_list|)
expr_stmt|;
comment|/* clear screen */
name|printf
argument_list|(
literal|"\E[7muusnap (press CTRL-C to escape)\E[m \n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  System     #in #out   last     next   #ret    Status\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|get_inq_num
argument_list|(
argument|int num
argument_list|,
argument|char firstTime
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|filename
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|Systems
index|[
name|num
index|]
operator|.
name|spooldir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/X./."
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|Systems
index|[
name|num
index|]
operator|.
name|lastidir
operator|)
operator|||
operator|(
name|firstTime
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|filename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|readdir
argument_list|(
name|dirp
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|Systems
index|[
name|num
index|]
operator|.
name|lastidir
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s \n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
name|i
operator|-=
literal|2
expr_stmt|;
comment|/* correct . and .. */
name|Systems
index|[
name|num
index|]
operator|.
name|in
operator|=
name|i
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|get_outq_num
argument_list|(
argument|int sys
argument_list|,
argument|char firstTime
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|filename
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|Systems
index|[
name|sys
index|]
operator|.
name|spooldir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/C./."
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|Systems
index|[
name|sys
index|]
operator|.
name|lastodir
operator|)
operator|||
operator|(
name|firstTime
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|filename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|readdir
argument_list|(
name|dirp
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|Systems
index|[
name|sys
index|]
operator|.
name|lastodir
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s \n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
name|i
operator|-=
literal|2
expr_stmt|;
comment|/* correct . and .. */
name|Systems
index|[
name|sys
index|]
operator|.
name|out
operator|=
name|i
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|get_stat_for_system
argument_list|(
argument|int i
argument_list|)
end_macro

begin_block
block|{
name|char
name|fn
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|sysInfo
name|sys
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|wait
decl_stmt|;
name|sys
operator|=
name|Systems
index|[
name|i
index|]
expr_stmt|;
name|stat
argument_list|(
name|sys
operator|.
name|statfile
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_atime
operator|>
name|sys
operator|.
name|laststat
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|sys
operator|.
name|statfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fgets
argument_list|(
name|fn
argument_list|,
literal|80
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|fn
argument_list|,
literal|"%d %d %ld %d"
argument_list|,
operator|&
name|sys
operator|.
name|status
argument_list|,
operator|&
name|sys
operator|.
name|num_retries
argument_list|,
operator|&
name|sys
operator|.
name|last
argument_list|,
operator|&
name|wait
argument_list|)
expr_stmt|;
name|sys
operator|.
name|next
operator|=
name|sys
operator|.
name|last
operator|+
name|wait
expr_stmt|;
block|}
else|else
block|{
name|sys
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|num_retries
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|last
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|stat
argument_list|(
name|sys
operator|.
name|statfile
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|sys
operator|.
name|laststat
operator|=
name|stbuf
operator|.
name|st_atime
expr_stmt|;
block|}
name|Systems
index|[
name|i
index|]
operator|=
name|sys
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

