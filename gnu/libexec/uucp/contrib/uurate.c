begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)uurate.c 1.2 - Thu Sep  3 18:32:46 1992  *  * This program digests log and stats files in the "Taylor" format  * and outputs various statistical data to standard out.  *  * Author:  *      Bob Denny (denny@alisa.com)  *      Fri Feb  7 13:38:36 1992  *  * Original author:  *      Mark Pizzolato   mark@infopiz.UUCP  *  * Edits:  *      Bob Denny - Fri Feb  7 15:04:54 1992  *      Heavy rework for Taylor UUCP. This was the (very old) uurate from  *      DECUS UUCP, which had a single logfile for activity and stats.  *      Personally, I would have done things differently, with tables  *      and case statements, but in the interest of time, I preserved  *      Mark Pizzolato's techniques and style.  *  *      Bob Denny - Sun Aug 30 14:18:50 1992  *      Changes to report format suggested by Francois Pinard and others.  *      Add summary report, format from uutraf.pl (perl script), again  *      thanks to Francois. Integrate and checkout with 1.03 of Taylor UUCP.  *  *      Stephan Niemz<stephan@sunlab.ka.sub.org> - Fri Apr 9 1993  *      - Print totals in summary report,  *      - show all commands in execution report,  *      - count incoming calls correctly,  *      - suppress empty tables,  *      - don't divide by zero in efficiency report,  *      - limit the efficiency to 100% (could be more with the i-protocol),  *      - suppress some zeros to improve readability,  *      - check for failure of calloc,  *      - -h option changed to -s for consistency with all other uucp commands  *        (but -h was left in for comptibility).  *  *      Scott Boyd<scott@futures.com> - Thu Aug 26 13:21:34 PDT 1993  *      - Changed hosts linked-list insertion routine so that hosts  *        are always listed in alphabetical order on reports.  *  *      Klaus Dahlenburg<kdburg@incoahe.hanse.de> - Fri Jun 18 1993 (1.2.2)  *      - redesigned the printed layout (sticked to those 80 column tubes).  *      - 'Retry time not ...' and ' ERROR: All matching ports ...' will now be  *        counted as calls and will raise the failed-call counter.  *      - times now shown as hh:mm:ss; the fields may hold up to 999 hrs    *        (a month equals 744 hrs at max). Printing will be as follows:  *  *         hrs> 0  hh:mm:ss  *         min> 0     mm:ss  *         sec> 0        ss  *         leading zeroes are suppressed.  *  *      - the bytes xfered will be given in thousands only (we're counting   *        so 1K is 1000 bytes!). Sums up to 9,999,999.9 thousand can be shown.  *      - dropped the fractions of a byte in columns: bytes/second (avg cps).  *      - File statistic changed to display in/out in one row instead of 2  *        separate reports.  *      - eliminated the goto in command report and tightened the code; also  *        the 'goto usage' has been replaced by a call to void usage() with no  *        return (exit 1).  *      - a totaling is done for all reports now; the total values are held   *        within the structure; after finishing read there will be an alloc  *        for a site named 'Total' so that the totals line will be printed  *        more or less automatically.  *      - option -t implemented: that is every possible report will be given.  *      - the start and end date/time of the input files are printed; can be  *        dropped by the -q option at run time.  *      - it is now possible to use Log/Stats files from V2_LOGGING configs.  *        They must however not be mixed together (with each other).  *      - the Log/Stats files are taken from config which is passed via  *        Makefile at compile time. Variable to set is: newconfigdir. If the  *        default config can't be read the default values are used  *        (the config is optional!).  *        Note: keyword/filename must be on the same line (no continuation).  *      - -I option implemented to run with a different config file. In case  *        the file can't be opened the run is aborted!  *      - -q option implemented to run without environment report (default is  *        FALSE: print the report).  *      - -p option added to print protocol statistics: one for the packets  *        and one for the errors encountered  *      - reapplied patch by Scott Boyd<scott@futures.com> that I did not  *        get knowledge of  */
end_comment

begin_comment
comment|/* $Log: uurate.c,v $  * Revision 1.3.4.1  1995/09/01  06:01:59  davidg  * Brought in changes from main branch: updated to UUCP 1.06.1  *  * Reviewed by:	ache  *  * Revision 1.4  1995/08/19  21:24:38  ache  * Commit delta: current -> 1.06 + FreeBSD configuration  *  * Revision 1.15  1994/04/07  21:47:11  kdburg  * printed 'no data avail' while there was data; layout chnaged  * (cosmetic only)  *  * Revision 1.14  1994/04/07  21:16:32  kdburg  * the layout of the protocol-used line within the LOGFILE changed  * from 1.04 to 1.05; both formats may be used together; output  * changed for packet report (columns adjusted)  *  * Revision 1.13  1994/04/04  10:04:35  kdburg  * cosmetic change to the packet-report (separator lines)  *  * Revision 1.12  1994/03/30  19:52:04  kdburg  * incorporated patch by Scott Boyd which was missing from this version  * of uurate.c. Left the comment in cronological order.  *  * Revision 1.11  1994/03/28  18:53:22  kdburg  * config not checked properly for 'logfile/statsfile' overwrites, bail-out  * possible; wrong file name written to log for statsfile when found  *  * Revision 1.10  1993/09/28  16:46:51  kdburg  * transmission failures denoted by: failed after ... in stats file  * have not been counted at all.  *  * Revision 1.9  1993/08/17  23:38:36  kdburg  * sometimes a line(site) was missing from the protocol stats due  * to a missing +; added option -d and -v reassing option -h to print  * the help; a zero was returned instead of a null-pointer by  * prot_sum  *  * Revision 1.8  1993/07/03  06:58:55  kdburg  * empty input not handled properly; assigned some buffer to input; msg  * not displayed when no protocol data was available  *  * Revision 1.7  1993/06/27  10:31:53  kdburg  * rindex was replaced by strchr must be strrchr  *  * Revision 1.6  1993/06/26  06:59:18  kdburg  * switch hdr_done not reset at beginning of protocol report  *  * Revision 1.5  1993/06/25  22:22:30  kdburg  * changed rindex to strchr; if there is no NEWCONFIG defined take  * appropriate action  *  * Revision 1.4  1993/06/25  20:04:07  kdburg  * added comment about -p option; inserted proto for rindex  *  * Revision 1.3  1993/06/25  19:31:14  kdburg  * major rework done; added protocol reports (normal/errors)  *  * Revision 1.2  1993/06/21  19:53:54  kdburg  * init  * */
end_comment

begin_decl_stmt
name|char
name|version
index|[]
init|=
literal|"@(#) Taylor UUCP Log File Summary Filter, Version 1.2.2"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: uurate.c,v 1.3.4.1 1995/09/01 06:01:59 davidg Exp $"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Character Classification      */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_comment
comment|/* uucp.h includes string.h or strings.h, no include here. */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_PARAM_H
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_DEBUG_
value|0
end_define

begin_comment
comment|/*  * Direction of Calling and Data Transmission  */
end_comment

begin_define
define|#
directive|define
name|IN
value|0
end_define

begin_comment
comment|/* Inbound            */
end_comment

begin_define
define|#
directive|define
name|OUT
value|1
end_define

begin_comment
comment|/* Outbound            */
end_comment

begin_comment
comment|/*  *  define some limits  */
end_comment

begin_define
define|#
directive|define
name|MAXCOLS
value|8
end_define

begin_comment
comment|/* report has this # of columns incl. 'name' */
end_comment

begin_define
define|#
directive|define
name|MAXREP
value|6
end_define

begin_comment
comment|/* number of reports available */
end_comment

begin_define
define|#
directive|define
name|MAXFNAME
value|64
end_define

begin_comment
comment|/* max input file name length incl. path*/
end_comment

begin_define
define|#
directive|define
name|MAXDNAME
value|8
end_define

begin_comment
comment|/* max display (Hostname) name length  */
end_comment

begin_comment
comment|/*  * Data structures used to collect information  */
end_comment

begin_struct
struct|struct
name|File_Stats
block|{
name|int
name|files
decl_stmt|;
comment|/* Files Transferred      */
name|unsigned
name|long
name|bytes
decl_stmt|;
comment|/* Data Size Transferred*/
name|double
name|time
decl_stmt|;
comment|/* Transmission Time      */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Phone_Call
block|{
name|int
name|calls
decl_stmt|;
comment|/* Call Count            */
name|int
name|succs
decl_stmt|;
comment|/* Successful calls     */
name|double
name|connect_time
decl_stmt|;
comment|/* Connect Time Spent      */
name|struct
name|File_Stats
name|flow
index|[
literal|2
index|]
decl_stmt|;
comment|/* Rcvd& Sent Data      */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Execution_Command
block|{
name|struct
name|Execution_Command
modifier|*
name|next
decl_stmt|;
name|char
name|Commandname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Protocol_Summary
block|{
name|struct
name|Protocol_Summary
modifier|*
name|next
decl_stmt|;
name|char
name|type
index|[
literal|3
index|]
decl_stmt|;
name|long
name|int
name|pr_cnt
decl_stmt|;
name|long
name|int
name|pr_psent
decl_stmt|;
name|long
name|int
name|pr_present
decl_stmt|;
name|long
name|int
name|pr_preceived
decl_stmt|;
name|long
name|int
name|pr_eheader
decl_stmt|;
name|long
name|int
name|pr_echksum
decl_stmt|;
name|long
name|int
name|pr_eorder
decl_stmt|;
name|long
name|int
name|pr_ereject
decl_stmt|;
name|long
name|int
name|pr_pwinmin
decl_stmt|;
name|long
name|int
name|pr_pwinmax
decl_stmt|;
name|long
name|int
name|pr_psizemin
decl_stmt|;
name|long
name|int
name|pr_psizemax
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Host_entry
block|{
name|struct
name|Host_entry
modifier|*
name|next
decl_stmt|;
name|char
name|Hostname
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|Execution_Command
modifier|*
name|cmds
decl_stmt|;
comment|/* Local Activities */
name|struct
name|Phone_Call
name|call
index|[
literal|2
index|]
decl_stmt|;
comment|/* In& Out Activities */
name|struct
name|Protocol_Summary
modifier|*
name|proto
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|Host_entry
modifier|*
name|hosts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Host_entry
modifier|*
name|tot
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Host_entry
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Execution_Command
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|t_cmds
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Protocol_Summary
modifier|*
name|prot
decl_stmt|,
modifier|*
name|t_prot
decl_stmt|,
modifier|*
name|s_prot
decl_stmt|,
modifier|*
name|ss_prot
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Stuff for getopt()  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GETOPT : Option Index */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GETOPT : Option Value */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_STDLIB_H
end_if

begin_function_decl
specifier|extern
name|pointer
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_comment
comment|/*  * Default files to read. Taken from Taylor compile-time configuration.  * def_logs must look like an argvec, hence the dummy argv[0].  * Maybe later modified by scanning the config  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|def_logs
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|I_conf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to config lib given by -I option */
end_comment

begin_decl_stmt
name|char
modifier|*
name|D_conf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to config lib from makefile */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Tlog
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to Log-file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Tstat
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to Stats-file */
end_comment

begin_decl_stmt
name|char
name|Pgm_name
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our pgm-name */
end_comment

begin_decl_stmt
name|char
name|logline
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input area */
end_comment

begin_decl_stmt
name|char
name|noConf
index|[]
init|=
literal|"- not defined -"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buff
index|[
literal|16
operator|*
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sbuff
index|[
literal|2
operator|*
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Boolean switches for various decisions  */
end_comment

begin_decl_stmt
name|int
name|p_done
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: start date/time of file printed */
end_comment

begin_decl_stmt
name|int
name|hdr_done
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: report header printed */
end_comment

begin_decl_stmt
name|int
name|show_files
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -f option given */
end_comment

begin_decl_stmt
name|int
name|show_calls
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -c option given */
end_comment

begin_decl_stmt
name|int
name|show_commands
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -x option given */
end_comment

begin_decl_stmt
name|int
name|show_efficiency
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -e option given */
end_comment

begin_decl_stmt
name|int
name|show_all
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -t option given */
end_comment

begin_decl_stmt
name|int
name|show_proto
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -p option given */
end_comment

begin_decl_stmt
name|int
name|use_stdin
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -i option given */
end_comment

begin_decl_stmt
name|int
name|be_quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: -q option given */
end_comment

begin_decl_stmt
name|int
name|have_files
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: [IN] or [OUT] files found */
end_comment

begin_decl_stmt
name|int
name|have_calls
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: in/out calls found */
end_comment

begin_decl_stmt
name|int
name|have_commands
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: found uuxqt records */
end_comment

begin_decl_stmt
name|int
name|have_proto
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE: protocol data found */
end_comment

begin_decl_stmt
name|int
name|no_records
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FALSE: got one record from file */
end_comment

begin_comment
comment|/*  * protos  */
end_comment

begin_function_decl
specifier|static
name|pointer
modifier|*
name|getmem
parameter_list|(
name|unsigned
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inc_cmd
parameter_list|(
name|struct
name|Execution_Command
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtime
parameter_list|(
name|double
name|sec
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmbytes
parameter_list|(
name|unsigned
name|long
name|n
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chk_config
parameter_list|(
name|char
modifier|*
name|conf
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdrprt
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|bot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|Protocol_Summary
modifier|*
name|prot_sum
parameter_list|(
name|struct
name|Protocol_Summary
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * BEGIN EXECUTION  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|Log
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|stt
decl_stmt|,
modifier|*
name|flq
init|=
name|NULL
decl_stmt|;
name|char
name|Hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* def taken from<sys/param.h> */
name|char
name|Filename
index|[
literal|15
index|]
decl_stmt|;
comment|/* filename to be printed */
name|char
name|in_date
index|[
literal|14
index|]
decl_stmt|;
comment|/* holds the date info of record read*/
name|char
name|in_time
index|[
literal|14
index|]
decl_stmt|;
comment|/* holds the time info of record read */
name|char
name|dt_info
index|[
literal|31
index|]
decl_stmt|;
comment|/* holds the date info from the last record read */
name|char
modifier|*
name|logmsg
decl_stmt|;
name|int
name|sent
decl_stmt|,
name|called
init|=
name|IN
decl_stmt|;
name|int
name|report
init|=
literal|0
decl_stmt|;
comment|/* if<= 0 give msg that no report was avail. */
name|int
name|junk
decl_stmt|;
comment|/* --------------------------------------------------------------------    *           P r o l o g    * --------------------------------------------------------------------    */
name|Hostname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|have_files
index|[
name|IN
index|]
operator|=
name|have_files
index|[
name|OUT
index|]
operator|=
name|FALSE
expr_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|sbuff
argument_list|,
name|_IOFBF
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuff
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * get how we've been called isolate the name from the path    */
if|if
condition|(
operator|(
name|stt
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|Pgm_name
argument_list|,
operator|++
name|stt
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|Pgm_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|def_logs
index|[
literal|0
index|]
operator|=
name|Pgm_name
expr_stmt|;
comment|/*    * I wish the compiler had the #error directive!    */
if|#
directive|if
operator|!
name|HAVE_TAYLOR_LOGGING
operator|&&
operator|!
name|HAVE_V2_LOGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\a%s: (E) %s\n"
argument_list|,
name|Pgm_name
argument_list|,
literal|"Your config of Taylor UUCP is not yet supported."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: (E) %s\n"
argument_list|,
name|Pgm_name
argument_list|,
literal|"Current support is for V2 or TAYLOR logging only."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Run aborted due to errors\n"
argument_list|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    *  get some mem to store the default config name (def's are in    *  policy.h )    */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|NEWCONFIGLIB
argument_list|)
operator|>
literal|1
condition|)
comment|/* defined at compile time */
block|{
name|D_conf
operator|=
operator|(
name|char
operator|*
operator|)
name|getmem
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|NEWCONFIGLIB
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"/config"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|D_conf
argument_list|,
name|NEWCONFIGLIB
argument_list|)
expr_stmt|;
comment|/* passed by makefile */
name|strcat
argument_list|(
name|D_conf
argument_list|,
literal|"/config"
argument_list|)
expr_stmt|;
block|}
name|Tlog
operator|=
operator|(
name|char
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
name|LOGFILE
argument_list|)
argument_list|)
expr_stmt|;
name|Tstat
operator|=
operator|(
name|char
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
name|STATFILE
argument_list|)
argument_list|)
expr_stmt|;
name|Tlog
operator|=
name|LOGFILE
expr_stmt|;
name|Tstat
operator|=
name|STATFILE
expr_stmt|;
comment|/*    * Process the command line arguments    */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:s:cfdexaitphv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'h'
case|:
operator|(
name|void
operator|)
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'s'
case|:
name|strcpy
argument_list|(
name|Hostname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|show_calls
operator|=
name|TRUE
expr_stmt|;
operator|++
name|report
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|printf
argument_list|(
literal|"%s: (I) config-file default: %s\n"
argument_list|,
name|Pgm_name
argument_list|,
name|D_conf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|show_files
operator|=
name|TRUE
expr_stmt|;
operator|++
name|report
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|show_commands
operator|=
name|TRUE
expr_stmt|;
operator|++
name|report
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|show_efficiency
operator|=
name|TRUE
expr_stmt|;
operator|++
name|report
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|show_calls
operator|=
name|show_files
operator|=
name|show_commands
operator|=
name|show_efficiency
operator|=
name|TRUE
expr_stmt|;
name|report
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|use_stdin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|show_all
operator|=
name|TRUE
expr_stmt|;
name|report
operator|=
name|MAXREP
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|show_proto
operator|=
name|TRUE
expr_stmt|;
operator|++
name|report
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|I_conf
operator|=
operator|(
name|char
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|I_conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|be_quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|rcsid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default :
operator|(
name|void
operator|)
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|report
operator|==
literal|0
condition|)
comment|/* no options given */
operator|++
name|report
expr_stmt|;
comment|/* at least summary can be printed */
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|hdrprt
argument_list|(
literal|'i'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print header for environment info */
comment|/*    * Adjust argv and argc to account for the args processed above.    */
name|argc
operator|-=
operator|(
name|optind
operator|-
literal|1
operator|)
expr_stmt|;
name|argv
operator|+=
operator|(
name|optind
operator|-
literal|1
operator|)
expr_stmt|;
comment|/*    * If further args present, Assume rest are logfiles for us to process    * which should be given in pairs (log plus stat) otherwise the results may    * not come out as expected! If no further args are present take input from     * Log and Stat files provided in the compilation environment of Taylor UUCP.     * If -i was given, Log already points to stdin and no file args are accepted.    */
if|if
condition|(
name|use_stdin
condition|)
comment|/* If -i, read from stdin */
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
comment|/* No file arguments allowed */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\a%s: (E) %s\n"
argument_list|,
name|Pgm_name
argument_list|,
literal|"it's not posssible to give file args with '-i'"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|=
literal|2
expr_stmt|;
name|Log
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|puts
argument_list|(
literal|"   Input from stdin; no other files will be used\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
comment|/* file arguments are present */
block|{
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|puts
argument_list|(
literal|"   No defaults used; will use passed file arguments\n"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Read from current logs */
block|{
name|def_logs
index|[
literal|1
index|]
operator|=
name|Tlog
expr_stmt|;
comment|/* prime the */
name|def_logs
index|[
literal|2
index|]
operator|=
name|Tstat
expr_stmt|;
comment|/*   file names */
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"   Config for this run: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|I_conf
operator|!=
name|NULL
condition|)
block|{
name|junk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|I_conf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|chk_config
argument_list|(
name|I_conf
argument_list|,
name|be_quiet
argument_list|,
name|junk
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|8
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|D_conf
operator|!=
name|NULL
condition|)
block|{
name|junk
operator|=
literal|1
expr_stmt|;
comment|/* indicate default (compiled) config */
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|D_conf
argument_list|)
expr_stmt|;
name|chk_config
argument_list|(
name|D_conf
argument_list|,
name|be_quiet
argument_list|,
name|junk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|noConf
argument_list|)
expr_stmt|;
block|}
name|def_logs
index|[
literal|1
index|]
operator|=
name|Tlog
expr_stmt|;
comment|/* final setting of */
name|def_logs
index|[
literal|2
index|]
operator|=
name|Tstat
expr_stmt|;
comment|/*   file names */
name|argv
operator|=
name|def_logs
expr_stmt|;
comment|/* Bash argvec to log/stat files */
name|argc
operator|=
sizeof|sizeof
argument_list|(
name|def_logs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|def_logs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* --------------------------------------------------------------------    *                 MAIN LOGFILE PROCESSING LOOP    * --------------------------------------------------------------------    */
if|if
condition|(
operator|!
name|use_stdin
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
operator|&&
operator|!
name|be_quiet
condition|)
block|{
name|puts
argument_list|(
literal|"   (W) there is only one input file!"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   (W) some reports may not be printed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|hdrprt
argument_list|(
literal|'d'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* give subheaderline  */
block|}
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|use_stdin
operator|&&
operator|(
name|Log
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|setvbuf
argument_list|(
name|Log
argument_list|,
name|buff
argument_list|,
name|_IOFBF
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flq
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strncpy
argument_list|(
name|Filename
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Filename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|Filename
argument_list|,
operator|++
name|flq
argument_list|,
sizeof|sizeof
argument_list|(
name|Filename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|in_date
argument_list|,
literal|"   n/a"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|in_time
argument_list|,
literal|"   n/a"
argument_list|)
expr_stmt|;
name|p_done
operator|=
name|FALSE
expr_stmt|;
comment|/* no info printed yet */
name|no_records
operator|=
name|TRUE
expr_stmt|;
comment|/* not read any record yet */
comment|/*      * Read each line of the logfile and collect information      */
while|while
condition|(
name|fgets
argument_list|(
name|logline
argument_list|,
sizeof|sizeof
argument_list|(
name|logline
argument_list|)
argument_list|,
name|Log
argument_list|)
condition|)
block|{
comment|/*          * The host name of the other end of the connection is          * always the second field of the log line, whether we          * are reading a Log file or a Stats file. Set 'p' to          * point to the second field, null-terminated. Skip          * the line if something is funny. V2 and Taylor ar identical          * up to this part. Put out the start/end date of the files read;          */
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|logline
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
continue|continue;
name|no_records
operator|=
name|FALSE
expr_stmt|;
comment|/* got one (usable) record at least */
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|stt
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'('
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_done
operator|&&
operator|!
name|use_stdin
operator|&&
operator|!
name|be_quiet
condition|)
block|{
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|sscanf
argument_list|(
operator|++
name|stt
argument_list|,
literal|"%s%*c%[^.]"
argument_list|,
name|in_date
argument_list|,
name|in_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
if|#
directive|if
name|HAVE_V2_LOGGING
name|sscanf
argument_list|(
operator|++
name|stt
argument_list|,
literal|"%[^-]%*c%[1234567890:]"
argument_list|,
name|in_date
argument_list|,
name|in_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
name|printf
argument_list|(
literal|"   %-14s %10s %8s"
argument_list|,
name|Filename
argument_list|,
name|in_date
argument_list|,
name|in_time
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|in_date
argument_list|,
literal|"   n/a"
argument_list|)
expr_stmt|;
comment|/* reset to default */
name|strcpy
argument_list|(
name|in_time
argument_list|,
literal|"   n/a"
argument_list|)
expr_stmt|;
name|p_done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|use_stdin
operator|&&
operator|!
name|be_quiet
condition|)
comment|/* save for last time stamp prt. */
name|strncpy
argument_list|(
name|dt_info
argument_list|,
operator|++
name|stt
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NULL
operator|!=
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/*          * Skip this line if we got -s<host> and          * this line does not contain that host name.          * Don't skip the `incoming call' line with the system name `-'.          */
if|if
condition|(
name|Hostname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
literal|0
operator|!=
name|strcmp
argument_list|(
name|p
argument_list|,
name|Hostname
argument_list|)
condition|)
continue|continue;
comment|/*          * We are within a call block now. If this line is a file          * transfer record, determine the direction. If not then          * skip the line if it is not interesting.          */
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
operator|++
name|s
argument_list|,
literal|')'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|#
directive|if
operator|!
name|HAVE_TAYLOR_LOGGING
if|#
directive|if
name|HAVE_V2_LOGGING
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|") ("
argument_list|,
literal|3
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* are we in stats file ?) */
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
operator|++
name|s
argument_list|,
literal|')'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* yes but strange layout */
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_LOGGING  */
name|logmsg
operator|=
name|s
operator|+
literal|2
expr_stmt|;
comment|/* Message is 2 characters after ')' */
if|if
condition|(
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Call complete"
argument_list|,
literal|13
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Calling system"
argument_list|,
literal|14
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Incoming call"
argument_list|,
literal|13
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Handshake successful"
argument_list|,
literal|20
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Retry time not"
argument_list|,
literal|14
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"ERROR: All matching ports"
argument_list|,
literal|25
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Executing"
argument_list|,
literal|9
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Protocol "
argument_list|,
literal|9
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"sent "
argument_list|,
literal|5
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"received "
argument_list|,
literal|9
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"failed after "
argument_list|,
literal|13
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Errors: "
argument_list|,
literal|8
argument_list|)
operator|)
condition|)
continue|continue;
comment|/*          * Find the Host_entry for this host, or create a new          * one and link it on to the list.          */
if|if
condition|(
operator|(
name|cur
operator|==
name|NULL
operator|)
operator|||
operator|(
literal|0
operator|!=
name|strcmp
argument_list|(
name|p
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|)
operator|)
condition|)
block|{
name|struct
name|Host_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|last
decl_stmt|;
for|for
control|(
name|e
operator|=
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|e
operator|=
name|cur
operator|,
name|cur
operator|=
name|cur
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|cur
operator|->
name|Hostname
argument_list|,
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|cur
operator|=
operator|(
expr|struct
name|Host_entry
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cur
operator|->
name|Hostname
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts
operator|==
name|NULL
condition|)
name|e
operator|=
name|hosts
operator|=
name|cur
expr_stmt|;
else|else
block|{
name|e
operator|=
name|hosts
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|e
operator|->
name|Hostname
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|next
operator|=
name|cur
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|next
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|hosts
operator|=
name|cur
expr_stmt|;
else|else
name|last
operator|->
name|next
operator|=
name|cur
expr_stmt|;
break|break;
block|}
block|}
comment|/*  while (e != NULL) */
block|}
comment|/*  hosts == NULL  */
block|}
comment|/* cur == NULL */
block|}
comment|/*          * OK, if this is a uuxqt record, find the Execution_Command          * structure for the command being executed, or create a new          * one. Then count an execution of this command.          * (Log file only)          */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Executing"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|logmsg
argument_list|,
literal|'('
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|s
operator|=
name|strpbrk
argument_list|(
operator|++
name|p
argument_list|,
literal|" )"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|inc_cmd
argument_list|(
operator|&
name|cur
operator|->
name|cmds
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inc_cmd
argument_list|(
operator|&
name|t_cmds
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|have_commands
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/*          * Count start of outgoing call.          */
if|if
condition|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Calling system"
argument_list|,
literal|14
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Retry time not"
argument_list|,
literal|14
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"ERROR: All matching ports"
argument_list|,
literal|25
argument_list|)
operator|)
condition|)
block|{
name|called
operator|=
name|OUT
expr_stmt|;
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
operator|++
expr_stmt|;
name|have_calls
operator|=
name|TRUE
expr_stmt|;
name|s_prot
operator|=
name|NULL
expr_stmt|;
comment|/* destroy pointer to protocol */
continue|continue;
block|}
comment|/*          * Count start of incoming call.          */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Incoming call"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|called
operator|=
name|IN
expr_stmt|;
name|s_prot
operator|=
name|NULL
expr_stmt|;
comment|/* destroy pointer to protocol */
continue|continue;
block|}
comment|/*          * On an incoming call, get system name from the second line.          * Get protocol type and size/window too          */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Handshake successful"
argument_list|,
literal|20
argument_list|)
condition|)
block|{
if|if
condition|(
name|called
operator|==
name|IN
condition|)
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
operator|++
expr_stmt|;
name|have_calls
operator|=
name|TRUE
expr_stmt|;
name|s_prot
operator|=
name|NULL
expr_stmt|;
comment|/* destroy pointer to protocol */
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|logmsg
argument_list|,
literal|'('
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"(protocol "
argument_list|,
literal|10
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
continue|continue;
name|ss_prot
operator|=
name|prot_sum
argument_list|(
operator|&
name|cur
operator|->
name|proto
argument_list|,
operator|++
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s_prot
operator|=
name|prot_sum
argument_list|(
operator|&
name|t_prot
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/*          * check protocol type and get stats          *          */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Protocol "
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|s_prot
operator|=
name|NULL
expr_stmt|;
comment|/* destroy pointer to protocol */
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|logmsg
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
continue|continue;
name|ss_prot
operator|=
name|prot_sum
argument_list|(
operator|&
name|cur
operator|->
name|proto
argument_list|,
operator|++
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s_prot
operator|=
name|prot_sum
argument_list|(
operator|&
name|t_prot
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          * check protocol errors. Unfortunately the line does not contain          * the used protocol, so if any previous line did contain that          * information and we did process that line we will save the pointer          * to that particular segment into s_prot. If this pointer is not set          * the error info is lost for we don't know where to store.          *          */
if|if
condition|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Errors: header"
argument_list|,
literal|14
argument_list|)
operator|)
operator|&&
name|s_prot
operator|!=
name|NULL
condition|)
block|{
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|i3
decl_stmt|,
name|i4
init|=
literal|0
decl_stmt|;
name|sscanf
argument_list|(
name|logmsg
argument_list|,
literal|"%*s %*s %d%*c%*s %d%*c%*s %d%*c%*s %*s%*c %d"
argument_list|,
operator|&
name|i1
argument_list|,
operator|&
name|i2
argument_list|,
operator|&
name|i3
argument_list|,
operator|&
name|i4
argument_list|)
expr_stmt|;
name|ss_prot
operator|->
name|pr_eheader
operator|+=
name|i1
expr_stmt|;
name|ss_prot
operator|->
name|pr_echksum
operator|+=
name|i2
expr_stmt|;
name|ss_prot
operator|->
name|pr_eorder
operator|+=
name|i3
expr_stmt|;
name|ss_prot
operator|->
name|pr_ereject
operator|+=
name|i4
expr_stmt|;
name|s_prot
operator|->
name|pr_eheader
operator|+=
name|i1
expr_stmt|;
name|s_prot
operator|->
name|pr_echksum
operator|+=
name|i2
expr_stmt|;
name|s_prot
operator|->
name|pr_eorder
operator|+=
name|i3
expr_stmt|;
name|s_prot
operator|->
name|pr_ereject
operator|+=
name|i4
expr_stmt|;
name|s_prot
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/*          * Handle end of call. Pick up the connect time.          * position is on the closing paren of date/time info          * i.e: ) text....            */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"Call complete"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|cur
operator|->
name|call
index|[
name|called
index|]
operator|.
name|succs
operator|++
expr_stmt|;
name|s_prot
operator|=
name|NULL
expr_stmt|;
comment|/* destroy pointer to protocol */
if|if
condition|(
name|NULL
operator|==
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|logmsg
argument_list|,
literal|'('
argument_list|)
operator|)
condition|)
continue|continue;
name|cur
operator|->
name|call
index|[
name|called
index|]
operator|.
name|connect_time
operator|+=
name|atof
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          * We are definitely in a Stats file now.          * If we reached here, this must have been a file transfer          * record. Count it in the field corresponding to the          * direction of the transfer. Count bytes transferred and          * the time to transfer as well.          * Position within the record is at the word 'received' or 'sent'          * depending on the direction.          */
name|sent
operator|=
name|IN
expr_stmt|;
comment|/* give it an initial value */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"failed after "
argument_list|,
literal|13
argument_list|)
condition|)
name|logmsg
operator|+=
literal|13
expr_stmt|;
comment|/* the transmission failed for any reason */
comment|/* so advance pointer */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"sent"
argument_list|,
literal|4
argument_list|)
condition|)
name|sent
operator|=
name|OUT
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|logmsg
argument_list|,
literal|"received"
argument_list|,
literal|8
argument_list|)
condition|)
name|sent
operator|=
name|IN
expr_stmt|;
name|have_files
index|[
name|sent
index|]
operator|=
name|TRUE
expr_stmt|;
name|cur
operator|->
name|call
index|[
name|called
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|files
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|logmsg
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
comment|/* point past keyword */
continue|continue;
comment|/* nothing follows */
comment|/* we should be at the bytes column now*/
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|cur
operator|->
name|call
index|[
name|called
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|bytes
operator|+=
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
if|#
directive|if
name|HAVE_V2_LOGGING
if|if
condition|(
name|NULL
operator|==
operator|(
name|s
operator|=
name|strpbrk
argument_list|(
name|s
argument_list|,
literal|"0123456789"
argument_list|)
operator|)
condition|)
comment|/* point to # bytes */
continue|continue;
name|cur
operator|->
name|call
index|[
name|called
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|bytes
operator|+=
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
if|if
condition|(
name|NULL
operator|==
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
comment|/* point past # of bytes */
continue|continue;
if|if
condition|(
name|NULL
operator|==
operator|(
name|s
operator|=
name|strpbrk
argument_list|(
name|s
argument_list|,
literal|"0123456789"
argument_list|)
operator|)
condition|)
comment|/* point to # of seconds */
continue|continue;
name|cur
operator|->
name|call
index|[
name|called
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|time
operator|+=
name|atof
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* end of while (fgets(logline...)) */
if|if
condition|(
name|stt
operator|!=
name|NULL
operator|&&
operator|!
name|use_stdin
operator|&&
operator|!
name|be_quiet
operator|&&
operator|!
name|no_records
condition|)
block|{
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|sscanf
argument_list|(
name|dt_info
argument_list|,
literal|"%s%*c%[^.]"
argument_list|,
name|in_date
argument_list|,
name|in_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
if|#
directive|if
name|HAVE_V2_LOGGING
name|sscanf
argument_list|(
name|dt_info
argument_list|,
literal|"%[^-]%*c%[1234567890:]"
argument_list|,
name|in_date
argument_list|,
name|in_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
name|printf
argument_list|(
literal|"  %10s %8s\n"
argument_list|,
name|in_date
argument_list|,
name|in_time
argument_list|)
expr_stmt|;
name|p_done
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|Log
operator|!=
name|stdin
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|ferror
argument_list|(
name|Log
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"   %-14s data is incomplete; read error"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (W) data is incomplete; read error on %s\n"
argument_list|,
name|Pgm_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|be_quiet
operator|&&
name|no_records
condition|)
name|printf
argument_list|(
literal|"   %-14s %10s\n"
argument_list|,
name|Filename
argument_list|,
literal|" is empty "
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|Log
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
comment|/* end of while (for (argv ....) */
comment|/*    *   do we have *any* data ?    */
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|puts
argument_list|(
literal|"\n(I) Sorry! No data is available for any requested report\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*    *   truncate hostname, alloc the structure holding the totals and    *   collect the totals data    */
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|cur
operator|->
name|Hostname
index|[
name|MAXDNAME
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
comment|/* last so will have to alloc totals */
block|{
name|cur
operator|->
name|next
operator|=
operator|(
expr|struct
name|Host_entry
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cur
operator|->
name|next
operator|->
name|Hostname
argument_list|,
literal|"Totals"
argument_list|)
expr_stmt|;
name|tot
operator|=
name|cur
operator|->
name|next
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|next
operator|!=
name|NULL
condition|)
comment|/* don't count totals to totals */
block|{
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|bytes
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|bytes
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|bytes
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|bytes
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|bytes
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|bytes
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|bytes
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|bytes
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|succs
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|succs
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|connect_time
operator|+=
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|connect_time
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|succs
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|succs
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
expr_stmt|;
name|tot
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|connect_time
operator|+=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|connect_time
expr_stmt|;
block|}
block|}
break|break;
comment|/* totals is last in Host_Entry */
block|}
block|}
comment|/*    *                       ***********    *                       * REPORTS *    *                       ***********    */
if|#
directive|if
name|_DEBUG_
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ------------------------------------------------------------------    *    * Summary report only when no other report except option -t is given    *    * I know, this code could be tightened (rbd)...    * ------------------------------------------------------------------    */
if|if
condition|(
operator|!
operator|(
name|show_calls
operator|||
name|show_files
operator|||
name|show_efficiency
operator|||
name|show_commands
operator|||
name|show_proto
operator|)
operator|||
name|show_all
condition|)
block|{
if|if
condition|(
name|have_calls
operator|||
name|have_files
index|[
name|IN
index|]
operator|||
name|have_files
index|[
name|OUT
index|]
condition|)
block|{
name|char
name|t1
index|[
literal|32
index|]
decl_stmt|,
name|t2
index|[
literal|32
index|]
decl_stmt|,
name|t3
index|[
literal|32
index|]
decl_stmt|,
name|t4
index|[
literal|32
index|]
decl_stmt|,
name|t5
index|[
literal|32
index|]
decl_stmt|;
name|long
name|ib
decl_stmt|,
name|ob
decl_stmt|,
name|b
decl_stmt|,
name|rf
decl_stmt|,
name|sf
decl_stmt|;
name|double
name|it
decl_stmt|,
name|ot
decl_stmt|,
name|ir
decl_stmt|,
name|or
decl_stmt|;
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|ib
operator|=
operator|(
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|bytes
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|bytes
operator|)
expr_stmt|;
name|fmbytes
argument_list|(
name|ib
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|ob
operator|=
operator|(
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|bytes
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|bytes
operator|)
expr_stmt|;
name|fmbytes
argument_list|(
name|ob
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* Don't print null-lines. */
if|if
condition|(
operator|(
name|b
operator|=
name|ib
operator|+
name|ob
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Don't print the header twice. */
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|hdrprt
argument_list|(
literal|'s'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print the header line(s) */
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
name|fmbytes
argument_list|(
name|b
argument_list|,
name|t3
argument_list|)
expr_stmt|;
name|it
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
expr_stmt|;
name|fmtime
argument_list|(
name|it
argument_list|,
name|t4
argument_list|)
expr_stmt|;
name|ot
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
expr_stmt|;
name|fmtime
argument_list|(
name|ot
argument_list|,
name|t5
argument_list|)
expr_stmt|;
name|rf
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
expr_stmt|;
name|sf
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
expr_stmt|;
name|ir
operator|=
operator|(
name|it
operator|==
literal|0.0
operator|)
condition|?
literal|0.0
else|:
operator|(
name|ib
operator|/
name|it
operator|)
expr_stmt|;
name|or
operator|=
operator|(
name|ot
operator|==
literal|0.0
operator|)
condition|?
literal|0.0
else|:
operator|(
name|ob
operator|/
name|ot
operator|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
comment|/* totals line reached ? */
name|hdrprt
argument_list|(
literal|'s'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* print the separator line */
name|printf
argument_list|(
literal|"%-8s %4d %4d %9s %9s %9s %9s %9s %5.0f %5.0f\n"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|,
name|rf
argument_list|,
name|sf
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|,
name|t4
argument_list|,
name|t5
argument_list|,
name|ir
argument_list|,
name|or
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|puts
argument_list|(
literal|"\n(I) No data found to print Compact summary report"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\n(I) No data available for Compact summary report"
argument_list|)
expr_stmt|;
operator|--
name|report
expr_stmt|;
block|}
block|}
comment|/* ------------------------------------------------------------------    *                     Protocol statistics report    * ------------------------------------------------------------------    */
if|if
condition|(
name|show_proto
operator|||
name|show_all
condition|)
block|{
if|if
condition|(
name|have_proto
condition|)
block|{
comment|/* ---------------------  */
comment|/* protocol packet report */
comment|/* ---------------------  */
name|char
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|type
operator|=
name|cur
operator|->
name|Hostname
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hdr_done
condition|)
name|puts
argument_list|(
literal|"-------------------------------------------------------------------"
argument_list|)
expr_stmt|;
name|cur
operator|->
name|proto
operator|=
name|t_prot
expr_stmt|;
block|}
for|for
control|(
name|prot
operator|=
name|cur
operator|->
name|proto
init|;
name|prot
operator|!=
name|NULL
condition|;
name|prot
operator|=
name|prot
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|hdrprt
argument_list|(
literal|'p'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print the header line(s) */
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%-8s %3s  %4d %4d %5d %4d    %10d %7d %10d\n"
argument_list|,
name|type
operator|==
name|NULL
condition|?
literal|" "
else|:
name|cur
operator|->
name|Hostname
argument_list|,
name|prot
operator|->
name|type
argument_list|,
name|prot
operator|->
name|pr_psizemin
argument_list|,
name|prot
operator|->
name|pr_psizemax
argument_list|,
name|prot
operator|->
name|pr_pwinmin
argument_list|,
name|prot
operator|->
name|pr_pwinmax
argument_list|,
name|prot
operator|->
name|pr_psent
argument_list|,
name|prot
operator|->
name|pr_present
argument_list|,
name|prot
operator|->
name|pr_preceived
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hdr_done
condition|)
name|puts
argument_list|(
literal|"\n(I) No data found to print Protocol packet report"
argument_list|)
expr_stmt|;
comment|/* --------------------- */
comment|/* protocol error report */
comment|/* --------------------- */
name|type
operator|=
name|NULL
expr_stmt|;
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|t_prot
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|type
operator|=
name|cur
operator|->
name|Hostname
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hdr_done
condition|)
name|puts
argument_list|(
literal|"--------------------------------------------------------------"
argument_list|)
expr_stmt|;
name|cur
operator|->
name|proto
operator|=
name|t_prot
expr_stmt|;
block|}
for|for
control|(
name|prot
operator|=
name|cur
operator|->
name|proto
init|;
name|prot
operator|!=
name|NULL
condition|;
name|prot
operator|=
name|prot
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|prot
operator|->
name|pr_eheader
operator|+
name|prot
operator|->
name|pr_echksum
operator|+
name|prot
operator|->
name|pr_eorder
operator|+
name|prot
operator|->
name|pr_ereject
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|hdrprt
argument_list|(
literal|'p'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* print the header line(s) */
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%-8s %3s  %11d %11d  %11d %11d\n"
argument_list|,
name|type
operator|==
name|NULL
condition|?
literal|" "
else|:
name|cur
operator|->
name|Hostname
argument_list|,
name|prot
operator|->
name|type
argument_list|,
name|prot
operator|->
name|pr_eheader
argument_list|,
name|prot
operator|->
name|pr_echksum
argument_list|,
name|prot
operator|->
name|pr_eorder
argument_list|,
name|prot
operator|->
name|pr_ereject
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|hdr_done
condition|)
name|puts
argument_list|(
literal|"\n(I) No data found to print Protocol error report"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\n(I) No data available for Protocol reports"
argument_list|)
expr_stmt|;
operator|--
name|report
expr_stmt|;
block|}
block|}
comment|/* ------------------------------------------------------------------    *                     Call statistics report    * ------------------------------------------------------------------    */
if|if
condition|(
name|show_calls
operator|||
name|show_all
condition|)
block|{
if|if
condition|(
name|have_calls
condition|)
block|{
name|char
name|t1
index|[
literal|32
index|]
decl_stmt|,
name|t2
index|[
literal|32
index|]
decl_stmt|;
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hdr_done
condition|)
name|hdrprt
argument_list|(
literal|'c'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* print the separator line */
block|}
else|else
block|{
comment|/* Don't print null-lines on deatail lines */
if|if
condition|(
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
operator|+
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
operator|==
literal|0
condition|)
continue|continue;
comment|/* Don't print the header twice. */
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|hdrprt
argument_list|(
literal|'c'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print the header line(s) */
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
operator|>
literal|0
operator|||
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|fmtime
argument_list|(
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|connect_time
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   %-8s %7d %7d %7d %9s"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|,
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|succs
argument_list|,
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
operator|-
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|succs
argument_list|,
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|calls
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"   %-42s"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
operator|>
literal|0
operator|||
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|fmtime
argument_list|(
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|connect_time
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %7d %7d %7d %9s"
argument_list|,
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|succs
argument_list|,
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
operator|-
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|succs
argument_list|,
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|calls
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|puts
argument_list|(
literal|"\n(I) No data found to print Call statistics report"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\n(I) No data available for Call statistics report"
argument_list|)
expr_stmt|;
operator|--
name|report
expr_stmt|;
block|}
block|}
comment|/* ------------------------------------------------------------------    *                    File statistics report    * ------------------------------------------------------------------    */
if|if
condition|(
name|show_files
operator|||
name|show_all
condition|)
block|{
if|if
condition|(
name|have_files
index|[
name|IN
index|]
operator|||
name|have_files
index|[
name|OUT
index|]
condition|)
block|{
name|char
name|t1
index|[
literal|32
index|]
decl_stmt|,
name|t2
index|[
literal|32
index|]
decl_stmt|;
name|double
name|rate
init|=
literal|0
decl_stmt|,
name|time
init|=
literal|0
decl_stmt|;
name|int
name|b
init|=
literal|0
decl_stmt|;
name|int
name|lineOut
init|=
literal|0
decl_stmt|;
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|lineOut
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sent
operator|=
name|IN
init|;
name|sent
operator|<=
name|OUT
condition|;
operator|++
name|sent
control|)
block|{
name|b
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|bytes
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|bytes
expr_stmt|;
name|time
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|time
expr_stmt|;
comment|/* Don't print null-lines on detail lines. */
if|if
condition|(
operator|(
name|b
operator|!=
literal|0
operator|&&
name|time
operator|!=
literal|0.0
operator|)
operator|||
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* Don't print the header twice. */
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|hdrprt
argument_list|(
literal|'f'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print the header line(s) */
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
name|fmbytes
argument_list|(
name|b
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|rate
operator|=
operator|(
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|bytes
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|bytes
operator|)
operator|/
name|time
expr_stmt|;
name|fmtime
argument_list|(
operator|(
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|time
operator|)
argument_list|,
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineOut
operator|==
literal|0
condition|)
comment|/* first half not printed yet ? */
block|{
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
comment|/* totals line ? */
name|hdrprt
argument_list|(
literal|'f'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* print the separator line */
name|printf
argument_list|(
literal|"   %-8s"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
operator|==
name|OUT
condition|)
comment|/* can't happen whith totals line */
name|printf
argument_list|(
literal|"%34s"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %5d %11s %9s %5.0f"
argument_list|,
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|files
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|sent
index|]
operator|.
name|files
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|lineOut
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* end:  for (sent ... ) */
if|if
condition|(
name|lineOut
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* end:  for (cur= ... ) */
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|puts
argument_list|(
literal|"\n(I) No data found to print File statistics report"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\n(I) No data available for File statistics report"
argument_list|)
expr_stmt|;
operator|--
name|report
expr_stmt|;
block|}
block|}
comment|/* ------------------------------------------------------------------    *                       Efficiency report    * ------------------------------------------------------------------    */
if|if
condition|(
name|show_efficiency
operator|||
name|show_all
condition|)
block|{
if|if
condition|(
name|have_files
index|[
name|IN
index|]
operator|||
name|have_files
index|[
name|OUT
index|]
condition|)
block|{
name|char
name|t1
index|[
literal|32
index|]
decl_stmt|,
name|t2
index|[
literal|32
index|]
decl_stmt|,
name|t3
index|[
literal|32
index|]
decl_stmt|;
name|double
name|total
decl_stmt|,
name|flow
decl_stmt|;
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
comment|/* Don't print null-lines. */
if|if
condition|(
literal|0
operator|==
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
operator|+
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|files
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|files
operator|||
literal|0.0
operator|==
operator|(
name|total
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|connect_time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|connect_time
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|hdrprt
argument_list|(
literal|'e'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print the header line(s) */
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
name|flow
operator|=
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|IN
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|IN
index|]
operator|.
name|time
operator|+
name|cur
operator|->
name|call
index|[
name|OUT
index|]
operator|.
name|flow
index|[
name|OUT
index|]
operator|.
name|time
expr_stmt|;
name|fmtime
argument_list|(
name|total
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|fmtime
argument_list|(
name|flow
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|fmtime
argument_list|(
name|total
operator|-
name|flow
argument_list|,
name|t3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
name|hdrprt
argument_list|(
literal|'e'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* print the separator line */
name|printf
argument_list|(
literal|"   %-8s %10s %10s %10s %7.2f\n"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|,
name|flow
operator|>=
name|total
condition|?
literal|100.0
else|:
name|flow
operator|*
literal|100.0
operator|/
name|total
argument_list|)
expr_stmt|;
block|}
comment|/* end: for (cur= .. */
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|puts
argument_list|(
literal|"\n(I) No data found to print Efficiency report"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\n(I) No data available for Efficiency report"
argument_list|)
expr_stmt|;
operator|--
name|report
expr_stmt|;
block|}
block|}
comment|/* ------------------------------------------------------------------    *                   Command execution report    * ------------------------------------------------------------------    */
if|if
condition|(
name|show_commands
operator|||
name|show_all
condition|)
block|{
if|if
condition|(
name|have_commands
condition|)
block|{
name|int
name|ncmds
decl_stmt|,
name|i
decl_stmt|,
name|match
decl_stmt|;
comment|/*           *  layout the header line. The column's header is the command name          */
name|hdr_done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ncmds
operator|=
literal|0
operator|,
name|cmd
operator|=
name|t_cmds
init|;
name|cmd
operator|!=
name|NULL
operator|&&
name|ncmds
operator|<=
name|MAXCOLS
operator|-
literal|1
condition|;
name|ncmds
operator|++
operator|,
name|cmd
operator|=
name|cmd
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|puts
argument_list|(
literal|"\nCommand executions:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"-------------------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Name of "
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   site    "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|hdr_done
operator|=
name|TRUE
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %7s"
argument_list|,
name|cmd
operator|->
name|Commandname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hdr_done
condition|)
block|{
name|puts
argument_list|(
literal|"\n(I) No data found to print Command execution report"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"\n   --------"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmds
condition|;
name|i
operator|++
control|)
name|fputs
argument_list|(
literal|"  ------"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/*           *  print out the number of executions for each host/command          */
for|for
control|(
name|cur
operator|=
name|hosts
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|next
operator|==
name|NULL
condition|)
break|break;
comment|/* Don't print null-lines. */
if|if
condition|(
name|cur
operator|->
name|cmds
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"   %-8s"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|)
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|t_cmds
init|;
name|cmd
operator|!=
name|NULL
condition|;
name|cmd
operator|=
name|cmd
operator|->
name|next
control|)
block|{
name|struct
name|Execution_Command
modifier|*
name|ec
decl_stmt|;
name|match
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ec
operator|=
name|cur
operator|->
name|cmds
init|;
name|ec
operator|!=
name|NULL
condition|;
name|ec
operator|=
name|ec
operator|->
name|next
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|cmd
operator|->
name|Commandname
argument_list|,
name|ec
operator|->
name|Commandname
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" %7d"
argument_list|,
name|ec
operator|->
name|count
argument_list|)
expr_stmt|;
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|printf
argument_list|(
literal|"%8s"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* blank out column */
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/*           *  print the totals line            */
name|fputs
argument_list|(
literal|"   --------"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmds
condition|;
name|i
operator|++
control|)
name|fputs
argument_list|(
literal|"--------"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n   %-8s"
argument_list|,
name|cur
operator|->
name|Hostname
argument_list|)
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|t_cmds
init|;
name|cmd
operator|!=
name|NULL
condition|;
name|cmd
operator|=
name|cmd
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|" %7d"
argument_list|,
name|cmd
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\n(I) No data available for Command execution report"
argument_list|)
expr_stmt|;
operator|--
name|report
expr_stmt|;
block|}
block|}
if|if
condition|(
name|report
operator|<=
literal|0
condition|)
comment|/* any reports ? */
block|{
name|puts
argument_list|(
literal|"\n(I) Sorry! No data is available for any requested report\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\n(I) End of reports\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of main */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    *                       * Functions *    * ------------------------------------------------------------------    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    *                    display the help     * ------------------------------------------------------------------    */
end_comment

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage uurate [-acdefhiptvx] [-s hostname] [-I config file] [logfile(s) ... logfile(s)]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"where:\t-a\tPrint reports c,e,f,x\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-c\tReport call statistics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-d\tPrint the name of the default config file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-e\tReport efficiency statistics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-f\tReport file transfer statistics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-h\tPrint this help\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-i\tRead log info from standard input\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-p\tReport protocol statistics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-t\tAll available reports plus compact summary report\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-v\tPrint version number\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-x\tReport command execution statistics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-s host\tReport activities involving HOST only\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-I config Use config instead of standard config file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"If no report options given, a compact summary report is printed.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"log files should be given as pairs that is Log/Stats ... .\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"If neither -i nor logfiles given, those names found in config will be used\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------   *                    getmem - get some memory   * ------------------------------------------------------------------   */
end_comment

begin_function
specifier|static
name|pointer
modifier|*
name|getmem
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|n
decl_stmt|;
block|{
name|pointer
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|n
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\a%s (C) %s\n"
argument_list|,
name|Pgm_name
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------    *             inc_cmd - increment command count    * ------------------------------------------------------------------    */
end_comment

begin_function
specifier|static
name|void
name|inc_cmd
parameter_list|(
name|cmds
parameter_list|,
name|name
parameter_list|)
name|struct
name|Execution_Command
modifier|*
modifier|*
name|cmds
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|Execution_Command
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|ec
decl_stmt|;
for|for
control|(
name|ec
operator|=
name|cmd
operator|=
operator|*
name|cmds
init|;
name|cmd
operator|!=
name|NULL
condition|;
name|ec
operator|=
name|cmd
operator|,
name|cmd
operator|=
name|cmd
operator|->
name|next
operator|,
name|cnt
operator|++
control|)
if|if
condition|(
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|cmd
operator|->
name|Commandname
argument_list|,
name|name
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|cmd
operator|->
name|Commandname
argument_list|,
literal|"Misc."
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|cmd
operator|=
operator|(
expr|struct
name|Execution_Command
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
name|MAXCOLS
operator|-
literal|1
condition|)
comment|/* first col prints site name therefore< max-1 */
block|{
name|strcpy
argument_list|(
name|cmd
operator|->
name|Commandname
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cmds
operator|==
name|NULL
condition|)
name|ec
operator|=
operator|*
name|cmds
operator|=
name|cmd
expr_stmt|;
else|else
name|ec
operator|->
name|next
operator|=
name|cmd
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|ec
operator|->
name|Commandname
argument_list|,
literal|"Misc."
argument_list|)
expr_stmt|;
comment|/* reached high-water-mark */
name|cmd
operator|=
name|ec
expr_stmt|;
comment|/* backtrack */
block|}
block|}
name|cmd
operator|->
name|count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------    *             prot_sum - collect protocol data    * ------------------------------------------------------------------    */
end_comment

begin_function
name|struct
name|Protocol_Summary
modifier|*
name|prot_sum
parameter_list|(
name|proto
parameter_list|,
name|ptype
parameter_list|,
name|ind
parameter_list|)
name|struct
name|Protocol_Summary
modifier|*
modifier|*
name|proto
decl_stmt|;
name|char
modifier|*
name|ptype
decl_stmt|;
name|int
name|ind
decl_stmt|;
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|i3
init|=
literal|0
decl_stmt|;
name|struct
name|Protocol_Summary
modifier|*
name|cur
decl_stmt|,
modifier|*
name|first
decl_stmt|;
for|for
control|(
name|first
operator|=
name|cur
operator|=
operator|*
name|proto
init|;
name|cur
operator|!=
name|NULL
condition|;
name|first
operator|=
name|cur
operator|,
name|cur
operator|=
name|cur
operator|->
name|next
operator|,
name|cnt
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|cur
operator|->
name|type
argument_list|,
name|ptype
argument_list|,
name|strlen
argument_list|(
name|cur
operator|->
name|type
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|cur
operator|=
operator|(
expr|struct
name|Protocol_Summary
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|ptype
argument_list|,
literal|"%[^\' ]3"
argument_list|,
name|cur
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|==
name|NULL
condition|)
name|first
operator|=
operator|*
name|proto
operator|=
name|cur
expr_stmt|;
else|else
name|first
operator|->
name|next
operator|=
name|cur
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
operator|(
name|ptype
operator|=
name|strchr
argument_list|(
name|ptype
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cur
operator|->
name|pr_cnt
operator|++
expr_stmt|;
name|have_proto
operator|=
name|TRUE
expr_stmt|;
operator|++
name|ptype
expr_stmt|;
switch|switch
condition|(
name|ind
condition|)
block|{
case|case
literal|1
case|:
comment|/* used protocol line */
comment|/*    * uucp-1.04 format: .... packet size ssss window ww)    * uucp-1.05 format: .... remote packet/window ssss/ww local ssss/ww)    *           (the remote packet/window will be used!)    */
name|i1
operator|=
name|i2
operator|=
literal|0
expr_stmt|;
comment|/* reset */
if|if
condition|(
name|NULL
operator|==
operator|(
name|strchr
argument_list|(
name|ptype
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|sscanf
argument_list|(
name|ptype
argument_list|,
literal|"%*s %*s %d %*s %d"
argument_list|,
operator|&
name|i1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
else|else
name|sscanf
argument_list|(
name|ptype
argument_list|,
literal|"%*s %*s %d/%d"
argument_list|,
operator|&
name|i1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|>
name|cur
operator|->
name|pr_psizemax
condition|)
name|cur
operator|->
name|pr_psizemax
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|i1
operator|<
name|cur
operator|->
name|pr_psizemin
operator|||
name|cur
operator|->
name|pr_psizemin
operator|==
literal|0
condition|)
name|cur
operator|->
name|pr_psizemin
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|i2
operator|>
name|cur
operator|->
name|pr_pwinmax
condition|)
name|cur
operator|->
name|pr_pwinmax
operator|=
name|i2
expr_stmt|;
if|if
condition|(
name|i2
operator|<
name|cur
operator|->
name|pr_pwinmin
operator|||
name|cur
operator|->
name|pr_pwinmin
operator|==
literal|0
condition|)
name|cur
operator|->
name|pr_pwinmin
operator|=
name|i2
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* protocol statistics line */
name|i1
operator|=
name|i2
operator|=
name|i3
operator|=
literal|0
expr_stmt|;
comment|/* reset */
name|sscanf
argument_list|(
name|ptype
argument_list|,
literal|"%*s %*s %d%*c %*s %d%*c %*s %d"
argument_list|,
operator|&
name|i1
argument_list|,
operator|&
name|i2
argument_list|,
operator|&
name|i3
argument_list|)
expr_stmt|;
name|cur
operator|->
name|pr_psent
operator|+=
name|i1
expr_stmt|;
name|cur
operator|->
name|pr_present
operator|+=
name|i2
expr_stmt|;
name|cur
operator|->
name|pr_preceived
operator|+=
name|i3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|cur
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------    *           fmtime() - Format time in hours& minutes& seconds;    * ------------------------------------------------------------------    */
end_comment

begin_function
specifier|static
name|void
name|fmtime
parameter_list|(
name|dsec
parameter_list|,
name|buf
parameter_list|)
name|double
name|dsec
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|long
name|hrs
decl_stmt|,
name|min
decl_stmt|,
name|lsec
decl_stmt|;
if|if
condition|(
name|dsec
operator|<=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lsec
operator|=
name|fmod
argument_list|(
name|dsec
operator|+
literal|0.5
argument_list|,
literal|60L
argument_list|)
expr_stmt|;
comment|/* round to the next full second */
name|hrs
operator|=
name|dsec
operator|/
literal|3600L
expr_stmt|;
name|min
operator|=
operator|(
operator|(
name|long
operator|)
name|dsec
operator|/
literal|60L
operator|)
operator|%
literal|60L
expr_stmt|;
if|if
condition|(
name|hrs
operator|==
literal|0
condition|)
if|if
condition|(
name|min
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%6s%2ld"
argument_list|,
literal|" "
argument_list|,
name|lsec
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%3s%2ld:%02ld"
argument_list|,
literal|" "
argument_list|,
name|min
argument_list|,
name|lsec
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%2ld:%02ld:%02ld"
argument_list|,
name|hrs
argument_list|,
name|min
argument_list|,
name|lsec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------    *                 fmbytes - Format size in bytes    * ------------------------------------------------------------------    */
end_comment

begin_function
specifier|static
name|void
name|fmbytes
parameter_list|(
name|n
parameter_list|,
name|buf
parameter_list|)
name|unsigned
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.1f"
argument_list|,
operator|(
name|double
operator|)
name|n
operator|/
literal|1000.0
argument_list|)
expr_stmt|;
comment|/* Display in Kilobytes */
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------    *                 chk_config - Read the config file    *    check on keywords: logfile and statfile. When found override    *    the corresponding default    * ------------------------------------------------------------------    */
end_comment

begin_function
name|int
name|chk_config
parameter_list|(
name|char
modifier|*
name|T_conf
parameter_list|,
name|int
name|be_quiet
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|FILE
modifier|*
name|Conf
decl_stmt|;
name|char
name|keywrd
index|[
literal|9
index|]
decl_stmt|;
name|char
name|name
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|,
modifier|*
name|pos2
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|logf
init|=
name|FALSE
decl_stmt|;
name|int
name|statf
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|Conf
operator|=
name|fopen
argument_list|(
name|T_conf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|be_quiet
condition|)
block|{
name|puts
argument_list|(
literal|"   Could not open config"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"   The run will be aborted\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (E) %s %s \n"
argument_list|,
name|Pgm_name
argument_list|,
literal|"could not open config:"
argument_list|,
name|T_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (W) defaults used for all files\n"
argument_list|,
name|Pgm_name
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (C) ended due to errors\n"
argument_list|,
name|Pgm_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|fgets
argument_list|(
name|logline
argument_list|,
sizeof|sizeof
argument_list|(
name|logline
argument_list|)
argument_list|,
name|Conf
argument_list|)
condition|)
block|{
if|if
condition|(
name|logline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|sscanf
argument_list|(
name|logline
argument_list|,
literal|"%8s %s"
argument_list|,
name|keywrd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|keywrd
argument_list|,
literal|"logfile"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|pos1
operator|=
name|pos2
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<=
name|MAXPATHLEN
operator|&&
operator|*
name|pos1
operator|!=
literal|'\0'
operator|)
condition|;
name|pos1
operator|++
operator|,
name|pos2
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pos1
operator|==
literal|'#'
condition|)
comment|/* name immed followed by comment */
break|break;
if|if
condition|(
operator|*
name|pos1
operator|==
literal|'\\'
condition|)
comment|/* quoted comment (filename has #) */
block|{
operator|++
name|pos1
expr_stmt|;
comment|/* skip escape char */
if|if
condition|(
operator|*
name|pos1
operator|!=
literal|'#'
condition|)
comment|/* continuation ? */
block|{
name|puts
argument_list|(
literal|"   Config error:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Found filename continuation; bailing out\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pos2
operator|=
operator|*
name|pos1
expr_stmt|;
comment|/* move char */
block|}
operator|*
name|pos2
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate string */
name|Tlog
operator|=
operator|(
name|char
operator|*
operator|)
name|getmem
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Tlog
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"   logfile used:        %s\n"
argument_list|,
name|Tlog
argument_list|)
expr_stmt|;
name|logf
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|statf
condition|)
comment|/* statsfile still to come ? */
break|break;
comment|/* no finished */
continue|continue;
block|}
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|keywrd
argument_list|,
literal|"statfile"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|pos1
operator|=
name|pos2
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<=
name|MAXPATHLEN
operator|&&
operator|*
name|pos1
operator|!=
literal|'\0'
operator|)
condition|;
name|pos1
operator|++
operator|,
name|pos2
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pos1
operator|==
literal|'#'
condition|)
comment|/* name immed followed by comment */
break|break;
if|if
condition|(
operator|*
name|pos1
operator|==
literal|'\\'
condition|)
comment|/* quoted comment (filename has #) */
block|{
operator|++
name|pos1
expr_stmt|;
comment|/* skip escape char */
if|if
condition|(
operator|*
name|pos1
operator|!=
literal|'#'
condition|)
comment|/* continuation ? */
block|{
name|puts
argument_list|(
literal|"   Config error:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Found filename continuation; bailing out\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pos2
operator|=
operator|*
name|pos1
expr_stmt|;
comment|/* move char */
block|}
operator|*
name|pos2
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate string */
name|Tstat
operator|=
operator|(
name|char
operator|*
operator|)
name|getmem
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Tstat
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|be_quiet
condition|)
name|printf
argument_list|(
literal|"   statfile used:       %s\n"
argument_list|,
name|Tstat
argument_list|)
expr_stmt|;
name|statf
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|logf
condition|)
comment|/* logfile still to come ? */
break|break;
comment|/* no finished */
continue|continue;
block|}
block|}
name|fclose
argument_list|(
name|Conf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|be_quiet
condition|)
block|{
if|if
condition|(
operator|!
name|logf
condition|)
name|puts
argument_list|(
literal|"   logfile used:        - default -"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|statf
condition|)
name|puts
argument_list|(
literal|"   statfile used:       - default -"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------    *   hdrprt - Print Header/Trailer lines (constant data)    * ------------------------------------------------------------------    */
end_comment

begin_function
specifier|static
name|void
name|hdrprt
parameter_list|(
name|char
name|head
parameter_list|,
name|int
name|bot
parameter_list|)
block|{
switch|switch
condition|(
name|head
condition|)
block|{
case|case
operator|(
literal|'s'
operator|)
case|:
comment|/* standard summary report */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nCompact summary:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"----------------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ Name of  + Files + +------- Bytes/1000 --------+ +------ Time -----+ + Avg CPS +\n\ site       in  out   inbound  outbound     total   inbound  outbound    in   out\n\ -------- ---- ---- --------- --------- --------- --------- --------- ----- -----"
argument_list|)
expr_stmt|;
block|}
else|else
name|puts
argument_list|(
literal|"\ --------------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'f'
operator|)
case|:
comment|/* file statistic report */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nFile statistics:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"----------------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Name of  +----------- Inbound -----------+ +---------- Outbound -----------+"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   site     files  Bytes/1000  xfr time B/sec files  Bytes/1000  xfr time B/sec"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   -------- ----- ----------- --------- ----- ----- ----------- --------- -----"
argument_list|)
expr_stmt|;
block|}
else|else
name|puts
argument_list|(
literal|"\    ----------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'c'
operator|)
case|:
comment|/* calls statistic report */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nCall statistics:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"----------------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Name of   +------- Outbound Calls -------+  +-------- Inbound Calls  ------+"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   site       succ.  failed   total      time   succ.  failed   total      time"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   --------  ------  ------  ------ ---------  ------  ------  ------ ---------"
argument_list|)
expr_stmt|;
block|}
else|else
name|puts
argument_list|(
literal|"\    ----------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'e'
operator|)
case|:
comment|/* efficiency statistic report */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nEfficiency:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"-----------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Name of   +------ Times inbound/outbound -------+"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   site      connected   xfr time   overhead  eff. %"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   --------  ---------  ---------  ---------  ------"
argument_list|)
expr_stmt|;
block|}
else|else
name|puts
argument_list|(
literal|"   -------------------------------------------------"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'i'
operator|)
case|:
comment|/* Environment information */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nEnvironment Information:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"------------------------"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Default config:      %s\n"
argument_list|,
name|D_conf
operator|==
name|NULL
condition|?
name|noConf
else|:
name|D_conf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Default logfile:     %s\n"
argument_list|,
name|Tlog
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Default statfile:    %s\n\n"
argument_list|,
name|Tstat
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
literal|'d'
operator|)
case|:
comment|/* Date/time coverage */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\n   Date coverage of input files:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   Name of        +----- Start -----+  +------ End ------+"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   file                 date     time        date     time"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   --------       ---------- --------  ---------- --------"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
literal|'p'
operator|)
case|:
comment|/* Protocol stats */
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nProtocol packet report:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"-----------------------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"          +------- protocol -----+   +--------- Packets ----------+"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Name of         packet     window "
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"site      typ  min  max   min  max          sent  resent   received"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"--------  --- ---- ----  ---- ----   ----------- ------- ----------"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|puts
argument_list|(
literal|"\nProtocol error report:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"----------------------"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Name of   +----------------- Error Types --------------------+"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"site      typ      header    checksum        order  rem-reject"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"--------  --- -----------  ----------  -----------  ----------"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|bot
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nNo header for this report defined:"
argument_list|)
expr_stmt|;
block|}
else|else
name|puts
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

