begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* statsb.c    System dependent routines for uustat.     Copyright (C) 1992, 1993, 1994 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|statsb_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_OPENDIR
end_if

begin_if
if|#
directive|if
name|HAVE_DIRENT_H
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_OPENDIR */
end_comment

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_UTIME_H
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|issettime
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|z
operator|,
name|time_t
name|inow
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fskill_or_rejuv
name|P
argument_list|(
operator|(
name|pointer
name|puuconf
operator|,
specifier|const
name|char
operator|*
name|zid
operator|,
name|boolean
name|fkill
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Set file access time to the present.  On many systems this could be    done by passing NULL to utime, but on some that doesn't work.  This    routine is not time critical, so we never rely on NULL.  */
end_comment

begin_function
specifier|static
name|int
name|issettime
parameter_list|(
name|z
parameter_list|,
name|inow
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|time_t
name|inow
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_UTIME_H
name|struct
name|utimbuf
name|s
decl_stmt|;
name|s
operator|.
name|actime
operator|=
name|inow
expr_stmt|;
name|s
operator|.
name|modtime
operator|=
name|inow
expr_stmt|;
return|return
name|utime
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z
argument_list|,
operator|&
name|s
argument_list|)
return|;
else|#
directive|else
name|time_t
name|ai
index|[
literal|2
index|]
decl_stmt|;
name|ai
index|[
literal|0
index|]
operator|=
name|inow
expr_stmt|;
name|ai
index|[
literal|1
index|]
operator|=
name|inow
expr_stmt|;
return|return
name|utime
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z
argument_list|,
name|ai
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Kill a job, given the jobid.  */
end_comment

begin_function
name|boolean
name|fsysdep_kill_job
parameter_list|(
name|puuconf
parameter_list|,
name|zid
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zid
decl_stmt|;
block|{
return|return
name|fskill_or_rejuv
argument_list|(
name|puuconf
argument_list|,
name|zid
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rejuvenate a job, given the jobid.  */
end_comment

begin_function
name|boolean
name|fsysdep_rejuvenate_job
parameter_list|(
name|puuconf
parameter_list|,
name|zid
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zid
decl_stmt|;
block|{
return|return
name|fskill_or_rejuv
argument_list|(
name|puuconf
argument_list|,
name|zid
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Kill or rejuvenate a job, given the jobid.  */
end_comment

begin_function
specifier|static
name|boolean
name|fskill_or_rejuv
parameter_list|(
name|puuconf
parameter_list|,
name|zid
parameter_list|,
name|fkill
parameter_list|)
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|char
modifier|*
name|zid
decl_stmt|;
name|boolean
name|fkill
decl_stmt|;
block|{
name|char
modifier|*
name|zfile
decl_stmt|;
name|char
modifier|*
name|zsys
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
name|time_t
name|inow
init|=
literal|0
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
name|struct
name|uuconf_system
name|ssys
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|size_t
name|cline
decl_stmt|;
name|int
name|isys
decl_stmt|;
name|zfile
operator|=
name|zsjobid_to_file
argument_list|(
name|zid
argument_list|,
operator|&
name|zsys
argument_list|,
operator|&
name|bgrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fkill
condition|)
name|inow
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_system_info
argument_list|(
name|puuconf
argument_list|,
name|zsys
argument_list|,
operator|&
name|ssys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_NOT_FOUND
condition|)
block|{
if|if
condition|(
operator|!
name|funknown_system
argument_list|(
name|puuconf
argument_list|,
name|zsys
argument_list|,
operator|&
name|ssys
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Bad job id"
argument_list|,
name|zid
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|iuuconf
operator|!=
name|UUCONF_SUCCESS
condition|)
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|e
operator|=
name|fopen
argument_list|(
name|zfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Job not found"
argument_list|,
name|zid
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now we have to read through the file to identify any temporary      files.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|fparse_cmd
argument_list|(
name|zline
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad line in command file %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* You are only permitted to delete a job if you submitted it or 	 if you are root or uucp.  */
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|.
name|zuser
argument_list|,
name|zsysdep_login_name
argument_list|()
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|fsysdep_privileged
argument_list|()
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Not submitted by you"
argument_list|,
name|zid
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|s
operator|.
name|bcmd
operator|==
literal|'S'
operator|||
name|s
operator|.
name|bcmd
operator|==
literal|'E'
condition|)
block|{
name|char
modifier|*
name|ztemp
decl_stmt|;
name|ztemp
operator|=
name|zsfind_file
argument_list|(
name|s
operator|.
name|ztemp
argument_list|,
name|ssys
operator|.
name|uuconf_zname
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztemp
operator|==
name|NULL
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fkill
condition|)
name|isys
operator|=
name|remove
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
else|else
name|isys
operator|=
name|issettime
argument_list|(
name|ztemp
argument_list|,
name|inow
argument_list|)
expr_stmt|;
if|if
condition|(
name|isys
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (%s): %s"
argument_list|,
name|fkill
condition|?
literal|"remove"
else|:
literal|"utime"
argument_list|,
name|ztemp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uuconf_system_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|ssys
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|fkill
condition|)
name|isys
operator|=
name|remove
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
else|else
name|isys
operator|=
name|issettime
argument_list|(
name|zfile
argument_list|,
name|inow
argument_list|)
expr_stmt|;
if|if
condition|(
name|isys
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (%s): %s"
argument_list|,
name|fkill
condition|?
literal|"remove"
else|:
literal|"utime"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the time a work job was queued.  */
end_comment

begin_function
name|long
name|ixsysdep_work_time
parameter_list|(
name|qsys
parameter_list|,
name|pseq
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|pointer
name|pseq
decl_stmt|;
block|{
name|char
modifier|*
name|zjobid
decl_stmt|,
modifier|*
name|zfile
decl_stmt|;
name|long
name|iret
decl_stmt|;
name|zjobid
operator|=
name|zsysdep_jobid
argument_list|(
name|qsys
argument_list|,
name|pseq
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zsjobid_to_file
argument_list|(
name|zjobid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ubuffree
argument_list|(
name|zjobid
argument_list|)
expr_stmt|;
name|iret
operator|=
name|ixsysdep_file_time
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|iret
return|;
block|}
end_function

begin_comment
comment|/* Get the time a file was created (actually, the time it was last    modified).  */
end_comment

begin_function
name|long
name|ixsysdep_file_time
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ixsysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
return|return
operator|(
name|long
operator|)
name|s
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* Set the time of a file to the current time.  */
end_comment

begin_function
name|boolean
name|fsysdep_touch_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
if|if
condition|(
name|issettime
argument_list|(
name|zfile
argument_list|,
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"utime (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start getting the status files.  */
end_comment

begin_function
name|boolean
name|fsysdep_all_status_init
parameter_list|(
name|phold
parameter_list|)
name|pointer
modifier|*
name|phold
decl_stmt|;
block|{
name|DIR
modifier|*
name|qdir
decl_stmt|;
name|qdir
operator|=
name|opendir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|".Status"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"opendir (.Status): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|phold
operator|=
operator|(
name|pointer
operator|)
name|qdir
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get the next status file.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_all_status
parameter_list|(
name|phold
parameter_list|,
name|pferr
parameter_list|,
name|qstat
parameter_list|)
name|pointer
name|phold
decl_stmt|;
name|boolean
modifier|*
name|pferr
decl_stmt|;
name|struct
name|sstatus
modifier|*
name|qstat
decl_stmt|;
block|{
name|DIR
modifier|*
name|qdir
init|=
operator|(
name|DIR
operator|*
operator|)
name|phold
decl_stmt|;
name|struct
name|dirent
modifier|*
name|qentry
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|qentry
operator|=
name|readdir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qentry
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
operator|*
name|pferr
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"readdir: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|qentry
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|struct
name|uuconf_system
name|ssys
decl_stmt|;
comment|/* Hack seriously; fsysdep_get_status only looks at the 	     zname element of the qsys argument, so if we fake that we 	     can read the status file.  This should really be done 	     differently.  */
name|ssys
operator|.
name|uuconf_zname
operator|=
name|qentry
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
name|fsysdep_get_status
argument_list|(
operator|&
name|ssys
argument_list|,
name|qstat
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|zbufcpy
argument_list|(
name|qentry
operator|->
name|d_name
argument_list|)
return|;
comment|/* If fsysdep_get_status fails, it will output an error 	     message.  We just continue with the next entry, so that 	     most of the status files will be displayed.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Finish getting the status file.  */
end_comment

begin_function
name|void
name|usysdep_all_status_free
parameter_list|(
name|phold
parameter_list|)
name|pointer
name|phold
decl_stmt|;
block|{
name|DIR
modifier|*
name|qdir
init|=
operator|(
name|DIR
operator|*
operator|)
name|phold
decl_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the status of all processes holding lock files.  We do this by    invoking ps after we've figured out the process entries to use.  */
end_comment

begin_function
name|boolean
name|fsysdep_lock_status
parameter_list|()
block|{
name|DIR
modifier|*
name|qdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|qentry
decl_stmt|;
name|int
name|calc
decl_stmt|;
name|pid_t
modifier|*
name|pai
decl_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|nid_t
modifier|*
name|painid
decl_stmt|;
endif|#
directive|endif
name|int
name|cgot
decl_stmt|;
name|int
name|aidescs
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|ztok
decl_stmt|;
name|int
name|cargs
decl_stmt|,
name|iarg
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazargs
decl_stmt|;
name|qdir
operator|=
name|opendir
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zSlockdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"opendir (%s): %s"
argument_list|,
name|zSlockdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We look for entries that start with "LCK.." and ignore everything      else.  This won't find all possible lock files, but it should      find all the locks on terminals and systems.  */
name|calc
operator|=
literal|0
expr_stmt|;
name|pai
operator|=
name|NULL
expr_stmt|;
name|cgot
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|painid
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|qentry
operator|=
name|readdir
argument_list|(
name|qdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zname
decl_stmt|;
name|int
name|o
decl_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|nid_t
name|inid
decl_stmt|;
name|char
name|ab
index|[
literal|23
index|]
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|int
name|i
decl_stmt|;
else|#
directive|else
name|char
name|ab
index|[
literal|12
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|cread
decl_stmt|;
name|int
name|ierr
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|int
name|icheck
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|qentry
operator|->
name|d_name
argument_list|,
literal|"LCK.."
argument_list|,
sizeof|sizeof
expr|"LCK.."
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
name|zSlockdir
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zname
argument_list|,
name|O_RDONLY
operator||
name|O_NOCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|cread
operator|=
name|read
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|cread
operator|=
name|read
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ierr
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|cread
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read %s: %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|ab
index|[
name|cread
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|ab
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|inid
operator|=
operator|(
name|nid_t
operator|)
name|strtol
argument_list|(
name|zend
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|i
expr_stmt|;
else|#
directive|else
name|ab
index|[
name|cread
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|ab
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|printf
argument_list|(
literal|"%s: %ld %ld\n"
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|,
operator|(
name|long
operator|)
name|inid
argument_list|,
operator|(
name|long
operator|)
name|ipid
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s: %ld\n"
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|,
operator|(
name|long
operator|)
name|ipid
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|icheck
operator|=
literal|0
init|;
name|icheck
operator|<
name|cgot
condition|;
name|icheck
operator|++
control|)
if|if
condition|(
name|pai
index|[
name|icheck
index|]
operator|==
name|ipid
condition|)
break|break;
if|if
condition|(
name|icheck
operator|<
name|cgot
condition|)
continue|continue;
if|if
condition|(
name|cgot
operator|>=
name|calc
condition|)
block|{
name|calc
operator|+=
literal|10
expr_stmt|;
name|pai
operator|=
operator|(
name|pid_t
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pai
argument_list|,
name|calc
operator|*
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|painid
operator|=
operator|(
name|nid_t
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|painid
argument_list|,
name|calc
operator|*
sizeof|sizeof
argument_list|(
name|nid_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|pai
index|[
name|cgot
index|]
operator|=
name|ipid
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|painid
index|[
name|cgot
index|]
operator|=
name|inid
expr_stmt|;
endif|#
directive|endif
operator|++
name|cgot
expr_stmt|;
block|}
if|if
condition|(
name|cgot
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|aidescs
index|[
literal|0
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
literal|2
expr_stmt|;
comment|/* Parse PS_PROGRAM into an array of arguments.  */
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|PS_PROGRAM
argument_list|)
expr_stmt|;
name|cargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ztok
operator|=
name|strtok
argument_list|(
name|zcopy
argument_list|,
literal|" \t"
argument_list|)
init|;
name|ztok
operator|!=
name|NULL
condition|;
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
operator|++
name|cargs
expr_stmt|;
name|pazargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|cargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zcopy
argument_list|,
name|PS_PROGRAM
argument_list|,
sizeof|sizeof
name|PS_PROGRAM
argument_list|)
expr_stmt|;
for|for
control|(
name|ztok
operator|=
name|strtok
argument_list|(
name|zcopy
argument_list|,
literal|" \t"
argument_list|)
operator|,
name|iarg
operator|=
literal|0
init|;
name|ztok
operator|!=
name|NULL
condition|;
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|,
operator|++
name|iarg
control|)
name|pazargs
index|[
name|iarg
index|]
operator|=
name|ztok
expr_stmt|;
name|pazargs
index|[
name|iarg
index|]
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_PS_MULTIPLE
comment|/* We have to invoke ps multiple times.  */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zlast
decl_stmt|,
modifier|*
name|zset
decl_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|char
modifier|*
name|zpenultimate
decl_stmt|,
modifier|*
name|zsetnid
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_QNX_LOCKFILES */
name|zlast
operator|=
name|pazargs
index|[
name|cargs
operator|-
literal|1
index|]
expr_stmt|;
name|zset
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zlast
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
comment|/* We assume in this case that PS_PROGRAM ends with " -n -p".        Thus, the last argument is "-p" and the second-to-last        (penultimate) argument is "-n".  We modify them to read "-n###"        and "-p###" where "###" is the node ID and the process ID,        respectively.  This seems like quite a roundabout way of doing        things.  Why don't we just leave the " -n -p" part out of        PS_PROGRAM and construct the "-n###" and "-p###" arguments here        from scratch?  Because that would not fit as well with how the        code works for the other systems and would require larger        changes. */
name|zpenultimate
operator|=
name|pazargs
index|[
name|cargs
operator|-
literal|2
index|]
expr_stmt|;
name|zsetnid
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|zpenultimate
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cgot
condition|;
name|i
operator|++
control|)
block|{
name|pid_t
name|ipid
decl_stmt|;
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"%s%ld"
argument_list|,
name|zlast
argument_list|,
operator|(
name|long
operator|)
name|pai
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pazargs
index|[
name|cargs
operator|-
literal|1
index|]
operator|=
name|zset
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|sprintf
argument_list|(
name|zsetnid
argument_list|,
literal|"%s%ld"
argument_list|,
name|zpenultimate
argument_list|,
operator|(
name|long
operator|)
name|painid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pazargs
index|[
name|cargs
operator|-
literal|2
index|]
operator|=
name|zsetnid
expr_stmt|;
endif|#
directive|endif
name|ipid
operator|=
name|ixsspawn
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|pazargs
argument_list|,
name|aidescs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ixsspawn: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
name|PS_PROGRAM
argument_list|)
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zset
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|ubuffree
argument_list|(
name|zsetnid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
block|{
name|char
modifier|*
name|zlast
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|zlast
operator|=
name|zbufalc
argument_list|(
name|strlen
argument_list|(
name|pazargs
index|[
name|cargs
operator|-
literal|1
index|]
argument_list|)
operator|+
name|cgot
operator|*
literal|20
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zlast
argument_list|,
name|pazargs
index|[
name|cargs
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cgot
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ab
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|pai
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zlast
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|cgot
condition|)
name|strcat
argument_list|(
name|zlast
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|pazargs
index|[
name|cargs
operator|-
literal|1
index|]
operator|=
name|zlast
expr_stmt|;
name|ipid
operator|=
name|ixsspawn
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|pazargs
argument_list|,
name|aidescs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ixsspawn: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
name|PS_PROGRAM
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zlast
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|pazargs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

