begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* status.c    Routines to get and set the status for a system.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_escape
end_escape

begin_if
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
end_if

begin_comment
comment|/* If we are using HDB spool layout, store status using HDB status    values.  SVR4 is a variant of HDB.  */
end_comment

begin_define
define|#
directive|define
name|MAP_STATUS
value|1
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|aiMapstatus
index|[]
init|=
block|{
literal|0
block|,
literal|13
block|,
literal|7
block|,
literal|6
block|,
literal|20
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CMAPENTRIES
value|(sizeof (aiMapstatus) / sizeof (aiMapstatus[0]))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4 */
end_comment

begin_define
define|#
directive|define
name|MAP_STATUS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get the status of a system.  This assumes that we are in the spool    directory.  */
end_comment

begin_function
name|boolean
name|fsysdep_get_status
parameter_list|(
name|qsys
parameter_list|,
name|qret
parameter_list|,
name|pfnone
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|struct
name|sstatus
modifier|*
name|qret
decl_stmt|;
name|boolean
modifier|*
name|pfnone
decl_stmt|;
block|{
name|char
modifier|*
name|zname
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|,
modifier|*
name|znext
decl_stmt|;
name|boolean
name|fbad
decl_stmt|;
name|int
name|istat
decl_stmt|;
if|if
condition|(
name|pfnone
operator|!=
name|NULL
condition|)
operator|*
name|pfnone
operator|=
name|FALSE
expr_stmt|;
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
literal|".Status"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|zname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zline
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|cline
decl_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zline
operator|==
name|NULL
condition|)
block|{
comment|/* There is either no status file for this system, or it's been 	 truncated, so fake a good status.  */
name|qret
operator|->
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
name|qret
operator|->
name|cretries
operator|=
literal|0
expr_stmt|;
name|qret
operator|->
name|ilast
operator|=
literal|0
expr_stmt|;
name|qret
operator|->
name|cwait
operator|=
literal|0
expr_stmt|;
name|qret
operator|->
name|zstring
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pfnone
operator|!=
name|NULL
condition|)
operator|*
name|pfnone
operator|=
name|TRUE
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* It turns out that scanf is not used much in this program, so for      the benefit of small computers we avoid linking it in.  This is      basically       sscanf (zline, "%d %d %ld %d",&qret->ttype,&qret->cretries,&qret->ilast,&qret->cwait);       except that it's done with strtol.  */
name|fbad
operator|=
name|FALSE
expr_stmt|;
name|istat
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|zline
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|zend
operator|==
name|zline
condition|)
name|fbad
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|MAP_STATUS
comment|/* On some systems it may be appropriate to map system dependent status      values on to our status values.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CMAPENTRIES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|aiMapstatus
index|[
name|i
index|]
operator|==
name|istat
condition|)
block|{
name|istat
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* MAP_STATUS */
if|if
condition|(
name|istat
operator|<
literal|0
operator|||
name|istat
operator|>=
operator|(
name|int
operator|)
name|STATUS_VALUES
condition|)
name|istat
operator|=
operator|(
name|int
operator|)
name|STATUS_COMPLETE
expr_stmt|;
name|qret
operator|->
name|ttype
operator|=
operator|(
expr|enum
name|tstatus_type
operator|)
name|istat
expr_stmt|;
name|znext
operator|=
name|zend
expr_stmt|;
name|qret
operator|->
name|cretries
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|znext
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|zend
operator|==
name|znext
condition|)
name|fbad
operator|=
name|TRUE
expr_stmt|;
name|znext
operator|=
name|zend
expr_stmt|;
name|qret
operator|->
name|ilast
operator|=
name|strtol
argument_list|(
name|znext
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|zend
operator|==
name|znext
condition|)
name|fbad
operator|=
name|TRUE
expr_stmt|;
name|znext
operator|=
name|zend
expr_stmt|;
name|qret
operator|->
name|cwait
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|znext
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|zend
operator|==
name|znext
condition|)
name|fbad
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fbad
condition|)
block|{
name|znext
operator|=
name|zend
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|znext
argument_list|)
argument_list|)
condition|)
operator|++
name|znext
expr_stmt|;
if|if
condition|(
operator|*
name|znext
operator|==
literal|'\0'
condition|)
name|qret
operator|->
name|zstring
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|znext
operator|==
literal|'"'
condition|)
operator|++
name|znext
expr_stmt|;
name|qret
operator|->
name|zstring
operator|=
name|zbufcpy
argument_list|(
name|znext
argument_list|)
expr_stmt|;
name|zend
operator|=
name|qret
operator|->
name|zstring
operator|+
name|strlen
argument_list|(
name|qret
operator|->
name|zstring
argument_list|)
expr_stmt|;
while|while
condition|(
name|zend
operator|!=
name|qret
operator|->
name|zstring
operator|&&
operator|*
name|zend
operator|!=
literal|' '
condition|)
operator|--
name|zend
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|==
literal|'"'
operator|&&
name|zend
operator|!=
name|qret
operator|->
name|zstring
condition|)
operator|--
name|zend
expr_stmt|;
if|if
condition|(
name|zend
operator|!=
name|qret
operator|->
name|zstring
condition|)
operator|*
name|zend
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|ubuffree
argument_list|(
name|qret
operator|->
name|zstring
argument_list|)
expr_stmt|;
name|qret
operator|->
name|zstring
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbad
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Bad status file format"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the status of a remote system.  This assumes the system is    locked when this is called, and that the program is in the spool    directory.  */
end_comment

begin_function
name|boolean
name|fsysdep_set_status
parameter_list|(
name|qsys
parameter_list|,
name|qset
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|sstatus
modifier|*
name|qset
decl_stmt|;
block|{
name|char
modifier|*
name|zname
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|istat
decl_stmt|;
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
literal|".Status"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zname
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|istat
operator|=
operator|(
name|int
operator|)
name|qset
operator|->
name|ttype
expr_stmt|;
if|#
directive|if
name|MAP_STATUS
comment|/* On some systems it may be appropriate to map istat onto a system      dependent number.  */
if|if
condition|(
name|istat
operator|>=
literal|0
operator|&&
name|istat
operator|<
name|CMAPENTRIES
condition|)
name|istat
operator|=
name|aiMapstatus
index|[
name|istat
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* MAP_STATUS */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%d %d %ld %d "
argument_list|,
name|istat
argument_list|,
name|qset
operator|->
name|cretries
argument_list|,
name|qset
operator|->
name|ilast
argument_list|,
name|qset
operator|->
name|cwait
argument_list|)
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_SVR4
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"%s\""
argument_list|,
name|azStatus
index|[
operator|(
name|int
operator|)
name|qset
operator|->
name|ttype
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|azStatus
index|[
operator|(
name|int
operator|)
name|qset
operator|->
name|ttype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" %s\n"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

