begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* indir.c    See if a file is in a directory.     Copyright (C) 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* See whether a file is in a directory, and optionally check access.  */
end_comment

begin_function
name|boolean
name|fsysdep_in_directory
parameter_list|(
name|zfile
parameter_list|,
name|zdir
parameter_list|,
name|fcheck
parameter_list|,
name|freadable
parameter_list|,
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdir
decl_stmt|;
name|boolean
name|fcheck
decl_stmt|;
name|boolean
name|freadable
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
name|size_t
name|c
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|zslash
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|zfile
operator|!=
literal|'/'
condition|)
return|return
name|FALSE
return|;
name|c
operator|=
name|strlen
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|zdir
index|[
name|c
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zfile
argument_list|,
name|zdir
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|zfile
index|[
name|c
index|]
operator|!=
literal|'/'
operator|&&
name|zfile
index|[
name|c
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strstr
argument_list|(
name|zfile
operator|+
name|c
argument_list|,
literal|"/../"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* If we're not checking access, get out now.  */
if|if
condition|(
operator|!
name|fcheck
condition|)
return|return
name|TRUE
return|;
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
comment|/* Start checking directories after zdir.  Otherwise, we would      require that all directories down to /usr/spool/uucppublic be      publically searchable; they probably are but it should not be a      requirement.  */
name|zslash
operator|=
name|zcopy
operator|+
name|c
expr_stmt|;
do|do
block|{
name|char
name|b
decl_stmt|;
name|struct
name|stat
name|shold
decl_stmt|;
name|b
operator|=
operator|*
name|zslash
expr_stmt|;
operator|*
name|zslash
operator|=
literal|'\0'
expr_stmt|;
name|shold
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|zcopy
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|zcopy
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If this is the top directory, any problems will be caught 	     later when we try to open it.  */
if|if
condition|(
name|zslash
operator|==
name|zcopy
operator|+
name|c
condition|)
block|{
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Go back and check the last directory for read or write 	     access.  */
name|s
operator|=
name|shold
expr_stmt|;
break|break;
block|}
comment|/* If this is not a directory, get out of the loop.  */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
break|break;
comment|/* Make sure the directory is searchable.  */
if|if
condition|(
operator|!
name|fsuser_access
argument_list|(
operator|&
name|s
argument_list|,
name|X_OK
argument_list|,
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|zcopy
argument_list|,
name|strerror
argument_list|(
name|EACCES
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we've reached the end of the string, get out.  */
if|if
condition|(
name|b
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|zslash
operator|=
name|b
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|zslash
operator|=
name|strchr
argument_list|(
name|zslash
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* At this point s holds a stat on the last component of the path.      We must check it for readability or writeability.  */
if|if
condition|(
operator|!
name|fsuser_access
argument_list|(
operator|&
name|s
argument_list|,
name|freadable
condition|?
name|R_OK
else|:
name|W_OK
argument_list|,
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|zcopy
argument_list|,
name|strerror
argument_list|(
name|EACCES
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

