begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tcp.c    Code to handle TCP connections.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|tcp_rcsid
index|[]
init|=
literal|"$Id: tcp.c,v 1.5 1995/06/21 19:20:46 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TCP
end_if

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TYPES_TCP_H
end_if

begin_include
include|#
directive|include
file|<sys/types.tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This code handles TCP connections.  It assumes a Berkeley socket    interface.  */
end_comment

begin_comment
comment|/* The normal "uucp" port number.  */
end_comment

begin_define
define|#
directive|define
name|IUUCP_PORT
value|(540)
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|utcp_free
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftcp_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftcp_close
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
name|fsuccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftcp_dial
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
expr|enum
name|tdialerfound
operator|*
name|ptdialer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itcp_port_number
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zport
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The command table for a TCP connection.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sconncmds
name|stcpcmds
init|=
block|{
name|utcp_free
block|,
name|NULL
block|,
comment|/* pflock */
name|NULL
block|,
comment|/* pfunlock */
name|ftcp_open
block|,
name|ftcp_close
block|,
name|ftcp_dial
block|,
name|fsysdep_conn_read
block|,
name|fsysdep_conn_write
block|,
name|fsysdep_conn_io
block|,
name|NULL
block|,
comment|/* pfbreak */
name|NULL
block|,
comment|/* pfset */
name|NULL
block|,
comment|/* pfcarrier */
name|fsysdep_conn_chat
block|,
name|NULL
comment|/* pibaud */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize a TCP connection.  */
end_comment

begin_function
name|boolean
name|fsysdep_tcp_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysdep_conn
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|owr
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|zdevice
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|iflags
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|iwr_flags
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|fterminal
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|ftli
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|ibaud
operator|=
literal|0
expr_stmt|;
name|qconn
operator|->
name|psysdep
operator|=
operator|(
name|pointer
operator|)
name|q
expr_stmt|;
name|qconn
operator|->
name|qcmds
operator|=
operator|&
name|stcpcmds
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Free a TCP connection.  */
end_comment

begin_function
specifier|static
name|void
name|utcp_free
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|xfree
argument_list|(
name|qconn
operator|->
name|psysdep
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a TCP connection.  If the fwait argument is TRUE, we are    running as a server.  Otherwise we are just trying to reach another    system.  */
end_comment

begin_function
specifier|static
name|boolean
name|ftcp_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|struct
name|sockaddr_in
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|uid_t
name|ieuid
decl_stmt|;
name|boolean
name|fswap
decl_stmt|;
name|ulog_device
argument_list|(
literal|"TCP"
argument_list|)
expr_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qsysdep
operator|->
name|iflags
operator|=
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|iflags
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We save our process ID in the qconn structure.  This is checked      in ftcp_close.  */
name|qsysdep
operator|->
name|ipid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* If we aren't waiting for a connection, we're done.  */
if|if
condition|(
operator|!
name|fwait
condition|)
return|return
name|TRUE
return|;
comment|/* Run as a server and wait for a new connection.  The code in      uucico.c has already detached us from our controlling terminal.      From this point on if the server gets an error we exit; we only      return if we have received a connection.  It would be more robust      to respawn the server if it fails; someday.  */
name|bzero
argument_list|(
operator|(
name|pointer
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
name|s
argument_list|)
expr_stmt|;
name|s
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|zport
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zport
expr_stmt|;
name|s
operator|.
name|sin_port
operator|=
name|itcp_port_number
argument_list|(
name|zport
argument_list|)
expr_stmt|;
name|s
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
comment|/* Swap to our real user ID when doing the bind call.  This will      permit the server to use privileged TCP ports when invoked by      root.  We only swap if our effective user ID is not root, so that      the program can also be made suid root in order to get privileged      ports when invoked by anybody.  */
name|fswap
operator|=
name|geteuid
argument_list|()
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|fswap
condition|)
block|{
if|if
condition|(
operator|!
name|fsuser_perms
argument_list|(
operator|&
name|ieuid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|bind
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"bind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now swap back to the uucp user ID.  */
if|if
condition|(
name|fswap
condition|)
block|{
if|if
condition|(
operator|!
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Could not swap back to UUCP user permissions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"listen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
name|int
name|onew
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftcp_open: Waiting for connections"
argument_list|)
expr_stmt|;
name|clen
operator|=
sizeof|sizeof
name|s
expr_stmt|;
name|onew
operator|=
name|accept
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
operator|&
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|onew
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftcp_open: Got connection; forking"
argument_list|)
expr_stmt|;
name|ipid
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|onew
expr_stmt|;
comment|/* Now we fork and let our parent die, so that we become 	     a child of init.  This lets the main server code wait 	     for its child and then continue without accumulating 	     zombie children.  */
name|ipid
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipid
operator|!=
literal|0
condition|)
name|_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
name|ulog_id
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
comment|/* Now wait for the child.  */
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We got a signal.  */
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Avoid compiler warnings.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close the port.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ftcp_close
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdialer
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|>=
literal|0
operator|&&
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If the current pid is not the one we used to open the port, then      we must have forked up above and we are now the child.  In this      case, we are being called from within the fendless loop in      uucico.c.  We return FALSE to force the loop to end and the child      to exit.  This should be handled in a cleaner fashion.  */
if|if
condition|(
name|qsysdep
operator|->
name|ipid
operator|!=
name|getpid
argument_list|()
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dial out on a TCP port, so to speak: connect to a remote computer.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ftcp_dial
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qsys
parameter_list|,
name|zphone
parameter_list|,
name|qdialer
parameter_list|,
name|ptdialer
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|enum
name|tdialerfound
modifier|*
name|ptdialer
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhost
decl_stmt|;
name|struct
name|hostent
modifier|*
name|q
decl_stmt|;
name|struct
name|sockaddr_in
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzdialer
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
operator|*
name|ptdialer
operator|=
name|DIALERFOUND_FALSE
expr_stmt|;
name|zhost
operator|=
name|zphone
expr_stmt|;
if|if
condition|(
name|zhost
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No address for TCP connection"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zhost
operator|=
name|qsys
operator|->
name|uuconf_zname
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|gethostbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|s
operator|.
name|sin_family
operator|=
name|q
operator|->
name|h_addrtype
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|s
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|q
operator|->
name|h_addr
argument_list|,
operator|(
name|size_t
operator|)
name|q
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"gethostbyname (%s): %s"
argument_list|,
name|zhost
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|s
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zhost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|s
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unknown host name"
argument_list|,
name|zhost
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zport
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zport
expr_stmt|;
name|s
operator|.
name|sin_port
operator|=
name|itcp_port_number
argument_list|(
name|zport
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"connect: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Handle the dialer sequence, if any.  */
name|pzdialer
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_pzdialer
expr_stmt|;
if|if
condition|(
name|pzdialer
operator|!=
name|NULL
operator|&&
operator|*
name|pzdialer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_dial_sequence
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|pzdialer
argument_list|,
name|qsys
argument_list|,
name|zphone
argument_list|,
name|qdialer
argument_list|,
name|ptdialer
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the port number given a name.  The argument will almost always    be "uucp" so we cache that value.  The return value is always in    network byte order.  This returns -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|itcp_port_number
parameter_list|(
name|zname
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
block|{
name|boolean
name|fuucp
decl_stmt|;
specifier|static
name|int
name|iuucp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
name|struct
name|servent
modifier|*
name|q
decl_stmt|;
name|fuucp
operator|=
name|strcmp
argument_list|(
name|zname
argument_list|,
literal|"uucp"
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|fuucp
operator|&&
name|iuucp
operator|!=
literal|0
condition|)
return|return
name|iuucp
return|;
comment|/* Try it as a number first.  */
name|i
operator|=
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zname
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|*
name|zend
operator|==
literal|'\0'
condition|)
return|return
name|htons
argument_list|(
name|i
argument_list|)
return|;
name|q
operator|=
name|getservbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
comment|/* We know that the "uucp" service should be 540, even if isn't 	 in /etc/services.  */
if|if
condition|(
name|fuucp
condition|)
block|{
name|iuucp
operator|=
name|htons
argument_list|(
name|IUUCP_PORT
argument_list|)
expr_stmt|;
return|return
name|iuucp
return|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"getservbyname (%s): %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fuucp
condition|)
name|iuucp
operator|=
name|q
operator|->
name|s_port
expr_stmt|;
return|return
name|q
operator|->
name|s_port
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TCP */
end_comment

end_unit

