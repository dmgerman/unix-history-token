begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tcp.c    Code to handle TCP connections.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|tcp_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TCP
end_if

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TYPES_TCP_H
end_if

begin_include
include|#
directive|include
file|<sys/types.tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This code handles TCP connections.  It assumes a Berkeley socket    interface.  */
end_comment

begin_comment
comment|/* The normal "uucp" port number.  */
end_comment

begin_define
define|#
directive|define
name|IUUCP_PORT
value|"540"
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|utcp_free
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftcp_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftcp_close
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
name|fsuccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftcp_dial
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
expr|enum
name|tdialerfound
operator|*
name|ptdialer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itcp_getaddrinfo
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zhost
operator|,
specifier|const
name|char
operator|*
name|zport
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
name|hints
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
name|res
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The command table for a TCP connection.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sconncmds
name|stcpcmds
init|=
block|{
name|utcp_free
block|,
name|NULL
block|,
comment|/* pflock */
name|NULL
block|,
comment|/* pfunlock */
name|ftcp_open
block|,
name|ftcp_close
block|,
name|ftcp_dial
block|,
name|fsysdep_conn_read
block|,
name|fsysdep_conn_write
block|,
name|fsysdep_conn_io
block|,
name|NULL
block|,
comment|/* pfbreak */
name|NULL
block|,
comment|/* pfset */
name|NULL
block|,
comment|/* pfcarrier */
name|fsysdep_conn_chat
block|,
name|NULL
comment|/* pibaud */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize a TCP connection.  */
end_comment

begin_function
name|boolean
name|fsysdep_tcp_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysdep_conn
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|owr
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|zdevice
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|iflags
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|iwr_flags
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|fterminal
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|ftli
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|ibaud
operator|=
literal|0
expr_stmt|;
name|qconn
operator|->
name|psysdep
operator|=
operator|(
name|pointer
operator|)
name|q
expr_stmt|;
name|qconn
operator|->
name|qcmds
operator|=
operator|&
name|stcpcmds
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Free a TCP connection.  */
end_comment

begin_function
specifier|static
name|void
name|utcp_free
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|xfree
argument_list|(
name|qconn
operator|->
name|psysdep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|utcp_init
parameter_list|(
name|qsysdep
parameter_list|)
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|qsysdep
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qsysdep
operator|->
name|iflags
operator|=
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|iflags
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a TCP connection.  If the fwait argument is TRUE, we are    running as a server.  Otherwise we are just trying to reach another    system.  */
end_comment

begin_function
specifier|static
name|boolean
name|ftcp_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|,
modifier|*
name|res0
decl_stmt|;
name|struct
name|sockaddr_storage
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|int
name|zfamily
decl_stmt|;
name|uid_t
name|ieuid
decl_stmt|;
name|boolean
name|fswap
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ulog_device
argument_list|(
literal|"TCP"
argument_list|)
expr_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We save our process ID in the qconn structure.  This is checked      in ftcp_close.  */
name|qsysdep
operator|->
name|ipid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* If we aren't waiting for a connection, we're done.  */
if|if
condition|(
operator|!
name|fwait
condition|)
return|return
name|TRUE
return|;
comment|/* Run as a server and wait for a new connection.  The code in      uucico.c has already detached us from our controlling terminal.      From this point on if the server gets an error we exit; we only      return if we have received a connection.  It would be more robust      to respawn the server if it fails; someday.  */
name|zport
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zport
expr_stmt|;
name|zfamily
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zfamily
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|zfamily
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|itcp_getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|zport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"getaddrinfo (NULL, %s): %s"
argument_list|,
name|zport
argument_list|,
name|gai_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|HAVE_GETADDRINFO
if|if
condition|(
name|zfamily
operator|==
name|PF_UNSPEC
condition|)
block|{
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|res
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
name|qsysdep
operator|->
name|o
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
name|qsysdep
operator|->
name|o
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|IPV6_BINDV6ONLY
if|if
condition|(
name|res
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
name|int
name|flag
init|=
operator|(
name|zfamily
operator|==
name|PF_UNSPEC
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_BINDV6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|,
sizeof|sizeof
argument_list|(
name|flag
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"setsockopt: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|utcp_init
argument_list|(
name|qsysdep
argument_list|)
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Swap to our real user ID when doing the bind call.  This will      permit the server to use privileged TCP ports when invoked by      root.  We only swap if our effective user ID is not root, so that      the program can also be made suid root in order to get privileged      ports when invoked by anybody.  */
name|fswap
operator|=
name|geteuid
argument_list|()
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|fswap
condition|)
block|{
if|if
condition|(
operator|!
name|fsuser_perms
argument_list|(
operator|&
name|ieuid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|bind
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"bind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* Now swap back to the uucp user ID.  */
if|if
condition|(
name|fswap
condition|)
block|{
if|if
condition|(
operator|!
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Could not swap back to UUCP user permissions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"listen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
name|int
name|onew
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftcp_open: Waiting for connections"
argument_list|)
expr_stmt|;
name|clen
operator|=
sizeof|sizeof
name|s
expr_stmt|;
name|onew
operator|=
name|accept
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
operator|&
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|onew
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftcp_open: Got connection; forking"
argument_list|)
expr_stmt|;
name|ipid
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|onew
expr_stmt|;
comment|/* Now we fork and let our parent die, so that we become 	     a child of init.  This lets the main server code wait 	     for its child and then continue without accumulating 	     zombie children.  */
name|ipid
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipid
operator|!=
literal|0
condition|)
name|_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
name|ulog_id
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
comment|/* Now wait for the child.  */
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We got a signal.  */
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Avoid compiler warnings.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close the port.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ftcp_close
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdialer
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|>=
literal|0
operator|&&
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If the current pid is not the one we used to open the port, then      we must have forked up above and we are now the child.  In this      case, we are being called from within the fendless loop in      uucico.c.  We return FALSE to force the loop to end and the child      to exit.  This should be handled in a cleaner fashion.  */
if|if
condition|(
name|qsysdep
operator|->
name|ipid
operator|!=
name|getpid
argument_list|()
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dial out on a TCP port, so to speak: connect to a remote computer.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ftcp_dial
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qsys
parameter_list|,
name|zphone
parameter_list|,
name|qdialer
parameter_list|,
name|ptdialer
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|enum
name|tdialerfound
modifier|*
name|ptdialer
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhost
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|,
modifier|*
name|res0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|connected
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzdialer
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
operator|*
name|ptdialer
operator|=
name|DIALERFOUND_FALSE
expr_stmt|;
name|zhost
operator|=
name|zphone
expr_stmt|;
if|if
condition|(
name|zhost
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No address for TCP connection"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zhost
operator|=
name|qsys
operator|->
name|uuconf_zname
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|zport
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zport
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_zfamily
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|itcp_getaddrinfo
argument_list|(
name|zhost
argument_list|,
name|zport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"getaddrinfo (%s, %s): %s"
argument_list|,
name|zhost
argument_list|,
name|zport
argument_list|,
name|gai_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
name|qsysdep
operator|->
name|o
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|connect
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|connected
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"connect: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|utcp_init
argument_list|(
name|qsysdep
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Handle the dialer sequence, if any.  */
name|pzdialer
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stcp
operator|.
name|uuconf_pzdialer
expr_stmt|;
if|if
condition|(
name|pzdialer
operator|!=
name|NULL
operator|&&
operator|*
name|pzdialer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_dial_sequence
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|pzdialer
argument_list|,
name|qsys
argument_list|,
name|zphone
argument_list|,
name|qdialer
argument_list|,
name|ptdialer
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|itcp_getaddrinfo
parameter_list|(
name|zhost
parameter_list|,
name|zport
parameter_list|,
name|hints
parameter_list|,
name|res
parameter_list|)
specifier|const
name|char
modifier|*
name|zhost
decl_stmt|,
decl|*
name|zport
decl_stmt|;
end_function

begin_decl_stmt
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|getaddrinfo
argument_list|(
name|zhost
argument_list|,
name|zport
argument_list|,
name|hints
argument_list|,
name|res
argument_list|)
operator|)
operator|!=
name|EAI_SERVICE
operator|||
name|strcmp
argument_list|(
name|zport
argument_list|,
literal|"uucp"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
return|return
name|getaddrinfo
argument_list|(
name|zhost
argument_list|,
name|IUUCP_PORT
argument_list|,
name|hints
argument_list|,
name|res
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TCP */
end_comment

end_unit

