begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* seq.c    Get and increment the conversation sequence number for a system.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o Infinity Development Systems, P.O. Box 520, Waltham, MA 02254.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Get the current conversation sequence number for a remote system,    and increment it for next time.  The conversation sequence number    is kept in a file named for the system in the directory .Sequence    in the spool directory.  This is not compatible with other versions    of UUCP, but it makes more sense to me.  The sequence file is only    used if specified in the information for that system.  */
end_comment

begin_function
name|long
name|ixsysdep_get_sequence
parameter_list|(
name|qsys
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|long
name|iseq
decl_stmt|;
comment|/* This will only be called when the system is locked anyhow, so there      is no need to use a separate lock for the conversation sequence      file.  */
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
literal|".Sequence"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
name|iseq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|zname
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|boolean
name|fok
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|size_t
name|cline
decl_stmt|;
comment|/* The file should only be readable and writable by uucp.  */
if|if
condition|(
operator|(
name|s
operator|.
name|st_mode
operator|&
operator|(
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad file protection for conversation sequence file"
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|e
operator|=
name|fopen
argument_list|(
name|zname
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
name|fok
operator|=
name|TRUE
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|<=
literal|0
condition|)
name|fok
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zend
decl_stmt|;
name|iseq
operator|=
name|strtol
argument_list|(
name|zline
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|zend
operator|==
name|zline
condition|)
name|fok
operator|=
name|FALSE
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad format for conversation sequence file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rewind
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zname
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
operator|++
name|iseq
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%ld"
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|iseq
return|;
block|}
end_function

end_unit

