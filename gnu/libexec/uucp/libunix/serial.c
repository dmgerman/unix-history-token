begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* serial.c    The serial port communication routines for Unix.     Copyright (C) 1991, 1992, 1993, 1994, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|serial_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_PARAM_H
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TLI
end_if

begin_if
if|#
directive|if
name|HAVE_TIUSER_H
end_if

begin_include
include|#
directive|include
file|<tiuser.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_TIUSER_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_XTI_H
end_if

begin_include
include|#
directive|include
file|<xti.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_XTI_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_TIUSER_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TLI */
end_comment

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_IOCTL_H
operator|||
name|HAVE_TXADDCD
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SELECT
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_if
if|#
directive|if
operator|!
name|HAVE_SYS_TIME_H
operator|||
operator|!
name|HAVE_SELECT
operator|||
name|TIME_WITH_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STRIP_BUG
operator|&&
name|HAVE_BSD_TTY
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SVR4_LOCKFILES
end_if

begin_comment
comment|/* Get the right definitions for major and minor.  */
end_comment

begin_if
if|#
directive|if
name|MAJOR_IN_MKDEV
end_if

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAJOR_IN_MKDEV */
end_comment

begin_if
if|#
directive|if
name|MAJOR_IN_SYSMACROS
end_if

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAJOR_IN_SYSMACROS */
end_comment

begin_if
if|#
directive|if
operator|!
name|MAJOR_IN_MKDEV
operator|&&
operator|!
name|MAJOR_IN_SYSMACROS
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|major
end_ifndef

begin_define
define|#
directive|define
name|major
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 8)& 0xff)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|minor
end_ifndef

begin_define
define|#
directive|define
name|minor
parameter_list|(
name|i
parameter_list|)
value|((i)& 0xff)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAJOR_IN_MKDEV&& ! MAJOR_IN_SYSMACROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SVR4_LOCKFILES */
end_comment

begin_if
if|#
directive|if
name|HAVE_DEV_INFO
end_if

begin_include
include|#
directive|include
file|<sys/dev.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for both O_NONBLOCK and O_NDELAY.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NDELAY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNDELAY
end_ifdef

begin_define
define|#
directive|define
name|O_NDELAY
value|FNDELAY
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_define
define|#
directive|define
name|O_NDELAY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NDELAY) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNBLOCK
end_ifdef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|FNBLOCK
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_define
define|#
directive|define
name|O_NONBLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NONBLOCK) */
end_comment

begin_if
if|#
directive|if
name|O_NDELAY
operator|==
literal|0
operator|&&
name|O_NONBLOCK
operator|==
literal|0
end_if

begin_error
error|#
directive|error
error|No way to do nonblocking I/O
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for EAGAIN, EWOULDBLOCK and ENODATA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EAGAIN
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EAGAIN
value|(-1)
end_define

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_define
define|#
directive|define
name|EAGAIN
value|EWOULDBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (EWOULDBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENODATA
end_ifndef

begin_define
define|#
directive|define
name|ENODATA
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make sure we have a definition for MAX_INPUT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_INPUT
end_ifndef

begin_define
define|#
directive|define
name|MAX_INPUT
value|(256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we have the TIOCSINUSE ioctl call, we use it to lock a terminal.    Otherwise, if we have the TIOCEXCL ioctl call, we have to open the    terminal before we know that it is unlocked.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSINUSE
end_ifdef

begin_define
define|#
directive|define
name|HAVE_TIOCSINUSE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCEXCL
end_ifdef

begin_define
define|#
directive|define
name|HAVE_TIOCEXCL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TLI
end_if

begin_decl_stmt
specifier|extern
name|int
name|t_errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|t_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|t_nerr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Determine bits to clear for the various terminal control fields for    HAVE_SYSV_TERMIO and HAVE_POSIX_TERMIOS.  */
end_comment

begin_comment
comment|/* These fields are defined on some systems, and I am told that it    does not hurt to clear them, and it sometimes helps.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IMAXBEL
end_ifndef

begin_define
define|#
directive|define
name|IMAXBEL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PENDIN
end_ifndef

begin_define
define|#
directive|define
name|PENDIN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYSV_TERMIO
end_if

begin_define
define|#
directive|define
name|ICLEAR_IFLAG
value|(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK \ 		      | ISTRIP | INLCR | IGNCR | ICRNL | IUCLC \ 		      | IXON | IXANY | IXOFF | IMAXBEL)
end_define

begin_define
define|#
directive|define
name|ICLEAR_OFLAG
value|(OPOST | OLCUC | ONLCR | OCRNL | ONOCR | ONLRET \ 		      | OFILL | OFDEL | NLDLY | CRDLY | TABDLY | BSDLY \ 		      | VTDLY | FFDLY)
end_define

begin_define
define|#
directive|define
name|ICLEAR_CFLAG
value|(CBAUD | CSIZE | PARENB | PARODD)
end_define

begin_define
define|#
directive|define
name|ISET_CFLAG
value|(CS8 | CREAD | HUPCL)
end_define

begin_define
define|#
directive|define
name|ICLEAR_LFLAG
value|(ISIG | ICANON | XCASE | ECHO | ECHOE | ECHOK \ 		      | ECHONL | NOFLSH | PENDIN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POSIX_TERMIOS
end_if

begin_define
define|#
directive|define
name|ICLEAR_IFLAG
value|(BRKINT | ICRNL | IGNBRK | IGNCR | IGNPAR \ 		      | INLCR | INPCK | ISTRIP | IXOFF | IXON \ 		      | PARMRK | IMAXBEL)
end_define

begin_define
define|#
directive|define
name|ICLEAR_OFLAG
value|(OPOST)
end_define

begin_define
define|#
directive|define
name|ICLEAR_CFLAG
value|(CSIZE | PARENB | PARODD)
end_define

begin_define
define|#
directive|define
name|ISET_CFLAG
value|(CS8 | CREAD | HUPCL)
end_define

begin_define
define|#
directive|define
name|ICLEAR_LFLAG
value|(ECHO | ECHOE | ECHOK | ECHONL | ICANON | IEXTEN \ 		      | ISIG | NOFLSH | TOSTOP | PENDIN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|tclocal_setting
block|{
name|SET_CLOCAL
block|,
name|CLEAR_CLOCAL
block|,
name|IGNORE_CLOCAL
block|}
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|usalarm
name|P
argument_list|(
operator|(
name|int
name|isig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_init
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
specifier|const
expr|struct
name|sconncmds
operator|*
name|qcmds
operator|,
specifier|const
name|char
operator|*
name|zdevice
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usserial_free
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_lockfile
name|P
argument_list|(
operator|(
name|boolean
name|flok
operator|,
specifier|const
expr|struct
name|sconnection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_lock
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|boolean
name|fin
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_unlock
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|,
expr|enum
name|tclocal_setting
name|tlocal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsstdin_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsmodem_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsdirect_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsblock
name|P
argument_list|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
name|q
operator|,
name|boolean
name|fblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_close
name|P
argument_list|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
name|q
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsstdin_close
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
name|fsuccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsmodem_close
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
name|fsuccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsdirect_close
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
name|fsuccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_break
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsstdin_break
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_set
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
expr|enum
name|tparitysetting
name|tparity
operator|,
expr|enum
name|tstripsetting
name|tstrip
operator|,
expr|enum
name|txonxoffsetting
name|txonxoff
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsstdin_set
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
expr|enum
name|tparitysetting
name|tparity
operator|,
expr|enum
name|tstripsetting
name|tstrip
operator|,
expr|enum
name|txonxoffsetting
name|txonxoff
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsmodem_carrier
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|boolean
name|fcarrier
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsserial_hardflow
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|boolean
name|fhardflow
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsrun_chat
name|P
argument_list|(
operator|(
name|int
name|oread
operator|,
name|int
name|owrite
operator|,
name|char
operator|*
operator|*
name|pzprog
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|isserial_baud
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The command table for standard input ports.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sconncmds
name|sstdincmds
init|=
block|{
name|usserial_free
block|,
name|NULL
block|,
comment|/* pflock */
name|NULL
block|,
comment|/* pfunlock */
name|fsstdin_open
block|,
name|fsstdin_close
block|,
name|NULL
block|,
comment|/* pfdial */
name|fsdouble_read
block|,
name|fsdouble_write
block|,
name|fsysdep_conn_io
block|,
name|fsstdin_break
block|,
name|fsstdin_set
block|,
name|NULL
block|,
comment|/* pfcarrier */
name|fsdouble_chat
block|,
name|isserial_baud
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command table for modem ports.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sconncmds
name|smodemcmds
init|=
block|{
name|usserial_free
block|,
name|fsserial_lock
block|,
name|fsserial_unlock
block|,
name|fsmodem_open
block|,
name|fsmodem_close
block|,
name|fmodem_dial
block|,
name|fsysdep_conn_read
block|,
name|fsysdep_conn_write
block|,
name|fsysdep_conn_io
block|,
name|fsserial_break
block|,
name|fsserial_set
block|,
name|fsmodem_carrier
block|,
name|fsysdep_conn_chat
block|,
name|isserial_baud
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command table for direct ports.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sconncmds
name|sdirectcmds
init|=
block|{
name|usserial_free
block|,
name|fsserial_lock
block|,
name|fsserial_unlock
block|,
name|fsdirect_open
block|,
name|fsdirect_close
block|,
name|NULL
block|,
comment|/* pfdial */
name|fsysdep_conn_read
block|,
name|fsysdep_conn_write
block|,
name|fsysdep_conn_io
block|,
name|fsserial_break
block|,
name|fsserial_set
block|,
name|NULL
block|,
comment|/* pfcarrier */
name|fsysdep_conn_chat
block|,
name|isserial_baud
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* If the system will let us set both O_NDELAY and O_NONBLOCK, we do    so.  This is because some ancient drivers on some systems appear to    look for one but not the other.  Some other systems will give an    EINVAL error if we attempt to set both, so we use a static global    to hold the value we want to set.  If we get EINVAL, we change the    global and try again (if some system gives an error other than    EINVAL, the code will have to be modified).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iSunblock
init|=
name|O_NDELAY
operator||
name|O_NONBLOCK
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This code handles SIGALRM.  See the discussion above    fsysdep_conn_read.  Normally we ignore SIGALRM, but the handler    will temporarily be set to this function, which should set fSalarm    and then either longjmp or schedule another SIGALRM.  fSalarm is    never referred to outside of this file, but we don't make it static    to try to fool compilers which don't understand volatile.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|fSalarm
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|usalarm
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|HAVE_SIGACTION
operator|&&
operator|!
name|HAVE_SIGVEC
operator|&&
operator|!
name|HAVE_SIGSET
operator|(
name|void
operator|)
name|signal
argument_list|(
name|isig
argument_list|,
name|usalarm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fSalarm
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|HAVE_RESTARTABLE_SYSCALLS
name|longjmp
argument_list|(
name|sSjmp_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We need a simple routine to block SIGINT, SIGQUIT, SIGTERM and    SIGPIPE and another to restore the original state.  When these    functions are called (in fsysdep_modem_close) SIGHUP is being    ignored.  The routines are isblocksigs, which returns a value of    type HELD_SIG_MASK and usunblocksigs which takes a single argument    of type HELD_SIG_MASK.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_SIGPROCMASK
end_if

begin_comment
comment|/* Use the POSIX sigprocmask call.  */
end_comment

begin_define
define|#
directive|define
name|HELD_SIG_MASK
value|sigset_t
end_define

begin_decl_stmt
specifier|static
name|sigset_t
name|isblocksigs
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|sigset_t
name|isblocksigs
parameter_list|()
block|{
name|sigset_t
name|sblock
decl_stmt|,
name|sold
decl_stmt|;
comment|/* These expressions need an extra set of parentheses to avoid a bug      in SCO 3.2.2.  */
call|(
name|void
call|)
argument_list|(
name|sigemptyset
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|sigaddset
argument_list|(
operator|&
name|sblock
argument_list|,
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|sigaddset
argument_list|(
operator|&
name|sblock
argument_list|,
name|SIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|sigaddset
argument_list|(
operator|&
name|sblock
argument_list|,
name|SIGTERM
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|sigaddset
argument_list|(
operator|&
name|sblock
argument_list|,
name|SIGPIPE
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sblock
argument_list|,
operator|&
name|sold
argument_list|)
expr_stmt|;
return|return
name|sold
return|;
block|}
end_function

begin_define
define|#
directive|define
name|usunblocksigs
parameter_list|(
name|s
parameter_list|)
define|\
value|((void) sigprocmask (SIG_SETMASK,&(s), (sigset_t *) NULL))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_SIGPROCMASK */
end_comment

begin_if
if|#
directive|if
name|HAVE_SIGBLOCK
end_if

begin_comment
comment|/* Use the BSD sigblock and sigsetmask calls.  */
end_comment

begin_define
define|#
directive|define
name|HELD_SIG_MASK
value|int
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|i
parameter_list|)
value|(1<< ((i) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|isblocksigs
parameter_list|()
define|\
value|sigblock (sigmask (SIGINT) | sigmask (SIGQUIT) \ 	    | sigmask (SIGTERM) | sigmask (SIGPIPE))
end_define

begin_define
define|#
directive|define
name|usunblocksigs
parameter_list|(
name|i
parameter_list|)
value|((void) sigsetmask (i))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_SIGBLOCK */
end_comment

begin_if
if|#
directive|if
name|HAVE_SIGHOLD
end_if

begin_comment
comment|/* Use the SVR3 sighold and sigrelse calls.  */
end_comment

begin_define
define|#
directive|define
name|HELD_SIG_MASK
value|int
end_define

begin_decl_stmt
specifier|static
name|int
name|isblocksigs
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|isblocksigs
parameter_list|()
block|{
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|usunblocksigs
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|usunblocksigs
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_SIGHOLD */
end_comment

begin_comment
comment|/* We have no way to block signals.  This system will suffer from a    race condition in fsysdep_modem_close.  */
end_comment

begin_define
define|#
directive|define
name|HELD_SIG_MASK
value|int
end_define

begin_define
define|#
directive|define
name|isblocksigs
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|usunblocksigs
parameter_list|(
name|i
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_SIGHOLD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_SIGBLOCK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_SIGPROCMASK */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Initialize a connection for use on a serial port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_init
parameter_list|(
name|qconn
parameter_list|,
name|qcmds
parameter_list|,
name|zdevice
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|struct
name|sconncmds
modifier|*
name|qcmds
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdevice
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysdep_conn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdevice
operator|==
name|NULL
operator|&&
name|qconn
operator|->
name|qport
operator|!=
name|NULL
operator|&&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_ttype
operator|!=
name|UUCONF_PORTTYPE_STDIN
condition|)
name|zdevice
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zname
expr_stmt|;
if|if
condition|(
name|zdevice
operator|==
name|NULL
condition|)
name|q
operator|->
name|zdevice
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|zdevice
operator|==
literal|'/'
condition|)
name|q
operator|->
name|zdevice
operator|=
name|zbufcpy
argument_list|(
name|zdevice
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|clen
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zdevice
argument_list|)
expr_stmt|;
name|q
operator|->
name|zdevice
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|clen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
operator|->
name|zdevice
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
operator|->
name|zdevice
operator|+
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|,
name|zdevice
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|q
operator|->
name|zdevice
index|[
sizeof|sizeof
name|_PATH_DEV
operator|+
name|clen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|q
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|owr
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|ftli
operator|=
name|FALSE
expr_stmt|;
name|qconn
operator|->
name|psysdep
operator|=
operator|(
name|pointer
operator|)
name|q
expr_stmt|;
name|qconn
operator|->
name|qcmds
operator|=
name|qcmds
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Initialize a connection for use on standard input.  */
end_comment

begin_function
name|boolean
name|fsysdep_stdin_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
comment|/* chmod /dev/tty to prevent other users from writing messages to      it.  This is essentially `mesg n'.  */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|_PATH_TTY
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
return|return
name|fsserial_init
argument_list|(
name|qconn
argument_list|,
operator|&
name|sstdincmds
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a connection for use on a modem port.  */
end_comment

begin_function
name|boolean
name|fsysdep_modem_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
return|return
name|fsserial_init
argument_list|(
name|qconn
argument_list|,
operator|&
name|smodemcmds
argument_list|,
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_zdevice
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a connection for use on a direct port.  */
end_comment

begin_function
name|boolean
name|fsysdep_direct_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
return|return
name|fsserial_init
argument_list|(
name|qconn
argument_list|,
operator|&
name|sdirectcmds
argument_list|,
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_sdirect
operator|.
name|uuconf_zdevice
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free up a serial port.  */
end_comment

begin_function
specifier|static
name|void
name|usserial_free
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|ubuffree
argument_list|(
name|qsysdep
operator|->
name|zdevice
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qsysdep
argument_list|)
expr_stmt|;
name|qconn
operator|->
name|psysdep
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_SEQUENT_LOCKFILES
end_if

begin_define
define|#
directive|define
name|LCK_TEMPLATE
value|"LCK..tty"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LCK_TEMPLATE
value|"LCK.."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This routine is used for both locking and unlocking.  It is the    only routine which knows how to translate a device name into the    name of a lock file.  If it can't figure out a name, it does    nothing and returns TRUE.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_lockfile
parameter_list|(
name|flok
parameter_list|,
name|qconn
parameter_list|)
name|boolean
name|flok
decl_stmt|;
specifier|const
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
name|qconn
operator|->
name|qport
operator|==
name|NULL
condition|)
name|z
operator|=
name|NULL
expr_stmt|;
else|else
name|z
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zlockname
expr_stmt|;
name|zalc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|HAVE_QNX_LOCKFILES
block|{
name|nid_t
name|idevice_nid
decl_stmt|;
name|char
name|abdevice_nid
index|[
literal|13
index|]
decl_stmt|;
comment|/* length of long, a period, and a NUL */
name|size_t
name|cdevice_nid
decl_stmt|;
specifier|const
name|char
modifier|*
name|zbase
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
comment|/* If the node ID is explicitly specified as part of the            pathname to the device, use that.  Otherwise, presume the            device is local to the current node. */
if|if
condition|(
name|qsysdep
operator|->
name|zdevice
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|qsysdep
operator|->
name|zdevice
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|idevice_nid
operator|=
operator|(
name|nid_t
operator|)
name|strtol
argument_list|(
name|qsysdep
operator|->
name|zdevice
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|idevice_nid
operator|=
name|getnid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|abdevice_nid
argument_list|,
literal|"%ld."
argument_list|,
operator|(
name|long
operator|)
name|idevice_nid
argument_list|)
expr_stmt|;
name|cdevice_nid
operator|=
name|strlen
argument_list|(
name|abdevice_nid
argument_list|)
expr_stmt|;
name|zbase
operator|=
name|strrchr
argument_list|(
name|qsysdep
operator|->
name|zdevice
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|LCK_TEMPLATE
operator|+
name|cdevice_nid
operator|+
name|clen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
argument_list|,
name|LCK_TEMPLATE
argument_list|,
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|,
name|abdevice_nid
argument_list|,
name|cdevice_nid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
operator|+
name|cdevice_nid
argument_list|,
name|zbase
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|z
operator|=
name|zalc
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_QNX_LOCKFILES */
if|#
directive|if
operator|!
name|HAVE_SVR4_LOCKFILES
block|{
specifier|const
name|char
modifier|*
name|zbase
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|zbase
operator|=
name|strrchr
argument_list|(
name|qsysdep
operator|->
name|zdevice
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|LCK_TEMPLATE
operator|+
name|clen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
argument_list|,
name|LCK_TEMPLATE
argument_list|,
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|,
name|zbase
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SCO_LOCKFILES
block|{
name|char
modifier|*
name|zl
decl_stmt|;
for|for
control|(
name|zl
operator|=
name|zalc
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
init|;
operator|*
name|zl
operator|!=
literal|'\0'
condition|;
name|zl
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|zl
argument_list|)
condition|)
operator|*
name|zl
operator|=
name|tolower
argument_list|(
operator|*
name|zl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|z
operator|=
name|zalc
expr_stmt|;
block|}
else|#
directive|else
comment|/* HAVE_SVR4_LOCKFILES */
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|qsysdep
operator|->
name|zdevice
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|qsysdep
operator|->
name|zdevice
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zalc
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
expr|"LK.1234567890.1234567890.1234567890"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"LK.%03d.%03d.%03d"
argument_list|,
name|major
argument_list|(
name|s
operator|.
name|st_dev
argument_list|)
argument_list|,
name|major
argument_list|(
name|s
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|s
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|zalc
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_SVR4_LOCKFILES */
endif|#
directive|endif
comment|/* ! HAVE_QNX_LOCKFILES */
block|}
if|if
condition|(
name|flok
condition|)
name|fret
operator|=
name|fsdo_lock
argument_list|(
name|z
argument_list|,
name|FALSE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fret
operator|=
name|fsdo_unlock
argument_list|(
name|z
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_COHERENT_LOCKFILES
if|if
condition|(
name|fret
condition|)
block|{
if|if
condition|(
name|flok
condition|)
block|{
if|if
condition|(
name|lockttyexist
argument_list|(
name|z
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"%s: port already locked"
argument_list|,
name|z
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|fret
operator|=
name|fscoherent_disable_tty
argument_list|(
name|z
operator|+
sizeof|sizeof
name|LCK_TEMPLATE
operator|-
literal|1
argument_list|,
operator|&
name|qsysdep
operator|->
name|zenable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|zenable
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|azargs
index|[
literal|3
index|]
decl_stmt|;
name|int
name|aidescs
index|[
literal|3
index|]
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|azargs
index|[
literal|0
index|]
operator|=
literal|"/etc/enable"
expr_stmt|;
name|azargs
index|[
literal|1
index|]
operator|=
name|qsysdep
operator|->
name|zenable
expr_stmt|;
name|azargs
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|aidescs
index|[
literal|0
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|1
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|ipid
operator|=
name|ixsspawn
argument_list|(
name|azargs
argument_list|,
name|aidescs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ixsspawn (/etc/enable %s): %s"
argument_list|,
name|qsysdep
operator|->
name|zenable
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|fret
operator|=
name|TRUE
expr_stmt|;
else|else
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|qsysdep
operator|->
name|zenable
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|zenable
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_COHERENT_LOCKFILES */
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we can mark a modem line in use, then when we lock a port we    must open it and mark it in use.  We can't wait until the actual    open because we can't fail out if it is locked then.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_lock
parameter_list|(
name|qconn
parameter_list|,
name|fin
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|boolean
name|fin
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fsserial_lockfile
argument_list|(
name|TRUE
argument_list|,
name|qconn
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|HAVE_TIOCSINUSE
operator|||
name|HAVE_TIOCEXCL
operator|||
name|HAVE_DEV_INFO
comment|/* Open the line and try to mark it in use.  */
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
name|fin
condition|)
name|iflag
operator|=
literal|0
expr_stmt|;
else|else
name|iflag
operator|=
name|iSunblock
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|open
argument_list|(
name|qsysdep
operator|->
name|zdevice
argument_list|,
name|O_RDWR
operator||
name|iflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|O_NONBLOCK
operator|!=
literal|0
if|if
condition|(
operator|!
name|fin
operator|&&
name|iSunblock
operator|!=
name|O_NONBLOCK
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|iSunblock
operator|=
name|O_NONBLOCK
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|open
argument_list|(
name|qsysdep
operator|->
name|zdevice
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EBUSY
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|qsysdep
operator|->
name|zdevice
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsserial_lockfile
argument_list|(
name|FALSE
argument_list|,
name|qconn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
name|HAVE_TIOCSINUSE
comment|/* If we can't mark it in use, return FALSE to indicate that the        lock failed.  */
if|if
condition|(
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCSINUSE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EALREADY
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (TIOCSINUSE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fsserial_lockfile
argument_list|(
name|FALSE
argument_list|,
name|qconn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_DEV_INFO
comment|/* QNX programs "lock" a serial port by simply opening it and        checking if some other program also has the port open.  If the        count of openers is greater than one, the program presumes the        port is "locked" and backs off.  This isn't really "locking" of        course, but it pretty much seems to work.  This can result in        dropping incoming connections if an outgoing connection is        started at exactly the same time.  It would probably be better        to stop using the lock files at all for this case, but that        would involve more complex changes to the code, and I'm afraid        I would break something.  -- Joe Wells<jbw@cs.bu.edu>  */
block|{
name|struct
name|_dev_info_entry
name|sdevinfo
decl_stmt|;
if|if
condition|(
name|dev_info
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|&
name|sdevinfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"dev_info: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sdevinfo
operator|.
name|open_count
operator|=
literal|2
expr_stmt|;
comment|/* force presumption of "locked" */
block|}
if|if
condition|(
name|sdevinfo
operator|.
name|open_count
operator|!=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCNOTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCNOTTY */
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fsserial_lockfile
argument_list|(
name|FALSE
argument_list|,
name|qconn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_DEV_INFO */
if|if
condition|(
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fsserial_lockfile
argument_list|(
name|FALSE
argument_list|,
name|qconn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TIOCSINUSE || HAVE_TIOCEXCL */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Unlock a modem or direct port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_unlock
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
comment|/* The file may have been opened by fsserial_lock, so close it here      if necessary.  */
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCNOTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsserial_lockfile
argument_list|(
name|FALSE
argument_list|,
name|qconn
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A table to map baud rates into index numbers.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_POSIX_TERMIOS
end_if

begin_typedef
typedef|typedef
name|speed_t
name|baud_code
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|baud_code
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
name|sbaud_table
block|{
name|baud_code
name|icode
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
block|}
name|asSbaud_table
index|[]
init|=
block|{
block|{
name|B50
block|,
literal|50
block|}
block|,
block|{
name|B75
block|,
literal|75
block|}
block|,
block|{
name|B110
block|,
literal|110
block|}
block|,
block|{
name|B134
block|,
literal|134
block|}
block|,
block|{
name|B150
block|,
literal|150
block|}
block|,
block|{
name|B200
block|,
literal|200
block|}
block|,
block|{
name|B300
block|,
literal|300
block|}
block|,
block|{
name|B600
block|,
literal|600
block|}
block|,
block|{
name|B1200
block|,
literal|1200
block|}
block|,
block|{
name|B1800
block|,
literal|1800
block|}
block|,
block|{
name|B2400
block|,
literal|2400
block|}
block|,
block|{
name|B4800
block|,
literal|4800
block|}
block|,
block|{
name|B9600
block|,
literal|9600
block|}
block|,
ifdef|#
directive|ifdef
name|B19200
block|{
name|B19200
block|,
literal|19200
block|}
block|,
else|#
directive|else
comment|/* ! defined (B19200) */
ifdef|#
directive|ifdef
name|EXTA
block|{
name|EXTA
block|,
literal|19200
block|}
block|,
endif|#
directive|endif
comment|/* EXTA */
endif|#
directive|endif
comment|/* ! defined (B19200) */
ifdef|#
directive|ifdef
name|B38400
block|{
name|B38400
block|,
literal|38400
block|}
block|,
else|#
directive|else
comment|/* ! defined (B38400) */
ifdef|#
directive|ifdef
name|EXTB
block|{
name|EXTB
block|,
literal|38400
block|}
block|,
endif|#
directive|endif
comment|/* EXTB */
endif|#
directive|endif
comment|/* ! defined (B38400) */
ifdef|#
directive|ifdef
name|B57600
block|{
name|B57600
block|,
literal|57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B76800
block|{
name|B76800
block|,
literal|76800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
name|B115200
block|,
literal|115200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B230400
block|{
name|B230400
block|,
literal|230400
block|}
block|,
endif|#
directive|endif
block|{
name|B0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CBAUD_TABLE
value|(sizeof asSbaud_table / sizeof asSbaud_table[0])
end_define

begin_if
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
end_if

begin_comment
comment|/* Hold the MIN value for the terminal to avoid setting it    unnecessarily.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cSmin
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
end_comment

begin_comment
comment|/* Open a serial line.  This sets the terminal settings.  We begin in    seven bit mode and let the protocol change if necessary.  If fwait    is FALSE we open the terminal in non-blocking mode.  If flocal is    TRUE we set CLOCAL on the terminal when using termio[s]; this is    supposedly required on some versions of BSD/386.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|,
name|tlocal
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
name|enum
name|tclocal_setting
name|tlocal
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|baud_code
name|ib
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|zdevice
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|LOG_DEVICE_PREFIX
name|ulog_device
argument_list|(
name|q
operator|->
name|zdevice
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|q
operator|->
name|zdevice
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|=
name|q
operator|->
name|zdevice
operator|+
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
expr_stmt|;
else|else
name|z
operator|=
name|q
operator|->
name|zdevice
expr_stmt|;
name|ulog_device
argument_list|(
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|boolean
name|fdummy
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|qconn
operator|->
name|qport
operator|!=
name|NULL
operator|&&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_ttype
operator|!=
name|UUCONF_PORTTYPE_STDIN
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsserial_open: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zport
operator|=
name|zsysdep_port_name
argument_list|(
operator|&
name|fdummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|zport
operator|!=
name|NULL
condition|)
name|ulog_device
argument_list|(
name|zport
argument_list|)
expr_stmt|;
block|}
name|ib
operator|=
name|B0
expr_stmt|;
if|if
condition|(
name|ibaud
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CBAUD_TABLE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|asSbaud_table
index|[
name|i
index|]
operator|.
name|ibaud
operator|==
name|ibaud
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|CBAUD_TABLE
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unsupported baud rate %ld"
argument_list|,
name|ibaud
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ib
operator|=
name|asSbaud_table
index|[
name|i
index|]
operator|.
name|icode
expr_stmt|;
block|}
comment|/* The port may have already been opened by the locking routine.  */
if|if
condition|(
name|q
operator|->
name|o
operator|<
literal|0
condition|)
block|{
name|int
name|iflag
decl_stmt|;
if|if
condition|(
name|fwait
condition|)
name|iflag
operator|=
literal|0
expr_stmt|;
else|else
name|iflag
operator|=
name|iSunblock
expr_stmt|;
name|q
operator|->
name|o
operator|=
name|open
argument_list|(
name|q
operator|->
name|zdevice
argument_list|,
name|O_RDWR
operator||
name|iflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|o
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|O_NONBLOCK
operator|!=
literal|0
if|if
condition|(
operator|!
name|fwait
operator|&&
name|iSunblock
operator|!=
name|O_NONBLOCK
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|iSunblock
operator|=
name|O_NONBLOCK
expr_stmt|;
name|q
operator|->
name|o
operator|=
name|open
argument_list|(
name|q
operator|->
name|zdevice
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|q
operator|->
name|zdevice
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Get the port flags, and make sure the ports are blocking.  */
name|q
operator|->
name|iflags
operator|=
name|fcntl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|iflags
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|q
operator|->
name|iwr_flags
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fgetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|sorig
argument_list|)
condition|)
block|{
name|q
operator|->
name|fterminal
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|q
operator|->
name|fterminal
operator|=
name|TRUE
expr_stmt|;
name|q
operator|->
name|snew
operator|=
name|q
operator|->
name|sorig
expr_stmt|;
if|#
directive|if
name|HAVE_BSD_TTY
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|=
name|RAW
operator||
name|ANYP
expr_stmt|;
if|if
condition|(
name|ibaud
operator|==
literal|0
condition|)
name|ib
operator|=
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_ospeed
expr_stmt|;
else|else
block|{
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_ispeed
operator|=
name|ib
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_ospeed
operator|=
name|ib
expr_stmt|;
block|}
comment|/* We don't want to receive any interrupt characters.  */
name|q
operator|->
name|snew
operator|.
name|stchars
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|stchars
operator|.
name|t_quitc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|stchars
operator|.
name|t_eofc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|stchars
operator|.
name|t_brkc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|sltchars
operator|.
name|t_suspc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|sltchars
operator|.
name|t_rprntc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|sltchars
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|sltchars
operator|.
name|t_flushc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|sltchars
operator|.
name|t_werasc
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|sltchars
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NTTYDISC
comment|/* We want to use the ``new'' terminal driver so that we can use the      local mode bits to control XON/XOFF.  */
block|{
name|int
name|iparam
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|iparam
argument_list|)
operator|>=
literal|0
operator|&&
name|iparam
operator|!=
name|NTTYDISC
condition|)
block|{
name|iparam
operator|=
name|NTTYDISC
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|iparam
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCHPCL
comment|/* When the file is closed, hang up the line.  This is a safety      measure in case the program crashes.  */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCHPCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCFLUSH
block|{
name|int
name|iparam
decl_stmt|;
comment|/* Flush pending input.  */
ifdef|#
directive|ifdef
name|FREAD
name|iparam
operator|=
name|FREAD
expr_stmt|;
else|#
directive|else
name|iparam
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|iparam
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCFLUSH */
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
if|#
directive|if
name|HAVE_SYSV_TERMIO
if|if
condition|(
name|ibaud
operator|==
literal|0
condition|)
name|ib
operator|=
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&=
operator|~
name|ICLEAR_IFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_oflag
operator|&=
operator|~
name|ICLEAR_OFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|ICLEAR_CFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|ib
operator||
name|ISET_CFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_lflag
operator|&=
operator|~
name|ICLEAR_LFLAG
expr_stmt|;
name|cSmin
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
name|cSmin
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TCFLSH
comment|/* Flush pending input.  */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TCFLSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO */
if|#
directive|if
name|HAVE_POSIX_TERMIOS
if|if
condition|(
name|ibaud
operator|==
literal|0
condition|)
name|ib
operator|=
name|cfgetospeed
argument_list|(
operator|&
name|q
operator|->
name|snew
argument_list|)
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&=
operator|~
name|ICLEAR_IFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_oflag
operator|&=
operator|~
name|ICLEAR_OFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|ICLEAR_CFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|ISET_CFLAG
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_lflag
operator|&=
operator|~
name|ICLEAR_LFLAG
expr_stmt|;
name|cSmin
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
name|cSmin
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|cfsetospeed
argument_list|(
operator|&
name|q
operator|->
name|snew
argument_list|,
name|ib
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfsetispeed
argument_list|(
operator|&
name|q
operator|->
name|snew
argument_list|,
name|ib
argument_list|)
expr_stmt|;
comment|/* Flush pending input.  */
operator|(
name|void
operator|)
name|tcflush
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TCIFLUSH
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POSIX_TERMIOS */
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
switch|switch
condition|(
name|tlocal
condition|)
block|{
case|case
name|SET_CLOCAL
case|:
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
break|break;
case|case
name|CLEAR_CLOCAL
case|:
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
break|break;
case|case
name|IGNORE_CLOCAL
case|:
break|break;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't set terminal settings: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|TIOCSCTTY
comment|/* On BSD 4.4, make it our controlling terminal.  */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCSCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ibaud
operator|!=
literal|0
condition|)
name|q
operator|->
name|ibaud
operator|=
name|ibaud
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|q
operator|->
name|ibaud
operator|=
operator|(
name|long
operator|)
literal|1200
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CBAUD_TABLE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|asSbaud_table
index|[
name|i
index|]
operator|.
name|icode
operator|==
name|ib
condition|)
block|{
name|q
operator|->
name|ibaud
operator|=
name|asSbaud_table
index|[
name|i
index|]
operator|.
name|ibaud
expr_stmt|;
break|break;
block|}
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fsserial_open: Baud rate is %ld"
argument_list|,
name|q
operator|->
name|ibaud
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Open a standard input port.  The code alternates q->o between    q->ord and q->owr as appropriate.  It is always q->ord before any    call to fsblock.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsstdin_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|q
operator|->
name|ord
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|owr
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|o
operator|=
name|q
operator|->
name|ord
expr_stmt|;
if|if
condition|(
operator|!
name|fsserial_open
argument_list|(
name|qconn
argument_list|,
name|ibaud
argument_list|,
name|fwait
argument_list|,
name|IGNORE_CLOCAL
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|q
operator|->
name|iwr_flags
operator|=
name|fcntl
argument_list|(
name|q
operator|->
name|owr
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|iwr_flags
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Open a modem port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsmodem_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|uuconf_modem_port
modifier|*
name|qm
decl_stmt|;
name|qm
operator|=
operator|&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
expr_stmt|;
if|if
condition|(
name|ibaud
operator|==
operator|(
name|long
operator|)
literal|0
condition|)
name|ibaud
operator|=
name|qm
operator|->
name|uuconf_ibaud
expr_stmt|;
if|if
condition|(
operator|!
name|fsserial_open
argument_list|(
name|qconn
argument_list|,
name|ibaud
argument_list|,
name|fwait
argument_list|,
name|fwait
condition|?
name|CLEAR_CLOCAL
else|:
name|SET_CLOCAL
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we are waiting for carrier, then turn on hardware flow      control.  We don't turn on hardware flow control when dialing      out, because some modems don't assert the necessary signals until      they see carrier.  Instead, we turn on hardware flow control in      fsmodem_carrier.  */
if|if
condition|(
name|fwait
operator|&&
operator|!
name|fsserial_hardflow
argument_list|(
name|qconn
argument_list|,
name|qm
operator|->
name|uuconf_fhardflow
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Open a direct port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsdirect_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|uuconf_direct_port
modifier|*
name|qd
decl_stmt|;
name|qd
operator|=
operator|&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_sdirect
expr_stmt|;
if|if
condition|(
name|ibaud
operator|==
operator|(
name|long
operator|)
literal|0
condition|)
name|ibaud
operator|=
name|qd
operator|->
name|uuconf_ibaud
expr_stmt|;
if|if
condition|(
operator|!
name|fsserial_open
argument_list|(
name|qconn
argument_list|,
name|ibaud
argument_list|,
name|fwait
argument_list|,
name|qd
operator|->
name|uuconf_fcarrier
condition|?
name|CLEAR_CLOCAL
else|:
name|SET_CLOCAL
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Always turn on hardware flow control for a direct port when it is      opened.  There is no other sensible time to turn it on.  */
return|return
name|fsserial_hardflow
argument_list|(
name|qconn
argument_list|,
name|qd
operator|->
name|uuconf_fhardflow
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the blocking status of the port.  We keep track of the    current blocking status to avoid calling fcntl unnecessarily; fcntl    turns out to be surprisingly expensive, at least on Ultrix.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsblock
parameter_list|(
name|qs
parameter_list|,
name|fblock
parameter_list|)
name|struct
name|ssysdep_conn
modifier|*
name|qs
decl_stmt|;
name|boolean
name|fblock
decl_stmt|;
block|{
name|int
name|iwant
decl_stmt|;
name|int
name|isys
decl_stmt|;
if|if
condition|(
name|fblock
condition|)
name|iwant
operator|=
name|qs
operator|->
name|iflags
operator|&
operator|~
operator|(
name|O_NDELAY
operator||
name|O_NONBLOCK
operator|)
expr_stmt|;
else|else
name|iwant
operator|=
name|qs
operator|->
name|iflags
operator||
name|iSunblock
expr_stmt|;
if|if
condition|(
name|iwant
operator|==
name|qs
operator|->
name|iflags
condition|)
return|return
name|TRUE
return|;
name|isys
operator|=
name|fcntl
argument_list|(
name|qs
operator|->
name|o
argument_list|,
name|F_SETFL
argument_list|,
name|iwant
argument_list|)
expr_stmt|;
if|if
condition|(
name|isys
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|O_NONBLOCK
operator|!=
literal|0
if|if
condition|(
operator|!
name|fblock
operator|&&
name|iSunblock
operator|!=
name|O_NONBLOCK
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|iSunblock
operator|=
name|O_NONBLOCK
expr_stmt|;
name|iwant
operator|=
name|qs
operator|->
name|iflags
operator||
name|O_NONBLOCK
expr_stmt|;
name|isys
operator|=
name|fcntl
argument_list|(
name|qs
operator|->
name|o
argument_list|,
name|F_SETFL
argument_list|,
name|iwant
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|isys
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|qs
operator|->
name|iflags
operator|=
name|iwant
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|iwr_flags
operator|>=
literal|0
operator|&&
name|qs
operator|->
name|ord
operator|!=
name|qs
operator|->
name|owr
condition|)
block|{
if|if
condition|(
name|fblock
condition|)
name|iwant
operator|=
name|qs
operator|->
name|iwr_flags
operator|&
operator|~
operator|(
name|O_NDELAY
operator||
name|O_NONBLOCK
operator|)
expr_stmt|;
else|else
name|iwant
operator|=
name|qs
operator|->
name|iwr_flags
operator||
name|iSunblock
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|qs
operator|->
name|owr
argument_list|,
name|F_SETFL
argument_list|,
name|iwant
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We don't bother to fix up iSunblock here, since we 	     succeeded above.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qs
operator|->
name|iwr_flags
operator|=
name|iwant
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close a serial port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_close
parameter_list|(
name|q
parameter_list|)
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
block|{
if|if
condition|(
name|q
operator|->
name|o
operator|>=
literal|0
condition|)
block|{
comment|/* Use a 30 second timeout to avoid hanging while draining 	 output.  */
if|if
condition|(
name|q
operator|->
name|fterminal
condition|)
block|{
name|fSalarm
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
name|usysdep_start_catch
argument_list|()
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|usalarm
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsetterminfodrain
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|sorig
argument_list|)
expr_stmt|;
block|}
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
comment|/* If we timed out, use the non draining call.  Hopefully 	     this can't hang.  */
if|if
condition|(
name|fSalarm
condition|)
operator|(
name|void
operator|)
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|sorig
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* We don't want this as our controlling terminal any more, so 	 get rid of it.  This is necessary because we don't want to 	 open /dev/tty, since that can confuse the serial port locking 	 on some computers.  */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|q
operator|->
name|o
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Sleep to give the terminal a chance to settle, in case we are 	 about to call out again.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Close a stdin port.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fsstdin_close
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdialer
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qsysdep
operator|->
name|owr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|qsysdep
operator|->
name|ord
expr_stmt|;
return|return
name|fsserial_close
argument_list|(
name|qsysdep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close a modem port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsmodem_close
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdialer
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|struct
name|uuconf_dialer
name|sdialer
decl_stmt|;
specifier|const
name|struct
name|uuconf_chat
modifier|*
name|qchat
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
comment|/* Figure out the dialer so that we can run the complete or abort      chat scripts.  */
if|if
condition|(
name|qdialer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_pzdialer
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zdialer
decl_stmt|;
name|int
name|iuuconf
decl_stmt|;
name|zdialer
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_pzdialer
index|[
literal|0
index|]
expr_stmt|;
name|iuuconf
operator|=
name|uuconf_dialer_info
argument_list|(
name|puuconf
argument_list|,
name|zdialer
argument_list|,
operator|&
name|sdialer
argument_list|)
expr_stmt|;
if|if
condition|(
name|iuuconf
operator|==
name|UUCONF_SUCCESS
condition|)
name|qdialer
operator|=
operator|&
name|sdialer
expr_stmt|;
else|else
block|{
name|ulog_uuconf
argument_list|(
name|LOG_ERROR
argument_list|,
name|puuconf
argument_list|,
name|iuuconf
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
name|qdialer
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_qdialer
expr_stmt|;
block|}
comment|/* Get the complete or abort chat script to use.  */
name|qchat
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qdialer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fsuccess
condition|)
name|qchat
operator|=
operator|&
name|qdialer
operator|->
name|uuconf_scomplete
expr_stmt|;
else|else
name|qchat
operator|=
operator|&
name|qdialer
operator|->
name|uuconf_sabort
expr_stmt|;
block|}
if|if
condition|(
name|qchat
operator|!=
name|NULL
operator|&&
operator|(
name|qchat
operator|->
name|uuconf_pzprogram
operator|!=
name|NULL
operator|||
name|qchat
operator|->
name|uuconf_pzchat
operator|!=
name|NULL
operator|)
condition|)
block|{
name|boolean
name|fsighup_ignored
decl_stmt|;
name|HELD_SIG_MASK
name|smask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sig_atomic_t
name|afhold
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
comment|/* We're no longer interested in carrier.  */
operator|(
name|void
operator|)
name|fsmodem_carrier
argument_list|(
name|qconn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* The port I/O routines check whether any signal has been 	 received, and abort if one has.  While we are closing down 	 the modem, we don't care if we received a signal in the past, 	 but we do care if we receive a new signal (otherwise it would 	 be difficult to kill a uucico which was closing down a 	 modem).  We never care if we get SIGHUP at this point.  So we 	 turn off SIGHUP, remember what signals we've already seen, 	 and clear our notion of what signals we've seen.  We have to 	 block the signals while we remember and clear the array, 	 since we might otherwise miss a signal which occurred between 	 the copy and the clear (old systems can't block signals; they 	 will just have to suffer the race).  */
name|usset_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|,
name|FALSE
argument_list|,
operator|&
name|fsighup_ignored
argument_list|)
expr_stmt|;
name|smask
operator|=
name|isblocksigs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INDEXSIG_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|afhold
index|[
name|i
index|]
operator|=
name|afSignal
index|[
name|i
index|]
expr_stmt|;
name|afSignal
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
name|usunblocksigs
argument_list|(
name|smask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fchat
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|qchat
argument_list|,
operator|(
specifier|const
expr|struct
name|uuconf_system
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
expr|struct
name|uuconf_dialer
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zname
argument_list|,
name|qsysdep
operator|->
name|ibaud
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
comment|/* Restore the old signal array and the SIGHUP handler.  It is 	 not necessary to block signals here, since all we are doing 	 is exactly what the signal handler itself would do if the 	 signal occurred.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INDEXSIG_COUNT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|afhold
index|[
name|i
index|]
condition|)
name|afSignal
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fsighup_ignored
condition|)
name|usset_signal
argument_list|(
name|SIGHUP
argument_list|,
name|ussignal
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qdialer
operator|!=
name|NULL
operator|&&
name|qdialer
operator|==
operator|&
name|sdialer
condition|)
operator|(
name|void
operator|)
name|uuconf_dialer_free
argument_list|(
name|puuconf
argument_list|,
operator|&
name|sdialer
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_RESET_BUG
comment|/* Reset the terminal to make sure we drop DTR.  It should be      dropped when we close the descriptor, but that doesn't seem to      happen on some systems.  Use a 30 second timeout to avoid hanging      while draining output.  */
if|if
condition|(
name|qsysdep
operator|->
name|fterminal
condition|)
block|{
if|#
directive|if
name|HAVE_BSD_TTY
name|qsysdep
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_ispeed
operator|=
name|B0
expr_stmt|;
name|qsysdep
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_ospeed
operator|=
name|B0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_SYSV_TERMIO
name|qsysdep
operator|->
name|snew
operator|.
name|c_cflag
operator|=
operator|(
name|qsysdep
operator|->
name|snew
operator|.
name|c_cflag
operator|&
operator|~
name|CBAUD
operator|)
operator||
name|B0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_POSIX_TERMIOS
operator|(
name|void
operator|)
name|cfsetospeed
argument_list|(
operator|&
name|qsysdep
operator|->
name|snew
argument_list|,
name|B0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fSalarm
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
name|usysdep_start_catch
argument_list|()
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|usalarm
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsetterminfodrain
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|&
name|qsysdep
operator|->
name|snew
argument_list|)
expr_stmt|;
block|}
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
comment|/* Let the port settle.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! HAVE_RESET_BUG */
if|if
condition|(
operator|!
name|fsserial_close
argument_list|(
name|qsysdep
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Close a direct port.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fsdirect_close
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdialer
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
return|return
name|fsserial_close
argument_list|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin dialing out on a modem port.  This opens the dialer device if    there is one.  */
end_comment

begin_function
name|boolean
name|fsysdep_modem_begin_dial
parameter_list|(
name|qconn
parameter_list|,
name|qdial
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdial
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCMODEM
comment|/* If we can tell the modem to obey modem control, do so.  */
block|{
name|int
name|iperm
decl_stmt|;
name|iperm
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCMODEM
argument_list|,
operator|&
name|iperm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCMODEM */
comment|/* If we supposed to toggle DTR, do so.  */
if|if
condition|(
name|qdial
operator|->
name|uuconf_fdtr_toggle
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCCDTR
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCCDTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|TIOCSDTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! defined (TIOCCDTR) */
if|if
condition|(
name|qsysdep
operator|->
name|fterminal
condition|)
block|{
name|sterminal
name|sbaud
decl_stmt|;
name|sbaud
operator|=
name|qsysdep
operator|->
name|snew
expr_stmt|;
if|#
directive|if
name|HAVE_BSD_TTY
name|sbaud
operator|.
name|stty
operator|.
name|sg_ispeed
operator|=
name|B0
expr_stmt|;
name|sbaud
operator|.
name|stty
operator|.
name|sg_ospeed
operator|=
name|B0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_SYSV_TERMIO
name|sbaud
operator|.
name|c_cflag
operator|=
operator|(
name|sbaud
operator|.
name|c_cflag
operator|&
operator|~
name|CBAUD
operator|)
operator||
name|B0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_POSIX_TERMIOS
operator|(
name|void
operator|)
name|cfsetospeed
argument_list|(
operator|&
name|sbaud
argument_list|,
name|B0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fsetterminfodrain
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|&
name|sbaud
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsetterminfo
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|&
name|qsysdep
operator|->
name|snew
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! defined (TIOCCDTR) */
if|if
condition|(
name|qdial
operator|->
name|uuconf_fdtr_toggle_wait
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsmodem_carrier
argument_list|(
name|qconn
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Open the dial device if there is one.  */
name|z
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_zdial_device
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zfree
decl_stmt|;
name|int
name|o
decl_stmt|;
name|qsysdep
operator|->
name|ohold
operator|=
name|qsysdep
operator|->
name|o
expr_stmt|;
name|zfree
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|!=
literal|'/'
condition|)
block|{
name|zfree
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|strlen
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfree
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|=
name|zfree
expr_stmt|;
block|}
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|z
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qsysdep
operator|->
name|o
operator|=
name|o
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Tell the port to require or not require carrier.  On BSD this uses    TIOCCAR and TIOCNCAR, which I assume are generally supported (it    can also use the LNOMDM bit supported by IS68K Unix).  On System V    it resets or sets CLOCAL.  We only require carrier if the port    supports it.  This will only be called with fcarrier TRUE if the    dialer supports carrier.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsmodem_carrier
parameter_list|(
name|qconn
parameter_list|,
name|fcarrier
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|boolean
name|fcarrier
decl_stmt|;
block|{
specifier|register
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|struct
name|uuconf_modem_port
modifier|*
name|qm
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|fterminal
condition|)
return|return
name|TRUE
return|;
name|qm
operator|=
operator|&
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
expr_stmt|;
if|if
condition|(
name|fcarrier
condition|)
block|{
if|if
condition|(
name|qm
operator|->
name|uuconf_fcarrier
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCCAR
comment|/* Tell the modem to pay attention to carrier.  */
if|if
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCCAR
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (TIOCCAR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* TIOCCAR */
if|#
directive|if
name|HAVE_BSD_TTY
ifdef|#
directive|ifdef
name|LNOMDM
comment|/* IS68K Unix uses a local LNOMDM bit.  */
block|{
name|int
name|iparam
decl_stmt|;
name|iparam
operator|=
name|LNOMDM
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCLBIC
argument_list|,
operator|&
name|iparam
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (TIOCLBIC, LNOMDM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* LNOMDM */
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
comment|/* Put the modem into nonlocal mode.  */
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't clear CLOCAL: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
block|}
comment|/* Turn on hardware flow control after turning on carrier.  We 	 don't do it until now because some modems don't assert the 	 right signals until they see carrier.  */
if|if
condition|(
operator|!
name|fsserial_hardflow
argument_list|(
name|qconn
argument_list|,
name|qm
operator|->
name|uuconf_fhardflow
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* Turn off any hardware flow control before turning off 	 carrier.  */
if|if
condition|(
operator|!
name|fsserial_hardflow
argument_list|(
name|qconn
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|TIOCNCAR
comment|/* Tell the modem to ignore carrier.  */
if|if
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCNCAR
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (TIOCNCAR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* TIOCNCAR */
if|#
directive|if
name|HAVE_BSD_TTY
ifdef|#
directive|ifdef
name|LNOMDM
comment|/* IS68K Unix uses a local LNOMDM bit.  */
block|{
name|int
name|iparam
decl_stmt|;
name|iparam
operator|=
name|LNOMDM
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCLBIS
argument_list|,
operator|&
name|iparam
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (TIOCLBIS, LNOMDM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* LNOMDM */
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
comment|/* Put the modem into local mode (ignore carrier) to start the chat 	 script.  */
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't set CLOCAL: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|HAVE_CLOCAL_BUG
comment|/* On SCO and AT&T UNIX PC you have to reopen the port.  */
block|{
name|int
name|onew
decl_stmt|;
name|onew
operator|=
name|open
argument_list|(
name|q
operator|->
name|zdevice
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|onew
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|q
operator|->
name|zdevice
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|q
operator|->
name|o
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
name|onew
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_CLOCAL_BUG */
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Tell the port to use hardware flow control.  There is no standard    mechanism for controlling this.  This implementation supports    CRTSCTS on SunOS, RTS/CTSFLOW on 386(ish) unix, CTSCD on the 3b1,    CCTS_OFLOW/CRTS_IFLOW on BSDI, TXADDCD/TXDELCD on AIX, and IRTS on    NCR Tower.  If you know how to do it on other systems, please    implement it and send me the patches.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_hardflow
parameter_list|(
name|qconn
parameter_list|,
name|fhardflow
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|boolean
name|fhardflow
decl_stmt|;
block|{
specifier|register
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|fterminal
condition|)
return|return
name|TRUE
return|;
comment|/* Don't do anything if we don't know what to do.  */
if|#
directive|if
name|HAVE_BSD_TTY
define|#
directive|define
name|HAVE_HARDFLOW
value|0
endif|#
directive|endif
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
if|#
directive|if
operator|!
name|HAVE_TXADDCD
ifndef|#
directive|ifndef
name|CRTSFL
ifndef|#
directive|ifndef
name|CRTSCTS
ifndef|#
directive|ifndef
name|CTSCD
ifndef|#
directive|ifndef
name|CCTS_OFLOW
ifndef|#
directive|ifndef
name|IRTS
define|#
directive|define
name|HAVE_HARDFLOW
value|0
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|HAVE_HARDFLOW
define|#
directive|define
name|HAVE_HARDFLOW
value|1
endif|#
directive|endif
if|#
directive|if
name|HAVE_HARDFLOW
if|if
condition|(
name|fhardflow
condition|)
block|{
if|#
directive|if
name|HAVE_TXADDCD
comment|/* The return value does not reliably indicate whether this 	 actually succeeded.  */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TXADDCD
argument_list|,
literal|"rts"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TXADDCD */
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
ifdef|#
directive|ifdef
name|CRTSFL
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|CRTSFL
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|RTSFLOW
operator||
name|CTSFLOW
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined (CRTSFL) */
ifdef|#
directive|ifdef
name|CRTSCTS
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|CRTSCTS
expr_stmt|;
endif|#
directive|endif
comment|/* defined (CRTSCTS) */
ifdef|#
directive|ifdef
name|CTSCD
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|CTSCD
expr_stmt|;
endif|#
directive|endif
comment|/* defined (CTSCD) */
ifdef|#
directive|ifdef
name|CCTS_OFLOW
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|CCTS_OFLOW
operator||
name|CRTS_IFLOW
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IRTS
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator||=
name|IRTS
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't enable hardware flow control: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* ! HAVE_TXADDCD */
block|}
else|else
block|{
if|#
directive|if
name|HAVE_TXADDCD
comment|/* The return value does not reliably indicate whether this 	 actually succeeded.  */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TXDELCD
argument_list|,
literal|"rts"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TXADDCD */
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
ifdef|#
directive|ifdef
name|CRTSFL
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|CRTSFL
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|RTSFLOW
operator||
name|CTSFLOW
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined (CRTSFL) */
ifdef|#
directive|ifdef
name|CRTSCTS
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|CRTSCTS
expr_stmt|;
endif|#
directive|endif
comment|/* defined (CRTSCTS) */
ifdef|#
directive|ifdef
name|CTSCD
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|CTSCD
expr_stmt|;
endif|#
directive|endif
comment|/* defined (CTSCD) */
ifdef|#
directive|ifdef
name|CCTS_OFLOW
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CCTS_OFLOW
operator||
name|CRTS_IFLOW
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IRTS
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&=
operator|~
name|IRTS
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't disable hardware flow control: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* ! HAVE_TXADDCD */
block|}
endif|#
directive|endif
comment|/* HAVE_HARDFLOW */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish dialing out on a modem by closing any dialer device and waiting    for carrier.  */
end_comment

begin_function
name|boolean
name|fsysdep_modem_end_dial
parameter_list|(
name|qconn
parameter_list|,
name|qdial
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdial
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_zdial_device
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|q
operator|->
name|o
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
name|q
operator|->
name|ohold
expr_stmt|;
block|}
if|if
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_fcarrier
operator|&&
name|qdial
operator|->
name|uuconf_fcarrier
condition|)
block|{
comment|/* Tell the port that we need carrier.  */
if|if
condition|(
operator|!
name|fsmodem_carrier
argument_list|(
name|qconn
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|TIOCWONLINE
comment|/* We know how to wait for carrier, so do so.  */
comment|/* If we already got a signal, just quit now.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* This bit of code handles signals just like fsysdep_conn_read 	 does.  See that function for a longer explanation.  */
comment|/* Use fsysdep_catch to handle a longjmp from the signal 	 handler.  */
name|fSalarm
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
comment|/* Start catching SIGALRM; normally we ignore it.  */
name|usysdep_start_catch
argument_list|()
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|usalarm
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|qdial
operator|->
name|uuconf_ccarrier_wait
argument_list|)
expr_stmt|;
comment|/* We really don't care if we get an error, since that will 	     probably just mean that TIOCWONLINE isn't supported in 	     which case there's nothing we can do anyhow.  If we get 	     SIGINT we want to keep waiting for carrier, because 	     SIGINT just means don't start any new sessions.  We don't 	     handle SIGINT correctly if we do a longjmp in the signal 	     handler; too bad.  */
while|while
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCWONLINE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
block|{
comment|/* Log the signal.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
operator|||
name|fSalarm
condition|)
break|break;
block|}
block|}
comment|/* Turn off the pending SIGALRM and ignore SIGALARM again.  */
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
comment|/* If we got a random signal, just return FALSE.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* If we timed out, give an error.  */
if|if
condition|(
name|fSalarm
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for carrier"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|#
directive|else
comment|/* ! defined (TIOCWONLINE) */
comment|/* Try to open the port again without using O_NDELAY.  In 	 principle, the open should delay until carrier is available. 	 This may not work on some systems, so we just ignore any 	 errors.  */
block|{
name|int
name|onew
decl_stmt|;
name|onew
operator|=
name|open
argument_list|(
name|q
operator|->
name|zdevice
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|onew
operator|>=
literal|0
condition|)
block|{
name|boolean
name|fbad
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|fbad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
name|fbad
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fbad
condition|)
block|{
name|iflags
operator|=
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflags
operator|<
literal|0
operator|||
operator|!
name|fsetterminfo
argument_list|(
name|onew
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
name|fbad
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fbad
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|q
operator|->
name|o
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
name|onew
expr_stmt|;
name|q
operator|->
name|iflags
operator|=
name|iflags
expr_stmt|;
if|#
directive|if
name|HAVE_TIOCSINUSE
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|onew
argument_list|,
name|TIOCSINUSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
endif|#
directive|endif
comment|/* ! defined (TIOCWONLINE) */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read data from a connection, with a timeout.  This routine handles    all types of connections, including TLI.     This function should return when we have read cmin characters or    the timeout has occurred.  We have to work a bit to get Unix to do    this efficiently on a terminal.  The simple implementation    schedules a SIGALRM signal and then calls read; if there is a    single character available, the call to read will return    immediately, so there must be a loop which terminates when the    SIGALRM is delivered or the correct number of characters has been    read.  This can be very inefficient with a fast CPU or a low baud    rate (or both!), since each call to read may return only one or two    characters.     Under POSIX or System V, we can specify a minimum number of    characters to read, so there is no serious trouble.     Under BSD, we figure out how many characters we have left to read,    how long it will take for them to arrive at the current baud rate,    and sleep that long.     Doing this with a timeout and avoiding all possible race conditions    get very hairy, though.  Basically, we're going to schedule a    SIGALRM for when the timeout expires.  I don't really want to do a    longjmp in the SIGALRM handler, though, because that may lose data.    Therefore, I have the signal handler set a variable.  However, this    means that there will be a span of time between the time the code    checks the variable and the time it calls the read system call; if    the SIGALRM occurs during that time, the read might hang forever.    To avoid this, the SIGALRM handler not only sets a global variable,    it also schedules another SIGALRM for one second in the future    (POSIX specifies that a signal handler is permitted to safely call    alarm).  To avoid getting a continual sequence of SIGALRM    interrupts, we change the signal handler to ignore SIGALRM when    we're about to exit the function.  This means that every time we    execute fsysdep_conn_read we make at least five system calls.  It's    the best I've been able to come up with, though.     When fsysdep_conn_read finishes, there will be no SIGALRM scheduled    and SIGALRM will be ignored.  */
end_comment

begin_function
name|boolean
name|fsysdep_conn_read
parameter_list|(
name|qconn
parameter_list|,
name|zbuf
parameter_list|,
name|pclen
parameter_list|,
name|cmin
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
name|size_t
name|cmin
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
name|CATCH_PROTECT
name|size_t
name|cwant
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
specifier|register
name|struct
name|ssysdep_conn
modifier|*
specifier|const
name|q
init|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
decl_stmt|;
name|int
name|cwouldblock
decl_stmt|;
name|cwant
operator|=
operator|*
name|pclen
expr_stmt|;
operator|*
name|pclen
operator|=
literal|0
expr_stmt|;
comment|/* Guard against a bad timeout.  We return TRUE when a timeout      expires.  It is possible to get a negative timeout here because      the calling code does not check user supplied timeouts for      plausibility.  */
if|if
condition|(
name|ctimeout
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* We want to do a blocking read.  */
if|if
condition|(
operator|!
name|fsblock
argument_list|(
name|q
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fSalarm
operator|=
name|FALSE
expr_stmt|;
comment|/* We're going to set up an alarm signal to last for the entire      read.  If the read system call cannot be interrupted, the signal      handler will do a longjmp causing fsysdep_catch (a macro) to      return FALSE.  We handle that here.  If read can be interrupted,      fsysdep_catch will be defined to TRUE.  */
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
comment|/* Prepare to catch SIGALRM and schedule the signal.  */
name|usysdep_start_catch
argument_list|()
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|usalarm
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|ctimeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We caught a signal.  We don't actually have to do anything, 	 as all the appropriate checks are made at the start of the 	 following loop.  */
block|}
name|fret
operator|=
name|FALSE
expr_stmt|;
name|cwouldblock
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|cgot
decl_stmt|;
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|||
name|HAVE_POSIX_TERMIOS
comment|/* If we can tell the terminal not to return until we have a 	 certain number of characters, do so.  */
if|if
condition|(
name|q
operator|->
name|fterminal
condition|)
block|{
name|int
name|csetmin
decl_stmt|;
comment|/* I'm not that confident about setting MIN to values larger 	     than 127, although up to 255 would probably work.  */
if|if
condition|(
name|cmin
operator|<
literal|127
condition|)
name|csetmin
operator|=
name|cmin
expr_stmt|;
else|else
name|csetmin
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|csetmin
operator|!=
name|cSmin
condition|)
block|{
name|q
operator|->
name|snew
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
name|csetmin
expr_stmt|;
while|while
condition|(
operator|!
name|fsetterminfo
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|||
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
block|{
name|int
name|ierr
decl_stmt|;
comment|/* We turn off the signal before reporting the 			 error to minimize any problems with 			 interrupted system calls.  */
name|ierr
operator|=
name|errno
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't set MIN for terminal: %s"
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fSalarm
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out when setting MIN to %d; retrying"
argument_list|,
name|csetmin
argument_list|)
expr_stmt|;
name|fSalarm
operator|=
name|FALSE
expr_stmt|;
name|alarm
argument_list|(
name|ctimeout
argument_list|)
expr_stmt|;
block|}
block|}
name|cSmin
operator|=
name|csetmin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO || HAVE_POSIX_TERMIOS */
comment|/* If we've received a signal, get out now.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
break|break;
comment|/* If we've already gotten a SIGALRM, get out with whatever 	 we've accumulated.  */
if|if
condition|(
name|fSalarm
condition|)
block|{
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Right here is the race condition which we avoid by having the 	 SIGALRM handler schedule another SIGALRM.  */
if|#
directive|if
name|HAVE_TLI
if|if
condition|(
name|q
operator|->
name|ftli
condition|)
block|{
name|int
name|iflags
decl_stmt|;
name|cgot
operator|=
name|t_rcv
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zbuf
argument_list|,
name|cwant
argument_list|,
operator|&
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|<
literal|0
operator|&&
name|t_errno
operator|!=
name|TSYSERR
condition|)
block|{
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
if|if
condition|(
name|freport
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_rcv: %s"
argument_list|,
operator|(
name|t_errno
operator|>=
literal|0
operator|&&
name|t_errno
operator|<
name|t_nerr
condition|?
name|t_errlist
index|[
name|t_errno
index|]
else|:
literal|"unknown TLI error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
endif|#
directive|endif
name|cgot
operator|=
name|read
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zbuf
argument_list|,
name|cwant
argument_list|)
expr_stmt|;
comment|/* If the read returned an error, check for signals.  */
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
comment|/* Log the signal.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fSalarm
condition|)
block|{
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
break|break;
block|}
comment|/* If read returned an error, get out.  We just ignore EINTR 	 here, since it must be from some signal we don't care about. 	 If the read returned 0 then the line must have been hung up 	 (normally we would have received SIGHUP, but we can't count 	 on that).  We turn off the signals before calling ulog to 	 reduce problems with interrupted system calls.  */
if|if
condition|(
name|cgot
operator|>
literal|0
condition|)
name|cwouldblock
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cgot
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
name|cgot
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cgot
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
name|cwouldblock
operator|<
literal|2
condition|)
block|{
comment|/* Incomprehensibly, on some systems the read will 		 return EWOULDBLOCK even though the descriptor has 		 been set to blocking mode.  We permit the read call 		 to do this twice in a row, and then error out.  We 		 don't want to permit an arbitrary number of 		 EWOULDBLOCK errors, since that could hang us up 		 indefinitely.  */
operator|++
name|cwouldblock
expr_stmt|;
name|cgot
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|ierr
decl_stmt|;
name|ierr
operator|=
name|errno
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
if|if
condition|(
name|freport
condition|)
block|{
if|if
condition|(
name|cgot
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Line disconnected"
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
block|}
name|cwant
operator|-=
name|cgot
expr_stmt|;
if|if
condition|(
name|cgot
operator|>=
name|cmin
condition|)
name|cmin
operator|=
literal|0
expr_stmt|;
else|else
name|cmin
operator|-=
name|cgot
expr_stmt|;
name|zbuf
operator|+=
name|cgot
expr_stmt|;
operator|*
name|pclen
operator|+=
name|cgot
expr_stmt|;
comment|/* If we have enough data, get out now.  */
if|if
condition|(
name|cmin
operator|==
literal|0
condition|)
block|{
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_BSD_TTY
comment|/* We still want more data, so sleep long enough for the rest of 	 it to arrive.  We don't this for System V or POSIX because 	 setting MIN is good enough (we can't sleep longer than it 	 takes to get MAX_INPUT characters anyhow).  	 The baud rate is approximately 10 times the number of 	 characters which will arrive in one second, so the number of 	 milliseconds to sleep == 	 characters * (milliseconds / character) == 	 characters * (1000 * (seconds / character)) == 	 characters * (1000 * (1 / (baud / 10))) == 	 characters * (10000 / baud)  	 We arbitrarily reduce the sleep amount by 10 milliseconds to 	 attempt to account for the amount of time it takes to set up 	 the sleep.  This is how long it takes to get half a character 	 at 19200 baud.  We then don't bother to sleep for less than 	 10 milliseconds.  We don't sleep if the read was interrupted.  	 We use select to sleep.  It would be easy to use poll as 	 well, but it's unlikely that any system with BSD ttys would 	 have poll but not select.  Using select avoids hassles with 	 the pending SIGALRM; if it hits the select will be 	 interrupted, and otherwise the select will not affect it.  */
if|#
directive|if
operator|!
name|HAVE_SELECT
error|#
directive|error
error|This code requires select; feel free to extend it
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|fterminal
operator|&&
name|cmin
operator|>
literal|1
operator|&&
name|cgot
operator|>
literal|0
condition|)
block|{
name|int
name|csleepchars
decl_stmt|;
name|int
name|isleep
decl_stmt|;
comment|/* We don't try to read all the way up to MAX_INPUT, 	     since that might drop a character.  */
if|if
condition|(
name|cmin
operator|<=
name|MAX_INPUT
operator|-
literal|10
condition|)
name|csleepchars
operator|=
name|cmin
expr_stmt|;
else|else
name|csleepchars
operator|=
name|MAX_INPUT
operator|-
literal|10
expr_stmt|;
name|isleep
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|csleepchars
operator|*
literal|10000L
operator|)
operator|/
operator|(
name|q
operator|->
name|ibaud
condition|?
name|q
operator|->
name|ibaud
else|:
operator|(
name|long
operator|)
literal|1200
operator|)
argument_list|)
expr_stmt|;
name|isleep
operator|-=
literal|10
expr_stmt|;
if|if
condition|(
name|isleep
operator|>
literal|10
condition|)
block|{
name|struct
name|timeval
name|s
decl_stmt|;
name|s
operator|.
name|tv_sec
operator|=
name|isleep
operator|/
literal|1000
expr_stmt|;
name|s
operator|.
name|tv_usec
operator|=
operator|(
name|isleep
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
comment|/* Some versions of select take a pointer to an int, 		 while some take a pointer to an fd_set.  I just cast 		 the arguments to a generic pointer, and assume that 		 any machine which distinguishes int * from fd_set * 		 (I would be amazed if there are any such machines) 		 have an appropriate prototype somewhere or other.  */
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Here either the select finished sleeping or we got a 		 SIGALRM.  If the latter occurred, fSalarm was set to 		 TRUE; it will be checked at the top of the loop.  */
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
block|}
comment|/* Turn off the pending SIGALRM and return.  */
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Read from a port with separate read/write file descriptors.  */
end_comment

begin_function
name|boolean
name|fsdouble_read
parameter_list|(
name|qconn
parameter_list|,
name|zbuf
parameter_list|,
name|pclen
parameter_list|,
name|cmin
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
name|size_t
modifier|*
name|pclen
decl_stmt|;
name|size_t
name|cmin
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|qsysdep
operator|->
name|ord
expr_stmt|;
return|return
name|fsysdep_conn_read
argument_list|(
name|qconn
argument_list|,
name|zbuf
argument_list|,
name|pclen
argument_list|,
name|cmin
argument_list|,
name|ctimeout
argument_list|,
name|freport
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write data to a connection.  This routine handles all types of    connections, including TLI.  */
end_comment

begin_function
name|boolean
name|fsysdep_conn_write
parameter_list|(
name|qconn
parameter_list|,
name|zwrite
parameter_list|,
name|cwrite
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|size_t
name|cwrite
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|int
name|czero
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
comment|/* We want blocking writes here.  */
if|if
condition|(
operator|!
name|fsblock
argument_list|(
name|q
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|czero
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cwrite
operator|>
literal|0
condition|)
block|{
name|int
name|cdid
decl_stmt|;
comment|/* Loop until we don't get an interrupt.  */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* If we've received a signal, don't continue.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|HAVE_TLI
if|if
condition|(
name|q
operator|->
name|ftli
condition|)
block|{
name|cdid
operator|=
name|t_snd
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zwrite
argument_list|,
name|cwrite
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdid
operator|<
literal|0
operator|&&
name|t_errno
operator|!=
name|TSYSERR
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_snd: %s"
argument_list|,
operator|(
name|t_errno
operator|>=
literal|0
operator|&&
name|t_errno
operator|<
name|t_nerr
condition|?
name|t_errlist
index|[
name|t_errno
index|]
else|:
literal|"unknown TLI error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
endif|#
directive|endif
name|cdid
operator|=
name|write
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zwrite
argument_list|,
name|cwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdid
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
break|break;
comment|/* We were interrupted by a signal.  Log it.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENODATA
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cdid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cdid
operator|==
literal|0
condition|)
block|{
comment|/* On some systems write will return 0 if carrier is lost. 	     If we fail to write anything ten times in a row, we 	     assume that this has happened.  This is hacked in like 	     this because there seems to be no reliable way to tell 	     exactly why the write returned 0.  */
operator|++
name|czero
expr_stmt|;
if|if
condition|(
name|czero
operator|>=
literal|10
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Line disconnected"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|czero
operator|=
literal|0
expr_stmt|;
name|cwrite
operator|-=
name|cdid
expr_stmt|;
name|zwrite
operator|+=
name|cdid
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write to a port with separate read/write file descriptors.  */
end_comment

begin_function
name|boolean
name|fsdouble_write
parameter_list|(
name|qconn
parameter_list|,
name|zwrite
parameter_list|,
name|cwrite
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|size_t
name|cwrite
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|qsysdep
operator|->
name|ord
expr_stmt|;
if|if
condition|(
operator|!
name|fsblock
argument_list|(
name|qsysdep
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|qsysdep
operator|->
name|o
operator|=
name|qsysdep
operator|->
name|owr
expr_stmt|;
return|return
name|fsysdep_conn_write
argument_list|(
name|qconn
argument_list|,
name|zwrite
argument_list|,
name|cwrite
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The fsysdep_conn_io routine is supposed to both read and write data    until it has either filled its read buffer or written out all the    data it was given.  This lets us write out large packets without    losing incoming data.  It handles all types of connections,    including TLI.  */
end_comment

begin_function
name|boolean
name|fsysdep_conn_io
parameter_list|(
name|qconn
parameter_list|,
name|zwrite
parameter_list|,
name|pcwrite
parameter_list|,
name|zread
parameter_list|,
name|pcread
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|size_t
modifier|*
name|pcwrite
decl_stmt|;
name|char
modifier|*
name|zread
decl_stmt|;
name|size_t
modifier|*
name|pcread
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|size_t
name|cwrite
decl_stmt|,
name|cread
decl_stmt|;
name|int
name|czero
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|cwrite
operator|=
operator|*
name|pcwrite
expr_stmt|;
operator|*
name|pcwrite
operator|=
literal|0
expr_stmt|;
name|cread
operator|=
operator|*
name|pcread
expr_stmt|;
operator|*
name|pcread
operator|=
literal|0
expr_stmt|;
name|czero
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|cgot
decl_stmt|,
name|cdid
decl_stmt|;
name|size_t
name|cdo
decl_stmt|;
comment|/* This used to always use nonblocking writes, but it turns out 	 that some systems don't support them on terminals.  	 The current algorithm is: 	     loop: 	       unblocked read 	       if read buffer full, return 	       if nothing to write, return 	       if HAVE_UNBLOCKED_WRITES 	         write all data 	       else 	         write up to SINGLE_WRITE bytes 	       if all data written, return 	       if no data written 	         if select works 		   select on the write descriptor with a ten second timeout 		 else 		   blocked write of one byte with a ten second alarm  	 This algorithm should work whether the system supports 	 unblocked writes on terminals or not.  If the system supports 	 unblocked writes but HAVE_UNBLOCKED_WRITES is 0, then it will 	 call write more often than it needs to.  If the system does 	 not support unblocked writes but HAVE_UNBLOCKED_WRITES is 1, 	 then the write may hang so long that incoming data is lost. 	 This is actually possible at high baud rates on any system 	 when a blocking write is done; there is no solution, except 	 hardware handshaking.  	 If we were not able to write any data, then we need to block 	 until we can write something.  The code used to simply do a 	 blocking write.  However, that fails when a bidirectional 	 protocol is permitted to push out enough bytes to fill the 	 entire pipe between the two communicating uucico processes. 	 They can both block on writing, because neither is reading.  	 In this case, we use select.  We could select on both the 	 read and write descriptor, but on some systems that would 	 lead to calling read on each byte, which would be very 	 inefficient.  Instead, we select only on the write 	 descriptor.  After the select succeeds or times out, we retry 	 the read.  	 Of course, some systems don't have select, and on some 	 systems that have it it doesn't work on terminal devices.  If 	 we can't use select, then we do a blocked write of a single 	 byte after setting an alarm.  We only write a single byte to 	 avoid any confusion as to whether or not the byte was 	 actually written.  */
comment|/* If we are running on standard input, we switch the file 	 descriptors by hand.  */
if|if
condition|(
name|q
operator|->
name|ord
operator|>=
literal|0
condition|)
name|q
operator|->
name|o
operator|=
name|q
operator|->
name|ord
expr_stmt|;
comment|/* Do an unblocked read.  */
if|if
condition|(
operator|!
name|fsblock
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Loop until we get something (error or data) other than an 	 acceptable EINTR.  */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* If we've received a signal, don't continue.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|HAVE_TLI
if|if
condition|(
name|q
operator|->
name|ftli
condition|)
block|{
name|int
name|iflags
decl_stmt|;
name|cgot
operator|=
name|t_rcv
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zread
argument_list|,
name|cread
argument_list|,
operator|&
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|t_errno
operator|==
name|TNODATA
condition|)
name|errno
operator|=
name|EAGAIN
expr_stmt|;
elseif|else
if|if
condition|(
name|t_errno
operator|!=
name|TSYSERR
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_rcv: %s"
argument_list|,
operator|(
name|t_errno
operator|>=
literal|0
operator|&&
name|t_errno
operator|<
name|t_nerr
condition|?
name|t_errlist
index|[
name|t_errno
index|]
else|:
literal|"unknown TLI error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
name|cgot
operator|=
name|read
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zread
argument_list|,
name|cread
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
break|break;
comment|/* We got interrupted by a signal.  Log it.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENODATA
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cgot
operator|=
literal|0
expr_stmt|;
block|}
name|cread
operator|-=
name|cgot
expr_stmt|;
name|zread
operator|+=
name|cgot
expr_stmt|;
operator|*
name|pcread
operator|+=
name|cgot
expr_stmt|;
comment|/* If we've filled the read buffer, or we have nothing left to 	 write, return out.  */
if|if
condition|(
name|cread
operator|==
literal|0
operator|||
name|cwrite
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* The port is currently unblocked.  Do a write.  */
name|cdo
operator|=
name|cwrite
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_UNBLOCKED_WRITES
if|if
condition|(
name|q
operator|->
name|fterminal
operator|&&
name|cdo
operator|>
name|SINGLE_WRITE
condition|)
name|cdo
operator|=
name|SINGLE_WRITE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|owr
operator|>=
literal|0
condition|)
name|q
operator|->
name|o
operator|=
name|q
operator|->
name|owr
expr_stmt|;
comment|/* Loop until we get something besides EINTR.  */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* If we've received a signal, don't continue.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|HAVE_TLI
if|if
condition|(
name|q
operator|->
name|ftli
condition|)
block|{
name|cdid
operator|=
name|t_snd
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zwrite
argument_list|,
name|cdo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|t_errno
operator|==
name|TFLOW
condition|)
name|errno
operator|=
name|EAGAIN
expr_stmt|;
elseif|else
if|if
condition|(
name|t_errno
operator|!=
name|TSYSERR
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_snd: %s"
argument_list|,
operator|(
name|t_errno
operator|>=
literal|0
operator|&&
name|t_errno
operator|<
name|t_nerr
condition|?
name|t_errlist
index|[
name|t_errno
index|]
else|:
literal|"unknown TLI error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
name|cdid
operator|=
name|write
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zwrite
argument_list|,
name|cdo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdid
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
break|break;
comment|/* We got interrupted by a signal.  Log it.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cdid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENODATA
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cdid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cdid
operator|>
literal|0
condition|)
block|{
comment|/* We wrote some data.  If we wrote everything, return out. 	     Otherwise loop around and do another read.  */
name|cwrite
operator|-=
name|cdid
expr_stmt|;
name|zwrite
operator|+=
name|cdid
expr_stmt|;
operator|*
name|pcwrite
operator|+=
name|cdid
expr_stmt|;
if|if
condition|(
name|cwrite
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|czero
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_SELECT
name|struct
name|timeval
name|stime
decl_stmt|;
name|int
name|imask
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* We didn't write any data.  Call select.  We use a timeout              long enough for 1024 bytes to be sent. 	       secs/kbyte == (1024 bytes/kbyte * 10 bits/byte) / baud bits/sec 	       usecs/kbyte == (((1024 bytes/kbyte * 1000000 usecs/sec) 	                        / baud bits/sec) 			       * 10 bits/byte) 	     */
name|stime
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
literal|10240
operator|/
operator|(
name|q
operator|->
name|ibaud
condition|?
name|q
operator|->
name|ibaud
else|:
operator|(
name|long
operator|)
literal|1200
operator|)
expr_stmt|;
name|stime
operator|.
name|tv_usec
operator|=
operator|(
operator|(
operator|(
operator|(
name|long
operator|)
literal|1024000000
operator|/
operator|(
name|q
operator|->
name|ibaud
condition|?
name|q
operator|->
name|ibaud
else|:
operator|(
name|long
operator|)
literal|1200
operator|)
operator|)
operator|*
operator|(
name|long
operator|)
literal|10
operator|)
operator|%
operator|(
name|long
operator|)
literal|1000000
operator|)
expr_stmt|;
name|imask
operator|=
literal|1
operator|<<
name|q
operator|->
name|o
expr_stmt|;
if|if
condition|(
name|imask
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsysdep_conn_io: File descriptors too large"
argument_list|)
expr_stmt|;
comment|/* If we've received a signal, don't continue.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fsysdep_conn_io: Calling select"
argument_list|)
expr_stmt|;
comment|/* We don't bother to loop on EINTR.  If we get a signal, we              just loop around and try the read and write again.  */
name|c
operator|=
name|select
argument_list|(
name|q
operator|->
name|o
operator|+
literal|1
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|imask
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
block|{
comment|/* We got interrupted by a signal.  Log it.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
comment|/* The select either discovered that we could write                  something, or it timed out.  Either way, we go around                  the main read/write loop again.  */
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_SELECT */
block|{
name|int
name|ierr
decl_stmt|;
comment|/* Either the select failed for some reason other than 	      	 EINTR, or the system does not support select at all. 	      	 Fall back on a timed write.  We don't worry about why 	      	 the select might have failed, we just assume that it 	      	 will not succeed on this descriptor.  */
if|#
directive|if
name|HAVE_RESTARTABLE_SYSCALLS
comment|/* If HAVE_RESTARTABLE_SYSCALLS, then receiving an alarm                  signal in the middle of a write will not cause the                  write to return EINTR, and the only way to interrupt                  the write is to longjmp out of it (see sysh.unx).                  That is unreliable, because it means that we won't                  know whether the byte was actually written or not.                  However, I believe that the only system on which we                  need to do this longjmp is BSD 4.2, and that system                  supports select, so we should never execute this                  case.  */
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fsysdep_conn_io: Unsupported case; see code"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|ord
operator|>=
literal|0
condition|)
name|q
operator|->
name|o
operator|=
name|q
operator|->
name|ord
expr_stmt|;
if|if
condition|(
operator|!
name|fsblock
argument_list|(
name|q
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fsysdep_conn_io: Blocking write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|owr
operator|>=
literal|0
condition|)
name|q
operator|->
name|o
operator|=
name|q
operator|->
name|owr
expr_stmt|;
comment|/* If we've received a signal, don't continue.  */
if|if
condition|(
name|FGOT_QUIT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* Start up an alarm to interrupt the write.  Note that                  we don't need to use the catch stuff, since we know                  that HAVE_RESTARTABLE_SYSCALLS is 0.  */
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|usalarm
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|long
operator|)
literal|10240
operator|/
operator|(
name|q
operator|->
name|ibaud
condition|?
name|q
operator|->
name|ibaud
else|:
operator|(
name|long
operator|)
literal|1200
operator|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* There is a race condition here: on a severely loaded                  system, we could get the alarm before we start the                  write call.  This would not be a disaster; often the                  write will succeed anyhow.  */
if|#
directive|if
name|HAVE_TLI
if|if
condition|(
name|q
operator|->
name|ftli
condition|)
block|{
name|cdid
operator|=
name|t_snd
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zwrite
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdid
operator|<
literal|0
operator|&&
name|t_errno
operator|!=
name|TSYSERR
condition|)
block|{
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_snd: %s"
argument_list|,
operator|(
name|t_errno
operator|>=
literal|0
operator|&&
name|t_errno
operator|<
name|t_nerr
condition|?
name|t_errlist
index|[
name|t_errno
index|]
else|:
literal|"unknown TLI error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
endif|#
directive|endif
name|cdid
operator|=
name|write
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|zwrite
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ierr
operator|=
name|errno
expr_stmt|;
comment|/* Note that we don't really care whether the write                  finished because the byte was written out or whether                  it finished because the alarm was triggered.  Either                  way, we are going to loop around and try another                  read.  */
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ierr
operator|==
name|EINTR
condition|)
block|{
comment|/* We got interrupted by a signal.  Log it.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cdid
operator|==
literal|0
condition|)
block|{
comment|/* On some systems write will return 0 if carrier is 		     lost.  If we fail to write anything ten times in 		     a row, we assume that this has happened.  This is 		     hacked in like this because there seems to be no 		     reliable way to tell exactly why the write 		     returned 0.  */
operator|++
name|czero
expr_stmt|;
if|if
condition|(
name|czero
operator|>=
literal|10
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Line disconnected"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|cwrite
operator|-=
name|cdid
expr_stmt|;
name|zwrite
operator|+=
name|cdid
expr_stmt|;
operator|*
name|pcwrite
operator|+=
name|cdid
expr_stmt|;
name|czero
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a break character to a serial port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_break
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|#
directive|if
name|HAVE_BSD_TTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCSBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCCBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
if|#
directive|if
name|HAVE_SYSV_TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TCSBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO */
if|#
directive|if
name|HAVE_POSIX_TERMIOS
return|return
name|tcsendbreak
argument_list|(
name|q
operator|->
name|o
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_POSIX_TERMIOS */
block|}
end_function

begin_comment
comment|/* Send a break character to a stdin port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsstdin_break
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|qsysdep
operator|->
name|owr
expr_stmt|;
return|return
name|fsserial_break
argument_list|(
name|qconn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the setting of a serial port.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fsserial_set
parameter_list|(
name|qconn
parameter_list|,
name|tparity
parameter_list|,
name|tstrip
parameter_list|,
name|txonxoff
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|enum
name|tparitysetting
name|tparity
decl_stmt|;
name|enum
name|tstripsetting
name|tstrip
decl_stmt|;
name|enum
name|txonxoffsetting
name|txonxoff
decl_stmt|;
block|{
specifier|register
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|boolean
name|fchanged
decl_stmt|,
name|fdo
decl_stmt|;
name|int
name|iset
init|=
literal|0
decl_stmt|;
name|int
name|iclear
init|=
literal|0
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|fterminal
condition|)
return|return
name|TRUE
return|;
name|fchanged
operator|=
name|FALSE
expr_stmt|;
comment|/* Set the parity for output characters.  */
if|#
directive|if
name|HAVE_BSD_TTY
comment|/* This will also cause parity detection on input characters.  */
name|fdo
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|tparity
condition|)
block|{
case|case
name|PARITYSETTING_DEFAULT
case|:
break|break;
case|case
name|PARITYSETTING_NONE
case|:
if|#
directive|if
name|HAVE_PARITY_BUG
comment|/* The Sony NEWS mishandles this for some reason.  */
name|iset
operator|=
literal|0
expr_stmt|;
name|iclear
operator|=
name|ANYP
expr_stmt|;
else|#
directive|else
name|iset
operator|=
name|ANYP
expr_stmt|;
name|iclear
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PARITYSETTING_EVEN
case|:
name|iset
operator|=
name|EVENP
expr_stmt|;
name|iclear
operator|=
name|ODDP
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PARITYSETTING_ODD
case|:
name|iset
operator|=
name|ODDP
expr_stmt|;
name|iclear
operator|=
name|EVENP
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PARITYSETTING_MARK
case|:
case|case
name|PARITYSETTING_SPACE
case|:
comment|/* Not supported.  */
break|break;
block|}
if|if
condition|(
name|fdo
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&
name|iset
operator|)
operator|!=
name|iset
operator|||
operator|(
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&
name|iclear
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator||=
name|iset
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&=
operator|~
name|iclear
expr_stmt|;
name|fchanged
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* ! HAVE_BSD_TTY */
name|fdo
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|tparity
condition|)
block|{
case|case
name|PARITYSETTING_DEFAULT
case|:
break|break;
case|case
name|PARITYSETTING_NONE
case|:
name|iset
operator|=
name|CS8
expr_stmt|;
name|iclear
operator|=
name|PARENB
operator||
name|PARODD
operator||
operator|(
name|CSIZE
operator|&
operator|~
name|CS8
operator|)
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PARITYSETTING_EVEN
case|:
name|iset
operator|=
name|PARENB
operator||
name|CS7
expr_stmt|;
name|iclear
operator|=
name|PARODD
operator||
operator|(
name|CSIZE
operator|&
operator|~
name|CS7
operator|)
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PARITYSETTING_ODD
case|:
name|iset
operator|=
name|PARENB
operator||
name|PARODD
operator||
name|CS7
expr_stmt|;
name|iclear
operator|=
name|CSIZE
operator|&
operator|~
name|CS7
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PARITYSETTING_MARK
case|:
case|case
name|PARITYSETTING_SPACE
case|:
comment|/* Not supported.  */
break|break;
block|}
if|if
condition|(
name|fdo
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&
name|iset
operator|)
operator|!=
name|iset
operator|||
operator|(
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&
name|iclear
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator||=
name|iset
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&=
operator|~
name|iclear
expr_stmt|;
name|fchanged
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ! HAVE_BSD_TTY */
comment|/* Set whether input characters are stripped to seven bits.  */
if|#
directive|if
name|HAVE_BSD_TTY
ifdef|#
directive|ifdef
name|LPASS8
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|LPASS8
expr_stmt|;
if|if
condition|(
name|tstrip
operator|==
name|STRIPSETTING_EIGHTBITS
condition|)
block|{
name|i
operator|=
name|LPASS8
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCLBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tstrip
operator|==
name|STRIPSETTING_SEVENBITS
condition|)
block|{
name|i
operator|=
name|LPASS8
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCLBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|#
directive|else
comment|/* ! HAVE_BSD_TTY */
name|fdo
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|tstrip
condition|)
block|{
case|case
name|STRIPSETTING_DEFAULT
case|:
break|break;
case|case
name|STRIPSETTING_EIGHTBITS
case|:
name|iset
operator|=
literal|0
expr_stmt|;
name|iclear
operator|=
name|ISTRIP
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|STRIPSETTING_SEVENBITS
case|:
name|iset
operator|=
name|ISTRIP
expr_stmt|;
name|iclear
operator|=
literal|0
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fdo
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&
name|iset
operator|)
operator|!=
name|iset
operator|||
operator|(
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&
name|iclear
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator||=
name|iset
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&=
operator|~
name|iclear
expr_stmt|;
name|fchanged
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ! HAVE_BSD_TTY */
comment|/* Set XON/XOFF handshaking.  */
if|#
directive|if
name|HAVE_BSD_TTY
name|fdo
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|txonxoff
condition|)
block|{
case|case
name|XONXOFF_DEFAULT
case|:
break|break;
case|case
name|XONXOFF_OFF
case|:
name|iset
operator|=
name|RAW
expr_stmt|;
name|iclear
operator|=
name|TANDEM
operator||
name|CBREAK
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|XONXOFF_ON
case|:
name|iset
operator|=
name|CBREAK
operator||
name|TANDEM
expr_stmt|;
name|iclear
operator|=
name|RAW
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fdo
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&
name|iset
operator|)
operator|!=
name|iset
operator|||
operator|(
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&
name|iclear
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator||=
name|iset
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&=
operator|~
name|iclear
expr_stmt|;
name|fchanged
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* ! HAVE_BSD_TTY */
name|fdo
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|txonxoff
condition|)
block|{
case|case
name|XONXOFF_DEFAULT
case|:
break|break;
case|case
name|XONXOFF_OFF
case|:
name|iset
operator|=
literal|0
expr_stmt|;
name|iclear
operator|=
name|IXON
operator||
name|IXOFF
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|XONXOFF_ON
case|:
ifdef|#
directive|ifdef
name|CRTSCTS
if|#
directive|if
name|HAVE_POSIX_TERMIOS
comment|/* This is system dependent, but I haven't figured out a good 	 way around it yet.  If we are doing hardware flow control, we 	 don't send XON/XOFF characters but we do recognize them.  */
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&
name|CRTSCTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|iset
operator|=
name|IXON
expr_stmt|;
name|iclear
operator|=
name|IXOFF
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* HAVE_POSIX_TERMIOS */
endif|#
directive|endif
comment|/* defined (CRTSCTS) */
ifdef|#
directive|ifdef
name|CRTSFL
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|c_cflag
operator|&
name|CRTSFL
operator|)
operator|!=
literal|0
condition|)
block|{
name|iset
operator|=
name|IXON
expr_stmt|;
name|iclear
operator|=
name|IXOFF
expr_stmt|;
comment|/* SCO says we cant have CRTSFL **and** RTSFLOW/CTSFLOW */
ifdef|#
directive|ifdef
name|RTSFLOW
name|iclear
operator||=
name|RTSFLOW
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CTSFLOW
name|iclear
operator||=
name|CTSFLOW
expr_stmt|;
endif|#
directive|endif
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* defined(CRTSFL) */
name|iset
operator|=
name|IXON
operator||
name|IXOFF
expr_stmt|;
name|iclear
operator|=
literal|0
expr_stmt|;
name|fdo
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fdo
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&
name|iset
operator|)
operator|!=
name|iset
operator|||
operator|(
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&
name|iclear
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator||=
name|iset
expr_stmt|;
name|q
operator|->
name|snew
operator|.
name|c_iflag
operator|&=
operator|~
name|iclear
expr_stmt|;
name|fchanged
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ! HAVE_BSD_TTY */
if|if
condition|(
name|fchanged
condition|)
block|{
if|if
condition|(
operator|!
name|fsetterminfodrain
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|q
operator|->
name|snew
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't change terminal settings: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
name|HAVE_BSD_TTY
if|if
condition|(
name|txonxoff
operator|==
name|XONXOFF_ON
operator|&&
operator|(
name|q
operator|->
name|snew
operator|.
name|stty
operator|.
name|sg_flags
operator|&
name|ANYP
operator|)
operator|==
name|ANYP
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* At least on Ultrix, we seem to have to set LLITOUT and 	 LPASS8.  This shouldn't foul things up anywhere else.  As far 	 as I can tell, this has to be done after setting the terminal 	 into cbreak mode, not before.  */
ifndef|#
directive|ifndef
name|LLITOUT
define|#
directive|define
name|LLITOUT
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LPASS8
define|#
directive|define
name|LPASS8
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LAUTOFLOW
define|#
directive|define
name|LAUTOFLOW
value|0
endif|#
directive|endif
name|i
operator|=
name|LLITOUT
operator||
name|LPASS8
operator||
name|LAUTOFLOW
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TIOCLBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_STRIP_BUG
comment|/* Ultrix 4.0 has a peculiar problem: setting CBREAK always 	 causes input characters to be stripped.  I hope this does not 	 apply to other BSD systems.  It is possible to work around 	 this by using the termio call.  I wish this sort of stuff was 	 not necessary!!!  */
block|{
name|struct
name|termio
name|s
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|s
operator|.
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|q
operator|->
name|o
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_STRIP_BUG */
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Change settings of a stdin port.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsstdin_set
parameter_list|(
name|qconn
parameter_list|,
name|tparity
parameter_list|,
name|tstrip
parameter_list|,
name|txonxoff
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|enum
name|tparitysetting
name|tparity
decl_stmt|;
name|enum
name|tstripsetting
name|tstrip
decl_stmt|;
name|enum
name|txonxoffsetting
name|txonxoff
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|qsysdep
operator|->
name|ord
expr_stmt|;
return|return
name|fsserial_set
argument_list|(
name|qconn
argument_list|,
name|tparity
argument_list|,
name|tstrip
argument_list|,
name|txonxoff
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Run a chat program.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsrun_chat
parameter_list|(
name|oread
parameter_list|,
name|owrite
parameter_list|,
name|pzprog
parameter_list|)
name|int
name|oread
decl_stmt|;
name|int
name|owrite
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzprog
decl_stmt|;
block|{
name|int
name|aidescs
index|[
literal|3
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|aidescs
index|[
literal|0
index|]
operator|=
name|oread
expr_stmt|;
name|aidescs
index|[
literal|1
index|]
operator|=
name|owrite
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
name|SPAWN_READ_PIPE
expr_stmt|;
comment|/* Pass fkeepuid, fkeepenv and fshell as TRUE.  This puts the      responsibility of maintaing security on the chat program.  */
name|ipid
operator|=
name|ixsspawn
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|pzprog
argument_list|,
name|aidescs
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ixsspawn (%s): %s"
argument_list|,
name|pzprog
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|e
operator|=
name|fdopen
argument_list|(
name|aidescs
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fdopen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|ipid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The FILE e now is attached to stderr of the program.  Forward      every line the program outputs to the log file.  */
name|z
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|z
argument_list|,
operator|&
name|c
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
index|[
name|clen
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|z
index|[
name|clen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|!=
literal|'\0'
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"chat: %s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|z
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
literal|"Chat program"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Run a chat program on a port using separate read/write file    descriptors.  */
end_comment

begin_function
name|boolean
name|fsdouble_chat
parameter_list|(
name|qconn
parameter_list|,
name|pzprog
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzprog
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|fret
operator|=
name|fsrun_chat
argument_list|(
name|qsysdep
operator|->
name|ord
argument_list|,
name|qsysdep
operator|->
name|owr
argument_list|,
name|pzprog
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|fterminal
condition|)
operator|(
name|void
operator|)
name|fgetterminfo
argument_list|(
name|qsysdep
operator|->
name|ord
argument_list|,
operator|&
name|qsysdep
operator|->
name|snew
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Run a chat program on any general type of connection.  */
end_comment

begin_function
name|boolean
name|fsysdep_conn_chat
parameter_list|(
name|qconn
parameter_list|,
name|pzprog
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzprog
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|fret
operator|=
name|fsrun_chat
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|qsysdep
operator|->
name|o
argument_list|,
name|pzprog
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|fterminal
condition|)
operator|(
name|void
operator|)
name|fgetterminfo
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|&
name|qsysdep
operator|->
name|snew
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return baud rate of a serial port.  */
end_comment

begin_function
specifier|static
name|long
name|isserial_baud
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
return|return
name|qsysdep
operator|->
name|ibaud
return|;
block|}
end_function

end_unit

