begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* work.c    Routines to read command files.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|work_rcsid
index|[]
init|=
literal|"$Id: work.c,v 1.4 1995/08/19 21:26:21 ache Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_OPENDIR
end_if

begin_if
if|#
directive|if
name|HAVE_DIRENT_H
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_OPENDIR */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zswork_directory
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zsystem
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fswork_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zsystem
operator|,
specifier|const
name|char
operator|*
name|zfile
operator|,
name|char
operator|*
name|pbgrade
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iswork_cmp
name|P
argument_list|(
operator|(
name|constpointer
name|pkey
operator|,
name|constpointer
name|pdatum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* These functions can support multiple actions going on at once.    This allows the UUCP package to send and receive multiple files at    the same time.  */
end_comment

begin_comment
comment|/* To avoid wasting a lot of time scanning the spool directory, which    might cause the remote system to time out, we limit each scan to    pick up at most a certain number of files.  */
end_comment

begin_define
define|#
directive|define
name|COMMANDS_PER_SCAN
value|(200)
end_define

begin_comment
comment|/* The ssfilename structure holds the name of a work file, as well as    its grade.  */
end_comment

begin_struct
struct|struct
name|ssfilename
block|{
name|char
modifier|*
name|zfile
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
comment|/* Some compiler may need this, and it won't normally hurt.  */
name|char
name|bdummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ssfile structure holds a command file name and all the lines    read in from that command file.  The union within the ssline    structure initially holds a line from the file and then holds a    pointer back to the ssfile structure; a pointer to this union is    used as a sequence pointer.  The ztemp entry of the ssline    structure holds the name of a temporary file to delete, if any.  */
end_comment

begin_define
define|#
directive|define
name|CFILELINES
value|(10)
end_define

begin_struct
struct|struct
name|ssline
block|{
name|char
modifier|*
name|zline
decl_stmt|;
name|struct
name|ssfile
modifier|*
name|qfile
decl_stmt|;
name|char
modifier|*
name|ztemp
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ssfile
block|{
name|char
modifier|*
name|zfile
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
comment|/* bdummy is needed for some buggy compilers.  */
name|char
name|bdummy
decl_stmt|;
name|int
name|clines
decl_stmt|;
name|int
name|cdid
decl_stmt|;
name|struct
name|ssline
name|aslines
index|[
name|CFILELINES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Static variables for the work scan.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ssfilename
modifier|*
name|asSwork_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|cSwork_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|iSwork_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ssfile
modifier|*
name|qSwork_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a system name, return a directory to search for work.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zswork_directory
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
if|#
directive|if
name|SPOOLDIR_V2
return|return
name|zbufcpy
argument_list|(
literal|"."
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_V2 */
if|#
directive|if
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
return|return
name|zbufcpy
argument_list|(
literal|"C."
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_BSD42 || SPOOLDIR_BSD43 */
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
return|return
name|zbufcpy
argument_list|(
name|zsystem
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_HDB || SPOOLDIR_SVR4 */
if|#
directive|if
name|SPOOLDIR_ULTRIX
return|return
name|zsappend3
argument_list|(
literal|"sys"
argument_list|,
operator|(
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|?
name|zsystem
else|:
literal|"DEFAULT"
operator|)
argument_list|,
literal|"C."
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX */
if|#
directive|if
name|SPOOLDIR_TAYLOR
return|return
name|zsysdep_in_dir
argument_list|(
name|zsystem
argument_list|,
literal|"C."
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
block|}
end_function

begin_comment
comment|/* See whether a file name from the directory returned by    zswork_directory is really a command for a particular system.    Return the command grade.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fswork_file
parameter_list|(
name|zsystem
parameter_list|,
name|zfile
parameter_list|,
name|pbgrade
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|char
modifier|*
name|pbgrade
decl_stmt|;
block|{
if|#
directive|if
name|SPOOLDIR_V2
operator|||
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
operator|||
name|SPOOLDIR_ULTRIX
name|int
name|cfilesys
decl_stmt|,
name|csys
decl_stmt|;
comment|/* The file name should be C.ssssssgqqqq, where g is exactly one      letter and qqqq is exactly four numbers.  The system name may be      truncated to six or seven characters.  The system name of the      file must match the system name we're looking for, since there      could be work files for several systems in one directory.  */
if|if
condition|(
name|zfile
index|[
literal|0
index|]
operator|!=
literal|'C'
operator|||
name|zfile
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
return|return
name|FALSE
return|;
name|csys
operator|=
name|strlen
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
name|cfilesys
operator|=
name|strlen
argument_list|(
name|zfile
argument_list|)
operator|-
literal|7
expr_stmt|;
if|if
condition|(
name|csys
operator|!=
name|cfilesys
operator|&&
operator|(
name|csys
operator|<
literal|6
operator|||
operator|(
name|cfilesys
operator|!=
literal|6
operator|&&
name|cfilesys
operator|!=
literal|7
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|pbgrade
operator|=
name|zfile
index|[
name|cfilesys
operator|+
literal|2
index|]
expr_stmt|;
return|return
name|strncmp
argument_list|(
name|zfile
operator|+
literal|2
argument_list|,
name|zsystem
argument_list|,
name|cfilesys
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
comment|/* V2 || BSD42 || BSD43 || ULTRIX */
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|int
name|clen
decl_stmt|;
comment|/* The HDB file name should be C.ssssssgqqqq where g is exactly one      letter and qqqq is exactly four numbers or letters.  We don't      check the system name, because it is guaranteed by the directory      we are looking in and some versions of uucp set it to the local      system rather than the remote one.  I'm not sure of the exact      format of the SVR4 file name, but it does not include the grade      at all.  */
if|if
condition|(
name|zfile
index|[
literal|0
index|]
operator|!=
literal|'C'
operator|||
name|zfile
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
return|return
name|FALSE
return|;
name|clen
operator|=
name|strlen
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
literal|7
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
operator|!
name|SPOOLDIR_SVR4
operator|*
name|pbgrade
operator|=
name|zfile
index|[
name|clen
operator|-
literal|5
index|]
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_HDB || SPOOLDIR_SVR4 */
if|#
directive|if
name|SPOOLDIR_TAYLOR
comment|/* We don't keep the system name in the file name, since that      forces truncation.  Our file names are always C.gqqqq.  */
operator|*
name|pbgrade
operator|=
name|zfile
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
name|zfile
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|zfile
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|zfile
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
block|}
end_function

begin_comment
comment|/* A comparison function to look through the list of file names.  */
end_comment

begin_function
specifier|static
name|int
name|iswork_cmp
parameter_list|(
name|pkey
parameter_list|,
name|pdatum
parameter_list|)
name|constpointer
name|pkey
decl_stmt|;
name|constpointer
name|pdatum
decl_stmt|;
block|{
specifier|const
name|struct
name|ssfilename
modifier|*
name|qkey
init|=
operator|(
specifier|const
expr|struct
name|ssfilename
operator|*
operator|)
name|pkey
decl_stmt|;
specifier|const
name|struct
name|ssfilename
modifier|*
name|qdatum
init|=
operator|(
specifier|const
expr|struct
name|ssfilename
operator|*
operator|)
name|pdatum
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|qkey
operator|->
name|zfile
argument_list|,
name|qdatum
operator|->
name|zfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See whether there is any work to do for a particular system.  */
end_comment

begin_function
name|boolean
name|fsysdep_has_work
parameter_list|(
name|qsys
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
block|{
name|char
modifier|*
name|zdir
decl_stmt|;
name|DIR
modifier|*
name|qdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|qentry
decl_stmt|;
if|#
directive|if
name|SPOOLDIR_SVR4
name|DIR
modifier|*
name|qgdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|qgentry
decl_stmt|;
endif|#
directive|endif
name|zdir
operator|=
name|zswork_directory
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdir
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qdir
operator|=
name|opendir
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|SPOOLDIR_SVR4
name|qgdir
operator|=
name|qdir
expr_stmt|;
while|while
condition|(
operator|(
name|qgentry
operator|=
name|readdir
argument_list|(
name|qgdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zsub
decl_stmt|;
if|if
condition|(
name|qgentry
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|qgentry
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
continue|continue;
name|zsub
operator|=
name|zsysdep_in_dir
argument_list|(
name|zdir
argument_list|,
name|qgentry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|qdir
operator|=
name|opendir
argument_list|(
name|zsub
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsub
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NULL
condition|)
continue|continue;
endif|#
directive|endif
while|while
condition|(
operator|(
name|qentry
operator|=
name|readdir
argument_list|(
name|qdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|bgrade
decl_stmt|;
if|if
condition|(
name|fswork_file
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|,
operator|&
name|bgrade
argument_list|)
condition|)
block|{
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_SVR4
name|closedir
argument_list|(
name|qgdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|#
directive|if
name|SPOOLDIR_SVR4
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
block|}
name|qdir
operator|=
name|qgdir
expr_stmt|;
endif|#
directive|endif
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Initialize the work scan.  We have to read all the files in the    work directory, so that we can sort them by work grade.  The bgrade    argument is the minimum grade to consider.  We don't want to return    files that we have already considered; usysdep_get_work_free will    clear the data out when we are done with the system.  This returns    FALSE on error.  */
end_comment

begin_define
define|#
directive|define
name|CWORKFILES
value|(10)
end_define

begin_function
name|boolean
name|fsysdep_get_work_init
parameter_list|(
name|qsys
parameter_list|,
name|bgrade
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
block|{
name|char
modifier|*
name|zdir
decl_stmt|;
name|DIR
modifier|*
name|qdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|qentry
decl_stmt|;
name|size_t
name|chad
decl_stmt|;
name|size_t
name|callocated
decl_stmt|;
if|#
directive|if
name|SPOOLDIR_SVR4
name|DIR
modifier|*
name|qgdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|qgentry
decl_stmt|;
endif|#
directive|endif
name|zdir
operator|=
name|zswork_directory
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdir
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qdir
operator|=
name|opendir
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NULL
condition|)
block|{
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|fret
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"opendir (%s): %s"
argument_list|,
name|zdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
name|chad
operator|=
name|cSwork_files
expr_stmt|;
name|callocated
operator|=
name|cSwork_files
expr_stmt|;
comment|/* Sort the files we already know about so that we can check the new      ones with bsearch.  It would be faster to use a hash table, and      the code should be probably be changed.  The sort done at the end      of this function does not suffice because it only includes the      files added last time, and does not sort the entire array.  Some      (bad) qsort implementations are very slow when given a sorted      array, which causes particularly bad effects here.  */
if|if
condition|(
name|chad
operator|>
literal|0
condition|)
name|qsort
argument_list|(
operator|(
name|pointer
operator|)
name|asSwork_files
argument_list|,
name|chad
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ssfilename
argument_list|)
argument_list|,
name|iswork_cmp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_SVR4
name|qgdir
operator|=
name|qdir
expr_stmt|;
while|while
condition|(
operator|(
name|qgentry
operator|=
name|readdir
argument_list|(
name|qgdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zsub
decl_stmt|;
if|if
condition|(
name|qgentry
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|qgentry
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|UUCONF_GRADE_CMP
argument_list|(
name|bgrade
argument_list|,
name|qgentry
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|zsub
operator|=
name|zsysdep_in_dir
argument_list|(
name|zdir
argument_list|,
name|qgentry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|qdir
operator|=
name|opendir
argument_list|(
name|zsub
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOTDIR
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"opendir (%s): %s"
argument_list|,
name|zsub
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zsub
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zsub
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ubuffree
argument_list|(
name|zsub
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|qentry
operator|=
name|readdir
argument_list|(
name|qdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|bfilegrade
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
name|struct
name|ssfilename
name|slook
decl_stmt|;
if|#
directive|if
operator|!
name|SPOOLDIR_SVR4
name|zname
operator|=
name|zbufcpy
argument_list|(
name|qentry
operator|->
name|d_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
name|qgentry
operator|->
name|d_name
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|bfilegrade
operator|=
name|qgentry
operator|->
name|d_name
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|slook
operator|.
name|zfile
operator|=
name|zname
expr_stmt|;
if|if
condition|(
operator|!
name|fswork_file
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|,
operator|&
name|bfilegrade
argument_list|)
operator|||
name|UUCONF_GRADE_CMP
argument_list|(
name|bgrade
argument_list|,
name|bfilegrade
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|asSwork_files
operator|!=
name|NULL
operator|&&
name|bsearch
argument_list|(
operator|(
name|pointer
operator|)
operator|&
name|slook
argument_list|,
operator|(
name|pointer
operator|)
name|asSwork_files
argument_list|,
name|chad
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ssfilename
argument_list|)
argument_list|,
name|iswork_cmp
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
else|else
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"fsysdep_get_work_init: Found %s"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSwork_files
operator|>=
name|callocated
condition|)
block|{
name|callocated
operator|+=
name|CWORKFILES
expr_stmt|;
name|asSwork_files
operator|=
operator|(
operator|(
expr|struct
name|ssfilename
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|asSwork_files
argument_list|,
operator|(
name|callocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssfilename
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|asSwork_files
index|[
name|cSwork_files
index|]
operator|.
name|zfile
operator|=
name|zname
expr_stmt|;
name|asSwork_files
index|[
name|cSwork_files
index|]
operator|.
name|bgrade
operator|=
name|bfilegrade
expr_stmt|;
operator|++
name|cSwork_files
expr_stmt|;
if|if
condition|(
name|cSwork_files
operator|-
name|chad
operator|>
name|COMMANDS_PER_SCAN
condition|)
break|break;
block|}
block|}
if|#
directive|if
name|SPOOLDIR_SVR4
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSwork_files
operator|-
name|chad
operator|>
name|COMMANDS_PER_SCAN
condition|)
break|break;
block|}
name|qdir
operator|=
name|qgdir
expr_stmt|;
endif|#
directive|endif
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
comment|/* Sorting the files alphabetically will get the grades in the      right order, since all the file prefixes are the same.  */
if|if
condition|(
name|cSwork_files
operator|>
name|iSwork_file
condition|)
name|qsort
argument_list|(
call|(
name|pointer
call|)
argument_list|(
name|asSwork_files
operator|+
name|iSwork_file
argument_list|)
argument_list|,
name|cSwork_files
operator|-
name|iSwork_file
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ssfilename
argument_list|)
argument_list|,
name|iswork_cmp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get the next work entry for a system.  This must parse the next    line in the next work file.  The type of command is set into    qcmd->bcmd If there are no more commands, qcmd->bcmd is set to 'H'.    Each field in the structure is set to point to a spot in an    malloced string.  The grade argument is never used; it has been    used by fsysdep_get_work_init.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fsysdep_get_work
parameter_list|(
name|qsys
parameter_list|,
name|bgrade
parameter_list|,
name|qcmd
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
name|char
modifier|*
name|zdir
decl_stmt|;
if|if
condition|(
name|qSwork_file
operator|!=
name|NULL
operator|&&
name|qSwork_file
operator|->
name|cdid
operator|>=
name|qSwork_file
operator|->
name|clines
condition|)
name|qSwork_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|asSwork_files
operator|==
name|NULL
condition|)
block|{
name|qcmd
operator|->
name|bcmd
operator|=
literal|'H'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|zdir
operator|=
name|NULL
expr_stmt|;
comment|/* This loop continues until a line is returned.  */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* This loop continues until a file is opened and read in.  */
while|while
condition|(
name|qSwork_file
operator|==
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|ssfile
modifier|*
name|qfile
decl_stmt|;
name|int
name|iline
decl_stmt|,
name|callocated
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|size_t
name|cline
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
name|char
name|bfilegrade
decl_stmt|;
comment|/* Read all the lines of a command file into memory.  */
do|do
block|{
if|if
condition|(
name|iSwork_file
operator|>=
name|cSwork_files
condition|)
block|{
name|qcmd
operator|->
name|bcmd
operator|=
literal|'H'
expr_stmt|;
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|zdir
operator|==
name|NULL
condition|)
block|{
name|zdir
operator|=
name|zswork_directory
argument_list|(
name|qsys
operator|->
name|uuconf_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdir
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
name|zdir
argument_list|,
name|asSwork_files
index|[
name|iSwork_file
index|]
operator|.
name|zfile
argument_list|)
expr_stmt|;
name|bfilegrade
operator|=
name|asSwork_files
index|[
name|iSwork_file
index|]
operator|.
name|bgrade
expr_stmt|;
operator|++
name|iSwork_file
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|zname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|e
operator|==
name|NULL
condition|)
do|;
name|qfile
operator|=
operator|(
expr|struct
name|ssfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssfile
argument_list|)
argument_list|)
expr_stmt|;
name|callocated
operator|=
name|CFILELINES
expr_stmt|;
name|iline
operator|=
literal|0
expr_stmt|;
name|zline
operator|=
name|NULL
expr_stmt|;
name|cline
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|zline
argument_list|,
operator|&
name|cline
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|iline
operator|>=
name|callocated
condition|)
block|{
comment|/* The sizeof (struct ssfile) includes CFILELINES 		     entries already, so using callocated * sizeof 		     (struct ssline) will give us callocated * 		     CFILELINES entries.  */
name|qfile
operator|=
operator|(
operator|(
expr|struct
name|ssfile
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|qfile
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssfile
argument_list|)
operator|+
operator|(
name|callocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssline
argument_list|)
operator|)
operator|)
argument_list|)
operator|)
expr_stmt|;
name|callocated
operator|+=
name|CFILELINES
expr_stmt|;
block|}
name|qfile
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|zline
operator|=
name|zbufcpy
argument_list|(
name|zline
argument_list|)
expr_stmt|;
name|qfile
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|qfile
operator|=
name|NULL
expr_stmt|;
name|qfile
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|ztemp
operator|=
name|NULL
expr_stmt|;
name|iline
operator|++
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iline
operator|==
literal|0
condition|)
block|{
comment|/* There were no lines in the file; this is a poll file, 		 for which we return a 'P' command.  */
name|qfile
operator|->
name|aslines
index|[
literal|0
index|]
operator|.
name|zline
operator|=
name|zbufcpy
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
name|qfile
operator|->
name|aslines
index|[
literal|0
index|]
operator|.
name|qfile
operator|=
name|NULL
expr_stmt|;
name|qfile
operator|->
name|aslines
index|[
literal|0
index|]
operator|.
name|ztemp
operator|=
name|NULL
expr_stmt|;
name|iline
operator|=
literal|1
expr_stmt|;
block|}
name|qfile
operator|->
name|zfile
operator|=
name|zname
expr_stmt|;
name|qfile
operator|->
name|bgrade
operator|=
name|bfilegrade
expr_stmt|;
name|qfile
operator|->
name|clines
operator|=
name|iline
expr_stmt|;
name|qfile
operator|->
name|cdid
operator|=
literal|0
expr_stmt|;
name|qSwork_file
operator|=
name|qfile
expr_stmt|;
block|}
comment|/* This loop continues until all the lines from the current file 	 are used up, or a line is returned.  */
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|iline
decl_stmt|;
if|if
condition|(
name|qSwork_file
operator|->
name|cdid
operator|>=
name|qSwork_file
operator|->
name|clines
condition|)
block|{
comment|/* We don't want to free qSwork_file here, since it must 		 remain until all the lines have been completed.  It 		 is freed in fsysdep_did_work.  */
name|qSwork_file
operator|=
name|NULL
expr_stmt|;
comment|/* Go back to the main loop which finds another file.  */
break|break;
block|}
name|iline
operator|=
name|qSwork_file
operator|->
name|cdid
expr_stmt|;
operator|++
name|qSwork_file
operator|->
name|cdid
expr_stmt|;
comment|/* Now parse the line into a command.  */
if|if
condition|(
operator|!
name|fparse_cmd
argument_list|(
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|zline
argument_list|,
name|qcmd
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad line in command file %s"
argument_list|,
name|qSwork_file
operator|->
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|zline
argument_list|)
expr_stmt|;
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|zline
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|qcmd
operator|->
name|bgrade
operator|=
name|qSwork_file
operator|->
name|bgrade
expr_stmt|;
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|qfile
operator|=
name|qSwork_file
expr_stmt|;
name|qcmd
operator|->
name|pseq
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|&
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'S'
operator|||
name|qcmd
operator|->
name|bcmd
operator|==
literal|'E'
condition|)
block|{
name|char
modifier|*
name|zreal
decl_stmt|;
name|zreal
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|,
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|zreal
operator|==
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|zline
argument_list|)
expr_stmt|;
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|zline
operator|=
name|NULL
expr_stmt|;
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qSwork_file
operator|->
name|aslines
index|[
name|iline
index|]
operator|.
name|ztemp
operator|=
name|zreal
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zdir
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* When a command has been complete, fsysdep_did_work is called.  The    sequence entry was set above to be the address of an aslines    structure whose pfile entry points to the ssfile corresponding to    this file.  We can then check whether all the lines have been    completed (they will have been if the pfile entry is NULL) and    remove the file if they have been.  This means that we only remove    a command file if we manage to complete every transfer it specifies    in a single UUCP session.  I don't know if this is how regular UUCP    works.  */
end_comment

begin_function
name|boolean
name|fsysdep_did_work
parameter_list|(
name|pseq
parameter_list|)
name|pointer
name|pseq
decl_stmt|;
block|{
name|struct
name|ssfile
modifier|*
name|qfile
decl_stmt|;
name|struct
name|ssline
modifier|*
name|qline
decl_stmt|;
name|int
name|i
decl_stmt|;
name|qline
operator|=
operator|(
expr|struct
name|ssline
operator|*
operator|)
name|pseq
expr_stmt|;
name|ubuffree
argument_list|(
name|qline
operator|->
name|zline
argument_list|)
expr_stmt|;
name|qline
operator|->
name|zline
operator|=
name|NULL
expr_stmt|;
name|qfile
operator|=
name|qline
operator|->
name|qfile
expr_stmt|;
name|qline
operator|->
name|qfile
operator|=
name|NULL
expr_stmt|;
comment|/* Remove the temporary file, if there is one.  It really doesn't      matter if this fails, and not checking the return value lets us      attempt to remove D.0 or whatever an unused temporary file is      called without complaining.  */
if|if
condition|(
name|qline
operator|->
name|ztemp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qline
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qline
operator|->
name|ztemp
argument_list|)
expr_stmt|;
name|qline
operator|->
name|ztemp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If not all the lines have been returned from fsysdep_get_work,      we can't remove the file yet.  */
if|if
condition|(
name|qfile
operator|->
name|cdid
operator|<
name|qfile
operator|->
name|clines
condition|)
return|return
name|TRUE
return|;
comment|/* See whether all the commands have been completed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qfile
operator|->
name|clines
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|qfile
operator|->
name|aslines
index|[
name|i
index|]
operator|.
name|qfile
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* All commands have finished.  */
if|if
condition|(
name|remove
argument_list|(
name|qfile
operator|->
name|zfile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|qfile
operator|->
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|qfile
operator|->
name|zfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfile
operator|==
name|qSwork_file
condition|)
name|qSwork_file
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Free up the results of a work scan, when we're done with this    system.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|usysdep_get_work_free
parameter_list|(
name|qsys
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
block|{
if|if
condition|(
name|asSwork_files
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cSwork_files
condition|;
name|i
operator|++
control|)
name|ubuffree
argument_list|(
operator|(
name|pointer
operator|)
name|asSwork_files
index|[
name|i
index|]
operator|.
name|zfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|asSwork_files
argument_list|)
expr_stmt|;
name|asSwork_files
operator|=
name|NULL
expr_stmt|;
name|cSwork_files
operator|=
literal|0
expr_stmt|;
name|iSwork_file
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qSwork_file
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ubuffree
argument_list|(
name|qSwork_file
operator|->
name|zfile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qSwork_file
operator|->
name|cdid
condition|;
name|i
operator|++
control|)
block|{
name|ubuffree
argument_list|(
name|qSwork_file
operator|->
name|aslines
index|[
name|i
index|]
operator|.
name|zline
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|qSwork_file
operator|->
name|aslines
index|[
name|i
index|]
operator|.
name|ztemp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|qSwork_file
operator|->
name|cdid
init|;
name|i
operator|<
name|qSwork_file
operator|->
name|clines
condition|;
name|i
operator|++
control|)
name|ubuffree
argument_list|(
name|qSwork_file
operator|->
name|aslines
index|[
name|i
index|]
operator|.
name|zline
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qSwork_file
argument_list|)
expr_stmt|;
name|qSwork_file
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save the temporary file used by a send command, and return an    informative message to mail to the requestor.  This is called when    a file transfer failed, to make sure that the potentially valuable    file is not completely lost.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zsysdep_save_temp_file
parameter_list|(
name|pseq
parameter_list|)
name|pointer
name|pseq
decl_stmt|;
block|{
name|struct
name|ssline
modifier|*
name|qline
init|=
operator|(
expr|struct
name|ssline
operator|*
operator|)
name|pseq
decl_stmt|;
name|char
modifier|*
name|zto
decl_stmt|,
modifier|*
name|zslash
decl_stmt|;
name|size_t
name|cwant
decl_stmt|;
specifier|static
name|char
modifier|*
name|zbuf
decl_stmt|;
specifier|static
name|int
name|cbuf
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|qline
operator|->
name|ztemp
argument_list|)
condition|)
return|return
name|NULL
return|;
name|zslash
operator|=
name|strrchr
argument_list|(
name|qline
operator|->
name|ztemp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
condition|)
name|zslash
operator|=
name|qline
operator|->
name|ztemp
expr_stmt|;
else|else
operator|++
name|zslash
expr_stmt|;
name|zto
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|PRESERVEDIR
operator|+
sizeof|sizeof
expr|"/"
operator|+
name|strlen
argument_list|(
name|zslash
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zto
argument_list|,
literal|"%s/%s"
argument_list|,
name|PRESERVEDIR
argument_list|,
name|zslash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_move_file
argument_list|(
name|qline
operator|->
name|ztemp
argument_list|,
name|zto
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
comment|/* Leave the file where it was, not that is much help.  */
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
literal|"Could not move file to preservation directory"
return|;
block|}
name|cwant
operator|=
sizeof|sizeof
expr|"File saved as\n\t/"
operator|+
name|strlen
argument_list|(
name|zSspooldir
argument_list|)
operator|+
name|strlen
argument_list|(
name|zto
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwant
operator|>
name|cbuf
condition|)
block|{
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
name|zbuf
operator|=
name|zbufalc
argument_list|(
name|cwant
argument_list|)
expr_stmt|;
name|cbuf
operator|=
name|cwant
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|zbuf
argument_list|,
literal|"File saved as\n\t%s/%s"
argument_list|,
name|zSspooldir
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zto
argument_list|)
expr_stmt|;
return|return
name|zbuf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the jobid of a work file.  This is needed by uustat.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_jobid
parameter_list|(
name|qsys
parameter_list|,
name|pseq
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|pointer
name|pseq
decl_stmt|;
block|{
return|return
name|zsfile_to_jobid
argument_list|(
name|qsys
argument_list|,
operator|(
operator|(
expr|struct
name|ssline
operator|*
operator|)
name|pseq
operator|)
operator|->
name|qfile
operator|->
name|zfile
argument_list|,
name|bsgrade
argument_list|(
name|pseq
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the grade of a work file.  The pseq argument can be NULL when    this is called from zsysdep_spool_file_name, and simply means that    this is a remote file; returning -1 will cause zsfind_file to do    the right thing.  */
end_comment

begin_function
name|int
name|bsgrade
parameter_list|(
name|pseq
parameter_list|)
name|pointer
name|pseq
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
if|if
condition|(
name|pseq
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|zfile
operator|=
operator|(
operator|(
expr|struct
name|ssline
operator|*
operator|)
name|pseq
operator|)
operator|->
name|qfile
operator|->
name|zfile
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_TAYLOR
name|bgrade
operator|=
operator|*
operator|(
name|strrchr
argument_list|(
name|zfile
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
name|SPOOLDIR_SVR4
name|bgrade
operator|=
name|zfile
index|[
name|strlen
argument_list|(
name|zfile
argument_list|)
operator|-
name|CSEQLEN
operator|-
literal|1
index|]
expr_stmt|;
else|#
directive|else
name|bgrade
operator|=
operator|*
operator|(
name|strchr
argument_list|(
name|zfile
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|bgrade
return|;
block|}
end_function

end_unit

