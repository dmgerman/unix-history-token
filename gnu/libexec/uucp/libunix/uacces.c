begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uacces.c    Check access to a file by user name.     Copyright (C) 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_GETGRENT
end_if

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_if
if|#
directive|if
name|GETGRENT_DECLARATION_OK
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|getgrent
end_ifndef

begin_function_decl
specifier|extern
name|struct
name|group
modifier|*
name|getgrent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETGRENT */
end_comment

begin_if
if|#
directive|if
name|GETPWNAM_DECLARATION_OK
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|getpwnam
end_ifndef

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Do access(2) on a stat structure, except that the user name is    provided.  If the user name in zuser is NULL, require the file to    be accessible to the world.  Return TRUE if access is permitted,    FALSE otherwise.  This does not log an error message.  */
end_comment

begin_function
name|boolean
name|fsuser_access
parameter_list|(
name|q
parameter_list|,
name|imode
parameter_list|,
name|zuser
parameter_list|)
specifier|const
name|struct
name|stat
modifier|*
name|q
decl_stmt|;
name|int
name|imode
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|zuser_hold
decl_stmt|;
specifier|static
name|uid_t
name|iuid_hold
decl_stmt|;
specifier|static
name|gid_t
name|igid_hold
decl_stmt|;
specifier|static
name|int
name|cgroups_hold
decl_stmt|;
specifier|static
name|gid_t
modifier|*
name|paigroups_hold
decl_stmt|;
name|int
name|ir
decl_stmt|,
name|iw
decl_stmt|,
name|ix
decl_stmt|,
name|iand
decl_stmt|;
if|if
condition|(
name|imode
operator|==
name|F_OK
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|zuser
operator|!=
name|NULL
condition|)
block|{
comment|/* We keep static variables around for the last user we did, to 	 avoid looking up a user multiple times.  */
if|if
condition|(
name|zuser_hold
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zuser_hold
argument_list|,
name|zuser
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|qpwd
decl_stmt|;
if|if
condition|(
name|zuser_hold
operator|!=
name|NULL
condition|)
block|{
name|ubuffree
argument_list|(
name|zuser_hold
argument_list|)
expr_stmt|;
name|zuser_hold
operator|=
name|NULL
expr_stmt|;
name|cgroups_hold
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|paigroups_hold
argument_list|)
expr_stmt|;
name|paigroups_hold
operator|=
name|NULL
expr_stmt|;
block|}
name|qpwd
operator|=
name|getpwnam
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpwd
operator|==
name|NULL
condition|)
block|{
comment|/* Check this as a remote request.  */
name|zuser
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_GETGRENT
name|struct
name|group
modifier|*
name|qg
decl_stmt|;
endif|#
directive|endif
name|zuser_hold
operator|=
name|zbufcpy
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
name|iuid_hold
operator|=
name|qpwd
operator|->
name|pw_uid
expr_stmt|;
name|igid_hold
operator|=
name|qpwd
operator|->
name|pw_gid
expr_stmt|;
if|#
directive|if
name|HAVE_GETGRENT
comment|/* Get the list of groups for this user.  This is 		 definitely more appropriate for BSD than for System 		 V.  It may just be a waste of time, and perhaps it 		 should be configurable.  */
name|setgrent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|qg
operator|=
name|getgrent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|qg
operator|->
name|gr_gid
operator|==
name|igid_hold
condition|)
continue|continue;
for|for
control|(
name|pz
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|qg
operator|->
name|gr_mem
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pz
operator|)
index|[
literal|0
index|]
operator|==
operator|*
name|zuser
operator|&&
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
name|zuser
argument_list|)
operator|==
literal|0
condition|)
block|{
name|paigroups_hold
operator|=
operator|(
operator|(
name|gid_t
operator|*
operator|)
operator|(
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|paigroups_hold
argument_list|,
operator|(
operator|(
name|cgroups_hold
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
operator|)
argument_list|)
operator|)
operator|)
expr_stmt|;
name|paigroups_hold
index|[
name|cgroups_hold
index|]
operator|=
name|qg
operator|->
name|gr_gid
expr_stmt|;
operator|++
name|cgroups_hold
expr_stmt|;
break|break;
block|}
block|}
block|}
name|endgrent
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* Now do the actual access check.  */
if|if
condition|(
name|zuser
operator|!=
name|NULL
condition|)
block|{
comment|/* The superuser can do anything.  */
if|if
condition|(
name|iuid_hold
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If this is the uid we're running under, there's no point to 	 checking access further, because when we actually try the 	 operation the system will do the checking for us.  */
if|if
condition|(
name|iuid_hold
operator|==
name|geteuid
argument_list|()
condition|)
return|return
name|TRUE
return|;
block|}
name|ir
operator|=
name|S_IROTH
expr_stmt|;
name|iw
operator|=
name|S_IWOTH
expr_stmt|;
name|ix
operator|=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|zuser
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|iuid_hold
operator|==
name|q
operator|->
name|st_uid
condition|)
block|{
name|ir
operator|=
name|S_IRUSR
expr_stmt|;
name|iw
operator|=
name|S_IWUSR
expr_stmt|;
name|ix
operator|=
name|S_IXUSR
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|fgroup
decl_stmt|;
name|fgroup
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|igid_hold
operator|==
name|q
operator|->
name|st_gid
condition|)
name|fgroup
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cgroups_hold
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|paigroups_hold
index|[
name|i
index|]
operator|==
name|q
operator|->
name|st_gid
condition|)
block|{
name|fgroup
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|fgroup
condition|)
block|{
name|ir
operator|=
name|S_IRGRP
expr_stmt|;
name|iw
operator|=
name|S_IWGRP
expr_stmt|;
name|ix
operator|=
name|S_IXGRP
expr_stmt|;
block|}
block|}
block|}
name|iand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|imode
operator|&
name|R_OK
operator|)
operator|!=
literal|0
condition|)
name|iand
operator||=
name|ir
expr_stmt|;
if|if
condition|(
operator|(
name|imode
operator|&
name|W_OK
operator|)
operator|!=
literal|0
condition|)
name|iand
operator||=
name|iw
expr_stmt|;
if|if
condition|(
operator|(
name|imode
operator|&
name|X_OK
operator|)
operator|!=
literal|0
condition|)
name|iand
operator||=
name|ix
expr_stmt|;
return|return
operator|(
name|q
operator|->
name|st_mode
operator|&
name|iand
operator|)
operator|==
name|iand
return|;
block|}
end_function

end_unit

