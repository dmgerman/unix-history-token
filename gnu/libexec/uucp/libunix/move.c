begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* move.c    Move a file.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o Infinity Development Systems, P.O. Box 520, Waltham, MA 02254.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Move (rename) a file from one name to another.  This routine will    optionally create necessary directories, and fpublic indicates    whether the new directories should be publically accessible or not.    If fcheck is true, it will try to determine whether the named user    has write access to the new file.  */
end_comment

begin_function
name|boolean
name|fsysdep_move_file
parameter_list|(
name|zorig
parameter_list|,
name|zto
parameter_list|,
name|fmkdirs
parameter_list|,
name|fpublic
parameter_list|,
name|fcheck
parameter_list|,
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zorig
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|boolean
name|fmkdirs
decl_stmt|;
name|boolean
name|fpublic
decl_stmt|;
name|boolean
name|fcheck
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|int
name|o
decl_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"fsysdep_move_file: Moving %s to %s"
argument_list|,
name|zorig
argument_list|,
name|zto
argument_list|)
expr_stmt|;
comment|/* Optionally make sure that zuser has write access on the      directory.  */
if|if
condition|(
name|fcheck
condition|)
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|char
modifier|*
name|zslash
decl_stmt|;
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|zslash
operator|=
name|strrchr
argument_list|(
name|zcopy
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|zcopy
condition|)
name|zslash
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|zslash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|zcopy
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|zcopy
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|fsuser_access
argument_list|(
operator|&
name|s
argument_list|,
name|W_OK
argument_list|,
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|zcopy
argument_list|,
name|strerror
argument_list|(
name|EACCES
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
comment|/* A malicious user now has a few milliseconds to change a 	 symbolic link to a directory uucp has write permission on but 	 the user does not (the obvious choice being /usr/lib/uucp). 	 The only certain method I can come up with to close this race 	 is to fork an suid process which takes on the users identity 	 and does the actual copy.  This is sufficiently high overhead 	 that I'm not going to do it.  */
block|}
comment|/* We try to use rename to move the file.  */
if|if
condition|(
name|rename
argument_list|(
name|zorig
argument_list|,
name|zto
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fmkdirs
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zto
argument_list|,
name|fpublic
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|rename
argument_list|(
name|zorig
argument_list|,
name|zto
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
if|#
directive|if
name|HAVE_RENAME
comment|/* On some systems the system call rename seems to fail for      arbitrary reasons.  To get around this, we always try to copy the      file by hand if the rename failed.  */
name|errno
operator|=
name|EXDEV
expr_stmt|;
endif|#
directive|endif
comment|/* If we can't link across devices, we must copy the file by hand.  */
if|if
condition|(
name|errno
operator|!=
name|EXDEV
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"rename (%s, %s): %s"
argument_list|,
name|zorig
argument_list|,
name|zto
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Copy the file.  */
if|if
condition|(
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zorig
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|zorig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make sure the file gets the right mode by creating it before we      call fcopy_file.  */
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|o
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zto
argument_list|,
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fmkdirs
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zto
argument_list|,
name|fpublic
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|o
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zto
argument_list|,
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"creat (%s): %s"
argument_list|,
name|zto
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcopy_file
argument_list|(
name|zorig
argument_list|,
name|zto
argument_list|,
name|fpublic
argument_list|,
name|fmkdirs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zorig
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|remove
argument_list|(
name|zorig
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|zorig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

