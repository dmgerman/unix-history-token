begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* signal.c    Signal handling routines.     Copyright (C) 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Signal handling routines.  When we catch a signal, we want to set    the appropriate elements of afSignal and afLog_signal to TRUE.  If    we are on a system which restarts system calls, we may also want to    longjmp out.  On a system which does not restart system calls,    these signal handling routines are well-defined by ANSI C.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_RESTARTABLE_SYSCALLS
end_if

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|fSjmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|jmp_buf
name|sSjmp_buf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_RESTARTABLE_SYSCALLS */
end_comment

begin_comment
comment|/* Some systems, such as SunOS, have a SA_INTERRUPT bit that must be    set in the sigaction structure to force system calls to be    interrupted.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SA_INTERRUPT
end_ifndef

begin_define
define|#
directive|define
name|SA_INTERRUPT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The SVR3 sigset function can be called just like signal, unless    system calls are restarted which is extremely unlikely; we prevent    this case in sysh.unx.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_SIGSET
operator|&&
operator|!
name|HAVE_SIGACTION
operator|&&
operator|!
name|HAVE_SIGVEC
end_if

begin_define
define|#
directive|define
name|signal
value|sigset
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The sigvec structure changed from 4.2BSD to 4.3BSD.  These macros    make the 4.3 code backward compatible.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SV_INTERRUPT
end_ifndef

begin_define
define|#
directive|define
name|SV_INTERRUPT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_SIGVEC_SV_FLAGS
end_if

begin_define
define|#
directive|define
name|sv_flags
value|sv_onstack
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Catch a signal.  Reinstall the signal handler if necessary, set the    appropriate variables, and do a longjmp if necessary.  */
end_comment

begin_function
name|RETSIGTYPE
name|ussignal
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
name|int
name|iindex
decl_stmt|;
if|#
directive|if
operator|!
name|HAVE_SIGACTION
operator|&&
operator|!
name|HAVE_SIGVEC
operator|&&
operator|!
name|HAVE_SIGSET
operator|(
name|void
operator|)
name|signal
argument_list|(
name|isig
argument_list|,
name|ussignal
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|isig
condition|)
block|{
default|default:
name|iindex
operator|=
name|INDEXSIG_SIGHUP
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SIGINT
case|case
name|SIGINT
case|:
name|iindex
operator|=
name|INDEXSIG_SIGINT
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
name|iindex
operator|=
name|INDEXSIG_SIGQUIT
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
case|case
name|SIGTERM
case|:
name|iindex
operator|=
name|INDEXSIG_SIGTERM
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
case|case
name|SIGPIPE
case|:
name|iindex
operator|=
name|INDEXSIG_SIGPIPE
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|afSignal
index|[
name|iindex
index|]
operator|=
name|TRUE
expr_stmt|;
name|afLog_signal
index|[
name|iindex
index|]
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|HAVE_RESTARTABLE_SYSCALLS
if|if
condition|(
name|fSjmp
condition|)
name|longjmp
argument_list|(
name|sSjmp_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_RESTARTABLE_SYSCALLS */
block|}
end_function

begin_comment
comment|/* Prepare to catch a signal.  This is basically the ANSI C routine    signal, but it uses sigaction or sigvec instead if they are    available.  If fforce is FALSE, we do not set the signal if it is    currently being ignored.  If pfignored is not NULL and fforce is    FALSE, then *pfignored will be set to TRUE if the signal was    previously being ignored (if fforce is TRUE the value returned in    *pfignored is meaningless).  If we can't change the signal handler    we give a fatal error.  */
end_comment

begin_function_decl
name|void
name|usset_signal
parameter_list|(
name|isig
parameter_list|,
name|pfn
parameter_list|,
name|fforce
parameter_list|,
name|pfignored
parameter_list|)
name|int
name|isig
decl_stmt|;
function_decl|RETSIGTYPE
parameter_list|(
function_decl|*pfn
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean
name|fforce
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
modifier|*
name|pfignored
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|HAVE_SIGACTION
name|struct
name|sigaction
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|fforce
condition|)
block|{
call|(
name|void
call|)
argument_list|(
name|sigemptyset
argument_list|(
operator|&
name|s
operator|.
name|sa_mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|isig
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"sigaction (%d): %s"
argument_list|,
name|isig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|sa_handler
operator|==
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|pfignored
operator|!=
name|NULL
condition|)
operator|*
name|pfignored
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pfignored
operator|!=
name|NULL
condition|)
operator|*
name|pfignored
operator|=
name|FALSE
expr_stmt|;
block|}
name|s
operator|.
name|sa_handler
operator|=
name|pfn
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|sigemptyset
argument_list|(
operator|&
name|s
operator|.
name|sa_mask
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|sa_flags
operator|=
name|SA_INTERRUPT
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|isig
argument_list|,
operator|&
name|s
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"sigaction (%d): %s"
argument_list|,
name|isig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_SIGACTION */
if|#
directive|if
name|HAVE_SIGVEC
name|struct
name|sigvec
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|fforce
condition|)
block|{
if|if
condition|(
name|sigvec
argument_list|(
name|isig
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"sigvec (%d): %s"
argument_list|,
name|isig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|sv_handler
operator|==
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|pfignored
operator|!=
name|NULL
condition|)
operator|*
name|pfignored
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pfignored
operator|!=
name|NULL
condition|)
operator|*
name|pfignored
operator|=
name|FALSE
expr_stmt|;
block|}
name|s
operator|.
name|sv_handler
operator|=
name|pfn
expr_stmt|;
name|s
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|sv_flags
operator|=
name|SV_INTERRUPT
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|isig
argument_list|,
operator|&
name|s
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"sigvec (%d): %s"
argument_list|,
name|isig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_SIGVEC */
if|if
condition|(
operator|!
name|fforce
condition|)
block|{
if|if
condition|(
name|signal
argument_list|(
name|isig
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|pfignored
operator|!=
name|NULL
condition|)
operator|*
name|pfignored
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pfignored
operator|!=
name|NULL
condition|)
operator|*
name|pfignored
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|isig
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_SIGVEC */
endif|#
directive|endif
comment|/* ! HAVE_SIGACTION */
block|}
end_block

begin_comment
comment|/* The routine called by the system independent code, which always    uses the same signal handler.  */
end_comment

begin_function
name|void
name|usysdep_signal
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
name|usset_signal
argument_list|(
name|isig
argument_list|,
name|ussignal
argument_list|,
name|FALSE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

