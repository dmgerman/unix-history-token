begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xqtfil.c    Routines to read execute files.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|xqtfil_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_OPENDIR
end_if

begin_if
if|#
directive|if
name|HAVE_DIRENT_H
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_OPENDIR */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Under the V2 or BSD42 spool directory scheme, all execute files are    in the main spool directory.  Under the BSD43 scheme, they are all    in the directory X..  Under the HDB or SVR4 scheme, they are in    directories named after systems.  Under the ULTRIX scheme, they are    in X.  subdirectories of subdirectories of sys.  Under the TAYLOR    scheme, they are all in the subdirectory X. of a directory named    after the system.     This means that for HDB, ULTRIX, SVR4 or TAYLOR, we have to search    directories of directories.  */
end_comment

begin_if
if|#
directive|if
name|SPOOLDIR_V2
operator|||
name|SPOOLDIR_BSD42
end_if

begin_define
define|#
directive|define
name|ZDIR
value|"."
end_define

begin_define
define|#
directive|define
name|SUBDIRS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
operator|||
name|SPOOLDIR_TAYLOR
end_if

begin_define
define|#
directive|define
name|ZDIR
value|"."
end_define

begin_define
define|#
directive|define
name|SUBDIRS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SPOOLDIR_ULTRIX
end_if

begin_define
define|#
directive|define
name|ZDIR
value|"sys"
end_define

begin_define
define|#
directive|define
name|SUBDIRS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SPOOLDIR_BSD43
end_if

begin_define
define|#
directive|define
name|ZDIR
value|"X."
end_define

begin_define
define|#
directive|define
name|SUBDIRS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static variables for the execute file scan.  */
end_comment

begin_decl_stmt
specifier|static
name|DIR
modifier|*
name|qSxqt_topdir
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|SUBDIRS
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zSdir
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SUBDIRS */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fSone_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zSdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DIR
modifier|*
name|qSxqt_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zSsystem
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUBDIRS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Initialize the scan for execute files.  The function    usysdep_get_xqt_free will clear the data out when we are done with    the system.  This returns FALSE on error.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fsysdep_get_xqt_init
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
name|usysdep_get_xqt_free
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|SUBDIRS
if|if
condition|(
name|zsystem
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|zSdir
operator|=
name|zbufcpy
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
name|zSdir
operator|=
name|zsappend3
argument_list|(
literal|"sys"
argument_list|,
name|zsystem
argument_list|,
literal|"X."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_TAYLOR
name|zSdir
operator|=
name|zsysdep_in_dir
argument_list|(
name|zsystem
argument_list|,
literal|"X."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qSxqt_dir
operator|=
name|opendir
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zSdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qSxqt_dir
operator|!=
name|NULL
condition|)
block|{
name|qSxqt_topdir
operator|=
name|qSxqt_dir
expr_stmt|;
name|fSone_dir
operator|=
name|TRUE
expr_stmt|;
name|zSsystem
operator|=
name|zbufcpy
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|fSone_dir
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|qSxqt_topdir
operator|=
name|opendir
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ZDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|qSxqt_topdir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
name|TRUE
return|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"opendir (%s): %s"
argument_list|,
name|ZDIR
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the next execute file to read and process.  If    this returns NULL, *pferr must be checked.  If will be TRUE on    error, FALSE if there are no more files.  On a successful return    *pzsystem will be set to the system for which the execute file was    created.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|zsysdep_get_xqt
parameter_list|(
name|zsystem
parameter_list|,
name|pzsystem
parameter_list|,
name|pferr
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzsystem
decl_stmt|;
name|boolean
modifier|*
name|pferr
decl_stmt|;
block|{
operator|*
name|pferr
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|qSxqt_topdir
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* This loop continues until we find a file.  */
while|while
condition|(
name|TRUE
condition|)
block|{
name|DIR
modifier|*
name|qdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|q
decl_stmt|;
if|#
directive|if
operator|!
name|SUBDIRS
name|zSdir
operator|=
name|ZDIR
expr_stmt|;
name|qdir
operator|=
name|qSxqt_topdir
expr_stmt|;
else|#
directive|else
comment|/* SUBDIRS */
comment|/* This loop continues until we find a subdirectory to read.  */
while|while
condition|(
name|qSxqt_dir
operator|==
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|qtop
decl_stmt|;
name|qtop
operator|=
name|readdir
argument_list|(
name|qSxqt_topdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtop
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|qSxqt_topdir
argument_list|)
expr_stmt|;
name|qSxqt_topdir
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* No system name may start with a dot This allows us to 	     quickly skip impossible directories.  */
if|if
condition|(
name|qtop
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"zsysdep_get_xqt: Found %s in top directory"
argument_list|,
name|qtop
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zSdir
argument_list|)
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|zSdir
operator|=
name|zbufcpy
argument_list|(
name|qtop
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
name|zSdir
operator|=
name|zsappend3
argument_list|(
literal|"sys"
argument_list|,
name|qtop
operator|->
name|d_name
argument_list|,
literal|"X."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_TAYLOR
name|zSdir
operator|=
name|zsysdep_in_dir
argument_list|(
name|qtop
operator|->
name|d_name
argument_list|,
literal|"X."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubuffree
argument_list|(
name|zSsystem
argument_list|)
expr_stmt|;
name|zSsystem
operator|=
name|zbufcpy
argument_list|(
name|qtop
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|qSxqt_dir
operator|=
name|opendir
argument_list|(
name|zSdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qSxqt_dir
operator|==
name|NULL
operator|&&
name|errno
operator|!=
name|ENOTDIR
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"opendir (%s): %s"
argument_list|,
name|zSdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qdir
operator|=
name|qSxqt_dir
expr_stmt|;
endif|#
directive|endif
comment|/* SUBDIRS */
name|q
operator|=
name|readdir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"zsysdep_get_xqt: Found %s in subdirectory %s"
argument_list|,
name|q
operator|->
name|d_name
argument_list|,
name|zSdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we've found an execute file, return it.  We have to get 	 the system name, which is easy for HDB or TAYLOR.  For other 	 spool directory schemes, we have to pull it out of the X. 	 file name; this would be insecure, except that zsfind_file 	 clobbers the file name to include the real system name.  */
if|if
condition|(
name|q
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'X'
operator|&&
name|q
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|char
modifier|*
name|zret
decl_stmt|;
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
operator|||
name|SPOOLDIR_TAYLOR
operator|*
name|pzsystem
operator|=
name|zbufcpy
argument_list|(
name|zSsystem
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|size_t
name|clen
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|q
operator|->
name|d_name
argument_list|)
operator|-
literal|7
expr_stmt|;
operator|*
name|pzsystem
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|pzsystem
argument_list|,
name|q
operator|->
name|d_name
operator|+
literal|2
argument_list|,
name|clen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pzsystem
operator|)
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|zret
operator|=
name|zsysdep_in_dir
argument_list|(
name|zSdir
argument_list|,
name|q
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"zsysdep_get_xqt: Returning %s (system %s)"
argument_list|,
name|zret
argument_list|,
operator|*
name|pzsystem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|zret
return|;
block|}
comment|/* If we've reached the end of the directory, then if we are 	 using subdirectories loop around to read the next one, 	 otherwise we are finished.  */
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
if|#
directive|if
name|SUBDIRS
name|qSxqt_dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fSone_dir
condition|)
continue|continue;
endif|#
directive|endif
name|qSxqt_topdir
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free up the results of an execute file scan, when we're done with    this system.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|usysdep_get_xqt_free
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
if|if
condition|(
name|qSxqt_topdir
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|qSxqt_topdir
argument_list|)
expr_stmt|;
name|qSxqt_topdir
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|SUBDIRS
if|if
condition|(
name|qSxqt_dir
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|qSxqt_dir
argument_list|)
expr_stmt|;
name|qSxqt_dir
operator|=
name|NULL
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zSdir
argument_list|)
expr_stmt|;
name|zSdir
operator|=
name|NULL
expr_stmt|;
name|ubuffree
argument_list|(
name|zSsystem
argument_list|)
expr_stmt|;
name|zSsystem
operator|=
name|NULL
expr_stmt|;
name|fSone_dir
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

