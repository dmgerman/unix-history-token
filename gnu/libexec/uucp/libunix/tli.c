begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tli.c    Code to handle TLI connections.     Copyright (C) 1992, 1993, 1994 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|tli_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TLI
end_if

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_IOCTL_H
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TIUSER_H
end_if

begin_include
include|#
directive|include
file|<tiuser.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_XTI_H
end_if

begin_include
include|#
directive|include
file|<xti.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_TLI_H
end_if

begin_include
include|#
directive|include
file|<sys/tli.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STROPTS_H
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The arguments to t_alloca have two different names.  I want the    SVID ones, not the XPG3 ones.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|T_BIND
end_ifndef

begin_define
define|#
directive|define
name|T_BIND
value|T_BIND_STR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|T_CALL
end_ifndef

begin_define
define|#
directive|define
name|T_CALL
value|T_CALL_STR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hopefully these externs will not cause any trouble.  This is how    they are shown in the SVID.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|t_errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|t_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|t_nerr
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TIUSER_H
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|t_alloc
end_ifndef

begin_function_decl
specifier|extern
name|pointer
name|t_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This code handles TLI connections.  It's Unix specific.  It's    largely based on code from Unix Network Programming, by W. Richard    Stevens.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ztlierror
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|utli_free
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftli_push
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftli_open
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|long
name|ibaud
operator|,
name|boolean
name|fwait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftli_close
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
name|boolean
name|fsuccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ftli_dial
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|pointer
name|puuconf
operator|,
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
expr|struct
name|uuconf_dialer
operator|*
name|qdialer
operator|,
expr|enum
name|tdialerfound
operator|*
name|ptdialer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The command table for a TLI connection.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sconncmds
name|stlicmds
init|=
block|{
name|utli_free
block|,
name|NULL
block|,
comment|/* pflock */
name|NULL
block|,
comment|/* pfunlock */
name|ftli_open
block|,
name|ftli_close
block|,
name|ftli_dial
block|,
name|fsysdep_conn_read
block|,
name|fsysdep_conn_write
block|,
name|fsysdep_conn_io
block|,
name|NULL
block|,
comment|/* pfbreak */
name|NULL
block|,
comment|/* pfset */
name|NULL
block|,
comment|/* pfcarrier */
name|fsysdep_conn_chat
block|,
name|NULL
comment|/* pibaud */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Get a TLI error string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ztlierror
parameter_list|()
block|{
if|if
condition|(
name|t_errno
operator|==
name|TSYSERR
condition|)
return|return
name|strerror
argument_list|(
name|errno
argument_list|)
return|;
if|if
condition|(
name|t_errno
operator|<
literal|0
operator|||
name|t_errno
operator|>=
name|t_nerr
condition|)
return|return
literal|"Unknown TLI error"
return|;
return|return
name|t_errlist
index|[
name|t_errno
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize a TLI connection.  This may be called with qconn->qport    NULL, when opening standard input as a TLI connection.  */
end_comment

begin_function
name|boolean
name|fsysdep_tli_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysdep_conn
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|owr
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|zdevice
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|iflags
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|iwr_flags
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|fterminal
operator|=
name|FALSE
expr_stmt|;
name|q
operator|->
name|ftli
operator|=
name|TRUE
expr_stmt|;
name|q
operator|->
name|ibaud
operator|=
literal|0
expr_stmt|;
name|qconn
operator|->
name|psysdep
operator|=
operator|(
name|pointer
operator|)
name|q
expr_stmt|;
name|qconn
operator|->
name|qcmds
operator|=
operator|&
name|stlicmds
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Free a TLI connection.  */
end_comment

begin_function
specifier|static
name|void
name|utli_free
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|xfree
argument_list|(
name|qconn
operator|->
name|psysdep
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push all desired modules onto a TLI stream.  If the user requests a    STREAMS connection without giving a list of modules, we just push    tirdwr.  If the I_PUSH ioctl is not defined on this system, we just    ignore any list of modules.  */
end_comment

begin_function
specifier|static
name|boolean
name|ftli_push
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|I_PUSH
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
if|if
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_pzpush
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
for|for
control|(
name|pz
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_pzpush
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|I_PUSH
argument_list|,
operator|*
name|pz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (I_PUSH, %s): %s"
argument_list|,
operator|*
name|pz
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_fstream
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|I_PUSH
argument_list|,
literal|"tirdwr"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ioctl (I_PUSH, tirdwr): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If we have just put the connection into stream mode, we must turn      off the TLI flag to avoid using TLI calls on it.  */
if|if
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_fstream
condition|)
name|qsysdep
operator|->
name|ftli
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* defined (I_PUSH) */
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a TLI connection.  If the fwait argument is TRUE, we are    running as a server.  Otherwise we are just trying to reach another    system.  */
end_comment

begin_function
specifier|static
name|boolean
name|ftli_open
parameter_list|(
name|qconn
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdevice
decl_stmt|;
name|char
modifier|*
name|zfreedev
decl_stmt|;
specifier|const
name|char
modifier|*
name|zservaddr
decl_stmt|;
name|char
modifier|*
name|zfreeaddr
decl_stmt|;
name|uid_t
name|ieuid
decl_stmt|;
name|boolean
name|fswap
decl_stmt|;
name|struct
name|t_bind
modifier|*
name|qtbind
decl_stmt|;
name|struct
name|t_call
modifier|*
name|qtcall
decl_stmt|;
comment|/* Unlike most other device types, we don't bother to call      ulog_device here, because fconn_open calls it with the name of      the port anyhow.  */
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|zdevice
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_zdevice
expr_stmt|;
if|if
condition|(
name|zdevice
operator|==
name|NULL
condition|)
name|zdevice
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_zname
expr_stmt|;
name|zfreedev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|zdevice
operator|!=
literal|'/'
condition|)
block|{
name|zfreedev
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|strlen
argument_list|(
name|zdevice
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfreedev
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|zdevice
argument_list|)
expr_stmt|;
name|zdevice
operator|=
name|zfreedev
expr_stmt|;
block|}
comment|/* If we are acting as a server, swap to our real user ID before      calling t_open.  This will permit the server to use privileged      TCP ports when invoked by root.  We only swap if our effective      user ID is not root, so that the program can also be made suid      root in order to get privileged ports when invoked by anybody.  */
name|fswap
operator|=
name|fwait
operator|&&
name|geteuid
argument_list|()
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|fswap
condition|)
block|{
if|if
condition|(
operator|!
name|fsuser_perms
argument_list|(
operator|&
name|ieuid
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfreedev
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|qsysdep
operator|->
name|o
operator|=
name|t_open
argument_list|(
name|zdevice
argument_list|,
name|O_RDWR
argument_list|,
operator|(
expr|struct
name|t_info
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_open (%s): %s"
argument_list|,
name|zdevice
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfreedev
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfreedev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t_close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qsysdep
operator|->
name|iflags
operator|=
name|fcntl
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|iflags
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfreedev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t_close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We save our process ID in the qconn structure.  This is checked      in ftli_close.  */
name|qsysdep
operator|->
name|ipid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* If we aren't waiting for a connection, we can bind to any local      address, and then we're finished.  */
if|if
condition|(
operator|!
name|fwait
condition|)
block|{
comment|/* fswap is known to be FALSE here.  */
name|ubuffree
argument_list|(
name|zfreedev
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_bind
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|t_bind
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|t_bind
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_bind: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t_close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Run as a server and wait for a new connection.  The code in      uucico.c has already detached us from our controlling terminal.      From this point on if the server gets an error we exit; we only      return if we have received a connection.  It would be more robust      to respawn the server if it fails; someday.  */
name|qtbind
operator|=
operator|(
expr|struct
name|t_bind
operator|*
operator|)
name|t_alloc
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|T_BIND
argument_list|,
name|T_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtbind
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_alloc (T_BIND): %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|zservaddr
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_zservaddr
expr_stmt|;
if|if
condition|(
name|zservaddr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Can't run as TLI server; no server address"
argument_list|)
expr_stmt|;
block|}
name|zfreeaddr
operator|=
name|zbufcpy
argument_list|(
name|zservaddr
argument_list|)
expr_stmt|;
name|qtbind
operator|->
name|addr
operator|.
name|len
operator|=
name|cescape
argument_list|(
name|zfreeaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtbind
operator|->
name|addr
operator|.
name|len
operator|>
name|qtbind
operator|->
name|addr
operator|.
name|maxlen
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: TLI server address too long (max %d)"
argument_list|,
name|zservaddr
argument_list|,
name|qtbind
operator|->
name|addr
operator|.
name|maxlen
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|qtbind
operator|->
name|addr
operator|.
name|buf
argument_list|,
name|zfreeaddr
argument_list|,
name|qtbind
operator|->
name|addr
operator|.
name|len
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfreeaddr
argument_list|)
expr_stmt|;
name|qtbind
operator|->
name|qlen
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|t_bind
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|qtbind
argument_list|,
operator|(
expr|struct
name|t_bind
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fswap
condition|)
operator|(
name|void
operator|)
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_bind (%s): %s"
argument_list|,
name|zservaddr
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fswap
condition|)
block|{
if|if
condition|(
operator|!
name|fsuucp_perms
argument_list|(
operator|(
name|long
operator|)
name|ieuid
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Could not swap back to UUCP user permissions"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|t_free
argument_list|(
operator|(
name|pointer
operator|)
name|qtbind
argument_list|,
name|T_BIND
argument_list|)
expr_stmt|;
name|qtcall
operator|=
operator|(
expr|struct
name|t_call
operator|*
operator|)
name|t_alloc
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|T_CALL
argument_list|,
name|T_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtcall
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_alloc (T_CALL): %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
name|int
name|onew
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftli_open: Waiting for connections"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_listen
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|qtcall
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_listen: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
name|onew
operator|=
name|t_open
argument_list|(
name|zdevice
argument_list|,
name|O_RDWR
argument_list|,
operator|(
expr|struct
name|t_info
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|onew
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_open (%s): %s"
argument_list|,
name|zdevice
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|onew
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_bind
argument_list|(
name|onew
argument_list|,
operator|(
expr|struct
name|t_bind
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|t_bind
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_bind: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_accept
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|onew
argument_list|,
name|qtcall
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We may have received a disconnect.  */
if|if
condition|(
name|t_errno
operator|!=
name|TLOOK
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_accept: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_rcvdis
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|t_discon
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"t_rcvdis: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t_close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftli_open: Got connection; forking"
argument_list|)
expr_stmt|;
name|ipid
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|==
literal|0
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|t_close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
expr_stmt|;
name|qsysdep
operator|->
name|o
operator|=
name|onew
expr_stmt|;
comment|/* Push any desired modules.  */
if|if
condition|(
operator|!
name|ftli_push
argument_list|(
name|qconn
argument_list|)
condition|)
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* Now we fork and let our parent die, so that we become 	     a child of init.  This lets the main server code wait 	     for its child and then continue without accumulating 	     zombie children.  */
name|ipid
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipid
operator|!=
literal|0
condition|)
name|_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
name|ulog_id
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|t_close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
comment|/* Now wait for the child.  */
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We got a signal.  */
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Avoid compiler warnings.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close the port.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ftli_close
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qdialer
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qsysdep
operator|->
name|o
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|qsysdep
operator|->
name|ftli
condition|)
block|{
if|if
condition|(
name|t_close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_close: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|close
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|qsysdep
operator|->
name|o
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If the current pid is not the one we used to open the port, then      we must have forked up above and we are now the child.  In this      case, we are being called from within the fendless loop in      uucico.c.  We return FALSE to force the loop to end and the child      to exit.  This should be handled in a cleaner fashion.  */
if|if
condition|(
name|qsysdep
operator|->
name|ipid
operator|!=
name|getpid
argument_list|()
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dial out on a TLI port, so to speak: connect to a remote computer.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ftli_dial
parameter_list|(
name|qconn
parameter_list|,
name|puuconf
parameter_list|,
name|qsys
parameter_list|,
name|zphone
parameter_list|,
name|qdialer
parameter_list|,
name|ptdialerfound
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|pointer
name|puuconf
decl_stmt|;
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|struct
name|uuconf_dialer
modifier|*
name|qdialer
decl_stmt|;
name|enum
name|tdialerfound
modifier|*
name|ptdialerfound
decl_stmt|;
block|{
name|struct
name|ssysdep_conn
modifier|*
name|qsysdep
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzdialer
decl_stmt|;
specifier|const
name|char
modifier|*
name|zaddr
decl_stmt|;
name|struct
name|t_call
modifier|*
name|qtcall
decl_stmt|;
name|char
modifier|*
name|zescape
decl_stmt|;
name|qsysdep
operator|=
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
expr_stmt|;
operator|*
name|ptdialerfound
operator|=
name|DIALERFOUND_FALSE
expr_stmt|;
name|pzdialer
operator|=
name|qconn
operator|->
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_stli
operator|.
name|uuconf_pzdialer
expr_stmt|;
if|if
condition|(
operator|*
name|pzdialer
operator|==
name|NULL
condition|)
name|pzdialer
operator|=
name|NULL
expr_stmt|;
comment|/* If the first dialer is "TLI" or "TLIS", we use the first token      (pzdialer[1]) as the address to connect to.  */
name|zaddr
operator|=
name|zphone
expr_stmt|;
if|if
condition|(
name|pzdialer
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|pzdialer
index|[
literal|0
index|]
argument_list|,
literal|"TLI"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|pzdialer
index|[
literal|0
index|]
argument_list|,
literal|"TLIS"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|pzdialer
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
operator|++
name|pzdialer
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pzdialer
index|[
literal|1
index|]
argument_list|,
literal|"\\D"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pzdialer
index|[
literal|1
index|]
argument_list|,
literal|"\\T"
argument_list|)
operator|!=
literal|0
condition|)
name|zaddr
operator|=
name|pzdialer
index|[
literal|1
index|]
expr_stmt|;
name|pzdialer
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zaddr
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No address for TLI connection"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qtcall
operator|=
operator|(
expr|struct
name|t_call
operator|*
operator|)
name|t_alloc
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|T_CALL
argument_list|,
name|T_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtcall
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_alloc (T_CALL): %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zescape
operator|=
name|zbufcpy
argument_list|(
name|zaddr
argument_list|)
expr_stmt|;
name|qtcall
operator|->
name|addr
operator|.
name|len
operator|=
name|cescape
argument_list|(
name|zescape
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtcall
operator|->
name|addr
operator|.
name|len
operator|>
name|qtcall
operator|->
name|addr
operator|.
name|maxlen
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: TLI address too long (max %d)"
argument_list|,
name|zaddr
argument_list|,
name|qtcall
operator|->
name|addr
operator|.
name|maxlen
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zescape
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memcpy
argument_list|(
name|qtcall
operator|->
name|addr
operator|.
name|buf
argument_list|,
name|zescape
argument_list|,
name|qtcall
operator|->
name|addr
operator|.
name|len
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zescape
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_connect
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
name|qtcall
argument_list|,
operator|(
expr|struct
name|t_call
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|t_errno
operator|!=
name|TLOOK
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_connect: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|t_rcvdis
argument_list|(
name|qsysdep
operator|->
name|o
argument_list|,
operator|(
expr|struct
name|t_discon
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"t_rcvdis: %s"
argument_list|,
name|ztlierror
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Connection refused"
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
comment|/* We've connected to the remote.  Push any desired modules.  */
if|if
condition|(
operator|!
name|ftli_push
argument_list|(
name|qconn
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Handle the rest of the dialer sequence.  */
if|if
condition|(
name|pzdialer
operator|!=
name|NULL
operator|&&
operator|*
name|pzdialer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fconn_dial_sequence
argument_list|(
name|qconn
argument_list|,
name|puuconf
argument_list|,
name|pzdialer
argument_list|,
name|qsys
argument_list|,
name|zphone
argument_list|,
name|qdialer
argument_list|,
name|ptdialerfound
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TLI */
end_comment

end_unit

