begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* recep.c    See whether a file has already been received.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zsreceived_name
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|uuconf_system
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|ztemp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* These routines are used to see whether we have already received a    file in a previous UUCP connection.  It is possible for the    acknowledgement of a received file to be lost.  The sending system    will then not know that the file was correctly received, and will    send it again.  This can be a problem particularly with protocols    which support channels, since they may send several small files in    a single window, all of which may be received correctly although    the sending system never sees the acknowledgement.  If these files    involve an execution, the execution will happen twice, which will    be bad.     We use a simple system.  For each file we want to remember, we    create an empty file names .Received/SYS/TEMP, where SYS is the    name of the system and TEMP is the name of the temporary file used    by the sender.  If no temporary file is used by the sender, we    don't remember that we received the file.  This is not perfect, but    execution files will always have a temporary file, so the most    important case is handled.  Also, any file received from Taylor    UUCP 1.04 or greater will always have a temporary file.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the name we are going use for the marker, or NULL if we have    no name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zsreceived_name
parameter_list|(
name|qsys
parameter_list|,
name|ztemp
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
block|{
if|if
condition|(
name|ztemp
operator|!=
name|NULL
operator|&&
operator|*
name|ztemp
operator|==
literal|'D'
operator|&&
name|strcmp
argument_list|(
name|ztemp
argument_list|,
literal|"D.0"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|zsappend3
argument_list|(
literal|".Received"
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|ztemp
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Remember that we have already received a file.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fsysdep_remember_reception
parameter_list|(
name|qsys
parameter_list|,
name|zto
parameter_list|,
name|ztemp
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
block|{
name|char
modifier|*
name|zfile
decl_stmt|;
name|int
name|o
decl_stmt|;
name|zfile
operator|=
name|zsreceived_name
argument_list|(
name|qsys
argument_list|,
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|o
operator|=
name|creat
argument_list|(
name|zfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|fsysdep_make_dirs
argument_list|(
name|zfile
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|o
operator|=
name|creat
argument_list|(
name|zfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"creat (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
comment|/* We don't have to actually put anything in the file; we just use      the name.  This is more convenient than keeping a file with a      list of names.  */
if|if
condition|(
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fsysdep_remember_reception: close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The number of seconds in one week.  We must cast to long for this    to be calculated correctly on a machine with 16 bit ints.  */
end_comment

begin_define
define|#
directive|define
name|SECS_PER_WEEK
value|((long) 7 * (long) 24 * (long) 60 * (long) 60)
end_define

begin_comment
comment|/* See if we have already received a file.  Note that don't delete the    marker file here, because we need to know that the sending system    has received our denial first.  This function returns TRUE if the    file has already been received, FALSE if it has not.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fsysdep_already_received
parameter_list|(
name|qsys
parameter_list|,
name|zto
parameter_list|,
name|ztemp
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
block|{
name|char
modifier|*
name|zfile
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zfile
operator|=
name|zsreceived_name
argument_list|(
name|qsys
argument_list|,
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|stat
argument_list|(
name|zfile
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Ignore the file (return FALSE) if it is over one week old.  */
name|fret
operator|=
name|s
operator|.
name|st_mtime
operator|+
name|SECS_PER_WEEK
operator|>=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"fsysdep_already_received: Found %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Forget that we have received a file.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fsysdep_forget_reception
parameter_list|(
name|qsys
parameter_list|,
name|zto
parameter_list|,
name|ztemp
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
block|{
name|char
modifier|*
name|zfile
decl_stmt|;
name|zfile
operator|=
name|zsreceived_name
argument_list|(
name|qsys
argument_list|,
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|remove
argument_list|(
name|zfile
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

