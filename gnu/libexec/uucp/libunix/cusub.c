begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cusub.c    System dependent routines for cu.     Copyright (C) 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|cusub_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cu.h"
end_include

begin_include
include|#
directive|include
file|"conn.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for both O_NONBLOCK and O_NDELAY.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NDELAY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNDELAY
end_ifdef

begin_define
define|#
directive|define
name|O_NDELAY
value|FNDELAY
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_define
define|#
directive|define
name|O_NDELAY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NDELAY) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNBLOCK
end_ifdef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|FNBLOCK
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_define
define|#
directive|define
name|O_NONBLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NONBLOCK) */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_comment
comment|/* 4.2 systems don't define SIGUSR2.  This should work for them.  On    systems which are missing SIGUSR1, or SIGURG, you must find two    signals which you can safely use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIGUSR2
end_ifndef

begin_define
define|#
directive|define
name|SIGUSR2
value|SIGURG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for EAGAIN, EWOULDBLOCK and ENODATA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EAGAIN
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EAGAIN
value|(-1)
end_define

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_define
define|#
directive|define
name|EAGAIN
value|EWOULDBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (EWOULDBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENODATA
end_ifndef

begin_define
define|#
directive|define
name|ENODATA
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* The EOF character, as set by fsysdep_terminal_raw.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bSeof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The SUSP character, as set by fsysdep_terminal_raw.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bStstp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zsport_line
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|uuconf_port
operator|*
name|qport
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uscu_child
name|P
argument_list|(
operator|(
expr|struct
name|sconnection
operator|*
name|qconn
operator|,
name|int
name|opipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|uscu_child_handler
name|P
argument_list|(
operator|(
name|int
name|isig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|uscu_alarm
name|P
argument_list|(
operator|(
name|int
name|isig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cscu_escape
name|P
argument_list|(
operator|(
name|char
operator|*
name|pbcmd
operator|,
specifier|const
name|char
operator|*
name|zlocalname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|uscu_alarm_kill
name|P
argument_list|(
operator|(
name|int
name|isig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the device name for a port, or NULL if none.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zsport_line
parameter_list|(
name|qport
parameter_list|)
specifier|const
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zline
decl_stmt|;
if|if
condition|(
name|qport
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|qport
operator|->
name|uuconf_ttype
condition|)
block|{
default|default:
case|case
name|UUCONF_PORTTYPE_STDIN
case|:
return|return
name|NULL
return|;
case|case
name|UUCONF_PORTTYPE_MODEM
case|:
name|zline
operator|=
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_smodem
operator|.
name|uuconf_zdevice
expr_stmt|;
break|break;
case|case
name|UUCONF_PORTTYPE_DIRECT
case|:
name|zline
operator|=
name|qport
operator|->
name|uuconf_u
operator|.
name|uuconf_sdirect
operator|.
name|uuconf_zdevice
expr_stmt|;
break|break;
case|case
name|UUCONF_PORTTYPE_TCP
case|:
case|case
name|UUCONF_PORTTYPE_TLI
case|:
case|case
name|UUCONF_PORTTYPE_PIPE
case|:
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|zline
operator|==
name|NULL
condition|)
name|zline
operator|=
name|qport
operator|->
name|uuconf_zname
expr_stmt|;
return|return
name|zline
return|;
block|}
end_function

begin_comment
comment|/* Check whether the user has legitimate access to a port.  */
end_comment

begin_function
name|boolean
name|fsysdep_port_access
parameter_list|(
name|qport
parameter_list|)
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zline
decl_stmt|;
name|char
modifier|*
name|zfree
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zline
operator|=
name|zsport_line
argument_list|(
name|qport
argument_list|)
expr_stmt|;
if|if
condition|(
name|zline
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|zfree
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|zline
operator|!=
literal|'/'
condition|)
block|{
name|zfree
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|strlen
argument_list|(
name|zline
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfree
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|zline
argument_list|)
expr_stmt|;
name|zline
operator|=
name|zfree
expr_stmt|;
block|}
name|fret
operator|=
name|access
argument_list|(
name|zline
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Return whether the given port is named by the given line.  */
end_comment

begin_function
name|boolean
name|fsysdep_port_is_line
parameter_list|(
name|qport
parameter_list|,
name|zline
parameter_list|)
name|struct
name|uuconf_port
modifier|*
name|qport
decl_stmt|;
specifier|const
name|char
modifier|*
name|zline
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zpline
decl_stmt|;
name|char
modifier|*
name|zfree1
decl_stmt|,
modifier|*
name|zfree2
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zpline
operator|=
name|zsport_line
argument_list|(
name|qport
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpline
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|zline
argument_list|,
name|zpline
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|zfree1
operator|=
name|NULL
expr_stmt|;
name|zfree2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|zline
operator|!=
literal|'/'
condition|)
block|{
name|zfree1
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|strlen
argument_list|(
name|zline
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfree1
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|zline
argument_list|)
expr_stmt|;
name|zline
operator|=
name|zfree1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|zpline
operator|!=
literal|'/'
condition|)
block|{
name|zfree2
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|strlen
argument_list|(
name|zpline
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfree2
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|zpline
argument_list|)
expr_stmt|;
name|zpline
operator|=
name|zfree2
expr_stmt|;
block|}
name|fret
operator|=
name|strcmp
argument_list|(
name|zline
argument_list|,
name|zpline
argument_list|)
operator|==
literal|0
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree1
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree2
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The cu program wants the system dependent layer to handle the    details of copying data from the communications port to the    terminal.  This copying need only be done while executing    fsysdep_cu.  On Unix, however, we set up a subprocess to do it all    the time.  This subprocess must be controllable via the    fsysdep_cu_copy function.     We keep a pipe open to the subprocess.  When we want it to stop we    send it a signal, and then wait for it to write a byte to us over    the pipe.  */
end_comment

begin_comment
comment|/* The subprocess pid.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|pid_t
name|iSchild
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pipe from the subprocess.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oSpipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we tell the child to stop, it sends this.  */
end_comment

begin_define
define|#
directive|define
name|CHILD_STOPPED
value|('S')
end_define

begin_comment
comment|/* When we tell the child to start, it sends this.  */
end_comment

begin_define
define|#
directive|define
name|CHILD_STARTED
value|('G')
end_define

begin_comment
comment|/* Initialize the subprocess, and have it start copying data.  */
end_comment

begin_function
name|boolean
name|fsysdep_cu_init
parameter_list|(
name|qconn
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
block|{
name|int
name|ai
index|[
literal|2
index|]
decl_stmt|;
comment|/* Write out anything we may have buffered up during the chat      script.  We do this before forking the child only to make it easy      to move the child into a separate executable.  */
while|while
condition|(
name|iPrecend
operator|!=
name|iPrecstart
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
name|z
operator|=
name|abPrecbuf
operator|+
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|iPrecend
operator|>
name|iPrecstart
condition|)
name|c
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
else|else
name|c
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|c
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
while|while
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|int
name|cwrote
decl_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrote
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Line disconnected"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|c
operator|-=
name|cwrote
expr_stmt|;
name|z
operator|+=
name|cwrote
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipe
argument_list|(
name|ai
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|iSchild
operator|=
name|ixsfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|iSchild
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|iSchild
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ai
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|uscu_child
argument_list|(
name|qconn
argument_list|,
name|ai
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|ai
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|oSpipe
operator|=
name|ai
index|[
literal|0
index|]
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy all data from the terminal to the communications port.  If we    see an escape character following a newline character, read the    next character and return it.  */
end_comment

begin_function
name|boolean
name|fsysdep_cu
parameter_list|(
name|qconn
parameter_list|,
name|pbcmd
parameter_list|,
name|zlocalname
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|char
modifier|*
name|pbcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
block|{
name|boolean
name|fstart
decl_stmt|;
name|char
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
name|fstart
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
name|usysdep_start_catch
argument_list|()
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|c
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|fstart
operator|&&
name|b
operator|==
operator|*
name|zCuvar_escape
operator|&&
name|b
operator|!=
literal|'\0'
condition|)
block|{
name|c
operator|=
name|cscu_escape
argument_list|(
name|pbcmd
argument_list|,
name|zlocalname
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pbcmd
operator|!=
name|b
condition|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
name|pbcmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For Unix, we let the eof character be the same as 		 '.', and we let the suspend character (if any) be the 		 same as 'z'.  */
if|if
condition|(
operator|*
name|pbcmd
operator|==
name|bSeof
condition|)
operator|*
name|pbcmd
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
operator|*
name|pbcmd
operator|==
name|bStstp
condition|)
operator|*
name|pbcmd
operator|=
literal|'z'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fconn_write
argument_list|(
name|qconn
argument_list|,
operator|&
name|b
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fstart
operator|=
name|strchr
argument_list|(
name|zCuvar_eol
argument_list|,
name|b
argument_list|)
operator|!=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* I'm not sure what's best in this case.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"End of file on terminal"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* A SIGALRM handler that sets fScu_alarm and optionally longjmps.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|fScu_alarm
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|uscu_alarm
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|HAVE_SIGACTION
operator|&&
operator|!
name|HAVE_SIGVEC
operator|&&
operator|!
name|HAVE_SIGSET
operator|(
name|void
operator|)
name|signal
argument_list|(
name|isig
argument_list|,
name|uscu_alarm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fScu_alarm
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|HAVE_RESTARTABLE_SYSCALLS
if|if
condition|(
name|fSjmp
condition|)
name|longjmp
argument_list|(
name|sSjmp_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* We've just seen an escape character.  We print the host name,    optionally after a 1 second delay.  We read the next character from    the terminal and return it.  The 1 second delay on the host name is    mostly to be fancy; it lets ~~ look smoother.  */
end_comment

begin_function
specifier|static
name|int
name|cscu_escape
parameter_list|(
name|pbcmd
parameter_list|,
name|zlocalname
parameter_list|)
name|char
modifier|*
name|pbcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
block|{
name|CATCH_PROTECT
name|int
name|c
decl_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|zCuvar_escape
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fScu_alarm
operator|=
name|FALSE
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|uscu_alarm
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
name|usysdep_start_catch
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|fScu_alarm
condition|)
block|{
name|char
name|b
decl_stmt|;
name|fScu_alarm
operator|=
name|FALSE
expr_stmt|;
name|b
operator|=
literal|'['
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|zlocalname
argument_list|,
name|strlen
argument_list|(
name|zlocalname
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
literal|']'
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
name|c
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|pbcmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|usysdep_end_catch
argument_list|()
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A SIGALRM handler which does nothing but send a signal to the child    process and schedule another alarm.  POSIX.1 permits kill and alarm    from a signal handler.  The reference to static data may or may not    be permissible.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|iSsend_sig
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|uscu_alarm_kill
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|HAVE_SIGACTION
operator|&&
operator|!
name|HAVE_SIGVEC
operator|&&
operator|!
name|HAVE_SIGSET
operator|(
name|void
operator|)
name|signal
argument_list|(
name|isig
argument_list|,
name|uscu_alarm_kill
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|kill
argument_list|(
name|iSchild
argument_list|,
name|iSsend_sig
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start or stop copying data from the communications port to the    terminal.  We send a signal to the child process to tell it what to    do.  Unfortunately, there are race conditions in the child, so we    keep sending it a signal once a second until it responds.  We send    SIGUSR1 to make it start copying, and SIGUSR2 to make it stop.  */
end_comment

begin_function
name|boolean
name|fsysdep_cu_copy
parameter_list|(
name|fcopy
parameter_list|)
name|boolean
name|fcopy
decl_stmt|;
block|{
name|int
name|ierr
decl_stmt|;
name|int
name|c
decl_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|uscu_alarm_kill
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcopy
condition|)
name|iSsend_sig
operator|=
name|SIGUSR1
expr_stmt|;
else|else
name|iSsend_sig
operator|=
name|SIGUSR2
expr_stmt|;
name|uscu_alarm_kill
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
name|b
decl_stmt|;
name|c
operator|=
name|read
argument_list|(
name|oSpipe
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_INCOMING
argument_list|,
literal|"fsysdep_cu_copy: Got '%d'"
argument_list|,
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
operator|)
operator|||
name|c
operator|==
literal|0
operator|||
operator|(
name|c
operator|>
literal|0
operator|&&
name|b
operator|==
operator|(
name|fcopy
condition|?
name|CHILD_STARTED
else|:
name|CHILD_STOPPED
operator|)
operator|)
condition|)
break|break;
comment|/* If none of the above conditions were true, then we either got 	 an EINTR error, in which case we probably timed out and the 	 SIGALRM handler resent the signal, or we read the wrong 	 character, in which case we will just read again from the 	 pipe.  */
block|}
name|ierr
operator|=
name|errno
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"EOF on child pipe"
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Shut down cu by killing the child process.  */
end_comment

begin_function
name|boolean
name|fsysdep_cu_finish
parameter_list|()
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|oSpipe
argument_list|)
expr_stmt|;
comment|/* We hit the child with SIGTERM, give it two seconds to die, and      then send a SIGKILL.  */
if|if
condition|(
name|kill
argument_list|(
name|iSchild
argument_list|,
name|SIGTERM
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Don't give an error if the child has already died.  */
if|if
condition|(
name|errno
operator|!=
name|ESRCH
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"kill: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|uscu_alarm_kill
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|iSsend_sig
operator|=
name|SIGKILL
expr_stmt|;
name|alarm
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|iSchild
argument_list|,
literal|"child"
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for the child process.  */
end_comment

begin_comment
comment|/* This signal handler just records the signal.  In this case we only    care about which signal we received most recently.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|iSchild_sig
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|uscu_child_handler
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|HAVE_SIGACTION
operator|&&
operator|!
name|HAVE_SIGVEC
operator|&&
operator|!
name|HAVE_SIGSET
operator|(
name|void
operator|)
name|signal
argument_list|(
name|isig
argument_list|,
name|uscu_child_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iSchild_sig
operator|=
name|isig
expr_stmt|;
if|#
directive|if
name|HAVE_RESTARTABLE_SYSCALLS
if|if
condition|(
name|fSjmp
condition|)
name|longjmp
argument_list|(
name|sSjmp_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_RESTARTABLE_SYSCALLS */
block|}
end_function

begin_comment
comment|/* The child process.  This copies the port to the terminal, except    when it is stopped by a signal.  It would be reasonable to write a    separate program for this, probably passing it the port on stdin.    This would reduce the memory requirements, since we wouldn't need a    second process holding all the configuration stuff, and also let it    work reasonably on 680x0 versions of MINIX.  */
end_comment

begin_function
specifier|static
name|void
name|uscu_child
parameter_list|(
name|qconn
parameter_list|,
name|opipe
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
name|int
name|opipe
decl_stmt|;
block|{
name|CATCH_PROTECT
name|int
name|oport
decl_stmt|;
name|CATCH_PROTECT
name|boolean
name|fstopped
decl_stmt|,
name|fgot
decl_stmt|;
name|CATCH_PROTECT
name|int
name|cwrite
decl_stmt|;
name|CATCH_PROTECT
name|char
name|abbuf
index|[
literal|1024
index|]
decl_stmt|;
name|fgot
operator|=
name|FALSE
expr_stmt|;
comment|/* It would be nice if we could just use fsysdep_conn_read, but that      will log signals that we don't want logged.  There should be a      generic way to extract the file descriptor from the port.  */
if|if
condition|(
name|qconn
operator|->
name|qport
operator|==
name|NULL
condition|)
name|oport
operator|=
literal|0
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_ttype
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"uscu_child: Can't happen"
argument_list|)
expr_stmt|;
name|oport
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|UUCONF_PORTTYPE_PIPE
case|:
comment|/* A read of 0 on a pipe always means EOF (see below).  */
name|fgot
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through.  */
case|case
name|UUCONF_PORTTYPE_STDIN
case|:
name|oport
operator|=
operator|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
operator|)
operator|->
name|ord
expr_stmt|;
break|break;
case|case
name|UUCONF_PORTTYPE_MODEM
case|:
case|case
name|UUCONF_PORTTYPE_DIRECT
case|:
case|case
name|UUCONF_PORTTYPE_TCP
case|:
case|case
name|UUCONF_PORTTYPE_TLI
case|:
name|oport
operator|=
operator|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
operator|)
operator|->
name|o
expr_stmt|;
break|break;
block|}
block|}
comment|/* Force the descriptor into blocking mode.  */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|oport
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|oport
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
operator|(
name|O_NDELAY
operator||
name|O_NONBLOCK
operator|)
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGUSR1
argument_list|,
name|uscu_child_handler
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGUSR2
argument_list|,
name|uscu_child_handler
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usset_signal
argument_list|(
name|SIGTERM
argument_list|,
name|uscu_child_handler
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fstopped
operator|=
name|FALSE
expr_stmt|;
name|iSchild_sig
operator|=
literal|0
expr_stmt|;
name|cwrite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
name|usysdep_start_catch
argument_list|()
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|isig
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* There is a race condition here between checking the signal 	 and receiving a new and possibly different one.  This is 	 solved by having the parent resend the signal until it gets a 	 response.  */
name|isig
operator|=
name|iSchild_sig
expr_stmt|;
name|iSchild_sig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isig
operator|!=
literal|0
condition|)
block|{
name|char
name|b
decl_stmt|;
if|if
condition|(
name|isig
operator|==
name|SIGTERM
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isig
operator|==
name|SIGUSR1
condition|)
block|{
name|fstopped
operator|=
name|FALSE
expr_stmt|;
name|b
operator|=
name|CHILD_STARTED
expr_stmt|;
block|}
else|else
block|{
name|fstopped
operator|=
name|TRUE
expr_stmt|;
name|b
operator|=
name|CHILD_STOPPED
expr_stmt|;
name|cwrite
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|write
argument_list|(
name|opipe
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Apparently on some systems we can get EAGAIN here.  */
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|ENODATA
operator|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
comment|/* Should we give an error message here?  */
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fstopped
condition|)
name|pause
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cwrite
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|zbuf
decl_stmt|;
name|zbuf
operator|=
name|abbuf
expr_stmt|;
while|while
condition|(
name|cwrite
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|zbuf
argument_list|,
name|cwrite
argument_list|)
expr_stmt|;
comment|/* Apparently on some systems we can get EAGAIN here.  */
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|ENODATA
operator|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
break|break;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
comment|/* Should we give an error message here?  */
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|cwrite
operator|-=
name|c
expr_stmt|;
name|zbuf
operator|+=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* On some systems apparently read will return 0 until 	     something has been written to the port.  We therefore 	     accept a 0 return until after we have managed to read 	     something.  Setting errno to 0 apparently avoids a 	     problem on Coherent.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|read
argument_list|(
name|oport
argument_list|,
name|abbuf
argument_list|,
sizeof|sizeof
name|abbuf
argument_list|)
expr_stmt|;
comment|/* Apparently on some systems we can get EAGAIN here.  */
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|ENODATA
operator|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|0
operator|&&
name|fgot
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
operator|)
condition|)
block|{
comment|/* This can be a normal way to exit, depending on just 		 how the connection is dropped.  */
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|fgot
operator|=
name|TRUE
expr_stmt|;
name|cwrite
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Terminal control routines.  */
end_comment

begin_comment
comment|/* Whether file descriptor 0 is attached to a terminal or not.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fSterm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are doing local echoing.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fSlocalecho
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The original state of the terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|sterminal
name|sSterm_orig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The new state of the terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|sterminal
name|sSterm_new
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|HAVE_BSD_TTY
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/* Whether SIGTSTP is being ignored.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fStstp_ignored
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set the terminal into raw mode.  */
end_comment

begin_function
name|boolean
name|fsysdep_terminal_raw
parameter_list|(
name|flocalecho
parameter_list|)
name|boolean
name|flocalecho
decl_stmt|;
block|{
name|fSlocalecho
operator|=
name|flocalecho
expr_stmt|;
comment|/* This defaults may be overriden below.  */
name|bSeof
operator|=
literal|'\004'
expr_stmt|;
name|bStstp
operator|=
literal|'\032'
expr_stmt|;
if|if
condition|(
operator|!
name|fgetterminfo
argument_list|(
literal|0
argument_list|,
operator|&
name|sSterm_orig
argument_list|)
condition|)
block|{
name|fSterm
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|fSterm
operator|=
name|TRUE
expr_stmt|;
name|sSterm_new
operator|=
name|sSterm_orig
expr_stmt|;
if|#
directive|if
name|HAVE_BSD_TTY
comment|/* We use CBREAK mode rather than RAW mode, because RAW mode turns      off all output processing, which we don't want to do.  This means      that we have to disable the interrupt characters, which we do by      setting them to -1.  */
name|bSeof
operator|=
name|sSterm_orig
operator|.
name|stchars
operator|.
name|t_eofc
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_quitc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_startc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_eofc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_brkc
operator|=
operator|-
literal|1
expr_stmt|;
name|bStstp
operator|=
name|sSterm_orig
operator|.
name|sltchars
operator|.
name|t_suspc
expr_stmt|;
name|sSterm_new
operator|.
name|sltchars
operator|.
name|t_suspc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|sltchars
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|sltchars
operator|.
name|t_rprntc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|sltchars
operator|.
name|t_flushc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|sltchars
operator|.
name|t_werasc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|sltchars
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flocalecho
condition|)
block|{
name|sSterm_new
operator|.
name|stty
operator|.
name|sg_flags
operator||=
operator|(
name|CBREAK
operator||
name|ANYP
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|stty
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator||
name|TANDEM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sSterm_new
operator|.
name|stty
operator|.
name|sg_flags
operator||=
operator|(
name|CBREAK
operator||
name|ANYP
operator||
name|ECHO
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|stty
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|CRMOD
operator||
name|TANDEM
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTY */
if|#
directive|if
name|HAVE_SYSV_TERMIO
name|bSeof
operator|=
name|sSterm_new
operator|.
name|c_cc
index|[
name|VEOF
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|flocalecho
condition|)
name|sSterm_new
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ISIG
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
else|else
name|sSterm_new
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ISIG
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator||
name|IXON
operator||
name|IXOFF
operator||
name|IXANY
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OPOST
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYSV_TERMIO */
if|#
directive|if
name|HAVE_POSIX_TERMIOS
name|bSeof
operator|=
name|sSterm_new
operator|.
name|c_cc
index|[
name|VEOF
index|]
expr_stmt|;
name|bStstp
operator|=
name|sSterm_new
operator|.
name|c_cc
index|[
name|VSUSP
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|flocalecho
condition|)
name|sSterm_new
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
else|else
name|sSterm_new
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator||
name|IXON
operator||
name|IXOFF
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OPOST
operator|)
expr_stmt|;
name|sSterm_new
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POSIX_TERMIOS */
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
literal|0
argument_list|,
operator|&
name|sSterm_new
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't set terminal settings: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Restore the terminal to its original setting.  */
end_comment

begin_function
name|boolean
name|fsysdep_terminal_restore
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fSterm
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
literal|0
argument_list|,
operator|&
name|sSterm_orig
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't restore terminal: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read a line from the terminal.  This will be called after    fsysdep_terminal_raw has been called.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_terminal_line
parameter_list|(
name|zprompt
parameter_list|)
specifier|const
name|char
modifier|*
name|zprompt
decl_stmt|;
block|{
name|CATCH_PROTECT
name|size_t
name|cbuf
init|=
literal|0
decl_stmt|;
name|CATCH_PROTECT
name|char
modifier|*
name|zbuf
init|=
name|NULL
decl_stmt|;
name|CATCH_PROTECT
name|size_t
name|cgot
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zprompt
operator|!=
name|NULL
operator|&&
operator|*
name|zprompt
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|zprompt
argument_list|,
name|strlen
argument_list|(
name|zprompt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Forgot about any previous SIGINT or SIGQUIT signals we may have      received.  We don't worry about the race condition here, since we      can't get these signals from the terminal at the moment and it's      not too likely that somebody else will be sending them to us.  */
name|afSignal
index|[
name|INDEXSIG_SIGINT
index|]
operator|=
literal|0
expr_stmt|;
name|afSignal
index|[
name|INDEXSIG_SIGQUIT
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_terminal_restore
argument_list|()
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
name|usysdep_start_catch
argument_list|()
expr_stmt|;
name|cbuf
operator|=
literal|0
expr_stmt|;
name|zbuf
operator|=
name|NULL
expr_stmt|;
name|cgot
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|afSignal
index|[
name|INDEXSIG_SIGINT
index|]
operator|||
name|afSignal
index|[
name|INDEXSIG_SIGQUIT
index|]
condition|)
block|{
name|usysdep_end_catch
argument_list|()
expr_stmt|;
comment|/* Make sure the signal is logged.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Return an empty string.  */
name|cgot
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* There's a race here between checking the signals and calling 	 read.  It just means that the user will have to hit ^C more 	 than once.  */
name|c
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|usysdep_end_catch
argument_list|()
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_terminal_raw
argument_list|(
name|fSlocalecho
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* I'm not quite sure what to do here.  */
name|usysdep_end_catch
argument_list|()
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"EOF on terminal"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_terminal_raw
argument_list|(
name|fSlocalecho
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cgot
operator|>=
name|cbuf
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|cbuf
operator|+=
literal|64
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbuf
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|znew
argument_list|,
name|zbuf
argument_list|,
name|cgot
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
block|}
name|zbuf
operator|=
name|znew
expr_stmt|;
block|}
name|zbuf
index|[
name|cgot
index|]
operator|=
name|b
expr_stmt|;
operator|++
name|cgot
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\n'
condition|)
block|{
name|usysdep_end_catch
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cgot
operator|>=
name|cbuf
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
operator|++
name|cbuf
expr_stmt|;
name|znew
operator|=
name|zbufalc
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbuf
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|znew
argument_list|,
name|zbuf
argument_list|,
name|cgot
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
block|}
name|zbuf
operator|=
name|znew
expr_stmt|;
block|}
name|zbuf
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_terminal_raw
argument_list|(
name|fSlocalecho
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|zbuf
return|;
block|}
end_function

begin_comment
comment|/* Write a line to the terminal with a trailing newline.  */
end_comment

begin_function
name|boolean
name|fsysdep_terminal_puts
parameter_list|(
name|zline
parameter_list|)
specifier|const
name|char
modifier|*
name|zline
decl_stmt|;
block|{
name|char
modifier|*
name|zalc
decl_stmt|,
modifier|*
name|zprint
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
if|if
condition|(
name|zline
operator|==
name|NULL
condition|)
block|{
name|zalc
operator|=
name|zbufalc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
expr_stmt|;
name|zalc
operator|=
name|zbufalc
argument_list|(
name|clen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalc
argument_list|,
name|zline
argument_list|,
name|clen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fSterm
condition|)
block|{
name|zalc
index|[
name|clen
index|]
operator|=
literal|'\r'
expr_stmt|;
operator|++
name|clen
expr_stmt|;
block|}
name|zalc
index|[
name|clen
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|clen
expr_stmt|;
name|zprint
operator|=
name|zalc
expr_stmt|;
while|while
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|zprint
argument_list|,
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|clen
operator|-=
name|c
expr_stmt|;
name|zprint
operator|+=
name|c
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|zalc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allow or disallow signals from the terminal.  */
end_comment

begin_function
name|boolean
name|fsysdep_terminal_signals
parameter_list|(
name|faccept
parameter_list|)
name|boolean
name|faccept
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_BSD_TTY
if|if
condition|(
name|faccept
condition|)
block|{
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_intrc
operator|=
name|sSterm_orig
operator|.
name|stchars
operator|.
name|t_intrc
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_quitc
operator|=
name|sSterm_orig
operator|.
name|stchars
operator|.
name|t_quitc
expr_stmt|;
block|}
else|else
block|{
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
name|sSterm_new
operator|.
name|stchars
operator|.
name|t_quitc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_BSD_TTY */
if|if
condition|(
name|faccept
condition|)
name|sSterm_new
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
else|else
name|sSterm_new
operator|.
name|c_lflag
operator|&=
operator|~
name|ISIG
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* We only want to get SIGINT and SIGQUIT, not SIGTSTP.  This      function will be called with faccept TRUE before it is called      with faccept FALSE, so fStstp_ignored will be correctly      initialized.  */
if|if
condition|(
name|faccept
condition|)
name|usset_signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|,
name|FALSE
argument_list|,
operator|&
name|fStstp_ignored
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|fStstp_ignored
condition|)
name|usset_signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ! HAVE_BSD_TTY */
if|if
condition|(
operator|!
name|fsetterminfo
argument_list|(
literal|0
argument_list|,
operator|&
name|sSterm_new
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't set terminal: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start up a command, or possibly just a shell.  Optionally attach    stdin or stdout to the port.  We attach directly to the port,    rather than copying the data ourselves.  */
end_comment

begin_function
name|boolean
name|fsysdep_shell
parameter_list|(
name|qconn
parameter_list|,
name|zcmd
parameter_list|,
name|tcmd
parameter_list|)
name|struct
name|sconnection
modifier|*
name|qconn
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
name|enum
name|tshell_cmd
name|tcmd
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|azargs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|oread
decl_stmt|,
name|owrite
decl_stmt|;
name|int
name|aidescs
index|[
literal|3
index|]
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
if|if
condition|(
name|tcmd
operator|!=
name|SHELL_NORMAL
condition|)
name|azargs
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
else|else
block|{
name|azargs
index|[
literal|0
index|]
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|azargs
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|azargs
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
block|}
if|if
condition|(
name|zcmd
operator|==
name|NULL
operator|||
operator|*
name|zcmd
operator|==
literal|'\0'
condition|)
name|azargs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|azargs
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
name|azargs
index|[
literal|2
index|]
operator|=
name|zcmd
expr_stmt|;
name|azargs
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qconn
operator|->
name|qport
operator|==
name|NULL
condition|)
block|{
name|oread
operator|=
literal|0
expr_stmt|;
name|owrite
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|qconn
operator|->
name|qport
operator|->
name|uuconf_ttype
condition|)
block|{
default|default:
name|oread
operator|=
name|owrite
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|UUCONF_PORTTYPE_STDIN
case|:
case|case
name|UUCONF_PORTTYPE_PIPE
case|:
name|oread
operator|=
operator|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
operator|)
operator|->
name|ord
expr_stmt|;
name|owrite
operator|=
operator|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
operator|)
operator|->
name|owr
expr_stmt|;
break|break;
case|case
name|UUCONF_PORTTYPE_MODEM
case|:
case|case
name|UUCONF_PORTTYPE_DIRECT
case|:
case|case
name|UUCONF_PORTTYPE_TCP
case|:
case|case
name|UUCONF_PORTTYPE_TLI
case|:
name|oread
operator|=
name|owrite
operator|=
operator|(
operator|(
expr|struct
name|ssysdep_conn
operator|*
operator|)
name|qconn
operator|->
name|psysdep
operator|)
operator|->
name|o
expr_stmt|;
break|break;
block|}
block|}
name|aidescs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|aidescs
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|tcmd
operator|==
name|SHELL_STDIN_FROM_PORT
operator|||
name|tcmd
operator|==
name|SHELL_STDIO_ON_PORT
condition|)
name|aidescs
index|[
literal|0
index|]
operator|=
name|oread
expr_stmt|;
if|if
condition|(
name|tcmd
operator|==
name|SHELL_STDOUT_TO_PORT
operator|||
name|tcmd
operator|==
name|SHELL_STDIO_ON_PORT
condition|)
name|aidescs
index|[
literal|1
index|]
operator|=
name|owrite
expr_stmt|;
name|ipid
operator|=
name|ixsspawn
argument_list|(
name|azargs
argument_list|,
name|aidescs
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ixsspawn (/bin/sh): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
literal|"shell"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change directories.  */
end_comment

begin_function
name|boolean
name|fsysdep_chdir
parameter_list|(
name|zdir
parameter_list|)
specifier|const
name|char
modifier|*
name|zdir
decl_stmt|;
block|{
if|if
condition|(
name|zdir
operator|==
name|NULL
operator|||
operator|*
name|zdir
operator|==
literal|'\0'
condition|)
block|{
name|zdir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdir
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"HOME not defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|zdir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chdir (%s): %s"
argument_list|,
name|zdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Suspend the current process.  */
end_comment

begin_function
name|boolean
name|fsysdep_suspend
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|SIGTSTP
return|return
name|fsysdep_terminal_puts
argument_list|(
literal|"[process suspension not supported]"
argument_list|)
return|;
else|#
directive|else
return|return
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function

end_unit

