begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dirent.c    Replacements for opendir, readdir and closedir for the original    Unix filesystem only.     Copyright (C) 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Simple emulations of opendir/readdir/closedir for systems which    have the original format of Unix directories.  It's probably better    to get Doug Gwyn's public domain set of emulation functions.  */
end_comment

begin_function
name|DIR
modifier|*
name|opendir
parameter_list|(
name|zdir
parameter_list|)
specifier|const
name|char
modifier|*
name|zdir
decl_stmt|;
block|{
name|int
name|o
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|DIR
modifier|*
name|qret
decl_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zdir
argument_list|,
name|O_RDONLY
operator||
name|O_NOCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|o
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|o
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|o
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|isave
decl_stmt|;
name|isave
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|errno
operator|=
name|isave
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOTDIR
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|qret
operator|=
operator|(
name|DIR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DIR
argument_list|)
argument_list|)
expr_stmt|;
name|qret
operator|->
name|o
operator|=
name|o
expr_stmt|;
return|return
name|qret
return|;
block|}
end_function

begin_function
name|struct
name|dirent
modifier|*
name|readdir
parameter_list|(
name|q
parameter_list|)
name|DIR
modifier|*
name|q
decl_stmt|;
block|{
name|struct
name|direct
name|sdir
decl_stmt|;
name|int
name|cgot
decl_stmt|;
do|do
block|{
name|cgot
operator|=
name|read
argument_list|(
name|q
operator|->
name|o
argument_list|,
operator|&
name|sdir
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgot
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|cgot
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
do|while
condition|(
name|sdir
operator|.
name|d_ino
operator|==
literal|0
condition|)
do|;
name|strncpy
argument_list|(
name|q
operator|->
name|s
operator|.
name|d_name
argument_list|,
name|sdir
operator|.
name|d_name
argument_list|,
name|DIRSIZ
argument_list|)
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|&
name|q
operator|->
name|s
return|;
block|}
end_function

begin_function
name|int
name|closedir
parameter_list|(
name|q
parameter_list|)
name|DIR
modifier|*
name|q
decl_stmt|;
block|{
name|int
name|o
decl_stmt|;
name|o
operator|=
name|q
operator|->
name|o
expr_stmt|;
name|xfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|close
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

end_unit

