begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xqtsub.c    System dependent functions used only by uuxqt.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|xqtsub_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_OPENDIR
end_if

begin_if
if|#
directive|if
name|HAVE_DIRENT_H
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_DIRENT_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_OPENDIR */
end_comment

begin_comment
comment|/* Get a value for EX_TEMPFAIL.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYSEXITS_H
end_if

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EX_TEMPFAIL
end_ifndef

begin_define
define|#
directive|define
name|EX_TEMPFAIL
value|75
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Get the full pathname of the command to execute, given the list of    permitted commands and the allowed path.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_find_command
parameter_list|(
name|zcmd
parameter_list|,
name|pzcmds
parameter_list|,
name|pzpath
parameter_list|,
name|pferr
parameter_list|)
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzcmds
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzpath
decl_stmt|;
name|boolean
modifier|*
name|pferr
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
operator|*
name|pferr
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|pzcmds
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
name|char
modifier|*
name|zslash
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
literal|"ALL"
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|zslash
operator|=
name|strrchr
argument_list|(
operator|*
name|pz
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|!=
name|NULL
condition|)
operator|++
name|zslash
expr_stmt|;
else|else
name|zslash
operator|=
operator|*
name|pz
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zslash
argument_list|,
name|zcmd
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|pz
argument_list|,
name|zcmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If we already have an absolute path, we can get out 	     immediately.  */
if|if
condition|(
operator|*
operator|*
name|pz
operator|==
literal|'/'
condition|)
block|{
comment|/* Quick error check.  */
if|if
condition|(
name|stat
argument_list|(
operator|*
name|pz
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
operator|*
name|pz
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|zbufcpy
argument_list|(
operator|*
name|pz
argument_list|)
return|;
block|}
break|break;
block|}
block|}
comment|/* If we didn't find this command, get out.  */
if|if
condition|(
operator|*
name|pz
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* We didn't find an absolute pathname, so we must look through      the path.  */
for|for
control|(
name|pz
operator|=
name|pzpath
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
name|char
modifier|*
name|zname
decl_stmt|;
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
operator|*
name|pz
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|zname
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
name|zname
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a local filename for uuxqt.  This is special because uuxqt    only wants to expand filenames that start with ~ (it does not want    to prepend the current directory to other names) and if the ~ is    double, it is turned into a single ~.  This returns NULL to    indicate that no change was required; it has no way to return    error.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_xqt_local_file
parameter_list|(
name|qsys
parameter_list|,
name|zfile
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|zfile
operator|!=
literal|'~'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|zfile
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
block|{
name|size_t
name|clen
decl_stmt|;
name|char
modifier|*
name|zret
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|zret
operator|=
name|zbufalc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zret
argument_list|,
name|zfile
operator|+
literal|1
argument_list|,
name|clen
argument_list|)
expr_stmt|;
return|return
name|zret
return|;
block|}
return|return
name|zsysdep_local_file
argument_list|(
name|zfile
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|ALLOW_FILENAME_ARGUMENTS
end_if

begin_comment
comment|/* Check to see whether an argument specifies a file name; if it does,    make sure that the file may legally be sent and/or received.  For    Unix, we do not permit any occurrence of "/../" in the name, nor    may it start with "../".  Otherwise, if it starts with "/" we check    against the list of permitted files.  */
end_comment

begin_function
name|boolean
name|fsysdep_xqt_check_file
parameter_list|(
name|qsys
parameter_list|,
name|zfile
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|size_t
name|clen
decl_stmt|;
comment|/* Disallow exact "..", prefix "../", suffix "/..", internal "/../",      and restricted absolute paths.  */
name|clen
operator|=
name|strlen
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clen
operator|==
sizeof|sizeof
expr|".."
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|zfile
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|strncmp
argument_list|(
name|zfile
argument_list|,
literal|"../"
argument_list|,
sizeof|sizeof
expr|"../"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|clen
operator|>=
sizeof|sizeof
expr|"/.."
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|zfile
operator|+
name|clen
operator|-
operator|(
sizeof|sizeof
expr|"/.."
operator|-
literal|1
operator|)
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|strstr
argument_list|(
name|zfile
argument_list|,
literal|"/../"
argument_list|)
operator|!=
name|NULL
operator|||
operator|(
operator|*
name|zfile
operator|==
literal|'/'
operator|&&
operator|(
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|qsys
operator|->
name|uuconf_pzremote_send
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|fin_directory_list
argument_list|(
name|zfile
argument_list|,
name|qsys
operator|->
name|uuconf_pzremote_receive
argument_list|,
name|qsys
operator|->
name|uuconf_zpubdir
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to refer to file \"%s\""
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! ALLOW_FILENAME_ARGUMENTS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Invoke the command specified by an execute file.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fsysdep_execute
parameter_list|(
name|qsys
parameter_list|,
name|zuser
parameter_list|,
name|pazargs
parameter_list|,
name|zfullcmd
parameter_list|,
name|zinput
parameter_list|,
name|zoutput
parameter_list|,
name|fshell
parameter_list|,
name|iseq
parameter_list|,
name|pzerror
parameter_list|,
name|pftemp
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pazargs
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfullcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zinput
decl_stmt|;
specifier|const
name|char
modifier|*
name|zoutput
decl_stmt|;
name|boolean
name|fshell
decl_stmt|;
name|int
name|iseq
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzerror
decl_stmt|;
name|boolean
modifier|*
name|pftemp
decl_stmt|;
block|{
name|int
name|aidescs
index|[
literal|3
index|]
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|int
name|ierr
decl_stmt|;
name|char
name|abxqtdir
index|[
sizeof|sizeof
name|XQTDIR
operator|+
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zxqtdir
decl_stmt|;
name|int
name|istat
decl_stmt|;
name|char
modifier|*
name|zpath
decl_stmt|;
if|#
directive|if
name|ALLOW_SH_EXECUTION
specifier|const
name|char
modifier|*
name|azshargs
index|[
literal|4
index|]
decl_stmt|;
endif|#
directive|endif
operator|*
name|pzerror
operator|=
name|NULL
expr_stmt|;
operator|*
name|pftemp
operator|=
name|FALSE
expr_stmt|;
name|aidescs
index|[
literal|0
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|1
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|ferr
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zinput
operator|!=
name|NULL
condition|)
block|{
name|aidescs
index|[
literal|0
index|]
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zinput
argument_list|,
name|O_RDONLY
operator||
name|O_NOCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|0
index|]
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|zinput
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcntl
argument_list|(
name|aidescs
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|aidescs
index|[
literal|0
index|]
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ferr
operator|&&
name|zoutput
operator|!=
name|NULL
condition|)
block|{
name|aidescs
index|[
literal|1
index|]
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zoutput
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|1
index|]
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"creat (%s): %s"
argument_list|,
name|zoutput
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pftemp
operator|=
name|TRUE
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcntl
argument_list|(
name|aidescs
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|aidescs
index|[
literal|1
index|]
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ferr
condition|)
block|{
operator|*
name|pzerror
operator|=
name|zstemp_file
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
name|creat
argument_list|(
operator|*
name|pzerror
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|2
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
operator|*
name|pzerror
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
operator|*
name|pftemp
operator|=
name|TRUE
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|aidescs
index|[
literal|2
index|]
operator|=
name|creat
argument_list|(
operator|*
name|pzerror
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ferr
operator|&&
name|aidescs
index|[
literal|2
index|]
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"creat (%s): %s"
argument_list|,
operator|*
name|pzerror
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pftemp
operator|=
name|TRUE
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ferr
operator|&&
name|fcntl
argument_list|(
name|aidescs
index|[
literal|2
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|aidescs
index|[
literal|2
index|]
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fcntl (FD_CLOEXEC): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ferr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iseq
operator|==
literal|0
condition|)
name|zxqtdir
operator|=
name|XQTDIR
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|abxqtdir
argument_list|,
literal|"%s%04d"
argument_list|,
name|XQTDIR
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
name|zxqtdir
operator|=
name|abxqtdir
expr_stmt|;
block|}
if|if
condition|(
name|ferr
condition|)
block|{
if|if
condition|(
name|aidescs
index|[
literal|0
index|]
operator|!=
name|SPAWN_NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|1
index|]
operator|!=
name|SPAWN_NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|2
index|]
operator|!=
name|SPAWN_NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
operator|*
name|pzerror
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|ALLOW_SH_EXECUTION
if|if
condition|(
name|fshell
condition|)
block|{
name|azshargs
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
name|azshargs
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
name|azshargs
index|[
literal|2
index|]
operator|=
name|zfullcmd
expr_stmt|;
name|azshargs
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|pazargs
operator|=
name|azshargs
expr_stmt|;
block|}
else|#
directive|else
name|fshell
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qsys
operator|->
name|uuconf_pzpath
operator|==
name|NULL
condition|)
name|zpath
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|size_t
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|qsys
operator|->
name|uuconf_pzpath
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
name|c
operator|+=
name|strlen
argument_list|(
operator|*
name|pz
argument_list|)
operator|+
literal|1
expr_stmt|;
name|zpath
operator|=
name|zbufalc
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|zpath
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|pz
operator|=
name|qsys
operator|->
name|uuconf_pzpath
init|;
operator|*
name|pz
operator|!=
name|NULL
condition|;
name|pz
operator|++
control|)
block|{
name|strcat
argument_list|(
name|zpath
argument_list|,
operator|*
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|pz
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|zpath
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pass zchdir as zxqtdir, fnosigs as TRUE, fshell as TRUE if we      aren't already using the shell.  */
name|ipid
operator|=
name|ixsspawn
argument_list|(
name|pazargs
argument_list|,
name|aidescs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|zxqtdir
argument_list|,
name|TRUE
argument_list|,
operator|!
name|fshell
argument_list|,
name|zpath
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|zuser
argument_list|)
expr_stmt|;
name|ierr
operator|=
name|errno
expr_stmt|;
name|ubuffree
argument_list|(
name|zpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|0
index|]
operator|!=
name|SPAWN_NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|1
index|]
operator|!=
name|SPAWN_NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aidescs
index|[
literal|2
index|]
operator|!=
name|SPAWN_NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|aidescs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ixsspawn: %s"
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pftemp
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|istat
operator|=
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
literal|"Execution"
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pftemp
operator|=
name|TRUE
expr_stmt|;
return|return
name|istat
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lock a uuxqt process.  */
end_comment

begin_function
name|int
name|ixsysdep_lock_uuxqt
parameter_list|(
name|zcmd
parameter_list|,
name|cmaxuuxqts
parameter_list|)
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
name|int
name|cmaxuuxqts
decl_stmt|;
block|{
name|char
name|ab
index|[
sizeof|sizeof
expr|"LCK.XQT.9999"]
expr_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cmaxuuxqts
operator|<=
literal|0
operator|||
name|cmaxuuxqts
operator|>=
literal|10000
condition|)
name|cmaxuuxqts
operator|=
literal|9999
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmaxuuxqts
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"LCK.XQT.%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsdo_lock
argument_list|(
name|ab
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|cmaxuuxqts
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|zcmd
operator|!=
name|NULL
condition|)
block|{
name|char
name|abcmd
index|[
sizeof|sizeof
expr|"LXQ.123456789"]
expr_stmt|;
name|sprintf
argument_list|(
name|abcmd
argument_list|,
literal|"LXQ.%.9s"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|abcmd
index|[
name|strcspn
argument_list|(
name|abcmd
argument_list|,
literal|" \t/"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fsdo_lock
argument_list|(
name|abcmd
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
name|ab
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Unlock a uuxqt process.  */
end_comment

begin_function
name|boolean
name|fsysdep_unlock_uuxqt
parameter_list|(
name|iseq
parameter_list|,
name|zcmd
parameter_list|,
name|cmaxuuxqts
parameter_list|)
name|int
name|iseq
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
name|int
name|cmaxuuxqts
decl_stmt|;
block|{
name|char
name|ab
index|[
sizeof|sizeof
expr|"LCK.XQT.9999"]
expr_stmt|;
name|boolean
name|fret
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"LCK.XQT.%d"
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsdo_unlock
argument_list|(
name|ab
argument_list|,
name|TRUE
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zcmd
operator|!=
name|NULL
condition|)
block|{
name|char
name|abcmd
index|[
sizeof|sizeof
expr|"LXQ.123456789"]
expr_stmt|;
name|sprintf
argument_list|(
name|abcmd
argument_list|,
literal|"LXQ.%.9s"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|abcmd
index|[
name|strcspn
argument_list|(
name|abcmd
argument_list|,
literal|" \t/"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fsdo_unlock
argument_list|(
name|abcmd
argument_list|,
name|TRUE
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* See whether a particular uuxqt command is locked (this depends on    the implementation of fsdo_lock).  */
end_comment

begin_function
name|boolean
name|fsysdep_uuxqt_locked
parameter_list|(
name|zcmd
parameter_list|)
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
block|{
name|char
name|ab
index|[
sizeof|sizeof
expr|"LXQ.123456789"]
expr_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"LXQ.%.9s"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
return|return
name|stat
argument_list|(
name|ab
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lock a particular execute file.  */
end_comment

begin_function
name|boolean
name|fsysdep_lock_uuxqt_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|z
operator|=
name|strrchr
argument_list|(
name|zcopy
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
operator|*
name|zcopy
operator|=
literal|'L'
expr_stmt|;
else|else
operator|*
operator|(
name|z
operator|+
literal|1
operator|)
operator|=
literal|'L'
expr_stmt|;
name|fret
operator|=
name|fsdo_lock
argument_list|(
name|zcopy
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Unlock a particular execute file.  */
end_comment

begin_function
name|boolean
name|fsysdep_unlock_uuxqt_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zcopy
operator|=
name|zbufcpy
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|z
operator|=
name|strrchr
argument_list|(
name|zcopy
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
operator|*
name|zcopy
operator|=
literal|'L'
expr_stmt|;
else|else
operator|*
operator|(
name|z
operator|+
literal|1
operator|)
operator|=
literal|'L'
expr_stmt|;
name|fret
operator|=
name|fsdo_unlock
argument_list|(
name|zcopy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Lock the execute directory.  Since we use a different directory    depending on which LCK.XQT.dddd file we got, there is actually no    need to create a lock file.  We do make sure that the directory    exists, though.  */
end_comment

begin_function
name|boolean
name|fsysdep_lock_uuxqt_dir
parameter_list|(
name|iseq
parameter_list|)
name|int
name|iseq
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zxqtdir
decl_stmt|;
name|char
name|abxqtdir
index|[
sizeof|sizeof
name|XQTDIR
operator|+
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|iseq
operator|==
literal|0
condition|)
name|zxqtdir
operator|=
name|XQTDIR
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|abxqtdir
argument_list|,
literal|"%s%04d"
argument_list|,
name|XQTDIR
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
name|zxqtdir
operator|=
name|abxqtdir
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|zxqtdir
argument_list|,
name|S_IRWXU
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
operator|&&
name|errno
operator|!=
name|EISDIR
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"mkdir (%s): %s"
argument_list|,
name|zxqtdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Unlock the execute directory and clear it out.  The lock is    actually the LCK.XQT.dddd file, so we don't unlock it, but we do    remove all the files.  */
end_comment

begin_function
name|boolean
name|fsysdep_unlock_uuxqt_dir
parameter_list|(
name|iseq
parameter_list|)
name|int
name|iseq
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zxqtdir
decl_stmt|;
name|char
name|abxqtdir
index|[
sizeof|sizeof
name|XQTDIR
operator|+
literal|4
index|]
decl_stmt|;
name|DIR
modifier|*
name|qdir
decl_stmt|;
if|if
condition|(
name|iseq
operator|==
literal|0
condition|)
name|zxqtdir
operator|=
name|XQTDIR
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|abxqtdir
argument_list|,
literal|"%s%04d"
argument_list|,
name|XQTDIR
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
name|zxqtdir
operator|=
name|abxqtdir
expr_stmt|;
block|}
name|qdir
operator|=
name|opendir
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zxqtdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdir
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|qentry
decl_stmt|;
while|while
condition|(
operator|(
name|qentry
operator|=
name|readdir
argument_list|(
name|qdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|qentry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|qentry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|z
operator|=
name|zsysdep_in_dir
argument_list|(
name|zxqtdir
argument_list|,
name|qentry
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|z
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|ierr
decl_stmt|;
name|ierr
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_directory
argument_list|(
name|z
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|z
argument_list|,
name|strerror
argument_list|(
name|ierr
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fsysdep_rmdir
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
name|ubuffree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|qdir
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move files into the execution directory.  */
end_comment

begin_function
name|boolean
name|fsysdep_move_uuxqt_files
parameter_list|(
name|cfiles
parameter_list|,
name|pzfrom
parameter_list|,
name|pzto
parameter_list|,
name|fto
parameter_list|,
name|iseq
parameter_list|,
name|pzinput
parameter_list|)
name|int
name|cfiles
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|pzfrom
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|pzto
decl_stmt|;
name|boolean
name|fto
decl_stmt|;
name|int
name|iseq
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzinput
decl_stmt|;
block|{
name|char
modifier|*
name|zinput
decl_stmt|;
specifier|const
name|char
modifier|*
name|zxqtdir
decl_stmt|;
name|char
name|abxqtdir
index|[
sizeof|sizeof
name|XQTDIR
operator|+
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pzinput
operator|==
name|NULL
condition|)
name|zinput
operator|=
name|NULL
expr_stmt|;
else|else
name|zinput
operator|=
operator|*
name|pzinput
expr_stmt|;
if|if
condition|(
name|iseq
operator|==
literal|0
condition|)
name|zxqtdir
operator|=
name|XQTDIR
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|abxqtdir
argument_list|,
literal|"%s%04d"
argument_list|,
name|XQTDIR
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
name|zxqtdir
operator|=
name|abxqtdir
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfiles
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|,
modifier|*
name|zto
decl_stmt|;
name|char
modifier|*
name|zfree
decl_stmt|;
if|if
condition|(
name|pzto
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zxqtdir
argument_list|,
name|pzto
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zfrom
operator|=
name|pzfrom
index|[
name|i
index|]
expr_stmt|;
name|zto
operator|=
name|zfree
expr_stmt|;
if|if
condition|(
name|zinput
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zinput
argument_list|,
name|zfrom
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pzinput
operator|=
name|zbufcpy
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|zinput
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fto
condition|)
block|{
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
name|ztemp
operator|=
name|zfrom
expr_stmt|;
name|zfrom
operator|=
name|zto
expr_stmt|;
name|zto
operator|=
name|ztemp
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|zfrom
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rename
argument_list|(
name|zfrom
argument_list|,
name|zto
argument_list|)
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|HAVE_RENAME
comment|/* On some systems the system call rename seems to fail for 	     arbitrary reasons.  To get around this, we always try to 	     copy the file by hand if the rename failed.  */
name|errno
operator|=
name|EXDEV
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errno
operator|!=
name|EXDEV
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"rename (%s, %s): %s"
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fcopy_file
argument_list|(
name|zfrom
argument_list|,
name|zto
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|remove
argument_list|(
name|zfrom
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|zfrom
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fto
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|zto
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|cfiles
condition|)
block|{
if|if
condition|(
name|fto
condition|)
operator|(
name|void
operator|)
name|fsysdep_move_uuxqt_files
argument_list|(
name|i
argument_list|,
name|pzfrom
argument_list|,
name|pzto
argument_list|,
name|FALSE
argument_list|,
name|iseq
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

