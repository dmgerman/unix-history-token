begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filnam.c    Get names to use for UUCP files.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We need a definition for SEEK_SET.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We use POSIX style fcntl locks if they are available, unless    O_CREAT is not defined.  We could use them in the latter case, but    the code would have to become more complex to avoid races    concerning the use of creat.  It is very unlikely that there is any    system which does have POSIX style locking but does not have    O_CREAT.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_BROKEN_SETLKW
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|F_SETLKW
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|O_CREAT
end_ifdef

begin_define
define|#
directive|define
name|USE_POSIX_LOCKS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_POSIX_LOCKS
end_ifndef

begin_define
define|#
directive|define
name|USE_POSIX_LOCKS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External functions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lseek
end_ifndef

begin_function_decl
specifier|extern
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_define
define|#
directive|define
name|ZCHARS
define|\
value|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fscmd_seq
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zsystem
operator|,
name|char
operator|*
name|zseq
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zsfile_name
name|P
argument_list|(
operator|(
name|int
name|btype
operator|,
specifier|const
name|char
operator|*
name|zsystem
operator|,
specifier|const
name|char
operator|*
name|zlocalname
operator|,
name|int
name|bgrade
operator|,
name|boolean
name|fxqt
operator|,
name|char
operator|*
name|ztname
operator|,
name|char
operator|*
name|zdname
operator|,
name|char
operator|*
name|zxname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Get a new command sequence number (this is not a sequence number to    be used for communicating with another system, but a sequence    number to be used when generating the name of a command file).    The sequence number is placed into zseq, which should be five    characters long.  */
end_comment

begin_function
specifier|static
name|boolean
name|fscmd_seq
parameter_list|(
name|zsystem
parameter_list|,
name|zseq
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|char
modifier|*
name|zseq
decl_stmt|;
block|{
name|int
name|cdelay
decl_stmt|;
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|int
name|o
decl_stmt|;
name|boolean
name|flockfile
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|cdelay
operator|=
literal|5
expr_stmt|;
if|#
directive|if
operator|!
name|USE_POSIX_LOCKS
block|{
name|boolean
name|ferr
decl_stmt|;
comment|/* Lock the sequence file.  */
while|while
condition|(
operator|!
name|fsdo_lock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|,
operator|&
name|ferr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferr
operator|||
name|FGOT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
name|sleep
argument_list|(
name|cdelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdelay
operator|<
literal|60
condition|)
operator|++
name|cdelay
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|zfree
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_V2
operator|||
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
name|zfile
operator|=
literal|"SEQF"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
literal|".Sequence"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zfree
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
if|if
condition|(
operator|!
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|)
name|zfile
operator|=
literal|"sys/DEFAULT/.SEQF"
expr_stmt|;
else|else
block|{
name|zfree
operator|=
name|zsappend3
argument_list|(
literal|"sys"
argument_list|,
name|zsystem
argument_list|,
literal|".SEQF"
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zfree
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX */
if|#
directive|if
name|SPOOLDIR_TAYLOR
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zsystem
argument_list|,
literal|"SEQF"
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zfree
expr_stmt|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
ifdef|#
directive|ifdef
name|O_CREAT
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_NOCTTY
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
else|#
directive|else
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|o
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zfile
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|USE_POSIX_LOCKS
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|O_CREAT
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_NOCTTY
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
else|#
directive|else
name|o
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|IPRIVATE_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|USE_POSIX_LOCKS
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
operator|!
name|USE_POSIX_LOCKS
name|flockfile
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|flock
name|slock
decl_stmt|;
name|flockfile
operator|=
name|FALSE
expr_stmt|;
name|slock
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|slock
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|slock
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
name|slock
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fcntl
argument_list|(
name|o
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|slock
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|boolean
name|fagain
decl_stmt|;
comment|/* Some systems define F_SETLKW, but it does not work.  We try            to catch those systems at runtime, and revert to using a            lock file.  */
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|boolean
name|ferr
decl_stmt|;
comment|/* Lock the sequence file.  */
while|while
condition|(
operator|!
name|fsdo_lock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|,
operator|&
name|ferr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferr
operator|||
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sleep
argument_list|(
name|cdelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdelay
operator|<
literal|60
condition|)
operator|++
name|cdelay
expr_stmt|;
block|}
name|flockfile
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|fagain
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
name|fagain
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ENOLCK
if|if
condition|(
name|errno
operator|==
name|ENOLCK
condition|)
name|fagain
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOSPC
if|if
condition|(
name|errno
operator|==
name|ENOSPC
condition|)
name|fagain
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fagain
condition|)
block|{
name|sleep
argument_list|(
name|cdelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdelay
operator|<
literal|60
condition|)
operator|++
name|cdelay
expr_stmt|;
continue|continue;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Locking %s: %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|read
argument_list|(
name|o
argument_list|,
name|zseq
argument_list|,
name|CSEQLEN
argument_list|)
operator|!=
name|CSEQLEN
condition|)
name|strcpy
argument_list|(
name|zseq
argument_list|,
literal|"0000"
argument_list|)
expr_stmt|;
name|zseq
index|[
name|CSEQLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We must add one to the sequence number and return the new value.      On Ultrix, arbitrary characters are allowed in the sequence      number.  On other systems, the sequence number apparently must be      in hex.  */
if|#
directive|if
name|SPOOLDIR_V2
operator|||
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
operator|||
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|i
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|zseq
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0xffff
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* The sprintf argument has CSEQLEN built into it.  */
name|sprintf
argument_list|(
name|zseq
argument_list|,
literal|"%04x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
operator|||
name|SPOOLDIR_TAYLOR
for|for
control|(
name|i
operator|=
name|CSEQLEN
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|char
modifier|*
name|zdig
decl_stmt|;
name|zdig
operator|=
name|strchr
argument_list|(
name|ZCHARS
argument_list|,
name|zseq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdig
operator|==
name|NULL
operator|||
name|zdig
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|zdig
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|zseq
index|[
name|i
index|]
operator|=
literal|'0'
expr_stmt|;
else|else
block|{
name|zseq
index|[
name|i
index|]
operator|=
name|zdig
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX || SPOOLDIR_TAYLOR */
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|o
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|o
argument_list|,
name|zseq
argument_list|,
name|CSEQLEN
argument_list|)
operator|!=
name|CSEQLEN
operator|||
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"lseek or write or close %s: %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|flockfile
condition|)
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the name of a command or data file for a remote system.  The    btype argument should be C for a command file or D for a data file.    If the grade of a data file is X, it is assumed that this is going    to become an execute file on some other system.  The zsystem    argument is the system that the file will be transferred to.  The    ztname argument will be set to a file name that could be passed to    zsysdep_spool_file_name.  The zdname argument, if not NULL, will be    set to a data file name appropriate for the remote system.  The    zxname argument, if not NULL, will be set to the name of an execute    file on the remote system.  None of the names will be more than 14    characters long.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zsfile_name
parameter_list|(
name|btype
parameter_list|,
name|zsystem
parameter_list|,
name|zlocalname
parameter_list|,
name|bgrade
parameter_list|,
name|fxqt
parameter_list|,
name|ztname
parameter_list|,
name|zdname
parameter_list|,
name|zxname
parameter_list|)
name|int
name|btype
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fxqt
decl_stmt|;
name|char
modifier|*
name|ztname
decl_stmt|;
name|char
modifier|*
name|zdname
decl_stmt|;
name|char
modifier|*
name|zxname
decl_stmt|;
block|{
name|char
name|abseq
index|[
name|CSEQLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|absimple
index|[
literal|11
operator|+
name|CSEQLEN
index|]
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
if|if
condition|(
name|zlocalname
operator|==
name|NULL
condition|)
name|zlocalname
operator|=
name|zSlocalname
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|fscmd_seq
argument_list|(
name|zsystem
argument_list|,
name|abseq
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|btype
operator|==
literal|'C'
condition|)
block|{
if|#
directive|if
operator|!
name|SPOOLDIR_TAYLOR
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"C.%.7s%c%s"
argument_list|,
name|zsystem
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"C.%c%s"
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|btype
operator|==
literal|'D'
condition|)
block|{
comment|/* This name doesn't really matter that much; it's just the 	     name we use on the local system.  The name we use on the 	     remote system, which we return in zdname, should contain 	     our system name so that remote UUCP's running SPOOLDIR_V2 	     and the like can distinguish while files come from which 	     systems.  */
if|#
directive|if
name|SPOOLDIR_SVR4
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.%.7s%c%s"
argument_list|,
name|zsystem
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! SPOOLDIR_SVR4 */
if|#
directive|if
operator|!
name|SPOOLDIR_TAYLOR
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.%.7s%c%s"
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SPOOLDIR_TAYLOR */
if|if
condition|(
name|fxqt
condition|)
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.X%s"
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.%s"
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
endif|#
directive|endif
comment|/* ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4 */
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
else|else
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"zsfile_name: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zname
operator|=
name|zsfind_file
argument_list|(
name|absimple
argument_list|,
name|zsystem
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|zname
argument_list|)
condition|)
break|break;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztname
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|ztname
argument_list|,
name|absimple
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdname
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|zdname
argument_list|,
literal|"D.%.7s%c%s"
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxname
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|zxname
argument_list|,
literal|"X.%.7s%c%s"
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
return|return
name|zname
return|;
block|}
end_function

begin_comment
comment|/* Return a name to use for a data file to be copied to another    system.  The name returned will be for a real file.  The zlocalname    argument is the local name as seen by the remote system, the bgrade    argument is the file grade, and the fxqt argument is TRUE if this    file will become an execution file.  The ztname argument, if not    NULL, will be set to a name that could be passed to    zsysdep_spool_file_name to get back the return value of this    function.  The zdname argument, if not NULL, will be set to a name    that the file could be given on another system.  The zxname    argument, if not NULL, will be set to a name for an execute file on    another system.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_data_file_name
parameter_list|(
name|qsys
parameter_list|,
name|zlocalname
parameter_list|,
name|bgrade
parameter_list|,
name|fxqt
parameter_list|,
name|ztname
parameter_list|,
name|zdname
parameter_list|,
name|zxname
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fxqt
decl_stmt|;
name|char
modifier|*
name|ztname
decl_stmt|;
name|char
modifier|*
name|zdname
decl_stmt|;
name|char
modifier|*
name|zxname
decl_stmt|;
block|{
return|return
name|zsfile_name
argument_list|(
literal|'D'
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|fxqt
argument_list|,
name|ztname
argument_list|,
name|zdname
argument_list|,
name|zxname
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SPOOLDIR_TAYLOR
end_if

begin_comment
comment|/* Write out a number in base 62 into a given number of characters,    right justified with zero fill.  This is used by zscmd_file if    SPOOLDIR_TAYLOR.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|usput62
name|P
argument_list|(
operator|(
name|long
name|i
operator|,
name|char
operator|*
operator|,
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usput62
parameter_list|(
name|i
parameter_list|,
name|z
parameter_list|,
name|c
parameter_list|)
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
operator|--
name|c
init|;
name|c
operator|>=
literal|0
condition|;
operator|--
name|c
control|)
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
name|i
operator|%
literal|62
expr_stmt|;
name|i
operator|/=
literal|62
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|26
condition|)
name|z
index|[
name|c
index|]
operator|=
literal|'A'
operator|+
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|52
condition|)
name|z
index|[
name|c
index|]
operator|=
literal|'a'
operator|+
name|d
operator|-
literal|26
expr_stmt|;
else|else
name|z
index|[
name|c
index|]
operator|=
literal|'0'
operator|+
name|d
operator|-
literal|52
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SPOOLDIR_TAYLOR */
end_comment

begin_comment
comment|/* Get a command file name.  */
end_comment

begin_function
name|char
modifier|*
name|zscmd_file
parameter_list|(
name|qsys
parameter_list|,
name|bgrade
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|SPOOLDIR_TAYLOR
return|return
name|zsfile_name
argument_list|(
literal|'C'
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|bgrade
argument_list|,
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
else|#
directive|else
name|char
modifier|*
name|zname
decl_stmt|;
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
comment|/* This file name is never seen by the remote system, so we don't      actually need to get a sequence number for it.  We just need to      get a file name which is unique for this system.  We don't try      this optimization for other spool directory formats, mainly due      to compatibility concerns.  It would be possible for HDB and SVR4      spool directory formats.       We get a unique name by combining the process ID and the current      time.  The file name must start with C.g, where g is the grade.      Note that although it is likely that this name will be unique, it      is not guaranteed, so the caller must be careful.  */
name|isecs
operator|=
name|ixsysdep_time
argument_list|(
operator|&
name|imicros
argument_list|)
expr_stmt|;
name|ipid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* We are going to represent the file name as a series of numbers in      base 62 (using the alphanumeric characters).  The maximum file      name length is 14 characters, so we may use 11.  We use 3 for the      seconds within the day, 3 for the microseconds, and 5 for the      process ID.  */
comment|/* Cut the seconds down to a number within a day (maximum value      86399< 62 ** 3 == 238328).  */
name|isecs
operator|%=
operator|(
name|long
operator|)
literal|24
operator|*
operator|(
name|long
operator|)
literal|60
operator|*
operator|(
name|long
operator|)
literal|60
expr_stmt|;
comment|/* Divide the microseconds (max 999999) by 5 to make sure they are      less than 62 ** 3.  */
name|imicros
operator|%=
literal|1000000
expr_stmt|;
name|imicros
operator|/=
literal|5
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
name|ab
index|[
literal|15
index|]
decl_stmt|;
name|ab
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
name|ab
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|ab
index|[
literal|2
index|]
operator|=
name|bgrade
expr_stmt|;
name|usput62
argument_list|(
name|isecs
argument_list|,
name|ab
operator|+
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|usput62
argument_list|(
name|imicros
argument_list|,
name|ab
operator|+
literal|6
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|usput62
argument_list|(
operator|(
name|long
operator|)
name|ipid
argument_list|,
name|ab
operator|+
literal|9
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ab
index|[
literal|14
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zname
operator|=
name|zsfind_file
argument_list|(
name|ab
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|zname
argument_list|)
condition|)
break|break;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
comment|/* We hit a duplicate.  Move backward in time until we find an          available name.  Note that there is still a theoretical race          condition, since 5 base 62 digits might not be enough for the          process ID, and some other process might be running these          checks at the same time as we are.  The caller must deal with          this.  */
if|if
condition|(
name|imicros
operator|==
literal|0
condition|)
block|{
name|imicros
operator|=
operator|(
name|long
operator|)
literal|62
operator|*
operator|(
name|long
operator|)
literal|62
operator|*
operator|(
name|long
operator|)
literal|62
expr_stmt|;
if|if
condition|(
name|isecs
operator|==
literal|0
condition|)
name|isecs
operator|=
operator|(
name|long
operator|)
literal|62
operator|*
operator|(
name|long
operator|)
literal|62
operator|*
operator|(
name|long
operator|)
literal|62
expr_stmt|;
operator|--
name|isecs
expr_stmt|;
block|}
operator|--
name|imicros
expr_stmt|;
block|}
return|return
name|zname
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a name for an execute file to be created locally.  This is    used by uux to execute a command locally with remote files.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_xqt_file_name
parameter_list|()
block|{
name|char
name|abseq
index|[
name|CSEQLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|absx
index|[
literal|11
operator|+
name|CSEQLEN
index|]
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|fscmd_seq
argument_list|(
name|zSlocalname
argument_list|,
name|abseq
argument_list|)
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|absx
argument_list|,
literal|"X.%.7sX%s"
argument_list|,
name|zSlocalname
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
name|zname
operator|=
name|zsfind_file
argument_list|(
name|absx
argument_list|,
name|zSlocalname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|zname
argument_list|)
condition|)
break|break;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
return|return
name|zname
return|;
block|}
end_function

end_unit

