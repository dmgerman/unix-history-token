begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filnam.c    Get names to use for UUCP files.     Copyright (C) 1991, 1992, 1993 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, Building 200, 1 Kendall Square, Cambridge, MA 02139.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"uuconf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We need a definition for SEEK_SET.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External functions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lseek
end_ifndef

begin_function_decl
specifier|extern
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_define
define|#
directive|define
name|ZCHARS
define|\
value|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fscmd_seq
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zsystem
operator|,
name|char
operator|*
name|zseq
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zsfile_name
name|P
argument_list|(
operator|(
name|int
name|btype
operator|,
specifier|const
name|char
operator|*
name|zsystem
operator|,
specifier|const
name|char
operator|*
name|zlocalname
operator|,
name|int
name|bgrade
operator|,
name|boolean
name|fxqt
operator|,
name|char
operator|*
name|ztname
operator|,
name|char
operator|*
name|zdname
operator|,
name|char
operator|*
name|zxname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Get a new command sequence number (this is not a sequence number to    be used for communicating with another system, but a sequence    number to be used when generating the name of a command file).    The sequence number is placed into zseq, which should be five    characters long.  */
end_comment

begin_function
specifier|static
name|boolean
name|fscmd_seq
parameter_list|(
name|zsystem
parameter_list|,
name|zseq
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|char
modifier|*
name|zseq
decl_stmt|;
block|{
name|boolean
name|ferr
decl_stmt|;
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|int
name|o
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Lock the sequence file.  This may not be correct for all systems,      but it only matters if the system UUCP and this UUCP are running      at the same time.  */
while|while
condition|(
operator|!
name|fsdo_lock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|,
operator|&
name|ferr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferr
operator|||
name|FGOT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|zfree
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_V2
operator|||
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
name|zfile
operator|=
literal|"SEQF"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
literal|".Sequence"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zfree
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
if|if
condition|(
operator|!
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|)
name|zfile
operator|=
literal|"sys/DEFAULT/.SEQF"
expr_stmt|;
else|else
block|{
name|zfree
operator|=
name|zsappend3
argument_list|(
literal|"sys"
argument_list|,
name|zsystem
argument_list|,
literal|".SEQF"
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zfree
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX */
if|#
directive|if
name|SPOOLDIR_TAYLOR
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zsystem
argument_list|,
literal|"SEQF"
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zfree
expr_stmt|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
ifdef|#
directive|ifdef
name|O_CREAT
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_NOCTTY
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
else|#
directive|else
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|o
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zfile
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|O_CREAT
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_NOCTTY
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
else|#
directive|else
name|o
operator|=
name|creat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"open (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|read
argument_list|(
name|o
argument_list|,
name|zseq
argument_list|,
name|CSEQLEN
argument_list|)
operator|!=
name|CSEQLEN
condition|)
name|strcpy
argument_list|(
name|zseq
argument_list|,
literal|"0000"
argument_list|)
expr_stmt|;
name|zseq
index|[
name|CSEQLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We must add one to the sequence number and return the new value.      On Ultrix, arbitrary characters are allowed in the sequence      number.  On other systems, the sequence number apparently must be      in hex.  */
if|#
directive|if
name|SPOOLDIR_V2
operator|||
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
operator|||
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|i
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|zseq
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0xffff
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* The sprintf argument has CSEQLEN built into it.  */
name|sprintf
argument_list|(
name|zseq
argument_list|,
literal|"%04x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
operator|||
name|SPOOLDIR_TAYLOR
for|for
control|(
name|i
operator|=
name|CSEQLEN
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|char
modifier|*
name|zdig
decl_stmt|;
name|zdig
operator|=
name|strchr
argument_list|(
name|ZCHARS
argument_list|,
name|zseq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdig
operator|==
name|NULL
operator|||
name|zdig
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|zdig
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|zseq
index|[
name|i
index|]
operator|=
literal|'0'
expr_stmt|;
else|else
block|{
name|zseq
index|[
name|i
index|]
operator|=
name|zdig
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX || SPOOLDIR_TAYLOR */
if|if
condition|(
name|lseek
argument_list|(
name|o
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|o
argument_list|,
name|zseq
argument_list|,
name|CSEQLEN
argument_list|)
operator|!=
name|CSEQLEN
operator|||
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"lseek or write or close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|fsdo_unlock
argument_list|(
literal|"LCK..SEQ"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the name of a command or data file for a remote system.  The    btype argument should be C for a command file or D for a data file.    If the grade of a data file is X, it is assumed that this is going    to become an execute file on some other system.  The zsystem    argument is the system that the file will be transferred to.  The    ztname argument will be set to a file name that could be passed to    zsysdep_spool_file_name.  The zdname argument, if not NULL, will be    set to a data file name appropriate for the remote system.  The    zxname argument, if not NULL, will be set to the name of an execute    file on the remote system.  None of the names will be more than 14    characters long.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|zsfile_name
parameter_list|(
name|btype
parameter_list|,
name|zsystem
parameter_list|,
name|zlocalname
parameter_list|,
name|bgrade
parameter_list|,
name|fxqt
parameter_list|,
name|ztname
parameter_list|,
name|zdname
parameter_list|,
name|zxname
parameter_list|)
name|int
name|btype
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fxqt
decl_stmt|;
name|char
modifier|*
name|ztname
decl_stmt|;
name|char
modifier|*
name|zdname
decl_stmt|;
name|char
modifier|*
name|zxname
decl_stmt|;
block|{
name|char
name|abseq
index|[
name|CSEQLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|absimple
index|[
literal|11
operator|+
name|CSEQLEN
index|]
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
if|if
condition|(
name|zlocalname
operator|==
name|NULL
condition|)
name|zlocalname
operator|=
name|zSlocalname
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|fscmd_seq
argument_list|(
name|zsystem
argument_list|,
name|abseq
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|btype
operator|==
literal|'C'
condition|)
block|{
if|#
directive|if
operator|!
name|SPOOLDIR_TAYLOR
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"C.%.7s%c%s"
argument_list|,
name|zsystem
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"C.%c%s"
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|btype
operator|==
literal|'D'
condition|)
block|{
comment|/* This name doesn't really matter that much; it's just the 	     name we use on the local system.  The name we use on the 	     remote system, which we return in zdname, should contain 	     our system name so that remote UUCP's running SPOOLDIR_V2 	     and the like can distinguish while files come from which 	     systems.  */
if|#
directive|if
name|SPOOLDIR_HDB
operator|||
name|SPOOLDIR_SVR4
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.%.7s%c%s"
argument_list|,
name|zsystem
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4 */
if|#
directive|if
operator|!
name|SPOOLDIR_TAYLOR
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.%.7s%c%s"
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SPOOLDIR_TAYLOR */
if|if
condition|(
name|fxqt
condition|)
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.X%s"
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|absimple
argument_list|,
literal|"D.%s"
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
endif|#
directive|endif
comment|/* ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4 */
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
else|else
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"zsfile_name: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zname
operator|=
name|zsfind_file
argument_list|(
name|absimple
argument_list|,
name|zsystem
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|zname
argument_list|)
condition|)
break|break;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztname
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|ztname
argument_list|,
name|absimple
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdname
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|zdname
argument_list|,
literal|"D.%.7s%c%s"
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxname
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|zxname
argument_list|,
literal|"X.%.7s%c%s"
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
return|return
name|zname
return|;
block|}
end_function

begin_comment
comment|/* Return a name to use for a data file to be copied to another    system.  The name returned will be for a real file.  The zlocalname    argument is the local name as seen by the remote system, the bgrade    argument is the file grade, and the fxqt argument is TRUE if this    file will become an execution file.  The ztname argument, if not    NULL, will be set to a name that could be passed to    zsysdep_spool_file_name to get back the return value of this    function.  The zdname argument, if not NULL, will be set to a name    that the file could be given on another system.  The zxname    argument, if not NULL, will be set to a name for an execute file on    another system.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_data_file_name
parameter_list|(
name|qsys
parameter_list|,
name|zlocalname
parameter_list|,
name|bgrade
parameter_list|,
name|fxqt
parameter_list|,
name|ztname
parameter_list|,
name|zdname
parameter_list|,
name|zxname
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocalname
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fxqt
decl_stmt|;
name|char
modifier|*
name|ztname
decl_stmt|;
name|char
modifier|*
name|zdname
decl_stmt|;
name|char
modifier|*
name|zxname
decl_stmt|;
block|{
return|return
name|zsfile_name
argument_list|(
literal|'D'
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
name|zlocalname
argument_list|,
name|bgrade
argument_list|,
name|fxqt
argument_list|,
name|ztname
argument_list|,
name|zdname
argument_list|,
name|zxname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a command file name.  */
end_comment

begin_function
name|char
modifier|*
name|zscmd_file
parameter_list|(
name|qsys
parameter_list|,
name|bgrade
parameter_list|)
specifier|const
name|struct
name|uuconf_system
modifier|*
name|qsys
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
block|{
return|return
name|zsfile_name
argument_list|(
literal|'C'
argument_list|,
name|qsys
operator|->
name|uuconf_zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|bgrade
argument_list|,
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a name for an execute file to be created locally.  This is    used by uux to execute a command locally with remote files.  */
end_comment

begin_function
name|char
modifier|*
name|zsysdep_xqt_file_name
parameter_list|()
block|{
name|char
name|abseq
index|[
name|CSEQLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|absx
index|[
literal|11
operator|+
name|CSEQLEN
index|]
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|fscmd_seq
argument_list|(
name|zSlocalname
argument_list|,
name|abseq
argument_list|)
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|absx
argument_list|,
literal|"X.%.7sX%s"
argument_list|,
name|zSlocalname
argument_list|,
name|abseq
argument_list|)
expr_stmt|;
name|zname
operator|=
name|zsfind_file
argument_list|(
name|absx
argument_list|,
name|zSlocalname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|zname
argument_list|)
condition|)
break|break;
name|ubuffree
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
return|return
name|zname
return|;
block|}
end_function

end_unit

