begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lock.c    Lock and unlock a file name.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o Infinity Development Systems, P.O. Box 520, Waltham, MA 02254.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|lock_rcsid
index|[]
init|=
literal|"$Id: lock.c,v 1.1 1993/08/04 19:32:33 jtc Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Lock something.  If the fspooldir argument is TRUE, the argument is    a file name relative to the spool directory; otherwise the argument    is a simple file name which should be created in the system lock    directory (under HDB this is /etc/locks).  */
end_comment

begin_function
name|boolean
name|fsdo_lock
parameter_list|(
name|zlock
parameter_list|,
name|fspooldir
parameter_list|,
name|pferr
parameter_list|)
specifier|const
name|char
modifier|*
name|zlock
decl_stmt|;
name|boolean
name|fspooldir
decl_stmt|;
name|boolean
modifier|*
name|pferr
decl_stmt|;
block|{
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpath
decl_stmt|,
modifier|*
name|zslash
decl_stmt|;
name|size_t
name|cslash
decl_stmt|;
name|pid_t
name|ime
decl_stmt|;
name|char
modifier|*
name|ztempfile
decl_stmt|;
name|char
name|abtempfile
index|[
sizeof|sizeof
expr|"TMP1234567890"]
expr_stmt|;
name|int
name|o
decl_stmt|;
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|int
name|i
decl_stmt|;
else|#
directive|else
name|char
name|ab
index|[
literal|12
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|cwrote
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fspooldir
condition|)
block|{
name|zfree
operator|=
name|NULL
expr_stmt|;
name|zpath
operator|=
name|zlock
expr_stmt|;
block|}
else|else
block|{
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zSlockdir
argument_list|,
name|zlock
argument_list|)
expr_stmt|;
name|zpath
operator|=
name|zfree
expr_stmt|;
block|}
name|ime
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* We do the actual lock by creating a file and then linking it to      the final file name we want.  This avoids race conditions due to      one process checking the file before we have finished writing it,      and also works even if we are somehow running as root.       First, create the file in the right directory (we must create the      file in the same directory since otherwise we might attempt a      cross-device link).  */
name|zslash
operator|=
name|strrchr
argument_list|(
name|zpath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
condition|)
name|cslash
operator|=
literal|0
expr_stmt|;
else|else
name|cslash
operator|=
name|zslash
operator|-
name|zpath
operator|+
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|abtempfile
argument_list|,
literal|"TMP%010lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ime
argument_list|)
expr_stmt|;
name|ztempfile
operator|=
name|zbufalc
argument_list|(
name|cslash
operator|+
sizeof|sizeof
name|abtempfile
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ztempfile
argument_list|,
name|zpath
argument_list|,
name|cslash
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ztempfile
operator|+
name|cslash
argument_list|,
name|abtempfile
argument_list|,
sizeof|sizeof
name|abtempfile
argument_list|)
expr_stmt|;
name|o
operator|=
name|creat
argument_list|(
name|ztempfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|ztempfile
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|o
operator|=
name|creat
argument_list|(
name|ztempfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"creat (%s): %s"
argument_list|,
name|ztempfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|i
operator|=
name|ime
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%10d\n"
argument_list|,
operator|(
name|int
operator|)
name|ime
argument_list|)
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
name|strlen
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zerr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
name|zerr
operator|=
literal|"write"
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
name|zerr
operator|=
literal|"close"
expr_stmt|;
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (%s): %s"
argument_list|,
name|zerr
argument_list|,
name|ztempfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now try to link the file we just created to the lock file that we      want.  If it fails, try reading the existing file to make sure      the process that created it still exists.  We do this in a loop      to make it easy to retry if the old locking process no longer      exists.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|FALSE
expr_stmt|;
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|zerr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|link
argument_list|(
name|ztempfile
argument_list|,
name|zpath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|cgot
decl_stmt|;
name|int
name|ipid
decl_stmt|;
name|boolean
name|freadonly
decl_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"link (%s, %s): %s"
argument_list|,
name|ztempfile
argument_list|,
name|zpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|freadonly
operator|=
name|FALSE
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zpath
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
block|{
name|freadonly
operator|=
name|TRUE
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zpath
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* The file was presumably removed between the link 		     and the open.  Try the link again.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|zerr
operator|=
literal|"open"
expr_stmt|;
break|break;
block|}
block|}
comment|/* The race starts here.  See below for a discussion.  */
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"read"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|ipid
operator|=
name|i
expr_stmt|;
else|#
directive|else
name|ab
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
name|strtol
argument_list|(
name|ab
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* On NFS, the link might have actually succeeded even though we 	 got a failure return.  This can happen if the original 	 acknowledgement was lost or delayed and the operation was 	 retried.  In this case the pid will be our own.  This 	 introduces a rather improbable race condition: if a stale 	 lock was left with our process ID in it, and another process 	 just did the kill, below, but has not yet changed the lock 	 file to hold its own process ID, we could start up and make 	 it all the way to here and think we have the lock.  I'm not 	 going to worry about this possibility.  */
if|if
condition|(
name|ipid
operator|==
name|ime
condition|)
block|{
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* If the process still exists, we will get EPERM rather than 	 ESRCH.  We then return FALSE to indicate that we cannot make 	 the lock.  */
if|if
condition|(
name|kill
argument_list|(
name|ipid
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EPERM
condition|)
break|break;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Found stale lock %s held by process %d"
argument_list|,
name|zpath
argument_list|,
name|ipid
argument_list|)
expr_stmt|;
comment|/* This is a stale lock, created by a process that no longer 	 exists.  	 Now we could remove the file (and, if the file mode disallows 	 writing, that's what we have to do), but we try to avoid 	 doing so since it causes a race condition.  If we remove the 	 file, and are interrupted any time after we do the read until 	 we do the remove, another process could get in, open the 	 file, find that it was a stale lock, remove the file and 	 create a new one.  When we regained control we would remove 	 the file the other process just created.  	 These files are being generated partially for the benefit of 	 cu, and it would be nice to avoid the race however cu avoids 	 it, so that the programs remain compatible.  Unfortunately, 	 nobody seems to know how cu avoids the race, or even if it 	 tries to avoid it at all.  	 There are a few ways to avoid the race.  We could use kernel 	 locking primitives, but they may not be available.  We could 	 link to a special file name, but if that file were left lying 	 around then no stale lock could ever be broken (Henry Spencer 	 would think this was a good thing).  	 Instead I've implemented the following procedure: seek to the 	 start of the file, write our pid into it, sleep for five 	 seconds, and then make sure our pid is still there.  Anybody 	 who checks the file while we're asleep will find our pid 	 there and fail the lock.  The only race will come from 	 another process which has done the read by the time we do our 	 write.  That process will then have five seconds to do its 	 own write.  When we wake up, we'll notice that our pid is no 	 longer in the file, and retry the lock from the beginning.  	 This relies on the atomicity of write(2).  If it possible for 	 the writes of two processes to be interleaved, the two 	 processes could livelock.  POSIX unfortunately leaves this 	 case explicitly undefined; however, given that the write is 	 of less than a disk block, it's difficult to imagine an 	 interleave occurring.  	 Note that this is still a race.  If it takes the second 	 process more than five seconds to do the kill, the lseek, and 	 the write, both processes will think they have the lock. 	 Perhaps the length of time to sleep should be configurable. 	 Even better, perhaps I should add a configuration option to 	 use a permanent lock file, which eliminates any race and 	 forces the installer to be aware of the existence of the 	 permanent lock file.  	 We stat the file after the sleep, to make sure some other 	 program hasn't deleted it for us.  */
if|if
condition|(
name|freadonly
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zpath
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|o
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"lseek"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|i
operator|=
name|ime
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%10d\n"
argument_list|,
operator|(
name|int
operator|)
name|ime
argument_list|)
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
name|strlen
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"write"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|o
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"lseek"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"read"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|ipid
operator|=
name|i
expr_stmt|;
else|#
directive|else
name|ab
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
name|strtol
argument_list|(
name|ab
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ipid
operator|==
name|ime
condition|)
block|{
name|struct
name|stat
name|sfile
decl_stmt|,
name|sdescriptor
decl_stmt|;
comment|/* It looks like we have the lock.  Do the final stat 	     check.  */
if|if
condition|(
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zpath
argument_list|,
operator|&
name|sfile
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|zerr
operator|=
literal|"stat"
expr_stmt|;
break|break;
block|}
comment|/* Loop around and try again.  */
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|o
argument_list|,
operator|&
name|sdescriptor
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"fstat"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sfile
operator|.
name|st_ino
operator|==
name|sdescriptor
operator|.
name|st_ino
operator|&&
name|sfile
operator|.
name|st_dev
operator|==
name|sdescriptor
operator|.
name|st_dev
condition|)
block|{
comment|/* Close the file before assuming we've succeeded to 		     pick up any trailing errors.  */
if|if
condition|(
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"close"
expr_stmt|;
break|break;
block|}
name|o
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We have the lock.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Loop around and try the lock again.  We keep doing this until 	 the lock file holds a pid that exists.  */
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (%s): %s"
argument_list|,
name|zerr
argument_list|,
name|zpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
comment|/* It would be nice if we could leave the temporary file around for      future calls, but considering that we create lock files in      various different directories it's probably more trouble than      it's worth.  */
if|if
condition|(
name|remove
argument_list|(
name|ztempfile
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|ztempfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unlock something.  The fspooldir argument is as in fsdo_lock.  */
end_comment

begin_function
name|boolean
name|fsdo_unlock
parameter_list|(
name|zlock
parameter_list|,
name|fspooldir
parameter_list|)
specifier|const
name|char
modifier|*
name|zlock
decl_stmt|;
name|boolean
name|fspooldir
decl_stmt|;
block|{
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpath
decl_stmt|;
if|if
condition|(
name|fspooldir
condition|)
block|{
name|zfree
operator|=
name|NULL
expr_stmt|;
name|zpath
operator|=
name|zlock
expr_stmt|;
block|}
else|else
block|{
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zSlockdir
argument_list|,
name|zlock
argument_list|)
expr_stmt|;
name|zpath
operator|=
name|zfree
expr_stmt|;
block|}
if|if
condition|(
name|remove
argument_list|(
name|zpath
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|zpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

end_unit

