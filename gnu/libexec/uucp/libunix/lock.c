begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lock.c    Lock and unlock a file name.     Copyright (C) 1991, 1992, 1993, 1995 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|lock_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TM_IN_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_QNX_LOCKFILES
end_if

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/psinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/seginfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/vc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|localtime
end_ifndef

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_QNX_LOCKFILES
end_if

begin_decl_stmt
specifier|static
name|boolean
name|fsqnx_stale
name|P
argument_list|(
operator|(
name|unsigned
name|long
name|ipid
operator|,
name|unsigned
name|long
name|inme
operator|,
name|unsigned
name|long
name|inid
operator|,
name|boolean
operator|*
name|pferr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Lock something.  If the fspooldir argument is TRUE, the argument is    a file name relative to the spool directory; otherwise the argument    is a simple file name which should be created in the system lock    directory (under HDB this is /etc/locks).  */
end_comment

begin_function
name|boolean
name|fsdo_lock
parameter_list|(
name|zlock
parameter_list|,
name|fspooldir
parameter_list|,
name|pferr
parameter_list|)
specifier|const
name|char
modifier|*
name|zlock
decl_stmt|;
name|boolean
name|fspooldir
decl_stmt|;
name|boolean
modifier|*
name|pferr
decl_stmt|;
block|{
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpath
decl_stmt|,
modifier|*
name|zslash
decl_stmt|;
name|size_t
name|cslash
decl_stmt|;
name|pid_t
name|ime
decl_stmt|;
name|char
modifier|*
name|ztempfile
decl_stmt|;
name|char
name|abtempfile
index|[
sizeof|sizeof
expr|"TMP12345678901234567890"]
expr_stmt|;
name|int
name|o
decl_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|nid_t
name|inme
decl_stmt|;
name|char
name|ab
index|[
literal|23
index|]
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|int
name|i
decl_stmt|;
else|#
directive|else
name|char
name|ab
index|[
literal|12
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|cwrote
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fspooldir
condition|)
block|{
name|zfree
operator|=
name|NULL
expr_stmt|;
name|zpath
operator|=
name|zlock
expr_stmt|;
block|}
else|else
block|{
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zSlockdir
argument_list|,
name|zlock
argument_list|)
expr_stmt|;
name|zpath
operator|=
name|zfree
expr_stmt|;
block|}
name|ime
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|inme
operator|=
name|getnid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* We do the actual lock by creating a file and then linking it to      the final file name we want.  This avoids race conditions due to      one process checking the file before we have finished writing it,      and also works even if we are somehow running as root.       First, create the file in the right directory (we must create the      file in the same directory since otherwise we might attempt a      cross-device link).  */
name|zslash
operator|=
name|strrchr
argument_list|(
name|zpath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
condition|)
name|cslash
operator|=
literal|0
expr_stmt|;
else|else
name|cslash
operator|=
name|zslash
operator|-
name|zpath
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|sprintf
argument_list|(
name|abtempfile
argument_list|,
literal|"TMP%010lx%010lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ime
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|inme
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|abtempfile
argument_list|,
literal|"TMP%010lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ztempfile
operator|=
name|zbufalc
argument_list|(
name|cslash
operator|+
sizeof|sizeof
name|abtempfile
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ztempfile
argument_list|,
name|zpath
argument_list|,
name|cslash
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ztempfile
operator|+
name|cslash
argument_list|,
name|abtempfile
argument_list|,
sizeof|sizeof
name|abtempfile
argument_list|)
expr_stmt|;
name|o
operator|=
name|creat
argument_list|(
name|ztempfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|ztempfile
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|o
operator|=
name|creat
argument_list|(
name|ztempfile
argument_list|,
name|IPUBLIC_FILE_MODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"creat (%s): %s"
argument_list|,
name|ztempfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%10ld %10ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ime
argument_list|,
operator|(
name|long
operator|)
name|inme
argument_list|)
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
name|strlen
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|i
operator|=
operator|(
name|int
operator|)
name|ime
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%10ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ime
argument_list|)
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
name|strlen
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|zerr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
name|zerr
operator|=
literal|"write"
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
name|zerr
operator|=
literal|"close"
expr_stmt|;
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (%s): %s"
argument_list|,
name|zerr
argument_list|,
name|ztempfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now try to link the file we just created to the lock file that we      want.  If it fails, try reading the existing file to make sure      the process that created it still exists.  We do this in a loop      to make it easy to retry if the old locking process no longer      exists.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|FALSE
expr_stmt|;
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|zerr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|link
argument_list|(
name|ztempfile
argument_list|,
name|zpath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|cgot
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|boolean
name|freadonly
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|abtime
index|[
sizeof|sizeof
expr|"1991-12-31 12:00:00"]
expr_stmt|;
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|nid_t
name|inid
decl_stmt|;
endif|#
directive|endif
name|fret
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"link (%s, %s): %s"
argument_list|,
name|ztempfile
argument_list|,
name|zpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|freadonly
operator|=
name|FALSE
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zpath
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
block|{
name|freadonly
operator|=
name|TRUE
expr_stmt|;
name|o
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zpath
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* The file was presumably removed between the link 		     and the open.  Try the link again.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|zerr
operator|=
literal|"open"
expr_stmt|;
break|break;
block|}
block|}
comment|/* The race starts here.  See below for a discussion.  */
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"read"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|#
directive|if
name|HAVE_V2_LOCKFILES
block|{
name|char
name|ab
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
argument_list|)
operator|>
literal|4
operator|&&
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|ab
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Lock file %s may be HDB format; check LOCKFILES in policy.h"
argument_list|,
name|zpath
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|cgot
operator|==
literal|4
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Lock file %s may be V2 format; check LOCKFILES in policy.h"
argument_list|,
name|zpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* DEBUG> 0 */
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|ab
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|ab
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|inid
operator|=
operator|(
name|nid_t
operator|)
name|strtol
argument_list|(
name|zend
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|i
expr_stmt|;
else|#
directive|else
name|ab
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|ab
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* On NFS, the link might have actually succeeded even though we 	 got a failure return.  This can happen if the original 	 acknowledgement was lost or delayed and the operation was 	 retried.  In this case the pid will be our own.  This 	 introduces a rather improbable race condition: if a stale 	 lock was left with our process ID in it, and another process 	 just did the kill, below, but has not yet changed the lock 	 file to hold its own process ID, we could start up and make 	 it all the way to here and think we have the lock.  I'm not 	 going to worry about this possibility.  */
if|if
condition|(
name|ipid
operator|==
name|ime
condition|)
block|{
if|#
directive|if
name|HAVE_QNX_LOCKFILES
if|if
condition|(
name|inid
operator|==
name|inme
condition|)
endif|#
directive|endif
block|{
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* If the lock file is empty (cgot == 0), we assume that it is          stale.  This can happen if the system crashed after the lock          file was created but before the process ID was written out.  */
if|if
condition|(
name|cgot
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|HAVE_QNX_LOCKFILES
if|if
condition|(
operator|!
name|fsqnx_stale
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|inme
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|inid
argument_list|,
name|pferr
argument_list|)
condition|)
break|break;
else|#
directive|else
comment|/* If the process still exists, we will get EPERM rather 	     than ESRCH.  We then return FALSE to indicate that we 	     cannot make the lock.  */
if|if
condition|(
name|kill
argument_list|(
name|ipid
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EPERM
condition|)
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|fstat
argument_list|(
name|o
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|strcpy
argument_list|(
name|abtime
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
else|else
block|{
name|time_t
name|itm
decl_stmt|;
name|struct
name|tm
modifier|*
name|q
decl_stmt|;
name|itm
operator|=
operator|(
name|time_t
operator|)
name|st
operator|.
name|st_mtime
expr_stmt|;
name|q
operator|=
name|localtime
argument_list|(
operator|&
name|itm
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|abtime
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02d"
argument_list|,
name|q
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|q
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|q
operator|->
name|tm_mday
argument_list|,
name|q
operator|->
name|tm_hour
argument_list|,
name|q
operator|->
name|tm_min
argument_list|,
name|q
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Stale lock %s held by process %ld on node %ld created %s"
argument_list|,
name|zpath
argument_list|,
operator|(
name|long
operator|)
name|ipid
argument_list|,
operator|(
name|long
operator|)
name|inid
argument_list|,
name|abtime
argument_list|)
expr_stmt|;
else|#
directive|else
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Stale lock %s held by process %ld created %s"
argument_list|,
name|zpath
argument_list|,
operator|(
name|long
operator|)
name|ipid
argument_list|,
name|abtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is a stale lock, created by a process that no longer 	 exists.  	 Now we could remove the file (and, if the file mode disallows 	 writing, that's what we have to do), but we try to avoid 	 doing so since it causes a race condition.  If we remove the 	 file, and are interrupted any time after we do the read until 	 we do the remove, another process could get in, open the 	 file, find that it was a stale lock, remove the file and 	 create a new one.  When we regained control we would remove 	 the file the other process just created.  	 These files are being generated partially for the benefit of 	 cu, and it would be nice to avoid the race however cu avoids 	 it, so that the programs remain compatible.  Unfortunately, 	 nobody seems to know how cu avoids the race, or even if it 	 tries to avoid it at all.  	 There are a few ways to avoid the race.  We could use kernel 	 locking primitives, but they may not be available.  We could 	 link to a special file name, but if that file were left lying 	 around then no stale lock could ever be broken (Henry Spencer 	 would think this was a good thing).  	 Instead I've implemented the following procedure: seek to the 	 start of the file, write our pid into it, sleep for five 	 seconds, and then make sure our pid is still there.  Anybody 	 who checks the file while we're asleep will find our pid 	 there and fail the lock.  The only race will come from 	 another process which has done the read by the time we do our 	 write.  That process will then have five seconds to do its 	 own write.  When we wake up, we'll notice that our pid is no 	 longer in the file, and retry the lock from the beginning.  	 This relies on the atomicity of write(2).  If it possible for 	 the writes of two processes to be interleaved, the two 	 processes could livelock.  POSIX unfortunately leaves this 	 case explicitly undefined; however, given that the write is 	 of less than a disk block, it's difficult to imagine an 	 interleave occurring.  	 Note that this is still a race.  If it takes the second 	 process more than five seconds to do the kill, the lseek, and 	 the write, both processes will think they have the lock. 	 Perhaps the length of time to sleep should be configurable. 	 Even better, perhaps I should add a configuration option to 	 use a permanent lock file, which eliminates any race and 	 forces the installer to be aware of the existence of the 	 permanent lock file.  	 We stat the file after the sleep, to make sure some other 	 program hasn't deleted it for us.  */
if|if
condition|(
name|freadonly
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zpath
argument_list|)
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|o
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"lseek"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%10ld %10ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ime
argument_list|,
operator|(
name|long
operator|)
name|inme
argument_list|)
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
name|strlen
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|i
operator|=
operator|(
name|int
operator|)
name|ime
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%10ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ime
argument_list|)
expr_stmt|;
name|cwrote
operator|=
name|write
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
name|strlen
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"write"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|o
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"lseek"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|cgot
operator|=
name|read
argument_list|(
name|o
argument_list|,
name|ab
argument_list|,
sizeof|sizeof
name|ab
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"read"
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_QNX_LOCKFILES
name|ab
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|ab
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|inid
operator|=
operator|(
name|nid_t
operator|)
name|strtol
argument_list|(
name|zend
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_V2_LOCKFILES
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|i
expr_stmt|;
else|#
directive|else
name|ab
index|[
name|cgot
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ipid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|ab
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|ipid
operator|==
name|ime
condition|)
block|{
if|#
directive|if
name|HAVE_QNX_LOCKFILES
if|if
condition|(
name|inid
operator|==
name|inme
condition|)
endif|#
directive|endif
block|{
name|struct
name|stat
name|sfile
decl_stmt|,
name|sdescriptor
decl_stmt|;
comment|/* It looks like we have the lock.  Do the final stat 		 check.  */
if|if
condition|(
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zpath
argument_list|,
operator|&
name|sfile
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|zerr
operator|=
literal|"stat"
expr_stmt|;
break|break;
block|}
comment|/* Loop around and try again.  */
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|o
argument_list|,
operator|&
name|sdescriptor
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"fstat"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sfile
operator|.
name|st_ino
operator|==
name|sdescriptor
operator|.
name|st_ino
operator|&&
name|sfile
operator|.
name|st_dev
operator|==
name|sdescriptor
operator|.
name|st_dev
condition|)
block|{
comment|/* Close the file before assuming we've 			 succeeded to pick up any trailing errors.  */
if|if
condition|(
name|close
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zerr
operator|=
literal|"close"
expr_stmt|;
break|break;
block|}
name|o
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We have the lock.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Loop around and try the lock again.  We keep doing this until 	 the lock file holds a pid that exists.  */
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s (%s): %s"
argument_list|,
name|zerr
argument_list|,
name|zpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
comment|/* It would be nice if we could leave the temporary file around for      future calls, but considering that we create lock files in      various different directories it's probably more trouble than      it's worth.  */
if|if
condition|(
name|remove
argument_list|(
name|ztempfile
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|ztempfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|ztempfile
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unlock something.  The fspooldir argument is as in fsdo_lock.  */
end_comment

begin_function
name|boolean
name|fsdo_unlock
parameter_list|(
name|zlock
parameter_list|,
name|fspooldir
parameter_list|)
specifier|const
name|char
modifier|*
name|zlock
decl_stmt|;
name|boolean
name|fspooldir
decl_stmt|;
block|{
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpath
decl_stmt|;
if|if
condition|(
name|fspooldir
condition|)
block|{
name|zfree
operator|=
name|NULL
expr_stmt|;
name|zpath
operator|=
name|zlock
expr_stmt|;
block|}
else|else
block|{
name|zfree
operator|=
name|zsysdep_in_dir
argument_list|(
name|zSlockdir
argument_list|,
name|zlock
argument_list|)
expr_stmt|;
name|zpath
operator|=
name|zfree
expr_stmt|;
block|}
if|if
condition|(
name|remove
argument_list|(
name|zpath
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"remove (%s): %s"
argument_list|,
name|zpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_QNX_LOCKFILES
end_if

begin_comment
comment|/* Return TRUE if the lock is stale.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsqnx_stale
parameter_list|(
name|ipid
parameter_list|,
name|inme
parameter_list|,
name|inid
parameter_list|,
name|pferr
parameter_list|)
name|unsigned
name|long
name|ipid
decl_stmt|;
name|unsigned
name|long
name|inme
decl_stmt|;
name|unsigned
name|long
name|inid
decl_stmt|;
name|boolean
modifier|*
name|pferr
decl_stmt|;
block|{
comment|/* A virtual process ID.  This virtual process ID, which will exist      on the local node, will represent the process ID of the process      manager process (Proc) on the remote node. */
name|pid_t
name|ivid
decl_stmt|;
comment|/* The return value of the qnx_psinfo function.  This is either a      process ID which might or might not be the same as the process      being looked for, or -1 to indicate no process found. */
name|pid_t
name|ifound_pid
decl_stmt|;
comment|/* This holds the actual result of qnx_psinfo.  We will ignore      almost all the fields since we're just checking for existence. */
name|struct
name|_psinfo
name|spsdata
decl_stmt|;
comment|/* Establish connection with a remote process manager if necessary. */
if|if
condition|(
name|inid
operator|!=
name|inme
condition|)
block|{
name|ivid
operator|=
name|qnx_vc_attach
argument_list|(
name|inid
comment|/* remote node ID */
argument_list|,
name|PROC_PID
comment|/* pid of process manager */
argument_list|,
literal|1000
comment|/* initial buffer size */
argument_list|,
literal|0
comment|/* flags */
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"qnx_vc_attach (%lu, PROC_PID): %s"
argument_list|,
name|inid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pferr
operator|!=
name|NULL
condition|)
operator|*
name|pferr
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* Use the local pid of the local process manager. */
name|ivid
operator|=
name|PROC_PID
expr_stmt|;
block|}
comment|/* Request the process information. */
name|ifound_pid
operator|=
name|qnx_psinfo
argument_list|(
name|ivid
comment|/* process manager handling request */
argument_list|,
name|ipid
comment|/* get info on this process */
argument_list|,
operator|&
name|spsdata
comment|/* put info in this struct */
argument_list|,
literal|0
comment|/* unused */
argument_list|,
operator|(
expr|struct
name|_seginfo
operator|*
operator|)
name|NULL
comment|/* unused */
argument_list|)
expr_stmt|;
comment|/* Deallocate the virtual connection before continuing. */
block|{
name|int
name|isaved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|qnx_vc_detach
argument_list|(
name|ivid
argument_list|)
operator|<
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"qnx_vd_detach (%ld): %s"
argument_list|,
operator|(
name|long
operator|)
name|ivid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|isaved_errno
expr_stmt|;
block|}
comment|/* If the returned pid matches then the process still holds the lock. */
if|if
condition|(
operator|(
name|ifound_pid
operator|==
name|ipid
operator|)
operator|&&
operator|(
name|spsdata
operator|.
name|pid
operator|==
name|ipid
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the returned pid is positive and doesn't match, then the      process doesn't exist and the lock is stale.  Continue. */
comment|/* If the returned pid is negative (-1) and errno is EINVAL (or ESRCH      in older versions of QNX), then the process doesn't exist and the      lock is stale.  Continue. */
comment|/* Check for impossible errors. */
if|if
condition|(
operator|(
name|ifound_pid
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ESRCH
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINVAL
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"qnx_psinfo (%ld, %ld): %s"
argument_list|,
operator|(
name|long
operator|)
name|ivid
argument_list|,
operator|(
name|long
operator|)
name|ipid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since we don't know what the hell this means, and we don't 	 want our system to freeze, we treat this case as a stale 	 lock.  Continue on. */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_QNX_LOCKFILES */
end_comment

end_unit

