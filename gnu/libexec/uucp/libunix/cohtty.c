begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Coherent tty locking support.  This file was contributed by Bob    Hemedinger<bob@dalek.mwc.com> of Mark Williams Corporation and    lightly edited by Ian Lance Taylor.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* The bottom part of this file is lock.c.  * This is a hacked lock.c. A full lock.c can be found in the libmisc sources   * under /usr/src/misc.tar.Z.  *  * These are for checking for the existence of locks:  * lockexist(resource)  * lockttyexist(ttyname)  */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|HAVE_COHERENT_LOCKFILES
end_if

begin_comment
comment|/* cohtty.c:	Given a serial device name, read /etc/ttys and determine if  *		the device is already enabled. If it is, disable the  *		device and return a string so that it can be re-enabled  * 		at the completion of the uucico session as part of the  *		function that resets the serial device before uucico  *		terminates.  *  */
end_comment

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_comment
comment|/* fscoherent_disable_tty() is a COHERENT specific function. It takes the name  * of a serial device and then scans /etc/ttys for a match. If it finds one,  * it checks the first field of the entry. If it is a '1', then it will disable  * the port and set a flag. The flag will be checked later when uucico wants to  * reset the serial device to see if the device needs to be re-enabled.  */
end_comment

begin_comment
comment|/* May 10, 1993: This function will always return true for the following  * reasons:  *  1) lock files have already been dealt with  *  2) if someone else already has the port open, uucico should fail anyways  *  3) Coherent's disable command return can return '0' or '1', but will  *     succeed in any event.  *  4) It doesn't matter if there is a ttys entry for the port in question.  *     /etc/ttys generally only lists devices that MAY be enabled for logins.  *     If a device will never be used for logins, then there may not be a  *     ttys entry, in which case, disable won't be called anyways.  *	---bob@mwc.com  */
end_comment

begin_function
name|boolean
name|fscoherent_disable_tty
parameter_list|(
name|zdevice
parameter_list|,
name|pzenable
parameter_list|)
specifier|const
name|char
modifier|*
name|zdevice
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzenable
decl_stmt|;
block|{
struct|struct
name|ttyentry
block|{
comment|/* this is an /etc/ttys entry */
name|char
name|enable_disable
index|[
literal|1
index|]
decl_stmt|;
name|char
name|remote_local
index|[
literal|1
index|]
decl_stmt|;
name|char
name|baud_rate
index|[
literal|1
index|]
decl_stmt|;
name|char
name|tty_device
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|ttyentry
name|sought_tty
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
comment|/* dummy */
name|FILE
modifier|*
name|infp
decl_stmt|;
comment|/* this will point to /etc/ttys */
name|char
name|disable_command
index|[
literal|66
index|]
decl_stmt|;
comment|/* this will be the disable command 					 * passed to the system. 					 */
name|char
name|enable_device
index|[
literal|16
index|]
decl_stmt|;
comment|/* this will hold our device name 					 * to enable. 					 */
operator|*
name|pzenable
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|enable_device
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* initialize our strings */
name|strcpy
argument_list|(
name|sought_tty
operator|.
name|tty_device
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|infp
operator|=
name|fopen
argument_list|(
literal|"/etc/ttys"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Error: check_disable_tty: failed to open /etc/ttys\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|NULL
operator|!=
operator|(
name|fgets
argument_list|(
operator|&
name|sought_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|sought_tty
argument_list|)
argument_list|,
name|infp
argument_list|)
operator|)
condition|)
block|{
name|sought_tty
operator|.
name|tty_device
index|[
name|strlen
argument_list|(
name|sought_tty
operator|.
name|tty_device
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|enable_device
argument_list|,
name|sought_tty
operator|.
name|tty_device
argument_list|)
expr_stmt|;
comment|/* we must strip away the suffix to the com port name or 		 * we will never find a match. For example, if we are passed 		 * /dev/com4l to call out with and the port is already enabled, 		 * 9/10 the port enabled will be com4r. After we strip away the 		 * suffix of the port found in /etc/ttys, then we can test 		 * if the base port name appears in the device name string 		 * passed to us. 		 */
for|for
control|(
name|z
operator|=
name|strlen
argument_list|(
name|sought_tty
operator|.
name|tty_device
argument_list|)
init|;
name|z
operator|>
literal|0
condition|;
name|z
operator|--
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|sought_tty
operator|.
name|tty_device
index|[
name|z
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|y
operator|=
name|strlen
argument_list|(
name|sought_tty
operator|.
name|tty_device
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|z
operator|+
literal|1
init|;
name|x
operator|<=
name|y
condition|;
name|x
operator|++
control|)
block|{
name|sought_tty
operator|.
name|tty_device
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*		ulog(LOG_NORMAL,"found device {%s}\n",sought_tty.tty_device); */
if|if
condition|(
name|strstr
argument_list|(
name|zdevice
argument_list|,
name|sought_tty
operator|.
name|tty_device
argument_list|)
condition|)
block|{
if|if
condition|(
name|sought_tty
operator|.
name|enable_disable
index|[
literal|0
index|]
operator|==
literal|'1'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"coh_tty: Disabling device %s {%s}\n"
argument_list|,
name|zdevice
argument_list|,
name|sought_tty
operator|.
name|tty_device
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|disable_command
argument_list|,
literal|"/etc/disable %s"
argument_list|,
name|enable_device
argument_list|)
expr_stmt|;
block|{
name|pid_t
name|ipid
decl_stmt|;
specifier|const
name|char
modifier|*
name|azargs
index|[
literal|3
index|]
decl_stmt|;
name|int
name|aidescs
index|[
literal|3
index|]
decl_stmt|;
name|azargs
index|[
literal|0
index|]
operator|=
literal|"/etc/disable"
expr_stmt|;
name|azargs
index|[
literal|1
index|]
operator|=
name|enable_device
expr_stmt|;
name|azargs
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|aidescs
index|[
literal|0
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|1
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|aidescs
index|[
literal|2
index|]
operator|=
name|SPAWN_NULL
expr_stmt|;
name|ipid
operator|=
name|ixsspawn
argument_list|(
name|azargs
argument_list|,
name|aidescs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
else|else
name|x
operator|=
name|ixswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|pzenable
operator|=
name|zbufalc
argument_list|(
sizeof|sizeof
name|_PATH_DEV
operator|+
name|strlen
argument_list|(
name|enable_device
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|pzenable
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|enable_device
argument_list|)
expr_stmt|;
comment|/*				ulog(LOG_NORMAL,"Enable string is {%s}",*pzenable); */
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* device not enabled */
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
comment|/* no ttys entry found */
block|}
end_function

begin_comment
comment|/* The following is COHERENT 4.0 specific. It is used to test for any  * existing lockfiles on a port which would have been created by init  * when a user logs into a port.  */
end_comment

begin_define
define|#
directive|define
name|LOCKSIG
value|9
end_define

begin_comment
comment|/* Significant Chars of Lockable Resources.  */
end_comment

begin_define
define|#
directive|define
name|LOKFLEN
value|64
end_define

begin_comment
comment|/* Max Length of UUCP Lock File Name.	     */
end_comment

begin_define
define|#
directive|define
name|LOCKPRE
value|"LCK.."
end_define

begin_define
define|#
directive|define
name|PIDLEN
value|6
end_define

begin_comment
comment|/* Maximum length of string representing a pid.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LOCKDIR
end_ifndef

begin_define
define|#
directive|define
name|LOCKDIR
value|SPOOLDIR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* There is a special version of DEVMASK for the PE multiport driver  * because of the peculiar way it uses the minor device number.  For  * all other drivers, the lower 5 bits describe the physical port--  * the upper 3 bits give attributes for the port.  */
end_comment

begin_define
define|#
directive|define
name|PE_DRIVER
value|21
end_define

begin_comment
comment|/* Major device number for the PE driver.  */
end_comment

begin_define
define|#
directive|define
name|PE_DEVMASK
value|0x3f
end_define

begin_comment
comment|/* PE driver minor device mask.  */
end_comment

begin_define
define|#
directive|define
name|DEVMASK
value|0x1f
end_define

begin_comment
comment|/* Minor device mask.  */
end_comment

begin_comment
comment|/*  * Generates a resource name for locking, based on the major number  * and the lower 4 bits of the minor number of the tty device.  *  * Builds the name in buff as two "." separated decimal numbers.  * Returns NULL on failure, buff on success.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gen_res_name
parameter_list|(
name|path
parameter_list|,
name|buff
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|status
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|)
condition|)
block|{
comment|/* Can't stat the file.  */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|PE_DRIVER
operator|==
name|major
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d.%d"
argument_list|,
name|major
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|PE_DEVMASK
operator|&
name|minor
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d.%d"
argument_list|,
name|major
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|DEVMASK
operator|&
name|minor
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gen_res_name */
end_comment

begin_comment
comment|/*  *  lockexist(resource)  char *resource;  *  *  Test for existance of a lock on the given resource.  *  *  Returns:  (1)  Resource is locked.  *	      (0)  Resource is not locked.  */
end_comment

begin_function
specifier|static
name|boolean
name|lockexist
parameter_list|(
name|resource
parameter_list|)
specifier|const
name|char
modifier|*
name|resource
decl_stmt|;
block|{
name|char
name|lockfn
index|[
name|LOKFLEN
index|]
decl_stmt|;
if|if
condition|(
name|resource
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sprintf
argument_list|(
name|lockfn
argument_list|,
literal|"%s/%s%.*s"
argument_list|,
name|LOCKDIR
argument_list|,
name|LOCKPRE
argument_list|,
name|LOCKSIG
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|access
argument_list|(
name|lockfn
argument_list|,
name|AEXISTS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* lockexist() */
end_comment

begin_comment
comment|/*  *  lockttyexist(ttyname)  char *ttyname;  *  *  Test for existance of a lock on the given tty.  *  *  Returns:  (1)  Resource is locked.  *	      (0)  Resource is not locked.  */
end_comment

begin_function
name|boolean
name|lockttyexist
parameter_list|(
name|ttyn
parameter_list|)
specifier|const
name|char
modifier|*
name|ttyn
decl_stmt|;
block|{
name|char
name|resource
index|[
name|LOKFLEN
index|]
decl_stmt|;
name|char
name|filename
index|[
name|LOKFLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|gen_res_name
argument_list|(
name|filename
argument_list|,
name|resource
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Non-existent tty can not be locked :-) */
block|}
return|return
operator|(
name|lockexist
argument_list|(
name|resource
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* lockttyexist() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_COHERENT_LOCKFILES */
end_comment

end_unit

