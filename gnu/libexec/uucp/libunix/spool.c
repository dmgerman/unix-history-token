begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* spool.c    Find a file in the spool directory.     Copyright (C) 1991, 1992, 1993 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.     The author of the program may be contacted at ian@airs.com or    c/o Cygnus Support, 48 Grove Street, Somerville, MA 02144.    */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
specifier|const
name|char
name|spool_rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* There are several types of files that go in the spool directory,    and they go into various different subdirectories.  Whenever the    system name LOCAL appears below, it means whatever the local system    name is.     Command files    These contain instructions for uucico indicating what files to transfer    to and from what systems.  Each line of a work file is a command    beginning with S, R, X, or E.    #if ! SPOOLDIR_TAYLOR    They are named C.ssssssgqqqq, where ssssss is the system name to    transfer to or from, g is the grade and qqqq is the sequence number.    #if SPOOLDIR_V2    They are put in the spool directory.    #elif SPOOLDIR_BSD42 || SPOOLDIR_BSD43    They are put in the directory "C.".    #elif SPOOLDIR_HDB    They are put in a directory named for the system for which they were    created.    #elif SPOOLDIR_ULTRIX    If the directory sys/ssssss exists, they are put in the directory    sys/ssssss/C; otherwise, they are put in the directory sys/DEFAULT/C.    #elif SPOOLDIR_SVR4    They are put in the directory sys/g, where sys is the system name    and g is the grade.    #endif    #else SPOOLDIR_TAYLOR    They are named C.gqqqq, where g is the grade and qqqq is the    sequence number, and are placed in the directory ssssss/C. where    ssssss is the system name to transfer to or from.  The sequence    number for a C. file is actually a long string; it is not based on    the sequence number file, but is generated via a process which    attempts to produce a unique string each time it is run.    #endif     Data files    There are files to be transferred to other systems.  Some files to    be transferred may not be in the spool directory, depending on how    uucp was invoked.  Data files are named in work files, so it is    never necessary to look at them directly (except to remove old ones);    it is only necessary to create them.  These means that the many    variations in naming are inconsequential.    #if ! SPOOLDIR_TAYLOR    They are named D.ssssssgqqqq where ssssss is a system name (which    may be LOCAL for locally initiated transfers or a remote system for    remotely initiated transfers, except that HDB appears to use the    system the file is being transferred to), g is the grade and qqqq    is the sequence number.  Some systems use a trailing subjob ID    number, but we currently do not.  The grade is not important, and    some systems do not use it.  If the data file is to become an    execution file on another system the grade (if present) will be    'X'.  Otherwise Ultrix appears to use 'b'; the uux included with    gnuucp 1.0 appears to use 'S'; SCO does not appear to use a grade,    although it does use a subjob ID number.    #if SPOOLDIR_V2    They are put in the spool directory.    #elif SPOOLDIR_BSD42    If the name begins with D.LOCAL, the file is put in the directory    D.LOCAL.  Otherwise the file is put in the directory D..    #elif SPOOLDIR_BSD43    If the name begins with D.LOCALX, the file is put in the directory    D.LOCALX.  Otherwise if the name begins with D.LOCAL, the file is    put in the directory D.LOCAL Otherwise the file is put in the    directory "D.".    #elif SPOOLDIR_HDB    They are put in a directory named for the system for which they    were created.    #elif SPOOLDIR_ULTRIX    Say the file is being transferred to system REMOTE.  If the    directory sys/REMOTE exists, then if the file begins with D.LOCALX    it is put in sys/REMOTE/D.LOCALX, if the file begins with D.LOCAL    it is put in sys/REMOTE/D.LOCAL, and otherwise it is put in    "sys/REMOTE/D.".  If the directory sys/REMOTE does not exist, the    same applies except that DEFAULT is used instead of REMOTE.    #elif SPOOLDIR_SVR4    They are put in the directory sys/g, where sys is the system name    and g is the grade.    #endif    #else SPOOLDIR_TAYLOR    If the file is to become an executable file on another system it is    named D.Xqqqq, otherwise it is named D.qqqq where in both cases    qqqq is a sequence number.  If the corresponding C. file is in    directory ssssss/C., a D.X file is placed in ssssss/D.X and a D.    file is placed in "ssssss/D.".    #endif     Execute files    These are files that specify programs to be executed.  They are    created by uux, perhaps as run on another system.  These names are    important, because a file transfer done to an execute file name    causes an execution to occur.  The name is X.ssssssgqqqq, where    ssssss is the requesting system, g is the grade, and qqqq is a    sequence number.    #if SPOOLDIR_V2 || SPOOLDIR_BSD42    These files are placed in the spool directory.    #elif SPOOLDIR_BSD43    These files are placed in the directory X..    #elif SPOOLDIR_HDB || SPOOLDIR_SVR4    These files are put in a directory named for the system for which    the files were created.    #elif SPOOLDIR_ULTRIX    If there is a spool directory (sys/ssssss) for the requesting    system, the files are placed in sys/ssssss/X.; otherwise, the files    are placed in "sys/DEFAULT/X.".    #elif SPOOLDIR_TAYLOR    The system name is automatically truncated to seven characters when    a file is created.  The files are placed in the subdirectory X. of    a directory named for the system for which the files were created.    #endif     Temporary receive files    These are used when receiving files from another system.  They are    later renamed to the final name.  The actual name is unimportant,    although it generally begins with TM..    #if SPOOLDIR_V2 || SPOOLDIR_BSD42    These files are placed in the spool directory.    #elif SPOOLDIR_BSD43 || SPOOLDIR_ULTRIX || SPOOLDIR_TAYLOR    These files are placed in the directory .Temp.    #elif SPOOLDIR_HDB || SPOOLDIR_SVR4    These files are placed in a directory named for the system for    which they were created.    #endif     System status files    These are used to record when the last call was made to the system    and what the status is.  They are used to prevent frequent recalls    to a system which is not responding.  I will not attempt to    recreate the format of these exactly, since they are not all that    important.  They will be put in the directory .Status, as in HDB,    and they use the system name as the name of the file.     Sequence file    This is used to generate a unique sequence number.  It contains an    ASCII number.    #if SPOOLDIR_V2 || SPOOLDIR_BSD42 || SPOOLDIR_BSD43    The file is named SEQF and is kept in the spool directory.    #elif SPOOLDIR_HDB || SPOOLDIR_SVR4    A separate sequence file is kept for each system in the directory    .Sequence with the name of the system.    #elif SPOOLDIR_ULTRIX    Each system with a file sys/ssssss has a sequence file in    sys/ssssss/.SEQF.  Other systems use sys/DEFAULT/.SEQF.    #else SPOOLDIR_TAYLOR    A sequence file named SEQF is kept in the directory ssssss for each    system.    #endif    */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Given the name of a file as specified in a UUCP command, and the    system for which this file has been created, return where to find    it in the spool directory.  The file will begin with C. (a command    file), D. (a data file) or X. (an execution file).  Under    SPOOLDIR_SVR4 we need to know the grade of the file created by the    local system; this is the bgrade argument, which is -1 for a file    from a remote system.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|zsfind_file
parameter_list|(
name|zsimple
parameter_list|,
name|zsystem
parameter_list|,
name|bgrade
parameter_list|)
specifier|const
name|char
modifier|*
name|zsimple
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
block|{
comment|/* zsysdep_spool_commands calls this with TMPXXX which we must treat      as a C. file.  */
if|if
condition|(
operator|(
name|zsimple
index|[
literal|0
index|]
operator|!=
literal|'T'
operator|||
name|zsimple
index|[
literal|1
index|]
operator|!=
literal|'M'
operator|||
name|zsimple
index|[
literal|2
index|]
operator|!=
literal|'P'
operator|)
operator|&&
operator|!
name|fspool_file
argument_list|(
name|zsimple
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized file name %s"
argument_list|,
name|zsimple
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
operator|!
name|SPOOLDIR_HDB
operator|&&
operator|!
name|SPOOLDIR_SVR4
operator|&&
operator|!
name|SPOOLDIR_TAYLOR
if|if
condition|(
operator|*
name|zsimple
operator|==
literal|'X'
condition|)
block|{
specifier|static
name|char
modifier|*
name|zbuf
decl_stmt|;
specifier|static
name|size_t
name|cbuf
decl_stmt|;
name|size_t
name|clen
decl_stmt|,
name|cwant
decl_stmt|;
comment|/* Files beginning with X. are execute files.  It is important 	 for security reasons that we know the system which created 	 the X. file.  This is easy under SPOOLDIR_HDB or 	 SPOOLDIR_SVR4 SPOOLDIR_TAYLOR, because the file will be in a 	 directory named for the system.  Under other schemes, we must 	 get the system name from the X. file name.  To prevent 	 security violations, we set the system name directly here; 	 this will cause problems if the maximum file name length is 	 too short, but hopefully no problem will occur since any 	 System V systems will be using HDB or SVR4 or TAYLOR.  */
name|clen
operator|=
name|strlen
argument_list|(
name|zsimple
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
literal|5
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad file name (too short) %s"
argument_list|,
name|zsimple
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cwant
operator|=
name|strlen
argument_list|(
name|zsystem
argument_list|)
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|cwant
operator|>
name|cbuf
condition|)
block|{
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|,
name|cwant
argument_list|)
expr_stmt|;
name|cbuf
operator|=
name|cwant
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|zbuf
argument_list|,
literal|"X.%s%s"
argument_list|,
name|zsystem
argument_list|,
name|zsimple
operator|+
name|clen
operator|-
literal|5
argument_list|)
expr_stmt|;
name|zsimple
operator|=
name|zbuf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4&& ! SPOOLDIR_TAYLOR */
if|#
directive|if
name|SPOOLDIR_V2
comment|/* V2 never uses subdirectories.  */
return|return
name|zbufcpy
argument_list|(
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_V2 */
if|#
directive|if
name|SPOOLDIR_HDB
comment|/* HDB always uses the system name as a directory.  */
return|return
name|zsysdep_in_dir
argument_list|(
name|zsystem
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_HDB */
if|#
directive|if
name|SPOOLDIR_SVR4
comment|/* SVR4 uses grade directories within the system directory for local      command and data files.  */
if|if
condition|(
name|bgrade
operator|<
literal|0
operator|||
operator|*
name|zsimple
operator|==
literal|'X'
condition|)
return|return
name|zsysdep_in_dir
argument_list|(
name|zsystem
argument_list|,
name|zsimple
argument_list|)
return|;
else|else
block|{
name|char
name|abgrade
index|[
literal|2
index|]
decl_stmt|;
name|abgrade
index|[
literal|0
index|]
operator|=
name|bgrade
expr_stmt|;
name|abgrade
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|zsappend3
argument_list|(
name|zsystem
argument_list|,
name|abgrade
argument_list|,
name|zsimple
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_SVR4 */
if|#
directive|if
operator|!
name|SPOOLDIR_V2
operator|&&
operator|!
name|SPOOLDIR_HDB
operator|&&
operator|!
name|SPOOLDIR_SVR4
switch|switch
condition|(
operator|*
name|zsimple
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'T'
case|:
if|#
directive|if
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
return|return
name|zsysdep_in_dir
argument_list|(
literal|"C."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_BSD42 || SPOOLDIR_BSD43 */
if|#
directive|if
name|SPOOLDIR_ULTRIX
if|if
condition|(
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|)
return|return
name|zsappend4
argument_list|(
literal|"sys"
argument_list|,
name|zsystem
argument_list|,
literal|"C."
argument_list|,
name|zsimple
argument_list|)
return|;
else|else
return|return
name|zsappend4
argument_list|(
literal|"sys"
argument_list|,
literal|"DEFAULT"
argument_list|,
literal|"C."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX */
if|#
directive|if
name|SPOOLDIR_TAYLOR
return|return
name|zsappend3
argument_list|(
name|zsystem
argument_list|,
literal|"C."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
case|case
literal|'D'
case|:
if|#
directive|if
name|SPOOLDIR_BSD42
operator|||
name|SPOOLDIR_BSD43
block|{
name|size_t
name|c
decl_stmt|;
name|boolean
name|ftruncated
decl_stmt|;
comment|/* D.LOCAL in D.LOCAL/, others in D./.  If BSD43, D.LOCALX in 	   D.LOCALX/.  */
name|ftruncated
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zsimple
operator|+
literal|2
argument_list|,
name|zSlocalname
argument_list|,
name|strlen
argument_list|(
name|zSlocalname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|strlen
argument_list|(
name|zSlocalname
argument_list|)
expr_stmt|;
name|ftruncated
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zsimple
operator|+
literal|2
argument_list|,
name|zSlocalname
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zsimple
operator|+
literal|2
argument_list|,
name|zSlocalname
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|6
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SPOOLDIR_BSD43
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|zsimple
index|[
name|c
operator|+
literal|2
index|]
operator|==
literal|'X'
condition|)
name|c
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* SPOOLDIR_BSD43 */
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|zalloc
decl_stmt|;
name|zalloc
operator|=
name|zbufalc
argument_list|(
name|c
operator|+
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zalloc
argument_list|,
name|zsimple
argument_list|,
name|c
operator|+
literal|2
argument_list|)
expr_stmt|;
name|zalloc
index|[
name|c
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If we truncated the system name, and there is no existing 	       directory with the truncated name, then just use D..  */
if|if
condition|(
operator|!
name|ftruncated
operator|||
name|fsysdep_directory
argument_list|(
name|zalloc
argument_list|)
condition|)
block|{
name|char
modifier|*
name|zret
decl_stmt|;
name|zret
operator|=
name|zsysdep_in_dir
argument_list|(
name|zalloc
argument_list|,
name|zsimple
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zalloc
argument_list|)
expr_stmt|;
return|return
name|zret
return|;
block|}
name|ubuffree
argument_list|(
name|zalloc
argument_list|)
expr_stmt|;
block|}
return|return
name|zsysdep_in_dir
argument_list|(
literal|"D."
argument_list|,
name|zsimple
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_BSD42 || SPOOLDIR_BSD43 */
if|#
directive|if
name|SPOOLDIR_ULTRIX
block|{
name|size_t
name|c
decl_stmt|;
name|boolean
name|ftruncated
decl_stmt|;
name|char
modifier|*
name|zfree
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdir
decl_stmt|;
name|char
modifier|*
name|zret
decl_stmt|;
comment|/* D.LOCALX in D.LOCALX/, D.LOCAL in D.LOCAL/, others in D./.  */
name|ftruncated
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zsimple
operator|+
literal|2
argument_list|,
name|zSlocalname
argument_list|,
name|strlen
argument_list|(
name|zSlocalname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|strlen
argument_list|(
name|zSlocalname
argument_list|)
expr_stmt|;
name|ftruncated
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zsimple
operator|+
literal|2
argument_list|,
name|zSlocalname
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zsimple
operator|+
literal|2
argument_list|,
name|zSlocalname
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|6
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|zsimple
index|[
name|c
operator|+
literal|2
index|]
operator|==
literal|'X'
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|zfree
operator|=
name|zbufalc
argument_list|(
name|c
operator|+
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zfree
argument_list|,
name|zsimple
argument_list|,
name|c
operator|+
literal|2
argument_list|)
expr_stmt|;
name|zfree
index|[
name|c
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zdir
operator|=
name|zfree
expr_stmt|;
comment|/* If we truncated the name, and there is no directory for 	       the truncated name, then don't use it.  */
if|if
condition|(
name|ftruncated
condition|)
block|{
name|char
modifier|*
name|zlook
decl_stmt|;
name|zlook
operator|=
name|zsappend3
argument_list|(
literal|"sys"
argument_list|,
operator|(
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|?
name|zsystem
else|:
literal|"DEFAULT"
operator|)
argument_list|,
name|zdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_directory
argument_list|(
name|zlook
argument_list|)
condition|)
name|zdir
operator|=
literal|"D."
expr_stmt|;
name|ubuffree
argument_list|(
name|zlook
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zfree
operator|=
name|NULL
expr_stmt|;
name|zdir
operator|=
literal|"D."
expr_stmt|;
block|}
name|zret
operator|=
name|zsappend4
argument_list|(
literal|"sys"
argument_list|,
operator|(
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|?
name|zsystem
else|:
literal|"DEFAULT"
operator|)
argument_list|,
name|zdir
argument_list|,
name|zsimple
argument_list|)
expr_stmt|;
name|ubuffree
argument_list|(
name|zfree
argument_list|)
expr_stmt|;
return|return
name|zret
return|;
block|}
endif|#
directive|endif
comment|/* SPOOLDIR_ULTRIX */
if|#
directive|if
name|SPOOLDIR_TAYLOR
if|if
condition|(
name|zsimple
index|[
literal|2
index|]
operator|==
literal|'X'
condition|)
return|return
name|zsappend3
argument_list|(
name|zsystem
argument_list|,
literal|"D.X"
argument_list|,
name|zsimple
argument_list|)
return|;
else|else
return|return
name|zsappend3
argument_list|(
name|zsystem
argument_list|,
literal|"D."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
comment|/* SPOOLDIR_TAYLOR */
case|case
literal|'X'
case|:
if|#
directive|if
name|SPOOLDIR_BSD42
return|return
name|zbufcpy
argument_list|(
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_BSD43
return|return
name|zsysdep_in_dir
argument_list|(
literal|"X."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_ULTRIX
return|return
name|zsappend4
argument_list|(
literal|"sys"
argument_list|,
operator|(
name|fsultrix_has_spool
argument_list|(
name|zsystem
argument_list|)
condition|?
name|zsystem
else|:
literal|"DEFAULT"
operator|)
argument_list|,
literal|"X."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|SPOOLDIR_TAYLOR
return|return
name|zsappend3
argument_list|(
name|zsystem
argument_list|,
literal|"X."
argument_list|,
name|zsimple
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/* This is just to avoid warnings; it will never be executed.  */
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* ! SPOOLDIR_V2&& ! SPOOLDIR_HDB&& ! SPOOLDIR_SVR4 */
block|}
end_function

end_unit

