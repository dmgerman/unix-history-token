begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Contributed by Isamu Hasegawa<isamu@yamato.ibm.com>.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, write to the Free    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA    02111-1307 USA.  */
end_comment

begin_function_decl
specifier|static
name|reg_errcode_t
name|re_compile_internal
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|length
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|re_compile_fastmap_iter
parameter_list|(
name|regex_t
modifier|*
name|bufp
parameter_list|,
specifier|const
name|re_dfastate_t
modifier|*
name|init_state
parameter_list|,
name|char
modifier|*
name|fastmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|init_dfa
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|int
name|pat_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_word_char
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_charset
parameter_list|(
name|re_charset_t
modifier|*
name|cset
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_function_decl
specifier|static
name|void
name|free_workarea_compile
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|create_initial_state
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function_decl
specifier|static
name|void
name|optimize_utf8
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|reg_errcode_t
name|analyze
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|create_initial_state
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|preorder
argument_list|(
name|bin_tree_t
operator|*
name|root
argument_list|,
name|reg_errcode_t
argument_list|(
name|fn
argument_list|(
name|void
operator|*
argument_list|,
name|bin_tree_t
operator|*
argument_list|)
argument_list|)
argument_list|,
name|void
operator|*
name|extra
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|postorder
argument_list|(
name|bin_tree_t
operator|*
name|root
argument_list|,
name|reg_errcode_t
argument_list|(
name|fn
argument_list|(
name|void
operator|*
argument_list|,
name|bin_tree_t
operator|*
argument_list|)
argument_list|)
argument_list|,
name|void
operator|*
name|extra
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|reg_errcode_t
name|optimize_subexps
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|lower_subexps
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|lower_subexp
parameter_list|(
name|reg_errcode_t
modifier|*
name|err
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|calc_first
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|calc_next
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|link_nfa_nodes
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|duplicate_node_closure
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|int
name|top_org_node
parameter_list|,
name|int
name|top_clone_node
parameter_list|,
name|int
name|root_node
parameter_list|,
name|unsigned
name|int
name|constraint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|duplicate_node
parameter_list|(
name|int
modifier|*
name|new_idx
parameter_list|,
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|int
name|org_idx
parameter_list|,
name|unsigned
name|int
name|constraint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|search_duplicated_node
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|int
name|org_node
parameter_list|,
name|unsigned
name|int
name|constraint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|calc_eclosure
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|calc_eclosure_iter
parameter_list|(
name|re_node_set
modifier|*
name|new_set
parameter_list|,
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|int
name|node
parameter_list|,
name|int
name|root
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|calc_inveclosure
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fetch_number
parameter_list|(
name|re_string_t
modifier|*
name|input
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetch_token
parameter_list|(
name|re_token_t
modifier|*
name|result
parameter_list|,
name|re_string_t
modifier|*
name|input
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|peek_token
parameter_list|(
name|re_token_t
modifier|*
name|token
parameter_list|,
name|re_string_t
modifier|*
name|input
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|peek_token_bracket
parameter_list|(
name|re_token_t
modifier|*
name|token
parameter_list|,
name|re_string_t
modifier|*
name|input
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse
parameter_list|(
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse_reg_exp
parameter_list|(
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|int
name|nest
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse_branch
parameter_list|(
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|int
name|nest
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse_expression
parameter_list|(
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|int
name|nest
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse_sub_exp
parameter_list|(
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|int
name|nest
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse_dup_op
parameter_list|(
name|bin_tree_t
modifier|*
name|dup_elem
parameter_list|,
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|parse_bracket_exp
parameter_list|(
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|parse_bracket_element
parameter_list|(
name|bracket_elem_t
modifier|*
name|elem
parameter_list|,
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|,
name|int
name|token_len
parameter_list|,
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|int
name|accept_hyphen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|parse_bracket_symbol
parameter_list|(
name|bracket_elem_t
modifier|*
name|elem
parameter_list|,
name|re_string_t
modifier|*
name|regexp
parameter_list|,
name|re_token_t
modifier|*
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_range_exp
parameter_list|(
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
name|re_charset_t
modifier|*
name|mbcset
parameter_list|,
name|int
modifier|*
name|range_alloc
parameter_list|,
name|bracket_elem_t
modifier|*
name|start_elem
parameter_list|,
name|bracket_elem_t
modifier|*
name|end_elem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_collating_symbol
parameter_list|(
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
name|re_charset_t
modifier|*
name|mbcset
parameter_list|,
name|int
modifier|*
name|coll_sym_alloc
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not RE_ENABLE_I18N */
end_comment

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_range_exp
parameter_list|(
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
name|bracket_elem_t
modifier|*
name|start_elem
parameter_list|,
name|bracket_elem_t
modifier|*
name|end_elem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_collating_symbol
parameter_list|(
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not RE_ENABLE_I18N */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _LIBC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_equiv_class
parameter_list|(
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
name|re_charset_t
modifier|*
name|mbcset
parameter_list|,
name|int
modifier|*
name|equiv_class_alloc
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_charclass
parameter_list|(
name|unsigned
name|RE_TRANSLATE_TYPE
name|trans
parameter_list|,
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
name|re_charset_t
modifier|*
name|mbcset
parameter_list|,
name|int
modifier|*
name|char_class_alloc
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|class_name
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not RE_ENABLE_I18N */
end_comment

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_equiv_class
parameter_list|(
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|build_charclass
parameter_list|(
name|unsigned
name|RE_TRANSLATE_TYPE
name|trans
parameter_list|,
name|re_bitset_ptr_t
name|sbcset
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|class_name
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not RE_ENABLE_I18N */
end_comment

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|build_charclass_op
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|unsigned
name|RE_TRANSLATE_TYPE
name|trans
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|class_name
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|extra
parameter_list|,
name|int
name|non_match
parameter_list|,
name|reg_errcode_t
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|create_tree
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|bin_tree_t
modifier|*
name|left
parameter_list|,
name|bin_tree_t
modifier|*
name|right
parameter_list|,
name|re_token_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|create_token_tree
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|,
name|bin_tree_t
modifier|*
name|left
parameter_list|,
name|bin_tree_t
modifier|*
name|right
parameter_list|,
specifier|const
name|re_token_t
modifier|*
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bin_tree_t
modifier|*
name|duplicate_tree
parameter_list|(
specifier|const
name|bin_tree_t
modifier|*
name|src
parameter_list|,
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_token
parameter_list|(
name|re_token_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|free_tree
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_errcode_t
name|mark_opt_subexp
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* This table gives an error message for each of the error codes listed    in regex.h.  Obviously the order here has to be same as there.    POSIX doesn't require that we do anything for REG_NOERROR,    but why not be nice?  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|__re_error_msgid
index|[]
name|attribute_hidden
init|=
block|{
define|#
directive|define
name|REG_NOERROR_IDX
value|0
name|gettext_noop
argument_list|(
literal|"Success"
argument_list|)
comment|/* REG_NOERROR */
literal|"\0"
define|#
directive|define
name|REG_NOMATCH_IDX
value|(REG_NOERROR_IDX + sizeof "Success")
name|gettext_noop
argument_list|(
literal|"No match"
argument_list|)
comment|/* REG_NOMATCH */
literal|"\0"
define|#
directive|define
name|REG_BADPAT_IDX
value|(REG_NOMATCH_IDX + sizeof "No match")
name|gettext_noop
argument_list|(
literal|"Invalid regular expression"
argument_list|)
comment|/* REG_BADPAT */
literal|"\0"
define|#
directive|define
name|REG_ECOLLATE_IDX
value|(REG_BADPAT_IDX + sizeof "Invalid regular expression")
name|gettext_noop
argument_list|(
literal|"Invalid collation character"
argument_list|)
comment|/* REG_ECOLLATE */
literal|"\0"
define|#
directive|define
name|REG_ECTYPE_IDX
value|(REG_ECOLLATE_IDX + sizeof "Invalid collation character")
name|gettext_noop
argument_list|(
literal|"Invalid character class name"
argument_list|)
comment|/* REG_ECTYPE */
literal|"\0"
define|#
directive|define
name|REG_EESCAPE_IDX
value|(REG_ECTYPE_IDX + sizeof "Invalid character class name")
name|gettext_noop
argument_list|(
literal|"Trailing backslash"
argument_list|)
comment|/* REG_EESCAPE */
literal|"\0"
define|#
directive|define
name|REG_ESUBREG_IDX
value|(REG_EESCAPE_IDX + sizeof "Trailing backslash")
name|gettext_noop
argument_list|(
literal|"Invalid back reference"
argument_list|)
comment|/* REG_ESUBREG */
literal|"\0"
define|#
directive|define
name|REG_EBRACK_IDX
value|(REG_ESUBREG_IDX + sizeof "Invalid back reference")
name|gettext_noop
argument_list|(
literal|"Unmatched [ or [^"
argument_list|)
comment|/* REG_EBRACK */
literal|"\0"
define|#
directive|define
name|REG_EPAREN_IDX
value|(REG_EBRACK_IDX + sizeof "Unmatched [ or [^")
name|gettext_noop
argument_list|(
literal|"Unmatched ( or \\("
argument_list|)
comment|/* REG_EPAREN */
literal|"\0"
define|#
directive|define
name|REG_EBRACE_IDX
value|(REG_EPAREN_IDX + sizeof "Unmatched ( or \\(")
name|gettext_noop
argument_list|(
literal|"Unmatched \\{"
argument_list|)
comment|/* REG_EBRACE */
literal|"\0"
define|#
directive|define
name|REG_BADBR_IDX
value|(REG_EBRACE_IDX + sizeof "Unmatched \\{")
name|gettext_noop
argument_list|(
literal|"Invalid content of \\{\\}"
argument_list|)
comment|/* REG_BADBR */
literal|"\0"
define|#
directive|define
name|REG_ERANGE_IDX
value|(REG_BADBR_IDX + sizeof "Invalid content of \\{\\}")
name|gettext_noop
argument_list|(
literal|"Invalid range end"
argument_list|)
comment|/* REG_ERANGE */
literal|"\0"
define|#
directive|define
name|REG_ESPACE_IDX
value|(REG_ERANGE_IDX + sizeof "Invalid range end")
name|gettext_noop
argument_list|(
literal|"Memory exhausted"
argument_list|)
comment|/* REG_ESPACE */
literal|"\0"
define|#
directive|define
name|REG_BADRPT_IDX
value|(REG_ESPACE_IDX + sizeof "Memory exhausted")
name|gettext_noop
argument_list|(
literal|"Invalid preceding regular expression"
argument_list|)
comment|/* REG_BADRPT */
literal|"\0"
define|#
directive|define
name|REG_EEND_IDX
value|(REG_BADRPT_IDX + sizeof "Invalid preceding regular expression")
name|gettext_noop
argument_list|(
literal|"Premature end of regular expression"
argument_list|)
comment|/* REG_EEND */
literal|"\0"
define|#
directive|define
name|REG_ESIZE_IDX
value|(REG_EEND_IDX + sizeof "Premature end of regular expression")
name|gettext_noop
argument_list|(
literal|"Regular expression too big"
argument_list|)
comment|/* REG_ESIZE */
literal|"\0"
define|#
directive|define
name|REG_ERPAREN_IDX
value|(REG_ESIZE_IDX + sizeof "Regular expression too big")
name|gettext_noop
argument_list|(
literal|"Unmatched ) or \\)"
argument_list|)
comment|/* REG_ERPAREN */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|size_t
name|__re_error_msgid_idx
index|[]
name|attribute_hidden
init|=
block|{
name|REG_NOERROR_IDX
block|,
name|REG_NOMATCH_IDX
block|,
name|REG_BADPAT_IDX
block|,
name|REG_ECOLLATE_IDX
block|,
name|REG_ECTYPE_IDX
block|,
name|REG_EESCAPE_IDX
block|,
name|REG_ESUBREG_IDX
block|,
name|REG_EBRACK_IDX
block|,
name|REG_EPAREN_IDX
block|,
name|REG_EBRACE_IDX
block|,
name|REG_BADBR_IDX
block|,
name|REG_ERANGE_IDX
block|,
name|REG_ESPACE_IDX
block|,
name|REG_BADRPT_IDX
block|,
name|REG_EEND_IDX
block|,
name|REG_ESIZE_IDX
block|,
name|REG_ERPAREN_IDX
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Entry points for GNU code.  */
end_comment

begin_comment
comment|/* re_compile_pattern is the GNU regular expression compiler: it    compiles PATTERN (of length LENGTH) and puts the result in BUFP.    Returns 0 if the pattern was valid, otherwise an error string.     Assumes the `allocated' (and perhaps `buffer') and `translate' fields    are set in BUFP on entry.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|re_compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|length
parameter_list|,
name|bufp
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* And GNU code determines whether or not to get register information      by passing null for the REGS argument to re_match, etc., not by      setting no_sub, unless RE_NO_SUB is set.  */
name|bufp
operator|->
name|no_sub
operator|=
operator|!
operator|!
operator|(
name|re_syntax_options
operator|&
name|RE_NO_SUB
operator|)
expr_stmt|;
comment|/* Match anchors at newline.  */
name|bufp
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|re_compile_internal
argument_list|(
name|bufp
argument_list|,
name|pattern
argument_list|,
name|length
argument_list|,
name|re_syntax_options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
return|return
name|gettext
argument_list|(
name|__re_error_msgid
operator|+
name|__re_error_msgid_idx
index|[
operator|(
name|int
operator|)
name|ret
index|]
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_compile_pattern
argument_list|,
argument|re_compile_pattern
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can    also be assigned to arbitrarily: each pattern buffer stores its own    syntax, so it can be changed between regex compilations.  */
end_comment

begin_comment
comment|/* This has no initializer because initialized variables in Emacs    become read-only after dumping.  */
end_comment

begin_decl_stmt
name|reg_syntax_t
name|re_syntax_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the precise syntax of regexps for compilation.  This provides    for compatibility for various utilities which historically have    different, incompatible syntaxes.     The argument SYNTAX is a bit mask comprised of the various bits    defined in regex.h.  We return the old syntax.  */
end_comment

begin_function
name|reg_syntax_t
name|re_set_syntax
parameter_list|(
name|syntax
parameter_list|)
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|reg_syntax_t
name|ret
init|=
name|re_syntax_options
decl_stmt|;
name|re_syntax_options
operator|=
name|syntax
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_set_syntax
argument_list|,
argument|re_set_syntax
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|re_compile_fastmap
parameter_list|(
name|bufp
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|bufp
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
name|memset
argument_list|(
name|fastmap
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|SBC_MAX
argument_list|)
expr_stmt|;
name|re_compile_fastmap_iter
argument_list|(
name|bufp
argument_list|,
name|dfa
operator|->
name|init_state
argument_list|,
name|fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|init_state
operator|!=
name|dfa
operator|->
name|init_state_word
condition|)
name|re_compile_fastmap_iter
argument_list|(
name|bufp
argument_list|,
name|dfa
operator|->
name|init_state_word
argument_list|,
name|fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|init_state
operator|!=
name|dfa
operator|->
name|init_state_nl
condition|)
name|re_compile_fastmap_iter
argument_list|(
name|bufp
argument_list|,
name|dfa
operator|->
name|init_state_nl
argument_list|,
name|fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|init_state
operator|!=
name|dfa
operator|->
name|init_state_begbuf
condition|)
name|re_compile_fastmap_iter
argument_list|(
name|bufp
argument_list|,
name|dfa
operator|->
name|init_state_begbuf
argument_list|,
name|fastmap
argument_list|)
expr_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_compile_fastmap
argument_list|,
argument|re_compile_fastmap
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|__attribute
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|re_set_fastmap
argument_list|(
name|char
operator|*
name|fastmap
argument_list|,
name|int
name|icase
argument_list|,
name|int
name|ch
argument_list|)
block|{
name|fastmap
index|[
name|ch
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|icase
condition|)
name|fastmap
index|[
name|tolower
argument_list|(
name|ch
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Helper function for re_compile_fastmap.    Compile fastmap for the initial_state INIT_STATE.  */
end_comment

begin_function
specifier|static
name|void
name|re_compile_fastmap_iter
parameter_list|(
name|bufp
parameter_list|,
name|init_state
parameter_list|,
name|fastmap
parameter_list|)
name|regex_t
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|re_dfastate_t
modifier|*
name|init_state
decl_stmt|;
name|char
modifier|*
name|fastmap
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|bufp
operator|->
name|buffer
decl_stmt|;
name|int
name|node_cnt
decl_stmt|;
name|int
name|icase
init|=
operator|(
name|dfa
operator|->
name|mb_cur_max
operator|==
literal|1
operator|&&
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_ICASE
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|node_cnt
operator|=
literal|0
init|;
name|node_cnt
operator|<
name|init_state
operator|->
name|nodes
operator|.
name|nelem
condition|;
operator|++
name|node_cnt
control|)
block|{
name|int
name|node
init|=
name|init_state
operator|->
name|nodes
operator|.
name|elems
index|[
name|node_cnt
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|CHARACTER
condition|)
block|{
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
name|icase
argument_list|,
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_ICASE
operator|)
operator|&&
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|dfa
operator|->
name|mb_cur_max
argument_list|)
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|c
expr_stmt|;
while|while
condition|(
operator|++
name|node
operator|<
name|dfa
operator|->
name|nodes_len
operator|&&
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
operator|==
name|CHARACTER
operator|&&
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|mb_partial
condition|)
operator|*
name|p
operator|++
operator|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|c
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|,
operator|&
name|state
argument_list|)
operator|==
name|p
operator|-
name|buf
operator|&&
operator|(
name|__wcrtomb
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|towlower
argument_list|(
name|wc
argument_list|)
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|)
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
literal|0
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SIMPLE_BRACKET
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ch
operator|=
literal|0
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UINT_BITS
condition|;
operator|++
name|j
operator|,
operator|++
name|ch
control|)
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|sbcset
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
name|icase
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
elseif|else
if|if
condition|(
name|type
operator|==
name|COMPLEX_BRACKET
condition|)
block|{
name|int
name|i
decl_stmt|;
name|re_charset_t
modifier|*
name|cset
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|mbcset
decl_stmt|;
if|if
condition|(
name|cset
operator|->
name|non_match
operator|||
name|cset
operator|->
name|ncoll_syms
operator|||
name|cset
operator|->
name|nequiv_classes
operator|||
name|cset
operator|->
name|nranges
operator|||
name|cset
operator|->
name|nchar_classes
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* In this case we want to catch the bytes which are 		     the first byte of any collation elements. 		     e.g. In da_DK, we want to catch 'a' since "aa" 			  is a valid collation element, and don't catch 			  'b' since 'b' is the only collation element 			  which starts from 'b'.  */
name|int
name|j
decl_stmt|,
name|ch
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|table
init|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEMB
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ch
operator|=
literal|0
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UINT_BITS
condition|;
operator|++
name|j
operator|,
operator|++
name|ch
control|)
if|if
condition|(
name|table
index|[
name|ch
index|]
operator|<
literal|0
condition|)
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
name|icase
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBC_MAX
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|__btowc
argument_list|(
name|i
argument_list|)
operator|==
name|WEOF
condition|)
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
name|icase
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not _LIBC */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|nmbchars
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__wcrtomb
argument_list|(
name|buf
argument_list|,
name|cset
operator|->
name|mbchars
index|[
name|i
index|]
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
name|icase
argument_list|,
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bufp
operator|->
name|syntax
operator|&
name|RE_ICASE
operator|)
operator|&&
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|__wcrtomb
argument_list|(
name|buf
argument_list|,
name|towlower
argument_list|(
name|cset
operator|->
name|mbchars
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|re_set_fastmap
argument_list|(
name|fastmap
argument_list|,
literal|0
argument_list|,
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_PERIOD
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
operator|||
name|type
operator|==
name|OP_UTF8_PERIOD
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
operator|||
name|type
operator|==
name|END_OF_RE
condition|)
block|{
name|memset
argument_list|(
name|fastmap
argument_list|,
literal|'\1'
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|SBC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|END_OF_RE
condition|)
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point for POSIX code.  */
end_comment

begin_comment
comment|/* regcomp takes a regular expression as a string and compiles it.     PREG is a regex_t *.  We do not expect any fields to be initialized,    since POSIX says we shouldn't.  Thus, we set       `buffer' to the compiled pattern;      `used' to the length of the compiled pattern;      `syntax' to RE_SYNTAX_POSIX_EXTENDED if the        REG_EXTENDED bit in CFLAGS is set; otherwise, to        RE_SYNTAX_POSIX_BASIC;      `newline_anchor' to REG_NEWLINE being set in CFLAGS;      `fastmap' to an allocated space for the fastmap;      `fastmap_accurate' to zero;      `re_nsub' to the number of subexpressions in PATTERN.     PATTERN is the address of the pattern string.     CFLAGS is a series of bits which affect compilation.       If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we      use POSIX basic syntax.       If REG_NEWLINE is set, then . and [^...] don't match newline.      Also, regexec will try a match beginning after every newline.       If REG_ICASE is set, then we considers upper- and lowercase      versions of letters to be equivalent when matching.       If REG_NOSUB is set, then when PREG is passed to regexec, that      routine will report only success or failure, and nothing about the      registers.     It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for    the return codes and their meanings.)  */
end_comment

begin_function
name|int
name|regcomp
parameter_list|(
name|preg
parameter_list|,
name|pattern
parameter_list|,
name|cflags
parameter_list|)
name|regex_t
modifier|*
name|__restrict
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|__restrict
name|pattern
decl_stmt|;
name|int
name|cflags
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|reg_syntax_t
name|syntax
init|=
operator|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
condition|?
name|RE_SYNTAX_POSIX_EXTENDED
else|:
name|RE_SYNTAX_POSIX_BASIC
operator|)
decl_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* Try to allocate space for the fastmap.  */
name|preg
operator|->
name|fastmap
operator|=
name|re_malloc
argument_list|(
name|char
argument_list|,
name|SBC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|preg
operator|->
name|fastmap
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|syntax
operator||=
operator|(
name|cflags
operator|&
name|REG_ICASE
operator|)
condition|?
name|RE_ICASE
else|:
literal|0
expr_stmt|;
comment|/* If REG_NEWLINE is set, newlines are treated differently.  */
if|if
condition|(
name|cflags
operator|&
name|REG_NEWLINE
condition|)
block|{
comment|/* REG_NEWLINE implies neither . nor [^...] match newline.  */
name|syntax
operator|&=
operator|~
name|RE_DOT_NEWLINE
expr_stmt|;
name|syntax
operator||=
name|RE_HAT_LISTS_NOT_NEWLINE
expr_stmt|;
comment|/* It also changes the matching behavior.  */
name|preg
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|newline_anchor
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|no_sub
operator|=
operator|!
operator|!
operator|(
name|cflags
operator|&
name|REG_NOSUB
operator|)
expr_stmt|;
name|preg
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|re_compile_internal
argument_list|(
name|preg
argument_list|,
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
comment|/* POSIX doesn't distinguish between an unmatched open-group and an      unmatched close-group: both are REG_EPAREN.  */
if|if
condition|(
name|ret
operator|==
name|REG_ERPAREN
condition|)
name|ret
operator|=
name|REG_EPAREN
expr_stmt|;
comment|/* We have already checked preg->fastmap != NULL.  */
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|==
name|REG_NOERROR
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* Compute the fastmap now, since regexec cannot modify the pattern        buffer.  This function never fails in this implementation.  */
operator|(
name|void
operator|)
name|re_compile_fastmap
argument_list|(
name|preg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Some error occurred while compiling the expression.  */
name|re_free
argument_list|(
name|preg
operator|->
name|fastmap
argument_list|)
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regcomp
argument_list|,
argument|regcomp
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Returns a message corresponding to an error code, ERRCODE, returned    from either regcomp or regexec.   We don't use PREG here.  */
end_comment

begin_function
name|size_t
name|regerror
parameter_list|(
name|errcode
parameter_list|,
name|preg
parameter_list|,
name|errbuf
parameter_list|,
name|errbuf_size
parameter_list|)
name|int
name|errcode
decl_stmt|;
specifier|const
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|char
modifier|*
name|errbuf
decl_stmt|;
name|size_t
name|errbuf_size
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|msg_size
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|errcode
operator|<
literal|0
operator|||
name|errcode
operator|>=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|__re_error_msgid_idx
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|__re_error_msgid_idx
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* Only error codes returned by the rest of the code should be passed        to this routine.  If we are given anything else, or if other regex        code generates an invalid error code, then the program has a bug.        Dump core so we can fix it.  */
name|abort
argument_list|()
expr_stmt|;
name|msg
operator|=
name|gettext
argument_list|(
name|__re_error_msgid
operator|+
name|__re_error_msgid_idx
index|[
name|errcode
index|]
argument_list|)
expr_stmt|;
name|msg_size
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Includes the null.  */
if|if
condition|(
name|BE
argument_list|(
name|errbuf_size
operator|!=
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|msg_size
operator|>
name|errbuf_size
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
name|HAVE_MEMPCPY
operator|||
name|defined
name|_LIBC
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|__mempcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbuf_size
operator|-
literal|1
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbuf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|errbuf
index|[
name|errbuf_size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|memcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
block|}
return|return
name|msg_size
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regerror
argument_list|,
argument|regerror
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_comment
comment|/* This static array is used for the map to single-byte characters when    UTF-8 is used.  Otherwise we would allocate memory just to initialize    it the same all the time.  UTF-8 is the preferred encoding so this is    a worthwhile optimization.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bitset
name|utf8_sb_map
init|=
block|{
comment|/* Set the first 128 bits.  */
if|#
directive|if
name|UINT_MAX
operator|==
literal|0xffffffff
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
else|#
directive|else
error|#
directive|error
literal|"Add case for new unsigned int size"
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|free_dfa_content
parameter_list|(
name|re_dfa_t
modifier|*
name|dfa
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|nodes_len
condition|;
operator|++
name|i
control|)
name|free_token
argument_list|(
name|dfa
operator|->
name|nodes
operator|+
name|i
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|dfa
operator|->
name|nexts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|nodes_len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|dfa
operator|->
name|eclosures
operator|!=
name|NULL
condition|)
name|re_node_set_free
argument_list|(
name|dfa
operator|->
name|eclosures
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|inveclosures
operator|!=
name|NULL
condition|)
name|re_node_set_free
argument_list|(
name|dfa
operator|->
name|inveclosures
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|edests
operator|!=
name|NULL
condition|)
name|re_node_set_free
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|re_free
argument_list|(
name|dfa
operator|->
name|edests
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|dfa
operator|->
name|eclosures
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|dfa
operator|->
name|inveclosures
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|dfa
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|state_table
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|state_hash_mask
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|re_state_table_entry
modifier|*
name|entry
init|=
name|dfa
operator|->
name|state_table
operator|+
name|i
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|entry
operator|->
name|num
condition|;
operator|++
name|j
control|)
block|{
name|re_dfastate_t
modifier|*
name|state
init|=
name|entry
operator|->
name|array
index|[
name|j
index|]
decl_stmt|;
name|free_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|re_free
argument_list|(
name|entry
operator|->
name|array
argument_list|)
expr_stmt|;
block|}
name|re_free
argument_list|(
name|dfa
operator|->
name|state_table
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|sb_char
operator|!=
name|utf8_sb_map
condition|)
name|re_free
argument_list|(
name|dfa
operator|->
name|sb_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|re_free
argument_list|(
name|dfa
operator|->
name|subexp_map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|re_free
argument_list|(
name|dfa
operator|->
name|re_str
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|re_free
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free dynamically allocated space used by PREG.  */
end_comment

begin_function
name|void
name|regfree
parameter_list|(
name|preg
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
name|free_dfa_content
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|re_free
argument_list|(
name|preg
operator|->
name|fastmap
argument_list|)
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|re_free
argument_list|(
name|preg
operator|->
name|translate
argument_list|)
expr_stmt|;
name|preg
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__regfree
argument_list|,
argument|regfree
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with 4.2 BSD regex library.  We don't define    them unless specifically requested.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_REGEX_RE_COMP
operator|||
name|defined
name|_LIBC
end_if

begin_comment
comment|/* BSD has one and only one pattern buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|re_comp_buf
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|_LIBC
comment|/* Make these definitions weak in libc, so POSIX programs can redefine    these names if they don't use our functions, and still use    regcomp/regexec above without link errors.  */
name|weak_function
endif|#
directive|endif
name|re_comp
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|char
modifier|*
name|fastmap
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
return|return
name|gettext
argument_list|(
literal|"No previous regular expression"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|re_comp_buf
operator|.
name|buffer
condition|)
block|{
name|fastmap
operator|=
name|re_comp_buf
operator|.
name|fastmap
expr_stmt|;
name|re_comp_buf
operator|.
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|__regfree
argument_list|(
operator|&
name|re_comp_buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_comp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|re_comp_buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
block|}
if|if
condition|(
name|re_comp_buf
operator|.
name|fastmap
operator|==
name|NULL
condition|)
block|{
name|re_comp_buf
operator|.
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|SBC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_comp_buf
operator|.
name|fastmap
operator|==
name|NULL
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|gettext
argument_list|(
name|__re_error_msgid
operator|+
name|__re_error_msgid_idx
index|[
operator|(
name|int
operator|)
name|REG_ESPACE
index|]
argument_list|)
return|;
block|}
comment|/* Since `re_exec' always passes NULL for the `regs' argument, we      don't need to initialize the pattern buffer fields which affect it.  */
comment|/* Match anchors at newlines.  */
name|re_comp_buf
operator|.
name|newline_anchor
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|re_compile_internal
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|re_syntax_options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
comment|/* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
return|return
operator|(
name|char
operator|*
operator|)
name|gettext
argument_list|(
name|__re_error_msgid
operator|+
name|__re_error_msgid_idx
index|[
operator|(
name|int
operator|)
name|ret
index|]
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|libc_freeres_fn
argument_list|(
argument|free_mem
argument_list|)
end_macro

begin_block
block|{
name|__regfree
argument_list|(
operator|&
name|re_comp_buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _REGEX_RE_COMP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Internal entry point.    Compile the regular expression PATTERN, whose length is LENGTH.    SYNTAX indicate regular expression's syntax.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_compile_internal
parameter_list|(
name|preg
parameter_list|,
name|pattern
parameter_list|,
name|length
parameter_list|,
name|syntax
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|length
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|reg_errcode_t
name|err
init|=
name|REG_NOERROR
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_string_t
name|regexp
decl_stmt|;
comment|/* Initialize the pattern buffer.  */
name|preg
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|syntax
operator|=
name|syntax
expr_stmt|;
name|preg
operator|->
name|not_bol
operator|=
name|preg
operator|->
name|not_eol
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|can_be_null
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
comment|/* Initialize the dfa.  */
name|dfa
operator|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|preg
operator|->
name|allocated
operator|<
sizeof|sizeof
argument_list|(
name|re_dfa_t
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If zero allocated, but buffer is non-null, try to realloc 	 enough space.  This loses if buffer's address is bogus, but 	 that is the user's responsibility.  If ->buffer is NULL this 	 is a simple allocation.  */
name|dfa
operator|=
name|re_realloc
argument_list|(
name|preg
operator|->
name|buffer
argument_list|,
name|re_dfa_t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
name|preg
operator|->
name|allocated
operator|=
sizeof|sizeof
argument_list|(
name|re_dfa_t
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dfa
expr_stmt|;
block|}
name|preg
operator|->
name|used
operator|=
sizeof|sizeof
argument_list|(
name|re_dfa_t
argument_list|)
expr_stmt|;
name|err
operator|=
name|init_dfa
argument_list|(
name|dfa
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free_dfa_content
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
return|return
name|err
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dfa
operator|->
name|re_str
operator|=
name|re_malloc
argument_list|(
name|char
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dfa
operator|->
name|re_str
argument_list|,
name|pattern
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|re_string_construct
argument_list|(
operator|&
name|regexp
argument_list|,
name|pattern
argument_list|,
name|length
argument_list|,
name|preg
operator|->
name|translate
argument_list|,
name|syntax
operator|&
name|RE_ICASE
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_compile_internal_free_return
label|:
name|free_workarea_compile
argument_list|(
name|preg
argument_list|)
expr_stmt|;
name|re_string_destruct
argument_list|(
operator|&
name|regexp
argument_list|)
expr_stmt|;
name|free_dfa_content
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Parse the regular expression, and build a structure tree.  */
name|preg
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
name|dfa
operator|->
name|str_tree
operator|=
name|parse
argument_list|(
operator|&
name|regexp
argument_list|,
name|preg
argument_list|,
name|syntax
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|str_tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|re_compile_internal_free_return
goto|;
comment|/* Analyze the tree and create the nfa.  */
name|err
operator|=
name|analyze
argument_list|(
name|preg
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|re_compile_internal_free_return
goto|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* If possible, do searching in single byte encoding to speed things up.  */
if|if
condition|(
name|dfa
operator|->
name|is_utf8
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_ICASE
operator|)
operator|&&
name|preg
operator|->
name|translate
operator|==
name|NULL
condition|)
name|optimize_utf8
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Then create the initial state of the dfa.  */
name|err
operator|=
name|create_initial_state
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
comment|/* Release work areas.  */
name|free_workarea_compile
argument_list|(
name|preg
argument_list|)
expr_stmt|;
name|re_string_destruct
argument_list|(
operator|&
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free_dfa_content
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Initialize DFA.  We use the length of the regular expression PAT_LEN    as the initial length of some arrays.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|init_dfa
parameter_list|(
name|dfa
parameter_list|,
name|pat_len
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|pat_len
decl_stmt|;
block|{
name|int
name|table_size
decl_stmt|;
ifndef|#
directive|ifndef
name|_LIBC
name|char
modifier|*
name|codeset_name
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|dfa
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_dfa_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Force allocation of str_tree_storage the first time.  */
name|dfa
operator|->
name|str_tree_storage_idx
operator|=
name|BIN_TREE_STORAGE_SIZE
expr_stmt|;
name|dfa
operator|->
name|nodes_alloc
operator|=
name|pat_len
operator|+
literal|1
expr_stmt|;
name|dfa
operator|->
name|nodes
operator|=
name|re_malloc
argument_list|(
name|re_token_t
argument_list|,
name|dfa
operator|->
name|nodes_alloc
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|states_alloc
operator|=
name|pat_len
operator|+
literal|1
expr_stmt|;
comment|/*  table_size = 2 ^ ceil(log pat_len) */
for|for
control|(
name|table_size
operator|=
literal|1
init|;
name|table_size
operator|>
literal|0
condition|;
name|table_size
operator|<<=
literal|1
control|)
if|if
condition|(
name|table_size
operator|>
name|pat_len
condition|)
break|break;
name|dfa
operator|->
name|state_table
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_state_table_entry
argument_list|)
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|state_hash_mask
operator|=
name|table_size
operator|-
literal|1
expr_stmt|;
name|dfa
operator|->
name|mb_cur_max
operator|=
name|MB_CUR_MAX
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|==
literal|6
operator|&&
name|strcmp
argument_list|(
name|_NL_CURRENT
argument_list|(
name|LC_CTYPE
argument_list|,
name|_NL_CTYPE_CODESET_NAME
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|dfa
operator|->
name|is_utf8
operator|=
literal|1
expr_stmt|;
name|dfa
operator|->
name|map_notascii
operator|=
operator|(
name|_NL_CURRENT_WORD
argument_list|(
name|LC_CTYPE
argument_list|,
name|_NL_CTYPE_MAP_TO_NONASCII
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_CODESET
name|codeset_name
operator|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
expr_stmt|;
else|#
directive|else
name|codeset_name
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeset_name
operator|==
name|NULL
operator|||
name|codeset_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|codeset_name
operator|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeset_name
operator|==
name|NULL
operator|||
name|codeset_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|codeset_name
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeset_name
operator|==
name|NULL
condition|)
name|codeset_name
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|codeset_name
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
name|codeset_name
operator|=
name|strchr
argument_list|(
name|codeset_name
argument_list|,
literal|'.'
argument_list|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcasecmp
argument_list|(
name|codeset_name
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|codeset_name
argument_list|,
literal|"UTF8"
argument_list|)
operator|==
literal|0
condition|)
name|dfa
operator|->
name|is_utf8
operator|=
literal|1
expr_stmt|;
comment|/* We check exhaustively in the loop below if this charset is a      superset of ASCII.  */
name|dfa
operator|->
name|map_notascii
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dfa
operator|->
name|is_utf8
condition|)
name|dfa
operator|->
name|sb_char
operator|=
operator|(
name|re_bitset_ptr_t
operator|)
name|utf8_sb_map
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ch
decl_stmt|;
name|dfa
operator|->
name|sb_char
operator|=
operator|(
name|re_bitset_ptr_t
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitset
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|sb_char
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
comment|/* Clear all bits by, then set those corresponding to single 	     byte chars.  */
name|bitset_empty
argument_list|(
name|dfa
operator|->
name|sb_char
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ch
operator|=
literal|0
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UINT_BITS
condition|;
operator|++
name|j
operator|,
operator|++
name|ch
control|)
block|{
name|wchar_t
name|wch
init|=
name|__btowc
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|wch
operator|!=
name|WEOF
condition|)
name|dfa
operator|->
name|sb_char
index|[
name|i
index|]
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
ifndef|#
directive|ifndef
name|_LIBC
if|if
condition|(
name|isascii
argument_list|(
name|ch
argument_list|)
operator|&&
name|wch
operator|!=
operator|(
name|wchar_t
operator|)
name|ch
condition|)
name|dfa
operator|->
name|map_notascii
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|nodes
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|state_table
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Initialize WORD_CHAR table, which indicate which character is    "word".  In this case "word" means that it is the word construction    character used by some operators like "\<", "\>", etc.  */
end_comment

begin_function
specifier|static
name|void
name|init_word_char
parameter_list|(
name|dfa
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ch
decl_stmt|;
name|dfa
operator|->
name|word_ops_used
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ch
operator|=
literal|0
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UINT_BITS
condition|;
operator|++
name|j
operator|,
operator|++
name|ch
control|)
if|if
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'_'
condition|)
name|dfa
operator|->
name|word_char
index|[
name|i
index|]
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the work area which are only used while compiling.  */
end_comment

begin_function
specifier|static
name|void
name|free_workarea_compile
parameter_list|(
name|preg
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|bin_tree_storage_t
modifier|*
name|storage
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|storage
operator|=
name|dfa
operator|->
name|str_tree_storage
init|;
name|storage
condition|;
name|storage
operator|=
name|next
control|)
block|{
name|next
operator|=
name|storage
operator|->
name|next
expr_stmt|;
name|re_free
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
name|dfa
operator|->
name|str_tree_storage
operator|=
name|NULL
expr_stmt|;
name|dfa
operator|->
name|str_tree_storage_idx
operator|=
name|BIN_TREE_STORAGE_SIZE
expr_stmt|;
name|dfa
operator|->
name|str_tree
operator|=
name|NULL
expr_stmt|;
name|re_free
argument_list|(
name|dfa
operator|->
name|org_indices
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|org_indices
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create initial states for all contexts.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|create_initial_state
parameter_list|(
name|dfa
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|int
name|first
decl_stmt|,
name|i
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|re_node_set
name|init_nodes
decl_stmt|;
comment|/* Initial states have the epsilon closure of the node which is      the first node of the regular expression.  */
name|first
operator|=
name|dfa
operator|->
name|str_tree
operator|->
name|first
operator|->
name|node_idx
expr_stmt|;
name|dfa
operator|->
name|init_node
operator|=
name|first
expr_stmt|;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|init_nodes
argument_list|,
name|dfa
operator|->
name|eclosures
operator|+
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* The back-references which are in initial states can epsilon transit,      since in this case all of the subexpressions can be null.      Then we add epsilon closures of the nodes which are the next nodes of      the back-references.  */
if|if
condition|(
name|dfa
operator|->
name|nbackref
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|init_nodes
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|int
name|node_idx
init|=
name|init_nodes
operator|.
name|elems
index|[
name|i
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|node_idx
index|]
operator|.
name|type
decl_stmt|;
name|int
name|clexp_idx
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|OP_BACK_REF
condition|)
continue|continue;
for|for
control|(
name|clexp_idx
operator|=
literal|0
init|;
name|clexp_idx
operator|<
name|init_nodes
operator|.
name|nelem
condition|;
operator|++
name|clexp_idx
control|)
block|{
name|re_token_t
modifier|*
name|clexp_node
decl_stmt|;
name|clexp_node
operator|=
name|dfa
operator|->
name|nodes
operator|+
name|init_nodes
operator|.
name|elems
index|[
name|clexp_idx
index|]
expr_stmt|;
if|if
condition|(
name|clexp_node
operator|->
name|type
operator|==
name|OP_CLOSE_SUBEXP
operator|&&
name|clexp_node
operator|->
name|opr
operator|.
name|idx
operator|==
name|dfa
operator|->
name|nodes
index|[
name|node_idx
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
break|break;
block|}
if|if
condition|(
name|clexp_idx
operator|==
name|init_nodes
operator|.
name|nelem
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|OP_BACK_REF
condition|)
block|{
name|int
name|dest_idx
init|=
name|dfa
operator|->
name|edests
index|[
name|node_idx
index|]
operator|.
name|elems
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|re_node_set_contains
argument_list|(
operator|&
name|init_nodes
argument_list|,
name|dest_idx
argument_list|)
condition|)
block|{
name|re_node_set_merge
argument_list|(
operator|&
name|init_nodes
argument_list|,
name|dfa
operator|->
name|eclosures
operator|+
name|dest_idx
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* It must be the first time to invoke acquire_state.  */
name|dfa
operator|->
name|init_state
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|init_nodes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't check ERR here, since the initial state must not be NULL.  */
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|init_state
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|dfa
operator|->
name|init_state
operator|->
name|has_constraint
condition|)
block|{
name|dfa
operator|->
name|init_state_word
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|init_nodes
argument_list|,
name|CONTEXT_WORD
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|init_state_nl
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|init_nodes
argument_list|,
name|CONTEXT_NEWLINE
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|init_state_begbuf
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|init_nodes
argument_list|,
name|CONTEXT_NEWLINE
operator||
name|CONTEXT_BEGBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|init_state_word
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|init_state_nl
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|init_state_begbuf
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
else|else
name|dfa
operator|->
name|init_state_word
operator|=
name|dfa
operator|->
name|init_state_nl
operator|=
name|dfa
operator|->
name|init_state_begbuf
operator|=
name|dfa
operator|->
name|init_state
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|init_nodes
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_comment
comment|/* If it is possible to do searching in single byte encoding instead of UTF-8    to speed things up, set dfa->mb_cur_max to 1, clear is_utf8 and change    DFA nodes where needed.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_utf8
parameter_list|(
name|dfa
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|int
name|node
decl_stmt|,
name|i
decl_stmt|,
name|mb_chars
init|=
literal|0
decl_stmt|,
name|has_period
init|=
literal|0
decl_stmt|;
for|for
control|(
name|node
operator|=
literal|0
init|;
name|node
operator|<
name|dfa
operator|->
name|nodes_len
condition|;
operator|++
name|node
control|)
switch|switch
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
condition|)
block|{
case|case
name|CHARACTER
case|:
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|c
operator|>=
literal|0x80
condition|)
name|mb_chars
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ANCHOR
case|:
switch|switch
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
block|{
case|case
name|LINE_FIRST
case|:
case|case
name|LINE_LAST
case|:
case|case
name|BUF_FIRST
case|:
case|case
name|BUF_LAST
case|:
break|break;
default|default:
comment|/* Word anchors etc. cannot be handled.  */
return|return;
block|}
break|break;
case|case
name|OP_PERIOD
case|:
name|has_period
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_BACK_REF
case|:
case|case
name|OP_ALT
case|:
case|case
name|END_OF_RE
case|:
case|case
name|OP_DUP_ASTERISK
case|:
case|case
name|OP_OPEN_SUBEXP
case|:
case|case
name|OP_CLOSE_SUBEXP
case|:
break|break;
case|case
name|COMPLEX_BRACKET
case|:
return|return;
case|case
name|SIMPLE_BRACKET
case|:
comment|/* Just double check.  */
for|for
control|(
name|i
operator|=
literal|0x80
operator|/
name|UINT_BITS
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|sbcset
index|[
name|i
index|]
condition|)
return|return;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mb_chars
operator|||
name|has_period
condition|)
for|for
control|(
name|node
operator|=
literal|0
init|;
name|node
operator|<
name|dfa
operator|->
name|nodes_len
condition|;
operator|++
name|node
control|)
block|{
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
operator|==
name|CHARACTER
operator|&&
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|c
operator|>=
literal|0x80
condition|)
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|mb_partial
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
operator|==
name|OP_PERIOD
condition|)
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
operator|=
name|OP_UTF8_PERIOD
expr_stmt|;
block|}
comment|/* The search can be in single byte locale.  */
name|dfa
operator|->
name|mb_cur_max
operator|=
literal|1
expr_stmt|;
name|dfa
operator|->
name|is_utf8
operator|=
literal|0
expr_stmt|;
name|dfa
operator|->
name|has_mb_node
operator|=
name|dfa
operator|->
name|nbackref
operator|>
literal|0
operator|||
name|has_period
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Analyze the structure tree, and calculate "first", "next", "edest",    "eclosure", and "inveclosure".  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|analyze
parameter_list|(
name|preg
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* Allocate arrays.  */
name|dfa
operator|->
name|nexts
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|dfa
operator|->
name|nodes_alloc
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|org_indices
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|dfa
operator|->
name|nodes_alloc
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|edests
operator|=
name|re_malloc
argument_list|(
name|re_node_set
argument_list|,
name|dfa
operator|->
name|nodes_alloc
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|eclosures
operator|=
name|re_malloc
argument_list|(
name|re_node_set
argument_list|,
name|dfa
operator|->
name|nodes_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|nexts
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|org_indices
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|edests
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|eclosures
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|dfa
operator|->
name|subexp_map
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|preg
operator|->
name|re_nsub
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|subexp_map
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preg
operator|->
name|re_nsub
condition|;
name|i
operator|++
control|)
name|dfa
operator|->
name|subexp_map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|preorder
argument_list|(
name|dfa
operator|->
name|str_tree
argument_list|,
name|optimize_subexps
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preg
operator|->
name|re_nsub
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dfa
operator|->
name|subexp_map
index|[
name|i
index|]
operator|!=
name|i
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|preg
operator|->
name|re_nsub
condition|)
block|{
name|free
argument_list|(
name|dfa
operator|->
name|subexp_map
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|subexp_map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|postorder
argument_list|(
name|dfa
operator|->
name|str_tree
argument_list|,
name|lower_subexps
argument_list|,
name|preg
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|postorder
argument_list|(
name|dfa
operator|->
name|str_tree
argument_list|,
name|calc_first
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
name|preorder
argument_list|(
name|dfa
operator|->
name|str_tree
argument_list|,
name|calc_next
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
name|ret
operator|=
name|preorder
argument_list|(
name|dfa
operator|->
name|str_tree
argument_list|,
name|link_nfa_nodes
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|calc_eclosure
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
comment|/* We only need this during the prune_impossible_nodes pass in regexec.c;      skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */
if|if
condition|(
operator|(
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|preg
operator|->
name|re_nsub
operator|>
literal|0
operator|&&
name|dfa
operator|->
name|has_plural_match
operator|)
operator|||
name|dfa
operator|->
name|nbackref
condition|)
block|{
name|dfa
operator|->
name|inveclosures
operator|=
name|re_malloc
argument_list|(
name|re_node_set
argument_list|,
name|dfa
operator|->
name|nodes_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|inveclosures
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|ret
operator|=
name|calc_inveclosure
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Our parse trees are very unbalanced, so we cannot use a stack to    implement parse tree visits.  Instead, we use parent pointers and    some hairy code in these two functions.  */
end_comment

begin_function_decl
specifier|static
name|reg_errcode_t
name|postorder
parameter_list|(
name|root
parameter_list|,
name|fn
parameter_list|,
name|extra
parameter_list|)
name|bin_tree_t
modifier|*
name|root
decl_stmt|;
function_decl|reg_errcode_t
parameter_list|(
function_decl|fn
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bin_tree_t
modifier|*
parameter_list|)
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|void
modifier|*
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bin_tree_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|node
operator|=
name|root
init|;
condition|;
control|)
block|{
comment|/* Descend down the tree, preferably to the left (or to the right 	 if that's the only child).  */
while|while
condition|(
name|node
operator|->
name|left
operator|||
name|node
operator|->
name|right
condition|)
if|if
condition|(
name|node
operator|->
name|left
condition|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
else|else
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
do|do
block|{
name|reg_errcode_t
name|err
init|=
name|fn
argument_list|(
name|extra
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|node
operator|->
name|parent
operator|==
name|NULL
condition|)
return|return
name|REG_NOERROR
return|;
name|prev
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
block|}
comment|/* Go up while we have a node that is reached from the right.  */
do|while
condition|(
name|node
operator|->
name|right
operator|==
name|prev
operator|||
name|node
operator|->
name|right
operator|==
name|NULL
condition|)
do|;
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
block|}
block|}
end_block

begin_function_decl
specifier|static
name|reg_errcode_t
name|preorder
parameter_list|(
name|root
parameter_list|,
name|fn
parameter_list|,
name|extra
parameter_list|)
name|bin_tree_t
modifier|*
name|root
decl_stmt|;
function_decl|reg_errcode_t
parameter_list|(
function_decl|fn
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bin_tree_t
modifier|*
parameter_list|)
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|void
modifier|*
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|root
init|;
condition|;
control|)
block|{
name|reg_errcode_t
name|err
init|=
name|fn
argument_list|(
name|extra
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* Go to the left node, or up and to the right.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
else|else
block|{
name|bin_tree_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|node
operator|->
name|right
operator|==
name|prev
operator|||
name|node
operator|->
name|right
operator|==
name|NULL
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|REG_NOERROR
return|;
block|}
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Optimization pass: if a SUBEXP is entirely contained, strip it and tell    re_search_internal to map the inner one's opr.idx to this one's.  Adjust    backreferences as well.  Requires a preorder visit.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|optimize_subexps
parameter_list|(
name|extra
parameter_list|,
name|node
parameter_list|)
name|void
modifier|*
name|extra
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|extra
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|token
operator|.
name|type
operator|==
name|OP_BACK_REF
operator|&&
name|dfa
operator|->
name|subexp_map
condition|)
block|{
name|int
name|idx
init|=
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
decl_stmt|;
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|=
name|dfa
operator|->
name|subexp_map
index|[
name|idx
index|]
expr_stmt|;
name|dfa
operator|->
name|used_bkref_map
operator||=
literal|1
operator|<<
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|token
operator|.
name|type
operator|==
name|SUBEXP
operator|&&
name|node
operator|->
name|left
operator|&&
name|node
operator|->
name|left
operator|->
name|token
operator|.
name|type
operator|==
name|SUBEXP
condition|)
block|{
name|int
name|other_idx
init|=
name|node
operator|->
name|left
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
decl_stmt|;
name|node
operator|->
name|left
operator|=
name|node
operator|->
name|left
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|left
condition|)
name|node
operator|->
name|left
operator|->
name|parent
operator|=
name|node
expr_stmt|;
name|dfa
operator|->
name|subexp_map
index|[
name|other_idx
index|]
operator|=
name|dfa
operator|->
name|subexp_map
index|[
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|other_idx
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|dfa
operator|->
name|used_bkref_map
argument_list|)
condition|)
name|dfa
operator|->
name|used_bkref_map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|other_idx
operator|)
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Lowering pass: Turn each SUBEXP node into the appropriate concatenation    of OP_OPEN_SUBEXP, the body of the SUBEXP (if any) and OP_CLOSE_SUBEXP.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|lower_subexps
parameter_list|(
name|extra
parameter_list|,
name|node
parameter_list|)
name|void
modifier|*
name|extra
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
name|regex_t
modifier|*
name|preg
init|=
operator|(
name|regex_t
operator|*
operator|)
name|extra
decl_stmt|;
name|reg_errcode_t
name|err
init|=
name|REG_NOERROR
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|left
operator|&&
name|node
operator|->
name|left
operator|->
name|token
operator|.
name|type
operator|==
name|SUBEXP
condition|)
block|{
name|node
operator|->
name|left
operator|=
name|lower_subexp
argument_list|(
operator|&
name|err
argument_list|,
name|preg
argument_list|,
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|left
condition|)
name|node
operator|->
name|left
operator|->
name|parent
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|right
operator|&&
name|node
operator|->
name|right
operator|->
name|token
operator|.
name|type
operator|==
name|SUBEXP
condition|)
block|{
name|node
operator|->
name|right
operator|=
name|lower_subexp
argument_list|(
operator|&
name|err
argument_list|,
name|preg
argument_list|,
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
condition|)
name|node
operator|->
name|right
operator|->
name|parent
operator|=
name|node
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|lower_subexp
parameter_list|(
name|err
parameter_list|,
name|preg
parameter_list|,
name|node
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|bin_tree_t
modifier|*
name|body
init|=
name|node
operator|->
name|left
decl_stmt|;
name|bin_tree_t
modifier|*
name|op
decl_stmt|,
modifier|*
name|cls
decl_stmt|,
modifier|*
name|tree1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
if|if
condition|(
name|preg
operator|->
name|no_sub
comment|/* We do not optimize empty subexpressions, because otherwise we may 	 have bad CONCAT nodes with NULL children.  This is obviously not 	 very common, so we do not lose much.  An example that triggers 	 this case is the sed "script" /\(\)/x.  */
operator|&&
name|node
operator|->
name|left
operator|!=
name|NULL
operator|&&
operator|(
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|>=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|dfa
operator|->
name|used_bkref_map
argument_list|)
operator|||
operator|!
operator|(
name|dfa
operator|->
name|used_bkref_map
operator|&
operator|(
literal|1
operator|<<
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|)
operator|)
operator|)
condition|)
return|return
name|node
operator|->
name|left
return|;
comment|/* Convert the SUBEXP node to the concatenation of an      OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */
name|op
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|OP_OPEN_SUBEXP
argument_list|)
expr_stmt|;
name|cls
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|OP_CLOSE_SUBEXP
argument_list|)
expr_stmt|;
name|tree1
operator|=
name|body
condition|?
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|body
argument_list|,
name|cls
argument_list|,
name|CONCAT
argument_list|)
else|:
name|cls
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|op
argument_list|,
name|tree1
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
operator|||
name|tree1
operator|==
name|NULL
operator|||
name|op
operator|==
name|NULL
operator|||
name|cls
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|op
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|=
name|cls
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|=
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
expr_stmt|;
name|op
operator|->
name|token
operator|.
name|opt_subexp
operator|=
name|cls
operator|->
name|token
operator|.
name|opt_subexp
operator|=
name|node
operator|->
name|token
operator|.
name|opt_subexp
expr_stmt|;
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* Pass 1 in building the NFA: compute FIRST and create unlinked automaton    nodes.  Requires a postorder visit.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|calc_first
parameter_list|(
name|extra
parameter_list|,
name|node
parameter_list|)
name|void
modifier|*
name|extra
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|extra
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|token
operator|.
name|type
operator|==
name|CONCAT
condition|)
block|{
name|node
operator|->
name|first
operator|=
name|node
operator|->
name|left
operator|->
name|first
expr_stmt|;
name|node
operator|->
name|node_idx
operator|=
name|node
operator|->
name|left
operator|->
name|node_idx
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|first
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|node_idx
operator|=
name|re_dfa_add_node
argument_list|(
name|dfa
argument_list|,
name|node
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|node
operator|->
name|node_idx
operator|==
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Pass 2: compute NEXT on the tree.  Preorder visit.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|calc_next
parameter_list|(
name|extra
parameter_list|,
name|node
parameter_list|)
name|void
modifier|*
name|extra
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
switch|switch
condition|(
name|node
operator|->
name|token
operator|.
name|type
condition|)
block|{
case|case
name|OP_DUP_ASTERISK
case|:
name|node
operator|->
name|left
operator|->
name|next
operator|=
name|node
expr_stmt|;
break|break;
case|case
name|CONCAT
case|:
name|node
operator|->
name|left
operator|->
name|next
operator|=
name|node
operator|->
name|right
operator|->
name|first
expr_stmt|;
name|node
operator|->
name|right
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|node
operator|->
name|left
condition|)
name|node
operator|->
name|left
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
condition|)
name|node
operator|->
name|right
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
break|break;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Pass 3: link all DFA nodes to their NEXT node (any order will do).  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|link_nfa_nodes
parameter_list|(
name|extra
parameter_list|,
name|node
parameter_list|)
name|void
modifier|*
name|extra
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|extra
decl_stmt|;
name|int
name|idx
init|=
name|node
operator|->
name|node_idx
decl_stmt|;
name|reg_errcode_t
name|err
init|=
name|REG_NOERROR
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|token
operator|.
name|type
condition|)
block|{
case|case
name|CONCAT
case|:
break|break;
case|case
name|END_OF_RE
case|:
name|assert
argument_list|(
name|node
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DUP_ASTERISK
case|:
case|case
name|OP_ALT
case|:
block|{
name|int
name|left
decl_stmt|,
name|right
decl_stmt|;
name|dfa
operator|->
name|has_plural_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|left
operator|=
name|node
operator|->
name|left
operator|->
name|first
operator|->
name|node_idx
expr_stmt|;
else|else
name|left
operator|=
name|node
operator|->
name|next
operator|->
name|node_idx
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|right
operator|=
name|node
operator|->
name|right
operator|->
name|first
operator|->
name|node_idx
expr_stmt|;
else|else
name|right
operator|=
name|node
operator|->
name|next
operator|->
name|node_idx
expr_stmt|;
name|assert
argument_list|(
name|left
operator|>
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|right
operator|>
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_node_set_init_2
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|idx
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANCHOR
case|:
case|case
name|OP_OPEN_SUBEXP
case|:
case|case
name|OP_CLOSE_SUBEXP
case|:
name|err
operator|=
name|re_node_set_init_1
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|idx
argument_list|,
name|node
operator|->
name|next
operator|->
name|node_idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BACK_REF
case|:
name|dfa
operator|->
name|nexts
index|[
name|idx
index|]
operator|=
name|node
operator|->
name|next
operator|->
name|node_idx
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|token
operator|.
name|type
operator|==
name|OP_BACK_REF
condition|)
name|re_node_set_init_1
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|idx
argument_list|,
name|dfa
operator|->
name|nexts
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
operator|!
name|IS_EPSILON_NODE
argument_list|(
name|node
operator|->
name|token
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|nexts
index|[
name|idx
index|]
operator|=
name|node
operator|->
name|next
operator|->
name|node_idx
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Duplicate the epsilon closure of the node ROOT_NODE.    Note that duplicated nodes have constraint INIT_CONSTRAINT in addition    to their own constraint.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|duplicate_node_closure
parameter_list|(
name|dfa
parameter_list|,
name|top_org_node
parameter_list|,
name|top_clone_node
parameter_list|,
name|root_node
parameter_list|,
name|init_constraint
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|top_org_node
decl_stmt|,
name|top_clone_node
decl_stmt|,
name|root_node
decl_stmt|;
name|unsigned
name|int
name|init_constraint
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|org_node
decl_stmt|,
name|clone_node
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|constraint
init|=
name|init_constraint
decl_stmt|;
for|for
control|(
name|org_node
operator|=
name|top_org_node
operator|,
name|clone_node
operator|=
name|top_clone_node
init|;
condition|;
control|)
block|{
name|int
name|org_dest
decl_stmt|,
name|clone_dest
decl_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|org_node
index|]
operator|.
name|type
operator|==
name|OP_BACK_REF
condition|)
block|{
comment|/* If the back reference epsilon-transit, its destination must 	     also have the constraint.  Then duplicate the epsilon closure 	     of the destination of the back reference, and store it in 	     edests of the back reference.  */
name|org_dest
operator|=
name|dfa
operator|->
name|nexts
index|[
name|org_node
index|]
expr_stmt|;
name|re_node_set_empty
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|)
expr_stmt|;
name|err
operator|=
name|duplicate_node
argument_list|(
operator|&
name|clone_dest
argument_list|,
name|dfa
argument_list|,
name|org_dest
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|dfa
operator|->
name|nexts
index|[
name|clone_node
index|]
operator|=
name|dfa
operator|->
name|nexts
index|[
name|org_node
index|]
expr_stmt|;
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|,
name|clone_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
elseif|else
if|if
condition|(
name|dfa
operator|->
name|edests
index|[
name|org_node
index|]
operator|.
name|nelem
operator|==
literal|0
condition|)
block|{
comment|/* In case of the node can't epsilon-transit, don't duplicate the 	     destination and store the original destination as the 	     destination of the node.  */
name|dfa
operator|->
name|nexts
index|[
name|clone_node
index|]
operator|=
name|dfa
operator|->
name|nexts
index|[
name|org_node
index|]
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|dfa
operator|->
name|edests
index|[
name|org_node
index|]
operator|.
name|nelem
operator|==
literal|1
condition|)
block|{
comment|/* In case of the node can epsilon-transit, and it has only one 	     destination.  */
name|org_dest
operator|=
name|dfa
operator|->
name|edests
index|[
name|org_node
index|]
operator|.
name|elems
index|[
literal|0
index|]
expr_stmt|;
name|re_node_set_empty
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|org_node
index|]
operator|.
name|type
operator|==
name|ANCHOR
condition|)
block|{
comment|/* In case of the node has another constraint, append it.  */
if|if
condition|(
name|org_node
operator|==
name|root_node
operator|&&
name|clone_node
operator|!=
name|org_node
condition|)
block|{
comment|/* ...but if the node is root_node itself, it means the 		     epsilon closure have a loop, then tie it to the 		     destination of the root_node.  */
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|,
name|org_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
break|break;
block|}
name|constraint
operator||=
name|dfa
operator|->
name|nodes
index|[
name|org_node
index|]
operator|.
name|opr
operator|.
name|ctx_type
expr_stmt|;
block|}
name|err
operator|=
name|duplicate_node
argument_list|(
operator|&
name|clone_dest
argument_list|,
name|dfa
argument_list|,
name|org_dest
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|,
name|clone_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
else|else
comment|/* dfa->edests[org_node].nelem == 2 */
block|{
comment|/* In case of the node can epsilon-transit, and it has two 	     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */
name|org_dest
operator|=
name|dfa
operator|->
name|edests
index|[
name|org_node
index|]
operator|.
name|elems
index|[
literal|0
index|]
expr_stmt|;
name|re_node_set_empty
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|)
expr_stmt|;
comment|/* Search for a duplicated node which satisfies the constraint.  */
name|clone_dest
operator|=
name|search_duplicated_node
argument_list|(
name|dfa
argument_list|,
name|org_dest
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone_dest
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no such a duplicated node, create a new one.  */
name|err
operator|=
name|duplicate_node
argument_list|(
operator|&
name|clone_dest
argument_list|,
name|dfa
argument_list|,
name|org_dest
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|,
name|clone_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|err
operator|=
name|duplicate_node_closure
argument_list|(
name|dfa
argument_list|,
name|org_dest
argument_list|,
name|clone_dest
argument_list|,
name|root_node
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
else|else
block|{
comment|/* There are a duplicated node which satisfy the constraint, 		 use it to avoid infinite loop.  */
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|,
name|clone_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
name|org_dest
operator|=
name|dfa
operator|->
name|edests
index|[
name|org_node
index|]
operator|.
name|elems
index|[
literal|1
index|]
expr_stmt|;
name|err
operator|=
name|duplicate_node
argument_list|(
operator|&
name|clone_dest
argument_list|,
name|dfa
argument_list|,
name|org_dest
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|clone_node
argument_list|,
name|clone_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
name|org_node
operator|=
name|org_dest
expr_stmt|;
name|clone_node
operator|=
name|clone_dest
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Search for a node which is duplicated from the node ORG_NODE, and    satisfies the constraint CONSTRAINT.  */
end_comment

begin_function
specifier|static
name|int
name|search_duplicated_node
parameter_list|(
name|dfa
parameter_list|,
name|org_node
parameter_list|,
name|constraint
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|org_node
decl_stmt|;
name|unsigned
name|int
name|constraint
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|dfa
operator|->
name|nodes_len
operator|-
literal|1
init|;
name|dfa
operator|->
name|nodes
index|[
name|idx
index|]
operator|.
name|duplicated
operator|&&
name|idx
operator|>
literal|0
condition|;
operator|--
name|idx
control|)
block|{
if|if
condition|(
name|org_node
operator|==
name|dfa
operator|->
name|org_indices
index|[
name|idx
index|]
operator|&&
name|constraint
operator|==
name|dfa
operator|->
name|nodes
index|[
name|idx
index|]
operator|.
name|constraint
condition|)
return|return
name|idx
return|;
comment|/* Found.  */
block|}
return|return
operator|-
literal|1
return|;
comment|/* Not found.  */
block|}
end_function

begin_comment
comment|/* Duplicate the node whose index is ORG_IDX and set the constraint CONSTRAINT.    The new index will be stored in NEW_IDX and return REG_NOERROR if succeeded,    otherwise return the error code.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|duplicate_node
parameter_list|(
name|new_idx
parameter_list|,
name|dfa
parameter_list|,
name|org_idx
parameter_list|,
name|constraint
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
modifier|*
name|new_idx
decl_stmt|,
name|org_idx
decl_stmt|;
name|unsigned
name|int
name|constraint
decl_stmt|;
block|{
name|int
name|dup_idx
init|=
name|re_dfa_add_node
argument_list|(
name|dfa
argument_list|,
name|dfa
operator|->
name|nodes
index|[
name|org_idx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dup_idx
operator|==
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|dfa
operator|->
name|nodes
index|[
name|dup_idx
index|]
operator|.
name|constraint
operator|=
name|constraint
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|org_idx
index|]
operator|.
name|type
operator|==
name|ANCHOR
condition|)
name|dfa
operator|->
name|nodes
index|[
name|dup_idx
index|]
operator|.
name|constraint
operator||=
name|dfa
operator|->
name|nodes
index|[
name|org_idx
index|]
operator|.
name|opr
operator|.
name|ctx_type
expr_stmt|;
name|dfa
operator|->
name|nodes
index|[
name|dup_idx
index|]
operator|.
name|duplicated
operator|=
literal|1
expr_stmt|;
comment|/* Store the index of the original node.  */
name|dfa
operator|->
name|org_indices
index|[
name|dup_idx
index|]
operator|=
name|org_idx
expr_stmt|;
operator|*
name|new_idx
operator|=
name|dup_idx
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|calc_inveclosure
parameter_list|(
name|dfa
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|int
name|src
decl_stmt|,
name|idx
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|dfa
operator|->
name|nodes_len
condition|;
operator|++
name|idx
control|)
name|re_node_set_init_empty
argument_list|(
name|dfa
operator|->
name|inveclosures
operator|+
name|idx
argument_list|)
expr_stmt|;
for|for
control|(
name|src
operator|=
literal|0
init|;
name|src
operator|<
name|dfa
operator|->
name|nodes_len
condition|;
operator|++
name|src
control|)
block|{
name|int
modifier|*
name|elems
init|=
name|dfa
operator|->
name|eclosures
index|[
name|src
index|]
operator|.
name|elems
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|dfa
operator|->
name|eclosures
index|[
name|src
index|]
operator|.
name|nelem
condition|;
operator|++
name|idx
control|)
block|{
name|ret
operator|=
name|re_node_set_insert_last
argument_list|(
name|dfa
operator|->
name|inveclosures
operator|+
name|elems
index|[
name|idx
index|]
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|==
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Calculate "eclosure" for all the node in DFA.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|calc_eclosure
parameter_list|(
name|dfa
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|int
name|node_idx
decl_stmt|,
name|incomplete
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|dfa
operator|->
name|nodes_len
operator|>
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|incomplete
operator|=
literal|0
expr_stmt|;
comment|/* For each nodes, calculate epsilon closure.  */
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
condition|;
operator|++
name|node_idx
control|)
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|re_node_set
name|eclosure_elem
decl_stmt|;
if|if
condition|(
name|node_idx
operator|==
name|dfa
operator|->
name|nodes_len
condition|)
block|{
if|if
condition|(
operator|!
name|incomplete
condition|)
break|break;
name|incomplete
operator|=
literal|0
expr_stmt|;
name|node_idx
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|dfa
operator|->
name|eclosures
index|[
name|node_idx
index|]
operator|.
name|nelem
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we have already calculated, skip it.  */
if|if
condition|(
name|dfa
operator|->
name|eclosures
index|[
name|node_idx
index|]
operator|.
name|nelem
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Calculate epsilon closure of `node_idx'.  */
name|err
operator|=
name|calc_eclosure_iter
argument_list|(
operator|&
name|eclosure_elem
argument_list|,
name|dfa
argument_list|,
name|node_idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|dfa
operator|->
name|eclosures
index|[
name|node_idx
index|]
operator|.
name|nelem
operator|==
literal|0
condition|)
block|{
name|incomplete
operator|=
literal|1
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|eclosure_elem
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Calculate epsilon closure of NODE.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|calc_eclosure_iter
parameter_list|(
name|new_set
parameter_list|,
name|dfa
parameter_list|,
name|node
parameter_list|,
name|root
parameter_list|)
name|re_node_set
modifier|*
name|new_set
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|node
decl_stmt|,
name|root
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|unsigned
name|int
name|constraint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|incomplete
decl_stmt|;
name|re_node_set
name|eclosure
decl_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|re_node_set_alloc
argument_list|(
operator|&
name|eclosure
argument_list|,
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|nelem
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* This indicates that we are calculating this node now.      We reference this value to avoid infinite loop.  */
name|dfa
operator|->
name|eclosures
index|[
name|node
index|]
operator|.
name|nelem
operator|=
operator|-
literal|1
expr_stmt|;
name|constraint
operator|=
operator|(
operator|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
operator|==
name|ANCHOR
operator|)
condition|?
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|ctx_type
else|:
literal|0
operator|)
expr_stmt|;
comment|/* If the current node has constraints, duplicate all nodes.      Since they must inherit the constraints.  */
if|if
condition|(
name|constraint
operator|&&
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|nelem
operator|&&
operator|!
name|dfa
operator|->
name|nodes
index|[
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|elems
index|[
literal|0
index|]
index|]
operator|.
name|duplicated
condition|)
block|{
name|int
name|org_node
decl_stmt|,
name|cur_node
decl_stmt|;
name|org_node
operator|=
name|cur_node
operator|=
name|node
expr_stmt|;
name|err
operator|=
name|duplicate_node_closure
argument_list|(
name|dfa
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
comment|/* Expand each epsilon destination nodes.  */
if|if
condition|(
name|IS_EPSILON_NODE
argument_list|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|re_node_set
name|eclosure_elem
decl_stmt|;
name|int
name|edest
init|=
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|elems
index|[
name|i
index|]
decl_stmt|;
comment|/* If calculating the epsilon closure of `edest' is in progress, 	   return intermediate result.  */
if|if
condition|(
name|dfa
operator|->
name|eclosures
index|[
name|edest
index|]
operator|.
name|nelem
operator|==
operator|-
literal|1
condition|)
block|{
name|incomplete
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* If we haven't calculated the epsilon closure of `edest' yet, 	   calculate now. Otherwise use calculated epsilon closure.  */
if|if
condition|(
name|dfa
operator|->
name|eclosures
index|[
name|edest
index|]
operator|.
name|nelem
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|calc_eclosure_iter
argument_list|(
operator|&
name|eclosure_elem
argument_list|,
name|dfa
argument_list|,
name|edest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
else|else
name|eclosure_elem
operator|=
name|dfa
operator|->
name|eclosures
index|[
name|edest
index|]
expr_stmt|;
comment|/* Merge the epsilon closure of `edest'.  */
name|re_node_set_merge
argument_list|(
operator|&
name|eclosure
argument_list|,
operator|&
name|eclosure_elem
argument_list|)
expr_stmt|;
comment|/* If the epsilon closure of `edest' is incomplete, 	   the epsilon closure of this node is also incomplete.  */
if|if
condition|(
name|dfa
operator|->
name|eclosures
index|[
name|edest
index|]
operator|.
name|nelem
operator|==
literal|0
condition|)
block|{
name|incomplete
operator|=
literal|1
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|eclosure_elem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Epsilon closures include itself.  */
name|re_node_set_insert
argument_list|(
operator|&
name|eclosure
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|incomplete
operator|&&
operator|!
name|root
condition|)
name|dfa
operator|->
name|eclosures
index|[
name|node
index|]
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
else|else
name|dfa
operator|->
name|eclosures
index|[
name|node
index|]
operator|=
name|eclosure
expr_stmt|;
operator|*
name|new_set
operator|=
name|eclosure
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for token which are used in the parser.  */
end_comment

begin_comment
comment|/* Fetch a token from INPUT.    We must not use this function inside bracket expressions.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_token
parameter_list|(
name|result
parameter_list|,
name|input
parameter_list|,
name|syntax
parameter_list|)
name|re_token_t
modifier|*
name|result
decl_stmt|;
name|re_string_t
modifier|*
name|input
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|re_string_skip_bytes
argument_list|(
name|input
argument_list|,
name|peek_token
argument_list|(
name|result
argument_list|,
name|input
argument_list|,
name|syntax
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Peek a token from INPUT, and return the length of the token.    We must not use this function inside bracket expressions.  */
end_comment

begin_function
specifier|static
name|int
name|peek_token
parameter_list|(
name|token
parameter_list|,
name|input
parameter_list|,
name|syntax
parameter_list|)
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|re_string_t
modifier|*
name|input
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|re_string_eoi
argument_list|(
name|input
argument_list|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|END_OF_RE
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|re_string_peek_byte
argument_list|(
name|input
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|token
operator|->
name|word_char
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|token
operator|->
name|mb_partial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|input
operator|->
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|re_string_first_byte
argument_list|(
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
argument_list|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
name|token
operator|->
name|mb_partial
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|unsigned
name|char
name|c2
decl_stmt|;
if|if
condition|(
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
operator|+
literal|1
operator|>=
name|re_string_length
argument_list|(
name|input
argument_list|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|BACK_SLASH
expr_stmt|;
return|return
literal|1
return|;
block|}
name|c2
operator|=
name|re_string_peek_byte_case
argument_list|(
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|c
operator|=
name|c2
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|input
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|wint_t
name|wc
init|=
name|re_string_wchar_at
argument_list|(
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|token
operator|->
name|word_char
operator|=
name|IS_WIDE_WORD_CHAR
argument_list|(
name|wc
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|token
operator|->
name|word_char
operator|=
name|IS_WORD_CHAR
argument_list|(
name|c2
argument_list|)
operator|!=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c2
condition|)
block|{
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_ALT
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_REFS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|OP_BACK_REF
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|idx
operator|=
name|c2
operator|-
literal|'1'
expr_stmt|;
block|}
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|WORD_FIRST
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|WORD_LAST
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|WORD_DELIM
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|NOT_WORD_DELIM
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_WORD
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_NOTWORD
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_SPACE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_NOTSPACE
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|BUF_FIRST
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|BUF_LAST
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_OPEN_SUBEXP
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_CLOSE_SUBEXP
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_DUP_PLUS
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_DUP_QUESTION
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_OPEN_DUP_NUM
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_CLOSE_DUP_NUM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|2
return|;
block|}
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|input
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|wint_t
name|wc
init|=
name|re_string_wchar_at
argument_list|(
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
argument_list|)
decl_stmt|;
name|token
operator|->
name|word_char
operator|=
name|IS_WIDE_WORD_CHAR
argument_list|(
name|wc
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|token
operator|->
name|word_char
operator|=
name|IS_WORD_CHAR
argument_list|(
name|token
operator|->
name|opr
operator|.
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NEWLINE_ALT
condition|)
name|token
operator|->
name|type
operator|=
name|OP_ALT
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_ALT
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|token
operator|->
name|type
operator|=
name|OP_DUP_ASTERISK
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_DUP_PLUS
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_DUP_QUESTION
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_OPEN_DUP_NUM
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
name|token
operator|->
name|type
operator|=
name|OP_CLOSE_DUP_NUM
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
name|token
operator|->
name|type
operator|=
name|OP_OPEN_SUBEXP
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
name|token
operator|->
name|type
operator|=
name|OP_CLOSE_SUBEXP
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|token
operator|->
name|type
operator|=
name|OP_OPEN_BRACKET
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|token
operator|->
name|type
operator|=
name|OP_PERIOD
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
operator|(
name|RE_CONTEXT_INDEP_ANCHORS
operator||
name|RE_CARET_ANCHORS_HERE
operator|)
operator|)
operator|&&
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|prev
init|=
name|re_string_peek_byte
argument_list|(
name|input
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NEWLINE_ALT
operator|)
operator|||
name|prev
operator|!=
literal|'\n'
condition|)
break|break;
block|}
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|LINE_FIRST
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
operator|)
operator|&&
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
operator|+
literal|1
operator|!=
name|re_string_length
argument_list|(
name|input
argument_list|)
condition|)
block|{
name|re_token_t
name|next
decl_stmt|;
name|re_string_skip_bytes
argument_list|(
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peek_token
argument_list|(
operator|&
name|next
argument_list|,
name|input
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
name|re_string_skip_bytes
argument_list|(
name|input
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|.
name|type
operator|!=
name|OP_ALT
operator|&&
name|next
operator|.
name|type
operator|!=
name|OP_CLOSE_SUBEXP
condition|)
break|break;
block|}
name|token
operator|->
name|type
operator|=
name|ANCHOR
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|LINE_LAST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Peek a token from INPUT, and return the length of the token.    We must not use this function out of bracket expressions.  */
end_comment

begin_function
specifier|static
name|int
name|peek_token_bracket
parameter_list|(
name|token
parameter_list|,
name|input
parameter_list|,
name|syntax
parameter_list|)
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|re_string_t
modifier|*
name|input
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|re_string_eoi
argument_list|(
name|input
argument_list|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|END_OF_RE
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|re_string_peek_byte
argument_list|(
name|input
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|c
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|input
operator|->
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|re_string_first_byte
argument_list|(
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
argument_list|)
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|syntax
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
operator|&&
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
operator|+
literal|1
operator|<
name|re_string_length
argument_list|(
name|input
argument_list|)
condition|)
block|{
comment|/* In this case, '\' escape a character.  */
name|unsigned
name|char
name|c2
decl_stmt|;
name|re_string_skip_bytes
argument_list|(
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|re_string_peek_byte
argument_list|(
name|input
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|c
operator|=
name|c2
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
comment|/* '[' is a special char in a bracket exps.  */
block|{
name|unsigned
name|char
name|c2
decl_stmt|;
name|int
name|token_len
decl_stmt|;
if|if
condition|(
name|re_string_cur_idx
argument_list|(
name|input
argument_list|)
operator|+
literal|1
operator|<
name|re_string_length
argument_list|(
name|input
argument_list|)
condition|)
name|c2
operator|=
name|re_string_peek_byte
argument_list|(
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|c2
operator|=
literal|0
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|c
operator|=
name|c2
expr_stmt|;
name|token_len
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|c2
condition|)
block|{
case|case
literal|'.'
case|:
name|token
operator|->
name|type
operator|=
name|OP_OPEN_COLL_ELEM
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|token
operator|->
name|type
operator|=
name|OP_OPEN_EQUIV_CLASS
expr_stmt|;
break|break;
case|case
literal|':'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|OP_OPEN_CHAR_CLASS
expr_stmt|;
break|break;
block|}
comment|/* else fall through.  */
default|default:
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|token_len
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|token_len
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
name|token
operator|->
name|type
operator|=
name|OP_CHARSET_RANGE
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|token
operator|->
name|type
operator|=
name|OP_CLOSE_BRACKET
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|token
operator|->
name|type
operator|=
name|OP_NON_MATCH_LIST
expr_stmt|;
break|break;
default|default:
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for parser.  */
end_comment

begin_comment
comment|/* Entry point of the parser.    Parse the regular expression REGEXP and return the structure tree.    If an error is occured, ERR is set by error code, and return NULL.    This function build the following tree, from regular expression<reg_exp>: 	   CAT 	   / \ 	  /   \<reg_exp>  EOR     CAT means concatenation.    EOR means end of regular expression.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse
parameter_list|(
name|regexp
parameter_list|,
name|preg
parameter_list|,
name|syntax
parameter_list|,
name|err
parameter_list|)
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|bin_tree_t
modifier|*
name|tree
decl_stmt|,
modifier|*
name|eor
decl_stmt|,
modifier|*
name|root
decl_stmt|;
name|re_token_t
name|current_token
decl_stmt|;
name|dfa
operator|->
name|syntax
operator|=
name|syntax
expr_stmt|;
name|fetch_token
argument_list|(
operator|&
name|current_token
argument_list|,
name|regexp
argument_list|,
name|syntax
operator||
name|RE_CARET_ANCHORS_HERE
argument_list|)
expr_stmt|;
name|tree
operator|=
name|parse_reg_exp
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
operator|&
name|current_token
argument_list|,
name|syntax
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|eor
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|END_OF_RE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
name|root
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|eor
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
else|else
name|root
operator|=
name|eor
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|eor
operator|==
name|NULL
operator|||
name|root
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* This function build the following tree, from regular expression<branch1>|<branch2>: 	   ALT 	   / \ 	  /   \<branch1><branch2>     ALT means alternative, which represents the operator `|'.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse_reg_exp
parameter_list|(
name|regexp
parameter_list|,
name|preg
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|,
name|nest
parameter_list|,
name|err
parameter_list|)
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|bin_tree_t
modifier|*
name|tree
decl_stmt|,
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
name|tree
operator|=
name|parse_branch
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|token
operator|->
name|type
operator|==
name|OP_ALT
condition|)
block|{
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
operator||
name|RE_CARET_ANCHORS_HERE
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|OP_ALT
operator|&&
name|token
operator|->
name|type
operator|!=
name|END_OF_RE
operator|&&
operator|(
name|nest
operator|==
literal|0
operator|||
name|token
operator|->
name|type
operator|!=
name|OP_CLOSE_SUBEXP
operator|)
condition|)
block|{
name|branch
operator|=
name|parse_branch
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|branch
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|branch
operator|=
name|NULL
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|branch
argument_list|,
name|OP_ALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* This function build the following tree, from regular expression<exp1><exp2>: 	CAT 	/ \        /   \<exp1><exp2>     CAT means concatenation.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse_branch
parameter_list|(
name|regexp
parameter_list|,
name|preg
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|,
name|nest
parameter_list|,
name|err
parameter_list|)
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|bin_tree_t
modifier|*
name|tree
decl_stmt|,
modifier|*
name|exp
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|tree
operator|=
name|parse_expression
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|token
operator|->
name|type
operator|!=
name|OP_ALT
operator|&&
name|token
operator|->
name|type
operator|!=
name|END_OF_RE
operator|&&
operator|(
name|nest
operator|==
literal|0
operator|||
name|token
operator|->
name|type
operator|!=
name|OP_CLOSE_SUBEXP
operator|)
condition|)
block|{
name|exp
operator|=
name|parse_expression
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|exp
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tree
operator|!=
name|NULL
operator|&&
name|exp
operator|!=
name|NULL
condition|)
block|{
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|exp
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
name|tree
operator|=
name|exp
expr_stmt|;
comment|/* Otherwise exp == NULL, we don't need to create new tree.  */
block|}
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* This function build the following tree, from regular expression a*: 	 * 	 | 	 a */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse_expression
parameter_list|(
name|regexp
parameter_list|,
name|preg
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|,
name|nest
parameter_list|,
name|err
parameter_list|)
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|bin_tree_t
modifier|*
name|tree
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CHARACTER
case|:
name|tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
while|while
condition|(
operator|!
name|re_string_eoi
argument_list|(
name|regexp
argument_list|)
operator|&&
operator|!
name|re_string_first_byte
argument_list|(
name|regexp
argument_list|,
name|re_string_cur_idx
argument_list|(
name|regexp
argument_list|)
argument_list|)
condition|)
block|{
name|bin_tree_t
modifier|*
name|mbc_remain
decl_stmt|;
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
name|mbc_remain
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|mbc_remain
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbc_remain
operator|==
name|NULL
operator|||
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|OP_OPEN_SUBEXP
case|:
name|tree
operator|=
name|parse_sub_exp
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
operator|+
literal|1
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|OP_OPEN_BRACKET
case|:
name|tree
operator|=
name|parse_bracket_exp
argument_list|(
name|regexp
argument_list|,
name|dfa
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|OP_BACK_REF
case|:
if|if
condition|(
operator|!
name|BE
argument_list|(
name|dfa
operator|->
name|completed_bkref_map
operator|&
operator|(
literal|1
operator|<<
name|token
operator|->
name|opr
operator|.
name|idx
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESUBREG
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dfa
operator|->
name|used_bkref_map
operator||=
literal|1
operator|<<
name|token
operator|->
name|opr
operator|.
name|idx
expr_stmt|;
name|tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|++
name|dfa
operator|->
name|nbackref
expr_stmt|;
name|dfa
operator|->
name|has_mb_node
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_OPEN_DUP_NUM
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_DUP
condition|)
block|{
operator|*
name|err
operator|=
name|REG_BADRPT
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|OP_DUP_ASTERISK
case|:
case|case
name|OP_DUP_PLUS
case|:
case|case
name|OP_DUP_QUESTION
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
condition|)
block|{
operator|*
name|err
operator|=
name|REG_BADRPT
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
condition|)
block|{
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
return|return
name|parse_expression
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
argument_list|,
name|err
argument_list|)
return|;
block|}
comment|/* else fall through  */
case|case
name|OP_CLOSE_SUBEXP
case|:
if|if
condition|(
operator|(
name|token
operator|->
name|type
operator|==
name|OP_CLOSE_SUBEXP
operator|)
operator|&&
operator|!
operator|(
name|syntax
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
operator|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ERPAREN
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* else fall through  */
case|case
name|OP_CLOSE_DUP_NUM
case|:
comment|/* We treat it as a normal character.  */
comment|/* Then we can these characters as normal characters.  */
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
comment|/* mb_partial and word_char bits should be initialized already 	 by peek_token.  */
name|tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|ANCHOR
case|:
if|if
condition|(
operator|(
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|&
operator|(
name|WORD_DELIM
operator||
name|NOT_WORD_DELIM
operator||
name|WORD_FIRST
operator||
name|WORD_LAST
operator|)
operator|)
operator|&&
name|dfa
operator|->
name|word_ops_used
operator|==
literal|0
condition|)
name|init_word_char
argument_list|(
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|==
name|WORD_DELIM
operator|||
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|==
name|NOT_WORD_DELIM
condition|)
block|{
name|bin_tree_t
modifier|*
name|tree_first
decl_stmt|,
modifier|*
name|tree_last
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|==
name|WORD_DELIM
condition|)
block|{
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|WORD_FIRST
expr_stmt|;
name|tree_first
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|WORD_LAST
expr_stmt|;
block|}
else|else
block|{
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|INSIDE_WORD
expr_stmt|;
name|tree_first
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|token
operator|->
name|opr
operator|.
name|ctx_type
operator|=
name|INSIDE_NOTWORD
expr_stmt|;
block|}
name|tree_last
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree_first
argument_list|,
name|tree_last
argument_list|,
name|OP_ALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree_first
operator|==
name|NULL
operator|||
name|tree_last
operator|==
name|NULL
operator|||
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* We must return here, since ANCHORs can't be followed 	 by repetition operators. 	 eg. RE"^*" is invalid or "<ANCHOR(^)><CHAR(*)>", 	     it must not be "<ANCHOR(^)><REPEAT(*)>".  */
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
case|case
name|OP_PERIOD
case|:
name|tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|dfa
operator|->
name|has_mb_node
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_WORD
case|:
case|case
name|OP_NOTWORD
case|:
name|tree
operator|=
name|build_charclass_op
argument_list|(
name|dfa
argument_list|,
name|regexp
operator|->
name|trans
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"alnum"
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"_"
argument_list|,
name|token
operator|->
name|type
operator|==
name|OP_NOTWORD
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|OP_SPACE
case|:
case|case
name|OP_NOTSPACE
case|:
name|tree
operator|=
name|build_charclass_op
argument_list|(
name|dfa
argument_list|,
name|regexp
operator|->
name|trans
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"space"
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|""
argument_list|,
name|token
operator|->
name|type
operator|==
name|OP_NOTSPACE
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
case|case
name|OP_ALT
case|:
case|case
name|END_OF_RE
case|:
return|return
name|NULL
return|;
case|case
name|BACK_SLASH
case|:
operator|*
name|err
operator|=
name|REG_EESCAPE
expr_stmt|;
return|return
name|NULL
return|;
default|default:
comment|/* Must not happen?  */
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|->
name|type
operator|==
name|OP_DUP_ASTERISK
operator|||
name|token
operator|->
name|type
operator|==
name|OP_DUP_PLUS
operator|||
name|token
operator|->
name|type
operator|==
name|OP_DUP_QUESTION
operator|||
name|token
operator|->
name|type
operator|==
name|OP_OPEN_DUP_NUM
condition|)
block|{
name|tree
operator|=
name|parse_dup_op
argument_list|(
name|tree
argument_list|,
name|regexp
argument_list|,
name|dfa
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
operator|&&
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* In BRE consecutive duplications are not allowed.  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_DUP
operator|)
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
name|OP_DUP_ASTERISK
operator|||
name|token
operator|->
name|type
operator|==
name|OP_OPEN_DUP_NUM
operator|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_BADRPT
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* This function build the following tree, from regular expression    (<reg_exp>): 	 SUBEXP 	    |<reg_exp> */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse_sub_exp
parameter_list|(
name|regexp
parameter_list|,
name|preg
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|,
name|nest
parameter_list|,
name|err
parameter_list|)
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|bin_tree_t
modifier|*
name|tree
decl_stmt|;
name|size_t
name|cur_nsub
decl_stmt|;
name|cur_nsub
operator|=
name|preg
operator|->
name|re_nsub
operator|++
expr_stmt|;
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
operator||
name|RE_CARET_ANCHORS_HERE
argument_list|)
expr_stmt|;
comment|/* The subexpression may be a null string.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_CLOSE_SUBEXP
condition|)
name|tree
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tree
operator|=
name|parse_reg_exp
argument_list|(
name|regexp
argument_list|,
name|preg
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|,
name|nest
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|==
name|REG_NOERROR
operator|&&
name|token
operator|->
name|type
operator|!=
name|OP_CLOSE_SUBEXP
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|err
operator|=
name|REG_EPAREN
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|dfa
operator|->
name|completed_bkref_map
operator||=
literal|1
operator|<<
name|cur_nsub
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|NULL
argument_list|,
name|SUBEXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tree
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|=
name|cur_nsub
expr_stmt|;
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* This function parse repetition operators like "*", "+", "{1,3}" etc.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse_dup_op
parameter_list|(
name|elem
parameter_list|,
name|regexp
parameter_list|,
name|dfa
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|,
name|err
parameter_list|)
name|bin_tree_t
modifier|*
name|elem
decl_stmt|;
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|bin_tree_t
modifier|*
name|tree
init|=
name|NULL
decl_stmt|,
modifier|*
name|old_tree
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_idx
init|=
name|re_string_cur_idx
argument_list|(
name|regexp
argument_list|)
decl_stmt|;
name|re_token_t
name|start_token
init|=
operator|*
name|token
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_OPEN_DUP_NUM
condition|)
block|{
name|end
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|fetch_number
argument_list|(
name|regexp
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CHARACTER
operator|&&
name|token
operator|->
name|opr
operator|.
name|c
operator|==
literal|','
condition|)
name|start
operator|=
literal|0
expr_stmt|;
comment|/* We treat "{,m}" as "{0,m}".  */
else|else
block|{
operator|*
name|err
operator|=
name|REG_BADBR
expr_stmt|;
comment|/*<re>{} is invalid.  */
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|BE
argument_list|(
name|start
operator|!=
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* We treat "{n}" as "{n,n}".  */
name|end
operator|=
operator|(
operator|(
name|token
operator|->
name|type
operator|==
name|OP_CLOSE_DUP_NUM
operator|)
condition|?
name|start
else|:
operator|(
operator|(
name|token
operator|->
name|type
operator|==
name|CHARACTER
operator|&&
name|token
operator|->
name|opr
operator|.
name|c
operator|==
literal|','
operator|)
condition|?
name|fetch_number
argument_list|(
name|regexp
argument_list|,
name|token
argument_list|,
name|syntax
argument_list|)
else|:
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|start
operator|==
operator|-
literal|2
operator|||
name|end
operator|==
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Invalid sequence.  */
if|if
condition|(
name|BE
argument_list|(
operator|!
operator|(
name|syntax
operator|&
name|RE_INVALID_INTERVAL_ORD
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|END_OF_RE
condition|)
operator|*
name|err
operator|=
name|REG_EBRACE
expr_stmt|;
else|else
operator|*
name|err
operator|=
name|REG_BADBR
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If the syntax bit is set, rollback.  */
name|re_string_set_index
argument_list|(
name|regexp
argument_list|,
name|start_idx
argument_list|)
expr_stmt|;
operator|*
name|token
operator|=
name|start_token
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
comment|/* mb_partial and word_char bits should be already initialized by 	     peek_token.  */
return|return
name|elem
return|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|end
operator|!=
operator|-
literal|1
operator|&&
name|start
operator|>
name|end
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* First number greater than second.  */
operator|*
name|err
operator|=
name|REG_BADBR
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|start
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|OP_DUP_PLUS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|end
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|OP_DUP_QUESTION
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
block|}
name|fetch_token
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|elem
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|BE
argument_list|(
name|start
operator|==
literal|0
operator|&&
name|end
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|postorder
argument_list|(
name|elem
argument_list|,
name|free_tree
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Extract "<re>{n,m}" to "<re><re>...<re><re>{0,<m-n>}".  */
if|if
condition|(
name|BE
argument_list|(
name|start
operator|>
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
operator|=
name|elem
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|start
condition|;
operator|++
name|i
control|)
block|{
name|elem
operator|=
name|duplicate_tree
argument_list|(
name|elem
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|elem
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|elem
operator|==
name|NULL
operator|||
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_dup_op_espace
goto|;
block|}
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
name|tree
return|;
comment|/* Duplicate ELEM before it is marked optional.  */
name|elem
operator|=
name|duplicate_tree
argument_list|(
name|elem
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
name|old_tree
operator|=
name|tree
expr_stmt|;
block|}
else|else
name|old_tree
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|token
operator|.
name|type
operator|==
name|SUBEXP
condition|)
name|postorder
argument_list|(
name|elem
argument_list|,
name|mark_opt_subexp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|elem
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
argument_list|)
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|elem
argument_list|,
name|NULL
argument_list|,
operator|(
name|end
operator|==
operator|-
literal|1
condition|?
name|OP_DUP_ASTERISK
else|:
name|OP_ALT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_dup_op_espace
goto|;
comment|/* This loop is actually executed only when end != -1,      to rewrite<re>{0,n} as (<re>(<re>...<re>?)?)?...  We have      already created the start+1-th copy.  */
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|2
init|;
name|i
operator|<=
name|end
condition|;
operator|++
name|i
control|)
block|{
name|elem
operator|=
name|duplicate_tree
argument_list|(
name|elem
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|elem
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|elem
operator|==
name|NULL
operator|||
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_dup_op_espace
goto|;
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|NULL
argument_list|,
name|OP_ALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_dup_op_espace
goto|;
block|}
if|if
condition|(
name|old_tree
condition|)
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|old_tree
argument_list|,
name|tree
argument_list|,
name|CONCAT
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
name|parse_dup_op_espace
label|:
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Size of the names for collating symbol/equivalence_class/character_class.    I'm not sure, but maybe enough.  */
end_comment

begin_define
define|#
directive|define
name|BRACKET_NAME_BUF_SIZE
value|32
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_comment
comment|/* Local function for parse_bracket_exp only used in case of NOT _LIBC.      Build the range expression which starts from START_ELEM, and ends      at END_ELEM.  The result are written to MBCSET and SBCSET.      RANGE_ALLOC is the allocated size of mbcset->range_starts, and      mbcset->range_ends, is a pointer argument sinse we may      update it.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|build_range_exp
parameter_list|(
name|sbcset
parameter_list|,
name|mbcset
parameter_list|,
name|range_alloc
parameter_list|,
name|start_elem
parameter_list|,
name|end_elem
parameter_list|)
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
modifier|*
name|range_alloc
decl_stmt|;
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
function|build_range_exp
parameter_list|(
name|sbcset
parameter_list|,
name|start_elem
parameter_list|,
name|end_elem
parameter_list|)
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
name|bracket_elem_t
modifier|*
name|start_elem
decl_stmt|,
decl|*
name|end_elem
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|int
name|start_ch
decl_stmt|,
name|end_ch
decl_stmt|;
comment|/* Equivalence Classes and Character Classes can't be a range start/end.  */
if|if
condition|(
name|BE
argument_list|(
name|start_elem
operator|->
name|type
operator|==
name|EQUIV_CLASS
operator|||
name|start_elem
operator|->
name|type
operator|==
name|CHAR_CLASS
operator|||
name|end_elem
operator|->
name|type
operator|==
name|EQUIV_CLASS
operator|||
name|end_elem
operator|->
name|type
operator|==
name|CHAR_CLASS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* We can handle no multi character collating elements without libc      support.  */
if|if
condition|(
name|BE
argument_list|(
operator|(
name|start_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|&&
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|start_elem
operator|->
name|opr
operator|.
name|name
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|end_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|&&
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|end_elem
operator|->
name|opr
operator|.
name|name
argument_list|)
operator|>
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ECOLLATE
return|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
block|{
name|wchar_t
name|wc
decl_stmt|,
name|start_wc
decl_stmt|,
name|end_wc
decl_stmt|;
name|wchar_t
name|cmp_buf
index|[
literal|6
index|]
init|=
block|{
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|}
decl_stmt|;
name|start_ch
operator|=
operator|(
operator|(
name|start_elem
operator|->
name|type
operator|==
name|SB_CHAR
operator|)
condition|?
name|start_elem
operator|->
name|opr
operator|.
name|ch
else|:
operator|(
operator|(
name|start_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|)
condition|?
name|start_elem
operator|->
name|opr
operator|.
name|name
index|[
literal|0
index|]
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|end_ch
operator|=
operator|(
operator|(
name|end_elem
operator|->
name|type
operator|==
name|SB_CHAR
operator|)
condition|?
name|end_elem
operator|->
name|opr
operator|.
name|ch
else|:
operator|(
operator|(
name|end_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|)
condition|?
name|end_elem
operator|->
name|opr
operator|.
name|name
index|[
literal|0
index|]
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|start_wc
operator|=
operator|(
operator|(
name|start_elem
operator|->
name|type
operator|==
name|SB_CHAR
operator|||
name|start_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|)
condition|?
name|__btowc
argument_list|(
name|start_ch
argument_list|)
else|:
name|start_elem
operator|->
name|opr
operator|.
name|wch
operator|)
expr_stmt|;
name|end_wc
operator|=
operator|(
operator|(
name|end_elem
operator|->
name|type
operator|==
name|SB_CHAR
operator|||
name|end_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|)
condition|?
name|__btowc
argument_list|(
name|end_ch
argument_list|)
else|:
name|end_elem
operator|->
name|opr
operator|.
name|wch
operator|)
expr_stmt|;
if|if
condition|(
name|start_wc
operator|==
name|WEOF
operator|||
name|end_wc
operator|==
name|WEOF
condition|)
return|return
name|REG_ECOLLATE
return|;
name|cmp_buf
index|[
literal|0
index|]
operator|=
name|start_wc
expr_stmt|;
name|cmp_buf
index|[
literal|4
index|]
operator|=
name|end_wc
expr_stmt|;
if|if
condition|(
name|wcscoll
argument_list|(
name|cmp_buf
argument_list|,
name|cmp_buf
operator|+
literal|4
argument_list|)
operator|>
literal|0
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* Got valid collation sequence values, add them as a new entry.        However, for !_LIBC we have no collation elements: if the        character set is single byte, the single byte character set        that we build below suffices.  parse_bracket_exp passes        no MBCSET if dfa->mb_cur_max == 1.  */
if|if
condition|(
name|mbcset
condition|)
block|{
comment|/* Check the space of the arrays.  */
if|if
condition|(
name|BE
argument_list|(
operator|*
name|range_alloc
operator|==
name|mbcset
operator|->
name|nranges
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* There is not enough space, need realloc.  */
name|wchar_t
modifier|*
name|new_array_start
decl_stmt|,
modifier|*
name|new_array_end
decl_stmt|;
name|int
name|new_nranges
decl_stmt|;
comment|/* +1 in case of mbcset->nranges is 0.  */
name|new_nranges
operator|=
literal|2
operator|*
name|mbcset
operator|->
name|nranges
operator|+
literal|1
expr_stmt|;
comment|/* Use realloc since mbcset->range_starts and mbcset->range_ends 	       are NULL if *range_alloc == 0.  */
name|new_array_start
operator|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|range_starts
argument_list|,
name|wchar_t
argument_list|,
name|new_nranges
argument_list|)
expr_stmt|;
name|new_array_end
operator|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|range_ends
argument_list|,
name|wchar_t
argument_list|,
name|new_nranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array_start
operator|==
name|NULL
operator|||
name|new_array_end
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mbcset
operator|->
name|range_starts
operator|=
name|new_array_start
expr_stmt|;
name|mbcset
operator|->
name|range_ends
operator|=
name|new_array_end
expr_stmt|;
operator|*
name|range_alloc
operator|=
name|new_nranges
expr_stmt|;
block|}
name|mbcset
operator|->
name|range_starts
index|[
name|mbcset
operator|->
name|nranges
index|]
operator|=
name|start_wc
expr_stmt|;
name|mbcset
operator|->
name|range_ends
index|[
name|mbcset
operator|->
name|nranges
operator|++
index|]
operator|=
name|end_wc
expr_stmt|;
block|}
comment|/* Build the table for single byte characters.  */
for|for
control|(
name|wc
operator|=
literal|0
init|;
name|wc
operator|<
name|SBC_MAX
condition|;
operator|++
name|wc
control|)
block|{
name|cmp_buf
index|[
literal|2
index|]
operator|=
name|wc
expr_stmt|;
if|if
condition|(
name|wcscoll
argument_list|(
name|cmp_buf
argument_list|,
name|cmp_buf
operator|+
literal|2
argument_list|)
operator|<=
literal|0
operator|&&
name|wcscoll
argument_list|(
name|cmp_buf
operator|+
literal|2
argument_list|,
name|cmp_buf
operator|+
literal|4
argument_list|)
operator|<=
literal|0
condition|)
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
block|{
name|unsigned
name|int
name|ch
decl_stmt|;
name|start_ch
operator|=
operator|(
operator|(
name|start_elem
operator|->
name|type
operator|==
name|SB_CHAR
operator|)
condition|?
name|start_elem
operator|->
name|opr
operator|.
name|ch
else|:
operator|(
operator|(
name|start_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|)
condition|?
name|start_elem
operator|->
name|opr
operator|.
name|name
index|[
literal|0
index|]
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|end_ch
operator|=
operator|(
operator|(
name|end_elem
operator|->
name|type
operator|==
name|SB_CHAR
operator|)
condition|?
name|end_elem
operator|->
name|opr
operator|.
name|ch
else|:
operator|(
operator|(
name|end_elem
operator|->
name|type
operator|==
name|COLL_SYM
operator|)
condition|?
name|end_elem
operator|->
name|opr
operator|.
name|name
index|[
literal|0
index|]
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|start_ch
operator|>
name|end_ch
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* Build the table for single byte characters.  */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|SBC_MAX
condition|;
operator|++
name|ch
control|)
if|if
condition|(
name|start_ch
operator|<=
name|ch
operator|&&
name|ch
operator|<=
name|end_ch
condition|)
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _LIBC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_comment
comment|/* Helper function for parse_bracket_exp only used in case of NOT _LIBC..    Build the collating element which is represented by NAME.    The result are written to MBCSET and SBCSET.    COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a    pointer argument since we may update it.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|build_collating_symbol
parameter_list|(
name|sbcset
parameter_list|,
name|mbcset
parameter_list|,
name|coll_sym_alloc
parameter_list|,
name|name
parameter_list|)
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
modifier|*
name|coll_sym_alloc
decl_stmt|;
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
function|build_collating_symbol
parameter_list|(
name|sbcset
parameter_list|,
name|name
parameter_list|)
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|name_len
operator|!=
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ECOLLATE
return|;
else|else
block|{
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _LIBC */
end_comment

begin_comment
comment|/* This function parse bracket expression like "[abc]", "[a-c]",    "[[.a-a.]]" etc.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|parse_bracket_exp
parameter_list|(
name|regexp
parameter_list|,
name|dfa
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|,
name|err
parameter_list|)
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|_LIBC
specifier|const
name|unsigned
name|char
modifier|*
name|collseqmb
decl_stmt|;
specifier|const
name|char
modifier|*
name|collseqwc
decl_stmt|;
name|uint32_t
name|nrules
decl_stmt|;
name|int32_t
name|table_size
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|symb_table
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
comment|/* Local function for parse_bracket_exp used in _LIBC environement.      Seek the collating symbol entry correspondings to NAME.      Return the index of the symbol in the SYMB_TABLE.  */
specifier|auto
specifier|inline
name|int32_t
name|__attribute
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|seek_collating_symbol_entry
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|)
decl|const
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
block|{
name|int32_t
name|hash
init|=
name|elem_hash
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|,
name|name_len
argument_list|)
decl_stmt|;
name|int32_t
name|elem
init|=
name|hash
operator|%
name|table_size
decl_stmt|;
name|int32_t
name|second
init|=
name|hash
operator|%
operator|(
name|table_size
operator|-
literal|2
operator|)
decl_stmt|;
while|while
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* First compare the hashing value.  */
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
name|hash
comment|/* Compare the length of the name.  */
operator|&&
name|name_len
operator|==
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
index|]
comment|/* Compare the name.  */
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
operator|&
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
operator|+
literal|1
index|]
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yep, this is the entry.  */
break|break;
block|}
comment|/* Next entry.  */
name|elem
operator|+=
name|second
expr_stmt|;
block|}
return|return
name|elem
return|;
block|}
comment|/* Local function for parse_bracket_exp used in _LIBC environement.      Look up the collation sequence value of BR_ELEM.      Return the value if succeeded, UINT_MAX otherwise.  */
specifier|auto
specifier|inline
name|unsigned
name|int
name|__attribute
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|lookup_collation_sequence_value
argument_list|(
name|br_elem
argument_list|)
name|bracket_elem_t
modifier|*
name|br_elem
decl_stmt|;
block|{
if|if
condition|(
name|br_elem
operator|->
name|type
operator|==
name|SB_CHAR
condition|)
block|{
comment|/* 	  if (MB_CUR_MAX == 1) 	  */
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
return|return
name|collseqmb
index|[
name|br_elem
operator|->
name|opr
operator|.
name|ch
index|]
return|;
else|else
block|{
name|wint_t
name|wc
init|=
name|__btowc
argument_list|(
name|br_elem
operator|->
name|opr
operator|.
name|ch
argument_list|)
decl_stmt|;
return|return
name|__collseq_table_lookup
argument_list|(
name|collseqwc
argument_list|,
name|wc
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|br_elem
operator|->
name|type
operator|==
name|MB_CHAR
condition|)
block|{
return|return
name|__collseq_table_lookup
argument_list|(
name|collseqwc
argument_list|,
name|br_elem
operator|->
name|opr
operator|.
name|wch
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|br_elem
operator|->
name|type
operator|==
name|COLL_SYM
condition|)
block|{
name|size_t
name|sym_name_len
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|br_elem
operator|->
name|opr
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
name|int32_t
name|elem
decl_stmt|,
name|idx
decl_stmt|;
name|elem
operator|=
name|seek_collating_symbol_entry
argument_list|(
name|br_elem
operator|->
name|opr
operator|.
name|name
argument_list|,
name|sym_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We found the entry.  */
name|idx
operator|=
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Skip the name of collating element name.  */
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
comment|/* Skip the byte sequence of the collating element.  */
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
comment|/* Adjust for the alignment.  */
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Skip the multibyte collation sequence value.  */
name|idx
operator|+=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
comment|/* Skip the wide char sequence of the collating element.  */
name|idx
operator|+=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|*
operator|(
literal|1
operator|+
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|extra
operator|+
name|idx
operator|)
operator|)
expr_stmt|;
comment|/* Return the collation sequence value.  */
return|return
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|extra
operator|+
name|idx
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
literal|0
operator|&&
name|sym_name_len
operator|==
literal|1
condition|)
block|{
comment|/* No valid character.  Match it as a single byte 		     character.  */
return|return
name|collseqmb
index|[
name|br_elem
operator|->
name|opr
operator|.
name|name
index|[
literal|0
index|]
index|]
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sym_name_len
operator|==
literal|1
condition|)
return|return
name|collseqmb
index|[
name|br_elem
operator|->
name|opr
operator|.
name|name
index|[
literal|0
index|]
index|]
return|;
block|}
return|return
name|UINT_MAX
return|;
block|}
comment|/* Local function for parse_bracket_exp used in _LIBC environement.      Build the range expression which starts from START_ELEM, and ends      at END_ELEM.  The result are written to MBCSET and SBCSET.      RANGE_ALLOC is the allocated size of mbcset->range_starts, and      mbcset->range_ends, is a pointer argument sinse we may      update it.  */
specifier|auto
specifier|inline
name|reg_errcode_t
name|__attribute
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|build_range_exp
argument_list|(
name|sbcset
argument_list|,
name|mbcset
argument_list|,
name|range_alloc
argument_list|,
name|start_elem
argument_list|,
name|end_elem
argument_list|)
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
modifier|*
name|range_alloc
decl_stmt|;
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
name|bracket_elem_t
modifier|*
name|start_elem
decl_stmt|,
modifier|*
name|end_elem
decl_stmt|;
block|{
name|unsigned
name|int
name|ch
decl_stmt|;
name|uint32_t
name|start_collseq
decl_stmt|;
name|uint32_t
name|end_collseq
decl_stmt|;
comment|/* Equivalence Classes and Character Classes can't be a range 	 start/end.  */
if|if
condition|(
name|BE
argument_list|(
name|start_elem
operator|->
name|type
operator|==
name|EQUIV_CLASS
operator|||
name|start_elem
operator|->
name|type
operator|==
name|CHAR_CLASS
operator|||
name|end_elem
operator|->
name|type
operator|==
name|EQUIV_CLASS
operator|||
name|end_elem
operator|->
name|type
operator|==
name|CHAR_CLASS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ERANGE
return|;
name|start_collseq
operator|=
name|lookup_collation_sequence_value
argument_list|(
name|start_elem
argument_list|)
expr_stmt|;
name|end_collseq
operator|=
name|lookup_collation_sequence_value
argument_list|(
name|end_elem
argument_list|)
expr_stmt|;
comment|/* Check start/end collation sequence values.  */
if|if
condition|(
name|BE
argument_list|(
name|start_collseq
operator|==
name|UINT_MAX
operator|||
name|end_collseq
operator|==
name|UINT_MAX
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ECOLLATE
return|;
if|if
condition|(
name|BE
argument_list|(
operator|(
name|syntax
operator|&
name|RE_NO_EMPTY_RANGES
operator|)
operator|&&
name|start_collseq
operator|>
name|end_collseq
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* Got valid collation sequence values, add them as a new entry. 	 However, if we have no collation elements, and the character set 	 is single byte, the single byte character set that we 	 build below suffices. */
if|if
condition|(
name|nrules
operator|>
literal|0
operator|||
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
comment|/* Check the space of the arrays.  */
if|if
condition|(
name|BE
argument_list|(
operator|*
name|range_alloc
operator|==
name|mbcset
operator|->
name|nranges
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* There is not enough space, need realloc.  */
name|uint32_t
modifier|*
name|new_array_start
decl_stmt|;
name|uint32_t
modifier|*
name|new_array_end
decl_stmt|;
name|int
name|new_nranges
decl_stmt|;
comment|/* +1 in case of mbcset->nranges is 0.  */
name|new_nranges
operator|=
literal|2
operator|*
name|mbcset
operator|->
name|nranges
operator|+
literal|1
expr_stmt|;
name|new_array_start
operator|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|range_starts
argument_list|,
name|uint32_t
argument_list|,
name|new_nranges
argument_list|)
expr_stmt|;
name|new_array_end
operator|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|range_ends
argument_list|,
name|uint32_t
argument_list|,
name|new_nranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array_start
operator|==
name|NULL
operator|||
name|new_array_end
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mbcset
operator|->
name|range_starts
operator|=
name|new_array_start
expr_stmt|;
name|mbcset
operator|->
name|range_ends
operator|=
name|new_array_end
expr_stmt|;
operator|*
name|range_alloc
operator|=
name|new_nranges
expr_stmt|;
block|}
name|mbcset
operator|->
name|range_starts
index|[
name|mbcset
operator|->
name|nranges
index|]
operator|=
name|start_collseq
expr_stmt|;
name|mbcset
operator|->
name|range_ends
index|[
name|mbcset
operator|->
name|nranges
operator|++
index|]
operator|=
name|end_collseq
expr_stmt|;
block|}
comment|/* Build the table for single byte characters.  */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|SBC_MAX
condition|;
name|ch
operator|++
control|)
block|{
name|uint32_t
name|ch_collseq
decl_stmt|;
comment|/* 	  if (MB_CUR_MAX == 1) 	  */
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
name|ch_collseq
operator|=
name|collseqmb
index|[
name|ch
index|]
expr_stmt|;
else|else
name|ch_collseq
operator|=
name|__collseq_table_lookup
argument_list|(
name|collseqwc
argument_list|,
name|__btowc
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_collseq
operator|<=
name|ch_collseq
operator|&&
name|ch_collseq
operator|<=
name|end_collseq
condition|)
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
comment|/* Local function for parse_bracket_exp used in _LIBC environement.      Build the collating element which is represented by NAME.      The result are written to MBCSET and SBCSET.      COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a      pointer argument sinse we may update it.  */
specifier|auto
specifier|inline
name|reg_errcode_t
name|__attribute
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|build_collating_symbol
argument_list|(
name|sbcset
argument_list|,
name|mbcset
argument_list|,
name|coll_sym_alloc
argument_list|,
name|name
argument_list|)
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
modifier|*
name|coll_sym_alloc
decl_stmt|;
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int32_t
name|elem
decl_stmt|,
name|idx
decl_stmt|;
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
name|elem
operator|=
name|seek_collating_symbol_entry
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* We found the entry.  */
name|idx
operator|=
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Skip the name of collating element name.  */
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
literal|0
operator|&&
name|name_len
operator|==
literal|1
condition|)
block|{
comment|/* No valid character, treat it as a normal 		 character.  */
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
else|else
return|return
name|REG_ECOLLATE
return|;
comment|/* Got valid collation sequence, add it as a new entry.  */
comment|/* Check the space of the arrays.  */
if|if
condition|(
name|BE
argument_list|(
operator|*
name|coll_sym_alloc
operator|==
name|mbcset
operator|->
name|ncoll_syms
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Not enough, realloc it.  */
comment|/* +1 in case of mbcset->ncoll_syms is 0.  */
name|int
name|new_coll_sym_alloc
init|=
literal|2
operator|*
name|mbcset
operator|->
name|ncoll_syms
operator|+
literal|1
decl_stmt|;
comment|/* Use realloc since mbcset->coll_syms is NULL 		 if *alloc == 0.  */
name|int32_t
modifier|*
name|new_coll_syms
init|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|coll_syms
argument_list|,
name|int32_t
argument_list|,
name|new_coll_sym_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_coll_syms
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mbcset
operator|->
name|coll_syms
operator|=
name|new_coll_syms
expr_stmt|;
operator|*
name|coll_sym_alloc
operator|=
name|new_coll_sym_alloc
expr_stmt|;
block|}
name|mbcset
operator|->
name|coll_syms
index|[
name|mbcset
operator|->
name|ncoll_syms
operator|++
index|]
operator|=
name|idx
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
else|else
block|{
if|if
condition|(
name|BE
argument_list|(
name|name_len
operator|!=
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ECOLLATE
return|;
else|else
block|{
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
block|}
block|}
endif|#
directive|endif
name|re_token_t
name|br_token
decl_stmt|;
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
name|coll_sym_alloc
init|=
literal|0
decl_stmt|,
name|range_alloc
init|=
literal|0
decl_stmt|,
name|mbchar_alloc
init|=
literal|0
decl_stmt|;
name|int
name|equiv_class_alloc
init|=
literal|0
decl_stmt|,
name|char_class_alloc
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|int
name|non_match
init|=
literal|0
decl_stmt|;
name|bin_tree_t
modifier|*
name|work_tree
decl_stmt|;
name|int
name|token_len
decl_stmt|;
name|int
name|first_round
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|collseqmb
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQMB
argument_list|)
expr_stmt|;
name|nrules
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrules
condition|)
block|{
comment|/*       if (MB_CUR_MAX> 1)       */
name|collseqwc
operator|=
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQWC
argument_list|)
expr_stmt|;
name|table_size
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_HASH_SIZEMB
argument_list|)
expr_stmt|;
name|symb_table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_TABLEMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sbcset
operator|=
operator|(
name|re_bitset_ptr_t
operator|)
name|calloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|,
name|BITSET_UINTS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
operator|=
operator|(
name|re_charset_t
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_charset_t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|BE
argument_list|(
name|sbcset
operator|==
name|NULL
operator|||
name|mbcset
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|BE
argument_list|(
name|sbcset
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|token_len
operator|=
name|peek_token_bracket
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|token
operator|->
name|type
operator|==
name|END_OF_RE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_BADPAT
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_NON_MATCH_LIST
condition|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
operator|->
name|non_match
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|non_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|syntax
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
condition|)
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
name|token_len
argument_list|)
expr_stmt|;
comment|/* Skip a token.  */
name|token_len
operator|=
name|peek_token_bracket
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|token
operator|->
name|type
operator|==
name|END_OF_RE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_BADPAT
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
block|}
comment|/* We treat the first ']' as a normal character.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_CLOSE_BRACKET
condition|)
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bracket_elem_t
name|start_elem
decl_stmt|,
name|end_elem
decl_stmt|;
name|unsigned
name|char
name|start_name_buf
index|[
name|BRACKET_NAME_BUF_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|end_name_buf
index|[
name|BRACKET_NAME_BUF_SIZE
index|]
decl_stmt|;
name|reg_errcode_t
name|ret
decl_stmt|;
name|int
name|token_len2
init|=
literal|0
decl_stmt|,
name|is_range_exp
init|=
literal|0
decl_stmt|;
name|re_token_t
name|token2
decl_stmt|;
name|start_elem
operator|.
name|opr
operator|.
name|name
operator|=
name|start_name_buf
expr_stmt|;
name|ret
operator|=
name|parse_bracket_element
argument_list|(
operator|&
name|start_elem
argument_list|,
name|regexp
argument_list|,
name|token
argument_list|,
name|token_len
argument_list|,
name|dfa
argument_list|,
name|syntax
argument_list|,
name|first_round
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|ret
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
name|first_round
operator|=
literal|0
expr_stmt|;
comment|/* Get information about the next token.  We need it in any case.  */
name|token_len
operator|=
name|peek_token_bracket
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
comment|/* Do not check for ranges if we know they are not allowed.  */
if|if
condition|(
name|start_elem
operator|.
name|type
operator|!=
name|CHAR_CLASS
operator|&&
name|start_elem
operator|.
name|type
operator|!=
name|EQUIV_CLASS
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|token
operator|->
name|type
operator|==
name|END_OF_RE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_EBRACK
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_CHARSET_RANGE
condition|)
block|{
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
name|token_len
argument_list|)
expr_stmt|;
comment|/* Skip '-'.  */
name|token_len2
operator|=
name|peek_token_bracket
argument_list|(
operator|&
name|token2
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|token2
operator|.
name|type
operator|==
name|END_OF_RE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_EBRACK
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
if|if
condition|(
name|token2
operator|.
name|type
operator|==
name|OP_CLOSE_BRACKET
condition|)
block|{
comment|/* We treat the last '-' as a normal character.  */
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
operator|-
name|token_len
argument_list|)
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CHARACTER
expr_stmt|;
block|}
else|else
name|is_range_exp
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_range_exp
operator|==
literal|1
condition|)
block|{
name|end_elem
operator|.
name|opr
operator|.
name|name
operator|=
name|end_name_buf
expr_stmt|;
name|ret
operator|=
name|parse_bracket_element
argument_list|(
operator|&
name|end_elem
argument_list|,
name|regexp
argument_list|,
operator|&
name|token2
argument_list|,
name|token_len2
argument_list|,
name|dfa
argument_list|,
name|syntax
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|ret
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
name|token_len
operator|=
name|peek_token_bracket
argument_list|(
name|token
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
operator|*
name|err
operator|=
name|build_range_exp
argument_list|(
name|sbcset
argument_list|,
name|mbcset
argument_list|,
operator|&
name|range_alloc
argument_list|,
operator|&
name|start_elem
argument_list|,
operator|&
name|end_elem
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
operator|*
name|err
operator|=
name|build_range_exp
argument_list|(
name|sbcset
argument_list|,
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|?
name|mbcset
else|:
name|NULL
argument_list|,
operator|&
name|range_alloc
argument_list|,
operator|&
name|start_elem
argument_list|,
operator|&
name|end_elem
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|err
operator|=
name|build_range_exp
argument_list|(
name|sbcset
argument_list|,
operator|&
name|start_elem
argument_list|,
operator|&
name|end_elem
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
else|else
block|{
switch|switch
condition|(
name|start_elem
operator|.
name|type
condition|)
block|{
case|case
name|SB_CHAR
case|:
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|start_elem
operator|.
name|opr
operator|.
name|ch
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
case|case
name|MB_CHAR
case|:
comment|/* Check whether the array has enough space.  */
if|if
condition|(
name|BE
argument_list|(
name|mbchar_alloc
operator|==
name|mbcset
operator|->
name|nmbchars
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|wchar_t
modifier|*
name|new_mbchars
decl_stmt|;
comment|/* Not enough, realloc it.  */
comment|/* +1 in case of mbcset->nmbchars is 0.  */
name|mbchar_alloc
operator|=
literal|2
operator|*
name|mbcset
operator|->
name|nmbchars
operator|+
literal|1
expr_stmt|;
comment|/* Use realloc since array is NULL if *alloc == 0.  */
name|new_mbchars
operator|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|mbchars
argument_list|,
name|wchar_t
argument_list|,
name|mbchar_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_mbchars
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_espace
goto|;
name|mbcset
operator|->
name|mbchars
operator|=
name|new_mbchars
expr_stmt|;
block|}
name|mbcset
operator|->
name|mbchars
index|[
name|mbcset
operator|->
name|nmbchars
operator|++
index|]
operator|=
name|start_elem
operator|.
name|opr
operator|.
name|wch
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
case|case
name|EQUIV_CLASS
case|:
operator|*
name|err
operator|=
name|build_equiv_class
argument_list|(
name|sbcset
argument_list|,
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
argument_list|,
operator|&
name|equiv_class_alloc
argument_list|,
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
name|start_elem
operator|.
name|opr
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_free_return
goto|;
break|break;
case|case
name|COLL_SYM
case|:
operator|*
name|err
operator|=
name|build_collating_symbol
argument_list|(
name|sbcset
argument_list|,
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
argument_list|,
operator|&
name|coll_sym_alloc
argument_list|,
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
name|start_elem
operator|.
name|opr
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_free_return
goto|;
break|break;
case|case
name|CHAR_CLASS
case|:
operator|*
name|err
operator|=
name|build_charclass
argument_list|(
name|regexp
operator|->
name|trans
argument_list|,
name|sbcset
argument_list|,
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
argument_list|,
operator|&
name|char_class_alloc
argument_list|,
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
name|start_elem
operator|.
name|opr
operator|.
name|name
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_free_return
goto|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|BE
argument_list|(
name|token
operator|->
name|type
operator|==
name|END_OF_RE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_EBRACK
expr_stmt|;
goto|goto
name|parse_bracket_exp_free_return
goto|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_CLOSE_BRACKET
condition|)
break|break;
block|}
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
name|token_len
argument_list|)
expr_stmt|;
comment|/* Skip a token.  */
comment|/* If it is non-matching list.  */
if|if
condition|(
name|non_match
condition|)
name|bitset_not
argument_list|(
name|sbcset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* Ensure only single byte characters are set.  */
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|bitset_mask
argument_list|(
name|sbcset
argument_list|,
name|dfa
operator|->
name|sb_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcset
operator|->
name|nmbchars
operator|||
name|mbcset
operator|->
name|ncoll_syms
operator|||
name|mbcset
operator|->
name|nequiv_classes
operator|||
name|mbcset
operator|->
name|nranges
operator|||
operator|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|(
name|mbcset
operator|->
name|nchar_classes
operator|||
name|mbcset
operator|->
name|non_match
operator|)
operator|)
condition|)
block|{
name|bin_tree_t
modifier|*
name|mbc_tree
decl_stmt|;
name|int
name|sbc_idx
decl_stmt|;
comment|/* Build a tree for complex bracket.  */
name|dfa
operator|->
name|has_mb_node
operator|=
literal|1
expr_stmt|;
name|br_token
operator|.
name|type
operator|=
name|COMPLEX_BRACKET
expr_stmt|;
name|br_token
operator|.
name|opr
operator|.
name|mbcset
operator|=
name|mbcset
expr_stmt|;
name|mbc_tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|br_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbc_tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_espace
goto|;
for|for
control|(
name|sbc_idx
operator|=
literal|0
init|;
name|sbc_idx
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|sbc_idx
control|)
if|if
condition|(
name|sbcset
index|[
name|sbc_idx
index|]
condition|)
break|break;
comment|/* If there are no bits set in sbcset, there is no point 	 of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */
if|if
condition|(
name|sbc_idx
operator|<
name|BITSET_UINTS
condition|)
block|{
comment|/* Build a tree for simple bracket.  */
name|br_token
operator|.
name|type
operator|=
name|SIMPLE_BRACKET
expr_stmt|;
name|br_token
operator|.
name|opr
operator|.
name|sbcset
operator|=
name|sbcset
expr_stmt|;
name|work_tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|br_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|work_tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_espace
goto|;
comment|/* Then join them by ALT node.  */
name|work_tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|work_tree
argument_list|,
name|mbc_tree
argument_list|,
name|OP_ALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|work_tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_espace
goto|;
block|}
else|else
block|{
name|re_free
argument_list|(
name|sbcset
argument_list|)
expr_stmt|;
name|work_tree
operator|=
name|mbc_tree
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|free_charset
argument_list|(
name|mbcset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build a tree for simple bracket.  */
name|br_token
operator|.
name|type
operator|=
name|SIMPLE_BRACKET
expr_stmt|;
name|br_token
operator|.
name|opr
operator|.
name|sbcset
operator|=
name|sbcset
expr_stmt|;
name|work_tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|br_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|work_tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|parse_bracket_exp_espace
goto|;
block|}
return|return
name|work_tree
return|;
name|parse_bracket_exp_espace
label|:
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
name|parse_bracket_exp_free_return
label|:
name|re_free
argument_list|(
name|sbcset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|free_charset
argument_list|(
name|mbcset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse an element in the bracket expression.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|parse_bracket_element
parameter_list|(
name|elem
parameter_list|,
name|regexp
parameter_list|,
name|token
parameter_list|,
name|token_len
parameter_list|,
name|dfa
parameter_list|,
name|syntax
parameter_list|,
name|accept_hyphen
parameter_list|)
name|bracket_elem_t
modifier|*
name|elem
decl_stmt|;
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|int
name|token_len
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
name|int
name|accept_hyphen
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|int
name|cur_char_size
decl_stmt|;
name|cur_char_size
operator|=
name|re_string_char_size_at
argument_list|(
name|regexp
argument_list|,
name|re_string_cur_idx
argument_list|(
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_char_size
operator|>
literal|1
condition|)
block|{
name|elem
operator|->
name|type
operator|=
name|MB_CHAR
expr_stmt|;
name|elem
operator|->
name|opr
operator|.
name|wch
operator|=
name|re_string_wchar_at
argument_list|(
name|regexp
argument_list|,
name|re_string_cur_idx
argument_list|(
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
name|cur_char_size
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
name|token_len
argument_list|)
expr_stmt|;
comment|/* Skip a token.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_OPEN_COLL_ELEM
operator|||
name|token
operator|->
name|type
operator|==
name|OP_OPEN_CHAR_CLASS
operator|||
name|token
operator|->
name|type
operator|==
name|OP_OPEN_EQUIV_CLASS
condition|)
return|return
name|parse_bracket_symbol
argument_list|(
name|elem
argument_list|,
name|regexp
argument_list|,
name|token
argument_list|)
return|;
if|if
condition|(
name|BE
argument_list|(
name|token
operator|->
name|type
operator|==
name|OP_CHARSET_RANGE
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|accept_hyphen
condition|)
block|{
comment|/* A '-' must only appear as anything but a range indicator before 	 the closing bracket.  Everything else is an error.  */
name|re_token_t
name|token2
decl_stmt|;
operator|(
name|void
operator|)
name|peek_token_bracket
argument_list|(
operator|&
name|token2
argument_list|,
name|regexp
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|token2
operator|.
name|type
operator|!=
name|OP_CLOSE_BRACKET
condition|)
comment|/* The actual error value is not standardized since this whole 	   case is undefined.  But ERANGE makes good sense.  */
return|return
name|REG_ERANGE
return|;
block|}
name|elem
operator|->
name|type
operator|=
name|SB_CHAR
expr_stmt|;
name|elem
operator|->
name|opr
operator|.
name|ch
operator|=
name|token
operator|->
name|opr
operator|.
name|c
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse a bracket symbol in the bracket expression.  Bracket symbols are    such as [:<character_class>:], [.<collating_element>.], and    [=<equivalent_class>=].  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|parse_bracket_symbol
parameter_list|(
name|elem
parameter_list|,
name|regexp
parameter_list|,
name|token
parameter_list|)
name|bracket_elem_t
modifier|*
name|elem
decl_stmt|;
name|re_string_t
modifier|*
name|regexp
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
block|{
name|unsigned
name|char
name|ch
decl_stmt|,
name|delim
init|=
name|token
operator|->
name|opr
operator|.
name|c
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|re_string_eoi
argument_list|(
name|regexp
argument_list|)
condition|)
return|return
name|REG_EBRACK
return|;
for|for
control|(
init|;
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|BRACKET_NAME_BUF_SIZE
condition|)
return|return
name|REG_EBRACK
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_OPEN_CHAR_CLASS
condition|)
name|ch
operator|=
name|re_string_fetch_byte_case
argument_list|(
name|regexp
argument_list|)
expr_stmt|;
else|else
name|ch
operator|=
name|re_string_fetch_byte
argument_list|(
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_string_eoi
argument_list|(
name|regexp
argument_list|)
condition|)
return|return
name|REG_EBRACK
return|;
if|if
condition|(
name|ch
operator|==
name|delim
operator|&&
name|re_string_peek_byte
argument_list|(
name|regexp
argument_list|,
literal|0
argument_list|)
operator|==
literal|']'
condition|)
break|break;
name|elem
operator|->
name|opr
operator|.
name|name
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|re_string_skip_bytes
argument_list|(
name|regexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elem
operator|->
name|opr
operator|.
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|OP_OPEN_COLL_ELEM
case|:
name|elem
operator|->
name|type
operator|=
name|COLL_SYM
expr_stmt|;
break|break;
case|case
name|OP_OPEN_EQUIV_CLASS
case|:
name|elem
operator|->
name|type
operator|=
name|EQUIV_CLASS
expr_stmt|;
break|break;
case|case
name|OP_OPEN_CHAR_CLASS
case|:
name|elem
operator|->
name|type
operator|=
name|CHAR_CLASS
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for parse_bracket_exp.      Build the equivalence class which is represented by NAME.      The result are written to MBCSET and SBCSET.      EQUIV_CLASS_ALLOC is the allocated size of mbcset->equiv_classes,      is a pointer argument sinse we may update it.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|build_equiv_class
parameter_list|(
name|sbcset
parameter_list|,
name|mbcset
parameter_list|,
name|equiv_class_alloc
parameter_list|,
name|name
parameter_list|)
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
modifier|*
name|equiv_class_alloc
decl_stmt|;
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
function|build_equiv_class
parameter_list|(
name|sbcset
parameter_list|,
name|name
parameter_list|)
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|#
directive|if
name|defined
name|_LIBC
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
specifier|const
name|int32_t
modifier|*
name|table
decl_stmt|,
modifier|*
name|indirect
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|weights
decl_stmt|,
modifier|*
name|extra
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|char
name|char_buf
index|[
literal|2
index|]
decl_stmt|;
name|int32_t
name|idx1
decl_stmt|,
name|idx2
decl_stmt|;
name|unsigned
name|int
name|ch
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* This #include defines a local function!  */
include|#
directive|include
file|<locale/weight.h>
comment|/* Calculate the index for equivalence class.  */
name|cp
operator|=
name|name
expr_stmt|;
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEMB
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAMB
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTMB
argument_list|)
expr_stmt|;
name|idx1
operator|=
name|findidx
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|idx1
operator|==
literal|0
operator|||
name|cp
operator|<
name|name
operator|+
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* This isn't a valid character.  */
return|return
name|REG_ECOLLATE
return|;
comment|/* Build single byte matcing table for this equivalence class.  */
name|char_buf
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|'\0'
expr_stmt|;
name|len
operator|=
name|weights
index|[
name|idx1
index|]
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|SBC_MAX
condition|;
operator|++
name|ch
control|)
block|{
name|char_buf
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|cp
operator|=
name|char_buf
expr_stmt|;
name|idx2
operator|=
name|findidx
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* 	  idx2 = table[ch]; */
if|if
condition|(
name|idx2
operator|==
literal|0
condition|)
comment|/* This isn't a valid character.  */
continue|continue;
if|if
condition|(
name|len
operator|==
name|weights
index|[
name|idx2
index|]
condition|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cnt
operator|<=
name|len
operator|&&
name|weights
index|[
name|idx1
operator|+
literal|1
operator|+
name|cnt
index|]
operator|==
name|weights
index|[
name|idx2
operator|+
literal|1
operator|+
name|cnt
index|]
condition|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|len
condition|)
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check whether the array has enough space.  */
if|if
condition|(
name|BE
argument_list|(
operator|*
name|equiv_class_alloc
operator|==
name|mbcset
operator|->
name|nequiv_classes
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Not enough, realloc it.  */
comment|/* +1 in case of mbcset->nequiv_classes is 0.  */
name|int
name|new_equiv_class_alloc
init|=
literal|2
operator|*
name|mbcset
operator|->
name|nequiv_classes
operator|+
literal|1
decl_stmt|;
comment|/* Use realloc since the array is NULL if *alloc == 0.  */
name|int32_t
modifier|*
name|new_equiv_classes
init|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|equiv_classes
argument_list|,
name|int32_t
argument_list|,
name|new_equiv_class_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_equiv_classes
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mbcset
operator|->
name|equiv_classes
operator|=
name|new_equiv_classes
expr_stmt|;
operator|*
name|equiv_class_alloc
operator|=
name|new_equiv_class_alloc
expr_stmt|;
block|}
name|mbcset
operator|->
name|equiv_classes
index|[
name|mbcset
operator|->
name|nequiv_classes
operator|++
index|]
operator|=
name|idx1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* _LIBC */
block|{
if|if
condition|(
name|BE
argument_list|(
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
operator|!=
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ECOLLATE
return|;
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for parse_bracket_exp.      Build the character class which is represented by NAME.      The result are written to MBCSET and SBCSET.      CHAR_CLASS_ALLOC is the allocated size of mbcset->char_classes,      is a pointer argument sinse we may update it.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|build_charclass
parameter_list|(
name|trans
parameter_list|,
name|sbcset
parameter_list|,
name|mbcset
parameter_list|,
name|char_class_alloc
parameter_list|,
name|class_name
parameter_list|,
name|syntax
parameter_list|)
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
modifier|*
name|char_class_alloc
decl_stmt|;
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
function|build_charclass
parameter_list|(
name|trans
parameter_list|,
name|sbcset
parameter_list|,
name|class_name
parameter_list|,
name|syntax
parameter_list|)
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|unsigned
name|RE_TRANSLATE_TYPE
name|trans
decl_stmt|;
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|class_name
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|class_name
decl_stmt|;
comment|/* In case of REG_ICASE "upper" and "lower" match the both of      upper and lower cases.  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_ICASE
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"upper"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"lower"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|name
operator|=
literal|"alpha"
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* Check the space of the arrays.  */
if|if
condition|(
name|BE
argument_list|(
operator|*
name|char_class_alloc
operator|==
name|mbcset
operator|->
name|nchar_classes
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Not enough, realloc it.  */
comment|/* +1 in case of mbcset->nchar_classes is 0.  */
name|int
name|new_char_class_alloc
init|=
literal|2
operator|*
name|mbcset
operator|->
name|nchar_classes
operator|+
literal|1
decl_stmt|;
comment|/* Use realloc since array is NULL if *alloc == 0.  */
name|wctype_t
modifier|*
name|new_char_classes
init|=
name|re_realloc
argument_list|(
name|mbcset
operator|->
name|char_classes
argument_list|,
name|wctype_t
argument_list|,
name|new_char_class_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_char_classes
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mbcset
operator|->
name|char_classes
operator|=
name|new_char_classes
expr_stmt|;
operator|*
name|char_class_alloc
operator|=
name|new_char_class_alloc
expr_stmt|;
block|}
name|mbcset
operator|->
name|char_classes
index|[
name|mbcset
operator|->
name|nchar_classes
operator|++
index|]
operator|=
name|__wctype
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
define|#
directive|define
name|BUILD_CHARCLASS_LOOP
parameter_list|(
name|ctype_func
parameter_list|)
define|\
value|for (i = 0; i< SBC_MAX; ++i)		\       {						\ 	if (ctype_func (i))			\ 	  {					\ 	    int ch = trans ? trans[i] : i;	\ 	    bitset_set (sbcset, ch);		\ 	  }					\       }
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alnum"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isalnum
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"cntrl"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|iscntrl
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"lower"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|islower
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isspace
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alpha"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isalpha
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"digit"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isdigit
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"print"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isprint
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"upper"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isupper
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"blank"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isblank
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"graph"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isgraph
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"punct"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|ispunct
argument_list|)
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"xdigit"
argument_list|)
operator|==
literal|0
condition|)
name|BUILD_CHARCLASS_LOOP
argument_list|(
argument|isxdigit
argument_list|)
else|else
return|return
name|REG_ECTYPE
return|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|build_charclass_op
parameter_list|(
name|dfa
parameter_list|,
name|trans
parameter_list|,
name|class_name
parameter_list|,
name|extra
parameter_list|,
name|non_match
parameter_list|,
name|err
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|unsigned
name|RE_TRANSLATE_TYPE
name|trans
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|class_name
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
name|int
name|non_match
decl_stmt|;
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
block|{
name|re_bitset_ptr_t
name|sbcset
decl_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|re_charset_t
modifier|*
name|mbcset
decl_stmt|;
name|int
name|alloc
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|reg_errcode_t
name|ret
decl_stmt|;
name|re_token_t
name|br_token
decl_stmt|;
name|bin_tree_t
modifier|*
name|tree
decl_stmt|;
name|sbcset
operator|=
operator|(
name|re_bitset_ptr_t
operator|)
name|calloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|,
name|BITSET_UINTS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
operator|=
operator|(
name|re_charset_t
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_charset_t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|BE
argument_list|(
name|sbcset
operator|==
name|NULL
operator|||
name|mbcset
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
if|if
condition|(
name|BE
argument_list|(
name|sbcset
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|non_match
condition|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/*       if (syntax& RE_HAT_LISTS_NOT_NEWLINE) 	bitset_set(cset->sbcset, '\0');       */
name|mbcset
operator|->
name|non_match
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
block|}
comment|/* We don't care the syntax in this case.  */
name|ret
operator|=
name|build_charclass
argument_list|(
name|trans
argument_list|,
name|sbcset
argument_list|,
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|mbcset
argument_list|,
operator|&
name|alloc
argument_list|,
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
name|class_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_free
argument_list|(
name|sbcset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|free_charset
argument_list|(
name|mbcset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
operator|*
name|err
operator|=
name|ret
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* \w match '_' also.  */
for|for
control|(
init|;
operator|*
name|extra
condition|;
name|extra
operator|++
control|)
name|bitset_set
argument_list|(
name|sbcset
argument_list|,
operator|*
name|extra
argument_list|)
expr_stmt|;
comment|/* If it is non-matching list.  */
if|if
condition|(
name|non_match
condition|)
name|bitset_not
argument_list|(
name|sbcset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* Ensure only single byte characters are set.  */
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|bitset_mask
argument_list|(
name|sbcset
argument_list|,
name|dfa
operator|->
name|sb_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build a tree for simple bracket.  */
name|br_token
operator|.
name|type
operator|=
name|SIMPLE_BRACKET
expr_stmt|;
name|br_token
operator|.
name|opr
operator|.
name|sbcset
operator|=
name|sbcset
expr_stmt|;
name|tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|br_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|build_word_op_espace
goto|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|bin_tree_t
modifier|*
name|mbc_tree
decl_stmt|;
comment|/* Build a tree for complex bracket.  */
name|br_token
operator|.
name|type
operator|=
name|COMPLEX_BRACKET
expr_stmt|;
name|br_token
operator|.
name|opr
operator|.
name|mbcset
operator|=
name|mbcset
expr_stmt|;
name|dfa
operator|->
name|has_mb_node
operator|=
literal|1
expr_stmt|;
name|mbc_tree
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|br_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbc_tree
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|build_word_op_espace
goto|;
comment|/* Then join them by ALT node.  */
name|tree
operator|=
name|create_tree
argument_list|(
name|dfa
argument_list|,
name|tree
argument_list|,
name|mbc_tree
argument_list|,
name|OP_ALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbc_tree
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|tree
return|;
block|}
else|else
block|{
name|free_charset
argument_list|(
name|mbcset
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
else|#
directive|else
comment|/* not RE_ENABLE_I18N */
return|return
name|tree
return|;
endif|#
directive|endif
comment|/* not RE_ENABLE_I18N */
name|build_word_op_espace
label|:
name|re_free
argument_list|(
name|sbcset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|free_charset
argument_list|(
name|mbcset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This is intended for the expressions like "a{1,3}".    Fetch a number from `input', and return the number.    Return -1, if the number field is empty like "{,1}".    Return -2, If an error is occured.  */
end_comment

begin_function
specifier|static
name|int
name|fetch_number
parameter_list|(
name|input
parameter_list|,
name|token
parameter_list|,
name|syntax
parameter_list|)
name|re_string_t
modifier|*
name|input
decl_stmt|;
name|re_token_t
modifier|*
name|token
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
block|{
name|int
name|num
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fetch_token
argument_list|(
name|token
argument_list|,
name|input
argument_list|,
name|syntax
argument_list|)
expr_stmt|;
name|c
operator|=
name|token
operator|->
name|opr
operator|.
name|c
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|token
operator|->
name|type
operator|==
name|END_OF_RE
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|OP_CLOSE_DUP_NUM
operator|||
name|c
operator|==
literal|','
condition|)
break|break;
name|num
operator|=
operator|(
operator|(
name|token
operator|->
name|type
operator|!=
name|CHARACTER
operator|||
name|c
operator|<
literal|'0'
operator|||
literal|'9'
operator|<
name|c
operator|||
name|num
operator|==
operator|-
literal|2
operator|)
condition|?
operator|-
literal|2
else|:
operator|(
operator|(
name|num
operator|==
operator|-
literal|1
operator|)
condition|?
name|c
operator|-
literal|'0'
else|:
name|num
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
operator|)
operator|)
expr_stmt|;
name|num
operator|=
operator|(
name|num
operator|>
name|RE_DUP_MAX
operator|)
condition|?
operator|-
literal|2
else|:
name|num
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function
specifier|static
name|void
name|free_charset
parameter_list|(
name|re_charset_t
modifier|*
name|cset
parameter_list|)
block|{
name|re_free
argument_list|(
name|cset
operator|->
name|mbchars
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|re_free
argument_list|(
name|cset
operator|->
name|coll_syms
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|cset
operator|->
name|equiv_classes
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|cset
operator|->
name|range_starts
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|cset
operator|->
name|range_ends
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|re_free
argument_list|(
name|cset
operator|->
name|char_classes
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|cset
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Functions for binary tree operation.  */
end_comment

begin_comment
comment|/* Create a tree node.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|create_tree
parameter_list|(
name|dfa
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|,
name|type
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|bin_tree_t
modifier|*
name|left
decl_stmt|;
name|bin_tree_t
modifier|*
name|right
decl_stmt|;
name|re_token_type_t
name|type
decl_stmt|;
block|{
name|re_token_t
name|t
decl_stmt|;
name|t
operator|.
name|type
operator|=
name|type
expr_stmt|;
return|return
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
operator|&
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|create_token_tree
parameter_list|(
name|dfa
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|,
name|token
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|bin_tree_t
modifier|*
name|left
decl_stmt|;
name|bin_tree_t
modifier|*
name|right
decl_stmt|;
specifier|const
name|re_token_t
modifier|*
name|token
decl_stmt|;
block|{
name|bin_tree_t
modifier|*
name|tree
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|str_tree_storage_idx
operator|==
name|BIN_TREE_STORAGE_SIZE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bin_tree_storage_t
modifier|*
name|storage
init|=
name|re_malloc
argument_list|(
name|bin_tree_storage_t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|storage
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|storage
operator|->
name|next
operator|=
name|dfa
operator|->
name|str_tree_storage
expr_stmt|;
name|dfa
operator|->
name|str_tree_storage
operator|=
name|storage
expr_stmt|;
name|dfa
operator|->
name|str_tree_storage_idx
operator|=
literal|0
expr_stmt|;
block|}
name|tree
operator|=
operator|&
name|dfa
operator|->
name|str_tree_storage
operator|->
name|data
index|[
name|dfa
operator|->
name|str_tree_storage_idx
operator|++
index|]
expr_stmt|;
name|tree
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|right
expr_stmt|;
name|tree
operator|->
name|token
operator|=
operator|*
name|token
expr_stmt|;
name|tree
operator|->
name|token
operator|.
name|duplicated
operator|=
literal|0
expr_stmt|;
name|tree
operator|->
name|token
operator|.
name|opt_subexp
operator|=
literal|0
expr_stmt|;
name|tree
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|node_idx
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|NULL
condition|)
name|left
operator|->
name|parent
operator|=
name|tree
expr_stmt|;
if|if
condition|(
name|right
operator|!=
name|NULL
condition|)
name|right
operator|->
name|parent
operator|=
name|tree
expr_stmt|;
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/* Mark the tree SRC as an optional subexpression.    To be called from preorder or postorder.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|mark_opt_subexp
parameter_list|(
name|extra
parameter_list|,
name|node
parameter_list|)
name|void
modifier|*
name|extra
decl_stmt|;
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|idx
init|=
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|extra
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|token
operator|.
name|type
operator|==
name|SUBEXP
operator|&&
name|node
operator|->
name|token
operator|.
name|opr
operator|.
name|idx
operator|==
name|idx
condition|)
name|node
operator|->
name|token
operator|.
name|opt_subexp
operator|=
literal|1
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Free the allocated memory inside NODE. */
end_comment

begin_function
specifier|static
name|void
name|free_token
parameter_list|(
name|re_token_t
modifier|*
name|node
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|COMPLEX_BRACKET
operator|&&
name|node
operator|->
name|duplicated
operator|==
literal|0
condition|)
name|free_charset
argument_list|(
name|node
operator|->
name|opr
operator|.
name|mbcset
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|SIMPLE_BRACKET
operator|&&
name|node
operator|->
name|duplicated
operator|==
literal|0
condition|)
name|re_free
argument_list|(
name|node
operator|->
name|opr
operator|.
name|sbcset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for tree walking.  Free the allocated memory inside NODE    and its children. */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|free_tree
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|,
name|bin_tree_t
modifier|*
name|node
parameter_list|)
block|{
name|free_token
argument_list|(
operator|&
name|node
operator|->
name|token
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Duplicate the node SRC, and return new node.  This is a preorder    visit similar to the one implemented by the generic visitor, but    we need more infrastructure to maintain two parallel trees --- so,    it's easier to duplicate.  */
end_comment

begin_function
specifier|static
name|bin_tree_t
modifier|*
name|duplicate_tree
parameter_list|(
name|root
parameter_list|,
name|dfa
parameter_list|)
specifier|const
name|bin_tree_t
modifier|*
name|root
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
specifier|const
name|bin_tree_t
modifier|*
name|node
decl_stmt|;
name|bin_tree_t
modifier|*
name|dup_root
decl_stmt|;
name|bin_tree_t
modifier|*
modifier|*
name|p_new
init|=
operator|&
name|dup_root
decl_stmt|,
modifier|*
name|dup_node
init|=
name|root
operator|->
name|parent
decl_stmt|;
for|for
control|(
name|node
operator|=
name|root
init|;
condition|;
control|)
block|{
comment|/* Create a new tree and link it back to the current parent.  */
operator|*
name|p_new
operator|=
name|create_token_tree
argument_list|(
name|dfa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p_new
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
operator|*
name|p_new
operator|)
operator|->
name|parent
operator|=
name|dup_node
expr_stmt|;
operator|(
operator|*
name|p_new
operator|)
operator|->
name|token
operator|.
name|duplicated
operator|=
literal|1
expr_stmt|;
name|dup_node
operator|=
operator|*
name|p_new
expr_stmt|;
comment|/* Go to the left node, or up and to the right.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
name|p_new
operator|=
operator|&
name|dup_node
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|bin_tree_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|node
operator|->
name|right
operator|==
name|prev
operator|||
name|node
operator|->
name|right
operator|==
name|NULL
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|dup_node
operator|=
name|dup_node
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|dup_root
return|;
block|}
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
name|p_new
operator|=
operator|&
name|dup_node
operator|->
name|right
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

