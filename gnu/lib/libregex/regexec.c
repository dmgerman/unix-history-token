begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Contributed by Isamu Hasegawa<isamu@yamato.ibm.com>.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, write to the Free    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA    02111-1307 USA.  */
end_comment

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|match_ctx_init
argument_list|(
name|re_match_context_t
operator|*
name|cache
argument_list|,
name|int
name|eflags
argument_list|,
name|int
name|n
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|match_ctx_clean
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|match_ctx_free
argument_list|(
name|re_match_context_t
operator|*
name|cache
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|match_ctx_add_entry
argument_list|(
name|re_match_context_t
operator|*
name|cache
argument_list|,
name|int
name|node
argument_list|,
name|int
name|str_idx
argument_list|,
name|int
name|from
argument_list|,
name|int
name|to
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|search_cur_bkref_entry
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|match_ctx_add_subtop
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|node
argument_list|,
name|int
name|str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|re_sub_match_last_t
modifier|*
name|match_ctx_add_sublast
argument_list|(
name|re_sub_match_top_t
operator|*
name|subtop
argument_list|,
name|int
name|node
argument_list|,
name|int
name|str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sift_ctx_init
argument_list|(
name|re_sift_context_t
operator|*
name|sctx
argument_list|,
name|re_dfastate_t
operator|*
operator|*
name|sifted_sts
argument_list|,
name|re_dfastate_t
operator|*
operator|*
name|limited_sts
argument_list|,
name|int
name|last_node
argument_list|,
name|int
name|last_str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|re_search_internal
argument_list|(
specifier|const
name|regex_t
operator|*
name|preg
argument_list|,
specifier|const
name|char
operator|*
name|string
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start
argument_list|,
name|int
name|range
argument_list|,
name|int
name|stop
argument_list|,
name|size_t
name|nmatch
argument_list|,
name|regmatch_t
name|pmatch
index|[]
argument_list|,
name|int
name|eflags
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re_search_2_stub
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|bufp
argument_list|,
specifier|const
name|char
operator|*
name|string1
argument_list|,
name|int
name|length1
argument_list|,
specifier|const
name|char
operator|*
name|string2
argument_list|,
name|int
name|length2
argument_list|,
name|int
name|start
argument_list|,
name|int
name|range
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|stop
argument_list|,
name|int
name|ret_len
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re_search_stub
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|bufp
argument_list|,
specifier|const
name|char
operator|*
name|string
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start
argument_list|,
name|int
name|range
argument_list|,
name|int
name|stop
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|ret_len
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|re_copy_regs
argument_list|(
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|regmatch_t
operator|*
name|pmatch
argument_list|,
name|int
name|nregs
argument_list|,
name|int
name|regs_allocated
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|re_dfastate_t
modifier|*
name|acquire_init_state_context
argument_list|(
name|reg_errcode_t
operator|*
name|err
argument_list|,
specifier|const
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|idx
argument_list|)
name|__attribute
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|prune_impossible_nodes
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_matching
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|fl_longest_match
argument_list|,
name|int
operator|*
name|p_match_first
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_halt_node_context
argument_list|(
specifier|const
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|int
name|node
argument_list|,
name|unsigned
name|int
name|context
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_halt_state_context
argument_list|(
specifier|const
name|re_match_context_t
operator|*
name|mctx
argument_list|,
specifier|const
name|re_dfastate_t
operator|*
name|state
argument_list|,
name|int
name|idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_regs
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|regmatch_t
operator|*
name|pmatch
argument_list|,
name|regmatch_t
operator|*
name|prev_idx_match
argument_list|,
name|int
name|cur_node
argument_list|,
name|int
name|cur_idx
argument_list|,
name|int
name|nmatch
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|proceed_next_node
argument_list|(
specifier|const
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|nregs
argument_list|,
name|regmatch_t
operator|*
name|regs
argument_list|,
name|int
operator|*
name|pidx
argument_list|,
name|int
name|node
argument_list|,
name|re_node_set
operator|*
name|eps_via_nodes
argument_list|,
expr|struct
name|re_fail_stack_t
operator|*
name|fs
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|push_fail_stack
argument_list|(
expr|struct
name|re_fail_stack_t
operator|*
name|fs
argument_list|,
name|int
name|str_idx
argument_list|,
name|int
name|dest_node
argument_list|,
name|int
name|nregs
argument_list|,
name|regmatch_t
operator|*
name|regs
argument_list|,
name|re_node_set
operator|*
name|eps_via_nodes
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_fail_stack
argument_list|(
expr|struct
name|re_fail_stack_t
operator|*
name|fs
argument_list|,
name|int
operator|*
name|pidx
argument_list|,
name|int
name|nregs
argument_list|,
name|regmatch_t
operator|*
name|regs
argument_list|,
name|re_node_set
operator|*
name|eps_via_nodes
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|set_regs
argument_list|(
specifier|const
name|regex_t
operator|*
name|preg
argument_list|,
specifier|const
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|size_t
name|nmatch
argument_list|,
name|regmatch_t
operator|*
name|pmatch
argument_list|,
name|int
name|fl_backtrack
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|free_fail_stack_return
argument_list|(
expr|struct
name|re_fail_stack_t
operator|*
name|fs
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sift_states_iter_mb
argument_list|(
specifier|const
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_sift_context_t
operator|*
name|sctx
argument_list|,
name|int
name|node_idx
argument_list|,
name|int
name|str_idx
argument_list|,
name|int
name|max_str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|sift_states_backward
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_sift_context_t
operator|*
name|sctx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|build_sifted_states
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_sift_context_t
operator|*
name|sctx
argument_list|,
name|int
name|str_idx
argument_list|,
name|re_node_set
operator|*
name|cur_dest
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|update_cur_sifted_state
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_sift_context_t
operator|*
name|sctx
argument_list|,
name|int
name|str_idx
argument_list|,
name|re_node_set
operator|*
name|dest_nodes
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|add_epsilon_src_nodes
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_node_set
operator|*
name|dest_nodes
argument_list|,
specifier|const
name|re_node_set
operator|*
name|candidates
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|sub_epsilon_src_nodes
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|int
name|node
argument_list|,
name|re_node_set
operator|*
name|dest_nodes
argument_list|,
specifier|const
name|re_node_set
operator|*
name|and_nodes
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dst_limits
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_node_set
operator|*
name|limits
argument_list|,
name|int
name|dst_node
argument_list|,
name|int
name|dst_idx
argument_list|,
name|int
name|src_node
argument_list|,
name|int
name|src_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dst_limits_calc_pos_1
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|boundaries
argument_list|,
name|int
name|subexp_idx
argument_list|,
name|int
name|from_node
argument_list|,
name|int
name|bkref_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dst_limits_calc_pos
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|limit
argument_list|,
name|int
name|subexp_idx
argument_list|,
name|int
name|node
argument_list|,
name|int
name|str_idx
argument_list|,
name|int
name|bkref_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|check_subexp_limits
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_node_set
operator|*
name|dest_nodes
argument_list|,
specifier|const
name|re_node_set
operator|*
name|candidates
argument_list|,
name|re_node_set
operator|*
name|limits
argument_list|,
expr|struct
name|re_backref_cache_entry
operator|*
name|bkref_ents
argument_list|,
name|int
name|str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|sift_states_bkref
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_sift_context_t
operator|*
name|sctx
argument_list|,
name|int
name|str_idx
argument_list|,
specifier|const
name|re_node_set
operator|*
name|candidates
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|clean_state_log_if_needed
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|next_state_log_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|merge_state_array
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_dfastate_t
operator|*
operator|*
name|dst
argument_list|,
name|re_dfastate_t
operator|*
operator|*
name|src
argument_list|,
name|int
name|num
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|re_dfastate_t
modifier|*
name|find_recover_state
argument_list|(
name|reg_errcode_t
operator|*
name|err
argument_list|,
name|re_match_context_t
operator|*
name|mctx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|re_dfastate_t
modifier|*
name|transit_state
argument_list|(
name|reg_errcode_t
operator|*
name|err
argument_list|,
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_dfastate_t
operator|*
name|state
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|re_dfastate_t
modifier|*
name|merge_state_with_log
argument_list|(
name|reg_errcode_t
operator|*
name|err
argument_list|,
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_dfastate_t
operator|*
name|next_state
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|check_subexp_matching_top
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_node_set
operator|*
name|cur_nodes
argument_list|,
name|int
name|str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static re_dfastate_t *transit_state_sb (reg_errcode_t *err, 					re_match_context_t *mctx, 					re_dfastate_t *pstate) internal_function;
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|transit_state_mb
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_dfastate_t
operator|*
name|pstate
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|transit_state_bkref
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
specifier|const
name|re_node_set
operator|*
name|nodes
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|get_subexp
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|bkref_node
argument_list|,
name|int
name|bkref_str_idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|get_subexp_sub
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
specifier|const
name|re_sub_match_top_t
operator|*
name|sub_top
argument_list|,
name|re_sub_match_last_t
operator|*
name|sub_last
argument_list|,
name|int
name|bkref_node
argument_list|,
name|int
name|bkref_str
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_subexp_node
argument_list|(
specifier|const
name|re_dfa_t
operator|*
name|dfa
argument_list|,
specifier|const
name|re_node_set
operator|*
name|nodes
argument_list|,
name|int
name|subexp_idx
argument_list|,
name|int
name|type
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|check_arrival
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|state_array_t
operator|*
name|path
argument_list|,
name|int
name|top_node
argument_list|,
name|int
name|top_str
argument_list|,
name|int
name|last_node
argument_list|,
name|int
name|last_str
argument_list|,
name|int
name|type
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|check_arrival_add_next_nodes
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|int
name|str_idx
argument_list|,
name|re_node_set
operator|*
name|cur_nodes
argument_list|,
name|re_node_set
operator|*
name|next_nodes
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|check_arrival_expand_ecl
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_node_set
operator|*
name|cur_nodes
argument_list|,
name|int
name|ex_subexp
argument_list|,
name|int
name|type
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|check_arrival_expand_ecl_sub
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_node_set
operator|*
name|dst_nodes
argument_list|,
name|int
name|target
argument_list|,
name|int
name|ex_subexp
argument_list|,
name|int
name|type
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|expand_bkref_cache
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|,
name|re_node_set
operator|*
name|cur_nodes
argument_list|,
name|int
name|cur_str
argument_list|,
name|int
name|subexp_num
argument_list|,
name|int
name|type
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_trtable
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_dfastate_t
operator|*
name|state
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|check_node_accept_bytes
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|int
name|node_idx
argument_list|,
specifier|const
name|re_string_t
operator|*
name|input
argument_list|,
name|int
name|idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|find_collation_sequence_value
argument_list|(
specifier|const
name|unsigned
name|char
operator|*
name|mbs
argument_list|,
name|size_t
name|name_len
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_decl_stmt
specifier|static
name|int
name|group_nodes_into_DFAstates
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
specifier|const
name|re_dfastate_t
operator|*
name|state
argument_list|,
name|re_node_set
operator|*
name|states_node
argument_list|,
name|bitset
operator|*
name|states_ch
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_node_accept
argument_list|(
specifier|const
name|re_match_context_t
operator|*
name|mctx
argument_list|,
specifier|const
name|re_token_t
operator|*
name|node
argument_list|,
name|int
name|idx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|extend_buffers
argument_list|(
name|re_match_context_t
operator|*
name|mctx
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Entry point for POSIX code.  */
end_comment

begin_comment
comment|/* regexec searches for a given pattern, specified by PREG, in the    string STRING.     If NMATCH is zero or REG_NOSUB was set in the cflags argument to    `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at    least NMATCH elements, and we set them to the offsets of the    corresponding matched substrings.     EFLAGS specifies `execution flags' which affect matching: if    REG_NOTBOL is set, then ^ does not match at the beginning of the    string; if REG_NOTEOL is set, then $ does not match at the end.     We return 0 if we find a match and REG_NOMATCH if not.  */
end_comment

begin_function
name|int
name|regexec
parameter_list|(
name|preg
parameter_list|,
name|string
parameter_list|,
name|nmatch
parameter_list|,
name|pmatch
parameter_list|,
name|eflags
parameter_list|)
specifier|const
name|regex_t
modifier|*
name|__restrict
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|__restrict
name|string
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|regmatch_t
name|pmatch
index|[]
decl_stmt|;
name|int
name|eflags
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|start
decl_stmt|,
name|length
decl_stmt|;
if|if
condition|(
name|eflags
operator|&
operator|~
operator|(
name|REG_NOTBOL
operator||
name|REG_NOTEOL
operator||
name|REG_STARTEND
operator|)
condition|)
return|return
name|REG_BADPAT
return|;
if|if
condition|(
name|eflags
operator|&
name|REG_STARTEND
condition|)
block|{
name|start
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
name|length
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preg
operator|->
name|no_sub
condition|)
name|err
operator|=
name|re_search_internal
argument_list|(
name|preg
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|start
argument_list|,
name|length
operator|-
name|start
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|re_search_internal
argument_list|(
name|preg
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|start
argument_list|,
name|length
operator|-
name|start
argument_list|,
name|length
argument_list|,
name|nmatch
argument_list|,
name|pmatch
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
return|return
name|err
operator|!=
name|REG_NOERROR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<shlib-compat.h>
end_include

begin_expr_stmt
name|versioned_symbol
argument_list|(
name|libc
argument_list|,
name|__regexec
argument_list|,
name|regexec
argument_list|,
name|GLIBC_2_3_4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|SHLIB_COMPAT
argument_list|(
name|libc
operator|,
name|GLIBC_2_0
operator|,
name|GLIBC_2_3_4
argument_list|)
end_if

begin_macro
name|__typeof__
argument_list|(
argument|__regexec
argument_list|)
end_macro

begin_expr_stmt
name|__compat_regexec
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|attribute_compat_text_section
name|__compat_regexec
parameter_list|(
specifier|const
name|regex_t
modifier|*
name|__restrict
name|preg
parameter_list|,
specifier|const
name|char
modifier|*
name|__restrict
name|string
parameter_list|,
name|size_t
name|nmatch
parameter_list|,
name|regmatch_t
name|pmatch
index|[]
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
return|return
name|regexec
argument_list|(
name|preg
argument_list|,
name|string
argument_list|,
name|nmatch
argument_list|,
name|pmatch
argument_list|,
name|eflags
operator|&
operator|(
name|REG_NOTBOL
operator||
name|REG_NOTEOL
operator|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|compat_symbol
argument_list|(
name|libc
argument_list|,
name|__compat_regexec
argument_list|,
name|regexec
argument_list|,
name|GLIBC_2_0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Entry points for GNU code.  */
end_comment

begin_comment
comment|/* re_match, re_search, re_match_2, re_search_2     The former two functions operate on STRING with length LENGTH,    while the later two operate on concatenation of STRING1 and STRING2    with lengths LENGTH1 and LENGTH2, respectively.     re_match() matches the compiled pattern in BUFP against the string,    starting at index START.     re_search() first tries matching at index START, then it tries to match    starting from index START + 1, and so on.  The last start position tried    is START + RANGE.  (Thus RANGE = 0 forces re_search to operate the same    way as re_match().)     The parameter STOP of re_{match,search}_2 specifies that no match exceeding    the first STOP characters of the concatenation of the strings should be    concerned.     If REGS is not NULL, and BUFP->no_sub is not set, the offsets of the match    and all groups is stroed in REGS.  (For the "_2" variants, the offsets are    computed relative to the concatenation, not relative to the individual    strings.)     On success, re_match* functions return the length of the match, re_search*    return the position of the start of the match.  Return value -1 means no    match was found and -2 indicates an internal error.  */
end_comment

begin_function
name|int
name|re_match
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|start
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|,
name|start
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_search_stub
argument_list|(
name|bufp
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|regs
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_match
argument_list|,
argument|re_match
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|re_search
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|start
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|,
name|start
decl_stmt|,
name|range
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_search_stub
argument_list|(
name|bufp
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|start
argument_list|,
name|range
argument_list|,
name|length
argument_list|,
name|regs
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_search
argument_list|,
argument|re_search
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|re_match_2
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|length1
parameter_list|,
name|string2
parameter_list|,
name|length2
parameter_list|,
name|start
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|length1
decl_stmt|,
name|length2
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|re_search_2_stub
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|length1
argument_list|,
name|string2
argument_list|,
name|length2
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_match_2
argument_list|,
argument|re_match_2
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|re_search_2
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|length1
parameter_list|,
name|string2
parameter_list|,
name|length2
parameter_list|,
name|start
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|length1
decl_stmt|,
name|length2
decl_stmt|,
name|start
decl_stmt|,
name|range
decl_stmt|,
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|re_search_2_stub
argument_list|(
name|bufp
argument_list|,
name|string1
argument_list|,
name|length1
argument_list|,
name|string2
argument_list|,
name|length2
argument_list|,
name|start
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_search_2
argument_list|,
argument|re_search_2
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|re_search_2_stub
parameter_list|(
name|bufp
parameter_list|,
name|string1
parameter_list|,
name|length1
parameter_list|,
name|string2
parameter_list|,
name|length2
parameter_list|,
name|start
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|,
name|stop
parameter_list|,
name|ret_len
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|length1
decl_stmt|,
name|length2
decl_stmt|,
name|start
decl_stmt|,
name|range
decl_stmt|,
name|stop
decl_stmt|,
name|ret_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|len
init|=
name|length1
operator|+
name|length2
decl_stmt|;
name|int
name|free_str
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|length1
operator|<
literal|0
operator|||
name|length2
operator|<
literal|0
operator|||
name|stop
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
comment|/* Concatenate the strings.  */
if|if
condition|(
name|length2
operator|>
literal|0
condition|)
if|if
condition|(
name|length1
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|re_malloc
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|s
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|string1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|+
name|length1
argument_list|,
name|string2
argument_list|,
name|length2
argument_list|)
expr_stmt|;
name|str
operator|=
name|s
expr_stmt|;
name|free_str
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|str
operator|=
name|string2
expr_stmt|;
else|else
name|str
operator|=
name|string1
expr_stmt|;
name|rval
operator|=
name|re_search_stub
argument_list|(
name|bufp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|start
argument_list|,
name|range
argument_list|,
name|stop
argument_list|,
name|regs
argument_list|,
name|ret_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_str
condition|)
name|re_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* The parameters have the same meaning as those of re_search.    Additional parameters:    If RET_LEN is nonzero the length of the match is returned (re_match style);    otherwise the position of the match is returned.  */
end_comment

begin_function
specifier|static
name|int
name|re_search_stub
parameter_list|(
name|bufp
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|start
parameter_list|,
name|range
parameter_list|,
name|stop
parameter_list|,
name|regs
parameter_list|,
name|ret_len
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|,
name|start
decl_stmt|,
name|range
decl_stmt|,
name|stop
decl_stmt|,
name|ret_len
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
name|reg_errcode_t
name|result
decl_stmt|;
name|regmatch_t
modifier|*
name|pmatch
decl_stmt|;
name|int
name|nregs
decl_stmt|,
name|rval
decl_stmt|;
name|int
name|eflags
init|=
literal|0
decl_stmt|;
comment|/* Check for out-of-range.  */
if|if
condition|(
name|BE
argument_list|(
name|start
operator|<
literal|0
operator|||
name|start
operator|>
name|length
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|BE
argument_list|(
name|start
operator|+
name|range
operator|>
name|length
argument_list|,
literal|0
argument_list|)
condition|)
name|range
operator|=
name|length
operator|-
name|start
expr_stmt|;
elseif|else
if|if
condition|(
name|BE
argument_list|(
name|start
operator|+
name|range
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|range
operator|=
operator|-
name|start
expr_stmt|;
name|eflags
operator||=
operator|(
name|bufp
operator|->
name|not_bol
operator|)
condition|?
name|REG_NOTBOL
else|:
literal|0
expr_stmt|;
name|eflags
operator||=
operator|(
name|bufp
operator|->
name|not_eol
operator|)
condition|?
name|REG_NOTEOL
else|:
literal|0
expr_stmt|;
comment|/* Compile fastmap if we haven't yet.  */
if|if
condition|(
name|range
operator|>
literal|0
operator|&&
name|bufp
operator|->
name|fastmap
operator|!=
name|NULL
operator|&&
operator|!
name|bufp
operator|->
name|fastmap_accurate
condition|)
name|re_compile_fastmap
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|bufp
operator|->
name|no_sub
argument_list|,
literal|0
argument_list|)
condition|)
name|regs
operator|=
name|NULL
expr_stmt|;
comment|/* We need at least 1 register.  */
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
name|nregs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|BE
argument_list|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_FIXED
operator|&&
name|regs
operator|->
name|num_regs
operator|<
name|bufp
operator|->
name|re_nsub
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|nregs
operator|=
name|regs
operator|->
name|num_regs
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|nregs
operator|<
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Nothing can be copied to regs.  */
name|regs
operator|=
name|NULL
expr_stmt|;
name|nregs
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|nregs
operator|=
name|bufp
operator|->
name|re_nsub
operator|+
literal|1
expr_stmt|;
name|pmatch
operator|=
name|re_malloc
argument_list|(
name|regmatch_t
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pmatch
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|result
operator|=
name|re_search_internal
argument_list|(
name|bufp
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|start
argument_list|,
name|range
argument_list|,
name|stop
argument_list|,
name|nregs
argument_list|,
name|pmatch
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
comment|/* I hope we needn't fill ther regs with -1's when no match was found.  */
if|if
condition|(
name|result
operator|!=
name|REG_NOERROR
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|regs
operator|!=
name|NULL
condition|)
block|{
comment|/* If caller wants register contents data back, copy them.  */
name|bufp
operator|->
name|regs_allocated
operator|=
name|re_copy_regs
argument_list|(
name|regs
argument_list|,
name|pmatch
argument_list|,
name|nregs
argument_list|,
name|bufp
operator|->
name|regs_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|bufp
operator|->
name|regs_allocated
operator|==
name|REGS_UNALLOCATED
argument_list|,
literal|0
argument_list|)
condition|)
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|rval
operator|==
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret_len
condition|)
block|{
name|assert
argument_list|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
name|start
argument_list|)
expr_stmt|;
name|rval
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|-
name|start
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
block|}
name|re_free
argument_list|(
name|pmatch
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|re_copy_regs
parameter_list|(
name|regs
parameter_list|,
name|pmatch
parameter_list|,
name|nregs
parameter_list|,
name|regs_allocated
parameter_list|)
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
name|regmatch_t
modifier|*
name|pmatch
decl_stmt|;
name|int
name|nregs
decl_stmt|,
name|regs_allocated
decl_stmt|;
block|{
name|int
name|rval
init|=
name|REGS_REALLOCATE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|need_regs
init|=
name|nregs
operator|+
literal|1
decl_stmt|;
comment|/* We need one extra element beyond `num_regs' for the `-1' marker GNU code      uses.  */
comment|/* Have the register data arrays been allocated?  */
if|if
condition|(
name|regs_allocated
operator|==
name|REGS_UNALLOCATED
condition|)
block|{
comment|/* No.  So allocate them with malloc.  */
name|regs
operator|->
name|start
operator|=
name|re_malloc
argument_list|(
name|regoff_t
argument_list|,
name|need_regs
argument_list|)
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|re_malloc
argument_list|(
name|regoff_t
argument_list|,
name|need_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|regs
operator|->
name|start
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
operator|||
name|BE
argument_list|(
name|regs
operator|->
name|end
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REGS_UNALLOCATED
return|;
name|regs
operator|->
name|num_regs
operator|=
name|need_regs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regs_allocated
operator|==
name|REGS_REALLOCATE
condition|)
block|{
comment|/* Yes.  If we need more elements than were already 	 allocated, reallocate them.  If we need fewer, just 	 leave it alone.  */
if|if
condition|(
name|BE
argument_list|(
name|need_regs
operator|>
name|regs
operator|->
name|num_regs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|regoff_t
modifier|*
name|new_start
init|=
name|re_realloc
argument_list|(
name|regs
operator|->
name|start
argument_list|,
name|regoff_t
argument_list|,
name|need_regs
argument_list|)
decl_stmt|;
name|regoff_t
modifier|*
name|new_end
init|=
name|re_realloc
argument_list|(
name|regs
operator|->
name|end
argument_list|,
name|regoff_t
argument_list|,
name|need_regs
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_start
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
operator|||
name|BE
argument_list|(
name|new_end
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REGS_UNALLOCATED
return|;
name|regs
operator|->
name|start
operator|=
name|new_start
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|new_end
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
name|need_regs
expr_stmt|;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|regs_allocated
operator|==
name|REGS_FIXED
argument_list|)
expr_stmt|;
comment|/* This function may not be called with REGS_FIXED and nregs too big.  */
name|assert
argument_list|(
name|regs
operator|->
name|num_regs
operator|>=
name|nregs
argument_list|)
expr_stmt|;
name|rval
operator|=
name|REGS_FIXED
expr_stmt|;
block|}
comment|/* Copy the regs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
operator|++
name|i
control|)
block|{
name|regs
operator|->
name|start
index|[
name|i
index|]
operator|=
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_so
expr_stmt|;
name|regs
operator|->
name|end
index|[
name|i
index|]
operator|=
name|pmatch
index|[
name|i
index|]
operator|.
name|rm_eo
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|regs
operator|->
name|num_regs
condition|;
operator|++
name|i
control|)
name|regs
operator|->
name|start
index|[
name|i
index|]
operator|=
name|regs
operator|->
name|end
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Set REGS to hold NUM_REGS registers, storing them in STARTS and    ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use    this memory for recording register information.  STARTS and ENDS    must be allocated using the malloc library routine, and must each    be at least NUM_REGS * sizeof (regoff_t) bytes long.     If NUM_REGS == 0, then subsequent matches should allocate their own    register data.     Unless this function is called, the first search or match using    PATTERN_BUFFER will allocate its own register data, without    freeing the old data.  */
end_comment

begin_function
name|void
name|re_set_registers
parameter_list|(
name|bufp
parameter_list|,
name|regs
parameter_list|,
name|num_regs
parameter_list|,
name|starts
parameter_list|,
name|ends
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
name|unsigned
name|num_regs
decl_stmt|;
name|regoff_t
modifier|*
name|starts
decl_stmt|,
decl|*
name|ends
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|num_regs
condition|)
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|starts
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|ends
expr_stmt|;
block|}
else|else
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|regs
operator|->
name|end
operator|=
operator|(
name|regoff_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__re_set_registers
argument_list|,
argument|re_set_registers
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with 4.2 BSD regex library.  We don't define    them unless specifically requested.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|_REGEX_RE_COMP
operator|||
name|defined
name|_LIBC
end_if

begin_function
name|int
ifdef|#
directive|ifdef
name|_LIBC
name|weak_function
endif|#
directive|endif
name|re_exec
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
literal|0
operator|==
name|regexec
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _REGEX_RE_COMP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Internal entry point.  */
end_comment

begin_comment
comment|/* Searches for a compiled pattern PREG in the string STRING, whose    length is LENGTH.  NMATCH, PMATCH, and EFLAGS have the same    mingings with regexec.  START, and RANGE have the same meanings    with re_search.    Return REG_NOERROR if we find a match, and REG_NOMATCH if not,    otherwise return the error code.    Note: We assume front end functions already check ranges.    (START + RANGE>= 0&& START + RANGE<= LENGTH)  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_search_internal
parameter_list|(
name|preg
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|start
parameter_list|,
name|range
parameter_list|,
name|stop
parameter_list|,
name|nmatch
parameter_list|,
name|pmatch
parameter_list|,
name|eflags
parameter_list|)
specifier|const
name|regex_t
modifier|*
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|,
name|start
decl_stmt|,
name|range
decl_stmt|,
name|stop
decl_stmt|,
name|eflags
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|regmatch_t
name|pmatch
index|[]
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|int
name|left_lim
decl_stmt|,
name|right_lim
decl_stmt|,
name|incr
decl_stmt|;
name|int
name|fl_longest_match
decl_stmt|,
name|match_first
decl_stmt|,
name|match_kind
decl_stmt|,
name|match_last
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|extra_nmatch
decl_stmt|;
name|int
name|sb
decl_stmt|,
name|ch
decl_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|||
operator|(
name|defined
name|__STDC_VERSION__
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
name|re_match_context_t
name|mctx
init|=
block|{
operator|.
name|dfa
operator|=
name|dfa
block|}
decl_stmt|;
else|#
directive|else
name|re_match_context_t
name|mctx
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|fastmap
init|=
operator|(
name|preg
operator|->
name|fastmap
operator|!=
name|NULL
operator|&&
name|preg
operator|->
name|fastmap_accurate
operator|&&
name|range
operator|&&
operator|!
name|preg
operator|->
name|can_be_null
operator|)
condition|?
name|preg
operator|->
name|fastmap
else|:
name|NULL
decl_stmt|;
name|unsigned
name|RE_TRANSLATE_TYPE
name|t
init|=
operator|(
name|unsigned
name|RE_TRANSLATE_TYPE
operator|)
name|preg
operator|->
name|translate
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
name|_LIBC
operator|||
operator|(
name|defined
name|__STDC_VERSION__
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
operator|)
name|memset
argument_list|(
operator|&
name|mctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_match_context_t
argument_list|)
argument_list|)
expr_stmt|;
name|mctx
operator|.
name|dfa
operator|=
name|dfa
expr_stmt|;
endif|#
directive|endif
name|extra_nmatch
operator|=
operator|(
name|nmatch
operator|>
name|preg
operator|->
name|re_nsub
operator|)
condition|?
name|nmatch
operator|-
operator|(
name|preg
operator|->
name|re_nsub
operator|+
literal|1
operator|)
else|:
literal|0
expr_stmt|;
name|nmatch
operator|-=
name|extra_nmatch
expr_stmt|;
comment|/* Check if the DFA haven't been compiled.  */
if|if
condition|(
name|BE
argument_list|(
name|preg
operator|->
name|used
operator|==
literal|0
operator|||
name|dfa
operator|->
name|init_state
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|init_state_word
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|init_state_nl
operator|==
name|NULL
operator|||
name|dfa
operator|->
name|init_state_begbuf
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_NOMATCH
return|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* We assume front-end functions already check them.  */
name|assert
argument_list|(
name|start
operator|+
name|range
operator|>=
literal|0
operator|&&
name|start
operator|+
name|range
operator|<=
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If initial states with non-begbuf contexts have no elements,      the regex must be anchored.  If preg->newline_anchor is set,      we'll never use init_state_nl, so do not check it.  */
if|if
condition|(
name|dfa
operator|->
name|init_state
operator|->
name|nodes
operator|.
name|nelem
operator|==
literal|0
operator|&&
name|dfa
operator|->
name|init_state_word
operator|->
name|nodes
operator|.
name|nelem
operator|==
literal|0
operator|&&
operator|(
name|dfa
operator|->
name|init_state_nl
operator|->
name|nodes
operator|.
name|nelem
operator|==
literal|0
operator|||
operator|!
name|preg
operator|->
name|newline_anchor
operator|)
condition|)
block|{
if|if
condition|(
name|start
operator|!=
literal|0
operator|&&
name|start
operator|+
name|range
operator|!=
literal|0
condition|)
return|return
name|REG_NOMATCH
return|;
name|start
operator|=
name|range
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We must check the longest matching, if nmatch> 0.  */
name|fl_longest_match
operator|=
operator|(
name|nmatch
operator|!=
literal|0
operator|||
name|dfa
operator|->
name|nbackref
operator|)
expr_stmt|;
name|err
operator|=
name|re_string_allocate
argument_list|(
operator|&
name|mctx
operator|.
name|input
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|dfa
operator|->
name|nodes_len
operator|+
literal|1
argument_list|,
name|preg
operator|->
name|translate
argument_list|,
name|preg
operator|->
name|syntax
operator|&
name|RE_ICASE
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
name|mctx
operator|.
name|input
operator|.
name|stop
operator|=
name|stop
expr_stmt|;
name|mctx
operator|.
name|input
operator|.
name|raw_stop
operator|=
name|stop
expr_stmt|;
name|mctx
operator|.
name|input
operator|.
name|newline_anchor
operator|=
name|preg
operator|->
name|newline_anchor
expr_stmt|;
name|err
operator|=
name|match_ctx_init
argument_list|(
operator|&
name|mctx
argument_list|,
name|eflags
argument_list|,
name|dfa
operator|->
name|nbackref
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
comment|/* We will log all the DFA states through which the dfa pass,      if nmatch> 1, or this dfa has "multibyte node", which is a      back-reference or a node which can accept multibyte character or      multi character collating element.  */
if|if
condition|(
name|nmatch
operator|>
literal|1
operator|||
name|dfa
operator|->
name|has_mb_node
condition|)
block|{
name|mctx
operator|.
name|state_log
operator|=
name|re_malloc
argument_list|(
name|re_dfastate_t
operator|*
argument_list|,
name|mctx
operator|.
name|input
operator|.
name|bufs_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|.
name|state_log
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
block|}
else|else
name|mctx
operator|.
name|state_log
operator|=
name|NULL
expr_stmt|;
name|match_first
operator|=
name|start
expr_stmt|;
name|mctx
operator|.
name|input
operator|.
name|tip_context
operator|=
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
condition|?
name|CONTEXT_BEGBUF
else|:
name|CONTEXT_NEWLINE
operator||
name|CONTEXT_BEGBUF
expr_stmt|;
comment|/* Check incrementally whether of not the input string match.  */
name|incr
operator|=
operator|(
name|range
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|left_lim
operator|=
operator|(
name|range
operator|<
literal|0
operator|)
condition|?
name|start
operator|+
name|range
else|:
name|start
expr_stmt|;
name|right_lim
operator|=
operator|(
name|range
operator|<
literal|0
operator|)
condition|?
name|start
else|:
name|start
operator|+
name|range
expr_stmt|;
name|sb
operator|=
name|dfa
operator|->
name|mb_cur_max
operator|==
literal|1
expr_stmt|;
name|match_kind
operator|=
operator|(
name|fastmap
condition|?
operator|(
operator|(
name|sb
operator|||
operator|!
operator|(
name|preg
operator|->
name|syntax
operator|&
name|RE_ICASE
operator|||
name|t
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator||
operator|(
name|range
operator|>=
literal|0
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
name|t
operator|!=
name|NULL
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
else|:
literal|8
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
name|match_first
operator|+=
name|incr
control|)
block|{
name|err
operator|=
name|REG_NOMATCH
expr_stmt|;
if|if
condition|(
name|match_first
operator|<
name|left_lim
operator|||
name|right_lim
operator|<
name|match_first
condition|)
goto|goto
name|free_return
goto|;
comment|/* Advance as rapidly as possible through the string, until we 	 find a plausible place to start matching.  This may be done 	 with varying efficiency, so there are various possibilities: 	 only the most common of them are specialized, in order to 	 save on code size.  We use a switch statement for speed.  */
switch|switch
condition|(
name|match_kind
condition|)
block|{
case|case
literal|8
case|:
comment|/* No fastmap.  */
break|break;
case|case
literal|7
case|:
comment|/* Fastmap with single-byte translation, match forward.  */
while|while
condition|(
name|BE
argument_list|(
name|match_first
operator|<
name|right_lim
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|fastmap
index|[
name|t
index|[
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|match_first
index|]
index|]
index|]
condition|)
operator|++
name|match_first
expr_stmt|;
goto|goto
name|forward_match_found_start_or_reached_end
goto|;
case|case
literal|6
case|:
comment|/* Fastmap without translation, match forward.  */
while|while
condition|(
name|BE
argument_list|(
name|match_first
operator|<
name|right_lim
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|match_first
index|]
index|]
condition|)
operator|++
name|match_first
expr_stmt|;
name|forward_match_found_start_or_reached_end
label|:
if|if
condition|(
name|BE
argument_list|(
name|match_first
operator|==
name|right_lim
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ch
operator|=
name|match_first
operator|>=
name|length
condition|?
literal|0
else|:
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|match_first
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fastmap
index|[
name|t
condition|?
name|t
index|[
name|ch
index|]
else|:
name|ch
index|]
condition|)
goto|goto
name|free_return
goto|;
block|}
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
comment|/* Fastmap without multi-byte translation, match backwards.  */
while|while
condition|(
name|match_first
operator|>=
name|left_lim
condition|)
block|{
name|ch
operator|=
name|match_first
operator|>=
name|length
condition|?
literal|0
else|:
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|match_first
index|]
expr_stmt|;
if|if
condition|(
name|fastmap
index|[
name|t
condition|?
name|t
index|[
name|ch
index|]
else|:
name|ch
index|]
condition|)
break|break;
operator|--
name|match_first
expr_stmt|;
block|}
if|if
condition|(
name|match_first
operator|<
name|left_lim
condition|)
goto|goto
name|free_return
goto|;
break|break;
default|default:
comment|/* In this case, we can't determine easily the current byte, 	     since it might be a component byte of a multibyte 	     character.  Then we use the constructed buffer instead.  */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If MATCH_FIRST is out of the valid range, reconstruct the 		 buffers.  */
name|unsigned
name|int
name|offset
init|=
name|match_first
operator|-
name|mctx
operator|.
name|input
operator|.
name|raw_mbs_idx
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|offset
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|mctx
operator|.
name|input
operator|.
name|valid_raw_len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|re_string_reconstruct
argument_list|(
operator|&
name|mctx
operator|.
name|input
argument_list|,
name|match_first
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
name|offset
operator|=
name|match_first
operator|-
name|mctx
operator|.
name|input
operator|.
name|raw_mbs_idx
expr_stmt|;
block|}
comment|/* If MATCH_FIRST is out of the buffer, leave it as '\0'. 		 Note that MATCH_FIRST must not be smaller than 0.  */
name|ch
operator|=
operator|(
name|match_first
operator|>=
name|length
condition|?
literal|0
else|:
name|re_string_byte_at
argument_list|(
operator|&
name|mctx
operator|.
name|input
argument_list|,
name|offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fastmap
index|[
name|ch
index|]
condition|)
break|break;
name|match_first
operator|+=
name|incr
expr_stmt|;
if|if
condition|(
name|match_first
operator|<
name|left_lim
operator|||
name|match_first
operator|>
name|right_lim
condition|)
block|{
name|err
operator|=
name|REG_NOMATCH
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
block|}
break|break;
block|}
comment|/* Reconstruct the buffers so that the matcher can assume that 	 the matching starts from the beginning of the buffer.  */
name|err
operator|=
name|re_string_reconstruct
argument_list|(
operator|&
name|mctx
operator|.
name|input
argument_list|,
name|match_first
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* Don't consider this char as a possible match start if it part, 	yet isn't the head, of a multibyte character.  */
if|if
condition|(
operator|!
name|sb
operator|&&
operator|!
name|re_string_first_byte
argument_list|(
operator|&
name|mctx
operator|.
name|input
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* It seems to be appropriate one, then use the matcher.  */
comment|/* We assume that the matching starts from 0.  */
name|mctx
operator|.
name|state_log_top
operator|=
name|mctx
operator|.
name|nbkref_ents
operator|=
name|mctx
operator|.
name|max_mb_elem_len
operator|=
literal|0
expr_stmt|;
name|match_last
operator|=
name|check_matching
argument_list|(
operator|&
name|mctx
argument_list|,
name|fl_longest_match
argument_list|,
name|range
operator|>=
literal|0
condition|?
operator|&
name|match_first
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_last
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|match_last
operator|==
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
else|else
block|{
name|mctx
operator|.
name|match_last
operator|=
name|match_last
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|nmatch
operator|>
literal|1
operator|)
operator|||
name|dfa
operator|->
name|nbackref
condition|)
block|{
name|re_dfastate_t
modifier|*
name|pstate
init|=
name|mctx
operator|.
name|state_log
index|[
name|match_last
index|]
decl_stmt|;
name|mctx
operator|.
name|last_node
operator|=
name|check_halt_state_context
argument_list|(
operator|&
name|mctx
argument_list|,
name|pstate
argument_list|,
name|match_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|nmatch
operator|>
literal|1
operator|&&
name|dfa
operator|->
name|has_plural_match
operator|)
operator|||
name|dfa
operator|->
name|nbackref
condition|)
block|{
name|err
operator|=
name|prune_impossible_nodes
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|REG_NOERROR
condition|)
break|break;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOMATCH
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
name|match_last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
break|break;
comment|/* We found a match.  */
block|}
block|}
name|match_ctx_clean
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|match_last
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|err
operator|==
name|REG_NOERROR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set pmatch[] if we need.  */
if|if
condition|(
name|nmatch
operator|>
literal|0
condition|)
block|{
name|int
name|reg_idx
decl_stmt|;
comment|/* Initialize registers.  */
for|for
control|(
name|reg_idx
operator|=
literal|1
init|;
name|reg_idx
operator|<
name|nmatch
condition|;
operator|++
name|reg_idx
control|)
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|=
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set the points where matching start/end.  */
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|mctx
operator|.
name|match_last
expr_stmt|;
if|if
condition|(
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|nmatch
operator|>
literal|1
condition|)
block|{
name|err
operator|=
name|set_regs
argument_list|(
name|preg
argument_list|,
operator|&
name|mctx
argument_list|,
name|nmatch
argument_list|,
name|pmatch
argument_list|,
name|dfa
operator|->
name|has_plural_match
operator|&&
name|dfa
operator|->
name|nbackref
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
comment|/* At last, add the offset to the each registers, since we slided 	 the buffers so that we could assume that the matching starts 	 from 0.  */
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|<
name|nmatch
condition|;
operator|++
name|reg_idx
control|)
if|if
condition|(
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|.
name|input
operator|.
name|offsets_needed
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|==
name|mctx
operator|.
name|input
operator|.
name|valid_len
condition|)
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|+=
name|mctx
operator|.
name|input
operator|.
name|valid_raw_len
operator|-
name|mctx
operator|.
name|input
operator|.
name|valid_len
expr_stmt|;
else|else
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|=
name|mctx
operator|.
name|input
operator|.
name|offsets
index|[
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
index|]
expr_stmt|;
if|if
condition|(
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
operator|==
name|mctx
operator|.
name|input
operator|.
name|valid_len
condition|)
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
operator|+=
name|mctx
operator|.
name|input
operator|.
name|valid_raw_len
operator|-
name|mctx
operator|.
name|input
operator|.
name|valid_len
expr_stmt|;
else|else
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
operator|=
name|mctx
operator|.
name|input
operator|.
name|offsets
index|[
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
index|]
expr_stmt|;
block|}
else|#
directive|else
name|assert
argument_list|(
name|mctx
operator|.
name|input
operator|.
name|offsets_needed
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|+=
name|match_first
expr_stmt|;
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
operator|+=
name|match_first
expr_stmt|;
block|}
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|<
name|extra_nmatch
condition|;
operator|++
name|reg_idx
control|)
block|{
name|pmatch
index|[
name|nmatch
operator|+
name|reg_idx
index|]
operator|.
name|rm_so
operator|=
operator|-
literal|1
expr_stmt|;
name|pmatch
index|[
name|nmatch
operator|+
name|reg_idx
index|]
operator|.
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dfa
operator|->
name|subexp_map
condition|)
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|+
literal|1
operator|<
name|nmatch
condition|;
name|reg_idx
operator|++
control|)
if|if
condition|(
name|dfa
operator|->
name|subexp_map
index|[
name|reg_idx
index|]
operator|!=
name|reg_idx
condition|)
block|{
name|pmatch
index|[
name|reg_idx
operator|+
literal|1
index|]
operator|.
name|rm_so
operator|=
name|pmatch
index|[
name|dfa
operator|->
name|subexp_map
index|[
name|reg_idx
index|]
operator|+
literal|1
index|]
operator|.
name|rm_so
expr_stmt|;
name|pmatch
index|[
name|reg_idx
operator|+
literal|1
index|]
operator|.
name|rm_eo
operator|=
name|pmatch
index|[
name|dfa
operator|->
name|subexp_map
index|[
name|reg_idx
index|]
operator|+
literal|1
index|]
operator|.
name|rm_eo
expr_stmt|;
block|}
block|}
name|free_return
label|:
name|re_free
argument_list|(
name|mctx
operator|.
name|state_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nbackref
condition|)
name|match_ctx_free
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|re_string_destruct
argument_list|(
operator|&
name|mctx
operator|.
name|input
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|prune_impossible_nodes
parameter_list|(
name|mctx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|halt_node
decl_stmt|,
name|match_last
decl_stmt|;
name|reg_errcode_t
name|ret
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|sifted_states
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|lim_states
init|=
name|NULL
decl_stmt|;
name|re_sift_context_t
name|sctx
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|mctx
operator|->
name|state_log
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|match_last
operator|=
name|mctx
operator|->
name|match_last
expr_stmt|;
name|halt_node
operator|=
name|mctx
operator|->
name|last_node
expr_stmt|;
name|sifted_states
operator|=
name|re_malloc
argument_list|(
name|re_dfastate_t
operator|*
argument_list|,
name|match_last
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|sifted_states
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
name|REG_ESPACE
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
if|if
condition|(
name|dfa
operator|->
name|nbackref
condition|)
block|{
name|lim_states
operator|=
name|re_malloc
argument_list|(
name|re_dfastate_t
operator|*
argument_list|,
name|match_last
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|lim_states
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
name|REG_ESPACE
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|memset
argument_list|(
name|lim_states
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
operator|*
operator|(
name|match_last
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sift_ctx_init
argument_list|(
operator|&
name|sctx
argument_list|,
name|sifted_states
argument_list|,
name|lim_states
argument_list|,
name|halt_node
argument_list|,
name|match_last
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sift_states_backward
argument_list|(
name|mctx
argument_list|,
operator|&
name|sctx
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|sctx
operator|.
name|limits
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
if|if
condition|(
name|sifted_states
index|[
literal|0
index|]
operator|!=
name|NULL
operator|||
name|lim_states
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
break|break;
do|do
block|{
operator|--
name|match_last
expr_stmt|;
if|if
condition|(
name|match_last
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|REG_NOMATCH
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
block|}
do|while
condition|(
name|mctx
operator|->
name|state_log
index|[
name|match_last
index|]
operator|==
name|NULL
operator|||
operator|!
name|mctx
operator|->
name|state_log
index|[
name|match_last
index|]
operator|->
name|halt
condition|)
do|;
name|halt_node
operator|=
name|check_halt_state_context
argument_list|(
name|mctx
argument_list|,
name|mctx
operator|->
name|state_log
index|[
name|match_last
index|]
argument_list|,
name|match_last
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|merge_state_array
argument_list|(
name|dfa
argument_list|,
name|sifted_states
argument_list|,
name|lim_states
argument_list|,
name|match_last
operator|+
literal|1
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|lim_states
argument_list|)
expr_stmt|;
name|lim_states
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
else|else
block|{
name|sift_ctx_init
argument_list|(
operator|&
name|sctx
argument_list|,
name|sifted_states
argument_list|,
name|lim_states
argument_list|,
name|halt_node
argument_list|,
name|match_last
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sift_states_backward
argument_list|(
name|mctx
argument_list|,
operator|&
name|sctx
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|sctx
operator|.
name|limits
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
name|re_free
argument_list|(
name|mctx
operator|->
name|state_log
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|state_log
operator|=
name|sifted_states
expr_stmt|;
name|sifted_states
operator|=
name|NULL
expr_stmt|;
name|mctx
operator|->
name|last_node
operator|=
name|halt_node
expr_stmt|;
name|mctx
operator|->
name|match_last
operator|=
name|match_last
expr_stmt|;
name|ret
operator|=
name|REG_NOERROR
expr_stmt|;
name|free_return
label|:
name|re_free
argument_list|(
name|sifted_states
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|lim_states
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Acquire an initial state and return it.    We must select appropriate initial state depending on the context,    since initial states may have constraints like "\<", "^", etc..  */
end_comment

begin_function
specifier|static
specifier|inline
name|re_dfastate_t
modifier|*
name|acquire_init_state_context
parameter_list|(
name|err
parameter_list|,
name|mctx
parameter_list|,
name|idx
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
if|if
condition|(
name|dfa
operator|->
name|init_state
operator|->
name|has_constraint
condition|)
block|{
name|unsigned
name|int
name|context
decl_stmt|;
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_WORD_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
return|return
name|dfa
operator|->
name|init_state_word
return|;
elseif|else
if|if
condition|(
name|IS_ORDINARY_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
return|return
name|dfa
operator|->
name|init_state
return|;
elseif|else
if|if
condition|(
name|IS_BEGBUF_CONTEXT
argument_list|(
name|context
argument_list|)
operator|&&
name|IS_NEWLINE_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
return|return
name|dfa
operator|->
name|init_state_begbuf
return|;
elseif|else
if|if
condition|(
name|IS_NEWLINE_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
return|return
name|dfa
operator|->
name|init_state_nl
return|;
elseif|else
if|if
condition|(
name|IS_BEGBUF_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
block|{
comment|/* It is relatively rare case, then calculate on demand.  */
return|return
name|re_acquire_state_context
argument_list|(
name|err
argument_list|,
name|dfa
argument_list|,
name|dfa
operator|->
name|init_state
operator|->
name|entrance_nodes
argument_list|,
name|context
argument_list|)
return|;
block|}
else|else
comment|/* Must not happen?  */
return|return
name|dfa
operator|->
name|init_state
return|;
block|}
else|else
return|return
name|dfa
operator|->
name|init_state
return|;
block|}
end_function

begin_comment
comment|/* Check whether the regular expression match input string INPUT or not,    and return the index where the matching end, return -1 if not match,    or return -2 in case of an error.    FL_LONGEST_MATCH means we want the POSIX longest matching.    If P_MATCH_FIRST is not NULL, and the match fails, it is set to the    next place where we may want to try matching.    Note that the matcher assume that the maching starts from the current    index of the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|check_matching
parameter_list|(
name|mctx
parameter_list|,
name|fl_longest_match
parameter_list|,
name|p_match_first
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|fl_longest_match
decl_stmt|;
name|int
modifier|*
name|p_match_first
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|match_last
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cur_str_idx
init|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
decl_stmt|;
name|re_dfastate_t
modifier|*
name|cur_state
decl_stmt|;
name|int
name|at_init_state
init|=
name|p_match_first
operator|!=
name|NULL
decl_stmt|;
name|int
name|next_start_idx
init|=
name|cur_str_idx
decl_stmt|;
name|err
operator|=
name|REG_NOERROR
expr_stmt|;
name|cur_state
operator|=
name|acquire_init_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|mctx
argument_list|,
name|cur_str_idx
argument_list|)
expr_stmt|;
comment|/* An initial state must not be NULL (invalid).  */
if|if
condition|(
name|BE
argument_list|(
name|cur_state
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|err
operator|==
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|mctx
operator|->
name|state_log
operator|!=
name|NULL
condition|)
block|{
name|mctx
operator|->
name|state_log
index|[
name|cur_str_idx
index|]
operator|=
name|cur_state
expr_stmt|;
comment|/* Check OP_OPEN_SUBEXP in the initial state in case that we use them 	 later.  E.g. Processing back references.  */
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|nbackref
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|at_init_state
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|check_subexp_matching_top
argument_list|(
name|mctx
argument_list|,
operator|&
name|cur_state
operator|->
name|nodes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|cur_state
operator|->
name|has_backref
condition|)
block|{
name|err
operator|=
name|transit_state_bkref
argument_list|(
name|mctx
argument_list|,
operator|&
name|cur_state
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
block|}
block|}
comment|/* If the RE accepts NULL string.  */
if|if
condition|(
name|BE
argument_list|(
name|cur_state
operator|->
name|halt
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cur_state
operator|->
name|has_constraint
operator|||
name|check_halt_state_context
argument_list|(
name|mctx
argument_list|,
name|cur_state
argument_list|,
name|cur_str_idx
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fl_longest_match
condition|)
return|return
name|cur_str_idx
return|;
else|else
block|{
name|match_last
operator|=
name|cur_str_idx
expr_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|!
name|re_string_eoi
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
condition|)
block|{
name|re_dfastate_t
modifier|*
name|old_state
init|=
name|cur_state
decl_stmt|;
name|int
name|next_char_idx
init|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|next_char_idx
operator|>=
name|mctx
operator|->
name|input
operator|.
name|bufs_len
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|BE
argument_list|(
name|next_char_idx
operator|>=
name|mctx
operator|->
name|input
operator|.
name|valid_len
argument_list|,
literal|0
argument_list|)
operator|&&
name|mctx
operator|->
name|input
operator|.
name|valid_len
operator|<
name|mctx
operator|->
name|input
operator|.
name|len
operator|)
condition|)
block|{
name|err
operator|=
name|extend_buffers
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|err
operator|==
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
name|cur_state
operator|=
name|transit_state
argument_list|(
operator|&
name|err
argument_list|,
name|mctx
argument_list|,
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|state_log
operator|!=
name|NULL
condition|)
name|cur_state
operator|=
name|merge_state_with_log
argument_list|(
operator|&
name|err
argument_list|,
name|mctx
argument_list|,
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|==
name|NULL
condition|)
block|{
comment|/* Reached the invalid state or an error.  Try to recover a valid 	     state using the state log, if available and if we have not 	     already found a valid (even if not the longest) match.  */
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|mctx
operator|->
name|state_log
operator|==
name|NULL
operator|||
operator|(
name|match
operator|&&
operator|!
name|fl_longest_match
operator|)
operator|||
operator|(
name|cur_state
operator|=
name|find_recover_state
argument_list|(
operator|&
name|err
argument_list|,
name|mctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|BE
argument_list|(
name|at_init_state
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|old_state
operator|==
name|cur_state
condition|)
name|next_start_idx
operator|=
name|next_char_idx
expr_stmt|;
else|else
name|at_init_state
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cur_state
operator|->
name|halt
condition|)
block|{
comment|/* Reached a halt state. 	     Check the halt state can satisfy the current context.  */
if|if
condition|(
operator|!
name|cur_state
operator|->
name|has_constraint
operator|||
name|check_halt_state_context
argument_list|(
name|mctx
argument_list|,
name|cur_state
argument_list|,
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We found an appropriate halt state.  */
name|match_last
operator|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
expr_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
comment|/* We found a match, do not modify match_first below.  */
name|p_match_first
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fl_longest_match
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|p_match_first
condition|)
operator|*
name|p_match_first
operator|+=
name|next_start_idx
expr_stmt|;
return|return
name|match_last
return|;
block|}
end_function

begin_comment
comment|/* Check NODE match the current context.  */
end_comment

begin_function
specifier|static
name|int
name|check_halt_node_context
parameter_list|(
name|dfa
parameter_list|,
name|node
parameter_list|,
name|context
parameter_list|)
specifier|const
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|node
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
block|{
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
decl_stmt|;
name|unsigned
name|int
name|constraint
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|constraint
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|END_OF_RE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|constraint
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|NOT_SATISFY_NEXT_CONSTRAINT
argument_list|(
name|constraint
argument_list|,
name|context
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check the halt state STATE match the current context.    Return 0 if not match, if the node, STATE has, is a halt node and    match the context, return the node.  */
end_comment

begin_function
specifier|static
name|int
name|check_halt_state_context
parameter_list|(
name|mctx
parameter_list|,
name|state
parameter_list|,
name|idx
parameter_list|)
specifier|const
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
specifier|const
name|re_dfastate_t
modifier|*
name|state
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|state
operator|->
name|halt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|idx
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|nodes
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|check_halt_node_context
argument_list|(
name|mctx
operator|->
name|dfa
argument_list|,
name|state
operator|->
name|nodes
operator|.
name|elems
index|[
name|i
index|]
argument_list|,
name|context
argument_list|)
condition|)
return|return
name|state
operator|->
name|nodes
operator|.
name|elems
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the next node to which "NFA" transit from NODE("NFA" is a NFA    corresponding to the DFA).    Return the destination node, and update EPS_VIA_NODES, return -1 in case    of errors.  */
end_comment

begin_function
specifier|static
name|int
name|proceed_next_node
parameter_list|(
name|mctx
parameter_list|,
name|nregs
parameter_list|,
name|regs
parameter_list|,
name|pidx
parameter_list|,
name|node
parameter_list|,
name|eps_via_nodes
parameter_list|,
name|fs
parameter_list|)
specifier|const
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|regmatch_t
modifier|*
name|regs
decl_stmt|;
name|int
name|nregs
decl_stmt|,
decl|*
name|pidx
decl_stmt|,
name|node
decl_stmt|;
end_function

begin_decl_stmt
name|re_node_set
modifier|*
name|eps_via_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_fail_stack_t
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|dest_node
decl_stmt|;
name|dest_node
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|IS_EPSILON_NODE
argument_list|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
argument_list|)
condition|)
block|{
name|re_node_set
modifier|*
name|cur_nodes
init|=
operator|&
name|mctx
operator|->
name|state_log
index|[
operator|*
name|pidx
index|]
operator|->
name|nodes
decl_stmt|;
name|re_node_set
modifier|*
name|edests
init|=
operator|&
name|dfa
operator|->
name|edests
index|[
name|node
index|]
decl_stmt|;
name|int
name|dest_node
decl_stmt|;
name|err
operator|=
name|re_node_set_insert
argument_list|(
name|eps_via_nodes
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
comment|/* Pick up a valid destination, or return -1 if none is found.  */
for|for
control|(
name|dest_node
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edests
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|int
name|candidate
init|=
name|edests
operator|->
name|elems
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|re_node_set_contains
argument_list|(
name|cur_nodes
argument_list|,
name|candidate
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dest_node
operator|==
operator|-
literal|1
condition|)
name|dest_node
operator|=
name|candidate
expr_stmt|;
else|else
block|{
comment|/* In order to avoid infinite loop like "(a*)*", return the second 	         epsilon-transition if the first was already considered.  */
if|if
condition|(
name|re_node_set_contains
argument_list|(
name|eps_via_nodes
argument_list|,
name|dest_node
argument_list|)
condition|)
return|return
name|candidate
return|;
comment|/* Otherwise, push the second epsilon-transition on the fail stack.  */
elseif|else
if|if
condition|(
name|fs
operator|!=
name|NULL
operator|&&
name|push_fail_stack
argument_list|(
name|fs
argument_list|,
operator|*
name|pidx
argument_list|,
name|candidate
argument_list|,
name|nregs
argument_list|,
name|regs
argument_list|,
name|eps_via_nodes
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
comment|/* We know we are going to exit.  */
break|break;
block|}
block|}
return|return
name|dest_node
return|;
block|}
else|else
block|{
name|int
name|naccepted
init|=
literal|0
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
decl_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|accept_mb
condition|)
name|naccepted
operator|=
name|check_node_accept_bytes
argument_list|(
name|dfa
argument_list|,
name|node
argument_list|,
operator|&
name|mctx
operator|->
name|input
argument_list|,
operator|*
name|pidx
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|type
operator|==
name|OP_BACK_REF
condition|)
block|{
name|int
name|subexp_idx
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
operator|+
literal|1
decl_stmt|;
name|naccepted
operator|=
name|regs
index|[
name|subexp_idx
index|]
operator|.
name|rm_eo
operator|-
name|regs
index|[
name|subexp_idx
index|]
operator|.
name|rm_so
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|regs
index|[
name|subexp_idx
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
operator|||
name|regs
index|[
name|subexp_idx
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|naccepted
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|re_string_get_buffer
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|regs
index|[
name|subexp_idx
index|]
operator|.
name|rm_so
argument_list|,
name|buf
operator|+
operator|*
name|pidx
argument_list|,
name|naccepted
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|naccepted
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|re_node_set_insert
argument_list|(
name|eps_via_nodes
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|dest_node
operator|=
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|elems
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|re_node_set_contains
argument_list|(
operator|&
name|mctx
operator|->
name|state_log
index|[
operator|*
name|pidx
index|]
operator|->
name|nodes
argument_list|,
name|dest_node
argument_list|)
condition|)
return|return
name|dest_node
return|;
block|}
block|}
if|if
condition|(
name|naccepted
operator|!=
literal|0
operator|||
name|check_node_accept
argument_list|(
name|mctx
argument_list|,
name|dfa
operator|->
name|nodes
operator|+
name|node
argument_list|,
operator|*
name|pidx
argument_list|)
condition|)
block|{
name|dest_node
operator|=
name|dfa
operator|->
name|nexts
index|[
name|node
index|]
expr_stmt|;
operator|*
name|pidx
operator|=
operator|(
name|naccepted
operator|==
literal|0
operator|)
condition|?
operator|*
name|pidx
operator|+
literal|1
else|:
operator|*
name|pidx
operator|+
name|naccepted
expr_stmt|;
if|if
condition|(
name|fs
operator|&&
operator|(
operator|*
name|pidx
operator|>
name|mctx
operator|->
name|match_last
operator|||
name|mctx
operator|->
name|state_log
index|[
operator|*
name|pidx
index|]
operator|==
name|NULL
operator|||
operator|!
name|re_node_set_contains
argument_list|(
operator|&
name|mctx
operator|->
name|state_log
index|[
operator|*
name|pidx
index|]
operator|->
name|nodes
argument_list|,
name|dest_node
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|re_node_set_empty
argument_list|(
name|eps_via_nodes
argument_list|)
expr_stmt|;
return|return
name|dest_node
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_function
specifier|static
name|reg_errcode_t
name|push_fail_stack
parameter_list|(
name|fs
parameter_list|,
name|str_idx
parameter_list|,
name|dest_node
parameter_list|,
name|nregs
parameter_list|,
name|regs
parameter_list|,
name|eps_via_nodes
parameter_list|)
name|struct
name|re_fail_stack_t
modifier|*
name|fs
decl_stmt|;
name|int
name|str_idx
decl_stmt|,
name|dest_node
decl_stmt|,
name|nregs
decl_stmt|;
name|regmatch_t
modifier|*
name|regs
decl_stmt|;
name|re_node_set
modifier|*
name|eps_via_nodes
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|num
init|=
name|fs
operator|->
name|num
operator|++
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|num
operator|==
name|fs
operator|->
name|alloc
condition|)
block|{
name|struct
name|re_fail_stack_ent_t
modifier|*
name|new_array
decl_stmt|;
name|new_array
operator|=
name|realloc
argument_list|(
name|fs
operator|->
name|stack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_fail_stack_ent_t
argument_list|)
operator|*
name|fs
operator|->
name|alloc
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_array
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
name|fs
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|fs
operator|->
name|stack
operator|=
name|new_array
expr_stmt|;
block|}
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|idx
operator|=
name|str_idx
expr_stmt|;
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|node
operator|=
name|dest_node
expr_stmt|;
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|regs
operator|=
name|re_malloc
argument_list|(
name|regmatch_t
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|regs
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
name|memcpy
argument_list|(
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|regs
argument_list|,
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|nregs
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|eps_via_nodes
argument_list|,
name|eps_via_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pop_fail_stack
parameter_list|(
name|fs
parameter_list|,
name|pidx
parameter_list|,
name|nregs
parameter_list|,
name|regs
parameter_list|,
name|eps_via_nodes
parameter_list|)
name|struct
name|re_fail_stack_t
modifier|*
name|fs
decl_stmt|;
name|int
modifier|*
name|pidx
decl_stmt|,
name|nregs
decl_stmt|;
name|regmatch_t
modifier|*
name|regs
decl_stmt|;
name|re_node_set
modifier|*
name|eps_via_nodes
decl_stmt|;
block|{
name|int
name|num
init|=
operator|--
name|fs
operator|->
name|num
decl_stmt|;
name|assert
argument_list|(
name|num
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pidx
operator|=
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|idx
expr_stmt|;
name|memcpy
argument_list|(
name|regs
argument_list|,
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|nregs
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
name|eps_via_nodes
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|regs
argument_list|)
expr_stmt|;
operator|*
name|eps_via_nodes
operator|=
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|eps_via_nodes
expr_stmt|;
return|return
name|fs
operator|->
name|stack
index|[
name|num
index|]
operator|.
name|node
return|;
block|}
end_function

begin_comment
comment|/* Set the positions where the subexpressions are starts/ends to registers    PMATCH.    Note: We assume that pmatch[0] is already set, and    pmatch[i].rm_so == pmatch[i].rm_eo == -1 for 0< i< nmatch.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|set_regs
parameter_list|(
name|preg
parameter_list|,
name|mctx
parameter_list|,
name|nmatch
parameter_list|,
name|pmatch
parameter_list|,
name|fl_backtrack
parameter_list|)
specifier|const
name|regex_t
modifier|*
name|preg
decl_stmt|;
specifier|const
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|regmatch_t
modifier|*
name|pmatch
decl_stmt|;
name|int
name|fl_backtrack
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
name|dfa
init|=
operator|(
name|re_dfa_t
operator|*
operator|)
name|preg
operator|->
name|buffer
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|cur_node
decl_stmt|;
name|re_node_set
name|eps_via_nodes
decl_stmt|;
name|struct
name|re_fail_stack_t
modifier|*
name|fs
decl_stmt|;
name|struct
name|re_fail_stack_t
name|fs_body
init|=
block|{
literal|0
block|,
literal|2
block|,
name|NULL
block|}
decl_stmt|;
name|regmatch_t
modifier|*
name|prev_idx_match
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|nmatch
operator|>
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mctx
operator|->
name|state_log
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fl_backtrack
condition|)
block|{
name|fs
operator|=
operator|&
name|fs_body
expr_stmt|;
name|fs
operator|->
name|stack
operator|=
name|re_malloc
argument_list|(
expr|struct
name|re_fail_stack_ent_t
argument_list|,
name|fs
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|stack
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
block|}
else|else
name|fs
operator|=
name|NULL
expr_stmt|;
name|cur_node
operator|=
name|dfa
operator|->
name|init_node
expr_stmt|;
name|re_node_set_init_empty
argument_list|(
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
name|prev_idx_match
operator|=
operator|(
name|regmatch_t
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|nmatch
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prev_idx_match
argument_list|,
name|pmatch
argument_list|,
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|nmatch
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
init|;
name|idx
operator|<=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
condition|;
control|)
block|{
name|update_regs
argument_list|(
name|dfa
argument_list|,
name|pmatch
argument_list|,
name|prev_idx_match
argument_list|,
name|cur_node
argument_list|,
name|idx
argument_list|,
name|nmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|&&
name|cur_node
operator|==
name|mctx
operator|->
name|last_node
condition|)
block|{
name|int
name|reg_idx
decl_stmt|;
if|if
condition|(
name|fs
condition|)
block|{
for|for
control|(
name|reg_idx
operator|=
literal|0
init|;
name|reg_idx
operator|<
name|nmatch
condition|;
operator|++
name|reg_idx
control|)
if|if
condition|(
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_so
operator|>
operator|-
literal|1
operator|&&
name|pmatch
index|[
name|reg_idx
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|reg_idx
operator|==
name|nmatch
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
return|return
name|free_fail_stack_return
argument_list|(
name|fs
argument_list|)
return|;
block|}
name|cur_node
operator|=
name|pop_fail_stack
argument_list|(
name|fs
argument_list|,
operator|&
name|idx
argument_list|,
name|nmatch
argument_list|,
name|pmatch
argument_list|,
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_node_set_free
argument_list|(
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
block|}
comment|/* Proceed to next node.  */
name|cur_node
operator|=
name|proceed_next_node
argument_list|(
name|mctx
argument_list|,
name|nmatch
argument_list|,
name|pmatch
argument_list|,
operator|&
name|idx
argument_list|,
name|cur_node
argument_list|,
operator|&
name|eps_via_nodes
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|cur_node
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|cur_node
operator|==
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
name|free_fail_stack_return
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
if|if
condition|(
name|fs
condition|)
name|cur_node
operator|=
name|pop_fail_stack
argument_list|(
name|fs
argument_list|,
operator|&
name|idx
argument_list|,
name|nmatch
argument_list|,
name|pmatch
argument_list|,
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
else|else
block|{
name|re_node_set_free
argument_list|(
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
return|return
name|REG_NOMATCH
return|;
block|}
block|}
block|}
name|re_node_set_free
argument_list|(
operator|&
name|eps_via_nodes
argument_list|)
expr_stmt|;
return|return
name|free_fail_stack_return
argument_list|(
name|fs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|free_fail_stack_return
parameter_list|(
name|fs
parameter_list|)
name|struct
name|re_fail_stack_t
modifier|*
name|fs
decl_stmt|;
block|{
if|if
condition|(
name|fs
condition|)
block|{
name|int
name|fs_idx
decl_stmt|;
for|for
control|(
name|fs_idx
operator|=
literal|0
init|;
name|fs_idx
operator|<
name|fs
operator|->
name|num
condition|;
operator|++
name|fs_idx
control|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|fs
operator|->
name|stack
index|[
name|fs_idx
index|]
operator|.
name|eps_via_nodes
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|fs
operator|->
name|stack
index|[
name|fs_idx
index|]
operator|.
name|regs
argument_list|)
expr_stmt|;
block|}
name|re_free
argument_list|(
name|fs
operator|->
name|stack
argument_list|)
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_regs
parameter_list|(
name|dfa
parameter_list|,
name|pmatch
parameter_list|,
name|prev_idx_match
parameter_list|,
name|cur_node
parameter_list|,
name|cur_idx
parameter_list|,
name|nmatch
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|regmatch_t
modifier|*
name|pmatch
decl_stmt|,
decl|*
name|prev_idx_match
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|cur_node
decl_stmt|,
name|cur_idx
decl_stmt|,
name|nmatch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_OPEN_SUBEXP
condition|)
block|{
name|int
name|reg_num
init|=
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|opr
operator|.
name|idx
operator|+
literal|1
decl_stmt|;
comment|/* We are at the first node of this sub expression.  */
if|if
condition|(
name|reg_num
operator|<
name|nmatch
condition|)
block|{
name|pmatch
index|[
name|reg_num
index|]
operator|.
name|rm_so
operator|=
name|cur_idx
expr_stmt|;
name|pmatch
index|[
name|reg_num
index|]
operator|.
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_CLOSE_SUBEXP
condition|)
block|{
name|int
name|reg_num
init|=
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|opr
operator|.
name|idx
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|reg_num
operator|<
name|nmatch
condition|)
block|{
comment|/* We are at the last node of this sub expression.  */
if|if
condition|(
name|pmatch
index|[
name|reg_num
index|]
operator|.
name|rm_so
operator|<
name|cur_idx
condition|)
block|{
name|pmatch
index|[
name|reg_num
index|]
operator|.
name|rm_eo
operator|=
name|cur_idx
expr_stmt|;
comment|/* This is a non-empty match or we are not inside an optional 		 subexpression.  Accept this right away.  */
name|memcpy
argument_list|(
name|prev_idx_match
argument_list|,
name|pmatch
argument_list|,
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|nmatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|opt_subexp
operator|&&
name|prev_idx_match
index|[
name|reg_num
index|]
operator|.
name|rm_so
operator|!=
operator|-
literal|1
condition|)
comment|/* We transited through an empty match for an optional 		   subexpression, like (a?)*, and this is not the subexp's 		   first match.  Copy back the old content of the registers 		   so that matches of an inner subexpression are undone as 		   well, like in ((a?))*.  */
name|memcpy
argument_list|(
name|pmatch
argument_list|,
name|prev_idx_match
argument_list|,
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
operator|*
name|nmatch
argument_list|)
expr_stmt|;
else|else
comment|/* We completed a subexpression, but it may be part of 		   an optional one, so do not update PREV_IDX_MATCH.  */
name|pmatch
index|[
name|reg_num
index|]
operator|.
name|rm_eo
operator|=
name|cur_idx
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* This function checks the STATE_LOG from the SCTX->last_str_idx to 0    and sift the nodes in each states according to the following rules.    Updated state_log will be wrote to STATE_LOG.     Rules: We throw away the Node `a' in the STATE_LOG[STR_IDX] if...      1. When STR_IDX == MATCH_LAST(the last index in the state_log): 	If `a' isn't the LAST_NODE and `a' can't epsilon transit to 	the LAST_NODE, we throw away the node `a'.      2. When 0<= STR_IDX< MATCH_LAST and `a' accepts 	string `s' and transit to `b': 	i. If 'b' isn't in the STATE_LOG[STR_IDX+strlen('s')], we throw 	   away the node `a'. 	ii. If 'b' is in the STATE_LOG[STR_IDX+strlen('s')] but 'b' is 	    thrown away, we throw away the node `a'.      3. When 0<= STR_IDX< MATCH_LAST and 'a' epsilon transit to 'b': 	i. If 'b' isn't in the STATE_LOG[STR_IDX], we throw away the 	   node `a'. 	ii. If 'b' is in the STATE_LOG[STR_IDX] but 'b' is thrown away, 	    we throw away the node `a'.  */
end_comment

begin_define
define|#
directive|define
name|STATE_NODE_CONTAINS
parameter_list|(
name|state
parameter_list|,
name|node
parameter_list|)
define|\
value|((state) != NULL&& re_node_set_contains (&(state)->nodes, node))
end_define

begin_function
specifier|static
name|reg_errcode_t
name|sift_states_backward
parameter_list|(
name|mctx
parameter_list|,
name|sctx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_sift_context_t
modifier|*
name|sctx
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|null_cnt
init|=
literal|0
decl_stmt|;
name|int
name|str_idx
init|=
name|sctx
operator|->
name|last_str_idx
decl_stmt|;
name|re_node_set
name|cur_dest
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|mctx
operator|->
name|state_log
operator|!=
name|NULL
operator|&&
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build sifted state_log[str_idx].  It has the nodes which can epsilon      transit to the last_node and the last_node itself.  */
name|err
operator|=
name|re_node_set_init_1
argument_list|(
operator|&
name|cur_dest
argument_list|,
name|sctx
operator|->
name|last_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|err
operator|=
name|update_cur_sifted_state
argument_list|(
name|mctx
argument_list|,
name|sctx
argument_list|,
name|str_idx
argument_list|,
operator|&
name|cur_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
comment|/* Then check each states in the state_log.  */
while|while
condition|(
name|str_idx
operator|>
literal|0
condition|)
block|{
comment|/* Update counters.  */
name|null_cnt
operator|=
operator|(
name|sctx
operator|->
name|sifted_states
index|[
name|str_idx
index|]
operator|==
name|NULL
operator|)
condition|?
name|null_cnt
operator|+
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|null_cnt
operator|>
name|mctx
operator|->
name|max_mb_elem_len
condition|)
block|{
name|memset
argument_list|(
name|sctx
operator|->
name|sifted_states
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
operator|*
name|str_idx
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|cur_dest
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
name|re_node_set_empty
argument_list|(
operator|&
name|cur_dest
argument_list|)
expr_stmt|;
operator|--
name|str_idx
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
condition|)
block|{
name|err
operator|=
name|build_sifted_states
argument_list|(
name|mctx
argument_list|,
name|sctx
argument_list|,
name|str_idx
argument_list|,
operator|&
name|cur_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
comment|/* Add all the nodes which satisfy the following conditions: 	 - It can epsilon transit to a node in CUR_DEST. 	 - It is in CUR_SRC. 	 And update state_log.  */
name|err
operator|=
name|update_cur_sifted_state
argument_list|(
name|mctx
argument_list|,
name|sctx
argument_list|,
name|str_idx
argument_list|,
operator|&
name|cur_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
name|err
operator|=
name|REG_NOERROR
expr_stmt|;
name|free_return
label|:
name|re_node_set_free
argument_list|(
operator|&
name|cur_dest
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|build_sifted_states
parameter_list|(
name|mctx
parameter_list|,
name|sctx
parameter_list|,
name|str_idx
parameter_list|,
name|cur_dest
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_sift_context_t
modifier|*
name|sctx
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
name|re_node_set
modifier|*
name|cur_dest
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|re_node_set
modifier|*
name|cur_src
init|=
operator|&
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|->
name|non_eps_nodes
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Then build the next sifted state.      We build the next sifted state on `cur_dest', and update      `sifted_states[str_idx]' with `cur_dest'.      Note:      `cur_dest' is the sifted state from `state_log[str_idx + 1]'.      `cur_src' points the node_set of the old `state_log[str_idx]'      (with the epsilon nodes pre-filtered out).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_src
operator|->
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|int
name|prev_node
init|=
name|cur_src
operator|->
name|elems
index|[
name|i
index|]
decl_stmt|;
name|int
name|naccepted
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|prev_node
index|]
operator|.
name|type
decl_stmt|;
name|assert
argument_list|(
operator|!
name|IS_EPSILON_NODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* If the node may accept `multi byte'.  */
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|prev_node
index|]
operator|.
name|accept_mb
condition|)
name|naccepted
operator|=
name|sift_states_iter_mb
argument_list|(
name|mctx
argument_list|,
name|sctx
argument_list|,
name|prev_node
argument_list|,
name|str_idx
argument_list|,
name|sctx
operator|->
name|last_str_idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
comment|/* We don't check backreferences here. 	 See update_cur_sifted_state().  */
if|if
condition|(
operator|!
name|naccepted
operator|&&
name|check_node_accept
argument_list|(
name|mctx
argument_list|,
name|dfa
operator|->
name|nodes
operator|+
name|prev_node
argument_list|,
name|str_idx
argument_list|)
operator|&&
name|STATE_NODE_CONTAINS
argument_list|(
name|sctx
operator|->
name|sifted_states
index|[
name|str_idx
operator|+
literal|1
index|]
argument_list|,
name|dfa
operator|->
name|nexts
index|[
name|prev_node
index|]
argument_list|)
condition|)
name|naccepted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|naccepted
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sctx
operator|->
name|limits
operator|.
name|nelem
condition|)
block|{
name|int
name|to_idx
init|=
name|str_idx
operator|+
name|naccepted
decl_stmt|;
if|if
condition|(
name|check_dst_limits
argument_list|(
name|mctx
argument_list|,
operator|&
name|sctx
operator|->
name|limits
argument_list|,
name|dfa
operator|->
name|nexts
index|[
name|prev_node
index|]
argument_list|,
name|to_idx
argument_list|,
name|prev_node
argument_list|,
name|str_idx
argument_list|)
condition|)
continue|continue;
block|}
name|ret
operator|=
name|re_node_set_insert
argument_list|(
name|cur_dest
argument_list|,
name|prev_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|==
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper functions.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|clean_state_log_if_needed
parameter_list|(
name|mctx
parameter_list|,
name|next_state_log_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|next_state_log_idx
decl_stmt|;
block|{
name|int
name|top
init|=
name|mctx
operator|->
name|state_log_top
decl_stmt|;
if|if
condition|(
name|next_state_log_idx
operator|>=
name|mctx
operator|->
name|input
operator|.
name|bufs_len
operator|||
operator|(
name|next_state_log_idx
operator|>=
name|mctx
operator|->
name|input
operator|.
name|valid_len
operator|&&
name|mctx
operator|->
name|input
operator|.
name|valid_len
operator|<
name|mctx
operator|->
name|input
operator|.
name|len
operator|)
condition|)
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|err
operator|=
name|extend_buffers
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
if|if
condition|(
name|top
operator|<
name|next_state_log_idx
condition|)
block|{
name|memset
argument_list|(
name|mctx
operator|->
name|state_log
operator|+
name|top
operator|+
literal|1
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
operator|*
operator|(
name|next_state_log_idx
operator|-
name|top
operator|)
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|state_log_top
operator|=
name|next_state_log_idx
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|merge_state_array
parameter_list|(
name|dfa
parameter_list|,
name|dst
parameter_list|,
name|src
parameter_list|,
name|num
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|dst
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|src
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|int
name|st_idx
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
for|for
control|(
name|st_idx
operator|=
literal|0
init|;
name|st_idx
operator|<
name|num
condition|;
operator|++
name|st_idx
control|)
block|{
if|if
condition|(
name|dst
index|[
name|st_idx
index|]
operator|==
name|NULL
condition|)
name|dst
index|[
name|st_idx
index|]
operator|=
name|src
index|[
name|st_idx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|src
index|[
name|st_idx
index|]
operator|!=
name|NULL
condition|)
block|{
name|re_node_set
name|merged_set
decl_stmt|;
name|err
operator|=
name|re_node_set_init_union
argument_list|(
operator|&
name|merged_set
argument_list|,
operator|&
name|dst
index|[
name|st_idx
index|]
operator|->
name|nodes
argument_list|,
operator|&
name|src
index|[
name|st_idx
index|]
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|dst
index|[
name|st_idx
index|]
operator|=
name|re_acquire_state
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|merged_set
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|merged_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|update_cur_sifted_state
parameter_list|(
name|mctx
parameter_list|,
name|sctx
parameter_list|,
name|str_idx
parameter_list|,
name|dest_nodes
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_sift_context_t
modifier|*
name|sctx
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
name|re_node_set
modifier|*
name|dest_nodes
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|candidates
decl_stmt|;
name|candidates
operator|=
operator|(
operator|(
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
operator|&
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|->
name|nodes
operator|)
expr_stmt|;
if|if
condition|(
name|dest_nodes
operator|->
name|nelem
operator|==
literal|0
condition|)
name|sctx
operator|->
name|sifted_states
index|[
name|str_idx
index|]
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|candidates
condition|)
block|{
comment|/* At first, add the nodes which can epsilon transit to a node in 	     DEST_NODE.  */
name|err
operator|=
name|add_epsilon_src_nodes
argument_list|(
name|dfa
argument_list|,
name|dest_nodes
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* Then, check the limitations in the current sift_context.  */
if|if
condition|(
name|sctx
operator|->
name|limits
operator|.
name|nelem
condition|)
block|{
name|err
operator|=
name|check_subexp_limits
argument_list|(
name|dfa
argument_list|,
name|dest_nodes
argument_list|,
name|candidates
argument_list|,
operator|&
name|sctx
operator|->
name|limits
argument_list|,
name|mctx
operator|->
name|bkref_ents
argument_list|,
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
block|}
name|sctx
operator|->
name|sifted_states
index|[
name|str_idx
index|]
operator|=
name|re_acquire_state
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
name|dest_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
if|if
condition|(
name|candidates
operator|&&
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|->
name|has_backref
condition|)
block|{
name|err
operator|=
name|sift_states_bkref
argument_list|(
name|mctx
argument_list|,
name|sctx
argument_list|,
name|str_idx
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|add_epsilon_src_nodes
parameter_list|(
name|dfa
parameter_list|,
name|dest_nodes
parameter_list|,
name|candidates
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_node_set
modifier|*
name|dest_nodes
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|candidates
decl_stmt|;
block|{
name|reg_errcode_t
name|err
init|=
name|REG_NOERROR
decl_stmt|;
name|int
name|i
decl_stmt|;
name|re_dfastate_t
modifier|*
name|state
init|=
name|re_acquire_state
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
name|dest_nodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|state
operator|->
name|inveclosure
operator|.
name|alloc
condition|)
block|{
name|err
operator|=
name|re_node_set_alloc
argument_list|(
operator|&
name|state
operator|->
name|inveclosure
argument_list|,
name|dest_nodes
operator|->
name|nelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dest_nodes
operator|->
name|nelem
condition|;
name|i
operator|++
control|)
name|re_node_set_merge
argument_list|(
operator|&
name|state
operator|->
name|inveclosure
argument_list|,
name|dfa
operator|->
name|inveclosures
operator|+
name|dest_nodes
operator|->
name|elems
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|re_node_set_add_intersect
argument_list|(
name|dest_nodes
argument_list|,
name|candidates
argument_list|,
operator|&
name|state
operator|->
name|inveclosure
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|sub_epsilon_src_nodes
parameter_list|(
name|dfa
parameter_list|,
name|node
parameter_list|,
name|dest_nodes
parameter_list|,
name|candidates
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|node
decl_stmt|;
name|re_node_set
modifier|*
name|dest_nodes
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|candidates
decl_stmt|;
block|{
name|int
name|ecl_idx
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|re_node_set
modifier|*
name|inv_eclosure
init|=
name|dfa
operator|->
name|inveclosures
operator|+
name|node
decl_stmt|;
name|re_node_set
name|except_nodes
decl_stmt|;
name|re_node_set_init_empty
argument_list|(
operator|&
name|except_nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|ecl_idx
operator|=
literal|0
init|;
name|ecl_idx
operator|<
name|inv_eclosure
operator|->
name|nelem
condition|;
operator|++
name|ecl_idx
control|)
block|{
name|int
name|cur_node
init|=
name|inv_eclosure
operator|->
name|elems
index|[
name|ecl_idx
index|]
decl_stmt|;
if|if
condition|(
name|cur_node
operator|==
name|node
condition|)
continue|continue;
if|if
condition|(
name|IS_EPSILON_NODE
argument_list|(
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|type
argument_list|)
condition|)
block|{
name|int
name|edst1
init|=
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|elems
index|[
literal|0
index|]
decl_stmt|;
name|int
name|edst2
init|=
operator|(
operator|(
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|nelem
operator|>
literal|1
operator|)
condition|?
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|elems
index|[
literal|1
index|]
else|:
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|re_node_set_contains
argument_list|(
name|inv_eclosure
argument_list|,
name|edst1
argument_list|)
operator|&&
name|re_node_set_contains
argument_list|(
name|dest_nodes
argument_list|,
name|edst1
argument_list|)
operator|)
operator|||
operator|(
name|edst2
operator|>
literal|0
operator|&&
operator|!
name|re_node_set_contains
argument_list|(
name|inv_eclosure
argument_list|,
name|edst2
argument_list|)
operator|&&
name|re_node_set_contains
argument_list|(
name|dest_nodes
argument_list|,
name|edst2
argument_list|)
operator|)
condition|)
block|{
name|err
operator|=
name|re_node_set_add_intersect
argument_list|(
operator|&
name|except_nodes
argument_list|,
name|candidates
argument_list|,
name|dfa
operator|->
name|inveclosures
operator|+
name|cur_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|except_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
block|}
block|}
for|for
control|(
name|ecl_idx
operator|=
literal|0
init|;
name|ecl_idx
operator|<
name|inv_eclosure
operator|->
name|nelem
condition|;
operator|++
name|ecl_idx
control|)
block|{
name|int
name|cur_node
init|=
name|inv_eclosure
operator|->
name|elems
index|[
name|ecl_idx
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|re_node_set_contains
argument_list|(
operator|&
name|except_nodes
argument_list|,
name|cur_node
argument_list|)
condition|)
block|{
name|int
name|idx
init|=
name|re_node_set_contains
argument_list|(
name|dest_nodes
argument_list|,
name|cur_node
argument_list|)
operator|-
literal|1
decl_stmt|;
name|re_node_set_remove_at
argument_list|(
name|dest_nodes
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
name|re_node_set_free
argument_list|(
operator|&
name|except_nodes
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_dst_limits
parameter_list|(
name|mctx
parameter_list|,
name|limits
parameter_list|,
name|dst_node
parameter_list|,
name|dst_idx
parameter_list|,
name|src_node
parameter_list|,
name|src_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_node_set
modifier|*
name|limits
decl_stmt|;
name|int
name|dst_node
decl_stmt|,
name|dst_idx
decl_stmt|,
name|src_node
decl_stmt|,
name|src_idx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|lim_idx
decl_stmt|,
name|src_pos
decl_stmt|,
name|dst_pos
decl_stmt|;
name|int
name|dst_bkref_idx
init|=
name|search_cur_bkref_entry
argument_list|(
name|mctx
argument_list|,
name|dst_idx
argument_list|)
decl_stmt|;
name|int
name|src_bkref_idx
init|=
name|search_cur_bkref_entry
argument_list|(
name|mctx
argument_list|,
name|src_idx
argument_list|)
decl_stmt|;
for|for
control|(
name|lim_idx
operator|=
literal|0
init|;
name|lim_idx
operator|<
name|limits
operator|->
name|nelem
condition|;
operator|++
name|lim_idx
control|)
block|{
name|int
name|subexp_idx
decl_stmt|;
name|struct
name|re_backref_cache_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|limits
operator|->
name|elems
index|[
name|lim_idx
index|]
expr_stmt|;
name|subexp_idx
operator|=
name|dfa
operator|->
name|nodes
index|[
name|ent
operator|->
name|node
index|]
operator|.
name|opr
operator|.
name|idx
expr_stmt|;
name|dst_pos
operator|=
name|check_dst_limits_calc_pos
argument_list|(
name|mctx
argument_list|,
name|limits
operator|->
name|elems
index|[
name|lim_idx
index|]
argument_list|,
name|subexp_idx
argument_list|,
name|dst_node
argument_list|,
name|dst_idx
argument_list|,
name|dst_bkref_idx
argument_list|)
expr_stmt|;
name|src_pos
operator|=
name|check_dst_limits_calc_pos
argument_list|(
name|mctx
argument_list|,
name|limits
operator|->
name|elems
index|[
name|lim_idx
index|]
argument_list|,
name|subexp_idx
argument_list|,
name|src_node
argument_list|,
name|src_idx
argument_list|,
name|src_bkref_idx
argument_list|)
expr_stmt|;
comment|/* In case of:<src><dst> (<subexp> ) 	 (<subexp> )<src><dst> 	 (<subexp1><src><subexp2><dst><subexp3> )  */
if|if
condition|(
name|src_pos
operator|==
name|dst_pos
condition|)
continue|continue;
comment|/* This is unrelated limitation.  */
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_dst_limits_calc_pos_1
parameter_list|(
name|mctx
parameter_list|,
name|boundaries
parameter_list|,
name|subexp_idx
parameter_list|,
name|from_node
parameter_list|,
name|bkref_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|boundaries
decl_stmt|,
name|subexp_idx
decl_stmt|,
name|from_node
decl_stmt|,
name|bkref_idx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|re_node_set
modifier|*
name|eclosures
init|=
name|dfa
operator|->
name|eclosures
operator|+
name|from_node
decl_stmt|;
name|int
name|node_idx
decl_stmt|;
comment|/* Else, we are on the boundary: examine the nodes on the epsilon      closure.  */
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
name|node_idx
operator|<
name|eclosures
operator|->
name|nelem
condition|;
operator|++
name|node_idx
control|)
block|{
name|int
name|node
init|=
name|eclosures
operator|->
name|elems
index|[
name|node_idx
index|]
decl_stmt|;
switch|switch
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
condition|)
block|{
case|case
name|OP_BACK_REF
case|:
if|if
condition|(
name|bkref_idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|re_backref_cache_entry
modifier|*
name|ent
init|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|bkref_idx
decl_stmt|;
do|do
block|{
name|int
name|dst
decl_stmt|,
name|cpos
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|node
operator|!=
name|node
condition|)
continue|continue;
if|if
condition|(
name|subexp_idx
operator|<=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|ent
operator|->
name|eps_reachable_subexps_map
argument_list|)
operator|&&
operator|!
operator|(
name|ent
operator|->
name|eps_reachable_subexps_map
operator|&
operator|(
literal|1
operator|<<
name|subexp_idx
operator|)
operator|)
condition|)
continue|continue;
comment|/* Recurse trying to reach the OP_OPEN_SUBEXP and 		     OP_CLOSE_SUBEXP cases below.  But, if the 		     destination node is the same node as the source 		     node, don't recurse because it would cause an 		     infinite loop: a regex that exhibits this behavior 		     is ()\1*\1*  */
name|dst
operator|=
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|elems
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|from_node
condition|)
block|{
if|if
condition|(
name|boundaries
operator|&
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
comment|/* if (boundaries& 2) */
return|return
literal|0
return|;
block|}
name|cpos
operator|=
name|check_dst_limits_calc_pos_1
argument_list|(
name|mctx
argument_list|,
name|boundaries
argument_list|,
name|subexp_idx
argument_list|,
name|dst
argument_list|,
name|bkref_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpos
operator|==
operator|-
literal|1
comment|/*&& (boundaries& 1) */
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cpos
operator|==
literal|0
operator|&&
operator|(
name|boundaries
operator|&
literal|2
operator|)
condition|)
return|return
literal|0
return|;
name|ent
operator|->
name|eps_reachable_subexps_map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|subexp_idx
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|ent
operator|++
operator|->
name|more
condition|)
do|;
block|}
break|break;
case|case
name|OP_OPEN_SUBEXP
case|:
if|if
condition|(
operator|(
name|boundaries
operator|&
literal|1
operator|)
operator|&&
name|subexp_idx
operator|==
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|OP_CLOSE_SUBEXP
case|:
if|if
condition|(
operator|(
name|boundaries
operator|&
literal|2
operator|)
operator|&&
name|subexp_idx
operator|==
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|boundaries
operator|&
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_dst_limits_calc_pos
parameter_list|(
name|mctx
parameter_list|,
name|limit
parameter_list|,
name|subexp_idx
parameter_list|,
name|from_node
parameter_list|,
name|str_idx
parameter_list|,
name|bkref_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|limit
decl_stmt|,
name|subexp_idx
decl_stmt|,
name|from_node
decl_stmt|,
name|str_idx
decl_stmt|,
name|bkref_idx
decl_stmt|;
block|{
name|struct
name|re_backref_cache_entry
modifier|*
name|lim
init|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|limit
decl_stmt|;
name|int
name|boundaries
decl_stmt|;
comment|/* If we are outside the range of the subexpression, return -1 or 1.  */
if|if
condition|(
name|str_idx
operator|<
name|lim
operator|->
name|subexp_from
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|lim
operator|->
name|subexp_to
operator|<
name|str_idx
condition|)
return|return
literal|1
return|;
comment|/* If we are within the subexpression, return 0.  */
name|boundaries
operator|=
operator|(
name|str_idx
operator|==
name|lim
operator|->
name|subexp_from
operator|)
expr_stmt|;
name|boundaries
operator||=
operator|(
name|str_idx
operator|==
name|lim
operator|->
name|subexp_to
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|boundaries
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Else, examine epsilon closure.  */
return|return
name|check_dst_limits_calc_pos_1
argument_list|(
name|mctx
argument_list|,
name|boundaries
argument_list|,
name|subexp_idx
argument_list|,
name|from_node
argument_list|,
name|bkref_idx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check the limitations of sub expressions LIMITS, and remove the nodes    which are against limitations from DEST_NODES. */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|check_subexp_limits
parameter_list|(
name|dfa
parameter_list|,
name|dest_nodes
parameter_list|,
name|candidates
parameter_list|,
name|limits
parameter_list|,
name|bkref_ents
parameter_list|,
name|str_idx
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_node_set
modifier|*
name|dest_nodes
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|candidates
decl_stmt|;
name|re_node_set
modifier|*
name|limits
decl_stmt|;
name|struct
name|re_backref_cache_entry
modifier|*
name|bkref_ents
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|node_idx
decl_stmt|,
name|lim_idx
decl_stmt|;
for|for
control|(
name|lim_idx
operator|=
literal|0
init|;
name|lim_idx
operator|<
name|limits
operator|->
name|nelem
condition|;
operator|++
name|lim_idx
control|)
block|{
name|int
name|subexp_idx
decl_stmt|;
name|struct
name|re_backref_cache_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|bkref_ents
operator|+
name|limits
operator|->
name|elems
index|[
name|lim_idx
index|]
expr_stmt|;
if|if
condition|(
name|str_idx
operator|<=
name|ent
operator|->
name|subexp_from
operator|||
name|ent
operator|->
name|str_idx
operator|<
name|str_idx
condition|)
continue|continue;
comment|/* This is unrelated limitation.  */
name|subexp_idx
operator|=
name|dfa
operator|->
name|nodes
index|[
name|ent
operator|->
name|node
index|]
operator|.
name|opr
operator|.
name|idx
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|subexp_to
operator|==
name|str_idx
condition|)
block|{
name|int
name|ops_node
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cls_node
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
name|node_idx
operator|<
name|dest_nodes
operator|->
name|nelem
condition|;
operator|++
name|node_idx
control|)
block|{
name|int
name|node
init|=
name|dest_nodes
operator|->
name|elems
index|[
name|node_idx
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_OPEN_SUBEXP
operator|&&
name|subexp_idx
operator|==
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
name|ops_node
operator|=
name|node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_CLOSE_SUBEXP
operator|&&
name|subexp_idx
operator|==
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
name|cls_node
operator|=
name|node
expr_stmt|;
block|}
comment|/* Check the limitation of the open subexpression.  */
comment|/* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */
if|if
condition|(
name|ops_node
operator|>=
literal|0
condition|)
block|{
name|err
operator|=
name|sub_epsilon_src_nodes
argument_list|(
name|dfa
argument_list|,
name|ops_node
argument_list|,
name|dest_nodes
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
comment|/* Check the limitation of the close subexpression.  */
if|if
condition|(
name|cls_node
operator|>=
literal|0
condition|)
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
name|node_idx
operator|<
name|dest_nodes
operator|->
name|nelem
condition|;
operator|++
name|node_idx
control|)
block|{
name|int
name|node
init|=
name|dest_nodes
operator|->
name|elems
index|[
name|node_idx
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|re_node_set_contains
argument_list|(
name|dfa
operator|->
name|inveclosures
operator|+
name|node
argument_list|,
name|cls_node
argument_list|)
operator|&&
operator|!
name|re_node_set_contains
argument_list|(
name|dfa
operator|->
name|eclosures
operator|+
name|node
argument_list|,
name|cls_node
argument_list|)
condition|)
block|{
comment|/* It is against this limitation. 		       Remove it form the current sifted state.  */
name|err
operator|=
name|sub_epsilon_src_nodes
argument_list|(
name|dfa
argument_list|,
name|node
argument_list|,
name|dest_nodes
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
operator|--
name|node_idx
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* (ent->subexp_to != str_idx)  */
block|{
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
name|node_idx
operator|<
name|dest_nodes
operator|->
name|nelem
condition|;
operator|++
name|node_idx
control|)
block|{
name|int
name|node
init|=
name|dest_nodes
operator|->
name|elems
index|[
name|node_idx
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_CLOSE_SUBEXP
operator|||
name|type
operator|==
name|OP_OPEN_SUBEXP
condition|)
block|{
if|if
condition|(
name|subexp_idx
operator|!=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
condition|)
continue|continue;
comment|/* It is against this limitation. 		     Remove it form the current sifted state.  */
name|err
operator|=
name|sub_epsilon_src_nodes
argument_list|(
name|dfa
argument_list|,
name|node
argument_list|,
name|dest_nodes
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
block|}
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|sift_states_bkref
parameter_list|(
name|mctx
parameter_list|,
name|sctx
parameter_list|,
name|str_idx
parameter_list|,
name|candidates
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_sift_context_t
modifier|*
name|sctx
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|candidates
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|node_idx
decl_stmt|,
name|node
decl_stmt|;
name|re_sift_context_t
name|local_sctx
decl_stmt|;
name|int
name|first_idx
init|=
name|search_cur_bkref_entry
argument_list|(
name|mctx
argument_list|,
name|str_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|first_idx
operator|==
operator|-
literal|1
condition|)
return|return
name|REG_NOERROR
return|;
name|local_sctx
operator|.
name|sifted_states
operator|=
name|NULL
expr_stmt|;
comment|/* Mark that it hasn't been initialized.  */
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
name|node_idx
operator|<
name|candidates
operator|->
name|nelem
condition|;
operator|++
name|node_idx
control|)
block|{
name|int
name|enabled_idx
decl_stmt|;
name|re_token_type_t
name|type
decl_stmt|;
name|struct
name|re_backref_cache_entry
modifier|*
name|entry
decl_stmt|;
name|node
operator|=
name|candidates
operator|->
name|elems
index|[
name|node_idx
index|]
expr_stmt|;
name|type
operator|=
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
expr_stmt|;
comment|/* Avoid infinite loop for the REs like "()\1+".  */
if|if
condition|(
name|node
operator|==
name|sctx
operator|->
name|last_node
operator|&&
name|str_idx
operator|==
name|sctx
operator|->
name|last_str_idx
condition|)
continue|continue;
if|if
condition|(
name|type
operator|!=
name|OP_BACK_REF
condition|)
continue|continue;
name|entry
operator|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|first_idx
expr_stmt|;
name|enabled_idx
operator|=
name|first_idx
expr_stmt|;
do|do
block|{
name|int
name|subexp_len
decl_stmt|,
name|to_idx
decl_stmt|,
name|dst_node
decl_stmt|;
name|re_dfastate_t
modifier|*
name|cur_state
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|node
operator|!=
name|node
condition|)
continue|continue;
name|subexp_len
operator|=
name|entry
operator|->
name|subexp_to
operator|-
name|entry
operator|->
name|subexp_from
expr_stmt|;
name|to_idx
operator|=
name|str_idx
operator|+
name|subexp_len
expr_stmt|;
name|dst_node
operator|=
operator|(
name|subexp_len
condition|?
name|dfa
operator|->
name|nexts
index|[
name|node
index|]
else|:
name|dfa
operator|->
name|edests
index|[
name|node
index|]
operator|.
name|elems
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|to_idx
operator|>
name|sctx
operator|->
name|last_str_idx
operator|||
name|sctx
operator|->
name|sifted_states
index|[
name|to_idx
index|]
operator|==
name|NULL
operator|||
operator|!
name|STATE_NODE_CONTAINS
argument_list|(
name|sctx
operator|->
name|sifted_states
index|[
name|to_idx
index|]
argument_list|,
name|dst_node
argument_list|)
operator|||
name|check_dst_limits
argument_list|(
name|mctx
argument_list|,
operator|&
name|sctx
operator|->
name|limits
argument_list|,
name|node
argument_list|,
name|str_idx
argument_list|,
name|dst_node
argument_list|,
name|to_idx
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|local_sctx
operator|.
name|sifted_states
operator|==
name|NULL
condition|)
block|{
name|local_sctx
operator|=
operator|*
name|sctx
expr_stmt|;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|local_sctx
operator|.
name|limits
argument_list|,
operator|&
name|sctx
operator|->
name|limits
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
name|local_sctx
operator|.
name|last_node
operator|=
name|node
expr_stmt|;
name|local_sctx
operator|.
name|last_str_idx
operator|=
name|str_idx
expr_stmt|;
name|err
operator|=
name|re_node_set_insert
argument_list|(
operator|&
name|local_sctx
operator|.
name|limits
argument_list|,
name|enabled_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
name|cur_state
operator|=
name|local_sctx
operator|.
name|sifted_states
index|[
name|str_idx
index|]
expr_stmt|;
name|err
operator|=
name|sift_states_backward
argument_list|(
name|mctx
argument_list|,
operator|&
name|local_sctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
if|if
condition|(
name|sctx
operator|->
name|limited_states
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|merge_state_array
argument_list|(
name|dfa
argument_list|,
name|sctx
operator|->
name|limited_states
argument_list|,
name|local_sctx
operator|.
name|sifted_states
argument_list|,
name|str_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
name|local_sctx
operator|.
name|sifted_states
index|[
name|str_idx
index|]
operator|=
name|cur_state
expr_stmt|;
name|re_node_set_remove
argument_list|(
operator|&
name|local_sctx
operator|.
name|limits
argument_list|,
name|enabled_idx
argument_list|)
expr_stmt|;
comment|/* mctx->bkref_ents may have changed, reload the pointer.  */
name|entry
operator|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|enabled_idx
expr_stmt|;
block|}
do|while
condition|(
name|enabled_idx
operator|++
operator|,
name|entry
operator|++
operator|->
name|more
condition|)
do|;
block|}
name|err
operator|=
name|REG_NOERROR
expr_stmt|;
name|free_return
label|:
if|if
condition|(
name|local_sctx
operator|.
name|sifted_states
operator|!=
name|NULL
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|local_sctx
operator|.
name|limits
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function
specifier|static
name|int
name|sift_states_iter_mb
parameter_list|(
name|mctx
parameter_list|,
name|sctx
parameter_list|,
name|node_idx
parameter_list|,
name|str_idx
parameter_list|,
name|max_str_idx
parameter_list|)
specifier|const
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_sift_context_t
modifier|*
name|sctx
decl_stmt|;
name|int
name|node_idx
decl_stmt|,
name|str_idx
decl_stmt|,
name|max_str_idx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|naccepted
decl_stmt|;
comment|/* Check the node can accept `multi byte'.  */
name|naccepted
operator|=
name|check_node_accept_bytes
argument_list|(
name|dfa
argument_list|,
name|node_idx
argument_list|,
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|naccepted
operator|>
literal|0
operator|&&
name|str_idx
operator|+
name|naccepted
operator|<=
name|max_str_idx
operator|&&
operator|!
name|STATE_NODE_CONTAINS
argument_list|(
name|sctx
operator|->
name|sifted_states
index|[
name|str_idx
operator|+
name|naccepted
index|]
argument_list|,
name|dfa
operator|->
name|nexts
index|[
name|node_idx
index|]
argument_list|)
condition|)
comment|/* The node can't accept the `multi byte', or the        destination was already thrown away, then the node        could't accept the current input `multi byte'.   */
name|naccepted
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise, it is sure that the node could accept      `naccepted' bytes input.  */
return|return
name|naccepted
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Functions for state transition.  */
end_comment

begin_comment
comment|/* Return the next state to which the current state STATE will transit by    accepting the current input byte, and update STATE_LOG if necessary.    If STATE can accept a multibyte char/collating element/back reference    update the destination of STATE_LOG.  */
end_comment

begin_function
specifier|static
name|re_dfastate_t
modifier|*
name|transit_state
parameter_list|(
name|err
parameter_list|,
name|mctx
parameter_list|,
name|state
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_dfastate_t
modifier|*
name|state
decl_stmt|;
block|{
name|re_dfastate_t
modifier|*
modifier|*
name|trtable
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* If the current state can accept multibyte.  */
if|if
condition|(
name|BE
argument_list|(
name|state
operator|->
name|accept_mb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|transit_state_mb
argument_list|(
name|mctx
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
comment|/* Then decide the next state with the single byte.  */
if|#
directive|if
literal|0
block|if (0)
comment|/* don't use transition table  */
block|return transit_state_sb (err, mctx, state);
endif|#
directive|endif
comment|/* Use transition table  */
name|ch
operator|=
name|re_string_fetch_byte
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|trtable
operator|=
name|state
operator|->
name|trtable
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|trtable
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|trtable
index|[
name|ch
index|]
return|;
name|trtable
operator|=
name|state
operator|->
name|word_trtable
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|trtable
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|context
decl_stmt|;
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_WORD_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
return|return
name|trtable
index|[
name|ch
operator|+
name|SBC_MAX
index|]
return|;
else|else
return|return
name|trtable
index|[
name|ch
index|]
return|;
block|}
if|if
condition|(
operator|!
name|build_trtable
argument_list|(
name|mctx
operator|->
name|dfa
argument_list|,
name|state
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Retry, we now have a transition table.  */
block|}
block|}
end_function

begin_comment
comment|/* Update the state_log if we need */
end_comment

begin_function
name|re_dfastate_t
modifier|*
name|merge_state_with_log
parameter_list|(
name|err
parameter_list|,
name|mctx
parameter_list|,
name|next_state
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_dfastate_t
modifier|*
name|next_state
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|cur_idx
init|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_idx
operator|>
name|mctx
operator|->
name|state_log_top
condition|)
block|{
name|mctx
operator|->
name|state_log
index|[
name|cur_idx
index|]
operator|=
name|next_state
expr_stmt|;
name|mctx
operator|->
name|state_log_top
operator|=
name|cur_idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mctx
operator|->
name|state_log
index|[
name|cur_idx
index|]
operator|==
literal|0
condition|)
block|{
name|mctx
operator|->
name|state_log
index|[
name|cur_idx
index|]
operator|=
name|next_state
expr_stmt|;
block|}
else|else
block|{
name|re_dfastate_t
modifier|*
name|pstate
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
name|re_node_set
name|next_nodes
decl_stmt|,
modifier|*
name|log_nodes
decl_stmt|,
modifier|*
name|table_nodes
init|=
name|NULL
decl_stmt|;
comment|/* If (state_log[cur_idx] != 0), it implies that cur_idx is          the destination of a multibyte char/collating element/          back reference.  Then the next state is the union set of          these destinations and the results of the transition table.  */
name|pstate
operator|=
name|mctx
operator|->
name|state_log
index|[
name|cur_idx
index|]
expr_stmt|;
name|log_nodes
operator|=
name|pstate
operator|->
name|entrance_nodes
expr_stmt|;
if|if
condition|(
name|next_state
operator|!=
name|NULL
condition|)
block|{
name|table_nodes
operator|=
name|next_state
operator|->
name|entrance_nodes
expr_stmt|;
operator|*
name|err
operator|=
name|re_node_set_init_union
argument_list|(
operator|&
name|next_nodes
argument_list|,
name|table_nodes
argument_list|,
name|log_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|next_nodes
operator|=
operator|*
name|log_nodes
expr_stmt|;
comment|/* Note: We already add the nodes of the initial state, 	 then we don't need to add them here.  */
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
name|next_state
operator|=
name|mctx
operator|->
name|state_log
index|[
name|cur_idx
index|]
operator|=
name|re_acquire_state_context
argument_list|(
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* We don't need to check errors here, since the return value of          this function is next_state and ERR is already set.  */
if|if
condition|(
name|table_nodes
operator|!=
name|NULL
condition|)
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|nbackref
argument_list|,
literal|0
argument_list|)
operator|&&
name|next_state
operator|!=
name|NULL
condition|)
block|{
comment|/* Check OP_OPEN_SUBEXP in the current state in case that we use them 	 later.  We must check them here, since the back references in the 	 next state might use them.  */
operator|*
name|err
operator|=
name|check_subexp_matching_top
argument_list|(
name|mctx
argument_list|,
operator|&
name|next_state
operator|->
name|nodes
argument_list|,
name|cur_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If the next state has back references.  */
if|if
condition|(
name|next_state
operator|->
name|has_backref
condition|)
block|{
operator|*
name|err
operator|=
name|transit_state_bkref
argument_list|(
name|mctx
argument_list|,
operator|&
name|next_state
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
operator|*
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|next_state
operator|=
name|mctx
operator|->
name|state_log
index|[
name|cur_idx
index|]
expr_stmt|;
block|}
block|}
return|return
name|next_state
return|;
block|}
end_function

begin_comment
comment|/* Skip bytes in the input that correspond to part of a    multi-byte match, then look in the log for a state    from which to restart matching.  */
end_comment

begin_function
name|re_dfastate_t
modifier|*
name|find_recover_state
parameter_list|(
name|err
parameter_list|,
name|mctx
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
block|{
name|re_dfastate_t
modifier|*
name|cur_state
init|=
name|NULL
decl_stmt|;
do|do
block|{
name|int
name|max
init|=
name|mctx
operator|->
name|state_log_top
decl_stmt|;
name|int
name|cur_str_idx
init|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|cur_str_idx
operator|>
name|max
condition|)
return|return
name|NULL
return|;
name|re_string_skip_bytes
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mctx
operator|->
name|state_log
index|[
name|cur_str_idx
index|]
operator|==
name|NULL
condition|)
do|;
name|cur_state
operator|=
name|merge_state_with_log
argument_list|(
name|err
argument_list|,
name|mctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|==
name|REG_NOERROR
operator|&&
name|cur_state
operator|==
name|NULL
condition|)
do|;
return|return
name|cur_state
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for transit_state.  */
end_comment

begin_comment
comment|/* From the node set CUR_NODES, pick up the nodes whose types are    OP_OPEN_SUBEXP and which have corresponding back references in the regular    expression. And register them to use them later for evaluating the    correspoding back references.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|check_subexp_matching_top
parameter_list|(
name|mctx
parameter_list|,
name|cur_nodes
parameter_list|,
name|str_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_node_set
modifier|*
name|cur_nodes
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|node_idx
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
comment|/* TODO: This isn't efficient. 	   Because there might be more than one nodes whose types are 	   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all 	   nodes. 	   E.g. RE: (a){2}  */
for|for
control|(
name|node_idx
operator|=
literal|0
init|;
name|node_idx
operator|<
name|cur_nodes
operator|->
name|nelem
condition|;
operator|++
name|node_idx
control|)
block|{
name|int
name|node
init|=
name|cur_nodes
operator|->
name|elems
index|[
name|node_idx
index|]
decl_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|type
operator|==
name|OP_OPEN_SUBEXP
operator|&&
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
operator|<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|dfa
operator|->
name|used_bkref_map
argument_list|)
operator|)
operator|&&
name|dfa
operator|->
name|used_bkref_map
operator|&
operator|(
literal|1
operator|<<
name|dfa
operator|->
name|nodes
index|[
name|node
index|]
operator|.
name|opr
operator|.
name|idx
operator|)
condition|)
block|{
name|err
operator|=
name|match_ctx_add_subtop
argument_list|(
name|mctx
argument_list|,
name|node
argument_list|,
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return the next state to which the current state STATE will transit by    accepting the current input byte.  */
end_comment

begin_comment
unit|static re_dfastate_t * transit_state_sb (err, mctx, state)      reg_errcode_t *err;      re_match_context_t *mctx;      re_dfastate_t *state; {   re_dfa_t *const dfa = mctx->dfa;   re_node_set next_nodes;   re_dfastate_t *next_state;   int node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);   unsigned int context;    *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);   if (BE (*err != REG_NOERROR, 0))     return NULL;   for (node_cnt = 0; node_cnt< state->nodes.nelem; ++node_cnt)     {       int cur_node = state->nodes.elems[node_cnt];       if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx)) 	{ 	  *err = re_node_set_merge (&next_nodes, 				    dfa->eclosures + dfa->nexts[cur_node]); 	  if (BE (*err != REG_NOERROR, 0)) 	    { 	      re_node_set_free (&next_nodes); 	      return NULL; 	    } 	}     }   context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);   next_state = re_acquire_state_context (err, dfa,&next_nodes, context);
comment|/* We don't need to check errors here, since the return value of      this function is next_state and ERR is already set.  */
end_comment

begin_endif
unit|re_node_set_free (&next_nodes);   re_string_skip_bytes (&mctx->input, 1);   return next_state; }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_function
specifier|static
name|reg_errcode_t
name|transit_state_mb
parameter_list|(
name|mctx
parameter_list|,
name|pstate
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|re_dfastate_t
modifier|*
name|pstate
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pstate
operator|->
name|nodes
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|re_node_set
name|dest_nodes
decl_stmt|,
modifier|*
name|new_nodes
decl_stmt|;
name|int
name|cur_node_idx
init|=
name|pstate
operator|->
name|nodes
operator|.
name|elems
index|[
name|i
index|]
decl_stmt|;
name|int
name|naccepted
decl_stmt|,
name|dest_idx
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
name|re_dfastate_t
modifier|*
name|dest_state
decl_stmt|;
if|if
condition|(
operator|!
name|dfa
operator|->
name|nodes
index|[
name|cur_node_idx
index|]
operator|.
name|accept_mb
condition|)
continue|continue;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|cur_node_idx
index|]
operator|.
name|constraint
condition|)
block|{
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOT_SATISFY_NEXT_CONSTRAINT
argument_list|(
name|dfa
operator|->
name|nodes
index|[
name|cur_node_idx
index|]
operator|.
name|constraint
argument_list|,
name|context
argument_list|)
condition|)
continue|continue;
block|}
comment|/* How many bytes the node can accept?  */
name|naccepted
operator|=
name|check_node_accept_bytes
argument_list|(
name|dfa
argument_list|,
name|cur_node_idx
argument_list|,
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|naccepted
operator|==
literal|0
condition|)
continue|continue;
comment|/* The node can accepts `naccepted' bytes.  */
name|dest_idx
operator|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
operator|+
name|naccepted
expr_stmt|;
name|mctx
operator|->
name|max_mb_elem_len
operator|=
operator|(
operator|(
name|mctx
operator|->
name|max_mb_elem_len
operator|<
name|naccepted
operator|)
condition|?
name|naccepted
else|:
name|mctx
operator|->
name|max_mb_elem_len
operator|)
expr_stmt|;
name|err
operator|=
name|clean_state_log_if_needed
argument_list|(
name|mctx
argument_list|,
name|dest_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|dfa
operator|->
name|nexts
index|[
name|cur_node_idx
index|]
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new_nodes
operator|=
name|dfa
operator|->
name|eclosures
operator|+
name|dfa
operator|->
name|nexts
index|[
name|cur_node_idx
index|]
expr_stmt|;
name|dest_state
operator|=
name|mctx
operator|->
name|state_log
index|[
name|dest_idx
index|]
expr_stmt|;
if|if
condition|(
name|dest_state
operator|==
name|NULL
condition|)
name|dest_nodes
operator|=
operator|*
name|new_nodes
expr_stmt|;
else|else
block|{
name|err
operator|=
name|re_node_set_init_union
argument_list|(
operator|&
name|dest_nodes
argument_list|,
name|dest_state
operator|->
name|entrance_nodes
argument_list|,
name|new_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|dest_idx
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|state_log
index|[
name|dest_idx
index|]
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|dest_nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_state
operator|!=
name|NULL
condition|)
name|re_node_set_free
argument_list|(
operator|&
name|dest_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|state_log
index|[
name|dest_idx
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|transit_state_bkref
parameter_list|(
name|mctx
parameter_list|,
name|nodes
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cur_str_idx
init|=
name|re_string_cur_idx
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|int
name|dest_str_idx
decl_stmt|,
name|prev_nelem
decl_stmt|,
name|bkc_idx
decl_stmt|;
name|int
name|node_idx
init|=
name|nodes
operator|->
name|elems
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
specifier|const
name|re_token_t
modifier|*
name|node
init|=
name|dfa
operator|->
name|nodes
operator|+
name|node_idx
decl_stmt|;
name|re_node_set
modifier|*
name|new_dest_nodes
decl_stmt|;
comment|/* Check whether `node' is a backreference or not.  */
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|OP_BACK_REF
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|constraint
condition|)
block|{
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|cur_str_idx
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOT_SATISFY_NEXT_CONSTRAINT
argument_list|(
name|node
operator|->
name|constraint
argument_list|,
name|context
argument_list|)
condition|)
continue|continue;
block|}
comment|/* `node' is a backreference. 	 Check the substring which the substring matched.  */
name|bkc_idx
operator|=
name|mctx
operator|->
name|nbkref_ents
expr_stmt|;
name|err
operator|=
name|get_subexp
argument_list|(
name|mctx
argument_list|,
name|node_idx
argument_list|,
name|cur_str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
comment|/* And add the epsilon closures (which is `new_dest_nodes') of 	 the backreference to appropriate state_log.  */
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|dfa
operator|->
name|nexts
index|[
name|node_idx
index|]
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|bkc_idx
operator|<
name|mctx
operator|->
name|nbkref_ents
condition|;
operator|++
name|bkc_idx
control|)
block|{
name|int
name|subexp_len
decl_stmt|;
name|re_dfastate_t
modifier|*
name|dest_state
decl_stmt|;
name|struct
name|re_backref_cache_entry
modifier|*
name|bkref_ent
decl_stmt|;
name|bkref_ent
operator|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|bkc_idx
expr_stmt|;
if|if
condition|(
name|bkref_ent
operator|->
name|node
operator|!=
name|node_idx
operator|||
name|bkref_ent
operator|->
name|str_idx
operator|!=
name|cur_str_idx
condition|)
continue|continue;
name|subexp_len
operator|=
name|bkref_ent
operator|->
name|subexp_to
operator|-
name|bkref_ent
operator|->
name|subexp_from
expr_stmt|;
name|new_dest_nodes
operator|=
operator|(
name|subexp_len
operator|==
literal|0
condition|?
name|dfa
operator|->
name|eclosures
operator|+
name|dfa
operator|->
name|edests
index|[
name|node_idx
index|]
operator|.
name|elems
index|[
literal|0
index|]
else|:
name|dfa
operator|->
name|eclosures
operator|+
name|dfa
operator|->
name|nexts
index|[
name|node_idx
index|]
operator|)
expr_stmt|;
name|dest_str_idx
operator|=
operator|(
name|cur_str_idx
operator|+
name|bkref_ent
operator|->
name|subexp_to
operator|-
name|bkref_ent
operator|->
name|subexp_from
operator|)
expr_stmt|;
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|dest_str_idx
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
name|dest_state
operator|=
name|mctx
operator|->
name|state_log
index|[
name|dest_str_idx
index|]
expr_stmt|;
name|prev_nelem
operator|=
operator|(
operator|(
name|mctx
operator|->
name|state_log
index|[
name|cur_str_idx
index|]
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|mctx
operator|->
name|state_log
index|[
name|cur_str_idx
index|]
operator|->
name|nodes
operator|.
name|nelem
operator|)
expr_stmt|;
comment|/* Add `new_dest_node' to state_log.  */
if|if
condition|(
name|dest_state
operator|==
name|NULL
condition|)
block|{
name|mctx
operator|->
name|state_log
index|[
name|dest_str_idx
index|]
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
name|new_dest_nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|state_log
index|[
name|dest_str_idx
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
else|else
block|{
name|re_node_set
name|dest_nodes
decl_stmt|;
name|err
operator|=
name|re_node_set_init_union
argument_list|(
operator|&
name|dest_nodes
argument_list|,
name|dest_state
operator|->
name|entrance_nodes
argument_list|,
name|new_dest_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|dest_nodes
argument_list|)
expr_stmt|;
goto|goto
name|free_return
goto|;
block|}
name|mctx
operator|->
name|state_log
index|[
name|dest_str_idx
index|]
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|dest_nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|dest_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|state_log
index|[
name|dest_str_idx
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
comment|/* We need to check recursively if the backreference can epsilon 	     transit.  */
if|if
condition|(
name|subexp_len
operator|==
literal|0
operator|&&
name|mctx
operator|->
name|state_log
index|[
name|cur_str_idx
index|]
operator|->
name|nodes
operator|.
name|nelem
operator|>
name|prev_nelem
condition|)
block|{
name|err
operator|=
name|check_subexp_matching_top
argument_list|(
name|mctx
argument_list|,
name|new_dest_nodes
argument_list|,
name|cur_str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
name|err
operator|=
name|transit_state_bkref
argument_list|(
name|mctx
argument_list|,
name|new_dest_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|free_return
goto|;
block|}
block|}
block|}
name|err
operator|=
name|REG_NOERROR
expr_stmt|;
name|free_return
label|:
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Enumerate all the candidates which the backreference BKREF_NODE can match    at BKREF_STR_IDX, and register them by match_ctx_add_entry().    Note that we might collect inappropriate candidates here.    However, the cost of checking them strictly here is too high, then we    delay these checking for prune_impossible_nodes().  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|get_subexp
parameter_list|(
name|mctx
parameter_list|,
name|bkref_node
parameter_list|,
name|bkref_str_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|bkref_node
decl_stmt|,
name|bkref_str_idx
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|subexp_num
decl_stmt|,
name|sub_top_idx
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|re_string_get_buffer
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
decl_stmt|;
comment|/* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */
name|int
name|cache_idx
init|=
name|search_cur_bkref_entry
argument_list|(
name|mctx
argument_list|,
name|bkref_str_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache_idx
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|struct
name|re_backref_cache_entry
modifier|*
name|entry
init|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|cache_idx
decl_stmt|;
do|do
if|if
condition|(
name|entry
operator|->
name|node
operator|==
name|bkref_node
condition|)
return|return
name|REG_NOERROR
return|;
comment|/* We already checked it.  */
do|while
condition|(
name|entry
operator|++
operator|->
name|more
condition|)
do|;
block|}
name|subexp_num
operator|=
name|dfa
operator|->
name|nodes
index|[
name|bkref_node
index|]
operator|.
name|opr
operator|.
name|idx
expr_stmt|;
comment|/* For each sub expression  */
for|for
control|(
name|sub_top_idx
operator|=
literal|0
init|;
name|sub_top_idx
operator|<
name|mctx
operator|->
name|nsub_tops
condition|;
operator|++
name|sub_top_idx
control|)
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|re_sub_match_top_t
modifier|*
name|sub_top
init|=
name|mctx
operator|->
name|sub_tops
index|[
name|sub_top_idx
index|]
decl_stmt|;
name|re_sub_match_last_t
modifier|*
name|sub_last
decl_stmt|;
name|int
name|sub_last_idx
decl_stmt|,
name|sl_str
decl_stmt|,
name|bkref_str_off
decl_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|sub_top
operator|->
name|node
index|]
operator|.
name|opr
operator|.
name|idx
operator|!=
name|subexp_num
condition|)
continue|continue;
comment|/* It isn't related.  */
name|sl_str
operator|=
name|sub_top
operator|->
name|str_idx
expr_stmt|;
name|bkref_str_off
operator|=
name|bkref_str_idx
expr_stmt|;
comment|/* At first, check the last node of sub expressions we already 	 evaluated.  */
for|for
control|(
name|sub_last_idx
operator|=
literal|0
init|;
name|sub_last_idx
operator|<
name|sub_top
operator|->
name|nlasts
condition|;
operator|++
name|sub_last_idx
control|)
block|{
name|int
name|sl_str_diff
decl_stmt|;
name|sub_last
operator|=
name|sub_top
operator|->
name|lasts
index|[
name|sub_last_idx
index|]
expr_stmt|;
name|sl_str_diff
operator|=
name|sub_last
operator|->
name|str_idx
operator|-
name|sl_str
expr_stmt|;
comment|/* The matched string by the sub expression match with the substring 	     at the back reference?  */
if|if
condition|(
name|sl_str_diff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|bkref_str_off
operator|+
name|sl_str_diff
operator|>
name|mctx
operator|->
name|input
operator|.
name|valid_len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Not enough chars for a successful match.  */
if|if
condition|(
name|bkref_str_off
operator|+
name|sl_str_diff
operator|>
name|mctx
operator|->
name|input
operator|.
name|len
condition|)
break|break;
name|err
operator|=
name|clean_state_log_if_needed
argument_list|(
name|mctx
argument_list|,
name|bkref_str_off
operator|+
name|sl_str_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|re_string_get_buffer
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|bkref_str_off
argument_list|,
name|buf
operator|+
name|sl_str
argument_list|,
name|sl_str_diff
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* We don't need to search this sub expression any more.  */
block|}
name|bkref_str_off
operator|+=
name|sl_str_diff
expr_stmt|;
name|sl_str
operator|+=
name|sl_str_diff
expr_stmt|;
name|err
operator|=
name|get_subexp_sub
argument_list|(
name|mctx
argument_list|,
name|sub_top
argument_list|,
name|sub_last
argument_list|,
name|bkref_node
argument_list|,
name|bkref_str_idx
argument_list|)
expr_stmt|;
comment|/* Reload buf, since the preceding call might have reallocated 	     the buffer.  */
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|re_string_get_buffer
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|REG_NOMATCH
condition|)
continue|continue;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
if|if
condition|(
name|sub_last_idx
operator|<
name|sub_top
operator|->
name|nlasts
condition|)
continue|continue;
if|if
condition|(
name|sub_last_idx
operator|>
literal|0
condition|)
operator|++
name|sl_str
expr_stmt|;
comment|/* Then, search for the other last nodes of the sub expression.  */
for|for
control|(
init|;
name|sl_str
operator|<=
name|bkref_str_idx
condition|;
operator|++
name|sl_str
control|)
block|{
name|int
name|cls_node
decl_stmt|,
name|sl_str_off
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
name|sl_str_off
operator|=
name|sl_str
operator|-
name|sub_top
operator|->
name|str_idx
expr_stmt|;
comment|/* The matched string by the sub expression match with the substring 	     at the back reference?  */
if|if
condition|(
name|sl_str_off
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|bkref_str_off
operator|>=
name|mctx
operator|->
name|input
operator|.
name|valid_len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If we are at the end of the input, we cannot match.  */
if|if
condition|(
name|bkref_str_off
operator|>=
name|mctx
operator|->
name|input
operator|.
name|len
condition|)
break|break;
name|err
operator|=
name|extend_buffers
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|re_string_get_buffer
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
name|bkref_str_off
operator|++
index|]
operator|!=
name|buf
index|[
name|sl_str
operator|-
literal|1
index|]
condition|)
break|break;
comment|/* We don't need to search this sub expression 			  any more.  */
block|}
if|if
condition|(
name|mctx
operator|->
name|state_log
index|[
name|sl_str
index|]
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Does this state have a ')' of the sub expression?  */
name|nodes
operator|=
operator|&
name|mctx
operator|->
name|state_log
index|[
name|sl_str
index|]
operator|->
name|nodes
expr_stmt|;
name|cls_node
operator|=
name|find_subexp_node
argument_list|(
name|dfa
argument_list|,
name|nodes
argument_list|,
name|subexp_num
argument_list|,
name|OP_CLOSE_SUBEXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls_node
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* No.  */
if|if
condition|(
name|sub_top
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
name|sub_top
operator|->
name|path
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|state_array_t
argument_list|)
argument_list|,
name|sl_str
operator|-
name|sub_top
operator|->
name|str_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_top
operator|->
name|path
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
block|}
comment|/* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node 	     in the current context?  */
name|err
operator|=
name|check_arrival
argument_list|(
name|mctx
argument_list|,
name|sub_top
operator|->
name|path
argument_list|,
name|sub_top
operator|->
name|node
argument_list|,
name|sub_top
operator|->
name|str_idx
argument_list|,
name|cls_node
argument_list|,
name|sl_str
argument_list|,
name|OP_CLOSE_SUBEXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|REG_NOMATCH
condition|)
continue|continue;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|sub_last
operator|=
name|match_ctx_add_sublast
argument_list|(
name|sub_top
argument_list|,
name|cls_node
argument_list|,
name|sl_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|sub_last
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|err
operator|=
name|get_subexp_sub
argument_list|(
name|mctx
argument_list|,
name|sub_top
argument_list|,
name|sub_last
argument_list|,
name|bkref_node
argument_list|,
name|bkref_str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|REG_NOMATCH
condition|)
continue|continue;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for get_subexp().  */
end_comment

begin_comment
comment|/* Check SUB_LAST can arrive to the back reference BKREF_NODE at BKREF_STR.    If it can arrive, register the sub expression expressed with SUB_TOP    and SUB_LAST.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|get_subexp_sub
parameter_list|(
name|mctx
parameter_list|,
name|sub_top
parameter_list|,
name|sub_last
parameter_list|,
name|bkref_node
parameter_list|,
name|bkref_str
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
specifier|const
name|re_sub_match_top_t
modifier|*
name|sub_top
decl_stmt|;
name|re_sub_match_last_t
modifier|*
name|sub_last
decl_stmt|;
name|int
name|bkref_node
decl_stmt|,
name|bkref_str
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|to_idx
decl_stmt|;
comment|/* Can the subexpression arrive the back reference?  */
name|err
operator|=
name|check_arrival
argument_list|(
name|mctx
argument_list|,
operator|&
name|sub_last
operator|->
name|path
argument_list|,
name|sub_last
operator|->
name|node
argument_list|,
name|sub_last
operator|->
name|str_idx
argument_list|,
name|bkref_node
argument_list|,
name|bkref_str
argument_list|,
name|OP_OPEN_SUBEXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|REG_NOERROR
condition|)
return|return
name|err
return|;
name|err
operator|=
name|match_ctx_add_entry
argument_list|(
name|mctx
argument_list|,
name|bkref_node
argument_list|,
name|bkref_str
argument_list|,
name|sub_top
operator|->
name|str_idx
argument_list|,
name|sub_last
operator|->
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|to_idx
operator|=
name|bkref_str
operator|+
name|sub_last
operator|->
name|str_idx
operator|-
name|sub_top
operator|->
name|str_idx
expr_stmt|;
return|return
name|clean_state_log_if_needed
argument_list|(
name|mctx
argument_list|,
name|to_idx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the first node which is '(' or ')' and whose index is SUBEXP_IDX.    Search '(' if FL_OPEN, or search ')' otherwise.    TODO: This function isn't efficient... 	 Because there might be more than one nodes whose types are 	 OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all 	 nodes. 	 E.g. RE: (a){2}  */
end_comment

begin_function
specifier|static
name|int
name|find_subexp_node
parameter_list|(
name|dfa
parameter_list|,
name|nodes
parameter_list|,
name|subexp_idx
parameter_list|,
name|type
parameter_list|)
specifier|const
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
name|int
name|subexp_idx
decl_stmt|,
name|type
decl_stmt|;
block|{
name|int
name|cls_idx
decl_stmt|;
for|for
control|(
name|cls_idx
operator|=
literal|0
init|;
name|cls_idx
operator|<
name|nodes
operator|->
name|nelem
condition|;
operator|++
name|cls_idx
control|)
block|{
name|int
name|cls_node
init|=
name|nodes
operator|->
name|elems
index|[
name|cls_idx
index|]
decl_stmt|;
specifier|const
name|re_token_t
modifier|*
name|node
init|=
name|dfa
operator|->
name|nodes
operator|+
name|cls_node
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|type
operator|&&
name|node
operator|->
name|opr
operator|.
name|idx
operator|==
name|subexp_idx
condition|)
return|return
name|cls_node
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check whether the node TOP_NODE at TOP_STR can arrive to the node    LAST_NODE at LAST_STR.  We record the path onto PATH since it will be    heavily reused.    Return REG_NOERROR if it can arrive, or REG_NOMATCH otherwise.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|check_arrival
parameter_list|(
name|mctx
parameter_list|,
name|path
parameter_list|,
name|top_node
parameter_list|,
name|top_str
parameter_list|,
name|last_node
parameter_list|,
name|last_str
parameter_list|,
name|type
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|state_array_t
modifier|*
name|path
decl_stmt|;
name|int
name|top_node
decl_stmt|,
name|top_str
decl_stmt|,
name|last_node
decl_stmt|,
name|last_str
decl_stmt|,
name|type
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|subexp_num
decl_stmt|,
name|backup_cur_idx
decl_stmt|,
name|str_idx
decl_stmt|,
name|null_cnt
decl_stmt|;
name|re_dfastate_t
modifier|*
name|cur_state
init|=
name|NULL
decl_stmt|;
name|re_node_set
modifier|*
name|cur_nodes
decl_stmt|,
name|next_nodes
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|backup_state_log
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
name|subexp_num
operator|=
name|dfa
operator|->
name|nodes
index|[
name|top_node
index|]
operator|.
name|opr
operator|.
name|idx
expr_stmt|;
comment|/* Extend the buffer if we need.  */
if|if
condition|(
name|BE
argument_list|(
name|path
operator|->
name|alloc
operator|<
name|last_str
operator|+
name|mctx
operator|->
name|max_mb_elem_len
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_dfastate_t
modifier|*
modifier|*
name|new_array
decl_stmt|;
name|int
name|old_alloc
init|=
name|path
operator|->
name|alloc
decl_stmt|;
name|path
operator|->
name|alloc
operator|+=
name|last_str
operator|+
name|mctx
operator|->
name|max_mb_elem_len
operator|+
literal|1
expr_stmt|;
name|new_array
operator|=
name|re_realloc
argument_list|(
name|path
operator|->
name|array
argument_list|,
name|re_dfastate_t
operator|*
argument_list|,
name|path
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_array
operator|==
name|NULL
condition|)
block|{
name|path
operator|->
name|alloc
operator|=
name|old_alloc
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|path
operator|->
name|array
operator|=
name|new_array
expr_stmt|;
name|memset
argument_list|(
name|new_array
operator|+
name|old_alloc
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
operator|*
operator|(
name|path
operator|->
name|alloc
operator|-
name|old_alloc
operator|)
argument_list|)
expr_stmt|;
block|}
name|str_idx
operator|=
name|path
operator|->
name|next_idx
operator|==
literal|0
condition|?
name|top_str
else|:
name|path
operator|->
name|next_idx
expr_stmt|;
comment|/* Temporary modify MCTX.  */
name|backup_state_log
operator|=
name|mctx
operator|->
name|state_log
expr_stmt|;
name|backup_cur_idx
operator|=
name|mctx
operator|->
name|input
operator|.
name|cur_idx
expr_stmt|;
name|mctx
operator|->
name|state_log
operator|=
name|path
operator|->
name|array
expr_stmt|;
name|mctx
operator|->
name|input
operator|.
name|cur_idx
operator|=
name|str_idx
expr_stmt|;
comment|/* Setup initial node set.  */
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|str_idx
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_idx
operator|==
name|top_str
condition|)
block|{
name|err
operator|=
name|re_node_set_init_1
argument_list|(
operator|&
name|next_nodes
argument_list|,
name|top_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
name|err
operator|=
name|check_arrival_expand_ecl
argument_list|(
name|dfa
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|subexp_num
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
else|else
block|{
name|cur_state
operator|=
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
expr_stmt|;
if|if
condition|(
name|cur_state
operator|&&
name|cur_state
operator|->
name|has_backref
condition|)
block|{
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|next_nodes
argument_list|,
operator|&
name|cur_state
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
else|else
name|re_node_set_init_empty
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str_idx
operator|==
name|top_str
operator|||
operator|(
name|cur_state
operator|&&
name|cur_state
operator|->
name|has_backref
operator|)
condition|)
block|{
if|if
condition|(
name|next_nodes
operator|.
name|nelem
condition|)
block|{
name|err
operator|=
name|expand_bkref_cache
argument_list|(
name|mctx
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|str_idx
argument_list|,
name|subexp_num
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|cur_state
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|cur_state
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|=
name|cur_state
expr_stmt|;
block|}
for|for
control|(
name|null_cnt
operator|=
literal|0
init|;
name|str_idx
operator|<
name|last_str
operator|&&
name|null_cnt
operator|<=
name|mctx
operator|->
name|max_mb_elem_len
condition|;
control|)
block|{
name|re_node_set_empty
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|state_log
index|[
name|str_idx
operator|+
literal|1
index|]
condition|)
block|{
name|err
operator|=
name|re_node_set_merge
argument_list|(
operator|&
name|next_nodes
argument_list|,
operator|&
name|mctx
operator|->
name|state_log
index|[
name|str_idx
operator|+
literal|1
index|]
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
if|if
condition|(
name|cur_state
condition|)
block|{
name|err
operator|=
name|check_arrival_add_next_nodes
argument_list|(
name|mctx
argument_list|,
name|str_idx
argument_list|,
operator|&
name|cur_state
operator|->
name|non_eps_nodes
argument_list|,
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
operator|++
name|str_idx
expr_stmt|;
if|if
condition|(
name|next_nodes
operator|.
name|nelem
condition|)
block|{
name|err
operator|=
name|check_arrival_expand_ecl
argument_list|(
name|dfa
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|subexp_num
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|expand_bkref_cache
argument_list|(
name|mctx
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|str_idx
argument_list|,
name|subexp_num
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|context
operator|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|str_idx
operator|-
literal|1
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|next_nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|cur_state
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mctx
operator|->
name|state_log
index|[
name|str_idx
index|]
operator|=
name|cur_state
expr_stmt|;
name|null_cnt
operator|=
name|cur_state
operator|==
name|NULL
condition|?
name|null_cnt
operator|+
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|re_node_set_free
argument_list|(
operator|&
name|next_nodes
argument_list|)
expr_stmt|;
name|cur_nodes
operator|=
operator|(
name|mctx
operator|->
name|state_log
index|[
name|last_str
index|]
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|mctx
operator|->
name|state_log
index|[
name|last_str
index|]
operator|->
name|nodes
operator|)
expr_stmt|;
name|path
operator|->
name|next_idx
operator|=
name|str_idx
expr_stmt|;
comment|/* Fix MCTX.  */
name|mctx
operator|->
name|state_log
operator|=
name|backup_state_log
expr_stmt|;
name|mctx
operator|->
name|input
operator|.
name|cur_idx
operator|=
name|backup_cur_idx
expr_stmt|;
comment|/* Then check the current node set has the node LAST_NODE.  */
if|if
condition|(
name|cur_nodes
operator|!=
name|NULL
operator|&&
name|re_node_set_contains
argument_list|(
name|cur_nodes
argument_list|,
name|last_node
argument_list|)
condition|)
return|return
name|REG_NOERROR
return|;
return|return
name|REG_NOMATCH
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for check_arrival.  */
end_comment

begin_comment
comment|/* Calculate the destination nodes of CUR_NODES at STR_IDX, and append them    to NEXT_NODES.    TODO: This function is similar to the functions transit_state*(), 	 however this function has many additional works. 	 Can't we unify them?  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|check_arrival_add_next_nodes
parameter_list|(
name|mctx
parameter_list|,
name|str_idx
parameter_list|,
name|cur_nodes
parameter_list|,
name|next_nodes
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
name|re_node_set
modifier|*
name|cur_nodes
decl_stmt|,
decl|*
name|next_nodes
decl_stmt|;
end_function

begin_block
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|cur_idx
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|re_node_set
name|union_set
decl_stmt|;
name|re_node_set_init_empty
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
for|for
control|(
name|cur_idx
operator|=
literal|0
init|;
name|cur_idx
operator|<
name|cur_nodes
operator|->
name|nelem
condition|;
operator|++
name|cur_idx
control|)
block|{
name|int
name|naccepted
init|=
literal|0
decl_stmt|;
name|int
name|cur_node
init|=
name|cur_nodes
operator|->
name|elems
index|[
name|cur_idx
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|re_token_type_t
name|type
init|=
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|type
decl_stmt|;
name|assert
argument_list|(
operator|!
name|IS_EPSILON_NODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* If the node may accept `multi byte'.  */
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|accept_mb
condition|)
block|{
name|naccepted
operator|=
name|check_node_accept_bytes
argument_list|(
name|dfa
argument_list|,
name|cur_node
argument_list|,
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|naccepted
operator|>
literal|1
condition|)
block|{
name|re_dfastate_t
modifier|*
name|dest_state
decl_stmt|;
name|int
name|next_node
init|=
name|dfa
operator|->
name|nexts
index|[
name|cur_node
index|]
decl_stmt|;
name|int
name|next_idx
init|=
name|str_idx
operator|+
name|naccepted
decl_stmt|;
name|dest_state
operator|=
name|mctx
operator|->
name|state_log
index|[
name|next_idx
index|]
expr_stmt|;
name|re_node_set_empty
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_state
condition|)
block|{
name|err
operator|=
name|re_node_set_merge
argument_list|(
operator|&
name|union_set
argument_list|,
operator|&
name|dest_state
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|result
operator|=
name|re_node_set_insert
argument_list|(
operator|&
name|union_set
argument_list|,
name|next_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|result
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|mctx
operator|->
name|state_log
index|[
name|next_idx
index|]
operator|=
name|re_acquire_state
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|union_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|state_log
index|[
name|next_idx
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|naccepted
operator|||
name|check_node_accept
argument_list|(
name|mctx
argument_list|,
name|dfa
operator|->
name|nodes
operator|+
name|cur_node
argument_list|,
name|str_idx
argument_list|)
condition|)
block|{
name|result
operator|=
name|re_node_set_insert
argument_list|(
name|next_nodes
argument_list|,
name|dfa
operator|->
name|nexts
index|[
name|cur_node
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|result
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
block|}
block|}
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_comment
comment|/* For all the nodes in CUR_NODES, add the epsilon closures of them to    CUR_NODES, however exclude the nodes which are:     - inside the sub expression whose number is EX_SUBEXP, if FL_OPEN.     - out of the sub expression whose number is EX_SUBEXP, if !FL_OPEN. */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|check_arrival_expand_ecl
parameter_list|(
name|dfa
parameter_list|,
name|cur_nodes
parameter_list|,
name|ex_subexp
parameter_list|,
name|type
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_node_set
modifier|*
name|cur_nodes
decl_stmt|;
name|int
name|ex_subexp
decl_stmt|,
name|type
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|outside_node
decl_stmt|;
name|re_node_set
name|new_nodes
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|cur_nodes
operator|->
name|nelem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|re_node_set_alloc
argument_list|(
operator|&
name|new_nodes
argument_list|,
name|cur_nodes
operator|->
name|nelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* Create a new node set NEW_NODES with the nodes which are epsilon      closures of the node in CUR_NODES.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|cur_nodes
operator|->
name|nelem
condition|;
operator|++
name|idx
control|)
block|{
name|int
name|cur_node
init|=
name|cur_nodes
operator|->
name|elems
index|[
name|idx
index|]
decl_stmt|;
name|re_node_set
modifier|*
name|eclosure
init|=
name|dfa
operator|->
name|eclosures
operator|+
name|cur_node
decl_stmt|;
name|outside_node
operator|=
name|find_subexp_node
argument_list|(
name|dfa
argument_list|,
name|eclosure
argument_list|,
name|ex_subexp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|outside_node
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no problematic nodes, just merge them.  */
name|err
operator|=
name|re_node_set_merge
argument_list|(
operator|&
name|new_nodes
argument_list|,
name|eclosure
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|new_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
else|else
block|{
comment|/* There are problematic nodes, re-calculate incrementally.  */
name|err
operator|=
name|check_arrival_expand_ecl_sub
argument_list|(
name|dfa
argument_list|,
operator|&
name|new_nodes
argument_list|,
name|cur_node
argument_list|,
name|ex_subexp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|new_nodes
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
block|}
name|re_node_set_free
argument_list|(
name|cur_nodes
argument_list|)
expr_stmt|;
operator|*
name|cur_nodes
operator|=
name|new_nodes
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for check_arrival_expand_ecl.    Check incrementally the epsilon closure of TARGET, and if it isn't    problematic append it to DST_NODES.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|check_arrival_expand_ecl_sub
parameter_list|(
name|dfa
parameter_list|,
name|dst_nodes
parameter_list|,
name|target
parameter_list|,
name|ex_subexp
parameter_list|,
name|type
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|target
decl_stmt|,
name|ex_subexp
decl_stmt|,
name|type
decl_stmt|;
name|re_node_set
modifier|*
name|dst_nodes
decl_stmt|;
block|{
name|int
name|cur_node
decl_stmt|;
for|for
control|(
name|cur_node
operator|=
name|target
init|;
operator|!
name|re_node_set_contains
argument_list|(
name|dst_nodes
argument_list|,
name|cur_node
argument_list|)
condition|;
control|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|type
operator|==
name|type
operator|&&
name|dfa
operator|->
name|nodes
index|[
name|cur_node
index|]
operator|.
name|opr
operator|.
name|idx
operator|==
name|ex_subexp
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_CLOSE_SUBEXP
condition|)
block|{
name|err
operator|=
name|re_node_set_insert
argument_list|(
name|dst_nodes
argument_list|,
name|cur_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|==
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
break|break;
block|}
name|err
operator|=
name|re_node_set_insert
argument_list|(
name|dst_nodes
argument_list|,
name|cur_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|==
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
if|if
condition|(
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|nelem
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|nelem
operator|==
literal|2
condition|)
block|{
name|err
operator|=
name|check_arrival_expand_ecl_sub
argument_list|(
name|dfa
argument_list|,
name|dst_nodes
argument_list|,
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|elems
index|[
literal|1
index|]
argument_list|,
name|ex_subexp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
name|cur_node
operator|=
name|dfa
operator|->
name|edests
index|[
name|cur_node
index|]
operator|.
name|elems
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* For all the back references in the current state, calculate the    destination of the back references by the appropriate entry    in MCTX->BKREF_ENTS.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|expand_bkref_cache
parameter_list|(
name|mctx
parameter_list|,
name|cur_nodes
parameter_list|,
name|cur_str
parameter_list|,
name|subexp_num
parameter_list|,
name|type
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|cur_str
decl_stmt|,
name|subexp_num
decl_stmt|,
name|type
decl_stmt|;
name|re_node_set
modifier|*
name|cur_nodes
decl_stmt|;
block|{
name|re_dfa_t
modifier|*
specifier|const
name|dfa
init|=
name|mctx
operator|->
name|dfa
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|cache_idx_start
init|=
name|search_cur_bkref_entry
argument_list|(
name|mctx
argument_list|,
name|cur_str
argument_list|)
decl_stmt|;
name|struct
name|re_backref_cache_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|cache_idx_start
operator|==
operator|-
literal|1
condition|)
return|return
name|REG_NOERROR
return|;
name|restart
label|:
name|ent
operator|=
name|mctx
operator|->
name|bkref_ents
operator|+
name|cache_idx_start
expr_stmt|;
do|do
block|{
name|int
name|to_idx
decl_stmt|,
name|next_node
decl_stmt|;
comment|/* Is this entry ENT is appropriate?  */
if|if
condition|(
operator|!
name|re_node_set_contains
argument_list|(
name|cur_nodes
argument_list|,
name|ent
operator|->
name|node
argument_list|)
condition|)
continue|continue;
comment|/* No.  */
name|to_idx
operator|=
name|cur_str
operator|+
name|ent
operator|->
name|subexp_to
operator|-
name|ent
operator|->
name|subexp_from
expr_stmt|;
comment|/* Calculate the destination of the back reference, and append it 	 to MCTX->STATE_LOG.  */
if|if
condition|(
name|to_idx
operator|==
name|cur_str
condition|)
block|{
comment|/* The backreference did epsilon transit, we must re-check all the 	     node in the current state.  */
name|re_node_set
name|new_dests
decl_stmt|;
name|reg_errcode_t
name|err2
decl_stmt|,
name|err3
decl_stmt|;
name|next_node
operator|=
name|dfa
operator|->
name|edests
index|[
name|ent
operator|->
name|node
index|]
operator|.
name|elems
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|re_node_set_contains
argument_list|(
name|cur_nodes
argument_list|,
name|next_node
argument_list|)
condition|)
continue|continue;
name|err
operator|=
name|re_node_set_init_1
argument_list|(
operator|&
name|new_dests
argument_list|,
name|next_node
argument_list|)
expr_stmt|;
name|err2
operator|=
name|check_arrival_expand_ecl
argument_list|(
name|dfa
argument_list|,
operator|&
name|new_dests
argument_list|,
name|subexp_num
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|err3
operator|=
name|re_node_set_merge
argument_list|(
name|cur_nodes
argument_list|,
operator|&
name|new_dests
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|new_dests
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
operator|||
name|err2
operator|!=
name|REG_NOERROR
operator|||
name|err3
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
operator|(
name|err
operator|!=
name|REG_NOERROR
condition|?
name|err
else|:
operator|(
name|err2
operator|!=
name|REG_NOERROR
condition|?
name|err2
else|:
name|err3
operator|)
operator|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* TODO: It is still inefficient...  */
goto|goto
name|restart
goto|;
block|}
else|else
block|{
name|re_node_set
name|union_set
decl_stmt|;
name|next_node
operator|=
name|dfa
operator|->
name|nexts
index|[
name|ent
operator|->
name|node
index|]
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|state_log
index|[
name|to_idx
index|]
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|re_node_set_contains
argument_list|(
operator|&
name|mctx
operator|->
name|state_log
index|[
name|to_idx
index|]
operator|->
name|nodes
argument_list|,
name|next_node
argument_list|)
condition|)
continue|continue;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|union_set
argument_list|,
operator|&
name|mctx
operator|->
name|state_log
index|[
name|to_idx
index|]
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|ret
operator|=
name|re_node_set_insert
argument_list|(
operator|&
name|union_set
argument_list|,
name|next_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
operator|||
name|ret
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
name|err
operator|=
name|err
operator|!=
name|REG_NOERROR
condition|?
name|err
else|:
name|REG_ESPACE
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|re_node_set_init_1
argument_list|(
operator|&
name|union_set
argument_list|,
name|next_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
name|mctx
operator|->
name|state_log
index|[
name|to_idx
index|]
operator|=
name|re_acquire_state
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|union_set
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|union_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|state_log
index|[
name|to_idx
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err
return|;
block|}
block|}
do|while
condition|(
name|ent
operator|++
operator|->
name|more
condition|)
do|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Build transition table for the state.    Return 1 if succeeded, otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|int
name|build_trtable
parameter_list|(
name|dfa
parameter_list|,
name|state
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_dfastate_t
modifier|*
name|state
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ch
decl_stmt|,
name|need_word_trtable
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|elem
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|dests_node_malloced
init|=
literal|0
decl_stmt|,
name|dest_states_malloced
init|=
literal|0
decl_stmt|;
name|int
name|ndests
decl_stmt|;
comment|/* Number of the destination states from `state'.  */
name|re_dfastate_t
modifier|*
modifier|*
name|trtable
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|dest_states
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|dest_states_word
decl_stmt|,
modifier|*
modifier|*
name|dest_states_nl
decl_stmt|;
name|re_node_set
name|follows
decl_stmt|,
modifier|*
name|dests_node
decl_stmt|;
name|bitset
modifier|*
name|dests_ch
decl_stmt|;
name|bitset
name|acceptable
decl_stmt|;
comment|/* We build DFA states which corresponds to the destination nodes      from `state'.  `dests_node[i]' represents the nodes which i-th      destination state contains, and `dests_ch[i]' represents the      characters which i-th destination state accepts.  */
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__libc_use_alloca
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|re_node_set
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bitset
argument_list|)
operator|)
operator|*
name|SBC_MAX
argument_list|)
condition|)
name|dests_node
operator|=
operator|(
name|re_node_set
operator|*
operator|)
name|alloca
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|re_node_set
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bitset
argument_list|)
operator|)
operator|*
name|SBC_MAX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|dests_node
operator|=
operator|(
name|re_node_set
operator|*
operator|)
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|re_node_set
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bitset
argument_list|)
operator|)
operator|*
name|SBC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dests_node
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|dests_node_malloced
operator|=
literal|1
expr_stmt|;
block|}
name|dests_ch
operator|=
operator|(
name|bitset
operator|*
operator|)
operator|(
name|dests_node
operator|+
name|SBC_MAX
operator|)
expr_stmt|;
comment|/* Initialize transiton table.  */
name|state
operator|->
name|word_trtable
operator|=
name|state
operator|->
name|trtable
operator|=
name|NULL
expr_stmt|;
comment|/* At first, group all nodes belonging to `state' into several      destinations.  */
name|ndests
operator|=
name|group_nodes_into_DFAstates
argument_list|(
name|dfa
argument_list|,
name|state
argument_list|,
name|dests_node
argument_list|,
name|dests_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ndests
operator|<=
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|dests_node_malloced
condition|)
name|free
argument_list|(
name|dests_node
argument_list|)
expr_stmt|;
comment|/* Return 0 in case of an error, 1 otherwise.  */
if|if
condition|(
name|ndests
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|trtable
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
argument_list|,
name|SBC_MAX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
name|err
operator|=
name|re_node_set_alloc
argument_list|(
operator|&
name|follows
argument_list|,
name|ndests
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|__libc_use_alloca
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|re_node_set
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bitset
argument_list|)
operator|)
operator|*
name|SBC_MAX
operator|+
name|ndests
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
argument_list|)
condition|)
name|dest_states
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|ndests
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|dest_states
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ndests
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dest_states
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|out_free
label|:
if|if
condition|(
name|dest_states_malloced
condition|)
name|free
argument_list|(
name|dest_states
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|follows
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndests
condition|;
operator|++
name|i
control|)
name|re_node_set_free
argument_list|(
name|dests_node
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dests_node_malloced
condition|)
name|free
argument_list|(
name|dests_node
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dest_states_malloced
operator|=
literal|1
expr_stmt|;
block|}
name|dest_states_word
operator|=
name|dest_states
operator|+
name|ndests
expr_stmt|;
name|dest_states_nl
operator|=
name|dest_states_word
operator|+
name|ndests
expr_stmt|;
name|bitset_empty
argument_list|(
name|acceptable
argument_list|)
expr_stmt|;
comment|/* Then build the states for all destinations.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndests
condition|;
operator|++
name|i
control|)
block|{
name|int
name|next_node
decl_stmt|;
name|re_node_set_empty
argument_list|(
operator|&
name|follows
argument_list|)
expr_stmt|;
comment|/* Merge the follows of this destination states.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dests_node
index|[
name|i
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
block|{
name|next_node
operator|=
name|dfa
operator|->
name|nexts
index|[
name|dests_node
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|next_node
operator|!=
operator|-
literal|1
condition|)
block|{
name|err
operator|=
name|re_node_set_merge
argument_list|(
operator|&
name|follows
argument_list|,
name|dfa
operator|->
name|eclosures
operator|+
name|next_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
block|}
block|}
name|dest_states
index|[
name|i
index|]
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dest_states
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
comment|/* If the new state has context constraint, 	 build appropriate states for these contexts.  */
if|if
condition|(
name|dest_states
index|[
name|i
index|]
operator|->
name|has_constraint
condition|)
block|{
name|dest_states_word
index|[
name|i
index|]
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|follows
argument_list|,
name|CONTEXT_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dest_states_word
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
if|if
condition|(
name|dest_states
index|[
name|i
index|]
operator|!=
name|dest_states_word
index|[
name|i
index|]
operator|&&
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|need_word_trtable
operator|=
literal|1
expr_stmt|;
name|dest_states_nl
index|[
name|i
index|]
operator|=
name|re_acquire_state_context
argument_list|(
operator|&
name|err
argument_list|,
name|dfa
argument_list|,
operator|&
name|follows
argument_list|,
name|CONTEXT_NEWLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dest_states_nl
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
block|}
else|else
block|{
name|dest_states_word
index|[
name|i
index|]
operator|=
name|dest_states
index|[
name|i
index|]
expr_stmt|;
name|dest_states_nl
index|[
name|i
index|]
operator|=
name|dest_states
index|[
name|i
index|]
expr_stmt|;
block|}
name|bitset_merge
argument_list|(
name|acceptable
argument_list|,
name|dests_ch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BE
argument_list|(
name|need_word_trtable
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We don't care about whether the following character is a word 	 character, or we are in a single-byte character set so we can 	 discern by looking at the character code: allocate a 	 256-entry transition table.  */
name|trtable
operator|=
name|state
operator|->
name|trtable
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
argument_list|,
name|SBC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|trtable
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
comment|/* For all characters ch...:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
for|for
control|(
name|ch
operator|=
name|i
operator|*
name|UINT_BITS
operator|,
name|elem
operator|=
name|acceptable
index|[
name|i
index|]
operator|,
name|mask
operator|=
literal|1
init|;
name|elem
condition|;
name|mask
operator|<<=
literal|1
operator|,
name|elem
operator|>>=
literal|1
operator|,
operator|++
name|ch
control|)
if|if
condition|(
name|BE
argument_list|(
name|elem
operator|&
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* There must be exactly one destination which accepts 		 character ch.  See group_nodes_into_DFAstates.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|dests_ch
index|[
name|j
index|]
index|[
name|i
index|]
operator|&
name|mask
operator|)
operator|==
literal|0
condition|;
operator|++
name|j
control|)
empty_stmt|;
comment|/* j-th destination accepts the word character ch.  */
if|if
condition|(
name|dfa
operator|->
name|word_char
index|[
name|i
index|]
operator|&
name|mask
condition|)
name|trtable
index|[
name|ch
index|]
operator|=
name|dest_states_word
index|[
name|j
index|]
expr_stmt|;
else|else
name|trtable
index|[
name|ch
index|]
operator|=
name|dest_states
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We care about whether the following character is a word 	 character, and we are in a multi-byte character set: discern 	 by looking at the character code: build two 256-entry 	 transition tables, one starting at trtable[0] and one 	 starting at trtable[SBC_MAX].  */
name|trtable
operator|=
name|state
operator|->
name|word_trtable
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_dfastate_t
operator|*
argument_list|)
argument_list|,
literal|2
operator|*
name|SBC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|trtable
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
comment|/* For all characters ch...:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|i
control|)
for|for
control|(
name|ch
operator|=
name|i
operator|*
name|UINT_BITS
operator|,
name|elem
operator|=
name|acceptable
index|[
name|i
index|]
operator|,
name|mask
operator|=
literal|1
init|;
name|elem
condition|;
name|mask
operator|<<=
literal|1
operator|,
name|elem
operator|>>=
literal|1
operator|,
operator|++
name|ch
control|)
if|if
condition|(
name|BE
argument_list|(
name|elem
operator|&
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* There must be exactly one destination which accepts 		 character ch.  See group_nodes_into_DFAstates.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|dests_ch
index|[
name|j
index|]
index|[
name|i
index|]
operator|&
name|mask
operator|)
operator|==
literal|0
condition|;
operator|++
name|j
control|)
empty_stmt|;
comment|/* j-th destination accepts the word character ch.  */
name|trtable
index|[
name|ch
index|]
operator|=
name|dest_states
index|[
name|j
index|]
expr_stmt|;
name|trtable
index|[
name|ch
operator|+
name|SBC_MAX
index|]
operator|=
name|dest_states_word
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
comment|/* new line */
if|if
condition|(
name|bitset_contain
argument_list|(
name|acceptable
argument_list|,
name|NEWLINE_CHAR
argument_list|)
condition|)
block|{
comment|/* The current state accepts newline character.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndests
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|bitset_contain
argument_list|(
name|dests_ch
index|[
name|j
index|]
argument_list|,
name|NEWLINE_CHAR
argument_list|)
condition|)
block|{
comment|/* k-th destination accepts newline character.  */
name|trtable
index|[
name|NEWLINE_CHAR
index|]
operator|=
name|dest_states_nl
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|need_word_trtable
condition|)
name|trtable
index|[
name|NEWLINE_CHAR
operator|+
name|SBC_MAX
index|]
operator|=
name|dest_states_nl
index|[
name|j
index|]
expr_stmt|;
comment|/* There must be only one destination which accepts 	       newline.  See group_nodes_into_DFAstates.  */
break|break;
block|}
block|}
if|if
condition|(
name|dest_states_malloced
condition|)
name|free
argument_list|(
name|dest_states
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|follows
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndests
condition|;
operator|++
name|i
control|)
name|re_node_set_free
argument_list|(
name|dests_node
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dests_node_malloced
condition|)
name|free
argument_list|(
name|dests_node
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Group all nodes belonging to STATE into several destinations.    Then for all destinations, set the nodes belonging to the destination    to DESTS_NODE[i] and set the characters accepted by the destination    to DEST_CH[i].  This function return the number of destinations.  */
end_comment

begin_function
specifier|static
name|int
name|group_nodes_into_DFAstates
parameter_list|(
name|dfa
parameter_list|,
name|state
parameter_list|,
name|dests_node
parameter_list|,
name|dests_ch
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
specifier|const
name|re_dfastate_t
modifier|*
name|state
decl_stmt|;
name|re_node_set
modifier|*
name|dests_node
decl_stmt|;
name|bitset
modifier|*
name|dests_ch
decl_stmt|;
block|{
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ndests
decl_stmt|;
comment|/* Number of the destinations from `state'.  */
name|bitset
name|accepts
decl_stmt|;
comment|/* Characters a node can accept.  */
specifier|const
name|re_node_set
modifier|*
name|cur_nodes
init|=
operator|&
name|state
operator|->
name|nodes
decl_stmt|;
name|bitset_empty
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
name|ndests
operator|=
literal|0
expr_stmt|;
comment|/* For all the nodes belonging to `state',  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_nodes
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|re_token_t
modifier|*
name|node
init|=
operator|&
name|dfa
operator|->
name|nodes
index|[
name|cur_nodes
operator|->
name|elems
index|[
name|i
index|]
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|node
operator|->
name|type
decl_stmt|;
name|unsigned
name|int
name|constraint
init|=
name|node
operator|->
name|constraint
decl_stmt|;
comment|/* Enumerate all single byte character this node can accept.  */
if|if
condition|(
name|type
operator|==
name|CHARACTER
condition|)
name|bitset_set
argument_list|(
name|accepts
argument_list|,
name|node
operator|->
name|opr
operator|.
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SIMPLE_BRACKET
condition|)
block|{
name|bitset_merge
argument_list|(
name|accepts
argument_list|,
name|node
operator|->
name|opr
operator|.
name|sbcset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_PERIOD
condition|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|bitset_merge
argument_list|(
name|accepts
argument_list|,
name|dfa
operator|->
name|sb_char
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|bitset_set_all
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|bitset_clear
argument_list|(
name|accepts
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
condition|)
name|bitset_clear
argument_list|(
name|accepts
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_UTF8_PERIOD
condition|)
block|{
name|memset
argument_list|(
name|accepts
argument_list|,
literal|255
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|*
name|BITSET_UINTS
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|bitset_clear
argument_list|(
name|accepts
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
condition|)
name|bitset_clear
argument_list|(
name|accepts
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
continue|continue;
comment|/* Check the `accepts' and sift the characters which are not 	 match it the context.  */
if|if
condition|(
name|constraint
condition|)
block|{
if|if
condition|(
name|constraint
operator|&
name|NEXT_NEWLINE_CONSTRAINT
condition|)
block|{
name|int
name|accepts_newline
init|=
name|bitset_contain
argument_list|(
name|accepts
argument_list|,
name|NEWLINE_CHAR
argument_list|)
decl_stmt|;
name|bitset_empty
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
if|if
condition|(
name|accepts_newline
condition|)
name|bitset_set
argument_list|(
name|accepts
argument_list|,
name|NEWLINE_CHAR
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
if|if
condition|(
name|constraint
operator|&
name|NEXT_ENDBUF_CONSTRAINT
condition|)
block|{
name|bitset_empty
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|constraint
operator|&
name|NEXT_WORD_CONSTRAINT
condition|)
block|{
name|unsigned
name|int
name|any_set
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|CHARACTER
operator|&&
operator|!
name|node
operator|->
name|word_char
condition|)
block|{
name|bitset_empty
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|j
control|)
name|any_set
operator||=
operator|(
name|accepts
index|[
name|j
index|]
operator|&=
operator|(
name|dfa
operator|->
name|word_char
index|[
name|j
index|]
operator||
operator|~
name|dfa
operator|->
name|sb_char
index|[
name|j
index|]
operator|)
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|j
control|)
name|any_set
operator||=
operator|(
name|accepts
index|[
name|j
index|]
operator|&=
name|dfa
operator|->
name|word_char
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_set
condition|)
continue|continue;
block|}
if|if
condition|(
name|constraint
operator|&
name|NEXT_NOTWORD_CONSTRAINT
condition|)
block|{
name|unsigned
name|int
name|any_set
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|CHARACTER
operator|&&
name|node
operator|->
name|word_char
condition|)
block|{
name|bitset_empty
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|j
control|)
name|any_set
operator||=
operator|(
name|accepts
index|[
name|j
index|]
operator|&=
operator|~
operator|(
name|dfa
operator|->
name|word_char
index|[
name|j
index|]
operator|&
name|dfa
operator|->
name|sb_char
index|[
name|j
index|]
operator|)
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|j
control|)
name|any_set
operator||=
operator|(
name|accepts
index|[
name|j
index|]
operator|&=
operator|~
name|dfa
operator|->
name|word_char
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_set
condition|)
continue|continue;
block|}
block|}
comment|/* Then divide `accepts' into DFA states, or create a new 	 state.  Above, we make sure that accepts is not empty.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndests
condition|;
operator|++
name|j
control|)
block|{
name|bitset
name|intersec
decl_stmt|;
comment|/* Intersection sets, see below.  */
name|bitset
name|remains
decl_stmt|;
comment|/* Flags, see below.  */
name|int
name|has_intersec
decl_stmt|,
name|not_subset
decl_stmt|,
name|not_consumed
decl_stmt|;
comment|/* Optimization, skip if this state doesn't accept the character.  */
if|if
condition|(
name|type
operator|==
name|CHARACTER
operator|&&
operator|!
name|bitset_contain
argument_list|(
name|dests_ch
index|[
name|j
index|]
argument_list|,
name|node
operator|->
name|opr
operator|.
name|c
argument_list|)
condition|)
continue|continue;
comment|/* Enumerate the intersection set of this state and `accepts'.  */
name|has_intersec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|k
control|)
name|has_intersec
operator||=
name|intersec
index|[
name|k
index|]
operator|=
name|accepts
index|[
name|k
index|]
operator|&
name|dests_ch
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
comment|/* And skip if the intersection set is empty.  */
if|if
condition|(
operator|!
name|has_intersec
condition|)
continue|continue;
comment|/* Then check if this state is a subset of `accepts'.  */
name|not_subset
operator|=
name|not_consumed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|BITSET_UINTS
condition|;
operator|++
name|k
control|)
block|{
name|not_subset
operator||=
name|remains
index|[
name|k
index|]
operator|=
operator|~
name|accepts
index|[
name|k
index|]
operator|&
name|dests_ch
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
name|not_consumed
operator||=
name|accepts
index|[
name|k
index|]
operator|=
name|accepts
index|[
name|k
index|]
operator|&
operator|~
name|dests_ch
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
block|}
comment|/* If this state isn't a subset of `accepts', create a 	     new group state, which has the `remains'. */
if|if
condition|(
name|not_subset
condition|)
block|{
name|bitset_copy
argument_list|(
name|dests_ch
index|[
name|ndests
index|]
argument_list|,
name|remains
argument_list|)
expr_stmt|;
name|bitset_copy
argument_list|(
name|dests_ch
index|[
name|j
index|]
argument_list|,
name|intersec
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
name|dests_node
operator|+
name|ndests
argument_list|,
operator|&
name|dests_node
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
operator|++
name|ndests
expr_stmt|;
block|}
comment|/* Put the position in the current group. */
name|result
operator|=
name|re_node_set_insert
argument_list|(
operator|&
name|dests_node
index|[
name|j
index|]
argument_list|,
name|cur_nodes
operator|->
name|elems
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|result
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If all characters are consumed, go to next node. */
if|if
condition|(
operator|!
name|not_consumed
condition|)
break|break;
block|}
comment|/* Some characters remain, create a new group. */
if|if
condition|(
name|j
operator|==
name|ndests
condition|)
block|{
name|bitset_copy
argument_list|(
name|dests_ch
index|[
name|ndests
index|]
argument_list|,
name|accepts
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_node_set_init_1
argument_list|(
name|dests_node
operator|+
name|ndests
argument_list|,
name|cur_nodes
operator|->
name|elems
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
operator|++
name|ndests
expr_stmt|;
name|bitset_empty
argument_list|(
name|accepts
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ndests
return|;
name|error_return
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndests
condition|;
operator|++
name|j
control|)
name|re_node_set_free
argument_list|(
name|dests_node
operator|+
name|j
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_comment
comment|/* Check how many bytes the node `dfa->nodes[node_idx]' accepts.    Return the number of the bytes the node accepts.    STR_IDX is the current index of the input string.     This function handles the nodes which can accept one character, or    one collating element like '.', '[a-z]', opposite to the other nodes    can only accept one byte.  */
end_comment

begin_function
specifier|static
name|int
name|check_node_accept_bytes
parameter_list|(
name|dfa
parameter_list|,
name|node_idx
parameter_list|,
name|input
parameter_list|,
name|str_idx
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|int
name|node_idx
decl_stmt|,
name|str_idx
decl_stmt|;
specifier|const
name|re_string_t
modifier|*
name|input
decl_stmt|;
block|{
specifier|const
name|re_token_t
modifier|*
name|node
init|=
name|dfa
operator|->
name|nodes
operator|+
name|node_idx
decl_stmt|;
name|int
name|char_len
decl_stmt|,
name|elem_len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|node
operator|->
name|type
operator|==
name|OP_UTF8_PERIOD
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|c
init|=
name|re_string_byte_at
argument_list|(
name|input
argument_list|,
name|str_idx
argument_list|)
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|c
operator|<
literal|0xc2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|str_idx
operator|+
literal|2
operator|>
name|input
operator|->
name|len
condition|)
return|return
literal|0
return|;
name|d
operator|=
name|re_string_byte_at
argument_list|(
name|input
argument_list|,
name|str_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0xe0
condition|)
return|return
operator|(
name|d
operator|<
literal|0x80
operator|||
name|d
operator|>
literal|0xbf
operator|)
condition|?
literal|0
else|:
literal|2
return|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xf0
condition|)
block|{
name|char_len
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xe0
operator|&&
name|d
operator|<
literal|0xa0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xf8
condition|)
block|{
name|char_len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xf0
operator|&&
name|d
operator|<
literal|0x90
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xfc
condition|)
block|{
name|char_len
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xf8
operator|&&
name|d
operator|<
literal|0x88
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xfe
condition|)
block|{
name|char_len
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xfc
operator|&&
name|d
operator|<
literal|0x84
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|str_idx
operator|+
name|char_len
operator|>
name|input
operator|->
name|len
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|char_len
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|=
name|re_string_byte_at
argument_list|(
name|input
argument_list|,
name|str_idx
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0x80
operator|||
name|d
operator|>
literal|0xbf
condition|)
return|return
literal|0
return|;
block|}
return|return
name|char_len
return|;
block|}
name|char_len
operator|=
name|re_string_char_size_at
argument_list|(
name|input
argument_list|,
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|OP_PERIOD
condition|)
block|{
if|if
condition|(
name|char_len
operator|<=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* FIXME: I don't think this if is needed, as both '\n' 	 and '\0' are char_len == 1.  */
comment|/* '.' accepts any one character except the following two cases.  */
if|if
condition|(
operator|(
operator|!
operator|(
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
operator|&&
name|re_string_byte_at
argument_list|(
name|input
argument_list|,
name|str_idx
argument_list|)
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|(
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
operator|)
operator|&&
name|re_string_byte_at
argument_list|(
name|input
argument_list|,
name|str_idx
argument_list|)
operator|==
literal|'\0'
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|char_len
return|;
block|}
name|elem_len
operator|=
name|re_string_elem_size_at
argument_list|(
name|input
argument_list|,
name|str_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elem_len
operator|<=
literal|1
operator|&&
name|char_len
operator|<=
literal|1
operator|)
operator|||
name|char_len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|COMPLEX_BRACKET
condition|)
block|{
specifier|const
name|re_charset_t
modifier|*
name|cset
init|=
name|node
operator|->
name|opr
operator|.
name|mbcset
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
specifier|const
name|unsigned
name|char
modifier|*
name|pin
init|=
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|re_string_get_buffer
argument_list|(
name|input
argument_list|)
operator|+
name|str_idx
operator|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|uint32_t
name|nrules
decl_stmt|;
endif|#
directive|endif
comment|/* _LIBC */
name|int
name|match_len
init|=
literal|0
decl_stmt|;
name|wchar_t
name|wc
init|=
operator|(
operator|(
name|cset
operator|->
name|nranges
operator|||
name|cset
operator|->
name|nchar_classes
operator|||
name|cset
operator|->
name|nmbchars
operator|)
condition|?
name|re_string_wchar_at
argument_list|(
name|input
argument_list|,
name|str_idx
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
comment|/* match with multibyte character?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|nmbchars
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|wc
operator|==
name|cset
operator|->
name|mbchars
index|[
name|i
index|]
condition|)
block|{
name|match_len
operator|=
name|char_len
expr_stmt|;
goto|goto
name|check_node_accept_bytes_match
goto|;
block|}
comment|/* match with character_class?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|nchar_classes
condition|;
operator|++
name|i
control|)
block|{
name|wctype_t
name|wt
init|=
name|cset
operator|->
name|char_classes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|__iswctype
argument_list|(
name|wc
argument_list|,
name|wt
argument_list|)
condition|)
block|{
name|match_len
operator|=
name|char_len
expr_stmt|;
goto|goto
name|check_node_accept_bytes_match
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|_LIBC
name|nrules
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|in_collseq
init|=
literal|0
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|table
decl_stmt|,
modifier|*
name|indirect
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|weights
decl_stmt|,
modifier|*
name|extra
decl_stmt|;
specifier|const
name|char
modifier|*
name|collseqwc
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
comment|/* This #include defines a local function!  */
include|#
directive|include
file|<locale/weight.h>
comment|/* match with collating_symbol?  */
if|if
condition|(
name|cset
operator|->
name|ncoll_syms
condition|)
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|ncoll_syms
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|coll_sym
init|=
name|extra
operator|+
name|cset
operator|->
name|coll_syms
index|[
name|i
index|]
decl_stmt|;
comment|/* Compare the length of input collating element and 		 the length of current collating element.  */
if|if
condition|(
operator|*
name|coll_sym
operator|!=
name|elem_len
condition|)
continue|continue;
comment|/* Compare each bytes.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|*
name|coll_sym
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|pin
index|[
name|j
index|]
operator|!=
name|coll_sym
index|[
literal|1
operator|+
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|==
operator|*
name|coll_sym
condition|)
block|{
comment|/* Match if every bytes is equal.  */
name|match_len
operator|=
name|j
expr_stmt|;
goto|goto
name|check_node_accept_bytes_match
goto|;
block|}
block|}
if|if
condition|(
name|cset
operator|->
name|nranges
condition|)
block|{
if|if
condition|(
name|elem_len
operator|<=
name|char_len
condition|)
block|{
name|collseqwc
operator|=
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQWC
argument_list|)
expr_stmt|;
name|in_collseq
operator|=
name|__collseq_table_lookup
argument_list|(
name|collseqwc
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
else|else
name|in_collseq
operator|=
name|find_collation_sequence_value
argument_list|(
name|pin
argument_list|,
name|elem_len
argument_list|)
expr_stmt|;
block|}
comment|/* match with range expression?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|nranges
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|cset
operator|->
name|range_starts
index|[
name|i
index|]
operator|<=
name|in_collseq
operator|&&
name|in_collseq
operator|<=
name|cset
operator|->
name|range_ends
index|[
name|i
index|]
condition|)
block|{
name|match_len
operator|=
name|elem_len
expr_stmt|;
goto|goto
name|check_node_accept_bytes_match
goto|;
block|}
comment|/* match with equivalence_class?  */
if|if
condition|(
name|cset
operator|->
name|nequiv_classes
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|cp
init|=
name|pin
decl_stmt|;
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEMB
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAMB
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTMB
argument_list|)
expr_stmt|;
name|idx
operator|=
name|findidx
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|nequiv_classes
condition|;
operator|++
name|i
control|)
block|{
name|int32_t
name|equiv_class_idx
init|=
name|cset
operator|->
name|equiv_classes
index|[
name|i
index|]
decl_stmt|;
name|size_t
name|weight_len
init|=
name|weights
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|weight_len
operator|==
name|weights
index|[
name|equiv_class_idx
index|]
condition|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cnt
operator|<=
name|weight_len
operator|&&
operator|(
name|weights
index|[
name|equiv_class_idx
operator|+
literal|1
operator|+
name|cnt
index|]
operator|==
name|weights
index|[
name|idx
operator|+
literal|1
operator|+
name|cnt
index|]
operator|)
condition|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|weight_len
condition|)
block|{
name|match_len
operator|=
name|elem_len
expr_stmt|;
goto|goto
name|check_node_accept_bytes_match
goto|;
block|}
block|}
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* _LIBC */
block|{
comment|/* match with range expression?  */
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
name|wchar_t
name|cmp_buf
index|[]
init|=
block|{
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
name|wc
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|}
decl_stmt|;
else|#
directive|else
name|wchar_t
name|cmp_buf
index|[]
init|=
block|{
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|,
literal|L'
expr|\0'
block|}
decl_stmt|;
name|cmp_buf
index|[
literal|2
index|]
operator|=
name|wc
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cset
operator|->
name|nranges
condition|;
operator|++
name|i
control|)
block|{
name|cmp_buf
index|[
literal|0
index|]
operator|=
name|cset
operator|->
name|range_starts
index|[
name|i
index|]
expr_stmt|;
name|cmp_buf
index|[
literal|4
index|]
operator|=
name|cset
operator|->
name|range_ends
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|wcscoll
argument_list|(
name|cmp_buf
argument_list|,
name|cmp_buf
operator|+
literal|2
argument_list|)
operator|<=
literal|0
operator|&&
name|wcscoll
argument_list|(
name|cmp_buf
operator|+
literal|2
argument_list|,
name|cmp_buf
operator|+
literal|4
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|match_len
operator|=
name|char_len
expr_stmt|;
goto|goto
name|check_node_accept_bytes_match
goto|;
block|}
block|}
block|}
name|check_node_accept_bytes_match
label|:
if|if
condition|(
operator|!
name|cset
operator|->
name|non_match
condition|)
return|return
name|match_len
return|;
else|else
block|{
if|if
condition|(
name|match_len
operator|>
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
name|elem_len
operator|>
name|char_len
operator|)
condition|?
name|elem_len
else|:
name|char_len
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_function
specifier|static
name|unsigned
name|int
name|find_collation_sequence_value
parameter_list|(
name|mbs
parameter_list|,
name|mbs_len
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|mbs
decl_stmt|;
name|size_t
name|mbs_len
decl_stmt|;
block|{
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mbs_len
operator|==
literal|1
condition|)
block|{
comment|/* No valid character.  Match it as a single byte character.  */
specifier|const
name|unsigned
name|char
modifier|*
name|collseq
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQMB
argument_list|)
decl_stmt|;
return|return
name|collseq
index|[
name|mbs
index|[
literal|0
index|]
index|]
return|;
block|}
return|return
name|UINT_MAX
return|;
block|}
else|else
block|{
name|int32_t
name|idx
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
decl_stmt|;
name|int32_t
name|extrasize
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
operator|+
literal|1
argument_list|)
operator|-
name|extra
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|extrasize
condition|;
control|)
block|{
name|int
name|mbs_cnt
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|int32_t
name|elem_mbs_len
decl_stmt|;
comment|/* Skip the name of collating element name.  */
name|idx
operator|=
name|idx
operator|+
name|extra
index|[
name|idx
index|]
operator|+
literal|1
expr_stmt|;
name|elem_mbs_len
operator|=
name|extra
index|[
name|idx
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|mbs_len
operator|==
name|elem_mbs_len
condition|)
block|{
for|for
control|(
name|mbs_cnt
operator|=
literal|0
init|;
name|mbs_cnt
operator|<
name|elem_mbs_len
condition|;
operator|++
name|mbs_cnt
control|)
if|if
condition|(
name|extra
index|[
name|idx
operator|+
name|mbs_cnt
index|]
operator|!=
name|mbs
index|[
name|mbs_cnt
index|]
condition|)
break|break;
if|if
condition|(
name|mbs_cnt
operator|==
name|elem_mbs_len
condition|)
comment|/* Found the entry.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Skip the byte sequence of the collating element.  */
name|idx
operator|+=
name|elem_mbs_len
expr_stmt|;
comment|/* Adjust for the alignment.  */
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Skip the collation sequence value.  */
name|idx
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* Skip the wide char sequence of the collating element.  */
name|idx
operator|=
name|idx
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
operator|(
name|extra
index|[
name|idx
index|]
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* If we found the entry, return the sequence value.  */
if|if
condition|(
name|found
condition|)
return|return
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|extra
operator|+
name|idx
operator|)
return|;
comment|/* Skip the collation sequence value.  */
name|idx
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
return|return
name|UINT_MAX
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_comment
comment|/* Check whether the node accepts the byte which is IDX-th    byte of the INPUT.  */
end_comment

begin_function
specifier|static
name|int
name|check_node_accept
parameter_list|(
name|mctx
parameter_list|,
name|node
parameter_list|,
name|idx
parameter_list|)
specifier|const
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
specifier|const
name|re_token_t
modifier|*
name|node
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
name|ch
operator|=
name|re_string_byte_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|type
condition|)
block|{
case|case
name|CHARACTER
case|:
if|if
condition|(
name|node
operator|->
name|opr
operator|.
name|c
operator|!=
name|ch
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|SIMPLE_BRACKET
case|:
if|if
condition|(
operator|!
name|bitset_contain
argument_list|(
name|node
operator|->
name|opr
operator|.
name|sbcset
argument_list|,
name|ch
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
case|case
name|OP_UTF8_PERIOD
case|:
if|if
condition|(
name|ch
operator|>=
literal|0x80
condition|)
return|return
literal|0
return|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|OP_PERIOD
case|:
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\n'
operator|&&
operator|!
operator|(
name|mctx
operator|->
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\0'
operator|&&
operator|(
name|mctx
operator|->
name|dfa
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
operator|)
operator|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node
operator|->
name|constraint
condition|)
block|{
comment|/* The node has constraints.  Check whether the current context 	 satisfies the constraints.  */
name|unsigned
name|int
name|context
init|=
name|re_string_context_at
argument_list|(
operator|&
name|mctx
operator|->
name|input
argument_list|,
name|idx
argument_list|,
name|mctx
operator|->
name|eflags
argument_list|)
decl_stmt|;
if|if
condition|(
name|NOT_SATISFY_NEXT_CONSTRAINT
argument_list|(
name|node
operator|->
name|constraint
argument_list|,
name|context
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extend the buffers, if the buffers have run out.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|extend_buffers
parameter_list|(
name|mctx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|re_string_t
modifier|*
name|pstr
init|=
operator|&
name|mctx
operator|->
name|input
decl_stmt|;
comment|/* Double the lengthes of the buffers.  */
name|ret
operator|=
name|re_string_realloc_buffers
argument_list|(
name|pstr
argument_list|,
name|pstr
operator|->
name|bufs_len
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|mctx
operator|->
name|state_log
operator|!=
name|NULL
condition|)
block|{
comment|/* And double the length of state_log.  */
comment|/* XXX We have no indication of the size of this buffer.  If this 	 allocation fail we have no indication that the state_log array 	 does not have the right size.  */
name|re_dfastate_t
modifier|*
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|mctx
operator|->
name|state_log
argument_list|,
name|re_dfastate_t
operator|*
argument_list|,
name|pstr
operator|->
name|bufs_len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mctx
operator|->
name|state_log
operator|=
name|new_array
expr_stmt|;
block|}
comment|/* Then reconstruct the buffers.  */
if|if
condition|(
name|pstr
operator|->
name|icase
condition|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|ret
operator|=
name|build_wcs_upper_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
block|}
else|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N  */
name|build_upper_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|build_wcs_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N  */
block|{
if|if
condition|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
condition|)
name|re_string_translate_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for matching context.  */
end_comment

begin_comment
comment|/* Initialize MCTX.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|match_ctx_init
parameter_list|(
name|mctx
parameter_list|,
name|eflags
parameter_list|,
name|n
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|eflags
decl_stmt|,
name|n
decl_stmt|;
block|{
name|mctx
operator|->
name|eflags
operator|=
name|eflags
expr_stmt|;
name|mctx
operator|->
name|match_last
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|mctx
operator|->
name|bkref_ents
operator|=
name|re_malloc
argument_list|(
expr|struct
name|re_backref_cache_entry
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|sub_tops
operator|=
name|re_malloc
argument_list|(
name|re_sub_match_top_t
operator|*
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|bkref_ents
operator|==
name|NULL
operator|||
name|mctx
operator|->
name|sub_tops
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
comment|/* Already zero-ed by the caller.      else        mctx->bkref_ents = NULL;      mctx->nbkref_ents = 0;      mctx->nsub_tops = 0;  */
name|mctx
operator|->
name|abkref_ents
operator|=
name|n
expr_stmt|;
name|mctx
operator|->
name|max_mb_elem_len
operator|=
literal|1
expr_stmt|;
name|mctx
operator|->
name|asub_tops
operator|=
name|n
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Clean the entries which depend on the current input in MCTX.    This function must be invoked when the matcher changes the start index    of the input, or changes the input string.  */
end_comment

begin_function
specifier|static
name|void
name|match_ctx_clean
parameter_list|(
name|mctx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
block|{
name|int
name|st_idx
decl_stmt|;
for|for
control|(
name|st_idx
operator|=
literal|0
init|;
name|st_idx
operator|<
name|mctx
operator|->
name|nsub_tops
condition|;
operator|++
name|st_idx
control|)
block|{
name|int
name|sl_idx
decl_stmt|;
name|re_sub_match_top_t
modifier|*
name|top
init|=
name|mctx
operator|->
name|sub_tops
index|[
name|st_idx
index|]
decl_stmt|;
for|for
control|(
name|sl_idx
operator|=
literal|0
init|;
name|sl_idx
operator|<
name|top
operator|->
name|nlasts
condition|;
operator|++
name|sl_idx
control|)
block|{
name|re_sub_match_last_t
modifier|*
name|last
init|=
name|top
operator|->
name|lasts
index|[
name|sl_idx
index|]
decl_stmt|;
name|re_free
argument_list|(
name|last
operator|->
name|path
operator|.
name|array
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
name|re_free
argument_list|(
name|top
operator|->
name|lasts
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|path
condition|)
block|{
name|re_free
argument_list|(
name|top
operator|->
name|path
operator|->
name|array
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|top
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
name|mctx
operator|->
name|nsub_tops
operator|=
literal|0
expr_stmt|;
name|mctx
operator|->
name|nbkref_ents
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the memory associated with MCTX.  */
end_comment

begin_function
specifier|static
name|void
name|match_ctx_free
parameter_list|(
name|mctx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
block|{
comment|/* First, free all the memory associated with MCTX->SUB_TOPS.  */
name|match_ctx_clean
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|mctx
operator|->
name|sub_tops
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|mctx
operator|->
name|bkref_ents
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new backreference entry to MCTX.    Note that we assume that caller never call this function with duplicate    entry, and call with STR_IDX which isn't smaller than any existing entry. */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|match_ctx_add_entry
parameter_list|(
name|mctx
parameter_list|,
name|node
parameter_list|,
name|str_idx
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|node
decl_stmt|,
name|str_idx
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
if|if
condition|(
name|mctx
operator|->
name|nbkref_ents
operator|>=
name|mctx
operator|->
name|abkref_ents
condition|)
block|{
name|struct
name|re_backref_cache_entry
modifier|*
name|new_entry
decl_stmt|;
name|new_entry
operator|=
name|re_realloc
argument_list|(
name|mctx
operator|->
name|bkref_ents
argument_list|,
expr|struct
name|re_backref_cache_entry
argument_list|,
name|mctx
operator|->
name|abkref_ents
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_entry
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_free
argument_list|(
name|mctx
operator|->
name|bkref_ents
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|mctx
operator|->
name|bkref_ents
operator|=
name|new_entry
expr_stmt|;
name|memset
argument_list|(
name|mctx
operator|->
name|bkref_ents
operator|+
name|mctx
operator|->
name|nbkref_ents
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|re_backref_cache_entry
argument_list|)
operator|*
name|mctx
operator|->
name|abkref_ents
argument_list|)
expr_stmt|;
name|mctx
operator|->
name|abkref_ents
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|mctx
operator|->
name|nbkref_ents
operator|>
literal|0
operator|&&
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
operator|-
literal|1
index|]
operator|.
name|str_idx
operator|==
name|str_idx
condition|)
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
operator|-
literal|1
index|]
operator|.
name|more
operator|=
literal|1
expr_stmt|;
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
index|]
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
index|]
operator|.
name|str_idx
operator|=
name|str_idx
expr_stmt|;
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
index|]
operator|.
name|subexp_from
operator|=
name|from
expr_stmt|;
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
index|]
operator|.
name|subexp_to
operator|=
name|to
expr_stmt|;
comment|/* This is a cache that saves negative results of check_dst_limits_calc_pos.      If bit N is clear, means that this entry won't epsilon-transition to      an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If      it is set, check_dst_limits_calc_pos_1 will recurse and try to find one      such node.       A backreference does not epsilon-transition unless it is empty, so set      to all zeros if FROM != TO.  */
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
index|]
operator|.
name|eps_reachable_subexps_map
operator|=
operator|(
name|from
operator|==
name|to
condition|?
operator|~
literal|0
else|:
literal|0
operator|)
expr_stmt|;
name|mctx
operator|->
name|bkref_ents
index|[
name|mctx
operator|->
name|nbkref_ents
operator|++
index|]
operator|.
name|more
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|max_mb_elem_len
operator|<
name|to
operator|-
name|from
condition|)
name|mctx
operator|->
name|max_mb_elem_len
operator|=
name|to
operator|-
name|from
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Search for the first entry which has the same str_idx, or -1 if none is    found.  Note that MCTX->BKREF_ENTS is already sorted by MCTX->STR_IDX.  */
end_comment

begin_function
specifier|static
name|int
name|search_cur_bkref_entry
parameter_list|(
name|mctx
parameter_list|,
name|str_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|str_idx
decl_stmt|;
block|{
name|int
name|left
decl_stmt|,
name|right
decl_stmt|,
name|mid
decl_stmt|,
name|last
decl_stmt|;
name|last
operator|=
name|right
operator|=
name|mctx
operator|->
name|nbkref_ents
expr_stmt|;
for|for
control|(
name|left
operator|=
literal|0
init|;
name|left
operator|<
name|right
condition|;
control|)
block|{
name|mid
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|bkref_ents
index|[
name|mid
index|]
operator|.
name|str_idx
operator|<
name|str_idx
condition|)
name|left
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|right
operator|=
name|mid
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|<
name|last
operator|&&
name|mctx
operator|->
name|bkref_ents
index|[
name|left
index|]
operator|.
name|str_idx
operator|==
name|str_idx
condition|)
return|return
name|left
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Register the node NODE, whose type is OP_OPEN_SUBEXP, and which matches    at STR_IDX.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|match_ctx_add_subtop
parameter_list|(
name|mctx
parameter_list|,
name|node
parameter_list|,
name|str_idx
parameter_list|)
name|re_match_context_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|node
decl_stmt|,
name|str_idx
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|mctx
operator|->
name|sub_tops
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mctx
operator|->
name|asub_tops
operator|>
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|nsub_tops
operator|==
name|mctx
operator|->
name|asub_tops
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|new_asub_tops
init|=
name|mctx
operator|->
name|asub_tops
operator|*
literal|2
decl_stmt|;
name|re_sub_match_top_t
modifier|*
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|mctx
operator|->
name|sub_tops
argument_list|,
name|re_sub_match_top_t
operator|*
argument_list|,
name|new_asub_tops
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mctx
operator|->
name|sub_tops
operator|=
name|new_array
expr_stmt|;
name|mctx
operator|->
name|asub_tops
operator|=
name|new_asub_tops
expr_stmt|;
block|}
name|mctx
operator|->
name|sub_tops
index|[
name|mctx
operator|->
name|nsub_tops
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|re_sub_match_top_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mctx
operator|->
name|sub_tops
index|[
name|mctx
operator|->
name|nsub_tops
index|]
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|mctx
operator|->
name|sub_tops
index|[
name|mctx
operator|->
name|nsub_tops
index|]
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|mctx
operator|->
name|sub_tops
index|[
name|mctx
operator|->
name|nsub_tops
operator|++
index|]
operator|->
name|str_idx
operator|=
name|str_idx
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Register the node NODE, whose type is OP_CLOSE_SUBEXP, and which matches    at STR_IDX, whose corresponding OP_OPEN_SUBEXP is SUB_TOP.  */
end_comment

begin_function
specifier|static
name|re_sub_match_last_t
modifier|*
name|match_ctx_add_sublast
parameter_list|(
name|subtop
parameter_list|,
name|node
parameter_list|,
name|str_idx
parameter_list|)
name|re_sub_match_top_t
modifier|*
name|subtop
decl_stmt|;
name|int
name|node
decl_stmt|,
name|str_idx
decl_stmt|;
block|{
name|re_sub_match_last_t
modifier|*
name|new_entry
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|subtop
operator|->
name|nlasts
operator|==
name|subtop
operator|->
name|alasts
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|new_alasts
init|=
literal|2
operator|*
name|subtop
operator|->
name|alasts
operator|+
literal|1
decl_stmt|;
name|re_sub_match_last_t
modifier|*
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|subtop
operator|->
name|lasts
argument_list|,
name|re_sub_match_last_t
operator|*
argument_list|,
name|new_alasts
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|subtop
operator|->
name|lasts
operator|=
name|new_array
expr_stmt|;
name|subtop
operator|->
name|alasts
operator|=
name|new_alasts
expr_stmt|;
block|}
name|new_entry
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|re_sub_match_last_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_entry
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|subtop
operator|->
name|lasts
index|[
name|subtop
operator|->
name|nlasts
index|]
operator|=
name|new_entry
expr_stmt|;
name|new_entry
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|new_entry
operator|->
name|str_idx
operator|=
name|str_idx
expr_stmt|;
operator|++
name|subtop
operator|->
name|nlasts
expr_stmt|;
block|}
return|return
name|new_entry
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sift_ctx_init
parameter_list|(
name|sctx
parameter_list|,
name|sifted_sts
parameter_list|,
name|limited_sts
parameter_list|,
name|last_node
parameter_list|,
name|last_str_idx
parameter_list|)
name|re_sift_context_t
modifier|*
name|sctx
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|sifted_sts
decl_stmt|,
decl|*
modifier|*
name|limited_sts
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|last_node
decl_stmt|,
name|last_str_idx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sctx
operator|->
name|sifted_states
operator|=
name|sifted_sts
expr_stmt|;
name|sctx
operator|->
name|limited_states
operator|=
name|limited_sts
expr_stmt|;
name|sctx
operator|->
name|last_node
operator|=
name|last_node
expr_stmt|;
name|sctx
operator|->
name|last_str_idx
operator|=
name|last_str_idx
expr_stmt|;
name|re_node_set_init_empty
argument_list|(
operator|&
name|sctx
operator|->
name|limits
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

