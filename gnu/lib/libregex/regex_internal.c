begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Contributed by Isamu Hasegawa<isamu@yamato.ibm.com>.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, write to the Free    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA    02111-1307 USA.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|re_string_construct_common
argument_list|(
specifier|const
name|char
operator|*
name|str
argument_list|,
name|int
name|len
argument_list|,
name|re_string_t
operator|*
name|pstr
argument_list|,
name|RE_TRANSLATE_TYPE
name|trans
argument_list|,
name|int
name|icase
argument_list|,
specifier|const
name|re_dfa_t
operator|*
name|dfa
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|re_string_skip_chars
argument_list|(
name|re_string_t
operator|*
name|pstr
argument_list|,
name|int
name|new_raw_idx
argument_list|,
name|wint_t
operator|*
name|last_wc
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N */
end_comment

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|register_state
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
name|re_dfastate_t
operator|*
name|newstate
argument_list|,
name|unsigned
name|int
name|hash
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|re_dfastate_t
modifier|*
name|create_ci_newstate
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
specifier|const
name|re_node_set
operator|*
name|nodes
argument_list|,
name|unsigned
name|int
name|hash
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|re_dfastate_t
modifier|*
name|create_cd_newstate
argument_list|(
name|re_dfa_t
operator|*
name|dfa
argument_list|,
specifier|const
name|re_node_set
operator|*
name|nodes
argument_list|,
name|unsigned
name|int
name|context
argument_list|,
name|unsigned
name|int
name|hash
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|inline
name|calc_state_hash
argument_list|(
specifier|const
name|re_node_set
operator|*
name|nodes
argument_list|,
name|unsigned
name|int
name|context
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Functions for string operation.  */
end_comment

begin_comment
comment|/* This function allocate the buffers.  It is necessary to call    re_string_reconstruct before using the object.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_string_allocate
parameter_list|(
name|pstr
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|init_len
parameter_list|,
name|trans
parameter_list|,
name|icase
parameter_list|,
name|dfa
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|,
name|init_len
decl_stmt|,
name|icase
decl_stmt|;
name|RE_TRANSLATE_TYPE
name|trans
decl_stmt|;
specifier|const
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|int
name|init_buf_len
decl_stmt|;
comment|/* Ensure at least one character fits into the buffers.  */
if|if
condition|(
name|init_len
operator|<
name|dfa
operator|->
name|mb_cur_max
condition|)
name|init_len
operator|=
name|dfa
operator|->
name|mb_cur_max
expr_stmt|;
name|init_buf_len
operator|=
operator|(
name|len
operator|+
literal|1
operator|<
name|init_len
operator|)
condition|?
name|len
operator|+
literal|1
else|:
name|init_len
expr_stmt|;
name|re_string_construct_common
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|pstr
argument_list|,
name|trans
argument_list|,
name|icase
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
name|ret
operator|=
name|re_string_realloc_buffers
argument_list|(
name|pstr
argument_list|,
name|init_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
name|pstr
operator|->
name|word_char
operator|=
name|dfa
operator|->
name|word_char
expr_stmt|;
name|pstr
operator|->
name|word_ops_used
operator|=
name|dfa
operator|->
name|word_ops_used
expr_stmt|;
name|pstr
operator|->
name|mbs
operator|=
name|pstr
operator|->
name|mbs_allocated
condition|?
name|pstr
operator|->
name|mbs
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
expr_stmt|;
name|pstr
operator|->
name|valid_len
operator|=
operator|(
name|pstr
operator|->
name|mbs_allocated
operator|||
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
operator|)
condition|?
literal|0
else|:
name|len
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|pstr
operator|->
name|valid_len
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* This function allocate the buffers, and initialize them.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_string_construct
parameter_list|(
name|pstr
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|trans
parameter_list|,
name|icase
parameter_list|,
name|dfa
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|,
name|icase
decl_stmt|;
name|RE_TRANSLATE_TYPE
name|trans
decl_stmt|;
specifier|const
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|memset
argument_list|(
name|pstr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|re_string_t
argument_list|)
argument_list|)
expr_stmt|;
name|re_string_construct_common
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|pstr
argument_list|,
name|trans
argument_list|,
name|icase
argument_list|,
name|dfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|re_string_realloc_buffers
argument_list|(
name|pstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
block|}
name|pstr
operator|->
name|mbs
operator|=
name|pstr
operator|->
name|mbs_allocated
condition|?
name|pstr
operator|->
name|mbs
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
expr_stmt|;
if|if
condition|(
name|icase
condition|)
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|build_wcs_upper_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|pstr
operator|->
name|valid_raw_len
operator|>=
name|len
condition|)
break|break;
if|if
condition|(
name|pstr
operator|->
name|bufs_len
operator|>
name|pstr
operator|->
name|valid_len
operator|+
name|dfa
operator|->
name|mb_cur_max
condition|)
break|break;
name|ret
operator|=
name|re_string_realloc_buffers
argument_list|(
name|pstr
argument_list|,
name|pstr
operator|->
name|bufs_len
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N  */
name|build_upper_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|build_wcs_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N  */
block|{
if|if
condition|(
name|trans
operator|!=
name|NULL
condition|)
name|re_string_translate_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
else|else
block|{
name|pstr
operator|->
name|valid_len
operator|=
name|pstr
operator|->
name|bufs_len
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|pstr
operator|->
name|bufs_len
expr_stmt|;
block|}
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for re_string_allocate, and re_string_construct.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_string_realloc_buffers
parameter_list|(
name|pstr
parameter_list|,
name|new_buf_len
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
name|int
name|new_buf_len
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|wint_t
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|pstr
operator|->
name|wcs
argument_list|,
name|wint_t
argument_list|,
name|new_buf_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|pstr
operator|->
name|wcs
operator|=
name|new_array
expr_stmt|;
if|if
condition|(
name|pstr
operator|->
name|offsets
operator|!=
name|NULL
condition|)
block|{
name|int
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|pstr
operator|->
name|offsets
argument_list|,
name|int
argument_list|,
name|new_buf_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|pstr
operator|->
name|offsets
operator|=
name|new_array
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* RE_ENABLE_I18N  */
if|if
condition|(
name|pstr
operator|->
name|mbs_allocated
condition|)
block|{
name|unsigned
name|char
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
argument|pstr->mbs
argument_list|,
argument|unsigned char
argument_list|,
argument|new_buf_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|pstr
operator|->
name|mbs
operator|=
name|new_array
expr_stmt|;
block|}
name|pstr
operator|->
name|bufs_len
operator|=
name|new_buf_len
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|re_string_construct_common
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|pstr
parameter_list|,
name|trans
parameter_list|,
name|icase
parameter_list|,
name|dfa
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
name|RE_TRANSLATE_TYPE
name|trans
decl_stmt|;
name|int
name|icase
decl_stmt|;
specifier|const
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
block|{
name|pstr
operator|->
name|raw_mbs
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|str
expr_stmt|;
name|pstr
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|pstr
operator|->
name|raw_len
operator|=
name|len
expr_stmt|;
name|pstr
operator|->
name|trans
operator|=
operator|(
name|unsigned
name|RE_TRANSLATE_TYPE
operator|)
name|trans
expr_stmt|;
name|pstr
operator|->
name|icase
operator|=
name|icase
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|pstr
operator|->
name|mbs_allocated
operator|=
operator|(
name|trans
operator|!=
name|NULL
operator|||
name|icase
operator|)
expr_stmt|;
name|pstr
operator|->
name|mb_cur_max
operator|=
name|dfa
operator|->
name|mb_cur_max
expr_stmt|;
name|pstr
operator|->
name|is_utf8
operator|=
name|dfa
operator|->
name|is_utf8
expr_stmt|;
name|pstr
operator|->
name|map_notascii
operator|=
name|dfa
operator|->
name|map_notascii
expr_stmt|;
name|pstr
operator|->
name|stop
operator|=
name|pstr
operator|->
name|len
expr_stmt|;
name|pstr
operator|->
name|raw_stop
operator|=
name|pstr
operator|->
name|stop
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
end_ifdef

begin_comment
comment|/* Build wide character buffer PSTR->WCS.    If the byte sequence of the string are:<mb1>(0),<mb1>(1),<mb2>(0),<mb2>(1),<sb3>    Then wide character buffer will be:<wc1>   , WEOF    ,<wc2>   , WEOF    ,<wc3>    We use WEOF for padding, they indicate that the position isn't    a first byte of a multibyte character.     Note that this function assumes PSTR->VALID_LEN elements are already    built and starts from PSTR->VALID_LEN.  */
end_comment

begin_function
specifier|static
name|void
name|build_wcs_buffer
parameter_list|(
name|pstr
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|unsigned
name|char
name|buf
index|[
name|MB_CUR_MAX
index|]
decl_stmt|;
name|assert
argument_list|(
name|MB_CUR_MAX
operator|>=
name|pstr
operator|->
name|mb_cur_max
argument_list|)
expr_stmt|;
else|#
directive|else
name|unsigned
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
endif|#
directive|endif
name|mbstate_t
name|prev_st
decl_stmt|;
name|int
name|byte_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|remain_len
decl_stmt|;
name|size_t
name|mbclen
decl_stmt|;
comment|/* Build the buffers from pstr->valid_len to either pstr->len or      pstr->bufs_len.  */
name|end_idx
operator|=
operator|(
name|pstr
operator|->
name|bufs_len
operator|>
name|pstr
operator|->
name|len
operator|)
condition|?
name|pstr
operator|->
name|len
else|:
name|pstr
operator|->
name|bufs_len
expr_stmt|;
for|for
control|(
name|byte_idx
operator|=
name|pstr
operator|->
name|valid_len
init|;
name|byte_idx
operator|<
name|end_idx
condition|;
control|)
block|{
name|wchar_t
name|wc
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|remain_len
operator|=
name|end_idx
operator|-
name|byte_idx
expr_stmt|;
name|prev_st
operator|=
name|pstr
operator|->
name|cur_state
expr_stmt|;
comment|/* Apply the translation if we need.  */
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pstr
operator|->
name|mb_cur_max
operator|&&
name|i
operator|<
name|remain_len
condition|;
operator|++
name|i
control|)
block|{
name|ch
operator|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
operator|+
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|pstr
operator|->
name|mbs
index|[
name|byte_idx
operator|+
name|i
index|]
operator|=
name|pstr
operator|->
name|trans
index|[
name|ch
index|]
expr_stmt|;
block|}
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pstr
operator|->
name|raw_mbs
operator|+
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
expr_stmt|;
name|mbclen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|remain_len
argument_list|,
operator|&
name|pstr
operator|->
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* The buffer doesn't have enough space, finish to build.  */
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mbclen
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We treat these cases as a singlebyte character.  */
name|mbclen
operator|=
literal|1
expr_stmt|;
name|wc
operator|=
operator|(
name|wchar_t
operator|)
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
index|]
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|wc
operator|=
name|pstr
operator|->
name|trans
index|[
name|wc
index|]
expr_stmt|;
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
block|}
comment|/* Write wide character and padding.  */
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
name|wc
expr_stmt|;
comment|/* Write paddings.  */
for|for
control|(
name|remain_len
operator|=
name|byte_idx
operator|+
name|mbclen
operator|-
literal|1
init|;
name|byte_idx
operator|<
name|remain_len
condition|;
control|)
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
name|WEOF
expr_stmt|;
block|}
name|pstr
operator|->
name|valid_len
operator|=
name|byte_idx
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|byte_idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build wide character buffer PSTR->WCS like build_wcs_buffer,    but for REG_ICASE.  */
end_comment

begin_function
specifier|static
name|int
name|build_wcs_upper_buffer
parameter_list|(
name|pstr
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
block|{
name|mbstate_t
name|prev_st
decl_stmt|;
name|int
name|src_idx
decl_stmt|,
name|byte_idx
decl_stmt|,
name|end_idx
decl_stmt|,
name|remain_len
decl_stmt|;
name|size_t
name|mbclen
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|char
name|buf
index|[
name|MB_CUR_MAX
index|]
decl_stmt|;
name|assert
argument_list|(
name|MB_CUR_MAX
operator|>=
name|pstr
operator|->
name|mb_cur_max
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
endif|#
directive|endif
name|byte_idx
operator|=
name|pstr
operator|->
name|valid_len
expr_stmt|;
name|end_idx
operator|=
operator|(
name|pstr
operator|->
name|bufs_len
operator|>
name|pstr
operator|->
name|len
operator|)
condition|?
name|pstr
operator|->
name|len
else|:
name|pstr
operator|->
name|bufs_len
expr_stmt|;
comment|/* The following optimization assumes that ASCII characters can be      mapped to wide characters with a simple cast.  */
if|if
condition|(
operator|!
name|pstr
operator|->
name|map_notascii
operator|&&
name|pstr
operator|->
name|trans
operator|==
name|NULL
operator|&&
operator|!
name|pstr
operator|->
name|offsets_needed
condition|)
block|{
while|while
condition|(
name|byte_idx
operator|<
name|end_idx
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
index|]
argument_list|)
operator|&&
name|mbsinit
argument_list|(
operator|&
name|pstr
operator|->
name|cur_state
argument_list|)
condition|)
block|{
comment|/* In case of a singlebyte character.  */
name|pstr
operator|->
name|mbs
index|[
name|byte_idx
index|]
operator|=
name|toupper
argument_list|(
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
index|]
argument_list|)
expr_stmt|;
comment|/* The next step uses the assumption that wchar_t is encoded 		 ASCII-safe: all ASCII values can be converted like this.  */
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|pstr
operator|->
name|mbs
index|[
name|byte_idx
index|]
expr_stmt|;
operator|++
name|byte_idx
expr_stmt|;
continue|continue;
block|}
name|remain_len
operator|=
name|end_idx
operator|-
name|byte_idx
expr_stmt|;
name|prev_st
operator|=
name|pstr
operator|->
name|cur_state
expr_stmt|;
name|mbclen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|pstr
operator|->
name|raw_mbs
operator|+
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
operator|)
argument_list|,
name|remain_len
argument_list|,
operator|&
name|pstr
operator|->
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|+
literal|2
operator|>
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|wchar_t
name|wcu
init|=
name|wc
decl_stmt|;
if|if
condition|(
name|iswlower
argument_list|(
name|wc
argument_list|)
condition|)
block|{
name|size_t
name|mbcdlen
decl_stmt|;
name|wcu
operator|=
name|towupper
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|mbcdlen
operator|=
name|wcrtomb
argument_list|(
name|buf
argument_list|,
name|wcu
argument_list|,
operator|&
name|prev_st
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
name|mbcdlen
argument_list|,
literal|1
argument_list|)
condition|)
name|memcpy
argument_list|(
name|pstr
operator|->
name|mbs
operator|+
name|byte_idx
argument_list|,
name|buf
argument_list|,
name|mbclen
argument_list|)
expr_stmt|;
else|else
block|{
name|src_idx
operator|=
name|byte_idx
expr_stmt|;
goto|goto
name|offsets_needed
goto|;
block|}
block|}
else|else
name|memcpy
argument_list|(
name|pstr
operator|->
name|mbs
operator|+
name|byte_idx
argument_list|,
name|pstr
operator|->
name|raw_mbs
operator|+
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
argument_list|,
name|mbclen
argument_list|)
expr_stmt|;
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
name|wcu
expr_stmt|;
comment|/* Write paddings.  */
for|for
control|(
name|remain_len
operator|=
name|byte_idx
operator|+
name|mbclen
operator|-
literal|1
init|;
name|byte_idx
operator|<
name|remain_len
condition|;
control|)
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
name|WEOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mbclen
operator|==
literal|0
condition|)
block|{
comment|/* It is an invalid character or '\0'.  Just use the byte.  */
name|int
name|ch
init|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|byte_idx
index|]
decl_stmt|;
name|pstr
operator|->
name|mbs
index|[
name|byte_idx
index|]
operator|=
name|ch
expr_stmt|;
comment|/* And also cast it to wide char.  */
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
block|}
else|else
block|{
comment|/* The buffer doesn't have enough space, finish to build.  */
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
break|break;
block|}
block|}
name|pstr
operator|->
name|valid_len
operator|=
name|byte_idx
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|byte_idx
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
else|else
for|for
control|(
name|src_idx
operator|=
name|pstr
operator|->
name|valid_raw_len
init|;
name|byte_idx
operator|<
name|end_idx
condition|;
control|)
block|{
name|wchar_t
name|wc
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|offsets_needed
label|:
name|remain_len
operator|=
name|end_idx
operator|-
name|byte_idx
expr_stmt|;
name|prev_st
operator|=
name|pstr
operator|->
name|cur_state
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pstr
operator|->
name|mb_cur_max
operator|&&
name|i
operator|<
name|remain_len
condition|;
operator|++
name|i
control|)
block|{
name|ch
operator|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|src_idx
operator|+
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|pstr
operator|->
name|trans
index|[
name|ch
index|]
expr_stmt|;
block|}
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pstr
operator|->
name|raw_mbs
operator|+
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|src_idx
expr_stmt|;
name|mbclen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|remain_len
argument_list|,
operator|&
name|pstr
operator|->
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|+
literal|2
operator|>
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|wchar_t
name|wcu
init|=
name|wc
decl_stmt|;
if|if
condition|(
name|iswlower
argument_list|(
name|wc
argument_list|)
condition|)
block|{
name|size_t
name|mbcdlen
decl_stmt|;
name|wcu
operator|=
name|towupper
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|mbcdlen
operator|=
name|wcrtomb
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|wcu
argument_list|,
operator|&
name|prev_st
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
name|mbcdlen
argument_list|,
literal|1
argument_list|)
condition|)
name|memcpy
argument_list|(
name|pstr
operator|->
name|mbs
operator|+
name|byte_idx
argument_list|,
name|buf
argument_list|,
name|mbclen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mbcdlen
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|byte_idx
operator|+
name|mbcdlen
operator|>
name|pstr
operator|->
name|bufs_len
condition|)
block|{
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pstr
operator|->
name|offsets
operator|==
name|NULL
condition|)
block|{
name|pstr
operator|->
name|offsets
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|pstr
operator|->
name|bufs_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstr
operator|->
name|offsets
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
block|}
if|if
condition|(
operator|!
name|pstr
operator|->
name|offsets_needed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|byte_idx
condition|;
operator|++
name|i
control|)
name|pstr
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|pstr
operator|->
name|offsets_needed
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pstr
operator|->
name|mbs
operator|+
name|byte_idx
argument_list|,
name|buf
argument_list|,
name|mbcdlen
argument_list|)
expr_stmt|;
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
index|]
operator|=
name|wcu
expr_stmt|;
name|pstr
operator|->
name|offsets
index|[
name|byte_idx
index|]
operator|=
name|src_idx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mbcdlen
condition|;
operator|++
name|i
control|)
block|{
name|pstr
operator|->
name|offsets
index|[
name|byte_idx
operator|+
name|i
index|]
operator|=
name|src_idx
operator|+
operator|(
name|i
operator|<
name|mbclen
condition|?
name|i
else|:
name|mbclen
operator|-
literal|1
operator|)
expr_stmt|;
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|+
name|i
index|]
operator|=
name|WEOF
expr_stmt|;
block|}
name|pstr
operator|->
name|len
operator|+=
name|mbcdlen
operator|-
name|mbclen
expr_stmt|;
if|if
condition|(
name|pstr
operator|->
name|raw_stop
operator|>
name|src_idx
condition|)
name|pstr
operator|->
name|stop
operator|+=
name|mbcdlen
operator|-
name|mbclen
expr_stmt|;
name|end_idx
operator|=
operator|(
name|pstr
operator|->
name|bufs_len
operator|>
name|pstr
operator|->
name|len
operator|)
condition|?
name|pstr
operator|->
name|len
else|:
name|pstr
operator|->
name|bufs_len
expr_stmt|;
name|byte_idx
operator|+=
name|mbcdlen
expr_stmt|;
name|src_idx
operator|+=
name|mbclen
expr_stmt|;
continue|continue;
block|}
else|else
name|memcpy
argument_list|(
name|pstr
operator|->
name|mbs
operator|+
name|byte_idx
argument_list|,
name|p
argument_list|,
name|mbclen
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|pstr
operator|->
name|mbs
operator|+
name|byte_idx
argument_list|,
name|p
argument_list|,
name|mbclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|offsets_needed
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mbclen
condition|;
operator|++
name|i
control|)
name|pstr
operator|->
name|offsets
index|[
name|byte_idx
operator|+
name|i
index|]
operator|=
name|src_idx
operator|+
name|i
expr_stmt|;
block|}
name|src_idx
operator|+=
name|mbclen
expr_stmt|;
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
name|wcu
expr_stmt|;
comment|/* Write paddings.  */
for|for
control|(
name|remain_len
operator|=
name|byte_idx
operator|+
name|mbclen
operator|-
literal|1
init|;
name|byte_idx
operator|<
name|remain_len
condition|;
control|)
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
name|WEOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mbclen
operator|==
literal|0
condition|)
block|{
comment|/* It is an invalid character or '\0'.  Just use the byte.  */
name|int
name|ch
init|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|src_idx
index|]
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|ch
operator|=
name|pstr
operator|->
name|trans
index|[
name|ch
index|]
expr_stmt|;
name|pstr
operator|->
name|mbs
index|[
name|byte_idx
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|offsets_needed
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|pstr
operator|->
name|offsets
index|[
name|byte_idx
index|]
operator|=
name|src_idx
expr_stmt|;
operator|++
name|src_idx
expr_stmt|;
comment|/* And also cast it to wide char.  */
name|pstr
operator|->
name|wcs
index|[
name|byte_idx
operator|++
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
block|}
else|else
block|{
comment|/* The buffer doesn't have enough space, finish to build.  */
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
break|break;
block|}
block|}
name|pstr
operator|->
name|valid_len
operator|=
name|byte_idx
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|src_idx
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Skip characters until the index becomes greater than NEW_RAW_IDX.    Return the index.  */
end_comment

begin_function
specifier|static
name|int
name|re_string_skip_chars
parameter_list|(
name|pstr
parameter_list|,
name|new_raw_idx
parameter_list|,
name|last_wc
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
name|int
name|new_raw_idx
decl_stmt|;
name|wint_t
modifier|*
name|last_wc
decl_stmt|;
block|{
name|mbstate_t
name|prev_st
decl_stmt|;
name|int
name|rawbuf_idx
decl_stmt|;
name|size_t
name|mbclen
decl_stmt|;
name|wchar_t
name|wc
init|=
literal|0
decl_stmt|;
comment|/* Skip the characters which are not necessary to check.  */
for|for
control|(
name|rawbuf_idx
operator|=
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|pstr
operator|->
name|valid_raw_len
init|;
name|rawbuf_idx
operator|<
name|new_raw_idx
condition|;
control|)
block|{
name|int
name|remain_len
decl_stmt|;
name|remain_len
operator|=
name|pstr
operator|->
name|len
operator|-
name|rawbuf_idx
expr_stmt|;
name|prev_st
operator|=
name|pstr
operator|->
name|cur_state
expr_stmt|;
name|mbclen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|pstr
operator|->
name|raw_mbs
operator|+
name|rawbuf_idx
argument_list|,
name|remain_len
argument_list|,
operator|&
name|pstr
operator|->
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
operator|||
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mbclen
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We treat these cases as a singlebyte character.  */
name|mbclen
operator|=
literal|1
expr_stmt|;
name|pstr
operator|->
name|cur_state
operator|=
name|prev_st
expr_stmt|;
block|}
comment|/* Then proceed the next character.  */
name|rawbuf_idx
operator|+=
name|mbclen
expr_stmt|;
block|}
operator|*
name|last_wc
operator|=
operator|(
name|wint_t
operator|)
name|wc
expr_stmt|;
return|return
name|rawbuf_idx
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RE_ENABLE_I18N  */
end_comment

begin_comment
comment|/* Build the buffer PSTR->MBS, and apply the translation if we need.    This function is used in case of REG_ICASE.  */
end_comment

begin_function
specifier|static
name|void
name|build_upper_buffer
parameter_list|(
name|pstr
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
block|{
name|int
name|char_idx
decl_stmt|,
name|end_idx
decl_stmt|;
name|end_idx
operator|=
operator|(
name|pstr
operator|->
name|bufs_len
operator|>
name|pstr
operator|->
name|len
operator|)
condition|?
name|pstr
operator|->
name|len
else|:
name|pstr
operator|->
name|bufs_len
expr_stmt|;
for|for
control|(
name|char_idx
operator|=
name|pstr
operator|->
name|valid_len
init|;
name|char_idx
operator|<
name|end_idx
condition|;
operator|++
name|char_idx
control|)
block|{
name|int
name|ch
init|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|char_idx
index|]
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|ch
operator|=
name|pstr
operator|->
name|trans
index|[
name|ch
index|]
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
name|pstr
operator|->
name|mbs
index|[
name|char_idx
index|]
operator|=
name|toupper
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
name|pstr
operator|->
name|mbs
index|[
name|char_idx
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|pstr
operator|->
name|valid_len
operator|=
name|char_idx
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|char_idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply TRANS to the buffer in PSTR.  */
end_comment

begin_function
specifier|static
name|void
name|re_string_translate_buffer
parameter_list|(
name|pstr
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
block|{
name|int
name|buf_idx
decl_stmt|,
name|end_idx
decl_stmt|;
name|end_idx
operator|=
operator|(
name|pstr
operator|->
name|bufs_len
operator|>
name|pstr
operator|->
name|len
operator|)
condition|?
name|pstr
operator|->
name|len
else|:
name|pstr
operator|->
name|bufs_len
expr_stmt|;
for|for
control|(
name|buf_idx
operator|=
name|pstr
operator|->
name|valid_len
init|;
name|buf_idx
operator|<
name|end_idx
condition|;
operator|++
name|buf_idx
control|)
block|{
name|int
name|ch
init|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|buf_idx
index|]
decl_stmt|;
name|pstr
operator|->
name|mbs
index|[
name|buf_idx
index|]
operator|=
name|pstr
operator|->
name|trans
index|[
name|ch
index|]
expr_stmt|;
block|}
name|pstr
operator|->
name|valid_len
operator|=
name|buf_idx
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
name|buf_idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function re-construct the buffers.    Concretely, convert to wide character in case of pstr->mb_cur_max> 1,    convert to upper case in case of REG_ICASE, apply translation.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_string_reconstruct
parameter_list|(
name|pstr
parameter_list|,
name|idx
parameter_list|,
name|eflags
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|eflags
decl_stmt|;
block|{
name|int
name|offset
init|=
name|idx
operator|-
name|pstr
operator|->
name|raw_mbs_idx
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|offset
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Reset buffer.  */
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|memset
argument_list|(
operator|&
name|pstr
operator|->
name|cur_state
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
name|pstr
operator|->
name|len
operator|=
name|pstr
operator|->
name|raw_len
expr_stmt|;
name|pstr
operator|->
name|stop
operator|=
name|pstr
operator|->
name|raw_stop
expr_stmt|;
name|pstr
operator|->
name|valid_len
operator|=
literal|0
expr_stmt|;
name|pstr
operator|->
name|raw_mbs_idx
operator|=
literal|0
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
literal|0
expr_stmt|;
name|pstr
operator|->
name|offsets_needed
operator|=
literal|0
expr_stmt|;
name|pstr
operator|->
name|tip_context
operator|=
operator|(
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
condition|?
name|CONTEXT_BEGBUF
else|:
name|CONTEXT_NEWLINE
operator||
name|CONTEXT_BEGBUF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|pstr
operator|->
name|mbs_allocated
condition|)
name|pstr
operator|->
name|mbs
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pstr
operator|->
name|raw_mbs
expr_stmt|;
name|offset
operator|=
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|offset
operator|!=
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Are the characters which are already checked remain?  */
if|if
condition|(
name|BE
argument_list|(
name|offset
operator|<
name|pstr
operator|->
name|valid_raw_len
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* Handling this would enlarge the code too much. 	     Accept a slowdown in that case.  */
operator|&&
name|pstr
operator|->
name|offsets_needed
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
comment|/* Yes, move them to the front of the buffer.  */
name|pstr
operator|->
name|tip_context
operator|=
name|re_string_context_at
argument_list|(
name|pstr
argument_list|,
name|offset
operator|-
literal|1
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
name|memmove
argument_list|(
name|pstr
operator|->
name|wcs
argument_list|,
name|pstr
operator|->
name|wcs
operator|+
name|offset
argument_list|,
operator|(
name|pstr
operator|->
name|valid_len
operator|-
name|offset
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wint_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|mbs_allocated
argument_list|,
literal|0
argument_list|)
condition|)
name|memmove
argument_list|(
name|pstr
operator|->
name|mbs
argument_list|,
name|pstr
operator|->
name|mbs
operator|+
name|offset
argument_list|,
name|pstr
operator|->
name|valid_len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|pstr
operator|->
name|valid_len
operator|-=
name|offset
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|-=
name|offset
expr_stmt|;
if|#
directive|if
name|DEBUG
name|assert
argument_list|(
name|pstr
operator|->
name|valid_len
operator|>
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* No, skip all characters until IDX.  */
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|offsets_needed
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pstr
operator|->
name|len
operator|=
name|pstr
operator|->
name|raw_len
operator|-
name|idx
operator|+
name|offset
expr_stmt|;
name|pstr
operator|->
name|stop
operator|=
name|pstr
operator|->
name|raw_stop
operator|-
name|idx
operator|+
name|offset
expr_stmt|;
name|pstr
operator|->
name|offsets_needed
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|pstr
operator|->
name|valid_len
operator|=
literal|0
expr_stmt|;
name|pstr
operator|->
name|valid_raw_len
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|int
name|wcs_idx
decl_stmt|;
name|wint_t
name|wc
init|=
name|WEOF
decl_stmt|;
if|if
condition|(
name|pstr
operator|->
name|is_utf8
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* Special case UTF-8.  Multi-byte chars start with any 		     byte other than 0x80 - 0xbf.  */
name|raw
operator|=
name|pstr
operator|->
name|raw_mbs
operator|+
name|pstr
operator|->
name|raw_mbs_idx
expr_stmt|;
name|end
operator|=
name|raw
operator|+
operator|(
name|offset
operator|-
name|pstr
operator|->
name|mb_cur_max
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|raw
operator|+
name|offset
operator|-
literal|1
init|;
name|p
operator|>=
name|end
condition|;
operator|--
name|p
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|mbstate_t
name|cur_state
decl_stmt|;
name|wchar_t
name|wc2
decl_stmt|;
name|int
name|mlen
init|=
name|raw
operator|+
name|pstr
operator|->
name|len
operator|-
name|p
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|mlen
operator|<
literal|6
condition|?
name|mlen
else|:
literal|6
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|buf
index|[
name|i
index|]
operator|=
name|pstr
operator|->
name|trans
index|[
name|p
index|[
name|i
index|]
index|]
expr_stmt|;
name|q
operator|=
name|buf
expr_stmt|;
block|}
comment|/* XXX Don't use mbrtowc, we know which conversion 			   to use (UTF-8 -> UCS4).  */
name|memset
argument_list|(
operator|&
name|cur_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_state
argument_list|)
argument_list|)
expr_stmt|;
name|mlen
operator|=
operator|(
name|mbrtowc
argument_list|(
operator|&
name|wc2
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
name|mlen
argument_list|,
operator|&
name|cur_state
argument_list|)
operator|-
operator|(
name|raw
operator|+
name|offset
operator|-
name|p
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|>=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|pstr
operator|->
name|cur_state
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|pstr
operator|->
name|valid_len
operator|=
name|mlen
expr_stmt|;
name|wc
operator|=
name|wc2
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|wc
operator|==
name|WEOF
condition|)
name|pstr
operator|->
name|valid_len
operator|=
name|re_string_skip_chars
argument_list|(
name|pstr
argument_list|,
name|idx
argument_list|,
operator|&
name|wc
argument_list|)
operator|-
name|idx
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|valid_len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
for|for
control|(
name|wcs_idx
operator|=
literal|0
init|;
name|wcs_idx
operator|<
name|pstr
operator|->
name|valid_len
condition|;
operator|++
name|wcs_idx
control|)
name|pstr
operator|->
name|wcs
index|[
name|wcs_idx
index|]
operator|=
name|WEOF
expr_stmt|;
if|if
condition|(
name|pstr
operator|->
name|mbs_allocated
condition|)
name|memset
argument_list|(
name|pstr
operator|->
name|mbs
argument_list|,
literal|255
argument_list|,
name|pstr
operator|->
name|valid_len
argument_list|)
expr_stmt|;
block|}
name|pstr
operator|->
name|valid_raw_len
operator|=
name|pstr
operator|->
name|valid_len
expr_stmt|;
name|pstr
operator|->
name|tip_context
operator|=
operator|(
operator|(
name|BE
argument_list|(
name|pstr
operator|->
name|word_ops_used
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
operator|&&
name|IS_WIDE_WORD_CHAR
argument_list|(
name|wc
argument_list|)
operator|)
condition|?
name|CONTEXT_WORD
else|:
operator|(
operator|(
name|IS_WIDE_NEWLINE
argument_list|(
name|wc
argument_list|)
operator|&&
name|pstr
operator|->
name|newline_anchor
operator|)
condition|?
name|CONTEXT_NEWLINE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
block|{
name|int
name|c
init|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|offset
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|pstr
operator|->
name|trans
condition|)
name|c
operator|=
name|pstr
operator|->
name|trans
index|[
name|c
index|]
expr_stmt|;
name|pstr
operator|->
name|tip_context
operator|=
operator|(
name|bitset_contain
argument_list|(
name|pstr
operator|->
name|word_char
argument_list|,
name|c
argument_list|)
condition|?
name|CONTEXT_WORD
else|:
operator|(
operator|(
name|IS_NEWLINE
argument_list|(
name|c
argument_list|)
operator|&&
name|pstr
operator|->
name|newline_anchor
operator|)
condition|?
name|CONTEXT_NEWLINE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|BE
argument_list|(
name|pstr
operator|->
name|mbs_allocated
argument_list|,
literal|0
argument_list|)
condition|)
name|pstr
operator|->
name|mbs
operator|+=
name|offset
expr_stmt|;
block|}
name|pstr
operator|->
name|raw_mbs_idx
operator|=
name|idx
expr_stmt|;
name|pstr
operator|->
name|len
operator|-=
name|offset
expr_stmt|;
name|pstr
operator|->
name|stop
operator|-=
name|offset
expr_stmt|;
comment|/* Then build the buffers.  */
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|pstr
operator|->
name|icase
condition|)
block|{
name|int
name|ret
init|=
name|build_wcs_upper_buffer
argument_list|(
name|pstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|ret
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ret
return|;
block|}
else|else
name|build_wcs_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
if|if
condition|(
name|BE
argument_list|(
name|pstr
operator|->
name|mbs_allocated
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|pstr
operator|->
name|icase
condition|)
name|build_upper_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pstr
operator|->
name|trans
operator|!=
name|NULL
condition|)
name|re_string_translate_buffer
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
block|}
else|else
name|pstr
operator|->
name|valid_len
operator|=
name|pstr
operator|->
name|len
expr_stmt|;
name|pstr
operator|->
name|cur_idx
operator|=
literal|0
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|re_string_peek_byte_case
parameter_list|(
name|pstr
parameter_list|,
name|idx
parameter_list|)
specifier|const
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|,
name|off
decl_stmt|;
comment|/* Handle the common (easiest) cases first.  */
if|if
condition|(
name|BE
argument_list|(
operator|!
name|pstr
operator|->
name|mbs_allocated
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|re_string_peek_byte
argument_list|(
name|pstr
argument_list|,
name|idx
argument_list|)
return|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|re_string_is_single_byte_char
argument_list|(
name|pstr
argument_list|,
name|pstr
operator|->
name|cur_idx
operator|+
name|idx
argument_list|)
condition|)
return|return
name|re_string_peek_byte
argument_list|(
name|pstr
argument_list|,
name|idx
argument_list|)
return|;
endif|#
directive|endif
name|off
operator|=
name|pstr
operator|->
name|cur_idx
operator|+
name|idx
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|offsets_needed
condition|)
name|off
operator|=
name|pstr
operator|->
name|offsets
index|[
name|off
index|]
expr_stmt|;
endif|#
directive|endif
name|ch
operator|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|off
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
comment|/* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I      this function returns CAPITAL LETTER I instead of first byte of      DOTLESS SMALL LETTER I.  The latter would confuse the parser,      since peek_byte_case doesn't advance cur_idx in any way.  */
if|if
condition|(
name|pstr
operator|->
name|offsets_needed
operator|&&
operator|!
name|isascii
argument_list|(
name|ch
argument_list|)
condition|)
return|return
name|re_string_peek_byte
argument_list|(
name|pstr
argument_list|,
name|idx
argument_list|)
return|;
endif|#
directive|endif
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|re_string_fetch_byte_case
parameter_list|(
name|pstr
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
block|{
if|if
condition|(
name|BE
argument_list|(
operator|!
name|pstr
operator|->
name|mbs_allocated
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|re_string_fetch_byte
argument_list|(
name|pstr
argument_list|)
return|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|pstr
operator|->
name|offsets_needed
condition|)
block|{
name|int
name|off
decl_stmt|,
name|ch
decl_stmt|;
comment|/* For tr_TR.UTF-8 [[:islower:]] there is 	 [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip 	 in that case the whole multi-byte character and return 	 the original letter.  On the other side, with 	 [[: DOTLESS SMALL LETTER I return [[:I, as doing 	 anything else would complicate things too much.  */
if|if
condition|(
operator|!
name|re_string_first_byte
argument_list|(
name|pstr
argument_list|,
name|pstr
operator|->
name|cur_idx
argument_list|)
condition|)
return|return
name|re_string_fetch_byte
argument_list|(
name|pstr
argument_list|)
return|;
name|off
operator|=
name|pstr
operator|->
name|offsets
index|[
name|pstr
operator|->
name|cur_idx
index|]
expr_stmt|;
name|ch
operator|=
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|off
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|ch
argument_list|)
condition|)
return|return
name|re_string_fetch_byte
argument_list|(
name|pstr
argument_list|)
return|;
name|re_string_skip_bytes
argument_list|(
name|pstr
argument_list|,
name|re_string_char_size_at
argument_list|(
name|pstr
argument_list|,
name|pstr
operator|->
name|cur_idx
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
endif|#
directive|endif
return|return
name|pstr
operator|->
name|raw_mbs
index|[
name|pstr
operator|->
name|raw_mbs_idx
operator|+
name|pstr
operator|->
name|cur_idx
operator|++
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|re_string_destruct
parameter_list|(
name|pstr
parameter_list|)
name|re_string_t
modifier|*
name|pstr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|re_free
argument_list|(
name|pstr
operator|->
name|wcs
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|pstr
operator|->
name|offsets
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N  */
if|if
condition|(
name|pstr
operator|->
name|mbs_allocated
condition|)
name|re_free
argument_list|(
name|pstr
operator|->
name|mbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the context at IDX in INPUT.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|re_string_context_at
parameter_list|(
name|input
parameter_list|,
name|idx
parameter_list|,
name|eflags
parameter_list|)
specifier|const
name|re_string_t
modifier|*
name|input
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|eflags
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|idx
operator|<
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* In this case, we use the value stored in input->tip_context,        since we can't know the character in input->mbs[-1] here.  */
return|return
name|input
operator|->
name|tip_context
return|;
if|if
condition|(
name|BE
argument_list|(
name|idx
operator|==
name|input
operator|->
name|len
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|(
name|eflags
operator|&
name|REG_NOTEOL
operator|)
condition|?
name|CONTEXT_ENDBUF
else|:
name|CONTEXT_NEWLINE
operator||
name|CONTEXT_ENDBUF
operator|)
return|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
if|if
condition|(
name|input
operator|->
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|wint_t
name|wc
decl_stmt|;
name|int
name|wc_idx
init|=
name|idx
decl_stmt|;
while|while
condition|(
name|input
operator|->
name|wcs
index|[
name|wc_idx
index|]
operator|==
name|WEOF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* It must not happen.  */
name|assert
argument_list|(
name|wc_idx
operator|>=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|wc_idx
expr_stmt|;
if|if
condition|(
name|wc_idx
operator|<
literal|0
condition|)
return|return
name|input
operator|->
name|tip_context
return|;
block|}
name|wc
operator|=
name|input
operator|->
name|wcs
index|[
name|wc_idx
index|]
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|input
operator|->
name|word_ops_used
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
operator|&&
name|IS_WIDE_WORD_CHAR
argument_list|(
name|wc
argument_list|)
condition|)
return|return
name|CONTEXT_WORD
return|;
return|return
operator|(
name|IS_WIDE_NEWLINE
argument_list|(
name|wc
argument_list|)
operator|&&
name|input
operator|->
name|newline_anchor
condition|?
name|CONTEXT_NEWLINE
else|:
literal|0
operator|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|c
operator|=
name|re_string_byte_at
argument_list|(
name|input
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset_contain
argument_list|(
name|input
operator|->
name|word_char
argument_list|,
name|c
argument_list|)
condition|)
return|return
name|CONTEXT_WORD
return|;
return|return
name|IS_NEWLINE
argument_list|(
name|c
argument_list|)
operator|&&
name|input
operator|->
name|newline_anchor
condition|?
name|CONTEXT_NEWLINE
else|:
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for set operation.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_alloc
parameter_list|(
name|set
parameter_list|,
name|size
parameter_list|)
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|set
operator|->
name|alloc
operator|=
name|size
expr_stmt|;
name|set
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|elems
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|set
operator|->
name|elems
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_init_1
parameter_list|(
name|set
parameter_list|,
name|elem
parameter_list|)
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|elem
decl_stmt|;
block|{
name|set
operator|->
name|alloc
operator|=
literal|1
expr_stmt|;
name|set
operator|->
name|nelem
operator|=
literal|1
expr_stmt|;
name|set
operator|->
name|elems
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|set
operator|->
name|elems
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|set
operator|->
name|alloc
operator|=
name|set
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|set
operator|->
name|elems
index|[
literal|0
index|]
operator|=
name|elem
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_init_2
parameter_list|(
name|set
parameter_list|,
name|elem1
parameter_list|,
name|elem2
parameter_list|)
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|elem1
decl_stmt|,
name|elem2
decl_stmt|;
block|{
name|set
operator|->
name|alloc
operator|=
literal|2
expr_stmt|;
name|set
operator|->
name|elems
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|set
operator|->
name|elems
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
if|if
condition|(
name|elem1
operator|==
name|elem2
condition|)
block|{
name|set
operator|->
name|nelem
operator|=
literal|1
expr_stmt|;
name|set
operator|->
name|elems
index|[
literal|0
index|]
operator|=
name|elem1
expr_stmt|;
block|}
else|else
block|{
name|set
operator|->
name|nelem
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|elem1
operator|<
name|elem2
condition|)
block|{
name|set
operator|->
name|elems
index|[
literal|0
index|]
operator|=
name|elem1
expr_stmt|;
name|set
operator|->
name|elems
index|[
literal|1
index|]
operator|=
name|elem2
expr_stmt|;
block|}
else|else
block|{
name|set
operator|->
name|elems
index|[
literal|0
index|]
operator|=
name|elem2
expr_stmt|;
name|set
operator|->
name|elems
index|[
literal|1
index|]
operator|=
name|elem1
expr_stmt|;
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_init_copy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|re_node_set
modifier|*
name|dest
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|src
decl_stmt|;
block|{
name|dest
operator|->
name|nelem
operator|=
name|src
operator|->
name|nelem
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|nelem
operator|>
literal|0
condition|)
block|{
name|dest
operator|->
name|alloc
operator|=
name|dest
operator|->
name|nelem
expr_stmt|;
name|dest
operator|->
name|elems
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|dest
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dest
operator|->
name|elems
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|dest
operator|->
name|alloc
operator|=
name|dest
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
argument_list|,
name|src
operator|->
name|elems
argument_list|,
name|src
operator|->
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|re_node_set_init_empty
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Calculate the intersection of the sets SRC1 and SRC2. And merge it to    DEST. Return value indicate the error code or REG_NOERROR if succeeded.    Note: We assume dest->elems is NULL, when dest->alloc is 0.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_add_intersect
parameter_list|(
name|dest
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
name|re_node_set
modifier|*
name|dest
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|src1
decl_stmt|,
decl|*
name|src2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|is
decl_stmt|,
name|id
decl_stmt|,
name|delta
decl_stmt|,
name|sbase
decl_stmt|;
if|if
condition|(
name|src1
operator|->
name|nelem
operator|==
literal|0
operator|||
name|src2
operator|->
name|nelem
operator|==
literal|0
condition|)
return|return
name|REG_NOERROR
return|;
comment|/* We need dest->nelem + 2 * elems_in_intersection; this is a      conservative estimate.  */
if|if
condition|(
name|src1
operator|->
name|nelem
operator|+
name|src2
operator|->
name|nelem
operator|+
name|dest
operator|->
name|nelem
operator|>
name|dest
operator|->
name|alloc
condition|)
block|{
name|int
name|new_alloc
init|=
name|src1
operator|->
name|nelem
operator|+
name|src2
operator|->
name|nelem
operator|+
name|dest
operator|->
name|alloc
decl_stmt|;
name|int
modifier|*
name|new_elems
init|=
name|re_realloc
argument_list|(
name|dest
operator|->
name|elems
argument_list|,
name|int
argument_list|,
name|new_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_elems
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|dest
operator|->
name|elems
operator|=
name|new_elems
expr_stmt|;
name|dest
operator|->
name|alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
comment|/* Find the items in the intersection of SRC1 and SRC2, and copy      into the top of DEST those that are not already in DEST itself.  */
name|sbase
operator|=
name|dest
operator|->
name|nelem
operator|+
name|src1
operator|->
name|nelem
operator|+
name|src2
operator|->
name|nelem
expr_stmt|;
name|i1
operator|=
name|src1
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
name|i2
operator|=
name|src2
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
name|id
operator|=
name|dest
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|src1
operator|->
name|elems
index|[
name|i1
index|]
operator|==
name|src2
operator|->
name|elems
index|[
name|i2
index|]
condition|)
block|{
comment|/* Try to find the item in DEST.  Maybe we could binary search?  */
while|while
condition|(
name|id
operator|>=
literal|0
operator|&&
name|dest
operator|->
name|elems
index|[
name|id
index|]
operator|>
name|src1
operator|->
name|elems
index|[
name|i1
index|]
condition|)
operator|--
name|id
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|dest
operator|->
name|elems
index|[
name|id
index|]
operator|!=
name|src1
operator|->
name|elems
index|[
name|i1
index|]
condition|)
name|dest
operator|->
name|elems
index|[
operator|--
name|sbase
index|]
operator|=
name|src1
operator|->
name|elems
index|[
name|i1
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|i1
operator|<
literal|0
operator|||
operator|--
name|i2
operator|<
literal|0
condition|)
break|break;
block|}
comment|/* Lower the highest of the two items.  */
elseif|else
if|if
condition|(
name|src1
operator|->
name|elems
index|[
name|i1
index|]
operator|<
name|src2
operator|->
name|elems
index|[
name|i2
index|]
condition|)
block|{
if|if
condition|(
operator|--
name|i2
operator|<
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|--
name|i1
operator|<
literal|0
condition|)
break|break;
block|}
block|}
name|id
operator|=
name|dest
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
name|is
operator|=
name|dest
operator|->
name|nelem
operator|+
name|src1
operator|->
name|nelem
operator|+
name|src2
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
name|delta
operator|=
name|is
operator|-
name|sbase
operator|+
literal|1
expr_stmt|;
comment|/* Now copy.  When DELTA becomes zero, the remaining      DEST elements are already in place; this is more or      less the same loop that is in re_node_set_merge.  */
name|dest
operator|->
name|nelem
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|id
operator|>=
literal|0
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dest
operator|->
name|elems
index|[
name|is
index|]
operator|>
name|dest
operator|->
name|elems
index|[
name|id
index|]
condition|)
block|{
comment|/* Copy from the top.  */
name|dest
operator|->
name|elems
index|[
name|id
operator|+
name|delta
operator|--
index|]
operator|=
name|dest
operator|->
name|elems
index|[
name|is
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* Slide from the bottom.  */
name|dest
operator|->
name|elems
index|[
name|id
operator|+
name|delta
index|]
operator|=
name|dest
operator|->
name|elems
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|id
operator|<
literal|0
condition|)
break|break;
block|}
block|}
comment|/* Copy remaining SRC elements.  */
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
argument_list|,
name|dest
operator|->
name|elems
operator|+
name|sbase
argument_list|,
name|delta
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_comment
comment|/* Calculate the union set of the sets SRC1 and SRC2. And store it to    DEST. Return value indicate the error code or REG_NOERROR if succeeded.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_init_union
parameter_list|(
name|dest
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
name|re_node_set
modifier|*
name|dest
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|src1
decl_stmt|,
decl|*
name|src2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|id
decl_stmt|;
if|if
condition|(
name|src1
operator|!=
name|NULL
operator|&&
name|src1
operator|->
name|nelem
operator|>
literal|0
operator|&&
name|src2
operator|!=
name|NULL
operator|&&
name|src2
operator|->
name|nelem
operator|>
literal|0
condition|)
block|{
name|dest
operator|->
name|alloc
operator|=
name|src1
operator|->
name|nelem
operator|+
name|src2
operator|->
name|nelem
expr_stmt|;
name|dest
operator|->
name|elems
operator|=
name|re_malloc
argument_list|(
name|int
argument_list|,
name|dest
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dest
operator|->
name|elems
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
block|}
else|else
block|{
if|if
condition|(
name|src1
operator|!=
name|NULL
operator|&&
name|src1
operator|->
name|nelem
operator|>
literal|0
condition|)
return|return
name|re_node_set_init_copy
argument_list|(
name|dest
argument_list|,
name|src1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|src2
operator|!=
name|NULL
operator|&&
name|src2
operator|->
name|nelem
operator|>
literal|0
condition|)
return|return
name|re_node_set_init_copy
argument_list|(
name|dest
argument_list|,
name|src2
argument_list|)
return|;
else|else
name|re_node_set_init_empty
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
for|for
control|(
name|i1
operator|=
name|i2
operator|=
name|id
operator|=
literal|0
init|;
name|i1
operator|<
name|src1
operator|->
name|nelem
operator|&&
name|i2
operator|<
name|src2
operator|->
name|nelem
condition|;
control|)
block|{
if|if
condition|(
name|src1
operator|->
name|elems
index|[
name|i1
index|]
operator|>
name|src2
operator|->
name|elems
index|[
name|i2
index|]
condition|)
block|{
name|dest
operator|->
name|elems
index|[
name|id
operator|++
index|]
operator|=
name|src2
operator|->
name|elems
index|[
name|i2
operator|++
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|src1
operator|->
name|elems
index|[
name|i1
index|]
operator|==
name|src2
operator|->
name|elems
index|[
name|i2
index|]
condition|)
operator|++
name|i2
expr_stmt|;
name|dest
operator|->
name|elems
index|[
name|id
operator|++
index|]
operator|=
name|src1
operator|->
name|elems
index|[
name|i1
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i1
operator|<
name|src1
operator|->
name|nelem
condition|)
block|{
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
operator|+
name|id
argument_list|,
name|src1
operator|->
name|elems
operator|+
name|i1
argument_list|,
operator|(
name|src1
operator|->
name|nelem
operator|-
name|i1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|+=
name|src1
operator|->
name|nelem
operator|-
name|i1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i2
operator|<
name|src2
operator|->
name|nelem
condition|)
block|{
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
operator|+
name|id
argument_list|,
name|src2
operator|->
name|elems
operator|+
name|i2
argument_list|,
operator|(
name|src2
operator|->
name|nelem
operator|-
name|i2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|+=
name|src2
operator|->
name|nelem
operator|-
name|i2
expr_stmt|;
block|}
name|dest
operator|->
name|nelem
operator|=
name|id
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_comment
comment|/* Calculate the union set of the sets DEST and SRC. And store it to    DEST. Return value indicate the error code or REG_NOERROR if succeeded.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|re_node_set_merge
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|re_node_set
modifier|*
name|dest
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|is
decl_stmt|,
name|id
decl_stmt|,
name|sbase
decl_stmt|,
name|delta
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|src
operator|->
name|nelem
operator|==
literal|0
condition|)
return|return
name|REG_NOERROR
return|;
if|if
condition|(
name|dest
operator|->
name|alloc
operator|<
literal|2
operator|*
name|src
operator|->
name|nelem
operator|+
name|dest
operator|->
name|nelem
condition|)
block|{
name|int
name|new_alloc
init|=
literal|2
operator|*
operator|(
name|src
operator|->
name|nelem
operator|+
name|dest
operator|->
name|alloc
operator|)
decl_stmt|;
name|int
modifier|*
name|new_buffer
init|=
name|re_realloc
argument_list|(
name|dest
operator|->
name|elems
argument_list|,
name|int
argument_list|,
name|new_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_buffer
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|dest
operator|->
name|elems
operator|=
name|new_buffer
expr_stmt|;
name|dest
operator|->
name|alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|dest
operator|->
name|nelem
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|dest
operator|->
name|nelem
operator|=
name|src
operator|->
name|nelem
expr_stmt|;
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
argument_list|,
name|src
operator|->
name|elems
argument_list|,
name|src
operator|->
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
comment|/* Copy into the top of DEST the items of SRC that are not      found in DEST.  Maybe we could binary search in DEST?  */
for|for
control|(
name|sbase
operator|=
name|dest
operator|->
name|nelem
operator|+
literal|2
operator|*
name|src
operator|->
name|nelem
operator|,
name|is
operator|=
name|src
operator|->
name|nelem
operator|-
literal|1
operator|,
name|id
operator|=
name|dest
operator|->
name|nelem
operator|-
literal|1
init|;
name|is
operator|>=
literal|0
operator|&&
name|id
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|dest
operator|->
name|elems
index|[
name|id
index|]
operator|==
name|src
operator|->
name|elems
index|[
name|is
index|]
condition|)
name|is
operator|--
operator|,
name|id
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|dest
operator|->
name|elems
index|[
name|id
index|]
operator|<
name|src
operator|->
name|elems
index|[
name|is
index|]
condition|)
name|dest
operator|->
name|elems
index|[
operator|--
name|sbase
index|]
operator|=
name|src
operator|->
name|elems
index|[
name|is
operator|--
index|]
expr_stmt|;
else|else
comment|/* if (dest->elems[id]> src->elems[is]) */
operator|--
name|id
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|>=
literal|0
condition|)
block|{
comment|/* If DEST is exhausted, the remaining items of SRC must be unique.  */
name|sbase
operator|-=
name|is
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
operator|+
name|sbase
argument_list|,
name|src
operator|->
name|elems
argument_list|,
operator|(
name|is
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|dest
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
name|is
operator|=
name|dest
operator|->
name|nelem
operator|+
literal|2
operator|*
name|src
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
name|delta
operator|=
name|is
operator|-
name|sbase
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
return|return
name|REG_NOERROR
return|;
comment|/* Now copy.  When DELTA becomes zero, the remaining      DEST elements are already in place.  */
name|dest
operator|->
name|nelem
operator|+=
name|delta
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dest
operator|->
name|elems
index|[
name|is
index|]
operator|>
name|dest
operator|->
name|elems
index|[
name|id
index|]
condition|)
block|{
comment|/* Copy from the top.  */
name|dest
operator|->
name|elems
index|[
name|id
operator|+
name|delta
operator|--
index|]
operator|=
name|dest
operator|->
name|elems
index|[
name|is
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* Slide from the bottom.  */
name|dest
operator|->
name|elems
index|[
name|id
operator|+
name|delta
index|]
operator|=
name|dest
operator|->
name|elems
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|id
operator|<
literal|0
condition|)
block|{
comment|/* Copy remaining SRC elements.  */
name|memcpy
argument_list|(
name|dest
operator|->
name|elems
argument_list|,
name|dest
operator|->
name|elems
operator|+
name|sbase
argument_list|,
name|delta
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Insert the new element ELEM to the re_node_set* SET.    SET should not already have ELEM.    return -1 if an error is occured, return 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|re_node_set_insert
parameter_list|(
name|set
parameter_list|,
name|elem
parameter_list|)
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|elem
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
comment|/* In case the set is empty.  */
if|if
condition|(
name|set
operator|->
name|alloc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|BE
argument_list|(
name|re_node_set_init_1
argument_list|(
name|set
argument_list|,
name|elem
argument_list|)
operator|==
name|REG_NOERROR
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|BE
argument_list|(
name|set
operator|->
name|nelem
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We already guaranteed above that set->alloc != 0.  */
name|set
operator|->
name|elems
index|[
literal|0
index|]
operator|=
name|elem
expr_stmt|;
operator|++
name|set
operator|->
name|nelem
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Realloc if we need.  */
if|if
condition|(
name|set
operator|->
name|alloc
operator|==
name|set
operator|->
name|nelem
condition|)
block|{
name|int
modifier|*
name|new_array
decl_stmt|;
name|set
operator|->
name|alloc
operator|=
name|set
operator|->
name|alloc
operator|*
literal|2
expr_stmt|;
name|new_array
operator|=
name|re_realloc
argument_list|(
name|set
operator|->
name|elems
argument_list|,
name|int
argument_list|,
name|set
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|set
operator|->
name|elems
operator|=
name|new_array
expr_stmt|;
block|}
comment|/* Move the elements which follows the new element.  Test the      first element separately to skip a check in the inner loop.  */
if|if
condition|(
name|elem
operator|<
name|set
operator|->
name|elems
index|[
literal|0
index|]
condition|)
block|{
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|set
operator|->
name|nelem
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
name|set
operator|->
name|elems
index|[
name|idx
index|]
operator|=
name|set
operator|->
name|elems
index|[
name|idx
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|idx
operator|=
name|set
operator|->
name|nelem
init|;
name|set
operator|->
name|elems
index|[
name|idx
operator|-
literal|1
index|]
operator|>
name|elem
condition|;
name|idx
operator|--
control|)
name|set
operator|->
name|elems
index|[
name|idx
index|]
operator|=
name|set
operator|->
name|elems
index|[
name|idx
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* Insert the new element.  */
name|set
operator|->
name|elems
index|[
name|idx
index|]
operator|=
name|elem
expr_stmt|;
operator|++
name|set
operator|->
name|nelem
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert the new element ELEM to the re_node_set* SET.    SET should not already have any element greater than or equal to ELEM.    Return -1 if an error is occured, return 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|re_node_set_insert_last
parameter_list|(
name|set
parameter_list|,
name|elem
parameter_list|)
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|elem
decl_stmt|;
block|{
comment|/* Realloc if we need.  */
if|if
condition|(
name|set
operator|->
name|alloc
operator|==
name|set
operator|->
name|nelem
condition|)
block|{
name|int
modifier|*
name|new_array
decl_stmt|;
name|set
operator|->
name|alloc
operator|=
operator|(
name|set
operator|->
name|alloc
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|new_array
operator|=
name|re_realloc
argument_list|(
name|set
operator|->
name|elems
argument_list|,
name|int
argument_list|,
name|set
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|set
operator|->
name|elems
operator|=
name|new_array
expr_stmt|;
block|}
comment|/* Insert the new element.  */
name|set
operator|->
name|elems
index|[
name|set
operator|->
name|nelem
operator|++
index|]
operator|=
name|elem
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare two node sets SET1 and SET2.    return 1 if SET1 and SET2 are equivalent, return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|re_node_set_compare
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|)
specifier|const
name|re_node_set
modifier|*
name|set1
decl_stmt|,
decl|*
name|set2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|set1
operator|==
name|NULL
operator|||
name|set2
operator|==
name|NULL
operator|||
name|set1
operator|->
name|nelem
operator|!=
name|set2
operator|->
name|nelem
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|set1
operator|->
name|nelem
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|set1
operator|->
name|elems
index|[
name|i
index|]
operator|!=
name|set2
operator|->
name|elems
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Return (idx + 1) if SET contains the element ELEM, return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|re_node_set_contains
parameter_list|(
name|set
parameter_list|,
name|elem
parameter_list|)
specifier|const
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|elem
decl_stmt|;
block|{
name|unsigned
name|int
name|idx
decl_stmt|,
name|right
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
name|set
operator|->
name|nelem
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Binary search the element.  */
name|idx
operator|=
literal|0
expr_stmt|;
name|right
operator|=
name|set
operator|->
name|nelem
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|right
condition|)
block|{
name|mid
operator|=
operator|(
name|idx
operator|+
name|right
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|elems
index|[
name|mid
index|]
operator|<
name|elem
condition|)
name|idx
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|right
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|set
operator|->
name|elems
index|[
name|idx
index|]
operator|==
name|elem
condition|?
name|idx
operator|+
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|re_node_set_remove_at
parameter_list|(
name|set
parameter_list|,
name|idx
parameter_list|)
name|re_node_set
modifier|*
name|set
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|set
operator|->
name|nelem
condition|)
return|return;
operator|--
name|set
operator|->
name|nelem
expr_stmt|;
for|for
control|(
init|;
name|idx
operator|<
name|set
operator|->
name|nelem
condition|;
name|idx
operator|++
control|)
name|set
operator|->
name|elems
index|[
name|idx
index|]
operator|=
name|set
operator|->
name|elems
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add the token TOKEN to dfa->nodes, and return the index of the token.    Or return -1, if an error will be occured.  */
end_comment

begin_function
specifier|static
name|int
name|re_dfa_add_node
parameter_list|(
name|dfa
parameter_list|,
name|token
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_token_t
name|token
decl_stmt|;
block|{
name|int
name|type
init|=
name|token
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|dfa
operator|->
name|nodes_len
operator|>=
name|dfa
operator|->
name|nodes_alloc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|new_nodes_alloc
init|=
name|dfa
operator|->
name|nodes_alloc
operator|*
literal|2
decl_stmt|;
name|int
modifier|*
name|new_nexts
decl_stmt|,
modifier|*
name|new_indices
decl_stmt|;
name|re_node_set
modifier|*
name|new_edests
decl_stmt|,
modifier|*
name|new_eclosures
decl_stmt|;
name|re_token_t
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|dfa
operator|->
name|nodes
argument_list|,
name|re_token_t
argument_list|,
name|new_nodes_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|dfa
operator|->
name|nodes
operator|=
name|new_array
expr_stmt|;
name|new_nexts
operator|=
name|re_realloc
argument_list|(
name|dfa
operator|->
name|nexts
argument_list|,
name|int
argument_list|,
name|new_nodes_alloc
argument_list|)
expr_stmt|;
name|new_indices
operator|=
name|re_realloc
argument_list|(
name|dfa
operator|->
name|org_indices
argument_list|,
name|int
argument_list|,
name|new_nodes_alloc
argument_list|)
expr_stmt|;
name|new_edests
operator|=
name|re_realloc
argument_list|(
name|dfa
operator|->
name|edests
argument_list|,
name|re_node_set
argument_list|,
name|new_nodes_alloc
argument_list|)
expr_stmt|;
name|new_eclosures
operator|=
name|re_realloc
argument_list|(
name|dfa
operator|->
name|eclosures
argument_list|,
name|re_node_set
argument_list|,
name|new_nodes_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_nexts
operator|==
name|NULL
operator|||
name|new_indices
operator|==
name|NULL
operator|||
name|new_edests
operator|==
name|NULL
operator|||
name|new_eclosures
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|dfa
operator|->
name|nexts
operator|=
name|new_nexts
expr_stmt|;
name|dfa
operator|->
name|org_indices
operator|=
name|new_indices
expr_stmt|;
name|dfa
operator|->
name|edests
operator|=
name|new_edests
expr_stmt|;
name|dfa
operator|->
name|eclosures
operator|=
name|new_eclosures
expr_stmt|;
name|dfa
operator|->
name|nodes_alloc
operator|=
name|new_nodes_alloc
expr_stmt|;
block|}
name|dfa
operator|->
name|nodes
index|[
name|dfa
operator|->
name|nodes_len
index|]
operator|=
name|token
expr_stmt|;
name|dfa
operator|->
name|nodes
index|[
name|dfa
operator|->
name|nodes_len
index|]
operator|.
name|constraint
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|dfa
operator|->
name|nodes
index|[
name|dfa
operator|->
name|nodes_len
index|]
operator|.
name|accept_mb
operator|=
operator|(
name|type
operator|==
name|OP_PERIOD
operator|&&
name|dfa
operator|->
name|mb_cur_max
operator|>
literal|1
operator|)
operator|||
name|type
operator|==
name|COMPLEX_BRACKET
expr_stmt|;
endif|#
directive|endif
name|dfa
operator|->
name|nexts
index|[
name|dfa
operator|->
name|nodes_len
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|re_node_set_init_empty
argument_list|(
name|dfa
operator|->
name|edests
operator|+
name|dfa
operator|->
name|nodes_len
argument_list|)
expr_stmt|;
name|re_node_set_init_empty
argument_list|(
name|dfa
operator|->
name|eclosures
operator|+
name|dfa
operator|->
name|nodes_len
argument_list|)
expr_stmt|;
return|return
name|dfa
operator|->
name|nodes_len
operator|++
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
specifier|inline
name|calc_state_hash
parameter_list|(
name|nodes
parameter_list|,
name|context
parameter_list|)
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
init|=
name|nodes
operator|->
name|nelem
operator|+
name|context
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|->
name|nelem
condition|;
name|i
operator|++
control|)
name|hash
operator|+=
name|nodes
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Search for the state whose node_set is equivalent to NODES.    Return the pointer to the state, if we found it in the DFA.    Otherwise create the new one and return it.  In case of an error    return NULL and set the error code in ERR.    Note: - We assume NULL as the invalid state, then it is possible that 	   return value is NULL and ERR is REG_NOERROR. 	 - We never return non-NULL value in case of any errors, it is for 	   optimization.  */
end_comment

begin_function
specifier|static
name|re_dfastate_t
modifier|*
name|re_acquire_state
parameter_list|(
name|err
parameter_list|,
name|dfa
parameter_list|,
name|nodes
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|re_dfastate_t
modifier|*
name|new_state
decl_stmt|;
name|struct
name|re_state_table_entry
modifier|*
name|spot
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|nodes
operator|->
name|nelem
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|err
operator|=
name|REG_NOERROR
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hash
operator|=
name|calc_state_hash
argument_list|(
name|nodes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spot
operator|=
name|dfa
operator|->
name|state_table
operator|+
operator|(
name|hash
operator|&
name|dfa
operator|->
name|state_hash_mask
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spot
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|re_dfastate_t
modifier|*
name|state
init|=
name|spot
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hash
operator|!=
name|state
operator|->
name|hash
condition|)
continue|continue;
if|if
condition|(
name|re_node_set_compare
argument_list|(
operator|&
name|state
operator|->
name|nodes
argument_list|,
name|nodes
argument_list|)
condition|)
return|return
name|state
return|;
block|}
comment|/* There are no appropriate state in the dfa, create the new one.  */
name|new_state
operator|=
name|create_ci_newstate
argument_list|(
name|dfa
argument_list|,
name|nodes
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_state
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|new_state
return|;
else|else
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Search for the state whose node_set is equivalent to NODES and    whose context is equivalent to CONTEXT.    Return the pointer to the state, if we found it in the DFA.    Otherwise create the new one and return it.  In case of an error    return NULL and set the error code in ERR.    Note: - We assume NULL as the invalid state, then it is possible that 	   return value is NULL and ERR is REG_NOERROR. 	 - We never return non-NULL value in case of any errors, it is for 	   optimization.  */
end_comment

begin_function
specifier|static
name|re_dfastate_t
modifier|*
name|re_acquire_state_context
parameter_list|(
name|err
parameter_list|,
name|dfa
parameter_list|,
name|nodes
parameter_list|,
name|context
parameter_list|)
name|reg_errcode_t
modifier|*
name|err
decl_stmt|;
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|re_dfastate_t
modifier|*
name|new_state
decl_stmt|;
name|struct
name|re_state_table_entry
modifier|*
name|spot
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nodes
operator|->
name|nelem
operator|==
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|REG_NOERROR
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hash
operator|=
name|calc_state_hash
argument_list|(
name|nodes
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|spot
operator|=
name|dfa
operator|->
name|state_table
operator|+
operator|(
name|hash
operator|&
name|dfa
operator|->
name|state_hash_mask
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spot
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|re_dfastate_t
modifier|*
name|state
init|=
name|spot
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|hash
operator|==
name|hash
operator|&&
name|state
operator|->
name|context
operator|==
name|context
operator|&&
name|re_node_set_compare
argument_list|(
name|state
operator|->
name|entrance_nodes
argument_list|,
name|nodes
argument_list|)
condition|)
return|return
name|state
return|;
block|}
comment|/* There are no appropriate state in `dfa', create the new one.  */
name|new_state
operator|=
name|create_cd_newstate
argument_list|(
name|dfa
argument_list|,
name|nodes
argument_list|,
name|context
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_state
operator|!=
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|new_state
return|;
else|else
block|{
operator|*
name|err
operator|=
name|REG_ESPACE
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish initialization of the new state NEWSTATE, and using its hash value    HASH put in the appropriate bucket of DFA's state table.  Return value    indicates the error code if failed.  */
end_comment

begin_function
specifier|static
name|reg_errcode_t
name|register_state
parameter_list|(
name|dfa
parameter_list|,
name|newstate
parameter_list|,
name|hash
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
name|re_dfastate_t
modifier|*
name|newstate
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
block|{
name|struct
name|re_state_table_entry
modifier|*
name|spot
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|newstate
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|err
operator|=
name|re_node_set_alloc
argument_list|(
operator|&
name|newstate
operator|->
name|non_eps_nodes
argument_list|,
name|newstate
operator|->
name|nodes
operator|.
name|nelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newstate
operator|->
name|nodes
operator|.
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|int
name|elem
init|=
name|newstate
operator|->
name|nodes
operator|.
name|elems
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IS_EPSILON_NODE
argument_list|(
name|dfa
operator|->
name|nodes
index|[
name|elem
index|]
operator|.
name|type
argument_list|)
condition|)
name|re_node_set_insert_last
argument_list|(
operator|&
name|newstate
operator|->
name|non_eps_nodes
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
name|spot
operator|=
name|dfa
operator|->
name|state_table
operator|+
operator|(
name|hash
operator|&
name|dfa
operator|->
name|state_hash_mask
operator|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|spot
operator|->
name|alloc
operator|<=
name|spot
operator|->
name|num
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|new_alloc
init|=
literal|2
operator|*
name|spot
operator|->
name|num
operator|+
literal|2
decl_stmt|;
name|re_dfastate_t
modifier|*
modifier|*
name|new_array
init|=
name|re_realloc
argument_list|(
name|spot
operator|->
name|array
argument_list|,
name|re_dfastate_t
operator|*
argument_list|,
name|new_alloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|new_array
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|spot
operator|->
name|array
operator|=
name|new_array
expr_stmt|;
name|spot
operator|->
name|alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
name|spot
operator|->
name|array
index|[
name|spot
operator|->
name|num
operator|++
index|]
operator|=
name|newstate
expr_stmt|;
return|return
name|REG_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Create the new state which is independ of contexts.    Return the new state if succeeded, otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|re_dfastate_t
modifier|*
name|create_ci_newstate
parameter_list|(
name|dfa
parameter_list|,
name|nodes
parameter_list|,
name|hash
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|re_dfastate_t
modifier|*
name|newstate
decl_stmt|;
name|newstate
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_dfastate_t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|newstate
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|newstate
operator|->
name|nodes
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_free
argument_list|(
name|newstate
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newstate
operator|->
name|entrance_nodes
operator|=
operator|&
name|newstate
operator|->
name|nodes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|->
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|re_token_t
modifier|*
name|node
init|=
name|dfa
operator|->
name|nodes
operator|+
name|nodes
operator|->
name|elems
index|[
name|i
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|node
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|CHARACTER
operator|&&
operator|!
name|node
operator|->
name|constraint
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|newstate
operator|->
name|accept_mb
operator||=
name|node
operator|->
name|accept_mb
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
comment|/* If the state has the halt node, the state is a halt state.  */
if|if
condition|(
name|type
operator|==
name|END_OF_RE
condition|)
name|newstate
operator|->
name|halt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_BACK_REF
condition|)
name|newstate
operator|->
name|has_backref
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ANCHOR
operator|||
name|node
operator|->
name|constraint
condition|)
name|newstate
operator|->
name|has_constraint
operator|=
literal|1
expr_stmt|;
block|}
name|err
operator|=
name|register_state
argument_list|(
name|dfa
argument_list|,
name|newstate
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free_state
argument_list|(
name|newstate
argument_list|)
expr_stmt|;
name|newstate
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|newstate
return|;
block|}
end_function

begin_comment
comment|/* Create the new state which is depend on the context CONTEXT.    Return the new state if succeeded, otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|re_dfastate_t
modifier|*
name|create_cd_newstate
parameter_list|(
name|dfa
parameter_list|,
name|nodes
parameter_list|,
name|context
parameter_list|,
name|hash
parameter_list|)
name|re_dfa_t
modifier|*
name|dfa
decl_stmt|;
specifier|const
name|re_node_set
modifier|*
name|nodes
decl_stmt|;
name|unsigned
name|int
name|context
decl_stmt|,
name|hash
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nctx_nodes
init|=
literal|0
decl_stmt|;
name|reg_errcode_t
name|err
decl_stmt|;
name|re_dfastate_t
modifier|*
name|newstate
decl_stmt|;
name|newstate
operator|=
operator|(
name|re_dfastate_t
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|re_dfastate_t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|newstate
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|err
operator|=
name|re_node_set_init_copy
argument_list|(
operator|&
name|newstate
operator|->
name|nodes
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|re_free
argument_list|(
name|newstate
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newstate
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|newstate
operator|->
name|entrance_nodes
operator|=
operator|&
name|newstate
operator|->
name|nodes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|->
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|constraint
init|=
literal|0
decl_stmt|;
name|re_token_t
modifier|*
name|node
init|=
name|dfa
operator|->
name|nodes
operator|+
name|nodes
operator|->
name|elems
index|[
name|i
index|]
decl_stmt|;
name|re_token_type_t
name|type
init|=
name|node
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|constraint
condition|)
name|constraint
operator|=
name|node
operator|->
name|constraint
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CHARACTER
operator|&&
operator|!
name|constraint
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|RE_ENABLE_I18N
name|newstate
operator|->
name|accept_mb
operator||=
name|node
operator|->
name|accept_mb
expr_stmt|;
endif|#
directive|endif
comment|/* RE_ENABLE_I18N */
comment|/* If the state has the halt node, the state is a halt state.  */
if|if
condition|(
name|type
operator|==
name|END_OF_RE
condition|)
name|newstate
operator|->
name|halt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_BACK_REF
condition|)
name|newstate
operator|->
name|has_backref
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ANCHOR
condition|)
name|constraint
operator|=
name|node
operator|->
name|opr
operator|.
name|ctx_type
expr_stmt|;
if|if
condition|(
name|constraint
condition|)
block|{
if|if
condition|(
name|newstate
operator|->
name|entrance_nodes
operator|==
operator|&
name|newstate
operator|->
name|nodes
condition|)
block|{
name|newstate
operator|->
name|entrance_nodes
operator|=
name|re_malloc
argument_list|(
name|re_node_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|newstate
operator|->
name|entrance_nodes
operator|==
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free_state
argument_list|(
name|newstate
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|re_node_set_init_copy
argument_list|(
name|newstate
operator|->
name|entrance_nodes
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
name|nctx_nodes
operator|=
literal|0
expr_stmt|;
name|newstate
operator|->
name|has_constraint
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|NOT_SATISFY_PREV_CONSTRAINT
argument_list|(
name|constraint
argument_list|,
name|context
argument_list|)
condition|)
block|{
name|re_node_set_remove_at
argument_list|(
operator|&
name|newstate
operator|->
name|nodes
argument_list|,
name|i
operator|-
name|nctx_nodes
argument_list|)
expr_stmt|;
operator|++
name|nctx_nodes
expr_stmt|;
block|}
block|}
block|}
name|err
operator|=
name|register_state
argument_list|(
name|dfa
argument_list|,
name|newstate
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|BE
argument_list|(
name|err
operator|!=
name|REG_NOERROR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free_state
argument_list|(
name|newstate
argument_list|)
expr_stmt|;
name|newstate
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|newstate
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_state
parameter_list|(
name|state
parameter_list|)
name|re_dfastate_t
modifier|*
name|state
decl_stmt|;
block|{
name|re_node_set_free
argument_list|(
operator|&
name|state
operator|->
name|non_eps_nodes
argument_list|)
expr_stmt|;
name|re_node_set_free
argument_list|(
operator|&
name|state
operator|->
name|inveclosure
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|entrance_nodes
operator|!=
operator|&
name|state
operator|->
name|nodes
condition|)
block|{
name|re_node_set_free
argument_list|(
name|state
operator|->
name|entrance_nodes
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|state
operator|->
name|entrance_nodes
argument_list|)
expr_stmt|;
block|}
name|re_node_set_free
argument_list|(
operator|&
name|state
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|state
operator|->
name|word_trtable
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|state
operator|->
name|trtable
argument_list|)
expr_stmt|;
name|re_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

