begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* test.c: testing routines for regex.c.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Just to be complete, we make both the system V/ANSI and the BSD    versions of the string functions available.  */
end_comment

begin_if
if|#
directive|if
name|USG
operator|||
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
value|memcmp ((s1), (s2), (len))
end_define

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|len
parameter_list|)
value|memcpy ((to), (from), (len))
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
value|memset ((s), 0, (len))
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_define
define|#
directive|define
name|strrchr
value|rindex
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NEED_MEMORY_H
end_ifndef

begin_define
define|#
directive|define
name|memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|bcmp ((s1), (s2), (n))
end_define

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|)
value|bcopy ((from), (to), (len))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strstr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG or STDC_HEADERS */
end_comment

begin_comment
comment|/* SunOS 4.1 declares memchr in<memory.h>, not<string.h>.  I don't    understand why.  */
end_comment

begin_if
if|#
directive|if
name|NEED_MEMORY_H
end_if

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_define
define|#
directive|define
name|BYTEWIDTH
value|8
end_define

begin_function_decl
specifier|extern
name|void
name|print_partial_compiled_pattern
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_compiled_pattern
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_double_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* If nonzero, the results of every test are displayed.  */
end_comment

begin_decl_stmt
name|boolean
name|verbose
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, don't do register testing.  */
end_comment

begin_decl_stmt
name|boolean
name|omit_register_tests
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Says whether the current test should match or fail to match.  */
end_comment

begin_decl_stmt
name|boolean
name|test_should_match
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_all_registers
parameter_list|(
name|start0
parameter_list|,
name|end0
parameter_list|,
name|start1
parameter_list|,
name|end1
parameter_list|,
name|start2
parameter_list|,
name|end2
parameter_list|,
name|start3
parameter_list|,
name|end3
parameter_list|,
name|start4
parameter_list|,
name|end4
parameter_list|,
name|start5
parameter_list|,
name|end5
parameter_list|,
name|start6
parameter_list|,
name|end6
parameter_list|,
name|start7
parameter_list|,
name|end7
parameter_list|,
name|start8
parameter_list|,
name|end8
parameter_list|,
name|start9
parameter_list|,
name|end9
parameter_list|,
name|regs
parameter_list|)
name|int
name|start0
decl_stmt|;
name|int
name|end0
decl_stmt|;
name|int
name|start1
decl_stmt|;
name|int
name|end1
decl_stmt|;
name|int
name|start2
decl_stmt|;
name|int
name|end2
decl_stmt|;
name|int
name|start3
decl_stmt|;
name|int
name|end3
decl_stmt|;
name|int
name|start4
decl_stmt|;
name|int
name|end4
decl_stmt|;
name|int
name|start5
decl_stmt|;
name|int
name|end5
decl_stmt|;
name|int
name|start6
decl_stmt|;
name|int
name|end6
decl_stmt|;
name|int
name|start7
decl_stmt|;
name|int
name|end7
decl_stmt|;
name|int
name|start8
decl_stmt|;
name|int
name|end8
decl_stmt|;
name|int
name|start9
decl_stmt|;
name|int
name|end9
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
name|unsigned
name|r
decl_stmt|;
name|regs
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|start0
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|end0
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|1
index|]
operator|=
name|start1
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|1
index|]
operator|=
name|end1
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|2
index|]
operator|=
name|start2
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|2
index|]
operator|=
name|end2
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|3
index|]
operator|=
name|start3
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|3
index|]
operator|=
name|end3
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|4
index|]
operator|=
name|start4
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|4
index|]
operator|=
name|end4
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|5
index|]
operator|=
name|start5
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|5
index|]
operator|=
name|end5
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|6
index|]
operator|=
name|start6
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|6
index|]
operator|=
name|end6
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|7
index|]
operator|=
name|start7
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|7
index|]
operator|=
name|end7
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|8
index|]
operator|=
name|start8
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|8
index|]
operator|=
name|end8
expr_stmt|;
name|regs
operator|->
name|start
index|[
literal|9
index|]
operator|=
name|start9
expr_stmt|;
name|regs
operator|->
name|end
index|[
literal|9
index|]
operator|=
name|end9
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|10
init|;
name|r
operator|<
name|regs
operator|->
name|num_regs
condition|;
name|r
operator|++
control|)
block|{
name|regs
operator|->
name|start
index|[
name|r
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|end
index|[
name|r
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the concatenation of S1 and S2.  This would be a prime place    to use varargs.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
block|{
name|char
modifier|*
name|answer
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|answer
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|answer
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OK_TO_SEARCH
value|(nonconst_buf.fastmap_accurate&& (str1 || str2))
end_define

begin_comment
comment|/* We ignore the `can_be_null' argument.  Should just be removed.  */
end_comment

begin_function
name|void
name|general_test
parameter_list|(
name|pattern_should_be_valid
parameter_list|,
name|match_whole_string
parameter_list|,
name|pat
parameter_list|,
name|str1
parameter_list|,
name|str2
parameter_list|,
name|start
parameter_list|,
name|range
parameter_list|,
name|end
parameter_list|,
name|correct_fastmap
parameter_list|,
name|correct_regs
parameter_list|,
name|can_be_null
parameter_list|)
name|unsigned
name|pattern_should_be_valid
decl_stmt|;
name|unsigned
name|match_whole_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|str1
decl_stmt|,
decl|*
name|str2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|range
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|correct_fastmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|correct_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|can_be_null
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|re_pattern_buffer
name|nonconst_buf
decl_stmt|;
name|struct
name|re_pattern_buffer
name|old_buf
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
name|char
name|fastmap
index|[
literal|1
operator|<<
name|BYTEWIDTH
index|]
decl_stmt|;
name|unsigned
modifier|*
name|regs_correct
init|=
name|NULL
decl_stmt|;
name|unsigned
name|all_regs_correct
init|=
literal|1
decl_stmt|;
name|boolean
name|fastmap_internal_error
init|=
name|false
decl_stmt|;
name|unsigned
name|match
init|=
literal|0
decl_stmt|;
name|unsigned
name|match_1
init|=
literal|0
decl_stmt|;
name|unsigned
name|match_2
init|=
literal|0
decl_stmt|;
name|unsigned
name|invalid_pattern
init|=
literal|0
decl_stmt|;
name|boolean
name|internal_error_1
init|=
name|false
decl_stmt|;
name|boolean
name|internal_error_2
init|=
name|false
decl_stmt|;
name|nonconst_buf
operator|.
name|allocated
operator|=
literal|8
expr_stmt|;
name|nonconst_buf
operator|.
name|buffer
operator|=
name|xmalloc
argument_list|(
name|nonconst_buf
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|nonconst_buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|nonconst_buf
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|pat
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|=
name|re_compile_pattern
argument_list|(
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
comment|/* Kludge: if we are doing POSIX testing, we really should have      called regcomp, not re_compile_pattern.  As it happens, the only      way in which it matters is that re_compile_pattern sets the      newline/anchor field for matching (part of what happens when      REG_NEWLINE is given to regcomp).  We have to undo that for POSIX      matching.  */
if|if
condition|(
name|t
operator|==
name|posix_basic_test
operator|||
name|t
operator|==
name|posix_extended_test
condition|)
name|nonconst_buf
operator|.
name|newline_anchor
operator|=
literal|0
expr_stmt|;
name|invalid_pattern
operator|=
name|r
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|pattern_should_be_valid
condition|)
name|printf
argument_list|(
literal|"\nShould have been an invalid pattern but wasn't:\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fastmap_internal_error
operator|=
operator|(
name|re_compile_fastmap
argument_list|(
operator|&
name|nonconst_buf
argument_list|)
operator|==
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|correct_fastmap
condition|)
name|nonconst_buf
operator|.
name|fastmap_accurate
operator|=
name|memcmp
argument_list|(
name|nonconst_buf
operator|.
name|fastmap
argument_list|,
name|correct_fastmap
argument_list|,
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|OK_TO_SEARCH
condition|)
block|{
name|old_buf
operator|=
name|nonconst_buf
expr_stmt|;
name|old_buf
operator|.
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nonconst_buf
operator|.
name|used
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|old_buf
operator|.
name|buffer
argument_list|,
name|nonconst_buf
operator|.
name|buffer
argument_list|,
name|nonconst_buf
operator|.
name|used
argument_list|)
expr_stmt|;
comment|/* If only one string is null, call re_match or re_search,                 which is what the user would probably do.  */
if|if
condition|(
name|str1
operator|==
name|NULL
operator|&&
name|str2
operator|!=
name|NULL
operator|||
name|str2
operator|==
name|NULL
operator|&&
name|str1
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|the_str
init|=
name|str1
operator|==
name|NULL
condition|?
name|str2
else|:
name|str1
decl_stmt|;
name|match_1
operator|=
name|match_whole_string
condition|?
operator|(
name|r
operator|=
name|re_match
argument_list|(
operator|&
name|nonconst_buf
argument_list|,
name|the_str
argument_list|,
name|strlen
argument_list|(
name|the_str
argument_list|)
argument_list|,
name|start
argument_list|,
operator|&
name|regs
argument_list|)
operator|)
operator|==
name|strlen
argument_list|(
name|the_str
argument_list|)
else|:
operator|(
name|r
operator|=
name|re_search
argument_list|(
operator|&
name|nonconst_buf
argument_list|,
name|the_str
argument_list|,
name|strlen
argument_list|(
name|the_str
argument_list|)
argument_list|,
name|start
argument_list|,
name|range
argument_list|,
operator|&
name|regs
argument_list|)
operator|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|2
condition|)
name|internal_error_1
operator|=
name|true
expr_stmt|;
block|}
else|else
name|match_1
operator|=
literal|1
expr_stmt|;
comment|/* Also call with re_match_2 or re_search_2, as they might                  do this.  (Also can check calling with either string1                  or string2 or both null.)  */
if|if
condition|(
name|match_whole_string
condition|)
block|{
name|r
operator|=
name|re_match_2
argument_list|(
operator|&
name|nonconst_buf
argument_list|,
name|str1
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str1
argument_list|)
argument_list|,
name|str2
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str2
argument_list|)
argument_list|,
name|start
argument_list|,
operator|&
name|regs
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|match_2
operator|=
name|r
operator|==
name|SAFE_STRLEN
argument_list|(
name|str1
argument_list|)
operator|+
name|SAFE_STRLEN
argument_list|(
name|str2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|re_search_2
argument_list|(
operator|&
name|nonconst_buf
argument_list|,
name|str1
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str1
argument_list|)
argument_list|,
name|str2
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str2
argument_list|)
argument_list|,
name|start
argument_list|,
name|range
argument_list|,
operator|&
name|regs
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|match_2
operator|=
name|r
operator|>=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
operator|-
literal|2
condition|)
name|internal_error_2
operator|=
name|true
expr_stmt|;
name|match
operator|=
name|match_1
operator|&
name|match_2
expr_stmt|;
if|if
condition|(
name|correct_regs
condition|)
block|{
name|unsigned
name|reg
decl_stmt|;
if|if
condition|(
name|regs_correct
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|regs_correct
argument_list|)
expr_stmt|;
name|regs_correct
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|xmalloc
argument_list|(
name|regs
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|regs
operator|.
name|num_regs
operator|&&
name|reg
operator|<
name|correct_regs
operator|->
name|num_regs
condition|;
name|reg
operator|++
control|)
block|{
name|regs_correct
index|[
name|reg
index|]
operator|=
operator|(
name|regs
operator|.
name|start
index|[
name|reg
index|]
operator|==
name|correct_regs
operator|->
name|start
index|[
name|reg
index|]
operator|&&
name|regs
operator|.
name|end
index|[
name|reg
index|]
operator|==
name|correct_regs
operator|->
name|end
index|[
name|reg
index|]
operator|)
ifdef|#
directive|ifdef
name|EMPTY_REGS_CONFUSED
comment|/* There is confusion in the standard about                              the registers in some patterns which can                              match either the empty string or not match.                              For example, in `((a*))*' against the empty                              string, the two registers can either match                              the empty string (be 0/0), or not match                              (because of the outer *) (be -1/-1).  (Or                              one can do one and one can do the other.)  */
operator|||
operator|(
name|regs
operator|.
name|start
index|[
name|reg
index|]
operator|==
operator|-
literal|1
operator|&&
name|regs
operator|.
name|end
index|[
name|reg
index|]
operator|==
operator|-
literal|1
operator|&&
name|correct_regs
operator|->
name|start
index|[
name|reg
index|]
operator|==
name|correct_regs
operator|->
name|end
index|[
name|reg
index|]
operator|)
endif|#
directive|endif
expr_stmt|;
name|all_regs_correct
operator|&=
name|regs_correct
index|[
name|reg
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* OK_TO_SEARCH  */
block|}
block|}
if|if
condition|(
name|fastmap_internal_error
condition|)
name|printf
argument_list|(
literal|"\n\nInternal error in re_compile_fastmap:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_error_1
condition|)
block|{
if|if
condition|(
operator|!
name|fastmap_internal_error
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nInternal error in re_match or re_search:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|internal_error_2
condition|)
block|{
if|if
condition|(
operator|!
name|internal_error_1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nInternal error in re_match_2 or re_search_2:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|OK_TO_SEARCH
operator|&&
operator|(
operator|(
name|match
operator|&&
operator|!
name|test_should_match
operator|)
operator|||
operator|(
operator|!
name|match
operator|&&
name|test_should_match
operator|)
operator|)
operator|||
operator|(
name|correct_regs
operator|&&
operator|!
name|all_regs_correct
operator|)
operator|)
operator|||
operator|!
name|nonconst_buf
operator|.
name|fastmap_accurate
operator|||
name|invalid_pattern
operator|||
operator|!
name|pattern_should_be_valid
operator|||
name|internal_error_1
operator|||
name|internal_error_2
operator|||
name|verbose
condition|)
block|{
if|if
condition|(
name|OK_TO_SEARCH
operator|&&
name|match
operator|&&
operator|!
name|test_should_match
condition|)
block|{
name|printf
argument_list|(
literal|"\n\nMatched but shouldn't have:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_1
condition|)
name|printf
argument_list|(
literal|"The single match/search succeeded.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_2
condition|)
name|printf
argument_list|(
literal|"The double match/search succeeded.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OK_TO_SEARCH
operator|&&
operator|!
name|match
operator|&&
name|test_should_match
condition|)
block|{
name|printf
argument_list|(
literal|"\n\nDidn't match but should have:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match_1
condition|)
name|printf
argument_list|(
literal|"The single match/search failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match_2
condition|)
name|printf
argument_list|(
literal|"The double match/search failed.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|invalid_pattern
operator|&&
name|pattern_should_be_valid
condition|)
name|printf
argument_list|(
literal|"\n\nInvalid pattern (%s):\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nonconst_buf
operator|.
name|fastmap_accurate
operator|&&
name|pattern_should_be_valid
condition|)
name|printf
argument_list|(
literal|"\n\nIncorrect fastmap:\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OK_TO_SEARCH
operator|&&
name|correct_regs
operator|&&
operator|!
name|all_regs_correct
condition|)
name|printf
argument_list|(
literal|"\n\nNot all registers were correct:\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n\nTest was OK:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|invalid_pattern
operator|&&
operator|!
name|pattern_should_be_valid
operator|)
operator|)
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"  Pattern:  `%s'.\n"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_should_be_valid
operator|||
name|verbose
operator|||
name|internal_error_1
operator|||
name|internal_error_2
condition|)
block|{
name|printf
argument_list|(
literal|"  Strings: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"`%s' and "
argument_list|,
name|str1
operator|==
name|NULL
condition|?
literal|"NULL"
else|:
name|str1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"`%s'.\n"
argument_list|,
name|str2
operator|==
name|NULL
condition|?
literal|"NULL"
else|:
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OK_TO_SEARCH
operator|||
name|verbose
operator|||
name|internal_error_1
operator|||
name|internal_error_2
operator|)
operator|&&
operator|!
name|invalid_pattern
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|old_buf
operator|.
name|buffer
argument_list|,
name|nonconst_buf
operator|.
name|buffer
argument_list|,
name|nonconst_buf
operator|.
name|used
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|invalid_pattern
condition|)
block|{
name|printf
argument_list|(
literal|"  (%s)\n"
argument_list|,
name|r
condition|?
name|r
else|:
literal|"Valid regular expression"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  Compiled pattern before matching: "
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
operator|&
name|old_buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  Compiled pattern after matching:  "
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n  Compiled pattern:   "
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|correct_fastmap
operator|&&
operator|(
operator|!
name|nonconst_buf
operator|.
name|fastmap_accurate
operator|||
name|verbose
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n  The fastmap should have been: "
argument_list|)
expr_stmt|;
name|print_fastmap
argument_list|(
name|correct_fastmap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  Fastmap: "
argument_list|)
expr_stmt|;
name|print_fastmap
argument_list|(
name|fastmap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  Compiled pattern before matching: "
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|all_regs_correct
operator|||
name|verbose
operator|)
operator|&&
name|correct_regs
condition|)
block|{
name|unsigned
name|this_reg
decl_stmt|;
name|printf
argument_list|(
literal|"\n  Incorrect registers:"
argument_list|)
expr_stmt|;
for|for
control|(
name|this_reg
operator|=
literal|0
init|;
name|this_reg
operator|<
name|regs
operator|.
name|num_regs
condition|;
name|this_reg
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|regs_correct
index|[
name|this_reg
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"\n    Register %d's start was %2d.  "
argument_list|,
name|this_reg
argument_list|,
name|regs
operator|.
name|start
index|[
name|this_reg
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tIt should have been %d.\n"
argument_list|,
name|correct_regs
operator|->
name|start
index|[
name|this_reg
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Register %d's end was   %2d.  "
argument_list|,
name|this_reg
argument_list|,
name|regs
operator|.
name|end
index|[
name|this_reg
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tIt should have been %d.\n"
argument_list|,
name|correct_regs
operator|->
name|end
index|[
name|this_reg
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|nonconst_buf
operator|.
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nonconst_buf
operator|.
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|OK_TO_SEARCH
condition|)
block|{
name|free
argument_list|(
name|old_buf
operator|.
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|correct_regs
condition|)
name|free
argument_list|(
name|regs_correct
argument_list|)
expr_stmt|;
block|}
name|nonconst_buf
operator|.
name|buffer
operator|=
name|old_buf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|regs_correct
operator|=
name|NULL
expr_stmt|;
name|regs
operator|.
name|start
operator|=
name|regs
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* general_test */
end_comment

begin_function
name|void
name|test_search_return
parameter_list|(
name|match_start_wanted
parameter_list|,
name|pattern
parameter_list|,
name|string
parameter_list|)
name|int
name|match_start_wanted
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|char
name|fastmap
index|[
literal|1
operator|<<
name|BYTEWIDTH
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|compile_return
decl_stmt|;
name|int
name|match_start
decl_stmt|;
specifier|static
name|num_times_called
operator|=
literal|0
expr_stmt|;
name|num_times_called
operator|++
expr_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|1
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|xmalloc
argument_list|(
name|buf
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pattern
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
name|compile_return
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_return
condition|)
block|{
name|printf
argument_list|(
literal|"\n\nInvalid pattern in test_match_start:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|compile_return
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|match_start
operator|=
name|re_search
argument_list|(
operator|&
name|buf
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_start
operator|!=
name|match_start_wanted
condition|)
name|printf
argument_list|(
literal|"\nWanted search to start at %d but started at %d.\n"
argument_list|,
name|match_start
argument_list|,
name|match_start_wanted
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SET_FASTMAP
parameter_list|()
define|\
value|{									\     unsigned this_char;							\  									\     memset (correct_fastmap, invert, (1<< BYTEWIDTH));			\  									\     for (this_char = 0; this_char< strlen (fastmap_string); this_char++)\       correct_fastmap[fastmap_string[this_char]] = !invert;		\     correct_fastmap['\n'] = match_newline;				\   }
end_define

begin_function
name|void
name|test_fastmap
parameter_list|(
name|pat
parameter_list|,
name|fastmap_string
parameter_list|,
name|invert
parameter_list|,
name|match_newline
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|fastmap_string
decl_stmt|;
name|unsigned
name|invert
decl_stmt|;
name|unsigned
name|match_newline
decl_stmt|;
block|{
name|char
name|correct_fastmap
index|[
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
index|]
decl_stmt|;
name|SET_FASTMAP
argument_list|()
expr_stmt|;
name|general_test
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|pat
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|correct_fastmap
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_fastmap_search
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|,
name|fastmap_string
parameter_list|,
name|invert
parameter_list|,
name|match_newline
parameter_list|,
name|can_be_null
parameter_list|,
name|start0
parameter_list|,
name|end0
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|fastmap_string
decl_stmt|;
name|unsigned
name|invert
decl_stmt|;
name|unsigned
name|match_newline
decl_stmt|;
name|int
name|can_be_null
decl_stmt|;
name|int
name|start0
decl_stmt|;
name|int
name|end0
decl_stmt|;
block|{
name|char
name|correct_fastmap
index|[
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
index|]
decl_stmt|;
name|struct
name|re_registers
name|correct_regs
decl_stmt|;
name|correct_regs
operator|.
name|num_regs
operator|=
name|RE_NREGS
expr_stmt|;
name|correct_regs
operator|.
name|start
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|RE_NREGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|correct_regs
operator|.
name|end
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|RE_NREGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|set_all_registers
argument_list|(
name|start0
argument_list|,
name|end0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|correct_regs
argument_list|)
expr_stmt|;
name|SET_FASTMAP
argument_list|()
expr_stmt|;
name|general_test
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|pat
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str
argument_list|)
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str
argument_list|)
argument_list|,
name|correct_fastmap
argument_list|,
operator|&
name|correct_regs
argument_list|,
name|can_be_null
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|correct_regs
operator|.
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|correct_regs
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_all_registers
parameter_list|(
name|pat
parameter_list|,
name|str1
parameter_list|,
name|str2
parameter_list|,
name|start0
parameter_list|,
name|end0
parameter_list|,
name|start1
parameter_list|,
name|end1
parameter_list|,
name|start2
parameter_list|,
name|end2
parameter_list|,
name|start3
parameter_list|,
name|end3
parameter_list|,
name|start4
parameter_list|,
name|end4
parameter_list|,
name|start5
parameter_list|,
name|end5
parameter_list|,
name|start6
parameter_list|,
name|end6
parameter_list|,
name|start7
parameter_list|,
name|end7
parameter_list|,
name|start8
parameter_list|,
name|end8
parameter_list|,
name|start9
parameter_list|,
name|end9
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|start0
decl_stmt|;
name|int
name|end0
decl_stmt|;
name|int
name|start1
decl_stmt|;
name|int
name|end1
decl_stmt|;
name|int
name|start2
decl_stmt|;
name|int
name|end2
decl_stmt|;
name|int
name|start3
decl_stmt|;
name|int
name|end3
decl_stmt|;
name|int
name|start4
decl_stmt|;
name|int
name|end4
decl_stmt|;
name|int
name|start5
decl_stmt|;
name|int
name|end5
decl_stmt|;
name|int
name|start6
decl_stmt|;
name|int
name|end6
decl_stmt|;
name|int
name|start7
decl_stmt|;
name|int
name|end7
decl_stmt|;
name|int
name|start8
decl_stmt|;
name|int
name|end8
decl_stmt|;
name|int
name|start9
decl_stmt|;
name|int
name|end9
decl_stmt|;
block|{
name|struct
name|re_registers
name|correct_regs
decl_stmt|;
if|if
condition|(
name|omit_register_tests
condition|)
return|return;
name|correct_regs
operator|.
name|num_regs
operator|=
name|RE_NREGS
expr_stmt|;
name|correct_regs
operator|.
name|start
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|RE_NREGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|correct_regs
operator|.
name|end
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|RE_NREGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|set_all_registers
argument_list|(
name|start0
argument_list|,
name|end0
argument_list|,
name|start1
argument_list|,
name|end1
argument_list|,
name|start2
argument_list|,
name|end2
argument_list|,
name|start3
argument_list|,
name|end3
argument_list|,
name|start4
argument_list|,
name|end4
argument_list|,
name|start5
argument_list|,
name|end5
argument_list|,
name|start6
argument_list|,
name|end6
argument_list|,
name|start7
argument_list|,
name|end7
argument_list|,
name|start8
argument_list|,
name|end8
argument_list|,
name|start9
argument_list|,
name|end9
argument_list|,
operator|&
name|correct_regs
argument_list|)
expr_stmt|;
name|general_test
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|pat
argument_list|,
name|str1
argument_list|,
name|str2
argument_list|,
literal|0
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str1
argument_list|)
operator|+
name|SAFE_STRLEN
argument_list|(
name|str2
argument_list|)
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str1
argument_list|)
operator|+
name|SAFE_STRLEN
argument_list|(
name|str2
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|correct_regs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|correct_regs
operator|.
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|correct_regs
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|invalid_pattern
parameter_list|(
name|error_code_expected
parameter_list|,
name|pattern
parameter_list|)
name|int
name|error_code_expected
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|regex_t
name|pattern_buffer
decl_stmt|;
name|int
name|cflags
init|=
name|re_syntax_options
operator|==
name|RE_SYNTAX_POSIX_EXTENDED
operator|||
name|re_syntax_options
operator|==
name|RE_SYNTAX_POSIX_MINIMAL_EXTENDED
condition|?
name|REG_EXTENDED
else|:
literal|0
decl_stmt|;
name|test_compile
argument_list|(
literal|0
argument_list|,
name|error_code_expected
argument_list|,
name|pattern
argument_list|,
operator|&
name|pattern_buffer
argument_list|,
name|cflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|valid_pattern
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|regex_t
name|pattern_buffer
decl_stmt|;
name|int
name|cflags
init|=
name|re_syntax_options
operator|==
name|RE_SYNTAX_POSIX_EXTENDED
operator|||
name|re_syntax_options
operator|==
name|RE_SYNTAX_POSIX_MINIMAL_EXTENDED
condition|?
name|REG_EXTENDED
else|:
literal|0
decl_stmt|;
name|test_compile
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|pattern
argument_list|,
operator|&
name|pattern_buffer
argument_list|,
name|cflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|delimiters_to_ops
parameter_list|(
name|source
parameter_list|,
name|left_delimiter
parameter_list|,
name|right_delimiter
parameter_list|)
name|char
modifier|*
name|source
decl_stmt|;
name|char
name|left_delimiter
decl_stmt|;
name|char
name|right_delimiter
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|answer
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|boolean
name|double_size
init|=
name|false
decl_stmt|;
name|unsigned
name|source_char
decl_stmt|;
name|unsigned
name|answer_char
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|source
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|left_delimiter
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
operator|!
operator|(
name|re_syntax_options
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
name|double_size
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
operator|(
name|re_syntax_options
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
name|double_size
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Found strange delimiter %c in delimiter_to_ops.\n"
argument_list|,
name|left_delimiter
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The source was `%s'\n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
name|source
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|source
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|answer
condition|)
block|{
name|free
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|answer
operator|=
name|NULL
expr_stmt|;
block|}
name|answer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|double_size
condition|?
name|strlen
argument_list|(
name|source
argument_list|)
operator|<<
literal|1
else|:
name|strlen
argument_list|(
name|source
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|double_size
condition|)
name|strcpy
argument_list|(
name|answer
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|source_char
operator|=
literal|0
init|;
name|source_char
operator|<
name|strlen
argument_list|(
name|source
argument_list|)
condition|;
name|source_char
operator|++
control|)
block|{
if|if
condition|(
name|source
index|[
name|source_char
index|]
operator|==
name|left_delimiter
operator|||
name|source
index|[
name|source_char
index|]
operator|==
name|right_delimiter
condition|)
name|answer
index|[
name|answer_char
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|answer
index|[
name|answer_char
operator|++
index|]
operator|=
name|source
index|[
name|source_char
index|]
expr_stmt|;
block|}
name|answer
index|[
name|answer_char
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
end_function

begin_function
name|void
name|print_pattern_info
parameter_list|(
name|pattern
parameter_list|,
name|pattern_buffer_ptr
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|regex_t
modifier|*
name|pattern_buffer_ptr
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"  Pattern:  `%s'.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Compiled pattern:  "
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
name|pattern_buffer_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|valid_nonposix_pattern
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|struct
name|re_pattern_buffer
name|nonconst_buf
decl_stmt|;
name|nonconst_buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|nonconst_buf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|nonconst_buf
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|pattern
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't compile the pattern.\n"
argument_list|)
expr_stmt|;
name|print_pattern_info
argument_list|(
name|pattern
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|compile_and_print_pattern
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|struct
name|re_pattern_buffer
name|nonconst_buf
decl_stmt|;
name|nonconst_buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|nonconst_buf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Couldn't compile the pattern.\n"
argument_list|)
expr_stmt|;
name|print_pattern_info
argument_list|(
name|pattern
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_case_fold
parameter_list|(
name|pattern
parameter_list|,
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|re_pattern_buffer
name|nonconst_buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|init_pattern_buffer
argument_list|(
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
name|nonconst_buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
name|assert
argument_list|(
name|pattern
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"\nShould have been a valid pattern but wasn't.\n"
argument_list|)
expr_stmt|;
name|print_pattern_info
argument_list|(
name|pattern
argument_list|,
operator|&
name|nonconst_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|test_should_match
operator|&&
name|re_match
argument_list|(
operator|&
name|nonconst_buf
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|strlen
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Match failed for case fold.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Pattern:  `%s'.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  String: `%s'.\n"
argument_list|,
name|string
operator|==
name|NULL
condition|?
literal|"NULL"
else|:
name|string
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|test_match_n_times
parameter_list|(
name|n
parameter_list|,
name|pattern
parameter_list|,
name|string
parameter_list|)
name|unsigned
name|n
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
name|unsigned
name|match
init|=
literal|0
decl_stmt|;
name|unsigned
name|this_match
decl_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|pattern
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"Didn't compile.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Pattern: %s.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|this_match
operator|=
literal|1
init|;
name|this_match
operator|<=
name|n
condition|;
name|this_match
operator|++
control|)
name|match
operator|=
operator|(
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|&&
operator|!
name|test_should_match
condition|)
name|printf
argument_list|(
literal|"\n\nMatched but shouldn't have:\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|match
operator|&&
name|test_should_match
condition|)
name|printf
argument_list|(
literal|"\n\nDidn't match but should have:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|match
operator|&&
operator|!
name|test_should_match
operator|)
operator|||
operator|(
operator|!
name|match
operator|&&
name|test_should_match
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"  The string to match was:  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|printf
argument_list|(
literal|"`%s' and "
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"`'"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Pattern: %s.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Compiled pattern: %s.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|test_match_2
parameter_list|(
name|pat
parameter_list|,
name|str1
parameter_list|,
name|str2
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
block|{
name|general_test
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|pat
argument_list|,
name|str1
argument_list|,
name|str2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SAFE_STRLEN
argument_list|(
name|str1
argument_list|)
operator|+
name|SAFE_STRLEN
argument_list|(
name|str2
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_match
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|test_match_2
argument_list|(
name|pat
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|test_match_2
argument_list|(
name|pat
argument_list|,
name|NULL
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

