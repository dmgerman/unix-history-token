begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tregress.c: reported bugs.  The `t' just makes the filename not have    a common prefix with `regex.c', so completion works better.  */
end_comment

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_decl_stmt
name|boolean
name|pause_at_error
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|itoa
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|char
modifier|*
name|a
init|=
name|xmalloc
argument_list|(
literal|21
argument_list|)
decl_stmt|;
comment|/* sign + 19 digits (enough for 64 bits) + null */
name|sprintf
argument_list|(
name|a
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|simple_fail
parameter_list|(
name|routine
parameter_list|,
name|pat
parameter_list|,
name|buf
parameter_list|,
name|str
parameter_list|,
name|ret
parameter_list|)
specifier|const
name|char
modifier|*
name|routine
decl_stmt|;
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed %s (return = %s).\n"
argument_list|,
name|routine
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|&&
operator|*
name|str
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   String = %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Pattern = %s\n"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|print_compiled_pattern
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pause_at_error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RET to continue: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getchar
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Abbreviate the most common calls.  */
end_comment

begin_function
specifier|static
name|void
name|simple_compile
parameter_list|(
name|pat
parameter_list|,
name|buf
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|buf
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|ret
init|=
name|re_compile_pattern
argument_list|(
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|simple_fail
argument_list|(
literal|"compile"
argument_list|,
name|pat
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|simple_fastmap
parameter_list|(
name|pat
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
block|{
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|char
name|fastmap
index|[
literal|256
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|buf
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|simple_compile
argument_list|(
name|pat
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|re_compile_fastmap
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|simple_fail
argument_list|(
literal|"fastmap compile"
argument_list|,
name|pat
argument_list|,
operator|&
name|buf
argument_list|,
name|NULL
argument_list|,
name|itoa
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SIMPLE_MATCH
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|)
value|do_match (pat, str, strlen (str))
end_define

begin_define
define|#
directive|define
name|SIMPLE_NONMATCH
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|)
value|do_match (pat, str, -1)
end_define

begin_function
specifier|static
name|void
name|do_match
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|,
name|expected
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|expected
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|buf
operator|.
name|translate
operator|=
name|buf
operator|.
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|simple_compile
argument_list|(
name|pat
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ret
operator|=
name|re_match_2
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|expected
condition|)
name|simple_fail
argument_list|(
literal|"match"
argument_list|,
name|pat
argument_list|,
operator|&
name|buf
argument_list|,
name|str
argument_list|,
name|itoa
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|simple_search
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|,
name|correct_startpos
parameter_list|)
specifier|const
name|char
modifier|*
name|pat
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|correct_startpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|buf
operator|.
name|translate
operator|=
name|buf
operator|.
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|simple_compile
argument_list|(
name|pat
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ret
operator|=
name|re_search_2
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|correct_startpos
condition|)
name|simple_fail
argument_list|(
literal|"match"
argument_list|,
name|pat
argument_list|,
operator|&
name|buf
argument_list|,
name|str
argument_list|,
name|itoa
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Past bugs people have reported.  */
end_comment

begin_function
name|void
name|test_regress
parameter_list|()
block|{
specifier|extern
name|char
name|upcase
index|[]
decl_stmt|;
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|fastmap
init|=
name|xmalloc
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|buf
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|fastmap
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"\nStarting regression tests.\n"
argument_list|)
expr_stmt|;
name|t
operator|=
name|regress_test
expr_stmt|;
name|test_should_match
operator|=
name|true
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
comment|/* enami@sys.ptg.sony.co.jp  10 Nov 92 15:19:02 JST  */
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[A-[]"
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
comment|/* meyering@cs.utexas.edu  Nov  6 22:34:41 1992  */
name|simple_search
argument_list|(
literal|"\\w+"
argument_list|,
literal|"a"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* jimb@occs.cs.oberlin.edu  10 Sep 92 00:42:33  */
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\377]"
argument_list|,
literal|"\001"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\377]"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\377]"
argument_list|,
literal|"\377"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
comment|/* mike@skinner.cs.uoregon.edu  1 Sep 92 01:45:22  */
name|SIMPLE_MATCH
argument_list|(
literal|"^^$"
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
comment|/* pclink@qld.tne.oz.au  Sep  7 22:42:36 1992  */
name|re_set_syntax
argument_list|(
name|RE_INTERVALS
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"^a\\{3\\}$"
argument_list|,
literal|"aaa"
argument_list|)
expr_stmt|;
name|SIMPLE_NONMATCH
argument_list|(
literal|"^a\\{3\\}$"
argument_list|,
literal|"aa"
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
comment|/* pclink@qld.tne.oz.au, 31 Aug 92.  (conjecture) */
name|re_set_syntax
argument_list|(
name|RE_INTERVALS
argument_list|)
expr_stmt|;
name|simple_search
argument_list|(
literal|"a\\{1,3\\}b"
argument_list|,
literal|"aaab"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|simple_search
argument_list|(
literal|"a\\{1,3\\}b"
argument_list|,
literal|"aaaab"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
comment|/* trq@dionysos.thphys.ox.ac.uk, 31 Aug 92.  (simplified) */
name|simple_fastmap
argument_list|(
literal|"^.*\n[  ]*"
argument_list|)
expr_stmt|;
comment|/* wind!greg@plains.NoDak.edu, 25 Aug 92.  (simplified) */
name|re_set_syntax
argument_list|(
name|RE_INTERVALS
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[a-zA-Z]*.\\{5\\}"
argument_list|,
literal|"xN0000"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[a-zA-Z]*.\\{5\\}$"
argument_list|,
literal|"systemxN0000"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"\\([a-zA-Z]*\\).\\{5\\}$"
argument_list|,
literal|"systemxN0000"
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
comment|/* jimb, 18 Aug 92.  Don't use \000, so `strlen' (in our testing      routines) will work.  (This still tickles the bug jimb reported.)  */
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\377]"
argument_list|,
literal|"\001"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\377]"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\377]"
argument_list|,
literal|"\377"
argument_list|)
expr_stmt|;
comment|/* jimb, 13 Aug 92.  */
name|SIMPLE_MATCH
argument_list|(
literal|"[\001-\177]"
argument_list|,
literal|"\177"
argument_list|)
expr_stmt|;
comment|/* Tests based on bwoelfel's below.  */
name|SIMPLE_MATCH
argument_list|(
literal|"\\(a\\|ab\\)*"
argument_list|,
literal|"aab"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"\\(a\\|ab\\)+"
argument_list|,
literal|"aab"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"\\(a*\\|ab\\)+"
argument_list|,
literal|"aab"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"\\(a+\\|ab\\)+"
argument_list|,
literal|"aab"
argument_list|)
expr_stmt|;
name|SIMPLE_MATCH
argument_list|(
literal|"\\(a?\\|ab\\)+"
argument_list|,
literal|"aab"
argument_list|)
expr_stmt|;
comment|/* bwoelfel@widget.seas.upenn.edu, 25 Jul 92.  */
name|SIMPLE_MATCH
argument_list|(
literal|"^\\([ab]+\\|bc\\)+"
argument_list|,
literal|"abc"
argument_list|)
expr_stmt|;
comment|/* jla, 3 Jul 92.  Core dump in re_search_2.  */
name|buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
define|#
directive|define
name|DATEDUMP_PATTERN
value|" *[0-9]*:"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|DATEDUMP_PATTERN
argument_list|,
name|strlen
argument_list|(
name|DATEDUMP_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"date dump compile failed.\n"
argument_list|)
expr_stmt|;
name|regs
operator|.
name|num_regs
operator|=
literal|0
expr_stmt|;
name|regs
operator|.
name|start
operator|=
name|regs
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|re_search_2
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"Thu Jul  2 18:34:18 1992"
argument_list|,
literal|24
argument_list|,
literal|3
argument_list|,
literal|21
argument_list|,
operator|&
name|regs
argument_list|,
literal|24
argument_list|)
operator|!=
literal|10
condition|)
name|printf
argument_list|(
literal|"date dump search failed.\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|fastmap
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
comment|/* rms, 4 Jul 1992.  Pattern is much slower in Emacs 19.  Fastmap      should be only a backslash.  */
define|#
directive|define
name|BEGINEND_PATTERN
value|"\\(\\\\begin\\s *{\\)\\|\\(\\\\end\\s *{\\)"
name|test_fastmap
argument_list|(
name|BEGINEND_PATTERN
argument_list|,
literal|"\\"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* kaoru@is.s.u-tokyo.ac.jp, 27 Jun 1992.  Code for [a-z] (in regex.c)      should translate the whole set.  */
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
define|#
directive|define
name|CASE_SET_PATTERN
value|"[ -`]"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|CASE_SET_PATTERN
argument_list|,
name|strlen
argument_list|(
name|CASE_SET_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"case set compile failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_match_2
argument_list|(
operator|&
name|buf
argument_list|,
literal|"K"
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"case set match failed.\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|CASE_SET_PATTERN2
value|"[`-|]"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|CASE_SET_PATTERN2
argument_list|,
name|strlen
argument_list|(
name|CASE_SET_PATTERN2
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"case set2 compile failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_match_2
argument_list|(
operator|&
name|buf
argument_list|,
literal|"K"
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"case set2 match failed.\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
comment|/* jimb, 27 Jun 92.  Problems with gaps in the string.  */
define|#
directive|define
name|GAP_PATTERN
value|"x.*y.*z"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|GAP_PATTERN
argument_list|,
name|strlen
argument_list|(
name|GAP_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"gap didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_match_2
argument_list|(
operator|&
name|buf
argument_list|,
literal|"x-"
argument_list|,
literal|2
argument_list|,
literal|"y-z-"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|6
argument_list|)
operator|!=
literal|5
condition|)
name|printf
argument_list|(
literal|"gap match failed.\n"
argument_list|)
expr_stmt|;
comment|/* jimb, 19 Jun 92.  Since `beginning of word' matches at the      beginning of the string, then searching ought to find it there.      If `re_compile_fastmap' is not called, then it works ok.  */
name|buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
define|#
directive|define
name|BOW_BEG_PATTERN
value|"\\<"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|BOW_BEG_PATTERN
argument_list|,
name|strlen
argument_list|(
name|BOW_BEG_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"begword-begstring didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_search
argument_list|(
operator|&
name|buf
argument_list|,
literal|"foo"
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"begword-begstring search failed.\n"
argument_list|)
expr_stmt|;
comment|/* Same bug report, different null-matching pattern.  */
define|#
directive|define
name|EMPTY_ANCHOR_PATTERN
value|"^$"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|EMPTY_ANCHOR_PATTERN
argument_list|,
name|strlen
argument_list|(
name|EMPTY_ANCHOR_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"empty anchor didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_search
argument_list|(
operator|&
name|buf
argument_list|,
literal|"foo\n\nbar"
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|4
condition|)
name|printf
argument_list|(
literal|"empty anchor search failed.\n"
argument_list|)
expr_stmt|;
comment|/* jimb@occs.cs.oberlin.edu, 21 Apr 92.  After we first allocate      registers for a particular re_pattern_buffer, we might have to      reallocate more registers on subsequent calls -- and we should be      reusing the same memory.  */
define|#
directive|define
name|ALLOC_REG_PATTERN
value|"\\(abc\\)"
name|free
argument_list|(
name|buf
operator|.
name|fastmap
argument_list|)
expr_stmt|;
name|buf
operator|.
name|fastmap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|ALLOC_REG_PATTERN
argument_list|,
name|strlen
argument_list|(
name|ALLOC_REG_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"register allocation didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
literal|"abc"
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"register allocation didn't match.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|regs
operator|.
name|end
index|[
literal|1
index|]
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"register allocation reg #1 wrong.\n"
argument_list|)
expr_stmt|;
block|{
name|int
modifier|*
name|old_regstart
init|=
name|regs
operator|.
name|start
decl_stmt|;
name|int
modifier|*
name|old_regend
init|=
name|regs
operator|.
name|end
decl_stmt|;
if|if
condition|(
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
literal|"abc"
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"register reallocation didn't match.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|regs
operator|.
name|end
index|[
literal|1
index|]
operator|!=
literal|3
operator|||
name|old_regstart
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|old_regend
index|[
literal|1
index|]
operator|!=
literal|3
operator|||
name|regs
operator|.
name|start
operator|!=
name|old_regstart
operator|||
name|regs
operator|.
name|end
operator|!=
name|old_regend
condition|)
name|printf
argument_list|(
literal|"register reallocation registers wrong.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* jskudlarek@std.MENTORG.COM, 21 Apr 92 (string-match).  */
define|#
directive|define
name|JSKUD_PATTERN
value|"[^/]+\\(/[^/.]+\\)?/[0-9]+$"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|JSKUD_PATTERN
argument_list|,
name|strlen
argument_list|(
name|JSKUD_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"jskud test didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_search
argument_list|(
operator|&
name|buf
argument_list|,
literal|"a/1"
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
operator|&
name|regs
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"jskud test didn't match.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
operator|||
name|regs
operator|.
name|end
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"jskud test, reg #1 wrong.\n"
argument_list|)
expr_stmt|;
comment|/* jla's bug (with string-match), 5 Feb 92.  */
name|TEST_SEARCH
argument_list|(
literal|"\\`[ \t\n]*"
argument_list|,
literal|"jla@challenger (Joseph Arceneaux)"
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* jwz@lucid.com, 8 March 1992 (re-search-forward).  (His is the      second.)  These are not supposed to match.  */
if|#
directive|if
literal|0
comment|/* This one fails quickly, because we can change the maybe_pop_jump      from the + to a pop_failure_pop, because of the c's.  */
block|TEST_SEARCH ("^\\(To\\|CC\\):\\([^c]*\\)+co", "To: hbs%titanic@lucid.com (Harlan Sexton)\n\ Cc: eb@thalidomide, jlm@thalidomide\n\ Subject: Re: so is this really as horrible an idea as it seems to me?\n\ In-Reply-To: Harlan Sexton's message of Sun 8-Mar-92 11:00:06 PST<9203081900.AA24794@titanic.lucid>\n\ References:<9203080736.AA05869@thalidomide.lucid>\n\<9203081900.AA24794@titanic.lucid>", 0, 5000);
comment|/* This one takes a long, long time to complete, because we have to      keep the failure points around because we might backtrack.  */
block|TEST_SEARCH ("^\\(To\\|CC\\):\\(.*\n.*\\)+co",
comment|/* "X-Windows: The joke that kills.\n\ FCC:  /u/jwz/VM/inbox\n\ From: Jamie Zawinski<jwz@lucid.com>\n\ */
block|"To: hbs%titanic@lucid.com (Harlan Sexton)\n\ Cc: eb@thalidomide, jlm@thalidomide\n\ Subject: Re: so is this really as horrible an idea as it seems to me?\n\ In-Reply-To: Harlan Sexton's message of Sun 8-Mar-92 11:00:06 PST<9203081900.AA24794@titanic.lucid>\n\ References:<9203080736.AA05869@thalidomide.lucid>\n\<9203081900.AA24794@titanic.lucid>", 0, 5000);
endif|#
directive|endif
comment|/* 0 [failed searches] */
comment|/* macrakis' bugs.  */
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
comment|/* message of 24 Jan 91 */
if|if
condition|(
name|re_compile_pattern
argument_list|(
literal|"[!-`]"
argument_list|,
literal|5
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Range test didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
literal|"A"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"Range test #1 didn't match.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"Range test #2 didn't match.\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|FAO_PATTERN
value|"\\(f\\(.\\)o\\)+"
if|if
condition|(
name|re_compile_pattern
argument_list|(
name|FAO_PATTERN
argument_list|,
name|strlen
argument_list|(
name|FAO_PATTERN
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"faofdx test didn't compile.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_search
argument_list|(
operator|&
name|buf
argument_list|,
literal|"faofdx"
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
operator|&
name|regs
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"faofdx test didn't match.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|regs
operator|.
name|end
index|[
literal|1
index|]
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"faofdx test, reg #1 wrong.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
index|[
literal|2
index|]
operator|!=
literal|1
operator|||
name|regs
operator|.
name|end
index|[
literal|2
index|]
operator|!=
literal|2
condition|)
name|printf
argument_list|(
literal|"faofdx test, reg #2 wrong.\n"
argument_list|)
expr_stmt|;
name|TEST_REGISTERS
argument_list|(
literal|"\\(a\\)*a"
argument_list|,
literal|"aaa"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|test_fastmap
argument_list|(
literal|"^\\([^ \n]+:\n\\)+\\([^ \n]+:\\)"
argument_list|,
literal|" \n"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 40 lines, 48 a's in each line.  */
name|test_match
argument_list|(
literal|"^\\([^ \n]+:\n\\)+\\([^ \n]+:\\)"
argument_list|,
literal|"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\n\ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:"
argument_list|)
expr_stmt|;
comment|/* 640 a's followed by one b, twice.  */
name|test_match
argument_list|(
literal|"\\(.*\\)\\1"
argument_list|,
literal|"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
argument_list|)
expr_stmt|;
comment|/* 640 a's followed by two b's, twice.  */
name|test_match
argument_list|(
literal|"\\(.*\\)\\1"
argument_list|,
literal|"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"
argument_list|)
expr_stmt|;
comment|/* Dave G. bug: Reference to a subexpression which didn't match.      Should fail. */
name|re_set_syntax
argument_list|(
name|RE_NO_BK_PARENS
operator||
name|RE_NO_BK_VBAR
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(ooooooooooone())-annnnnnnnnnnd-(twooooooooooo\\2)"
argument_list|,
literal|"ooooooooooone-annnnnnnnnnnd-twooooooooooo"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o|t)"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o()|t)"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o|t)"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(ooooooooooooooo|tttttttttttttttt())"
argument_list|,
literal|"ooooooooooooooo"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o|t())"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o()|t())"
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(ooooooooooooooooooooooooone()|twooooooooooooooooooooooooo())"
argument_list|,
literal|"ooooooooooooooooooooooooone"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o()|t())-a-(t\\2|f\\3)"
argument_list|,
literal|"o-a-t"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o()|t())-a-(t\\2|f\\3)"
argument_list|,
literal|"t-a-f"
argument_list|)
expr_stmt|;
name|test_should_match
operator|=
literal|0
expr_stmt|;
name|test_match
argument_list|(
literal|"(foo(bar)|second)\\2"
argument_list|,
literal|"second"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o()|t())-a-(t\\2|f\\3)"
argument_list|,
literal|"t-a-t"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"(o()|t())-a-(t\\2|f\\3)"
argument_list|,
literal|"o-a-f"
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"\\(foo\\(bar\\)\\|second\\)\\2"
argument_list|,
literal|"secondbar"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"\\(one\\(\\)\\|two\\(\\)\\)-and-\\(three\\2\\|four\\3\\)"
argument_list|,
literal|"one-and-four"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"\\(one\\(\\)\\|two\\(\\)\\)-and-\\(three\\2\\|four\\3\\)"
argument_list|,
literal|"two-and-three"
argument_list|)
expr_stmt|;
name|test_should_match
operator|=
literal|1
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"\\(one\\(\\)\\|two\\(\\)\\)-and-\\(three\\2\\|four\\3\\)"
argument_list|,
literal|"one-and-three"
argument_list|)
expr_stmt|;
name|test_match
argument_list|(
literal|"\\(one\\(\\)\\|two\\(\\)\\)-and-\\(three\\2\\|four\\3\\)"
argument_list|,
literal|"two-and-four"
argument_list|)
expr_stmt|;
name|TEST_REGISTERS
argument_list|(
literal|":\\(.*\\)"
argument_list|,
literal|":/"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Bug with `upcase' translation table, from Nico Josuttis<nico@bredex.de> */
name|test_should_match
operator|=
literal|1
expr_stmt|;
name|test_case_fold
argument_list|(
literal|"[a-a]"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nFinished regression tests.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local variables: make-backup-files: t version-control: t trim-versions-without-asking: nil End: */
end_comment

end_unit

