begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* debugmalloc.c: a malloc for debugging purposes.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|s
parameter_list|)
value|if (trace) fprintf (stderr, "%s", s)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|s
parameter_list|,
name|e1
parameter_list|)
value|if (trace) fprintf (stderr, s, e1)
end_define

begin_define
define|#
directive|define
name|TRACE2
parameter_list|(
name|s
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|)
value|if (trace) fprintf (stderr, s, e1, e2)
end_define

begin_define
define|#
directive|define
name|TRACE3
parameter_list|(
name|s
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|)
value|if (trace) fprintf (stderr, s, e1, e2, e3)
end_define

begin_define
define|#
directive|define
name|TRACE4
parameter_list|(
name|s
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|)
define|\
value|if (trace) fprintf (stderr, s, e1, e2, e3, e4)
end_define

begin_typedef
typedef|typedef
name|char
modifier|*
name|address
typedef|;
end_typedef

begin_comment
comment|/* Wrap our calls to sbrk.  */
end_comment

begin_function
name|address
name|xsbrk
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
name|address
name|ret
init|=
name|sbrk
argument_list|(
name|incr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|address
operator|)
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"sbrk"
argument_list|)
expr_stmt|;
comment|/* Actually, we should return NULL, not quit.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
name|chunk_struct
block|{
comment|/* This is the size (in bytes) that has actually been actually      allocated, not the size that the user requested.  */
name|unsigned
name|alloc_size
decl_stmt|;
comment|/* This is the size the user requested.  */
name|unsigned
name|user_size
decl_stmt|;
comment|/* Points to the next block in one of the lists.  */
name|struct
name|chunk_struct
modifier|*
name|next
decl_stmt|;
comment|/* Now comes the user's memory.  */
name|address
name|user_mem
decl_stmt|;
comment|/* After the user's memory is a constant.  */
block|}
typedef|*
name|chunk
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MALLOC_OVERHEAD
value|16
end_define

begin_comment
comment|/* We might play around with the `user_size' field, but the amount of    memory that is actually available in the chunk is always the size    allocated minus the overhead.  */
end_comment

begin_define
define|#
directive|define
name|USER_ALLOC
parameter_list|(
name|c
parameter_list|)
value|((c)->alloc_size - MALLOC_OVERHEAD)
end_define

begin_comment
comment|/* Given a pointer to a malloc-allocated block, the beginning of the    chunk should always be MALLOC_OVERHEAD - 4 bytes back, since the only    overhead after the user memory is the constant.  */
end_comment

begin_function
name|chunk
name|mem_to_chunk
parameter_list|(
name|mem
parameter_list|)
name|address
name|mem
decl_stmt|;
block|{
return|return
call|(
name|chunk
call|)
argument_list|(
name|mem
operator|-
operator|(
name|MALLOC_OVERHEAD
operator|-
literal|4
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The other direction is even easier, since the user's memory starts at    the `user_mem' member in the chunk.  */
end_comment

begin_function
name|address
name|chunk_to_mem
parameter_list|(
name|c
parameter_list|)
name|chunk
name|c
decl_stmt|;
block|{
return|return
operator|(
name|address
operator|)
operator|&
operator|(
name|c
operator|->
name|user_mem
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We keep both all the allocated chunks and all the free chunks on    lists.  Since we put the next pointers in the chunk structure, we    don't need a separate chunk_list structure.  */
end_comment

begin_decl_stmt
name|chunk
name|alloc_list
init|=
name|NULL
decl_stmt|,
name|free_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We always append the new chunk at the beginning of the list.  */
end_comment

begin_function
name|void
name|chunk_insert
parameter_list|(
name|chunk_list
parameter_list|,
name|new_c
parameter_list|)
name|chunk
modifier|*
name|chunk_list
decl_stmt|;
name|chunk
name|new_c
decl_stmt|;
block|{
name|chunk
name|c
init|=
operator|*
name|chunk_list
decl_stmt|;
comment|/* old beginning of list */
name|TRACE3
argument_list|(
literal|"  Inserting 0x%x at the beginning of 0x%x, before 0x%x.\n"
argument_list|,
name|new_c
argument_list|,
name|chunk_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|*
name|chunk_list
operator|=
name|new_c
expr_stmt|;
name|new_c
operator|->
name|next
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Thus, removing an element means we have to search until we find it.    Have to delete before we insert, since insertion changes the next    pointer, which we need to put it on the other list.  */
end_comment

begin_function
name|void
name|chunk_delete
parameter_list|(
name|chunk_list
parameter_list|,
name|dead_c
parameter_list|)
name|chunk
modifier|*
name|chunk_list
decl_stmt|;
name|chunk
name|dead_c
decl_stmt|;
block|{
name|chunk
name|c
init|=
operator|*
name|chunk_list
decl_stmt|;
name|chunk
name|prev_c
init|=
name|NULL
decl_stmt|;
name|TRACE2
argument_list|(
literal|"  Deleting 0x%x from 0x%x:"
argument_list|,
name|dead_c
argument_list|,
name|chunk_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|dead_c
operator|&&
name|c
operator|!=
name|NULL
condition|)
block|{
name|TRACE1
argument_list|(
literal|" 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|prev_c
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Chunk at 0x%x not found on list.\n"
argument_list|,
name|dead_c
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|prev_c
operator|==
name|NULL
condition|)
block|{
name|TRACE1
argument_list|(
literal|".\n  Setting head to 0x%x.\n"
argument_list|,
name|c
operator|->
name|next
argument_list|)
expr_stmt|;
operator|*
name|chunk_list
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|TRACE2
argument_list|(
literal|".\n  Linking next(0x%x) to 0x%x.\n"
argument_list|,
name|prev_c
argument_list|,
name|c
operator|->
name|next
argument_list|)
expr_stmt|;
name|prev_c
operator|->
name|next
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See if a list is hunky-dory.  */
end_comment

begin_function
name|void
name|validate_list
parameter_list|(
name|chunk_list
parameter_list|)
name|chunk
modifier|*
name|chunk_list
decl_stmt|;
block|{
name|chunk
name|c
decl_stmt|;
name|TRACE1
argument_list|(
literal|"  Validating list at 0x%x:"
argument_list|,
name|chunk_list
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|chunk_list
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
name|assert
argument_list|(
name|c
operator|->
name|user_size
operator|<
name|c
operator|->
name|alloc_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|memcmp
argument_list|(
name|chunk_to_mem
argument_list|(
name|c
argument_list|)
operator|+
name|c
operator|->
name|user_size
argument_list|,
literal|"Karl"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE2
argument_list|(
literal|" 0x%x/%d"
argument_list|,
name|c
argument_list|,
name|c
operator|->
name|user_size
argument_list|)
expr_stmt|;
block|}
name|TRACE
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See if we have a free chunk of a given size.  We'll take the first    one that is big enough.  */
end_comment

begin_function
name|chunk
name|free_list_available
parameter_list|(
name|needed
parameter_list|)
name|unsigned
name|needed
decl_stmt|;
block|{
name|chunk
name|c
decl_stmt|;
name|TRACE1
argument_list|(
literal|"  Checking free list for %d bytes:"
argument_list|,
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_list
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|free_list
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|USER_ALLOC
argument_list|(
name|c
argument_list|)
operator|<
name|needed
condition|)
block|{
name|TRACE2
argument_list|(
literal|" 0x%x/%d"
argument_list|,
name|c
argument_list|,
name|USER_ALLOC
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
name|TRACE1
argument_list|(
literal|"\n  Returning 0x%x.\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|address
name|malloc
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|n
decl_stmt|;
block|{
name|address
name|new_mem
decl_stmt|;
name|chunk
name|c
decl_stmt|;
name|TRACE1
argument_list|(
literal|"Mallocing %d bytes.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|validate_list
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|validate_list
argument_list|(
operator|&
name|alloc_list
argument_list|)
expr_stmt|;
name|c
operator|=
name|free_list_available
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* Nothing suitable on free list.  Allocate a new chunk.  */
name|TRACE
argument_list|(
literal|"  not on free list.\n"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|chunk
operator|)
name|xsbrk
argument_list|(
name|n
operator|+
name|MALLOC_OVERHEAD
argument_list|)
expr_stmt|;
name|c
operator|->
name|alloc_size
operator|=
name|n
operator|+
name|MALLOC_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
comment|/* Found something on free list.  Don't split it, just use as is.  */
name|TRACE
argument_list|(
literal|"  found on free list.\n"
argument_list|)
expr_stmt|;
name|chunk_delete
argument_list|(
operator|&
name|free_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* If we took this from the free list, then the user size might be      different now, and consequently the constant at the end might be in      the wrong place.  */
name|c
operator|->
name|user_size
operator|=
name|n
expr_stmt|;
name|new_mem
operator|=
name|chunk_to_mem
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_mem
operator|+
name|n
argument_list|,
literal|"Karl"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|chunk_insert
argument_list|(
operator|&
name|alloc_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|TRACE2
argument_list|(
literal|"Malloc returning 0x%x (chunk 0x%x).\n"
argument_list|,
name|new_mem
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|new_mem
return|;
block|}
end_function

begin_function
name|address
name|realloc
parameter_list|(
name|mem
parameter_list|,
name|n
parameter_list|)
name|address
name|mem
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
name|void
name|free
parameter_list|()
function_decl|;
name|chunk
name|c
init|=
name|mem_to_chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|address
name|new_mem
decl_stmt|;
name|TRACE3
argument_list|(
literal|"Reallocing %d bytes at 0x%x (chunk 0x%x).\n"
argument_list|,
name|n
argument_list|,
name|mem
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|new_mem
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_mem
argument_list|,
name|mem
argument_list|,
name|c
operator|->
name|user_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|new_mem
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|mem
parameter_list|)
name|address
name|mem
decl_stmt|;
block|{
name|chunk
name|c
init|=
name|mem_to_chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|TRACE2
argument_list|(
literal|"Freeing memory at 0x%x (chunk at 0x%x).\n"
argument_list|,
name|mem
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|validate_list
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|validate_list
argument_list|(
operator|&
name|alloc_list
argument_list|)
expr_stmt|;
name|chunk_delete
argument_list|(
operator|&
name|alloc_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|chunk_insert
argument_list|(
operator|&
name|free_list
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

