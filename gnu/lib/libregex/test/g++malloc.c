begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|inline
end_define

begin_comment
comment|/* Copyright (C) 1989 Free Software Foundation     written by Doug Lea (dl@oswego.edu)  This file is part of GNU CC.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU CC General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU CC, but only under the conditions described in the GNU CC General Public License.   A copy of this license is supposed to have been given to you along with GNU CC so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_LIBGXX_MALLOC
end_ifndef

begin_comment
comment|/* ignore whole file otherwise */
end_comment

begin_comment
comment|/* compile with -DMALLOC_STATS to collect statistics */
end_comment

begin_comment
comment|/* collecting statistics slows down malloc by at least 15% */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_define
define|#
directive|define
name|UPDATE_STATS
parameter_list|(
name|ARGS
parameter_list|)
value|{ARGS;}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UPDATE_STATS
parameter_list|(
name|ARGS
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* History      Tue Jan 16 04:54:27 1990  Doug Lea  (dl at g.oswego.edu)       version 1 released in libg++     Sun Jan 21 05:52:47 1990  Doug Lea  (dl at g.oswego.edu)       bins are now own struct for, sanity.       new victim search strategy: scan up and consolidate.      Both faster and less fragmentation.       refined when to scan bins for consolidation, via consollink, etc.       realloc: always try to expand chunk, avoiding some fragmentation.       changed a few inlines into macros       hardwired SBRK_UNIT to 4096 for uniformity across systems     Tue Mar 20 14:18:23 1990  Doug Lea  (dl at g.oswego.edu)       calloc and cfree now correctly parameterized.     Sun Apr  1 10:00:48 1990  Doug Lea  (dl at g.oswego.edu)       added memalign and valloc.     Sun Jun 24 05:46:48 1990  Doug Lea  (dl at g.oswego.edu)       #include gepagesize.h only ifndef sun      cache pagesize after first call     Wed Jul 25 08:35:19 1990  Doug Lea  (dl at g.oswego.edu)       No longer rely on a `designated victim':         1. It sometimes caused splits of large chunks           when smaller ones would do, leading to           bad worst-case fragmentation.         2. Scanning through the av array fast anyway,           so the overhead isn't worth it.       To compensate, several other minor changes:         1. Unusable chunks are checked for consolidation during           searches inside bins, better distributing chunks           across bins.         2. Chunks are returned when found in malloc_find_space,            rather than finishing cleaning everything up, to            avoid wasted iterations due to (1). */
end_comment

begin_comment
comment|/*   A version of malloc/free/realloc tuned for C++ applications.    Here's what you probably want to know first:    In various tests, this appears to be about as fast as,   and usually substantially less memory-wasteful than BSD/GNUemacs malloc.    Generally, it is slower (by perhaps 20%) than bsd-style malloc   only when bsd malloc would waste a great deal of space in   fragmented blocks, which this malloc recovers; or when, by   chance or design, nearly all requests are near the bsd malloc   power-of-2 allocation bin boundaries, and as many chunks are   used as are allocated.    It uses more space than bsd malloc only when, again by chance   or design, only bsdmalloc bin-sized requests are malloced, or when   little dynamic space is malloced, since this malloc may grab larger   chunks from the system at a time than bsd.    In other words, this malloc seems generally superior to bsd   except perhaps for programs that are specially tuned to   deal with bsdmalloc's characteristics. But even here, the   performance differences are slight.     This malloc, like any other, is a compromised design.     Chunks of memory are maintained using a `boundary tag' method as   described in e.g., Knuth or Standish.  This means that the size of   the chunk is stored both in the front of the chunk and at the end.   This makes consolidating fragmented chunks into bigger chunks very fast.   The size field is also used to hold bits representing whether a   chunk is free or in use.    Malloced chunks have space overhead of 8 bytes: The preceding   and trailing size fields. When they are freed, the list pointer   fields are also needed.    Available chunks are kept in doubly linked lists. The lists are   maintained in an array of bins using a power-of-two method, except   that instead of 32 bins (one for each 1<< i), there are 128: each   power of two is split in quarters. The use of very fine bin sizes   closely approximates the use of one bin per actually used size,   without necessitating the overhead of locating such bins. It is   especially desirable in common C++ applications where large numbers   of identically-sized blocks are malloced/freed in some dynamic   manner, and then later are all freed. The finer bin sizes make   finding blocks fast, with little wasted overallocation. The   consolidation methods ensure that once the collection of blocks is   no longer useful, fragments are gathered into bigger chunks awaiting new   roles.    The bins av[i] serve as heads of the lists. Bins contain a dummy   header for the chunk lists, and a `dirty' field used to indicate   whether the list may need to be scanned for consolidation.    On allocation, the bin corresponding to the request size is   scanned, and if there is a chunk with size>= requested, it   is split, if too big, and used. Chunks on the list which are   too small are examined for consolidation during this traversal.    If no chunk exists in the list bigger bins are scanned in search of   a victim.    If no victim can be found, then smaller bins are examined for   consolidation in order to construct a victim.    Finally, if consolidation fails to come up with a usable chunk,   more space is obtained from the system.    After a split, the remainder is placed on   the back of the appropriate bin list. (All freed chunks are placed   on fronts of lists. All remaindered or consolidated chunks are   placed on the rear. Correspondingly, searching within a bin   starts at the front, but finding victims is from the back. All   of this approximates  the  effect of having 2 kinds of lists per   bin: returned chunks vs unallocated chunks, but without the overhead   of maintaining 2 lists.)    Deallocation (free) consists only of placing the chunk on   a list.    Reallocation proceeds in the usual way. If a chunk can be extended,   it is, else a malloc-copy-free sequence is taken.    memalign requests more than enough space from malloc, finds a   spot within that chunk that meets the alignment request, and   then possibly frees the leading and trailing space. Overreliance   on memalign is a sure way to fragment space.     Some other implementation matters:    8 byte alignment is currently hardwired into the design. Calling   memalign will return a chunk that is both 8-byte aligned, and   meets the requested alignment.    The basic overhead of a used chunk is 8 bytes: 4 at the front and   4 at the end.    When a chunk is free, 8 additional bytes are needed for free list   pointers. Thus, the minimum allocatable size is 16 bytes.    The existence of front and back overhead permits some reasonably   effective fence-bashing checks: The front and back fields must   be identical. This is checked only within free() and realloc().   The checks are fast enough to be made non-optional.    The overwriting of parts of freed memory with the freelist pointers   can also be very effective (albeit in an annoying way) in helping   users track down dangling pointers.    User overwriting of freed space will often result in crashes   within malloc or free.    These routines are also tuned to C++ in that free(0) is a noop and   a failed malloc automatically calls (*new_handler)().    malloc(0) returns a pointer to something of the minimum allocatable size.    Additional memory is gathered from the system (via sbrk) in a   way that allows chunks obtained across different sbrk calls to   be consolidated, but does not require contiguous memory: Thus,   it should be safe to intersperse mallocs with other sbrk calls.    This malloc is NOT designed to work in multiprocessing applications.   No semaphores or other concurrency control are provided to ensure   that multiple malloc or free calls don't run at the same time,   which could be disasterous.    VERY heavy use of inlines is made, for clarity. If this malloc   is ported via a compiler without inlining capabilities, all   inlines should be transformed into macros -- making them non-inline   makes malloc at least twice as slow.   */
end_comment

begin_escape
end_escape

begin_comment
comment|/* preliminaries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"//usr/include/stdio.h"
end_include

begin_comment
comment|/* needed for error reporting */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USG
specifier|extern
name|void
modifier|*
name|memset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/*inline void      bzero(void* s, int l) { memset(s, 0, l); }*/
else|#
directive|else
comment|/*extern void      bzero(void*, unsigned int);*/
endif|#
directive|endif
comment|/*extern void      bcopy(void*, void*, unsigned int);*/
specifier|extern
name|void
modifier|*
name|sbrk
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
comment|/* Put this in instead of commmented out stuff above.  */
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy((d),(s),(n))
define|#
directive|define
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|memcmp((s1),(s2),(n))
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset((s),0,(n))
ifdef|#
directive|ifdef
name|__GNUC__
specifier|extern
specifier|volatile
name|void
name|abort
parameter_list|()
function_decl|;
else|#
directive|else
specifier|extern
name|void
name|abort
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* end of extern "C" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A good multiple to call sbrk with */
end_comment

begin_define
define|#
directive|define
name|SBRK_UNIT
value|4096
end_define

begin_comment
comment|/* how to die on detected error */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_expr_stmt
specifier|static
specifier|volatile
name|void
name|malloc_user_error
argument_list|()
else|#
directive|else
specifier|static
name|void
name|malloc_user_error
argument_list|()
endif|#
directive|endif
block|{
name|fputs
argument_list|(
literal|"malloc/free/realloc: clobbered space detected\n"
argument_list|,
name|stderr
argument_list|)
block|;
name|abort
argument_list|()
block|; }
comment|/*  Basic overhead for each malloc'ed chunk */
expr|struct
name|malloc_chunk
block|{
name|unsigned
name|int
name|size
block|;
comment|/* Size in bytes, including overhead. */
comment|/* Or'ed with INUSE if in use. */
block|struct
name|malloc_chunk
operator|*
name|fd
block|;
comment|/* double links -- used only if free. */
block|struct
name|malloc_chunk
operator|*
name|bk
block|;  }
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|mchunkptr
typedef|;
end_typedef

begin_struct
struct|struct
name|malloc_bin
block|{
name|struct
name|malloc_chunk
name|hd
decl_stmt|;
comment|/* dummy list header */
name|unsigned
name|int
name|dirty
decl_stmt|;
comment|/* True if maybe consolidatable */
comment|/* Wasting a word here makes */
comment|/* sizeof(bin) a power of 2, */
comment|/* which makes size2bin() faster */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|malloc_bin
modifier|*
name|mbinptr
typedef|;
end_typedef

begin_comment
comment|/*  sizes, alignments */
end_comment

begin_define
define|#
directive|define
name|SIZE_SZ
value|(sizeof(unsigned int))
end_define

begin_define
define|#
directive|define
name|MALLOC_MIN_OVERHEAD
value|(SIZE_SZ + SIZE_SZ)
end_define

begin_define
define|#
directive|define
name|MALLOC_ALIGN_MASK
value|(MALLOC_MIN_OVERHEAD - 1)
end_define

begin_define
define|#
directive|define
name|MINSIZE
value|(sizeof(struct malloc_chunk) + SIZE_SZ)
end_define

begin_comment
comment|/* MUST == 16! */
end_comment

begin_comment
comment|/* pad request bytes into a usable size */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|request2size
parameter_list|(
name|unsigned
name|int
name|request
parameter_list|)
block|{
return|return
operator|(
name|request
operator|==
literal|0
operator|)
condition|?
name|MINSIZE
else|:
operator|(
operator|(
name|request
operator|+
name|MALLOC_MIN_OVERHEAD
operator|+
name|MALLOC_ALIGN_MASK
operator|)
operator|&
operator|~
operator|(
name|MALLOC_ALIGN_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|aligned_OK
parameter_list|(
name|void
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|m
argument_list|)
operator|&
operator|(
name|MALLOC_ALIGN_MASK
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* size field or'd with INUSE when in use */
end_comment

begin_define
define|#
directive|define
name|INUSE
value|0x1
end_define

begin_escape
end_escape

begin_comment
comment|/* the bins, initialized to have null double linked lists */
end_comment

begin_define
define|#
directive|define
name|MAXBIN
value|120
end_define

begin_comment
comment|/* 1 more than needed for 32 bit addresses */
end_comment

begin_define
define|#
directive|define
name|FIRSTBIN
value|(&(av[0]))
end_define

begin_decl_stmt
specifier|static
name|struct
name|malloc_bin
name|av
index|[
name|MAXBIN
index|]
init|=
block|{
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|0
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|0
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|1
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|1
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|2
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|2
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|3
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|3
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|4
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|4
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|5
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|5
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|6
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|6
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|7
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|7
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|8
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|8
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|9
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|9
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|10
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|10
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|11
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|11
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|12
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|12
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|13
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|13
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|14
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|14
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|15
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|15
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|16
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|16
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|17
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|17
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|18
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|18
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|19
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|19
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|20
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|20
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|21
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|21
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|22
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|22
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|23
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|23
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|24
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|24
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|25
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|25
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|26
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|26
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|27
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|27
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|28
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|28
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|29
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|29
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|30
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|30
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|31
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|31
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|32
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|32
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|33
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|33
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|34
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|34
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|35
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|35
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|36
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|36
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|37
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|37
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|38
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|38
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|39
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|39
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|40
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|40
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|41
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|41
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|42
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|42
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|43
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|43
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|44
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|44
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|45
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|45
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|46
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|46
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|47
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|47
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|48
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|48
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|49
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|49
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|50
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|50
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|51
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|51
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|52
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|52
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|53
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|53
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|54
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|54
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|55
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|55
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|56
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|56
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|57
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|57
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|58
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|58
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|59
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|59
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|60
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|60
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|61
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|61
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|62
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|62
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|63
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|63
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|64
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|64
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|65
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|65
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|66
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|66
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|67
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|67
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|68
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|68
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|69
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|69
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|70
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|70
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|71
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|71
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|72
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|72
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|73
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|73
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|74
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|74
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|75
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|75
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|76
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|76
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|77
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|77
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|78
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|78
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|79
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|79
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|80
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|80
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|81
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|81
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|82
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|82
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|83
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|83
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|84
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|84
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|85
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|85
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|86
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|86
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|87
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|87
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|88
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|88
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|89
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|89
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|90
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|90
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|91
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|91
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|92
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|92
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|93
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|93
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|94
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|94
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|95
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|95
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|96
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|96
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|97
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|97
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|98
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|98
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|99
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|99
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|100
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|100
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|101
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|101
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|102
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|102
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|103
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|103
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|104
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|104
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|105
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|105
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|106
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|106
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|107
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|107
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|108
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|108
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|109
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|109
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|110
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|110
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|111
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|111
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|112
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|112
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|113
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|113
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|114
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|114
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|115
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|115
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|116
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|116
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|117
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|117
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|118
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|118
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
literal|0
block|,
operator|&
operator|(
name|av
index|[
literal|119
index|]
operator|.
name|hd
operator|)
block|,
operator|&
operator|(
name|av
index|[
literal|119
index|]
operator|.
name|hd
operator|)
block|}
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   indexing into bins */
end_comment

begin_function
specifier|static
specifier|inline
name|mbinptr
name|size2bin
parameter_list|(
name|unsigned
name|int
name|sz
parameter_list|)
block|{
name|mbinptr
name|b
init|=
name|av
decl_stmt|;
while|while
condition|(
name|sz
operator|>=
operator|(
name|MINSIZE
operator|*
literal|2
operator|)
condition|)
block|{
name|b
operator|+=
literal|4
expr_stmt|;
name|sz
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* find power of 2 */
name|b
operator|+=
operator|(
name|sz
operator|-
name|MINSIZE
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* find quadrant */
return|return
name|b
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* counts maintained if MALLOC_STATS defined */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sbrked_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|requested_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|malloced_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|freed_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_used_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_sbrks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_mallocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_frees
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_reallocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_reallocs_with_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_inuse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_malloc_chunks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_malloc_bins
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_split
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_consol
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|do_malloc_stats
parameter_list|(
specifier|const
name|mchunkptr
name|p
parameter_list|)
block|{
operator|++
name|n_mallocs
expr_stmt|;
if|if
condition|(
operator|(
name|n_mallocs
operator|-
name|n_frees
operator|)
operator|>
name|max_inuse
condition|)
name|max_inuse
operator|=
name|n_mallocs
operator|-
name|n_frees
expr_stmt|;
name|malloced_mem
operator|+=
operator|(
name|p
operator|->
name|size
operator|&
operator|~
operator|(
name|INUSE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|malloced_mem
operator|-
name|freed_mem
operator|>
name|max_used_mem
condition|)
name|max_used_mem
operator|=
name|malloced_mem
operator|-
name|freed_mem
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_stats
parameter_list|(
specifier|const
name|mchunkptr
name|p
parameter_list|)
block|{
operator|++
name|n_frees
expr_stmt|;
name|freed_mem
operator|+=
operator|(
name|p
operator|->
name|size
operator|&
operator|~
operator|(
name|INUSE
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Utilities needed below for memalign */
end_comment

begin_comment
comment|/* This is redundant with libg++ support, but not if used stand-alone */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|gcd
parameter_list|(
name|unsigned
name|int
name|a
parameter_list|,
name|unsigned
name|int
name|b
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|b
operator|>
name|a
condition|)
block|{
name|tmp
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|tmp
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|a
return|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|1
condition|)
return|return
name|b
return|;
else|else
block|{
name|tmp
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|a
operator|%
name|b
expr_stmt|;
name|a
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|lcm
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|/
name|gcd
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|*
name|y
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* maintaining INUSE via size field */
end_comment

begin_define
define|#
directive|define
name|inuse
parameter_list|(
name|p
parameter_list|)
value|((p)->size& INUSE)
end_define

begin_define
define|#
directive|define
name|set_inuse
parameter_list|(
name|p
parameter_list|)
value|((p)->size |= INUSE)
end_define

begin_define
define|#
directive|define
name|clear_inuse
parameter_list|(
name|b
parameter_list|)
value|((p)->size&= ~INUSE)
end_define

begin_comment
comment|/* operations on  malloc_chunk addresses */
end_comment

begin_comment
comment|/* return ptr to next physical malloc_chunk */
end_comment

begin_define
define|#
directive|define
name|next_chunk
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)((char*)(p) + (p)->size))
end_define

begin_comment
comment|/* return ptr to previous physical malloc_chunk */
end_comment

begin_define
define|#
directive|define
name|prev_chunk
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)((char*)(p)-((((int*)(p))[-1])& ~(INUSE))))
end_define

begin_comment
comment|/* place size at front and back of chunk */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_size
parameter_list|(
name|mchunkptr
name|p
parameter_list|,
name|unsigned
name|int
name|sz
parameter_list|)
block|{
name|p
operator|->
name|size
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|sz
operator|-
name|SIZE_SZ
operator|)
operator|)
operator|=
name|sz
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* conversion from malloc headers to user pointers, and back */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|chunk2mem
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|set_inuse
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|SIZE_SZ
operator|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* xxxx my own */
end_comment

begin_function
name|mchunkptr
name|sanity_check
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|mchunkptr
name|p
init|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|mem
operator|)
operator|-
name|SIZE_SZ
argument_list|)
decl_stmt|;
comment|/* a quick sanity check */
name|unsigned
name|int
name|sz
init|=
name|p
operator|->
name|size
operator|&
operator|~
operator|(
name|INUSE
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|==
name|sz
operator|||
name|sz
operator|!=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|sz
operator|-
name|SIZE_SZ
operator|)
operator|)
condition|)
name|malloc_user_error
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|mchunkptr
name|mem2chunk
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|mchunkptr
name|p
init|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|mem
operator|)
operator|-
name|SIZE_SZ
argument_list|)
decl_stmt|;
comment|/* a quick sanity check */
name|unsigned
name|int
name|sz
init|=
name|p
operator|->
name|size
operator|&
operator|~
operator|(
name|INUSE
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|==
name|sz
operator|||
name|sz
operator|!=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|sz
operator|-
name|SIZE_SZ
operator|)
operator|)
condition|)
name|malloc_user_error
argument_list|()
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|sz
expr_stmt|;
comment|/* clears INUSE */
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* maintaining bins& pointers */
end_comment

begin_comment
comment|/* maximum bin actually used */
end_comment

begin_decl_stmt
specifier|static
name|mbinptr
name|malloc_maxbin
init|=
name|FIRSTBIN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* operations on lists inside bins */
end_comment

begin_comment
comment|/* take a chunk off a list */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|unlink
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
block|{
name|mchunkptr
name|b
init|=
name|p
operator|->
name|bk
decl_stmt|;
name|mchunkptr
name|f
init|=
name|p
operator|->
name|fd
decl_stmt|;
name|f
operator|->
name|bk
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|fd
operator|=
name|f
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|--
name|n_avail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* split a chunk and place on the back of a list */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|split
parameter_list|(
name|mchunkptr
name|p
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
name|unsigned
name|int
name|room
init|=
name|p
operator|->
name|size
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|room
operator|>=
name|MINSIZE
condition|)
block|{
name|mbinptr
name|bn
init|=
name|size2bin
argument_list|(
name|room
argument_list|)
decl_stmt|;
comment|/* new bin */
name|mchunkptr
name|h
init|=
operator|&
operator|(
name|bn
operator|->
name|hd
operator|)
decl_stmt|;
comment|/* its head */
name|mchunkptr
name|b
init|=
name|h
operator|->
name|bk
decl_stmt|;
comment|/* old back element */
name|mchunkptr
name|t
init|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|offset
argument_list|)
decl_stmt|;
comment|/* remaindered chunk */
comment|/* set size */
name|t
operator|->
name|size
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|t
operator|)
operator|+
name|room
operator|-
name|SIZE_SZ
operator|)
operator|)
operator|=
name|room
expr_stmt|;
comment|/* link up */
name|t
operator|->
name|bk
operator|=
name|b
expr_stmt|;
name|t
operator|->
name|fd
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|bk
operator|=
name|b
operator|->
name|fd
operator|=
name|t
expr_stmt|;
comment|/* adjust maxbin (h == b means was empty) */
if|if
condition|(
name|h
operator|==
name|b
operator|&&
name|bn
operator|>
name|malloc_maxbin
condition|)
name|malloc_maxbin
operator|=
name|bn
expr_stmt|;
comment|/* adjust size of chunk to be returned */
name|p
operator|->
name|size
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|offset
operator|-
name|SIZE_SZ
operator|)
operator|)
operator|=
name|offset
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|(
operator|++
name|n_split
operator|,
operator|++
name|n_avail
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* place a consolidated chunk on the back of a list */
end_comment

begin_comment
comment|/* like above, except no split */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|consollink
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
block|{
name|mbinptr
name|bn
init|=
name|size2bin
argument_list|(
name|p
operator|->
name|size
argument_list|)
decl_stmt|;
name|mchunkptr
name|h
init|=
operator|&
operator|(
name|bn
operator|->
name|hd
operator|)
decl_stmt|;
name|mchunkptr
name|b
init|=
name|h
operator|->
name|bk
decl_stmt|;
name|p
operator|->
name|bk
operator|=
name|b
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|bk
operator|=
name|b
operator|->
name|fd
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|b
operator|&&
name|bn
operator|>
name|malloc_maxbin
condition|)
name|malloc_maxbin
operator|=
name|bn
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_avail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* place a freed chunk on the front of a list */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|frontlink
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
block|{
name|mbinptr
name|bn
init|=
name|size2bin
argument_list|(
name|p
operator|->
name|size
argument_list|)
decl_stmt|;
name|mchunkptr
name|h
init|=
operator|&
operator|(
name|bn
operator|->
name|hd
operator|)
decl_stmt|;
name|mchunkptr
name|f
init|=
name|h
operator|->
name|fd
decl_stmt|;
name|p
operator|->
name|bk
operator|=
name|h
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|bk
operator|=
name|h
operator|->
name|fd
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|f
operator|&&
name|bn
operator|>
name|malloc_maxbin
condition|)
name|malloc_maxbin
operator|=
name|bn
expr_stmt|;
name|bn
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_avail
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dealing with sbrk */
end_comment

begin_comment
comment|/* To link consecutive sbrk regions when possible */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|last_sbrk_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  who to call when sbrk returns failure */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_NEW_HANDLER
end_ifndef

begin_typedef
typedef|typedef
specifier|volatile
name|void
function_decl|(
modifier|*
name|vfp
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
name|vfp
name|__new_handler
decl_stmt|;
end_extern

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|vfp
name|__new_handler
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|mchunkptr
name|malloc_from_sys
parameter_list|(
name|unsigned
name|nb
parameter_list|)
block|{
name|mchunkptr
name|p
decl_stmt|;
name|unsigned
name|int
name|sbrk_size
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
comment|/* Minimally, we need to pad with enough space */
comment|/* to place dummy size/use fields to ends if needed */
name|sbrk_size
operator|=
operator|(
operator|(
name|nb
operator|+
name|SBRK_UNIT
operator|-
literal|1
operator|+
name|SIZE_SZ
operator|+
name|SIZE_SZ
operator|)
operator|/
name|SBRK_UNIT
operator|)
operator|*
name|SBRK_UNIT
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|sbrk
argument_list|(
name|sbrk_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
condition|)
comment|/* sbrk returns -1 on failure */
block|{
ifndef|#
directive|ifndef
name|NO_NEW_HANDLER
call|(
modifier|*
name|__new_handler
call|)
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|UPDATE_STATS
argument_list|(
operator|(
operator|++
name|n_sbrks
operator|,
name|sbrked_mem
operator|+=
name|sbrk_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_sbrk_end
operator|!=
operator|&
name|ip
index|[
operator|-
literal|1
index|]
condition|)
block|{
comment|/* It's either first time through or someone else called sbrk. */
comment|/* Arrange end-markers at front& back */
comment|/* Shouldn't be necessary, but better to be safe */
while|while
condition|(
operator|!
name|aligned_OK
argument_list|(
name|ip
argument_list|)
condition|)
block|{
operator|++
name|ip
expr_stmt|;
name|sbrk_size
operator|-=
name|SIZE_SZ
expr_stmt|;
block|}
comment|/* Mark the front as in use to prevent merging. */
comment|/* Note we can get away with only 1 word, not MINSIZE overhead here */
operator|*
name|ip
operator|++
operator|=
name|SIZE_SZ
operator||
name|INUSE
expr_stmt|;
name|p
operator|=
operator|(
name|mchunkptr
operator|)
name|ip
expr_stmt|;
name|set_size
argument_list|(
name|p
argument_list|,
name|sbrk_size
operator|-
operator|(
name|SIZE_SZ
operator|+
name|SIZE_SZ
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mchunkptr
name|l
decl_stmt|;
comment|/* We can safely make the header start at end of prev sbrked chunk. */
comment|/* We will still have space left at the end from a previous call */
comment|/* to place the end marker, below */
name|p
operator|=
call|(
name|mchunkptr
call|)
argument_list|(
name|last_sbrk_end
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|p
argument_list|,
name|sbrk_size
argument_list|)
expr_stmt|;
comment|/* Even better, maybe we can merge with last fragment: */
name|l
operator|=
name|prev_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inuse
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|l
argument_list|,
name|p
operator|->
name|size
operator|+
name|l
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|/* mark the end of sbrked space as in use to prevent merging */
name|last_sbrk_end
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|p
operator|->
name|size
operator|)
expr_stmt|;
operator|*
name|last_sbrk_end
operator|=
name|SIZE_SZ
operator||
name|INUSE
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|(
operator|++
name|n_avail
operator|,
operator|++
name|n_malloc_chunks
operator|)
argument_list|)
expr_stmt|;
comment|/* make it safe to unlink in malloc */
name|UPDATE_STATS
argument_list|(
operator|++
name|n_avail
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|p
operator|->
name|bk
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Consolidate dirty bins. */
end_comment

begin_comment
comment|/* Stop if found a chunk big enough to satisfy current malloc request */
end_comment

begin_comment
comment|/* (It requires much less bookkeeping to consolidate entire bins */
end_comment

begin_comment
comment|/* at once than to keep records of which chunks might be */
end_comment

begin_comment
comment|/* consolidatable. So long as the lists are short, which we */
end_comment

begin_comment
comment|/* try to ensure via small bin ranges, there is little wasted effort.) */
end_comment

begin_function
specifier|static
name|mchunkptr
name|malloc_find_space
parameter_list|(
name|unsigned
name|int
name|nb
parameter_list|)
block|{
name|mbinptr
name|b
decl_stmt|;
comment|/* first, re-adjust max used bin */
while|while
condition|(
name|malloc_maxbin
operator|>=
name|FIRSTBIN
operator|&&
name|malloc_maxbin
operator|->
name|hd
operator|.
name|bk
operator|==
operator|&
operator|(
name|malloc_maxbin
operator|->
name|hd
operator|)
condition|)
block|{
name|malloc_maxbin
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
operator|--
name|malloc_maxbin
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
name|malloc_maxbin
init|;
name|b
operator|>=
name|FIRSTBIN
condition|;
operator|--
name|b
control|)
block|{
name|UPDATE_STATS
argument_list|(
operator|++
name|n_malloc_bins
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dirty
condition|)
block|{
name|mchunkptr
name|h
init|=
operator|&
operator|(
name|b
operator|->
name|hd
operator|)
decl_stmt|;
comment|/* head of list */
name|mchunkptr
name|p
init|=
name|h
operator|->
name|fd
decl_stmt|;
comment|/* chunk traverser */
while|while
condition|(
name|p
operator|!=
name|h
condition|)
block|{
name|mchunkptr
name|nextp
init|=
name|p
operator|->
name|fd
decl_stmt|;
comment|/* save, in case of relinks */
name|int
name|consolidated
init|=
literal|0
decl_stmt|;
comment|/* only unlink/relink if consolidated */
name|mchunkptr
name|t
decl_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_malloc_chunks
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|inuse
argument_list|(
name|t
operator|=
name|prev_chunk
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
comment|/* consolidate backward */
block|{
if|if
condition|(
operator|!
name|consolidated
condition|)
block|{
name|consolidated
operator|=
literal|1
expr_stmt|;
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|nextp
condition|)
name|nextp
operator|=
name|t
operator|->
name|fd
expr_stmt|;
name|unlink
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|size
operator|+
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_consol
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|inuse
argument_list|(
name|t
operator|=
name|next_chunk
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
comment|/* consolidate forward */
block|{
if|if
condition|(
operator|!
name|consolidated
condition|)
block|{
name|consolidated
operator|=
literal|1
expr_stmt|;
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|nextp
condition|)
name|nextp
operator|=
name|t
operator|->
name|fd
expr_stmt|;
name|unlink
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|size
operator|+
name|t
operator|->
name|size
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_consol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|consolidated
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|size
operator|>=
name|nb
condition|)
block|{
comment|/* make it safe to unlink in malloc */
name|UPDATE_STATS
argument_list|(
operator|++
name|n_avail
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|p
operator|->
name|bk
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
name|consollink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|nextp
expr_stmt|;
block|}
name|b
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* nothing available - sbrk some more */
return|return
name|malloc_from_sys
argument_list|(
name|nb
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*   Finally, the user-level functions  */
end_comment

begin_function
name|void
modifier|*
name|malloc
parameter_list|(
name|unsigned
name|int
name|bytes
parameter_list|)
block|{
name|unsigned
name|int
name|nb
init|=
name|request2size
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|/* padded request size */
name|mbinptr
name|b
init|=
name|size2bin
argument_list|(
name|nb
argument_list|)
decl_stmt|;
comment|/* corresponding bin */
name|mchunkptr
name|hd
init|=
operator|&
operator|(
name|b
operator|->
name|hd
operator|)
decl_stmt|;
comment|/* head of its list */
name|mchunkptr
name|p
init|=
name|hd
operator|->
name|fd
decl_stmt|;
comment|/* chunk traverser */
name|UPDATE_STATS
argument_list|(
operator|(
name|requested_mem
operator|+=
name|bytes
operator|,
operator|++
name|n_malloc_bins
operator|)
argument_list|)
expr_stmt|;
comment|/* Try a (near) exact match in own bin */
comment|/* clean out unusable but consolidatable chunks in bin while traversing */
while|while
condition|(
name|p
operator|!=
name|hd
condition|)
block|{
name|UPDATE_STATS
argument_list|(
operator|++
name|n_malloc_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|>=
name|nb
condition|)
goto|goto
name|found
goto|;
else|else
comment|/* try to consolidate; same code as malloc_find_space */
block|{
name|mchunkptr
name|nextp
init|=
name|p
operator|->
name|fd
decl_stmt|;
comment|/* save, in case of relinks */
name|int
name|consolidated
init|=
literal|0
decl_stmt|;
comment|/* only unlink/relink if consolidated */
name|mchunkptr
name|t
decl_stmt|;
while|while
condition|(
operator|!
name|inuse
argument_list|(
name|t
operator|=
name|prev_chunk
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
comment|/* consolidate backward */
block|{
if|if
condition|(
operator|!
name|consolidated
condition|)
block|{
name|consolidated
operator|=
literal|1
expr_stmt|;
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|nextp
condition|)
name|nextp
operator|=
name|t
operator|->
name|fd
expr_stmt|;
name|unlink
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|size
operator|+
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_consol
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|inuse
argument_list|(
name|t
operator|=
name|next_chunk
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
comment|/* consolidate forward */
block|{
if|if
condition|(
operator|!
name|consolidated
condition|)
block|{
name|consolidated
operator|=
literal|1
expr_stmt|;
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|nextp
condition|)
name|nextp
operator|=
name|t
operator|->
name|fd
expr_stmt|;
name|unlink
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|size
operator|+
name|t
operator|->
name|size
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_consol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|consolidated
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|size
operator|>=
name|nb
condition|)
block|{
comment|/* make it safe to unlink again below */
name|UPDATE_STATS
argument_list|(
operator|++
name|n_avail
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|p
operator|->
name|bk
operator|=
name|p
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
name|consollink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|nextp
expr_stmt|;
block|}
block|}
name|b
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
comment|/* true if got here */
comment|/*  Scan bigger bins for a victim */
while|while
condition|(
operator|++
name|b
operator|<=
name|malloc_maxbin
condition|)
block|{
name|UPDATE_STATS
argument_list|(
operator|++
name|n_malloc_bins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|b
operator|->
name|hd
operator|.
name|bk
operator|)
operator|!=
operator|&
operator|(
name|b
operator|->
name|hd
operator|)
condition|)
comment|/* no need to check size */
goto|goto
name|found
goto|;
block|}
comment|/* Consolidate or sbrk */
name|p
operator|=
name|malloc_find_space
argument_list|(
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* allocation failure */
name|found
label|:
comment|/* Use what we found */
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|split
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
name|do_malloc_stats
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|UPDATE_STATS
argument_list|(
name|do_free_stats
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|frontlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|calloc
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|int
name|elem_size
parameter_list|)
block|{
name|unsigned
name|int
name|sz
init|=
name|n
operator|*
name|elem_size
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* This is here for compatibility with older systems */
end_comment

begin_function
name|void
name|cfree
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|malloc_usable_size
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|mchunkptr
name|p
init|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|mem
operator|)
operator|-
name|SIZE_SZ
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|sz
init|=
name|p
operator|->
name|size
operator|&
operator|~
operator|(
name|INUSE
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|==
name|sz
operator|||
name|sz
operator|!=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|sz
operator|-
name|SIZE_SZ
operator|)
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|sz
operator|-
name|MALLOC_MIN_OVERHEAD
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|unsigned
name|int
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
name|malloc
argument_list|(
name|bytes
argument_list|)
return|;
else|else
block|{
name|unsigned
name|int
name|nb
init|=
name|request2size
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|oldsize
init|=
name|p
operator|->
name|size
decl_stmt|;
name|int
name|room
decl_stmt|;
name|mchunkptr
name|nxt
decl_stmt|;
name|UPDATE_STATS
argument_list|(
operator|(
operator|++
name|n_reallocs
operator|,
name|requested_mem
operator|+=
name|bytes
operator|-
name|oldsize
operator|)
argument_list|)
expr_stmt|;
comment|/* try to expand (even if already big enough), to clean up chunk */
while|while
condition|(
operator|!
name|inuse
argument_list|(
name|nxt
operator|=
name|next_chunk
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|UPDATE_STATS
argument_list|(
operator|(
name|malloced_mem
operator|+=
name|nxt
operator|->
name|size
operator|,
operator|++
name|n_consol
operator|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|set_size
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|size
operator|+
name|nxt
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|room
operator|=
name|p
operator|->
name|size
operator|-
name|nb
expr_stmt|;
if|if
condition|(
name|room
operator|>=
literal|0
condition|)
block|{
name|split
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
name|malloced_mem
operator|-=
name|room
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
else|else
comment|/* do the obvious */
block|{
name|void
modifier|*
name|newmem
decl_stmt|;
name|set_inuse
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* don't let malloc consolidate us yet! */
name|newmem
operator|=
name|malloc
argument_list|(
name|nb
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mem
argument_list|,
name|newmem
argument_list|,
name|oldsize
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
operator|++
name|n_reallocs_with_copy
argument_list|)
expr_stmt|;
return|return
name|newmem
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* return a pointer to space with at least the alignment requested */
end_comment

begin_function
name|void
modifier|*
name|memalign
parameter_list|(
name|unsigned
name|int
name|alignment
parameter_list|,
name|unsigned
name|int
name|bytes
parameter_list|)
block|{
name|mchunkptr
name|p
decl_stmt|;
name|unsigned
name|int
name|nb
init|=
name|request2size
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|/* find an alignment that both we and the user can live with: */
comment|/* least common multiple guarantees mutual happiness */
name|unsigned
name|int
name|align
init|=
name|lcm
argument_list|(
name|alignment
argument_list|,
name|MALLOC_MIN_OVERHEAD
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
name|align
operator|-
literal|1
decl_stmt|;
comment|/* call malloc with worst case padding to hit alignment; */
comment|/* we will give back extra */
name|unsigned
name|int
name|req
init|=
name|nb
operator|+
name|align
operator|+
name|MINSIZE
decl_stmt|;
name|void
modifier|*
name|m
init|=
name|malloc
argument_list|(
name|req
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|m
return|;
name|p
operator|=
name|mem2chunk
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* keep statistics on track */
name|UPDATE_STATS
argument_list|(
operator|--
name|n_mallocs
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
name|malloced_mem
operator|-=
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
name|requested_mem
operator|-=
name|req
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
name|requested_mem
operator|+=
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|int
call|)
argument_list|(
name|m
argument_list|)
operator|&
operator|(
name|mask
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* misaligned */
block|{
comment|/* find an aligned spot inside chunk */
name|mchunkptr
name|ap
init|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|m
argument_list|)
operator|+
name|mask
operator|)
operator|&
operator|-
name|align
operator|)
operator|-
name|SIZE_SZ
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|gap
init|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|ap
argument_list|)
operator|-
call|(
name|unsigned
name|int
call|)
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|room
decl_stmt|;
comment|/* we need to give back leading space in a chunk of at least MINSIZE */
if|if
condition|(
name|gap
operator|<
name|MINSIZE
condition|)
block|{
comment|/* This works since align>= MINSIZE */
comment|/* and we've malloc'd enough total room */
name|ap
operator|=
call|(
name|mchunkptr
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|ap
argument_list|)
operator|+
name|align
argument_list|)
expr_stmt|;
name|gap
operator|+=
name|align
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|+
name|nb
operator|>
name|p
operator|->
name|size
condition|)
comment|/* can't happen unless chunk sizes corrupted */
name|malloc_user_error
argument_list|()
expr_stmt|;
name|room
operator|=
name|p
operator|->
name|size
operator|-
name|gap
expr_stmt|;
comment|/* give back leader */
name|set_size
argument_list|(
name|p
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|consollink
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* use the rest */
name|p
operator|=
name|ap
expr_stmt|;
name|set_size
argument_list|(
name|p
argument_list|,
name|room
argument_list|)
expr_stmt|;
block|}
comment|/* also give back spare room at the end */
name|split
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|UPDATE_STATS
argument_list|(
name|do_malloc_stats
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|malloc_pagesize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|valloc
parameter_list|(
name|unsigned
name|int
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|malloc_pagesize
operator|==
literal|0
condition|)
name|malloc_pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
return|return
name|memalign
argument_list|(
name|malloc_pagesize
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|malloc_stats
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|MALLOC_STATS
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mchunkptr
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|nm
init|=
call|(
name|double
call|)
argument_list|(
name|n_mallocs
operator|+
name|n_reallocs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nmalloc statistics\n\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|n_mallocs
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"requests  = %10u total size = %10u\tave = %10u\n"
argument_list|,
name|n_mallocs
argument_list|,
name|requested_mem
argument_list|,
name|requested_mem
operator|/
name|n_mallocs
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|n_mallocs
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mallocs   = %10u total size = %10u\tave = %10u\n"
argument_list|,
name|n_mallocs
argument_list|,
name|malloced_mem
argument_list|,
name|malloced_mem
operator|/
name|n_mallocs
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|n_frees
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"frees     = %10u total size = %10u\tave = %10u\n"
argument_list|,
name|n_frees
argument_list|,
name|freed_mem
argument_list|,
name|freed_mem
operator|/
name|n_frees
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|n_mallocs
operator|-
name|n_frees
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in use    = %10u total size = %10u\tave = %10u\n"
argument_list|,
name|n_mallocs
operator|-
name|n_frees
argument_list|,
name|malloced_mem
operator|-
name|freed_mem
argument_list|,
operator|(
name|malloced_mem
operator|-
name|freed_mem
operator|)
operator|/
operator|(
name|n_mallocs
operator|-
name|n_frees
operator|)
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|max_inuse
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max in use= %10u total size = %10u\tave = %10u\n"
argument_list|,
name|max_inuse
argument_list|,
name|max_used_mem
argument_list|,
name|max_used_mem
operator|/
name|max_inuse
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|n_avail
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"available = %10u total size = %10u\tave = %10u\n"
argument_list|,
name|n_avail
argument_list|,
name|sbrked_mem
operator|-
operator|(
name|malloced_mem
operator|-
name|freed_mem
operator|)
argument_list|,
operator|(
name|sbrked_mem
operator|-
operator|(
name|malloced_mem
operator|-
name|freed_mem
operator|)
operator|)
operator|/
name|n_avail
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|n_sbrks
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sbrks     = %10u total size = %10u\tave = %10u\n\n"
argument_list|,
name|n_sbrks
argument_list|,
name|sbrked_mem
argument_list|,
name|sbrked_mem
operator|/
name|n_sbrks
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|n_reallocs
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reallocs  = %10u with copy  = %10u\n\n"
argument_list|,
name|n_reallocs
argument_list|,
name|n_reallocs_with_copy
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|nm
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chunks scanned per malloc = %6.3f\n"
argument_list|,
name|n_malloc_chunks
operator|/
name|nm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bins scanned per malloc   = %6.3f\n"
argument_list|,
name|n_malloc_bins
operator|/
name|nm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"splits per malloc         = %6.3f\n"
argument_list|,
name|n_split
operator|/
name|nm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"consolidations per malloc = %6.3f\n"
argument_list|,
name|n_consol
operator|/
name|nm
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nfree chunks:\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXBIN
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|av
index|[
name|i
index|]
operator|.
name|hd
operator|.
name|fd
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|&
operator|(
name|av
index|[
name|i
index|]
operator|.
name|hd
operator|)
condition|)
block|{
name|unsigned
name|int
name|count
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|sz
init|=
name|p
operator|->
name|size
decl_stmt|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|fd
init|;
name|p
operator|!=
operator|&
operator|(
name|av
index|[
name|i
index|]
operator|.
name|hd
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|fd
control|)
block|{
if|if
condition|(
name|p
operator|->
name|size
operator|==
name|sz
condition|)
operator|++
name|count
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsize = %10u count = %5u\n"
argument_list|,
name|sz
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|sz
operator|=
name|p
operator|->
name|size
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsize = %10u count = %5u\n"
argument_list|,
name|sz
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOC_STATS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_LIBGXX_MALLOC */
end_comment

end_unit

