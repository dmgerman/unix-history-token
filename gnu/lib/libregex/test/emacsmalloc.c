begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dynamic memory allocation for GNU.    Copyright (C) 1985, 1987 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/*  * @(#)nmalloc.c 1 (Caltech) 2/21/82  *  *	U of M Modified: 20 Jun 1983 ACT: strange hacks for Emacs  *  *	Nov 1983, Mike@BRL, Added support for 4.1C/4.2 BSD.  *  * This is a very fast storage allocator.  It allocates blocks of a small  * number of different sizes, and keeps free lists of each size.  Blocks  * that don't exactly fit are passed up to the next larger size.  In this  * implementation, the available sizes are (2^n)-4 (or -16) bytes long.  * This is designed for use in a program that uses vast quantities of  * memory, but bombs when it runs out.  To make it a little better, it  * warns the user when he starts to get near the end.  *  * June 84, ACT: modified rcheck code to check the range given to malloc,  * rather than the range determined by the 2-power used.  *  * Jan 85, RMS: calls malloc_warning to issue warning on nearly full.  * No longer Emacs-specific; can serve as all-purpose malloc for GNU.  * You should call malloc_init to reinitialize after loading dumped Emacs.  * Call malloc_stats to get info on memory stats if MSTATS turned on.  * realloc knows how to return same block given, just changing its size,  * if the power of 2 is correct.  */
end_comment

begin_comment
comment|/*  * nextf[i] is the pointer to the next free block of size 2^(i+3).  The  * smallest allocatable block is 8 bytes.  The overhead information will  * go in the first int of the block, and the returned pointer will point  * to the second.  * #ifdef MSTATS  * nmalloc[i] is the difference between the number of mallocs and frees  * for a given block size. #endif MSTATS  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_comment
comment|/* config.h specifies which kind of system this is.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Determine which kind of system this is.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy ((d), (s), (n))
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|memcmp ((s1), (s2), (n))
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset ((s), 0, (n))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SIGTSTP
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_define
define|#
directive|define
name|USG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SIGTSTP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_define
define|#
directive|define
name|BSD4_2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGIO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGTSTP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* Define getpagesize () if the system does not.  */
end_comment

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_include
include|#
directive|include
file|<sys/vlimit.h>
end_include

begin_comment
comment|/* warn the user when near the end */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if 4.2 or newer */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 4.2 or newer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|"vlimit.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_SEG_BITS
end_ifndef

begin_define
define|#
directive|define
name|start_of_data
parameter_list|()
value|&etext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_define
define|#
directive|define
name|start_of_data
parameter_list|()
value|&etext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISALLOC
value|((char) 0xf7)
end_define

begin_comment
comment|/* magic byte that implies allocation */
end_comment

begin_define
define|#
directive|define
name|ISFREE
value|((char) 0x54)
end_define

begin_comment
comment|/* magic byte that implies free block */
end_comment

begin_comment
comment|/* this is for error checking only */
end_comment

begin_define
define|#
directive|define
name|ISMEMALIGN
value|((char) 0xd6)
end_define

begin_comment
comment|/* Stored before the value returned by 				     memalign, with the rest of the word 				     being the distance to the true 				     beginning of the block.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|etext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These two are for user programs to look at, when they are interested.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|malloc_sbrk_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amount of data space used now */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|malloc_sbrk_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amount more we can have */
end_comment

begin_comment
comment|/* start of data space; can be changed by calling init_malloc */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|data_space_start
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSTATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|nmalloc
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nmal
decl_stmt|,
name|nfre
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSTATS */
end_comment

begin_comment
comment|/* If range checking is not turned on, all we have is a flag indicating    whether memory is allocated, an index in nextf[], and a size field; to    realloc() memory we copy either size bytes or 1<<(index+3) bytes depending    on whether the former can hold the exact size (given the value of    'index').  If range checking is on, we always need to know how much space    is allocated, so the 'size' field is never used. */
end_comment

begin_struct
struct|struct
name|mhead
block|{
name|char
name|mh_alloc
decl_stmt|;
comment|/* ISALLOC or ISFREE */
name|char
name|mh_index
decl_stmt|;
comment|/* index in nextf[] */
comment|/* Remainder are valid only when block is allocated */
name|unsigned
name|short
name|mh_size
decl_stmt|;
comment|/* size, if< 0x10000 */
ifdef|#
directive|ifdef
name|rcheck
name|unsigned
name|mh_nbytes
decl_stmt|;
comment|/* number of bytes allocated */
name|int
name|mh_magic4
decl_stmt|;
comment|/* should be == MAGIC4 */
endif|#
directive|endif
comment|/* rcheck */
block|}
struct|;
end_struct

begin_comment
comment|/* Access free-list pointer of a block.   It is stored at block + 4.   This is not a field in the mhead structure   because we want sizeof (struct mhead)   to describe the overhead for when the block is in use,   and we do not want the free-list pointer to count in that.  */
end_comment

begin_define
define|#
directive|define
name|CHAIN
parameter_list|(
name|a
parameter_list|)
define|\
value|(*(struct mhead **) (sizeof (char *) + (char *) (a)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|rcheck
end_ifdef

begin_comment
comment|/* To implement range checking, we write magic values in at the beginning and    end of each allocated block, and make sure they are undisturbed whenever a    free or a realloc occurs. */
end_comment

begin_comment
comment|/* Written in each of the 4 bytes following the block's real space */
end_comment

begin_define
define|#
directive|define
name|MAGIC1
value|0x55
end_define

begin_comment
comment|/* Written in the 4 bytes before the block's real space */
end_comment

begin_define
define|#
directive|define
name|MAGIC4
value|0x55555555
end_define

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|)
value|if (!(p)) botch("p"); else
end_define

begin_define
define|#
directive|define
name|EXTRA
value|4
end_define

begin_comment
comment|/* 4 bytes extra for MAGIC1s */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|)
value|if (!(p)) abort (); else
end_define

begin_define
define|#
directive|define
name|EXTRA
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* rcheck */
end_comment

begin_comment
comment|/* nextf[i] is free list of blocks of size 2**(i + 3)  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mhead
modifier|*
name|nextf
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* busy[i] is nonzero while allocation of block size i is in progress.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|busy
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes of writable memory we can expect to be able to get */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lim_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level number of warnings already issued.   0 -- no warnings issued.   1 -- 75% warning already issued.   2 -- 85% warning already issued. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warnlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to issue a warning;    0 means don't issue them.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|warnfunction
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* nonzero once initial bunch of free blocks made */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gotpool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_malloc_base
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|getpool
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Cause reinitialization based on job parameters;   also declare where the end of pure storage is. */
end_comment

begin_decl_stmt
name|void
name|malloc_init
argument_list|(
name|start
argument_list|,
name|warnfun
argument_list|)
name|char
modifier|*
name|start
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|warnfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|start
condition|)
name|data_space_start
operator|=
name|start
expr_stmt|;
name|lim_data
operator|=
literal|0
expr_stmt|;
name|warnlevel
operator|=
literal|0
expr_stmt|;
name|warnfunction
operator|=
name|warnfun
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the maximum size to which MEM can be realloc'd    without actually requiring copying.  */
end_comment

begin_function
name|int
name|malloc_usable_size
parameter_list|(
name|mem
parameter_list|)
name|char
modifier|*
name|mem
decl_stmt|;
block|{
name|struct
name|mhead
modifier|*
name|p
init|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|mem
operator|-
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mhead
argument_list|)
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
decl_stmt|;
name|int
name|blocksize
init|=
literal|8
operator|<<
name|p
operator|->
name|mh_index
decl_stmt|;
return|return
name|blocksize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mhead
argument_list|)
operator|-
name|EXTRA
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|morecore
parameter_list|(
name|nu
parameter_list|)
comment|/* ask system for more memory */
specifier|register
name|int
name|nu
decl_stmt|;
comment|/* size index to get more of  */
block|{
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|nblks
decl_stmt|;
specifier|register
name|unsigned
name|int
name|siz
decl_stmt|;
name|int
name|oldmask
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
name|int
name|newmask
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Blocking these signals interferes with debugging, at least on BSD on      the HP 9000/300.  */
ifdef|#
directive|ifdef
name|SIGTRAP
name|newmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|SIGTRAP
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|newmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|SIGILL
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
name|newmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|SIGTSTP
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSTOP
name|newmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|SIGSTOP
operator|)
expr_stmt|;
endif|#
directive|endif
name|oldmask
operator|=
name|sigsetmask
argument_list|(
name|newmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|data_space_start
condition|)
block|{
name|data_space_start
operator|=
name|start_of_data
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lim_data
operator|==
literal|0
condition|)
name|get_lim_data
argument_list|()
expr_stmt|;
comment|/* On initial startup, get two blocks of each size up to 1k bytes */
if|if
condition|(
operator|!
name|gotpool
condition|)
block|{
name|getpool
argument_list|()
expr_stmt|;
name|getpool
argument_list|()
expr_stmt|;
name|gotpool
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find current end of memory and issue warning if getting near max */
ifndef|#
directive|ifndef
name|VMS
comment|/* Maximum virtual memory on VMS is difficult to calculate since it    * depends on several dynmacially changing things. Also, alignment    * isn't that important. That is why much of the code here is ifdef'ed    * out for VMS systems.    */
name|cp
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|siz
operator|=
name|cp
operator|-
name|data_space_start
expr_stmt|;
if|if
condition|(
name|warnfunction
condition|)
switch|switch
condition|(
name|warnlevel
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|siz
operator|>
operator|(
name|lim_data
operator|/
literal|4
operator|)
operator|*
literal|3
condition|)
block|{
name|warnlevel
operator|++
expr_stmt|;
call|(
modifier|*
name|warnfunction
call|)
argument_list|(
literal|"Warning: past 75% of memory limit"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|siz
operator|>
operator|(
name|lim_data
operator|/
literal|20
operator|)
operator|*
literal|17
condition|)
block|{
name|warnlevel
operator|++
expr_stmt|;
call|(
modifier|*
name|warnfunction
call|)
argument_list|(
literal|"Warning: past 85% of memory limit"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|siz
operator|>
operator|(
name|lim_data
operator|/
literal|20
operator|)
operator|*
literal|19
condition|)
block|{
name|warnlevel
operator|++
expr_stmt|;
call|(
modifier|*
name|warnfunction
call|)
argument_list|(
literal|"Warning: past 95% of memory limit"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
condition|)
comment|/* land on 1K boundaries */
name|sbrk
argument_list|(
literal|1024
operator|-
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
comment|/* Take at least 2k, and figure out how many blocks of the desired size     we're about to get */
name|nblks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|siz
operator|=
name|nu
operator|)
operator|<
literal|8
condition|)
name|nblks
operator|=
literal|1
operator|<<
operator|(
operator|(
name|siz
operator|=
literal|8
operator|)
operator|-
name|nu
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|sbrk
argument_list|(
literal|1
operator|<<
operator|(
name|siz
operator|+
literal|3
operator|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return;
comment|/* no more room! */
block|}
name|malloc_sbrk_used
operator|=
name|siz
expr_stmt|;
name|malloc_sbrk_unused
operator|=
name|lim_data
operator|-
name|siz
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|7
condition|)
block|{
comment|/* shouldn't happen, but just in case */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|cp
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
name|nblks
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS */
comment|/* save new header and link the nblks blocks together */
name|nextf
index|[
name|nu
index|]
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
expr_stmt|;
name|siz
operator|=
literal|1
operator|<<
operator|(
name|nu
operator|+
literal|3
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_index
operator|=
name|nu
expr_stmt|;
if|if
condition|(
operator|--
name|nblks
operator|<=
literal|0
condition|)
break|break;
name|CHAIN
argument_list|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
argument_list|)
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|cp
operator|+
name|siz
operator|)
expr_stmt|;
name|cp
operator|+=
name|siz
expr_stmt|;
block|}
name|CHAIN
argument_list|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|getpool
parameter_list|()
block|{
specifier|register
name|int
name|nu
decl_stmt|;
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
condition|)
comment|/* land on 1K boundaries */
name|sbrk
argument_list|(
literal|1024
operator|-
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|0x3ff
operator|)
argument_list|)
expr_stmt|;
comment|/* Record address of start of space allocated by malloc.  */
if|if
condition|(
name|_malloc_base
operator|==
literal|0
condition|)
name|_malloc_base
operator|=
name|cp
expr_stmt|;
comment|/* Get 2k of storage */
name|cp
operator|=
name|sbrk
argument_list|(
literal|04000
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return;
comment|/* Divide it into an initial 8-word block      plus one block of size 2**nu for nu = 3 ... 10.  */
name|CHAIN
argument_list|(
name|cp
argument_list|)
operator|=
name|nextf
index|[
literal|0
index|]
expr_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_index
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
literal|8
expr_stmt|;
for|for
control|(
name|nu
operator|=
literal|0
init|;
name|nu
operator|<
literal|7
condition|;
name|nu
operator|++
control|)
block|{
name|CHAIN
argument_list|(
name|cp
argument_list|)
operator|=
name|nextf
index|[
name|nu
index|]
expr_stmt|;
name|nextf
index|[
name|nu
index|]
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
operator|(
operator|(
expr|struct
name|mhead
operator|*
operator|)
name|cp
operator|)
operator|->
name|mh_index
operator|=
name|nu
expr_stmt|;
name|cp
operator|+=
literal|8
operator|<<
name|nu
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|malloc
parameter_list|(
name|n
parameter_list|)
comment|/* get a block */
name|unsigned
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|nbytes
decl_stmt|;
specifier|register
name|int
name|nunits
init|=
literal|0
decl_stmt|;
comment|/* Figure out how many bytes are required, rounding up to the nearest      multiple of 8, then figure out which nestf[] area to use.      Both the beginning of the header and the beginning of the      block should be on an eight byte boundary.  */
name|nbytes
operator|=
operator|(
name|n
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|EXTRA
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|shiftr
init|=
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|>>
literal|2
decl_stmt|;
while|while
condition|(
name|shiftr
operator|>>=
literal|1
condition|)
name|nunits
operator|++
expr_stmt|;
block|}
comment|/* In case this is reentrant use of malloc from signal handler,      pick a block size that no other malloc level is currently      trying to allocate.  That's the easiest harmless way not to      interfere with the other level of execution.  */
while|while
condition|(
name|busy
index|[
name|nunits
index|]
condition|)
name|nunits
operator|++
expr_stmt|;
name|busy
index|[
name|nunits
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If there are no blocks of the appropriate size, go get some */
comment|/* COULD SPLIT UP A LARGER BLOCK HERE ... ACT */
if|if
condition|(
name|nextf
index|[
name|nunits
index|]
operator|==
literal|0
condition|)
name|morecore
argument_list|(
name|nunits
argument_list|)
expr_stmt|;
comment|/* Get one block off the list, and set the new list head */
if|if
condition|(
operator|(
name|p
operator|=
name|nextf
index|[
name|nunits
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|busy
index|[
name|nunits
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nextf
index|[
name|nunits
index|]
operator|=
name|CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|busy
index|[
name|nunits
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Check for free block clobbered */
comment|/* If not for this check, we would gobble a clobbered free chain ptr */
comment|/* and bomb out on the NEXT allocate of this size block */
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|!=
name|ISFREE
operator|||
name|p
operator|->
name|mh_index
operator|!=
name|nunits
condition|)
ifdef|#
directive|ifdef
name|rcheck
name|botch
argument_list|(
literal|"block on free list clobbered"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not rcheck */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
comment|/* Fill in the info, and if range checking, set up the magic numbers */
name|p
operator|->
name|mh_alloc
operator|=
name|ISALLOC
expr_stmt|;
ifdef|#
directive|ifdef
name|rcheck
name|p
operator|->
name|mh_nbytes
operator|=
name|n
expr_stmt|;
name|p
operator|->
name|mh_magic4
operator|=
name|MAGIC4
expr_stmt|;
block|{
comment|/* Get the location n after the beginning of the user's space.  */
specifier|register
name|char
modifier|*
name|m
init|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|n
decl_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
operator|,
operator|*
name|m
operator|++
operator|=
name|MAGIC1
operator|,
operator|*
name|m
operator|++
operator|=
name|MAGIC1
operator|,
operator|*
name|m
operator|=
name|MAGIC1
expr_stmt|;
block|}
else|#
directive|else
comment|/* not rcheck */
name|p
operator|->
name|mh_size
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
ifdef|#
directive|ifdef
name|MSTATS
name|nmalloc
index|[
name|nunits
index|]
operator|++
expr_stmt|;
name|nmal
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MSTATS */
return|return
operator|(
name|char
operator|*
operator|)
name|p
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
return|;
block|}
end_function

begin_macro
name|free
argument_list|(
argument|mem
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mem
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
init|=
name|mem
decl_stmt|;
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|ap
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|==
name|ISMEMALIGN
condition|)
block|{
name|ap
operator|-=
name|p
operator|->
name|mh_size
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|ap
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|rcheck
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|!=
name|ISALLOC
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
else|rcheck
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|!=
name|ISALLOC
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|mh_alloc
operator|==
name|ISFREE
condition|)
name|botch
argument_list|(
literal|"free: Called with already freed block argument\n"
argument_list|)
expr_stmt|;
else|else
name|botch
argument_list|(
literal|"free: Called with bad argument\n"
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|p
operator|->
name|mh_magic4
operator|==
name|MAGIC4
argument_list|)
expr_stmt|;
name|ap
operator|+=
name|p
operator|->
name|mh_nbytes
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|ap
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* rcheck */
block|}
block|{
specifier|register
name|int
name|nunits
init|=
name|p
operator|->
name|mh_index
decl_stmt|;
name|ASSERT
argument_list|(
name|nunits
operator|<=
literal|29
argument_list|)
expr_stmt|;
name|p
operator|->
name|mh_alloc
operator|=
name|ISFREE
expr_stmt|;
comment|/* Protect against signal handlers calling malloc.  */
name|busy
index|[
name|nunits
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Put this block on the free list.  */
name|CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|nextf
index|[
name|nunits
index|]
expr_stmt|;
name|nextf
index|[
name|nunits
index|]
operator|=
name|p
expr_stmt|;
name|busy
index|[
name|nunits
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MSTATS
name|nmalloc
index|[
name|nunits
index|]
operator|--
expr_stmt|;
name|nfre
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MSTATS */
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|realloc
parameter_list|(
name|mem
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|mem
decl_stmt|;
specifier|register
name|unsigned
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|tocopy
decl_stmt|;
specifier|register
name|unsigned
name|int
name|nbytes
decl_stmt|;
specifier|register
name|int
name|nunits
decl_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
name|malloc
argument_list|(
name|n
argument_list|)
return|;
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|mem
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
name|nunits
operator|=
name|p
operator|->
name|mh_index
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|mh_alloc
operator|==
name|ISALLOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|rcheck
name|ASSERT
argument_list|(
name|p
operator|->
name|mh_magic4
operator|==
name|MAGIC4
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|m
init|=
name|mem
operator|+
operator|(
name|tocopy
operator|=
name|p
operator|->
name|mh_nbytes
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|++
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|m
operator|==
name|MAGIC1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not rcheck */
if|if
condition|(
name|p
operator|->
name|mh_index
operator|>=
literal|13
condition|)
name|tocopy
operator|=
operator|(
literal|1
operator|<<
operator|(
name|p
operator|->
name|mh_index
operator|+
literal|3
operator|)
operator|)
operator|-
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
else|else
name|tocopy
operator|=
name|p
operator|->
name|mh_size
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
comment|/* See if desired size rounds to same power of 2 as actual size. */
name|nbytes
operator|=
operator|(
name|n
operator|+
operator|(
operator|(
sizeof|sizeof
expr|*
name|p
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|EXTRA
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* If ok, use the same block, just marking its size as changed.  */
if|if
condition|(
name|nbytes
operator|>
operator|(
literal|4
operator|<<
name|nunits
operator|)
operator|&&
name|nbytes
operator|<=
operator|(
literal|8
operator|<<
name|nunits
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|rcheck
specifier|register
name|char
modifier|*
name|m
init|=
name|mem
operator|+
name|tocopy
decl_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|mh_nbytes
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|mem
operator|+
name|n
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
operator|*
name|m
operator|++
operator|=
name|MAGIC1
expr_stmt|;
else|#
directive|else
comment|/* not rcheck */
name|p
operator|->
name|mh_size
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
comment|/* not rcheck */
return|return
name|mem
return|;
block|}
if|if
condition|(
name|n
operator|<
name|tocopy
condition|)
name|tocopy
operator|=
name|n
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|mem
argument_list|,
name|new
argument_list|,
name|tocopy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is in case something linked with Emacs calls calloc.  */
end_comment

begin_function
name|char
modifier|*
name|calloc
parameter_list|(
name|num
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|num
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|mem
decl_stmt|;
name|num
operator|*=
name|size
expr_stmt|;
name|mem
operator|=
name|malloc
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|mem
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_function
name|char
modifier|*
name|memalign
parameter_list|(
name|alignment
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|alignment
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
name|size
operator|+
name|alignment
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|aligned
decl_stmt|;
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If entire block has the desired alignment, just accept it.  */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ptr
return|;
comment|/* Otherwise, get address of byte in the block that has that alignment.  */
name|aligned
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|alignment
operator|)
expr_stmt|;
comment|/* Store a suitable indication of how to free the block,      so that free can find the true beginning of it.  */
name|p
operator|=
operator|(
expr|struct
name|mhead
operator|*
operator|)
operator|(
name|aligned
operator|-
operator|(
operator|(
literal|7
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mhead
argument_list|)
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
expr_stmt|;
name|p
operator|->
name|mh_size
operator|=
name|aligned
operator|-
name|ptr
expr_stmt|;
name|p
operator|->
name|mh_alloc
operator|=
name|ISMEMALIGN
expr_stmt|;
return|return
name|aligned
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HPUX
end_ifndef

begin_comment
comment|/* This runs into trouble with getpagesize on HPUX.    Patching out seems cleaner than the ugly fix needed.  */
end_comment

begin_function
name|char
modifier|*
name|valloc
parameter_list|(
name|size
parameter_list|)
block|{
return|return
name|memalign
argument_list|(
name|getpagesize
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HPUX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|MSTATS
end_ifdef

begin_comment
comment|/* Return statistics describing allocation of blocks of size 2**n. */
end_comment

begin_struct
struct|struct
name|mstats_value
block|{
name|int
name|blocksize
decl_stmt|;
name|int
name|nfree
decl_stmt|;
name|int
name|nused
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|mstats_value
name|malloc_stats
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|struct
name|mstats_value
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
name|v
operator|.
name|nfree
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>=
literal|30
condition|)
block|{
name|v
operator|.
name|blocksize
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|nused
operator|=
literal|0
expr_stmt|;
return|return
name|v
return|;
block|}
name|v
operator|.
name|blocksize
operator|=
literal|1
operator|<<
operator|(
name|size
operator|+
literal|3
operator|)
expr_stmt|;
name|v
operator|.
name|nused
operator|=
name|nmalloc
index|[
name|size
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nextf
index|[
name|size
index|]
init|;
name|p
condition|;
name|p
operator|=
name|CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|v
operator|.
name|nfree
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|int
name|malloc_mem_used
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|size_used
decl_stmt|;
name|size_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|int
name|allocation_size
init|=
literal|1
operator|<<
operator|(
name|i
operator|+
literal|3
operator|)
decl_stmt|;
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
name|size_used
operator|+=
name|nmalloc
index|[
name|i
index|]
operator|*
name|allocation_size
expr_stmt|;
block|}
return|return
name|size_used
return|;
block|}
end_function

begin_function
name|int
name|malloc_mem_free
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|size_unused
decl_stmt|;
name|size_unused
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|int
name|allocation_size
init|=
literal|1
operator|<<
operator|(
name|i
operator|+
literal|3
operator|)
decl_stmt|;
name|struct
name|mhead
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|nextf
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|size_unused
operator|+=
name|allocation_size
expr_stmt|;
block|}
return|return
name|size_unused
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSTATS */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *	This function returns the total number of bytes that the process  *	will be allowed to allocate via the sbrk(2) system call.  On  *	BSD systems this is the total space allocatable to stack and  *	data.  On USG systems this is the data space only.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_macro
name|get_lim_data
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|long
name|ulimit
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|ULIMIT_BREAK_VALUE
name|lim_data
operator|=
name|ULIMIT_BREAK_VALUE
expr_stmt|;
else|#
directive|else
name|lim_data
operator|=
name|ulimit
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lim_data
operator|-=
operator|(
name|long
operator|)
name|data_space_start
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD4_1
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_macro
name|get_lim_data
argument_list|()
end_macro

begin_block
block|{
name|lim_data
operator|=
name|vlimit
argument_list|(
name|LIM_DATA
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not BSD4_1 and not VMS */
end_comment

begin_macro
name|get_lim_data
argument_list|()
end_macro

begin_block
block|{
name|struct
name|rlimit
name|XXrlimit
decl_stmt|;
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|XXrlimit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIM_INFINITY
name|lim_data
operator|=
name|XXrlimit
operator|.
name|rlim_cur
operator|&
name|RLIM_INFINITY
expr_stmt|;
comment|/* soft limit */
else|#
directive|else
name|lim_data
operator|=
name|XXrlimit
operator|.
name|rlim_cur
expr_stmt|;
comment|/* soft limit */
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD4_1 and not VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* There is a problem when dumping and restoring things on VMS. Calls  * to SBRK don't necessarily result in contiguous allocation. Dumping  * doesn't work when it isn't. Therefore, we make the initial  * allocation contiguous by allocating a big chunk, and do SBRKs from  * there. Once Emacs has dumped there is no reason to continue  * contiguous allocation, malloc doesn't depend on it.  *  * There is a further problem of using brk and sbrk while using VMS C  * run time library routines malloc, calloc, etc. The documentation  * says that this is a no-no, although I'm not sure why this would be  * a problem. In any case, we remove the necessity to call brk and  * sbrk, by calling calloc (to assure zero filled data) rather than  * sbrk.  *  * VMS_ALLOCATION_SIZE is the size of the allocation array. This  * should be larger than the malloc size before dumping. Making this  * too large will result in the startup procedure slowing down since  * it will require more space and time to map it in.  *  * The value for VMS_ALLOCATION_SIZE in the following define was determined  * by running emacs linked (and a large allocation) with the debugger and  * looking to see how much storage was used. The allocation was 201 pages,  * so I rounded it up to a power of two.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS_ALLOCATION_SIZE
end_ifndef

begin_define
define|#
directive|define
name|VMS_ALLOCATION_SIZE
value|(512*256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use VMS RTL definitions */
end_comment

begin_undef
undef|#
directive|undef
name|sbrk
end_undef

begin_undef
undef|#
directive|undef
name|brk
end_undef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_decl_stmt
name|int
name|vms_out_initial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|vms_initial_buffer
index|[
name|VMS_ALLOCATION_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vms_current_brk
init|=
operator|&
name|vms_initial_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vms_end_brk
init|=
operator|&
name|vms_initial_buffer
index|[
name|VMS_ALLOCATION_SIZE
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|char
modifier|*
name|sys_sbrk
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
name|char
modifier|*
name|sbrk
argument_list|()
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|vms_out_initial
condition|)
block|{
comment|/* out of initial allocation... */
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|malloc
argument_list|(
name|incr
argument_list|)
operator|)
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, go out of our area */
name|ptr
operator|=
name|vms_current_brk
operator|+
name|incr
expr_stmt|;
comment|/* new current_brk */
if|if
condition|(
name|ptr
operator|<=
name|vms_end_brk
condition|)
block|{
name|temp
operator|=
name|vms_current_brk
expr_stmt|;
name|vms_current_brk
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|vms_out_initial
operator|=
literal|1
expr_stmt|;
comment|/* mark as out of initial allocation */
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|malloc
argument_list|(
name|incr
argument_list|)
operator|)
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|temp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

