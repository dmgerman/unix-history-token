begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bind.c -- key binding and startup file support for the readline library. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_SYS_FILE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_SYS_FILE */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_rl_horizontal_scroll_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_mark_modified_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_bell_preference
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_meta_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_blink_matching_paren
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_convert_meta_chars_to_ascii
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_output_meta_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_complete_show_all
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|rl_visible_stats
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_complete_with_tilde_expansion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_query_items
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_vi_comment_begin
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|rl_explicit_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_editing_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|short
name|_rl_parsing_conditionalized_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Keymap
name|_rl_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|possible_control_prefixes
index|[]
decl_stmt|,
modifier|*
name|possible_meta_prefixes
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|rl_funmap_names
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
name|void
name|rl_set_keymap_from_edit_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glean_key_from_name
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Binding keys				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* rl_add_defun (char *name, Function *function, int key)    Add NAME to the list of named functions.  Make FUNCTION be the function    that gets called.  If KEY is not -1, then bind it. */
end_comment

begin_macro
name|rl_add_defun
argument_list|(
argument|name
argument_list|,
argument|function
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|key
operator|!=
operator|-
literal|1
condition|)
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|rl_add_funmap_entry
argument_list|(
name|name
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
end_comment

begin_function
name|int
name|rl_bind_key
parameter_list|(
name|key
parameter_list|,
name|function
parameter_list|)
name|int
name|key
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|{
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
operator|(
name|key
operator|)
return|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|key
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
if|if
condition|(
name|_rl_keymap
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|Keymap
name|escmap
decl_stmt|;
name|escmap
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|_rl_keymap
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|key
operator|=
name|UNMETA
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|escmap
index|[
name|key
index|]
operator|.
name|type
operator|=
name|ISFUNC
expr_stmt|;
name|escmap
index|[
name|key
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|key
operator|)
return|;
block|}
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|type
operator|=
name|ISFUNC
expr_stmt|;
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid    KEY. */
end_comment

begin_function
name|int
name|rl_bind_key_in_map
parameter_list|(
name|key
parameter_list|,
name|function
parameter_list|,
name|map
parameter_list|)
name|int
name|key
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|Keymap
name|oldmap
init|=
name|_rl_keymap
decl_stmt|;
name|_rl_keymap
operator|=
name|map
expr_stmt|;
name|result
operator|=
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|_rl_keymap
operator|=
name|oldmap
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make KEY do nothing in the currently selected keymap.    Returns non-zero in case of error. */
end_comment

begin_function
name|int
name|rl_unbind_key
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_key
argument_list|(
name|key
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make KEY do nothing in MAP.    Returns non-zero in case of error. */
end_comment

begin_function
name|int
name|rl_unbind_key_in_map
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
name|int
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_key_in_map
argument_list|(
name|key
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    FUNCTION.  This makes new keymaps as necessary.  The initial    place to do bindings is in MAP. */
end_comment

begin_macro
name|rl_set_key
argument_list|(
argument|keyseq
argument_list|,
argument|function
argument_list|,
argument|map
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|keyseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_generic_bind
argument_list|(
name|ISFUNC
argument_list|,
name|keyseq
argument_list|,
name|function
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    the string of characters MACRO.  This makes new keymaps as    necessary.  The initial place to do bindings is in MAP. */
end_comment

begin_macro
name|rl_macro_bind
argument_list|(
argument|keyseq
argument_list|,
argument|macro
argument_list|,
argument|map
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|keyseq
decl_stmt|,
modifier|*
name|macro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|macro_keys
decl_stmt|;
name|int
name|macro_keys_len
decl_stmt|;
name|macro_keys
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|macro
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_translate_keyseq
argument_list|(
name|macro
argument_list|,
name|macro_keys
argument_list|,
operator|&
name|macro_keys_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|macro_keys
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_generic_bind
argument_list|(
name|ISMACR
argument_list|,
name|keyseq
argument_list|,
name|macro_keys
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    the arbitrary pointer DATA.  TYPE says what kind of data is    pointed to by DATA, right now this can be a function (ISFUNC),    a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps    as necessary.  The initial place to do bindings is in MAP. */
end_comment

begin_macro
name|rl_generic_bind
argument_list|(
argument|type
argument_list|,
argument|keyseq
argument_list|,
argument|data
argument_list|,
argument|map
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keyseq
decl_stmt|,
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|int
name|keys_len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If no keys to bind to, exit right away. */
if|if
condition|(
operator|!
name|keyseq
operator|||
operator|!
operator|*
name|keyseq
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|keys
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|keyseq
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Translate the ASCII representation of KEYSEQ into an array of      characters.  Stuff the characters into KEYS, and the length of      KEYS into KEYS_LEN. */
if|if
condition|(
name|rl_translate_keyseq
argument_list|(
name|keyseq
argument_list|,
name|keys
argument_list|,
operator|&
name|keys_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Bind keys, making new keymaps as necessary. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keys_len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ic
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|keys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|_rl_convert_meta_chars_to_ascii
operator|&&
name|META_CHAR
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|ic
operator|=
name|UNMETA
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|keys_len
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|!=
name|ISKMAP
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|ic
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|=
name|ISKMAP
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|=
name|KEYMAP_TO_FUNCTION
argument_list|(
name|rl_make_bare_keymap
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|ic
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|=
name|KEYMAP_TO_FUNCTION
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Translate the ASCII representation of SEQ, stuffing the values into ARRAY,    an array of characters.  LEN gets the final length of ARRAY.  Return    non-zero if there was an error parsing SEQ. */
end_comment

begin_macro
name|rl_translate_keyseq
argument_list|(
argument|seq
argument_list|,
argument|array
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|seq
decl_stmt|,
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|=
name|seq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|seq
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|c
operator|==
literal|'C'
operator|||
name|c
operator|==
literal|'M'
operator|)
operator|&&
name|seq
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'e'
operator|)
condition|)
block|{
comment|/* Handle special case of backwards define. */
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|seq
index|[
name|i
index|]
argument_list|,
literal|"C-\\M-"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|CTRL
argument_list|(
name|to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
index|[
name|i
index|]
condition|)
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|i
operator|++
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Special hack for C-?... */
if|if
condition|(
name|seq
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
name|array
index|[
name|l
operator|++
index|]
operator|=
name|RUBOUT
expr_stmt|;
else|else
name|array
index|[
name|l
operator|++
index|]
operator|=
name|CTRL
argument_list|(
name|to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|array
index|[
name|l
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|l
expr_stmt|;
name|array
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return a pointer to the function that STRING represents.    If STRING doesn't have a matching function, then a NULL pointer    is returned. */
end_comment

begin_function
name|Function
modifier|*
name|rl_named_function
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rl_initialize_funmap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|funmap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|funmap
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|funmap
index|[
name|i
index|]
operator|->
name|function
operator|)
return|;
return|return
operator|(
operator|(
name|Function
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the function (or macro) definition which would be invoked via    KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is    used.  TYPE, if non-NULL, is a pointer to an int which will receive the    type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),    or ISMACR (macro). */
end_comment

begin_function
name|Function
modifier|*
name|rl_function_of_keyseq
parameter_list|(
name|keyseq
parameter_list|,
name|map
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|keyseq
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
name|int
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
name|map
operator|=
name|_rl_keymap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keyseq
operator|&&
name|keyseq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ic
init|=
name|keyseq
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|ic
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|!=
name|ISKMAP
condition|)
block|{
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|map
index|[
name|ESC
index|]
operator|.
name|type
expr_stmt|;
return|return
operator|(
name|map
index|[
name|ESC
index|]
operator|.
name|function
operator|)
return|;
block|}
else|else
block|{
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|ic
operator|=
name|UNMETA
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
comment|/* If this is the last key in the key sequence, return the 	     map. */
if|if
condition|(
operator|!
name|keyseq
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|ISKMAP
expr_stmt|;
return|return
operator|(
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|)
return|;
block|}
else|else
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|map
index|[
name|ic
index|]
operator|.
name|type
expr_stmt|;
return|return
operator|(
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|(
name|Function
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The last key bindings file read. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_readline_init_file
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Re-read the current keybindings file. */
end_comment

begin_macro
name|rl_re_read_init_file
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|rl_read_init_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|rl_set_keymap_from_edit_mode
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/* Do key bindings from a file.  If FILENAME is NULL it defaults    to the first non-null filename from this list:      1. the filename used for the previous call      2. the value of the shell variable `INPUTRC'      3. ~/.inputrc    If the file existed and could be opened and read, 0 is returned,    otherwise errno is returned. */
end_comment

begin_function
name|int
name|rl_read_init_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|openname
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|int
name|file
decl_stmt|;
comment|/* Default the filename. */
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|filename
operator|=
name|last_readline_init_file
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|getenv
argument_list|(
literal|"INPUTRC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|DEFAULT_INPUTRC
expr_stmt|;
block|}
name|openname
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|openname
argument_list|,
operator|&
name|finfo
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|file
operator|=
name|open
argument_list|(
name|openname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|openname
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
else|else
name|free
argument_list|(
name|openname
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|last_readline_init_file
condition|)
block|{
if|if
condition|(
name|last_readline_init_file
condition|)
name|free
argument_list|(
name|last_readline_init_file
argument_list|)
expr_stmt|;
name|last_readline_init_file
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Read the file into BUFFER. */
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|finfo
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|finfo
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|finfo
operator|.
name|st_size
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* Loop over the lines in the file.  Lines that start with `#' are      comments; all other lines are commands for readline initialization. */
name|line
operator|=
name|buffer
expr_stmt|;
name|end
operator|=
name|buffer
operator|+
name|finfo
operator|.
name|st_size
expr_stmt|;
while|while
condition|(
name|line
operator|<
name|end
condition|)
block|{
comment|/* Find the end of this line. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
operator|+
name|i
operator|!=
name|end
operator|&&
name|line
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Mark end of line. */
name|line
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip leading whitespace. */
while|while
condition|(
operator|*
name|line
operator|&&
name|whitespace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
comment|/* If the line is not a comment, then parse it. */
if|if
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'#'
condition|)
name|rl_parse_and_bind
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Move to the next line. */
name|line
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Parser Directives       		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Conditionals. */
end_comment

begin_comment
comment|/* Calling programs set this to have their argv[0]. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_readline_name
init|=
literal|"other"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of previous values of parsing_conditionalized_out. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|if_stack
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_stack_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push _rl_parsing_conditionalized_out, and set parser state based    on ARGS. */
end_comment

begin_function
specifier|static
name|int
name|parser_if
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Push parser state. */
if|if
condition|(
name|if_stack_depth
operator|+
literal|1
operator|>=
name|if_stack_size
condition|)
block|{
if|if
condition|(
operator|!
name|if_stack
condition|)
name|if_stack
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|if_stack_size
operator|=
literal|20
argument_list|)
expr_stmt|;
else|else
name|if_stack
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|if_stack
argument_list|,
name|if_stack_size
operator|+=
literal|20
argument_list|)
expr_stmt|;
block|}
name|if_stack
index|[
name|if_stack_depth
operator|++
index|]
operator|=
name|_rl_parsing_conditionalized_out
expr_stmt|;
comment|/* If parsing is turned off, then nothing can turn it back on except      for finding the matching endif.  In that case, return right now. */
if|if
condition|(
name|_rl_parsing_conditionalized_out
condition|)
return|return
literal|0
return|;
comment|/* Isolate first argument. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Handle "if term=foo" and "if mode=emacs" constructs.  If this      isn't term=foo, or mode=emacs, then check to see if the first      word in ARGS is the same as the value stored in rl_readline_name. */
if|if
condition|(
name|rl_terminal_name
operator|&&
name|strnicmp
argument_list|(
name|args
argument_list|,
literal|"term="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tem
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
comment|/* Terminals like "aaa-60" are equivalent to "aaa". */
name|tname
operator|=
name|savestring
argument_list|(
name|rl_terminal_name
argument_list|)
expr_stmt|;
name|tem
operator|=
name|strchr
argument_list|(
name|tname
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
operator|*
name|tem
operator|=
literal|'\0'
expr_stmt|;
comment|/* Test the `long' and `short' forms of the terminal name so that 	 if someone has a `sun-cmd' and does not want to have bindings 	 that will be executed if the terminal is a `sun', they can put 	 `$if term=sun-cmd' into their .inputrc. */
if|if
condition|(
operator|(
name|stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
name|tname
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
name|rl_terminal_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|_rl_parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
else|else
name|_rl_parsing_conditionalized_out
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
elseif|else
if|if
condition|(
name|strnicmp
argument_list|(
name|args
argument_list|,
literal|"mode="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
literal|"emacs"
argument_list|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|emacs_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
literal|"vi"
argument_list|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|vi_mode
expr_stmt|;
else|else
name|mode
operator|=
name|no_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|rl_editing_mode
condition|)
name|_rl_parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
else|else
name|_rl_parsing_conditionalized_out
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
comment|/* Check to see if the first word in ARGS is the same as the      value stored in rl_readline_name. */
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|args
argument_list|,
name|rl_readline_name
argument_list|)
operator|==
literal|0
condition|)
name|_rl_parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
else|else
name|_rl_parsing_conditionalized_out
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invert the current parser state if there is anything on the stack. */
end_comment

begin_function
specifier|static
name|int
name|parser_else
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_stack_depth
condition|)
block|{
comment|/* Error message? */
return|return
literal|0
return|;
block|}
comment|/* Check the previous (n - 1) levels of the stack to make sure that      we haven't previously turned off parsing. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|if_stack_depth
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|if_stack
index|[
name|i
index|]
operator|==
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Invert the state of parsing if at top level. */
name|_rl_parsing_conditionalized_out
operator|=
operator|!
name|_rl_parsing_conditionalized_out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Terminate a conditional, popping the value of    _rl_parsing_conditionalized_out from the stack. */
end_comment

begin_function
specifier|static
name|int
name|parser_endif
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
if|if
condition|(
name|if_stack_depth
condition|)
name|_rl_parsing_conditionalized_out
operator|=
name|if_stack
index|[
operator|--
name|if_stack_depth
index|]
expr_stmt|;
else|else
block|{
comment|/* *** What, no error message? *** */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Associate textual names with actual functions. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|}
name|parser_directives
index|[]
init|=
block|{
block|{
literal|"if"
block|,
name|parser_if
block|}
block|,
block|{
literal|"endif"
block|,
name|parser_endif
block|}
block|,
block|{
literal|"else"
block|,
name|parser_else
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
operator|(
name|Function
operator|*
operator|)
literal|0x0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Handle a parser directive.  STATEMENT is the line of the directive    without any leading `$'. */
end_comment

begin_function
specifier|static
name|int
name|handle_parser_directive
parameter_list|(
name|statement
parameter_list|)
name|char
modifier|*
name|statement
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|,
modifier|*
name|args
decl_stmt|;
comment|/* Isolate the actual directive. */
comment|/* Skip whitespace. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|directive
operator|=
operator|&
name|statement
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|statement
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|statement
index|[
name|i
index|]
condition|)
name|statement
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|statement
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|args
operator|=
operator|&
name|statement
index|[
name|i
index|]
expr_stmt|;
comment|/* Lookup the command, and act on it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|parser_directives
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|directive
argument_list|,
name|parser_directives
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|parser_directives
index|[
name|i
index|]
operator|.
name|function
operator|)
operator|(
name|args
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* *** Should an error message be output? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|substring_member_of_array
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Read the binding command from STRING and perform it.    A key binding command looks like: Keyname: function-name\0,    a variable binding command looks like: set variable value.    A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
end_comment

begin_macro
name|rl_parse_and_bind
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|funname
decl_stmt|,
modifier|*
name|kname
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|key
decl_stmt|,
name|equivalency
decl_stmt|;
while|while
condition|(
name|string
operator|&&
name|whitespace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
operator|||
operator|*
name|string
operator|==
literal|'#'
condition|)
return|return
literal|0
return|;
comment|/* If this is a parser directive, act on it. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'$'
condition|)
block|{
name|handle_parser_directive
argument_list|(
operator|&
name|string
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we aren't supposed to be parsing right now, then we're done. */
if|if
condition|(
name|_rl_parsing_conditionalized_out
condition|)
return|return
literal|0
return|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If this keyname is a complex key expression surrounded by quotes,      advance to after the matching close quote.  This code allows the      backslash to quote characters in the key expression. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
name|int
name|passc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|passc
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
block|}
block|}
comment|/* Advance to the colon (:) or whitespace which separates the two objects. */
for|for
control|(
init|;
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
operator|&&
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|equivalency
operator|=
operator|(
name|c
operator|==
literal|':'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'='
operator|)
expr_stmt|;
comment|/* Mark the end of the command (or keyname). */
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If doing assignment, skip the '=' sign as well. */
if|if
condition|(
name|equivalency
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If this is a command to set a variable, then do that. */
if|if
condition|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|var
init|=
name|string
operator|+
name|i
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Make VAR point to start of variable name. */
while|while
condition|(
operator|*
name|var
operator|&&
name|whitespace
argument_list|(
operator|*
name|var
argument_list|)
condition|)
name|var
operator|++
expr_stmt|;
comment|/* Make value point to start of value string. */
name|value
operator|=
name|var
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
name|whitespace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
name|rl_variable_bind
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Skip any whitespace between keyname and funname. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|funname
operator|=
operator|&
name|string
index|[
name|i
index|]
expr_stmt|;
comment|/* Now isolate funname.      For straight function names just look for whitespace, since      that will signify the end of the string.  But this could be a      macro definition.  In that case, the string is quoted, so skip      to the matching delimiter.  We allow the backslash to quote the      delimiter characters in the macro body. */
comment|/* This code exists to allow whitespace in macro expansions, which      would otherwise be gobbled up by the next `for' loop.*/
comment|/* XXX - it may be desirable to allow backslash quoting only if " is      the quoted string delimiter, like the shell. */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|int
name|delimiter
init|=
name|string
index|[
name|i
operator|++
index|]
decl_stmt|;
name|int
name|passc
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|passc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|delimiter
condition|)
break|break;
block|}
if|if
condition|(
name|c
condition|)
name|i
operator|++
expr_stmt|;
block|}
comment|/* Advance to the end of the string.  */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* No extra whitespace at the end of the string. */
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Handle equivalency bindings here.  Make the left-hand side be exactly      whatever the right-hand evaluates to, including keymaps. */
if|if
condition|(
name|equivalency
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If this is a new-style key-binding, then do the binding with      rl_set_key ().  Otherwise, let the older code deal with it. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|seq
init|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
name|int
name|passc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|string
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
comment|/* Allow backslash to quote characters, but leave them in place. 	     This allows a string to end with a backslash quoting another 	     backslash, or with a backslash quoting a double quote.  The 	     backslashes are left in place for rl_translate_keyseq (). */
if|if
condition|(
name|passc
operator|||
operator|(
name|string
index|[
name|j
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|seq
index|[
name|k
operator|++
index|]
operator|=
name|string
index|[
name|j
index|]
expr_stmt|;
name|passc
operator|=
operator|!
name|passc
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|string
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
break|break;
name|seq
index|[
name|k
operator|++
index|]
operator|=
name|string
index|[
name|j
index|]
expr_stmt|;
block|}
name|seq
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Binding macro? */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|j
operator|=
name|strlen
argument_list|(
name|funname
argument_list|)
expr_stmt|;
comment|/* Remove the delimiting quotes from each end of FUNNAME. */
if|if
condition|(
name|j
operator|&&
name|funname
index|[
name|j
operator|-
literal|1
index|]
operator|==
operator|*
name|funname
condition|)
name|funname
index|[
name|j
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_macro_bind
argument_list|(
name|seq
argument_list|,
operator|&
name|funname
index|[
literal|1
index|]
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_set_key
argument_list|(
name|seq
argument_list|,
name|rl_named_function
argument_list|(
name|funname
argument_list|)
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Get the actual character we want to deal with. */
name|kname
operator|=
name|strrchr
argument_list|(
name|string
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kname
condition|)
name|kname
operator|=
name|string
expr_stmt|;
else|else
name|kname
operator|++
expr_stmt|;
name|key
operator|=
name|glean_key_from_name
argument_list|(
name|kname
argument_list|)
expr_stmt|;
comment|/* Add in control and meta bits. */
if|if
condition|(
name|substring_member_of_array
argument_list|(
name|string
argument_list|,
name|possible_control_prefixes
argument_list|)
condition|)
name|key
operator|=
name|CTRL
argument_list|(
name|to_upper
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|substring_member_of_array
argument_list|(
name|string
argument_list|,
name|possible_meta_prefixes
argument_list|)
condition|)
name|key
operator|=
name|META
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Temporary.  Handle old-style keyname with macro-binding. */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|char
name|seq
index|[
literal|2
index|]
decl_stmt|;
name|int
name|fl
init|=
name|strlen
argument_list|(
name|funname
argument_list|)
decl_stmt|;
name|seq
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|seq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fl
operator|&&
name|funname
index|[
name|fl
operator|-
literal|1
index|]
operator|==
operator|*
name|funname
condition|)
name|funname
index|[
name|fl
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_macro_bind
argument_list|(
name|seq
argument_list|,
operator|&
name|funname
index|[
literal|1
index|]
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PREFIX_META_HACK
argument_list|)
comment|/* Ugly, but working hack to keep prefix-meta around. */
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|funname
argument_list|,
literal|"prefix-meta"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|seq
index|[
literal|2
index|]
decl_stmt|;
name|seq
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|seq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_generic_bind
argument_list|(
name|ISKMAP
argument_list|,
name|seq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|emacs_meta_keymap
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PREFIX_META_HACK */
else|else
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|rl_named_function
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Simple structure for boolean readline variables (i.e., those that can    have one of two values; either "On" or 1 for truth, or "Off" or 0 for    false. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
block|}
name|boolean_varlist
index|[]
init|=
block|{
block|{
literal|"horizontal-scroll-mode"
block|,
operator|&
name|_rl_horizontal_scroll_mode
block|}
block|,
block|{
literal|"mark-modified-lines"
block|,
operator|&
name|_rl_mark_modified_lines
block|}
block|,
block|{
literal|"meta-flag"
block|,
operator|&
name|_rl_meta_flag
block|}
block|,
block|{
literal|"blink-matching-paren"
block|,
operator|&
name|rl_blink_matching_paren
block|}
block|,
block|{
literal|"convert-meta"
block|,
operator|&
name|_rl_convert_meta_chars_to_ascii
block|}
block|,
block|{
literal|"show-all-if-ambiguous"
block|,
operator|&
name|_rl_complete_show_all
block|}
block|,
block|{
literal|"output-meta"
block|,
operator|&
name|_rl_output_meta_chars
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
block|{
literal|"visible-stats"
block|,
operator|&
name|rl_visible_stats
block|}
block|,
endif|#
directive|endif
comment|/* VISIBLE_STATS */
block|{
literal|"expand-tilde"
block|,
operator|&
name|rl_complete_with_tilde_expansion
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
operator|*
operator|)
name|NULL
block|}
block|}
struct|;
end_struct

begin_macro
name|rl_variable_bind
argument_list|(
argument|name
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Check for simple variables first. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A variable is TRUE if the "value" is "on", "1" or "". */
if|if
condition|(
operator|(
operator|!
operator|*
name|value
operator|)
operator|||
operator|(
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"On"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|value
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|value
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
operator|*
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Not a boolean variable, so check for specials. */
comment|/* Editing mode change? */
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"editing-mode"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strnicmp
argument_list|(
name|value
argument_list|,
literal|"vi"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
name|rl_editing_mode
operator|=
name|vi_mode
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
elseif|else
if|if
condition|(
name|strnicmp
argument_list|(
name|value
argument_list|,
literal|"emacs"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
name|rl_editing_mode
operator|=
name|emacs_mode
expr_stmt|;
block|}
block|}
comment|/* Comment string change? */
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"comment-begin"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
operator|*
name|value
condition|)
block|{
if|if
condition|(
name|rl_vi_comment_begin
condition|)
name|free
argument_list|(
name|rl_vi_comment_begin
argument_list|)
expr_stmt|;
name|rl_vi_comment_begin
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"completion-query-items"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|nval
init|=
literal|100
decl_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
block|{
name|nval
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
literal|0
condition|)
name|nval
operator|=
literal|0
expr_stmt|;
block|}
name|rl_completion_query_items
operator|=
name|nval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"keymap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Keymap
name|kmap
decl_stmt|;
name|kmap
operator|=
name|rl_get_keymap_by_name
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmap
condition|)
name|rl_set_keymap
argument_list|(
name|kmap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"bell-style"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|value
condition|)
name|_rl_bell_preference
operator|=
name|AUDIBLE_BELL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|||
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_bell_preference
operator|=
name|NO_BELL
expr_stmt|;
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"audible"
argument_list|)
operator|==
literal|0
operator|||
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_bell_preference
operator|=
name|AUDIBLE_BELL
expr_stmt|;
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"visible"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_bell_preference
operator|=
name|VISIBLE_BELL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"prefer-visible-bell"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Backwards compatibility. */
if|if
condition|(
operator|*
name|value
operator|&&
operator|(
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|*
name|value
operator|==
literal|'1'
operator|&&
operator|!
name|value
index|[
literal|1
index|]
operator|)
operator|)
condition|)
name|_rl_bell_preference
operator|=
name|VISIBLE_BELL
expr_stmt|;
else|else
name|_rl_bell_preference
operator|=
name|AUDIBLE_BELL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return the character which matches NAME.    For example, `Space' returns ' '. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|assoc_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|assoc_list
name|name_key_alist
index|[]
init|=
block|{
block|{
literal|"DEL"
block|,
literal|0x7f
block|}
block|,
block|{
literal|"ESC"
block|,
literal|'\033'
block|}
block|,
block|{
literal|"Escape"
block|,
literal|'\033'
block|}
block|,
block|{
literal|"LFD"
block|,
literal|'\n'
block|}
block|,
block|{
literal|"Newline"
block|,
literal|'\n'
block|}
block|,
block|{
literal|"RET"
block|,
literal|'\r'
block|}
block|,
block|{
literal|"Return"
block|,
literal|'\r'
block|}
block|,
block|{
literal|"Rubout"
block|,
literal|0x7f
block|}
block|,
block|{
literal|"SPC"
block|,
literal|' '
block|}
block|,
block|{
literal|"Space"
block|,
literal|' '
block|}
block|,
block|{
literal|"Tab"
block|,
literal|0x09
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|glean_key_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name_key_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|name_key_alist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name_key_alist
index|[
name|i
index|]
operator|.
name|value
operator|)
return|;
return|return
operator|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|name
operator|)
return|;
comment|/* XXX was return (*name) */
block|}
end_function

begin_comment
comment|/* Auxiliary functions to manage keymaps. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|}
name|keymap_names
index|[]
init|=
block|{
block|{
literal|"emacs"
block|,
name|emacs_standard_keymap
block|}
block|,
block|{
literal|"emacs-standard"
block|,
name|emacs_standard_keymap
block|}
block|,
block|{
literal|"emacs-meta"
block|,
name|emacs_meta_keymap
block|}
block|,
block|{
literal|"emacs-ctlx"
block|,
name|emacs_ctlx_keymap
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
block|{
literal|"vi"
block|,
name|vi_movement_keymap
block|}
block|,
block|{
literal|"vi-move"
block|,
name|vi_movement_keymap
block|}
block|,
block|{
literal|"vi-command"
block|,
name|vi_movement_keymap
block|}
block|,
block|{
literal|"vi-insert"
block|,
name|vi_insertion_keymap
block|}
block|,
endif|#
directive|endif
comment|/* VI_MODE */
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
operator|(
name|Keymap
operator|)
literal|0x0
block|}
block|}
struct|;
end_struct

begin_function
name|Keymap
name|rl_get_keymap_by_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keymap_names
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|keymap_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|keymap_names
index|[
name|i
index|]
operator|.
name|map
operator|)
return|;
return|return
operator|(
operator|(
name|Keymap
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rl_set_keymap
parameter_list|(
name|map
parameter_list|)
name|Keymap
name|map
decl_stmt|;
block|{
if|if
condition|(
name|map
condition|)
name|_rl_keymap
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_function
name|Keymap
name|rl_get_keymap
parameter_list|()
block|{
return|return
operator|(
name|_rl_keymap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rl_set_keymap_from_edit_mode
parameter_list|()
block|{
if|if
condition|(
name|rl_editing_mode
operator|==
name|emacs_mode
condition|)
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
elseif|else
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		  Key Binding and Function Information		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Each of the following functions produces information about the    state of keybindings and functions known to Readline.  The info    is always printed to rl_outstream, and in such a way that it can    be read back in (i.e., passed to rl_parse_and_bind (). */
end_comment

begin_comment
comment|/* Print the names of functions known to Readline. */
end_comment

begin_function
name|void
name|rl_list_funmap_names
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|funmap_names
decl_stmt|;
name|funmap_names
operator|=
name|rl_funmap_names
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|funmap_names
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|funmap_names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s\n"
argument_list|,
name|funmap_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|funmap_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of strings which represent the key    sequences that are used to invoke FUNCTION in MAP. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs_in_map
parameter_list|(
name|function
parameter_list|,
name|map
parameter_list|)
name|Function
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|key
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|result_index
decl_stmt|,
name|result_size
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|result_index
operator|=
name|result_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
literal|128
condition|;
name|key
operator|++
control|)
block|{
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISMACR
case|:
comment|/* Macros match, if, and only if, the pointers are identical. 	     Thus, they are treated exactly like functions in here. */
case|case
name|ISFUNC
case|:
comment|/* If the function in the keymap is the one we are looking for, 	     then add the current KEY to the list of invoking keys. */
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|==
name|function
condition|)
block|{
name|char
modifier|*
name|keyname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|CTRL_P
argument_list|(
name|key
argument_list|)
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\C-%c"
argument_list|,
name|to_lower
argument_list|(
name|UNCTRL
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
name|RUBOUT
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\C-?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
operator|||
name|key
operator|==
literal|'"'
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|keyname
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>
name|result_size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|result_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
operator|++
index|]
operator|=
name|keyname
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ISKMAP
case|:
block|{
name|char
modifier|*
modifier|*
name|seqs
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Find the list of keyseqs in this map which have FUNCTION as 	       their target.  Add the key sequences found to RESULT. */
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
condition|)
name|seqs
operator|=
name|rl_invoking_keyseqs_in_map
argument_list|(
name|function
argument_list|,
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqs
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|seqs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|keyname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|6
operator|+
name|strlen
argument_list|(
name|seqs
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|ESC
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\e"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CTRL_P
argument_list|(
name|key
argument_list|)
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\C-%c"
argument_list|,
name|to_lower
argument_list|(
name|UNCTRL
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
name|RUBOUT
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\C-?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
operator|||
name|key
operator|==
literal|'"'
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|keyname
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|keyname
argument_list|,
name|seqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>
name|result_size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|result_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
operator|++
index|]
operator|=
name|keyname
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|seqs
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of strings which represent the key    sequences that can be used to invoke FUNCTION using the current keymap. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs
parameter_list|(
name|function
parameter_list|)
name|Function
modifier|*
name|function
decl_stmt|;
block|{
return|return
operator|(
name|rl_invoking_keyseqs_in_map
argument_list|(
name|function
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print all of the current functions and their bindings to    rl_outstream.  If an explicit argument is given, then print    the output in such a way that it can be read back in. */
end_comment

begin_function
name|int
name|rl_dump_functions
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_function_dumper
argument_list|(
name|rl_explicit_arg
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print all of the functions and their bindings to rl_outstream.  If    PRINT_READABLY is non-zero, then print the output in such a way    that it can be read back in. */
end_comment

begin_function
name|void
name|rl_function_dumper
parameter_list|(
name|print_readably
parameter_list|)
name|int
name|print_readably
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|names
operator|=
name|rl_funmap_names
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
operator|=
name|names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Function
modifier|*
name|function
decl_stmt|;
name|char
modifier|*
modifier|*
name|invokers
decl_stmt|;
name|function
operator|=
name|rl_named_function
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|invokers
operator|=
name|rl_invoking_keyseqs_in_map
argument_list|(
name|function
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_readably
condition|)
block|{
if|if
condition|(
operator|!
name|invokers
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"# %s (not bound)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|invokers
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\"%s\": %s\n"
argument_list|,
name|invokers
index|[
name|j
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|invokers
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|invokers
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|invokers
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s is not bound to any keys\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s can be found on "
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|invokers
index|[
name|j
index|]
operator|&&
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\"%s\"%s"
argument_list|,
name|invokers
index|[
name|j
index|]
argument_list|,
name|invokers
index|[
name|j
operator|+
literal|1
index|]
condition|?
literal|", "
else|:
literal|".\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|5
operator|&&
name|invokers
index|[
name|j
index|]
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|invokers
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|invokers
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|invokers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound. */
end_comment

begin_function
name|void
name|_rl_bind_if_unbound
parameter_list|(
name|keyseq
parameter_list|,
name|default_func
parameter_list|)
name|char
modifier|*
name|keyseq
decl_stmt|;
name|Function
modifier|*
name|default_func
decl_stmt|;
block|{
name|Function
modifier|*
name|func
decl_stmt|;
if|if
condition|(
name|keyseq
condition|)
block|{
name|func
operator|=
name|rl_function_of_keyseq
argument_list|(
name|keyseq
argument_list|,
name|_rl_keymap
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
operator|||
name|func
operator|==
name|rl_do_lowercase_version
condition|)
name|rl_set_key
argument_list|(
name|keyseq
argument_list|,
name|default_func
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			String Utility Functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|strindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return non-zero if any members of ARRAY are a substring in STRING. */
end_comment

begin_function
specifier|static
name|int
name|substring_member_of_array
parameter_list|(
name|string
parameter_list|,
name|array
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
modifier|*
name|array
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|array
condition|)
block|{
if|if
condition|(
name|strindex
argument_list|(
name|string
argument_list|,
operator|*
name|array
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|array
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Determine if s2 occurs in s1.  If so, return a pointer to the    match in s1.  The compare is case insensitive. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strindex
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|len
operator|-
name|i
operator|)
operator|>=
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strnicmp
argument_list|(
operator|&
name|s1
index|[
name|i
index|]
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|s1
operator|+
name|i
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

end_unit

