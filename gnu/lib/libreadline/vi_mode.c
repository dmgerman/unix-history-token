begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vi_mode.c -- A vi emulation mode for Bash.    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			VI Emulation Mode			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|digit
end_ifndef

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isletter
end_ifndef

begin_define
define|#
directive|define
name|isletter
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'A'&& (c)<= 'Z') || ((c)>= 'a'&& (c)<= 'z'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit_value
end_ifndef

begin_define
define|#
directive|define
name|digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? (char *)strchr ((s), (c)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isident
end_ifndef

begin_define
define|#
directive|define
name|isident
parameter_list|(
name|c
parameter_list|)
value|((isletter(c) || digit(c) || c == '_'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|exchange
end_ifndef

begin_define
define|#
directive|define
name|exchange
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{int temp = x; x = y; y = temp;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VI_COMMENT_BEGIN_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|VI_COMMENT_BEGIN_DEFAULT
value|"#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Variables imported from readline.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_point
decl_stmt|,
name|rl_end
decl_stmt|,
name|rl_mark
decl_stmt|,
name|rl_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rl_instream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_line_buffer_len
decl_stmt|,
name|rl_explicit_arg
decl_stmt|,
name|rl_numeric_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Keymap
name|_rl_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_arg_sign
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|rl_extend_line_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|rl_vi_check
argument_list|()
decl_stmt|,
name|rl_digit_loop1
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means enter insertion mode. */
end_comment

begin_decl_stmt
name|int
name|_rl_vi_doing_insert
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String inserted into the line by rl_vi_comment (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_vi_comment_begin
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *** UNCLEAN *** */
end_comment

begin_comment
comment|/* Command keys which do movement for xxx_to commands. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_motion
init|=
literal|" hl^$0ftFt;,%wbeWBE|"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keymap used for vi replace characters.  Created dynamically since    rarely used. */
end_comment

begin_decl_stmt
specifier|static
name|Keymap
name|vi_replace_map
init|=
operator|(
name|Keymap
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters inserted in the last replace operation. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_replace_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_vi_last_command
init|=
literal|'i'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default `.' puts you in insert mode */
end_comment

begin_decl_stmt
name|int
name|_rl_vi_last_repeat
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_vi_last_arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_motion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_search_char
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_replacement
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vi_redoing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text modification commands.  These are the `redoable' commands. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_textmod
init|=
literal|"_*\\AaIiCcDdPpYyRrSsXx~"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rl_vi_set_last
parameter_list|()
block|{
name|_rl_vi_last_command
operator|=
literal|'i'
expr_stmt|;
name|_rl_vi_last_repeat
operator|=
literal|1
expr_stmt|;
name|_rl_vi_last_arg_sign
operator|=
literal|1
expr_stmt|;
name|_rl_vi_last_motion
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is the command C a VI mode text modification command? */
end_comment

begin_function
name|int
name|rl_vi_textmod_command
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|member
argument_list|(
name|c
argument_list|,
name|vi_textmod
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bound to `.'.  Called from command mode, so we know that we have to    redo a text modification command.  The default for _rl_vi_last_command    puts you back into insert mode. */
end_comment

begin_macro
name|rl_vi_redo
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|rl_explicit_arg
condition|)
block|{
name|rl_numeric_arg
operator|=
name|_rl_vi_last_repeat
expr_stmt|;
name|rl_arg_sign
operator|=
name|_rl_vi_last_arg_sign
expr_stmt|;
block|}
name|vi_redoing
operator|=
literal|1
expr_stmt|;
name|rl_dispatch
argument_list|(
name|_rl_vi_last_command
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
name|vi_redoing
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Yank the nth arg from the previous line into this line at point. */
end_comment

begin_macro
name|rl_vi_yank_arg
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* vi mode is defined to insert a space before the last argument. */
name|rl_insert
argument_list|(
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* Readline thinks that the first word on a line is the 0th, while vi      thinks the first word on a line is the 1st.  Compensate. */
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_yank_nth_arg
argument_list|(
name|count
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_yank_nth_arg
argument_list|(
literal|'$'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* With an argument, move back that many history lines, else move to the    beginning of history. */
end_comment

begin_macro
name|rl_vi_fetch_history
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|current
init|=
name|where_history
argument_list|()
decl_stmt|;
comment|/* Giving an argument of n means we want the nth command in the history      file.  The command number is interpreted the same way that the bash      `history' command does it -- that is, giving an argument count of 450      to this command would get the command listed as number 450 in the      output of `history'. */
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|int
name|wanted
init|=
name|history_base
operator|+
name|current
operator|-
name|count
decl_stmt|;
if|if
condition|(
name|wanted
operator|<=
literal|0
condition|)
name|rl_beginning_of_history
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_get_previous_history
argument_list|(
name|wanted
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_beginning_of_history
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Search again for the last thing searched for. */
end_comment

begin_macro
name|rl_vi_search_again
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'n'
case|:
name|rl_noninc_reverse_search_again
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|rl_noninc_forward_search_again
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Do a vi style search. */
end_comment

begin_macro
name|rl_vi_search
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'?'
case|:
name|rl_noninc_forward_search
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|rl_noninc_reverse_search
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Completion, from vi's point of view. */
end_comment

begin_macro
name|rl_vi_complete
argument_list|(
argument|ignore
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
operator|&&
operator|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|+
literal|1
index|]
argument_list|)
condition|)
name|rl_vi_end_word
argument_list|(
literal|1
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|'*'
condition|)
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
comment|/* Expansion and replacement. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'='
condition|)
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
comment|/* List possible completions. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
condition|)
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
comment|/* Standard Readline completion. */
else|else
name|rl_complete
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|'*'
operator|||
name|key
operator|==
literal|'\\'
condition|)
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Tilde expansion for vi mode. */
end_comment

begin_macro
name|rl_vi_tilde_expand
argument_list|(
argument|ignore
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_tilde_expand
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Previous word in vi mode. */
end_comment

begin_macro
name|rl_vi_prev_word
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_next_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_bWord
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|rl_vi_bword
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Next word in vi mode. */
end_comment

begin_macro
name|rl_vi_next_word
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_prev_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|>=
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_fWord
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|rl_vi_fword
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Move to the end of the ?next? word. */
end_comment

begin_macro
name|rl_vi_end_word
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_eWord
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|rl_vi_eword
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Move forward a word the way that 'W' does. */
end_comment

begin_macro
name|rl_vi_fWord
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Skip until whitespace. */
while|while
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Now skip whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_bWord
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
comment|/* If we are at the start of a word, move back to whitespace so 	 we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_eWord
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move to the next non-whitespace character (to the start of the 	 next word). */
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
comment|/* Skip whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Skip until whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move back to the last character of the word. */
name|rl_point
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_fword
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Move to white space (really non-identifer). */
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
else|else
comment|/* if (!whitespace (rl_line_buffer[rl_point])) */
block|{
while|while
condition|(
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
comment|/* Move past whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_bword
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
name|int
name|last_is_ident
decl_stmt|;
comment|/* If we are at the start of a word, move back to whitespace 	 so we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If this character and the previous character are `opposite', move 	 back so we don't get messed up by the rl_point++ down there in 	 the while loop.  Without this code, words like `l;' screw up the 	 function. */
name|last_is_ident
operator|=
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|last_is_ident
operator|)
operator|||
operator|(
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|last_is_ident
operator|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_eword
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
block|}
name|rl_point
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_insert_beg
argument_list|()
end_macro

begin_block
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_append_mode
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|+=
literal|1
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_append_eol
argument_list|()
end_macro

begin_block
block|{
name|rl_end_of_line
argument_list|()
expr_stmt|;
name|rl_vi_append_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* What to do in the case of C-d. */
end_comment

begin_macro
name|rl_vi_eof_maybe
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Insertion mode stuff. */
end_comment

begin_comment
comment|/* Switching from one mode to the other really just involves    switching keymaps. */
end_comment

begin_macro
name|rl_vi_insertion_mode
argument_list|()
end_macro

begin_block
block|{
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_movement_mode
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rl_vi_set_last
argument_list|()
expr_stmt|;
name|_rl_keymap
operator|=
name|vi_movement_keymap
expr_stmt|;
name|vi_done_inserting
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vi_done_inserting
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|_rl_vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_arg_digit
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
operator|&&
name|rl_numeric_arg
operator|==
literal|1
operator|&&
operator|!
name|rl_explicit_arg
condition|)
return|return
operator|(
name|rl_beg_of_line
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|rl_digit_argument
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_change_case
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
init|=
literal|0
decl_stmt|;
comment|/* Don't try this on an empty line. */
if|if
condition|(
name|rl_point
operator|>=
name|rl_end
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|uppercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|to_lower
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lowercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|to_upper
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Just skip over characters neither upper nor lower case. */
name|rl_forward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Vi is kind of strange here. */
if|if
condition|(
name|c
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_check
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_forward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_put
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|uppercase_p
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
name|rl_point
operator|+
literal|1
operator|<=
name|rl_end
operator|)
condition|)
name|rl_point
operator|++
expr_stmt|;
name|rl_yank
argument_list|()
expr_stmt|;
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_check
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_point
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_column
argument_list|(
argument|count
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|>
name|rl_end
condition|)
name|rl_end_of_line
argument_list|()
expr_stmt|;
else|else
name|rl_point
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|rl_vi_domove
parameter_list|(
name|key
parameter_list|,
name|nextkey
parameter_list|)
name|int
name|key
decl_stmt|,
decl|*
name|nextkey
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|save
decl_stmt|;
name|int
name|old_end
decl_stmt|;
name|rl_mark
operator|=
name|rl_point
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|vi_motion
argument_list|)
condition|)
block|{
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|save
operator|=
name|rl_numeric_arg
expr_stmt|;
name|rl_numeric_arg
operator|=
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_digit_loop1
argument_list|()
expr_stmt|;
name|rl_numeric_arg
operator|*=
name|save
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* real command */
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|key
operator|==
literal|'d'
operator|&&
name|c
operator|==
literal|'d'
operator|)
operator|||
operator|(
name|key
operator|==
literal|'y'
operator|&&
name|c
operator|==
literal|'y'
operator|)
operator|||
operator|(
name|key
operator|==
literal|'c'
operator|&&
name|c
operator|==
literal|'c'
operator|)
condition|)
block|{
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|_rl_vi_last_motion
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_rl_vi_last_motion
operator|=
name|c
expr_stmt|;
comment|/* Append a blank character temporarily so that the motion routines      work right at the end of the line. */
name|old_end
operator|=
name|rl_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_dispatch
argument_list|(
name|c
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
comment|/* Remove the blank that we added. */
name|rl_end
operator|=
name|old_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
name|rl_end
condition|)
name|rl_point
operator|=
name|rl_end
expr_stmt|;
comment|/* No change in position means the command failed. */
if|if
condition|(
name|rl_mark
operator|==
name|rl_point
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* rl_vi_f[wW]ord () leaves the cursor on the first character of the next      word.  If we are not at the end of the line, and we are on a      non-whitespace character, move back one (presumably to whitespace). */
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|||
name|c
operator|==
literal|'W'
operator|)
operator|&&
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If cw or cW, back up to the end of a word, so the behaviour of ce      or cE is the actual result.  Brute-force, no subtlety. */
if|if
condition|(
name|key
operator|==
literal|'c'
operator|&&
operator|(
name|to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
condition|)
block|{
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* Move past the end of the word so that the kill doesn't remove the 	 last letter of the previous word.  Only do this if we are not at 	 the end of the line. */
if|if
condition|(
operator|(
name|rl_point
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rl_mark
operator|<
name|rl_point
condition|)
name|exchange
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* A simplified loop for vi. Don't dispatch key at end.    Don't recognize minus sign? */
end_comment

begin_macro
name|rl_digit_loop1
argument_list|()
end_macro

begin_block
block|{
name|int
name|key
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rl_message
argument_list|(
literal|"(arg: %d) "
argument_list|,
name|rl_arg_sign
operator|*
name|rl_numeric_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key
operator|=
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_numeric_arg
operator|=
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|rl_numeric_arg
operator|=
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_stuff_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_delete_to
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vi_redoing
condition|)
name|rl_stuff_char
argument_list|(
name|_rl_vi_last_motion
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|h^0%bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_change_to
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|start_pos
decl_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vi_redoing
condition|)
name|rl_stuff_char
argument_list|(
name|_rl_vi_last_motion
argument_list|)
expr_stmt|;
name|start_pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark.  c[wW] are handled by special-case code in rl_vi_domove(),      and already leave the mark at the correct location. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|hwW^0%bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
comment|/* The cursor never moves with c[wW]. */
if|if
condition|(
operator|(
name|to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
operator|&&
name|rl_point
operator|<
name|start_pos
condition|)
name|rl_point
operator|=
name|start_pos
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_yank_to
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|save
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|h^0%bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_delete
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|rl_end
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|end
operator|=
name|rl_point
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|rl_end
condition|)
name|end
operator|=
name|rl_end
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Turn the current line into a comment in shell history.    A K*rn shell style function. */
end_comment

begin_macro
name|rl_vi_comment
argument_list|()
end_macro

begin_block
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_vi_comment_begin
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|rl_insert_text
argument_list|(
name|rl_vi_comment_begin
argument_list|)
expr_stmt|;
else|else
name|rl_insert_text
argument_list|(
name|VI_COMMENT_BEGIN_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Default. */
name|rl_redisplay
argument_list|()
expr_stmt|;
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\010'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_first_print
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|rl_back_to_indent
argument_list|()
operator|)
return|;
block|}
end_block

begin_macro
name|rl_back_to_indent
argument_list|(
argument|ignore1
argument_list|,
argument|ignore2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* NOTE: it is necessary that opposite directions are inverses */
end_comment

begin_define
define|#
directive|define
name|FTO
value|1
end_define

begin_comment
comment|/* forward to */
end_comment

begin_define
define|#
directive|define
name|BTO
value|-1
end_define

begin_comment
comment|/* backward to */
end_comment

begin_define
define|#
directive|define
name|FFIND
value|2
end_define

begin_comment
comment|/* forward find */
end_comment

begin_define
define|#
directive|define
name|BFIND
value|-2
end_define

begin_comment
comment|/* backward find */
end_comment

begin_macro
name|rl_vi_char_search
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|target
decl_stmt|;
specifier|static
name|int
name|orig_dir
decl_stmt|,
name|dir
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|';'
operator|||
name|key
operator|==
literal|','
condition|)
name|dir
operator|=
operator|(
name|key
operator|==
literal|';'
condition|?
name|orig_dir
else|:
operator|-
name|orig_dir
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|vi_redoing
condition|)
name|target
operator|=
name|_rl_vi_last_search_char
expr_stmt|;
else|else
name|_rl_vi_last_search_char
operator|=
name|target
operator|=
name|rl_getc
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'t'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|FTO
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|BTO
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|FFIND
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|BFIND
expr_stmt|;
break|break;
block|}
block|}
name|pos
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|pos
operator|--
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rl_line_buffer
index|[
name|pos
index|]
operator|==
name|target
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|BTO
condition|)
name|rl_point
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
else|else
name|rl_point
operator|=
name|pos
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|pos
operator|--
condition|)
do|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* dir> 0 */
if|if
condition|(
name|pos
operator|>=
name|rl_end
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rl_line_buffer
index|[
name|pos
index|]
operator|==
name|target
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|FTO
condition|)
name|rl_point
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
else|else
name|rl_point
operator|=
name|pos
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|++
name|pos
operator|<
name|rl_end
condition|)
do|;
if|if
condition|(
name|pos
operator|>=
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Match brackets */
end_comment

begin_macro
name|rl_vi_match
argument_list|()
end_macro

begin_block
block|{
name|int
name|count
init|=
literal|1
decl_stmt|,
name|brack
decl_stmt|,
name|pos
decl_stmt|;
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
name|rl_forward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|brack
operator|<=
literal|0
condition|)
block|{
name|rl_point
operator|=
name|pos
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|brack
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* brack> 0 */
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|++
name|pos
operator|<
name|rl_end
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|rl_point
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|rl_vi_bracktype
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
return|return
literal|1
return|;
case|case
literal|')'
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'['
case|:
return|return
literal|2
return|;
case|case
literal|']'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|'{'
case|:
return|return
literal|3
return|;
case|case
literal|'}'
case|:
return|return
operator|-
literal|3
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_macro
name|rl_vi_change_char
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vi_redoing
condition|)
name|c
operator|=
name|_rl_vi_last_replacement
expr_stmt|;
else|else
name|_rl_vi_last_replacement
operator|=
name|c
operator|=
name|rl_getc
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\033'
operator|||
name|c
operator|==
name|CTRL
argument_list|(
literal|'C'
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_subst
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|rl_kill_line
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_delete
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_overstrike
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|_rl_vi_doing_insert
operator|==
literal|0
condition|)
block|{
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vi_replace_count
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_overstrike_delete
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_do_undo
argument_list|()
condition|)
name|vi_replace_count
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|s
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
operator|&&
name|_rl_vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rl_vi_replace
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|vi_replace_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|vi_replace_map
condition|)
block|{
name|vi_replace_map
operator|=
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<
literal|127
condition|;
name|i
operator|++
control|)
name|vi_replace_map
index|[
name|i
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike
expr_stmt|;
name|vi_replace_map
index|[
name|RUBOUT
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
name|vi_replace_map
index|[
name|ESC
index|]
operator|.
name|function
operator|=
name|rl_vi_movement_mode
expr_stmt|;
name|vi_replace_map
index|[
name|RETURN
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
name|vi_replace_map
index|[
name|NEWLINE
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
comment|/* If the normal vi insertion keymap has ^H bound to erase, do the          same here.  Probably should remove the assignment to RUBOUT up          there, but I don't think it will make a difference in real life. */
if|if
condition|(
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|==
name|rl_rubout
condition|)
name|vi_replace_map
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
block|}
name|_rl_keymap
operator|=
name|vi_replace_map
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Try to complete the word we are standing on or the word that ends with    the previous character.  A space matches everything.  Word delimiters are    space and ;. */
end_comment

begin_macro
name|rl_vi_possible_completions
argument_list|()
end_macro

begin_block
block|{
name|int
name|save_pos
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|' '
operator|&&
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|';'
condition|)
block|{
while|while
condition|(
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|' '
operator|&&
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|';'
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rl_possible_completions
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save_pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

end_unit

