begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* display.c -- readline redisplay facility. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_comment
comment|/* Global and pseudo-global variables and functions    imported from readline.c. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|readline_echoing_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|term_clreol
decl_stmt|,
modifier|*
name|term_im
decl_stmt|,
modifier|*
name|term_ic
decl_stmt|,
modifier|*
name|term_ei
decl_stmt|,
modifier|*
name|term_DC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap variables. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|term_up
decl_stmt|,
modifier|*
name|term_dc
decl_stmt|,
modifier|*
name|term_cr
decl_stmt|,
modifier|*
name|term_IC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screenheight
decl_stmt|,
name|screenwidth
decl_stmt|,
name|screenchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|terminal_can_insert
decl_stmt|,
name|term_xn
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_rl_output_some_chars
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_rl_output_character_function
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|_rl_output_meta_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_horizontal_scroll_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_mark_modified_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_prefer_visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-global functions (local to the readline library) exported    by this file. */
end_comment

begin_decl_stmt
name|void
name|_rl_move_cursor_relative
argument_list|()
decl_stmt|,
name|_rl_output_some_chars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|_rl_move_vert
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|update_line
argument_list|()
decl_stmt|,
name|clear_to_eol
argument_list|()
decl_stmt|,
name|space_to_eol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_chars
argument_list|()
decl_stmt|,
name|insert_some_chars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Heuristic used to decide whether it is faster to move from CUR to NEW    by backing up or outputting a carriage return and moving forward. */
end_comment

begin_define
define|#
directive|define
name|CR_FASTER
parameter_list|(
name|new
parameter_list|,
name|cur
parameter_list|)
value|(((new) + 1)< ((cur) - (new)))
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Display stuff				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is the stuff that is hard for me.  I never seem to write good    display routines in C.  Let's see how I do this time. */
end_comment

begin_comment
comment|/* (PWP) Well... Good for a simple line updater, but totally ignores    the problems of input lines longer than the screen width.     update_line and the code that calls it makes a multiple line,    automatically wrapping line update.  Careful attention needs    to be paid to the vertical position variables. */
end_comment

begin_comment
comment|/* Keep two buffers; one which reflects the current contents of the    screen, and the other to draw what we think the new contents should    be.  Then compare the buffers, and make whatever changes to the    screen itself that we should.  Finally, make the buffer that we    just drew into be the one which reflects the current contents of the    screen, and place the cursor where it belongs.     Commands that want to can fix the display themselves, and then let    this function know that the display has been fixed by setting the    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
end_comment

begin_comment
comment|/* Global variables declared here. */
end_comment

begin_comment
comment|/* What YOU turn on when you have handled all redisplay yourself. */
end_comment

begin_decl_stmt
name|int
name|rl_display_fixed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stuff that gets printed out before the actual text of the line.    This is usually pointing to rl_prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_display_prompt
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-global variables declared here. */
end_comment

begin_comment
comment|/* The visible cursor position.  If you print some text, adjust this. */
end_comment

begin_decl_stmt
name|int
name|_rl_last_c_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_last_v_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines currently on screen minus 1. */
end_comment

begin_decl_stmt
name|int
name|_rl_vis_botlin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used only in this file. */
end_comment

begin_comment
comment|/* The last left edge of text that was displayed.  This is used when    doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_lmargin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line display buffers.  One is the line currently displayed on    the screen.  The other is the line about to be displayed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|visible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|invisible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A buffer for `modeline' messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|msg_buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero forces the redisplay even if we thought it was unnecessary. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forced_display
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default and initial buffer size.  Can grow. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_prompt_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|local_prompt
decl_stmt|,
modifier|*
name|local_prompt_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|visible_length
decl_stmt|,
name|prefix_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of invisible characters in the line currently being    displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_wrap_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The length (buffer offset) of the first line of the last (possibly    multi-line) buffer displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_first_line_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the prompt string S and return the number of visible    characters in *LP, if LP is not null.  This is currently more-or-less    a placeholder for expansion. */
end_comment

begin_comment
comment|/* Current implementation: 	\001 (^A) start non-visible characters 	\002 (^B) end non-visible characters    all characters except \001 and \002 (following a \001) are copied to    the returned string; all characters except those between \001 and    \002 are assumed to be `visible'. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|expand_prompt
parameter_list|(
name|pmt
parameter_list|,
name|lp
parameter_list|)
name|char
modifier|*
name|pmt
decl_stmt|;
name|int
modifier|*
name|lp
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|rl
decl_stmt|,
name|ignoring
decl_stmt|;
comment|/* Short-circuit if we can. */
if|if
condition|(
name|strchr
argument_list|(
name|pmt
argument_list|,
name|RL_PROMPT_START_IGNORE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|savestring
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
name|r
operator|=
name|ret
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|rl
operator|=
name|ignoring
operator|=
literal|0
operator|,
name|p
operator|=
name|pmt
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
comment|/* This code strips the invisible character string markers 	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
if|if
condition|(
operator|*
name|p
operator|==
name|RL_PROMPT_START_IGNORE
condition|)
block|{
name|ignoring
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ignoring
operator|&&
operator|*
name|p
operator|==
name|RL_PROMPT_END_IGNORE
condition|)
block|{
name|ignoring
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|r
operator|++
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ignoring
condition|)
name|rl
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|rl
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Expand the prompt string into the various display components, if  * necessary.  *  * local_prompt = expanded last line of string in rl_display_prompt  *		  (portion after the final newline)  * local_prompt_prefix = portion before last newline of rl_display_prompt,  *			 expanded via expand_prompt  * visible_length = number of visible characters in local_prompt  * prefix_length = number of visible characters in local_prompt_prefix  *  * This function is called once per call to readline().  It may also be  * called arbitrarily to expand the primary prompt.  *  * The return value is the number of visible characters on the last line  * of the (possibly multi-line) prompt.  */
end_comment

begin_function
name|int
name|rl_expand_prompt
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Clear out any saved values. */
if|if
condition|(
name|local_prompt
condition|)
name|free
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_prompt_prefix
condition|)
name|free
argument_list|(
name|local_prompt_prefix
argument_list|)
expr_stmt|;
name|local_prompt
operator|=
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
literal|0
operator|||
operator|*
name|prompt
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|strrchr
argument_list|(
name|prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|/* The prompt is only one line. */
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|visible_length
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|visible_length
operator|)
return|;
block|}
else|else
block|{
comment|/* The prompt spans multiple lines. */
name|t
operator|=
operator|++
name|p
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|p
argument_list|,
operator|&
name|visible_length
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
comment|/* The portion of the prompt string up to and including the 	 final newline is now null-terminated. */
name|local_prompt_prefix
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|prefix_length
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|prefix_length
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Basic redisplay algorithm. */
end_comment

begin_function
name|void
name|rl_redisplay
parameter_list|()
block|{
specifier|register
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|c
decl_stmt|,
name|linenum
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
init|=
name|invisible_line
decl_stmt|;
name|int
name|c_pos
init|=
literal|0
decl_stmt|,
name|inv_botlin
init|=
literal|0
decl_stmt|,
name|wrap_offset
decl_stmt|,
name|wrap_column
decl_stmt|;
name|char
modifier|*
name|prompt_this_line
decl_stmt|;
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
return|return;
if|if
condition|(
operator|!
name|rl_display_prompt
condition|)
name|rl_display_prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|invisible_line
condition|)
block|{
name|visible_line
operator|=
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|line_size
condition|;
name|in
operator|++
control|)
block|{
name|visible_line
index|[
name|in
index|]
operator|=
literal|0
expr_stmt|;
name|invisible_line
index|[
name|in
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
comment|/* Draw the line into the buffer. */
name|c_pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark the line as modified or not.  We only do this for history      lines. */
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_rl_mark_modified_lines
operator|&&
name|current_history
argument_list|()
operator|&&
name|rl_undo_list
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If someone thought that the redisplay was handled, but the currently      visible line has a different modification state than the one about      to become visible, then correct the caller's misconception. */
if|if
condition|(
name|visible_line
index|[
literal|0
index|]
operator|!=
name|invisible_line
index|[
literal|0
index|]
condition|)
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If the prompt to be displayed is the `primary' readline prompt (the      one passed to readline()), use the values we have already expanded.      If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the      number of non-visible characters in the prompt string. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
condition|)
block|{
name|int
name|local_len
init|=
name|local_prompt
condition|?
name|strlen
argument_list|(
name|local_prompt
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|local_prompt_prefix
operator|&&
name|forced_display
condition|)
name|_rl_output_some_chars
argument_list|(
name|local_prompt_prefix
argument_list|,
name|strlen
argument_list|(
name|local_prompt_prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_len
operator|>
literal|0
condition|)
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|local_prompt
argument_list|,
name|local_len
argument_list|)
expr_stmt|;
name|out
operator|+=
name|local_len
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
name|local_len
operator|-
name|visible_length
expr_stmt|;
block|}
else|else
block|{
name|int
name|pmtlen
decl_stmt|;
name|prompt_this_line
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_this_line
condition|)
name|prompt_this_line
operator|=
name|rl_display_prompt
expr_stmt|;
else|else
block|{
name|prompt_this_line
operator|++
expr_stmt|;
if|if
condition|(
name|forced_display
condition|)
name|_rl_output_some_chars
argument_list|(
name|rl_display_prompt
argument_list|,
name|prompt_this_line
operator|-
name|rl_display_prompt
argument_list|)
expr_stmt|;
block|}
name|pmtlen
operator|=
name|strlen
argument_list|(
name|prompt_this_line
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|prompt_this_line
argument_list|,
name|pmtlen
argument_list|)
expr_stmt|;
name|out
operator|+=
name|pmtlen
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|rl_end
condition|;
name|in
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|rl_line_buffer
index|[
name|in
index|]
expr_stmt|;
if|if
condition|(
name|out
operator|+
literal|8
operator|>=
name|line_size
condition|)
comment|/* XXX - 8 for \t */
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
name|visible_line
operator|=
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
name|c_pos
operator|=
name|out
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_output_meta_chars
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|line
operator|+
name|out
argument_list|,
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
specifier|register
name|int
name|newout
init|=
operator|(
name|out
operator||
operator|(
name|int
operator|)
literal|7
operator|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
name|UNCTRL
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* XXX was c ^ 0x40 */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c_pos
operator|<
literal|0
condition|)
name|c_pos
operator|=
name|out
expr_stmt|;
comment|/* C_POS == position in buffer where cursor should be placed. */
comment|/* PWP: now is when things get a bit hairy.  The visible and invisible      line buffers are really multiple lines, which would wrap every      (screenwidth - 1) characters.  Go through each in turn, finding      the changed region and updating it.  The line order is top to bottom. */
comment|/* If we can move the cursor up and down, then use multiple lines,      otherwise, let long lines display in a single terminal line, and      horizontally scroll it. */
if|if
condition|(
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|term_up
operator|&&
operator|*
name|term_up
condition|)
block|{
name|int
name|total_screen_chars
init|=
name|screenchars
decl_stmt|;
name|int
name|nleft
decl_stmt|,
name|cursor_linenum
decl_stmt|,
name|pos
decl_stmt|,
name|changed_screen_line
decl_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
comment|/* If we have more than a screenful of material to display, then 	     only display a screenful.  We should display the last screen, 	     not the first.  I'll fix this in a minute. */
if|if
condition|(
name|out
operator|>=
name|total_screen_chars
condition|)
name|out
operator|=
name|total_screen_chars
operator|-
literal|1
expr_stmt|;
comment|/* Number of screen lines to display.  The first line wraps at 	     (screenwidth + wrap_offset) chars, the rest of the lines have 	     screenwidth chars. */
name|nleft
operator|=
name|out
operator|-
name|wrap_offset
operator|+
name|term_xn
operator|-
literal|1
expr_stmt|;
name|inv_botlin
operator|=
operator|(
name|nleft
operator|>
literal|0
operator|)
condition|?
name|nleft
operator|/
name|screenwidth
else|:
literal|0
expr_stmt|;
comment|/* The first line is at character position 0 in the buffer.  The 	     second and subsequent lines start at N * screenwidth, offset by 	     OFFSET.  OFFSET is wrap_offset for the invisible line and 	     visible_wrap_offset for the line currently displayed. */
define|#
directive|define
name|W_OFFSET
parameter_list|(
name|line
parameter_list|,
name|offset
parameter_list|)
value|((line) == 0 ? offset : 0)
define|#
directive|define
name|L_OFFSET
parameter_list|(
name|n
parameter_list|,
name|offset
parameter_list|)
value|((n)> 0 ? ((n) * screenwidth) + (offset) : 0)
define|#
directive|define
name|VIS_CHARS
parameter_list|(
name|line
parameter_list|)
value|&visible_line[L_OFFSET((line), visible_wrap_offset)]
define|#
directive|define
name|VIS_LINE
parameter_list|(
name|line
parameter_list|)
value|((line)> _rl_vis_botlin) ? "" : VIS_CHARS(line)
define|#
directive|define
name|INV_LINE
parameter_list|(
name|line
parameter_list|)
value|&invisible_line[L_OFFSET((line), wrap_offset)]
comment|/* For each line in the buffer, do the updating display. */
for|for
control|(
name|linenum
operator|=
literal|0
init|;
name|linenum
operator|<=
name|inv_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|update_line
argument_list|(
name|VIS_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|INV_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|linenum
argument_list|,
name|screenwidth
operator|+
name|W_OFFSET
argument_list|(
name|linenum
argument_list|,
name|visible_wrap_offset
argument_list|)
argument_list|,
name|screenwidth
operator|+
name|W_OFFSET
argument_list|(
name|linenum
argument_list|,
name|wrap_offset
argument_list|)
argument_list|,
name|inv_botlin
argument_list|)
expr_stmt|;
comment|/* If this is the line with the prompt, we might need to 		 compensate for invisible characters in the new line. Do 		 this only if there is not more than one new line (which 		 implies that we completely overwrite the old visible line) 		 and the new line is shorter than the old. */
if|if
condition|(
name|linenum
operator|==
literal|0
operator|&&
name|inv_botlin
operator|==
literal|0
operator|&&
operator|(
name|wrap_offset
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|<
name|visible_first_line_len
operator|)
condition|)
block|{
name|nleft
operator|=
name|screenwidth
operator|+
name|wrap_offset
operator|-
name|_rl_last_c_pos
expr_stmt|;
if|if
condition|(
name|nleft
condition|)
name|clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
comment|/* Since the new first line is now visible, save its length. */
if|if
condition|(
name|linenum
operator|==
literal|0
condition|)
name|visible_first_line_len
operator|=
operator|(
name|inv_botlin
operator|>
literal|0
operator|)
condition|?
name|screenwidth
else|:
name|out
operator|-
name|wrap_offset
expr_stmt|;
block|}
comment|/* We may have deleted some lines.  If so, clear the left over 	     blank ones at the bottom out. */
if|if
condition|(
name|_rl_vis_botlin
operator|>
name|inv_botlin
condition|)
block|{
name|char
modifier|*
name|tt
decl_stmt|;
for|for
control|(
init|;
name|linenum
operator|<=
name|_rl_vis_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|tt
operator|=
name|VIS_CHARS
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|clear_to_eol
argument_list|(
operator|(
name|linenum
operator|==
name|_rl_vis_botlin
operator|)
condition|?
name|strlen
argument_list|(
name|tt
argument_list|)
else|:
name|screenwidth
argument_list|)
expr_stmt|;
block|}
block|}
name|_rl_vis_botlin
operator|=
name|inv_botlin
expr_stmt|;
comment|/* Move the cursor where it should be. */
comment|/* Which line? */
name|nleft
operator|=
name|c_pos
operator|-
name|wrap_offset
operator|+
name|term_xn
operator|-
literal|1
expr_stmt|;
name|cursor_linenum
operator|=
operator|(
name|nleft
operator|>
literal|0
operator|)
condition|?
name|nleft
operator|/
name|screenwidth
else|:
literal|0
expr_stmt|;
comment|/* CHANGED_SCREEN_LINE is set to 1 if we have moved to a 	     different screen line during this redisplay. */
name|changed_screen_line
operator|=
name|_rl_last_v_pos
operator|!=
name|cursor_linenum
expr_stmt|;
if|if
condition|(
name|changed_screen_line
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|cursor_linenum
argument_list|)
expr_stmt|;
comment|/* If we moved up to the line with the prompt using term_up, 	         the physical cursor position on the screen stays the same, 	         but the buffer position needs to be adjusted to account 	         for invisible characters. */
if|if
condition|(
name|cursor_linenum
operator|==
literal|0
operator|&&
name|wrap_offset
condition|)
name|_rl_last_c_pos
operator|+=
name|wrap_offset
expr_stmt|;
block|}
comment|/* We have to reprint the prompt if it contains invisible 	     characters, since it's not generally OK to just reprint 	     the characters from the current cursor position. */
name|nleft
operator|=
name|visible_length
operator|+
name|wrap_offset
expr_stmt|;
if|if
condition|(
name|cursor_linenum
operator|==
literal|0
operator|&&
name|wrap_offset
operator|>
literal|0
operator|&&
name|_rl_last_c_pos
operator|>
literal|0
operator|&&
name|_rl_last_c_pos
operator|<=
name|nleft
operator|&&
name|local_prompt
condition|)
block|{
if|if
condition|(
name|term_cr
condition|)
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_output_some_chars
argument_list|(
name|local_prompt
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|nleft
expr_stmt|;
block|}
comment|/* Where on that line?  And where does that line start 	     in the buffer? */
name|pos
operator|=
name|L_OFFSET
argument_list|(
name|cursor_linenum
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
comment|/* nleft == number of characters in the line buffer between the 	     start of the line and the cursor position. */
name|nleft
operator|=
name|c_pos
operator|-
name|pos
expr_stmt|;
comment|/* Since backspace() doesn't know about invisible characters in the 	     prompt, and there's no good way to tell it, we compensate for 	     those characters here and call backspace() directly. */
if|if
condition|(
name|wrap_offset
operator|&&
name|cursor_linenum
operator|==
literal|0
operator|&&
name|nleft
operator|<
name|_rl_last_c_pos
condition|)
block|{
name|backspace
argument_list|(
name|_rl_last_c_pos
operator|-
name|nleft
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|nleft
expr_stmt|;
block|}
if|if
condition|(
name|nleft
operator|!=
name|_rl_last_c_pos
condition|)
name|_rl_move_cursor_relative
argument_list|(
name|nleft
argument_list|,
operator|&
name|invisible_line
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Do horizontal scrolling. */
block|{
define|#
directive|define
name|M_OFFSET
parameter_list|(
name|margin
parameter_list|,
name|offset
parameter_list|)
value|((margin) == 0 ? offset : 0)
name|int
name|lmargin
decl_stmt|,
name|ndisp
decl_stmt|,
name|nleft
decl_stmt|,
name|phys_c_pos
decl_stmt|,
name|t
decl_stmt|;
comment|/* Always at top line. */
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
comment|/* Compute where in the buffer the displayed line should start.  This 	 will be LMARGIN. */
comment|/* The number of characters that will be displayed before the cursor. */
name|ndisp
operator|=
name|c_pos
operator|-
name|wrap_offset
expr_stmt|;
name|nleft
operator|=
name|visible_length
operator|+
name|wrap_offset
expr_stmt|;
comment|/* Where the new cursor position will be on the screen.  This can be          longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
name|phys_c_pos
operator|=
name|c_pos
operator|-
operator|(
name|last_lmargin
condition|?
name|last_lmargin
else|:
name|wrap_offset
operator|)
expr_stmt|;
name|t
operator|=
name|screenwidth
operator|/
literal|3
expr_stmt|;
comment|/* If the number of characters had already exceeded the screenwidth,          last_lmargin will be> 0. */
comment|/* If the number of characters to be displayed is more than the screen          width, compute the starting offset so that the cursor is about          two-thirds of the way across the screen. */
if|if
condition|(
name|phys_c_pos
operator|>
name|screenwidth
operator|-
literal|2
condition|)
block|{
name|lmargin
operator|=
name|c_pos
operator|-
operator|(
literal|2
operator|*
name|t
operator|)
expr_stmt|;
if|if
condition|(
name|lmargin
operator|<
literal|0
condition|)
name|lmargin
operator|=
literal|0
expr_stmt|;
comment|/* If the left margin would be in the middle of a prompt with 	     invisible characters, don't display the prompt at all. */
if|if
condition|(
name|wrap_offset
operator|&&
name|lmargin
operator|>
literal|0
operator|&&
name|lmargin
operator|<
name|nleft
condition|)
name|lmargin
operator|=
name|nleft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndisp
operator|<
name|screenwidth
operator|-
literal|2
condition|)
comment|/* XXX - was -1 */
name|lmargin
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|phys_c_pos
operator|<
literal|1
condition|)
block|{
comment|/* If we are moving back towards the beginning of the line and 	     the last margin is no longer correct, compute a new one. */
name|lmargin
operator|=
operator|(
operator|(
name|c_pos
operator|-
literal|1
operator|)
operator|/
name|t
operator|)
operator|*
name|t
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|wrap_offset
operator|&&
name|lmargin
operator|>
literal|0
operator|&&
name|lmargin
operator|<
name|nleft
condition|)
name|lmargin
operator|=
name|nleft
expr_stmt|;
block|}
else|else
name|lmargin
operator|=
name|last_lmargin
expr_stmt|;
comment|/* If the first character on the screen isn't the first character 	 in the display line, indicate this with a special character. */
if|if
condition|(
name|lmargin
operator|>
literal|0
condition|)
name|line
index|[
name|lmargin
index|]
operator|=
literal|'<'
expr_stmt|;
comment|/* If SCREENWIDTH characters starting at LMARGIN do not encompass          the whole line, indicate that with a special characters at the          right edge of the screen.  If LMARGIN is 0, we need to take the          wrap offset into account. */
name|t
operator|=
name|lmargin
operator|+
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
operator|+
name|screenwidth
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|out
condition|)
name|line
index|[
name|t
operator|-
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
operator|||
name|lmargin
operator|!=
name|last_lmargin
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
name|update_line
argument_list|(
operator|&
name|visible_line
index|[
name|last_lmargin
index|]
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|,
literal|0
argument_list|,
name|screenwidth
operator|+
name|visible_wrap_offset
argument_list|,
name|screenwidth
operator|+
operator|(
name|lmargin
condition|?
literal|0
else|:
name|wrap_offset
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the visible new line is shorter than the old, but the number 	     of invisible characters is greater, and we are at the end of 	     the new line, we need to clear to eol. */
name|t
operator|=
name|_rl_last_c_pos
operator|-
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|==
name|out
operator|)
operator|&&
name|t
operator|<
name|visible_first_line_len
condition|)
block|{
name|nleft
operator|=
name|screenwidth
operator|-
name|t
expr_stmt|;
name|clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
name|visible_first_line_len
operator|=
name|out
operator|-
name|lmargin
operator|-
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible_first_line_len
operator|>
name|screenwidth
condition|)
name|visible_first_line_len
operator|=
name|screenwidth
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|c_pos
operator|-
name|lmargin
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
name|lmargin
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
comment|/* Swap visible and non-visible lines. */
block|{
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
name|visible_line
operator|=
name|invisible_line
expr_stmt|;
name|invisible_line
operator|=
name|temp
expr_stmt|;
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If we are displaying on a single line, and last_lmargin is> 0, we        are not displaying any invisible characters, so set visible_wrap_offset        to 0. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|last_lmargin
condition|)
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
else|else
name|visible_wrap_offset
operator|=
name|wrap_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PWP: update_line() is based on finding the middle difference of each    line on the screen; vis:  			     /old first difference 	/beginning of line   |	      /old last same       /old EOL 	v		     v	      v		    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^	^			   ^ 	\beginning of line   |	\new last same	   \new end of line 			     \new first difference     All are character pointers for the sake of speed.  Special cases for    no differences, as well as for end of line additions must be handeled.     Could be made even smarter, but this works well enough */
end_comment

begin_function
specifier|static
name|void
name|update_line
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|current_line
parameter_list|,
name|omax
parameter_list|,
name|nmax
parameter_list|,
name|inv_botlin
parameter_list|)
specifier|register
name|char
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|current_line
decl_stmt|,
name|omax
decl_stmt|,
name|nmax
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|lendiff
decl_stmt|,
name|wsatend
decl_stmt|,
name|od
decl_stmt|,
name|nd
decl_stmt|;
comment|/* If we're at the right edge of a terminal that supports xn, we're      ready to wrap around, so do so.  This fixes problems with knowing      the exact cursor position and cut-and-paste with certain terminal      emulators.  In this calculation, TEMP is the physical screen      position of the cursor. */
name|temp
operator|=
name|_rl_last_c_pos
operator|-
name|W_OFFSET
argument_list|(
name|_rl_last_v_pos
argument_list|,
name|visible_wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|screenwidth
operator|&&
name|term_xn
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_last_v_pos
operator|==
name|current_line
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|new
index|[
literal|0
index|]
condition|)
name|putc
argument_list|(
name|new
index|[
literal|0
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|_rl_last_v_pos
operator|++
expr_stmt|;
if|if
condition|(
name|old
index|[
literal|0
index|]
operator|&&
name|new
index|[
literal|0
index|]
condition|)
name|old
index|[
literal|0
index|]
operator|=
name|new
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Find first difference. */
for|for
control|(
name|ofd
operator|=
name|old
operator|,
name|nfd
operator|=
name|new
init|;
operator|(
name|ofd
operator|-
name|old
operator|<
name|omax
operator|)
operator|&&
operator|*
name|ofd
operator|&&
operator|(
operator|*
name|ofd
operator|==
operator|*
name|nfd
operator|)
condition|;
name|ofd
operator|++
operator|,
name|nfd
operator|++
control|)
empty_stmt|;
comment|/* Move to the end of the screen line.  ND and OD are used to keep track      of the distance between ne and new and oe and old, respectively, to      move a subtraction out of each loop. */
for|for
control|(
name|od
operator|=
name|ofd
operator|-
name|old
operator|,
name|oe
operator|=
name|ofd
init|;
name|od
operator|<
name|omax
operator|&&
operator|*
name|oe
condition|;
name|oe
operator|++
operator|,
name|od
operator|++
control|)
empty_stmt|;
for|for
control|(
name|nd
operator|=
name|nfd
operator|-
name|new
operator|,
name|ne
operator|=
name|nfd
init|;
name|nd
operator|<
name|nmax
operator|&&
operator|*
name|ne
condition|;
name|ne
operator|++
operator|,
name|nd
operator|++
control|)
empty_stmt|;
comment|/* If no difference, continue to next line. */
if|if
condition|(
name|ofd
operator|==
name|oe
operator|&&
name|nfd
operator|==
name|ne
condition|)
return|return;
name|wsatend
operator|=
literal|1
expr_stmt|;
comment|/* flag for trailing whitespace */
name|ols
operator|=
name|oe
operator|-
literal|1
expr_stmt|;
comment|/* find last same */
name|nls
operator|=
name|ne
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ols
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|nls
operator|>
name|nfd
operator|)
operator|&&
operator|(
operator|*
name|ols
operator|==
operator|*
name|nls
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|ols
operator|!=
literal|' '
condition|)
name|wsatend
operator|=
literal|0
expr_stmt|;
name|ols
operator|--
expr_stmt|;
name|nls
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|wsatend
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ols
operator|!=
operator|*
name|nls
condition|)
block|{
if|if
condition|(
operator|*
name|ols
condition|)
comment|/* don't step past the NUL */
name|ols
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nls
condition|)
name|nls
operator|++
expr_stmt|;
block|}
name|_rl_move_vert
argument_list|(
name|current_line
argument_list|)
expr_stmt|;
comment|/* If this is the first line and there are invisible characters in the      prompt string, and the prompt string has not changed, then redraw      the entire prompt string.  We can only do this reliably if the      terminal supports a `cr' capability.       This is more than just an efficiency hack -- there is a problem with      redrawing portions of the prompt string if they contain terminal      escape sequences (like drawing the `unbold' sequence without a      corresponding `bold') that manifests itself on certain terminals. */
name|lendiff
operator|=
name|strlen
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_line
operator|==
literal|0
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|lendiff
operator|>
name|visible_length
operator|&&
name|_rl_last_c_pos
operator|>
literal|0
operator|&&
operator|(
name|ofd
operator|-
name|old
operator|)
operator|>=
name|lendiff
operator|&&
name|term_cr
condition|)
block|{
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_output_some_chars
argument_list|(
name|local_prompt
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|lendiff
expr_stmt|;
block|}
name|_rl_move_cursor_relative
argument_list|(
name|ofd
operator|-
name|old
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* if (len (new)> len (old)) */
name|lendiff
operator|=
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
operator|(
name|ols
operator|-
name|ofd
operator|)
expr_stmt|;
comment|/* Insert (diff (len (old), len (new)) ch. */
name|temp
operator|=
name|ne
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
name|lendiff
operator|>
literal|0
condition|)
block|{
comment|/* Non-zero if we're increasing the number of lines. */
name|int
name|gl
init|=
name|current_line
operator|>=
name|_rl_vis_botlin
operator|&&
name|inv_botlin
operator|>
name|_rl_vis_botlin
decl_stmt|;
comment|/* Sometimes it is cheaper to print the characters rather than 	 use the terminal's capabilities.  If we're growing the number 	 of lines, make sure we actually cause the new line to wrap 	 around on auto-wrapping terminals. */
if|if
condition|(
name|terminal_can_insert
operator|&&
operator|(
operator|(
literal|2
operator|*
name|temp
operator|)
operator|>=
name|lendiff
operator|||
name|term_IC
operator|)
operator|&&
operator|(
operator|!
name|term_xn
operator|||
operator|!
name|gl
operator|)
condition|)
block|{
comment|/* If lendiff> visible_length and _rl_last_c_pos == 0 and 	     _rl_horizontal_scroll_mode == 1, inserting the characters with 	     term_IC or term_ic will screw up the screen because of the 	     invisible characters.  We need to just draw them. */
if|if
condition|(
operator|*
name|ols
operator|&&
operator|(
operator|!
name|_rl_horizontal_scroll_mode
operator|||
name|_rl_last_c_pos
operator|>
literal|0
operator|||
name|lendiff
operator|<=
name|visible_length
operator|)
condition|)
block|{
name|insert_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
else|else
block|{
comment|/* At the end of a line the characters do not have to 		 be "inserted".  They can just be placed on the screen. */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
comment|/* Copy (new) chars to screen from first diff to last match. */
name|temp
operator|=
name|nls
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|-
name|lendiff
operator|)
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
operator|+
name|lendiff
argument_list|,
name|temp
operator|-
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
operator|-
name|lendiff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot insert chars, write to EOL */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
block|}
block|}
else|else
comment|/* Delete characters from line. */
block|{
comment|/* If possible and inexpensive to use terminal deletion, then do so. */
if|if
condition|(
name|term_dc
operator|&&
operator|(
literal|2
operator|*
name|temp
operator|)
operator|>=
operator|-
name|lendiff
condition|)
block|{
comment|/* If all we're doing is erasing the invisible characters in the 	     prompt string, don't bother.  It screws up the assumptions 	     about what's on the screen. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_last_c_pos
operator|==
literal|0
operator|&&
operator|-
name|lendiff
operator|==
name|visible_wrap_offset
condition|)
name|lendiff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lendiff
condition|)
name|delete_chars
argument_list|(
operator|-
name|lendiff
argument_list|)
expr_stmt|;
comment|/* delete (diff) characters */
comment|/* Copy (new) chars to screen from first diff to last match */
name|temp
operator|=
name|nls
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Otherwise, print over the existing material. */
else|else
block|{
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
block|}
name|lendiff
operator|=
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
expr_stmt|;
if|if
condition|(
name|term_xn
operator|&&
name|current_line
operator|<
name|inv_botlin
condition|)
name|space_to_eol
argument_list|(
name|lendiff
argument_list|)
expr_stmt|;
else|else
name|clear_to_eol
argument_list|(
name|lendiff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Tell the update routines that we have moved onto a new (empty) line. */
end_comment

begin_macro
name|rl_on_new_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|visible_line
condition|)
name|visible_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
name|_rl_vis_botlin
operator|=
name|last_lmargin
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Actually update the display, period. */
end_comment

begin_macro
name|rl_forced_update_display
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|visible_line
condition|)
block|{
specifier|register
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
while|while
condition|(
operator|*
name|temp
condition|)
operator|*
name|temp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|forced_display
operator|++
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.    DATA is the contents of the screen line of interest; i.e., where    the movement is being done. */
end_comment

begin_function
name|void
name|_rl_move_cursor_relative
parameter_list|(
name|new
parameter_list|,
name|data
parameter_list|)
name|int
name|new
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we don't have to do anything, then return. */
if|if
condition|(
name|_rl_last_c_pos
operator|==
name|new
condition|)
return|return;
comment|/* It may be faster to output a CR, and then move forwards instead      of moving backwards. */
comment|/* i == current physical cursor position. */
name|i
operator|=
name|_rl_last_c_pos
operator|-
name|W_OFFSET
argument_list|(
name|_rl_last_v_pos
argument_list|,
name|visible_wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|CR_FASTER
argument_list|(
name|new
argument_list|,
name|_rl_last_c_pos
argument_list|)
operator|||
operator|(
name|term_xn
operator|&&
name|i
operator|==
name|screenwidth
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__MSDOS__ */
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_rl_last_c_pos
operator|<
name|new
condition|)
block|{
comment|/* Move the cursor forward.  We do it by printing the command 	 to move the cursor forward if there is one, else print that 	 portion of the output buffer again.  Which is cheaper? */
comment|/* The above comment is left here for posterity.  It is faster 	 to print one character (non-control) than to print a control 	 sequence telling the terminal to move forward one character. 	 That kind of control is for people who don't know what the 	 data is underneath the cursor. */
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
specifier|extern
name|char
modifier|*
name|term_forward_char
decl_stmt|;
if|if
condition|(
name|term_forward_char
condition|)
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_forward_char
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
block|}
elseif|else
if|if
condition|(
name|_rl_last_c_pos
operator|!=
name|new
condition|)
name|backspace
argument_list|(
name|_rl_last_c_pos
operator|-
name|new
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PWP: move the cursor up or down. */
end_comment

begin_function
name|void
name|_rl_move_vert
parameter_list|(
name|to
parameter_list|)
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|delta
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|_rl_last_v_pos
operator|==
name|to
operator|||
name|to
operator|>
name|screenheight
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|ScreenSetCursor
argument_list|(
operator|(
name|row
operator|+
name|to
operator|-
name|_rl_last_v_pos
operator|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !__GO32__ */
if|if
condition|(
operator|(
name|delta
operator|=
name|to
operator|-
name|_rl_last_v_pos
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|delta
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* delta< 0 */
if|if
condition|(
name|term_up
operator|&&
operator|*
name|term_up
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|delta
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_up
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
name|_rl_last_v_pos
operator|=
name|to
expr_stmt|;
comment|/* Now TO is here */
block|}
end_function

begin_comment
comment|/* Physically print C on rl_outstream.  This is for functions which know    how to optimize the display.  Return the number of characters output. */
end_comment

begin_macro
name|rl_show_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
if|if
condition|(
name|c
operator|<
literal|32
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"C-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|+=
literal|64
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_function
name|int
name|rl_character_len
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|unsigned
name|char
name|uc
decl_stmt|;
name|uc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|uc
argument_list|)
condition|)
return|return
operator|(
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|?
literal|4
else|:
literal|1
operator|)
return|;
if|if
condition|(
name|uc
operator|==
literal|'\t'
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
return|return
operator|(
operator|(
operator|(
name|pos
operator||
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|pos
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|}
return|return
operator|(
operator|(
name|isprint
argument_list|(
name|uc
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to print things in the "echo-area".  The prompt is treated as a    mini-modeline. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
end_if

begin_macro
name|rl_message
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_VARARGS_H */
end_comment

begin_macro
name|rl_message
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VARARGS_H */
end_comment

begin_comment
comment|/* How to clear things from the "echo-area". */
end_comment

begin_macro
name|rl_clear_message
argument_list|()
end_macro

begin_block
block|{
name|rl_display_prompt
operator|=
name|rl_prompt
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|rl_reset_line_state
argument_list|()
end_macro

begin_block
block|{
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|rl_prompt
condition|?
name|rl_prompt
else|:
literal|""
expr_stmt|;
name|forced_display
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Quick redisplay hack when erasing characters at the end of the line. */
end_comment

begin_function
name|void
name|_rl_erase_at_end_of_line
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|visible_line
index|[
operator|--
name|_rl_last_c_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
specifier|static
name|void
name|clear_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
if|if
condition|(
name|term_clreol
condition|)
block|{
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* !__GO32__ */
name|space_to_eol
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line using spaces.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
specifier|static
name|void
name|space_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert COUNT characters from STRING to the output stream. */
end_comment

begin_function
specifier|static
name|void
name|insert_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|width
decl_stmt|;
name|char
modifier|*
name|row_start
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|width
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|row_start
operator|=
name|ScreenPrimary
operator|+
operator|(
name|row
operator|*
name|width
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|row_start
operator|+
name|col
operator|+
name|count
argument_list|,
name|row_start
operator|+
name|col
argument_list|,
name|width
operator|-
name|col
operator|-
name|count
argument_list|)
expr_stmt|;
comment|/* Place the text on the screen. */
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_GO32 */
comment|/* If IC is defined, then we do not have to "enter" insert mode. */
if|if
condition|(
name|term_IC
condition|)
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_IC
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we have to turn on insert-mode, then do so. */
if|if
condition|(
name|term_im
operator|&&
operator|*
name|term_im
condition|)
name|tputs
argument_list|(
name|term_im
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
comment|/* If there is a special command for inserting characters, then 	 use that first to open up the space. */
if|if
condition|(
name|term_ic
operator|&&
operator|*
name|term_ic
condition|)
block|{
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|--
condition|;
control|)
name|tputs
argument_list|(
name|term_ic
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
comment|/* Print the text. */
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* If there is a string to turn off insert mode, we had best use 	 it now. */
if|if
condition|(
name|term_ei
operator|&&
operator|*
name|term_ei
condition|)
name|tputs
argument_list|(
name|term_ei
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

begin_comment
comment|/* Delete COUNT characters from the display line. */
end_comment

begin_function
specifier|static
name|void
name|delete_chars
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|width
decl_stmt|;
name|char
modifier|*
name|row_start
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|width
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|row_start
operator|=
name|ScreenPrimary
operator|+
operator|(
name|row
operator|*
name|width
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|row_start
operator|+
name|col
argument_list|,
name|row_start
operator|+
name|col
operator|+
name|count
argument_list|,
name|width
operator|-
name|col
operator|-
name|count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|row_start
operator|+
name|width
operator|-
name|count
argument_list|,
literal|0
argument_list|,
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_GO32 */
if|if
condition|(
name|count
operator|>
name|screenwidth
condition|)
comment|/* XXX */
return|return;
if|if
condition|(
name|term_DC
operator|&&
operator|*
name|term_DC
condition|)
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_DC
argument_list|,
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
name|count
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|term_dc
operator|&&
operator|*
name|term_dc
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_dc
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

begin_function
name|void
name|_rl_update_final
parameter_list|()
block|{
name|int
name|full_lines
decl_stmt|;
name|full_lines
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_rl_vis_botlin
operator|&&
name|visible_line
index|[
name|screenwidth
operator|*
name|_rl_vis_botlin
index|]
operator|==
literal|0
condition|)
block|{
name|_rl_vis_botlin
operator|--
expr_stmt|;
name|full_lines
operator|=
literal|1
expr_stmt|;
block|}
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_lines
operator|&&
name|term_xn
condition|)
block|{
comment|/* Remove final line-wrap flag in xterm. */
name|char
modifier|*
name|last_line
decl_stmt|;
name|last_line
operator|=
operator|&
name|visible_line
index|[
name|screenwidth
operator|*
name|_rl_vis_botlin
index|]
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|screenwidth
operator|-
literal|1
argument_list|,
name|last_line
argument_list|)
expr_stmt|;
name|clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|last_line
index|[
name|screenwidth
operator|-
literal|1
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move to the start of the current line. */
end_comment

begin_function
specifier|static
name|void
name|cr
parameter_list|()
block|{
if|if
condition|(
name|term_cr
condition|)
block|{
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Redisplay the current line after a SIGWINCH is received. */
end_comment

begin_function
name|void
name|_rl_redisplay_after_sigwinch
parameter_list|()
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|oldp
decl_stmt|;
comment|/* Clear the current line and put the cursor at column 0.  Make sure      the right thing happens if we have wrapped to a new screen line. */
if|if
condition|(
name|term_cr
condition|)
block|{
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|term_clreol
condition|)
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
block|{
name|space_to_eol
argument_list|(
name|screenwidth
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_rl_last_v_pos
operator|>
literal|0
condition|)
name|_rl_move_vert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|crlf
argument_list|()
expr_stmt|;
comment|/* Redraw only the last line of a multi-line prompt. */
name|t
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|oldp
operator|=
name|rl_display_prompt
expr_stmt|;
name|rl_display_prompt
operator|=
operator|++
name|t
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|oldp
expr_stmt|;
block|}
else|else
name|rl_forced_update_display
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

