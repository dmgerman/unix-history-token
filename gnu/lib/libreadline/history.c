begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* History.c -- standalone history library */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)[0] == (b)[0])&& (strcmp ((a), (b)) == 0))
end_define

begin_define
define|#
directive|define
name|STREQN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|(((a)[0] == (b)[0])&& (strncmp ((a), (b), (n)) == 0))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|savestring
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|strcpy
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
value|strcpy (xmalloc (1 + strlen (x)), (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|whitespace
end_ifndef

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == ' ') || ((c) == '\t'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit_p
end_ifndef

begin_define
define|#
directive|define
name|digit_p
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit_value
end_ifndef

begin_define
define|#
directive|define
name|digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Possible history errors passed to hist_error. */
end_comment

begin_define
define|#
directive|define
name|EVENT_NOT_FOUND
value|0
end_define

begin_define
define|#
directive|define
name|BAD_WORD_SPEC
value|1
end_define

begin_define
define|#
directive|define
name|SUBST_FAILED
value|2
end_define

begin_define
define|#
directive|define
name|BAD_MODIFIER
value|3
end_define

begin_decl_stmt
specifier|static
name|char
name|error_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subst_lhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subst_rhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subst_lhs_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subst_rhs_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|get_history_word_specifier
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|single_quote
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* An array of HIST_ENTRY.  This is where we store the history. */
end_comment

begin_decl_stmt
specifier|static
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have enforced a limit on the amount of    history that we save. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_stifled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If HISTORY_STIFLED is non-zero, then this is the maximum number of    entries to remember. */
end_comment

begin_decl_stmt
name|int
name|max_input_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current location of the interactive history pointer.  Just makes    life easier for outside callers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of strings currently stored in the input_history list. */
end_comment

begin_decl_stmt
name|int
name|history_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current number of slots allocated to the input_history. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots to increase the_history by. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HISTORY_GROW_SIZE
value|50
end_define

begin_comment
comment|/* The character that represents the start of a history expansion    request.  This is usually `!'. */
end_comment

begin_decl_stmt
name|char
name|history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that invokes word substitution if found at the start of    a line.  This is usually `^'. */
end_comment

begin_decl_stmt
name|char
name|history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During tokenization, if this character is seen as the first character    of a word, then it, and all subsequent characters upto a newline are    ignored.  For a Bourne shell, this should be '#'.  Bash special cases    the interactive comment character to not be a comment delimiter. */
end_comment

begin_decl_stmt
name|char
name|history_comment_char
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters which inhibit the expansion of text if found    immediately following history_expansion_char. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|history_no_expand_chars
init|=
literal|" \t\n\r="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The logical `base' of the history array.  It defaults to 1. */
end_comment

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current HISTORY_STATE of the history. */
end_comment

begin_function
name|HISTORY_STATE
modifier|*
name|history_get_history_state
parameter_list|()
block|{
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|HISTORY_STATE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HISTORY_STATE
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|entries
operator|=
name|the_history
expr_stmt|;
name|state
operator|->
name|offset
operator|=
name|history_offset
expr_stmt|;
name|state
operator|->
name|length
operator|=
name|history_length
expr_stmt|;
name|state
operator|->
name|size
operator|=
name|history_size
expr_stmt|;
name|state
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_stifled
condition|)
name|state
operator|->
name|flags
operator||=
name|HS_STIFLED
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the state of the current history array to STATE. */
end_comment

begin_function
name|void
name|history_set_history_state
parameter_list|(
name|state
parameter_list|)
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
block|{
name|the_history
operator|=
name|state
operator|->
name|entries
expr_stmt|;
name|history_offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
name|history_length
operator|=
name|state
operator|->
name|length
expr_stmt|;
name|history_size
operator|=
name|state
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|HS_STIFLED
condition|)
name|history_stifled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a session in which the history functions might be used.  This    initializes interactive variables. */
end_comment

begin_function
name|void
name|using_history
parameter_list|()
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes that the primary history entries are using.    This just adds up the lengths of the_history->lines. */
end_comment

begin_function
name|int
name|history_total_bytes
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|the_history
operator|&&
name|the_history
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|result
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Place STRING at the end of the history list.  The data field    is  set to NULL. */
end_comment

begin_function
name|void
name|add_history
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|history_stifled
operator|&&
operator|(
name|history_length
operator|==
name|max_input_history
operator|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the history is stifled, and history_length is zero, 	 and it equals max_input_history, we don't save items. */
if|if
condition|(
name|history_length
operator|==
literal|0
condition|)
return|return;
comment|/* If there is something in the slot, then remove it. */
if|if
condition|(
name|the_history
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the rest of the entries, moving down one slot. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_base
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|history_size
condition|)
block|{
name|history_size
operator|=
name|DEFAULT_HISTORY_GROW_SIZE
expr_stmt|;
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|history_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_length
operator|==
operator|(
name|history_size
operator|-
literal|1
operator|)
condition|)
block|{
name|history_size
operator|+=
name|DEFAULT_HISTORY_GROW_SIZE
expr_stmt|;
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_history
argument_list|,
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|history_length
operator|++
expr_stmt|;
block|}
block|}
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the history entry at WHICH have LINE and DATA.  This returns    the old entry so you can dispose of the data.  In the case of an    invalid WHICH, a NULL pointer is returned. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|replace_history_entry
parameter_list|(
name|which
parameter_list|,
name|line
parameter_list|,
name|data
parameter_list|)
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|old_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
name|old_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|the_history
index|[
name|which
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|old_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the magic number which says what history element we are    looking at now.  In this implementation, it returns history_offset. */
end_comment

begin_function
name|int
name|where_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search the history for STRING, starting at history_offset.    If DIRECTION< 0, then the search is through previous entries, else    through subsequent.  If ANCHORED is non-zero, the string must    appear at the beginning of a history line, otherwise, the string    may appear anywhere in the line.  If the string is found, then    current_history () is the history entry, and the value of this    function is the offset in the line of that history entry that the    string was found in.  Otherwise, nothing is changed, and a -1 is    returned. */
end_comment

begin_define
define|#
directive|define
name|ANCHORED_SEARCH
value|1
end_define

begin_define
define|#
directive|define
name|NON_ANCHORED_SEARCH
value|0
end_define

begin_function
specifier|static
name|int
name|history_search_internal
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|,
name|anchored
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|,
name|anchored
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|reverse
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|line_index
decl_stmt|;
name|int
name|string_len
decl_stmt|;
name|i
operator|=
name|history_offset
expr_stmt|;
name|reverse
operator|=
operator|(
name|direction
operator|<
literal|0
operator|)
expr_stmt|;
comment|/* Take care of trivial cases first. */
if|if
condition|(
operator|!
name|history_length
operator|||
operator|(
operator|(
name|i
operator|==
name|history_length
operator|)
operator|&&
operator|!
name|reverse
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|reverse
operator|&&
operator|(
name|i
operator|==
name|history_length
operator|)
condition|)
name|i
operator|--
expr_stmt|;
define|#
directive|define
name|NEXT_LINE
parameter_list|()
value|do { if (reverse) i--; else i++; } while (0)
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Search each line in the history list for STRING. */
comment|/* At limit for direction? */
if|if
condition|(
operator|(
name|reverse
operator|&&
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|reverse
operator|&&
name|i
operator|==
name|history_length
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|line
operator|=
name|the_history
index|[
name|i
index|]
operator|->
name|line
expr_stmt|;
name|line_index
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* If STRING is longer than line, no match. */
if|if
condition|(
name|string_len
operator|>
name|line_index
condition|)
block|{
name|NEXT_LINE
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Handle anchored searches first. */
if|if
condition|(
name|anchored
operator|==
name|ANCHORED_SEARCH
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|string
argument_list|,
name|line
argument_list|,
name|string_len
argument_list|)
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NEXT_LINE
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Do substring search. */
if|if
condition|(
name|reverse
condition|)
block|{
name|line_index
operator|-=
name|string_len
expr_stmt|;
while|while
condition|(
name|line_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|line_index
argument_list|,
name|string_len
argument_list|)
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|line_index
operator|)
return|;
block|}
name|line_index
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|int
name|limit
init|=
name|line_index
operator|-
name|string_len
operator|+
literal|1
decl_stmt|;
name|line_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|line_index
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|line_index
argument_list|,
name|string_len
argument_list|)
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|line_index
operator|)
return|;
block|}
name|line_index
operator|++
expr_stmt|;
block|}
block|}
name|NEXT_LINE
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a non-anchored search for STRING through the history in DIRECTION. */
end_comment

begin_function
name|int
name|history_search
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
return|return
operator|(
name|history_search_internal
argument_list|(
name|string
argument_list|,
name|direction
argument_list|,
name|NON_ANCHORED_SEARCH
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do an anchored search for string through the history in DIRECTION. */
end_comment

begin_function
name|int
name|history_search_prefix
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
return|return
operator|(
name|history_search_internal
argument_list|(
name|string
argument_list|,
name|direction
argument_list|,
name|ANCHORED_SEARCH
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove history element WHICH from the history.  The removed    element is returned to you so you can free the line, data,    and containing structure. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|remove_history
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|return_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
operator|||
operator|!
name|history_length
condition|)
name|return_value
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|return_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|which
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_length
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stifle the history list, remembering only MAX number of lines. */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_length
operator|>
name|max
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|history_length
operator|-
name|max
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|history_base
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|max
init|;
name|j
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|the_history
index|[
name|j
index|]
operator|=
name|the_history
index|[
name|i
index|]
expr_stmt|;
name|the_history
index|[
name|j
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|history_length
operator|=
name|j
expr_stmt|;
block|}
name|history_stifled
operator|=
literal|1
expr_stmt|;
name|max_input_history
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop stifling the history.  This returns the previous amount the history  was stifled by.  The value is positive if the history was stifled, negative  if it wasn't. */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|()
block|{
name|int
name|result
init|=
name|max_input_history
decl_stmt|;
if|if
condition|(
name|history_stifled
condition|)
block|{
name|result
operator|=
operator|-
name|result
expr_stmt|;
name|history_stifled
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|history_is_stifled
parameter_list|()
block|{
return|return
operator|(
name|history_stifled
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the string that should be used in the place of this    filename.  This only matters when you don't specify the    filename to read_history (), or write_history (). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|history_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|return_val
init|=
name|filename
condition|?
name|savestring
argument_list|(
name|filename
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|return_val
condition|)
block|{
name|char
modifier|*
name|home
decl_stmt|;
name|int
name|home_len
decl_stmt|;
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|home
condition|)
name|home
operator|=
literal|"."
expr_stmt|;
name|home_len
operator|=
name|strlen
argument_list|(
name|home
argument_list|)
expr_stmt|;
comment|/* strlen(".history") == 8 */
name|return_val
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|home_len
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|return_val
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|return_val
index|[
name|home_len
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|return_val
operator|+
name|home_len
operator|+
literal|1
argument_list|,
literal|".history"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the contents of FILENAME to the history list, a line at a time.    If FILENAME is NULL, then read from ~/.history.  Returns 0 if    successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|read_history_range
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a range of lines from FILENAME, adding them to the history list.    Start reading at the FROM'th line and end at the TO'th.  If FROM    is zero, start at the beginning.  If TO is less than FROM, read    until the end of the file.  If FILENAME is NULL, then read from    ~/.history.  Returns 0 if successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history_range
parameter_list|(
name|filename
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|line_start
decl_stmt|,
name|line_end
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|,
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|file
decl_stmt|,
name|current_line
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|input
operator|=
name|history_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|input
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|<
literal|0
operator|)
operator|||
operator|(
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
goto|goto
name|error_and_exit
goto|;
name|buffer
operator|=
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|finfo
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|finfo
operator|.
name|st_size
argument_list|)
operator|!=
name|finfo
operator|.
name|st_size
condition|)
block|{
name|error_and_exit
label|:
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
condition|)
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set TO to larger than end of file if negative. */
if|if
condition|(
name|to
operator|<
literal|0
condition|)
name|to
operator|=
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* Start at beginning of file, work to end. */
name|line_start
operator|=
name|line_end
operator|=
name|current_line
operator|=
literal|0
expr_stmt|;
comment|/* Skip lines until we are at FROM. */
while|while
condition|(
name|line_start
operator|<
name|finfo
operator|.
name|st_size
operator|&&
name|current_line
operator|<
name|from
condition|)
block|{
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|finfo
operator|.
name|st_size
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|line_end
index|]
operator|==
literal|'\n'
condition|)
block|{
name|current_line
operator|++
expr_stmt|;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|current_line
operator|==
name|from
condition|)
break|break;
block|}
block|}
comment|/* If there are lines left to gobble, then gobble them now. */
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|finfo
operator|.
name|st_size
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|line_end
index|]
operator|==
literal|'\n'
condition|)
block|{
name|buffer
index|[
name|line_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|line_start
index|]
condition|)
name|add_history
argument_list|(
name|buffer
operator|+
name|line_start
argument_list|)
expr_stmt|;
name|current_line
operator|++
expr_stmt|;
if|if
condition|(
name|current_line
operator|>=
name|to
condition|)
break|break;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|input
condition|)
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate the history file FNAME, leaving only LINES trailing lines.    If FNAME is NULL, then use ~/.history. */
end_comment

begin_function
name|int
name|history_truncate_file
parameter_list|(
name|fname
parameter_list|,
name|lines
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|int
name|lines
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|file
decl_stmt|,
name|chars_read
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|filename
operator|=
name|history_filename
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|-
literal|1
operator|||
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|truncate_exit
goto|;
name|buffer
operator|=
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|finfo
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chars_read
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|finfo
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|<=
literal|0
condition|)
goto|goto
name|truncate_exit
goto|;
comment|/* Count backwards from the end of buffer until we have passed      LINES lines. */
for|for
control|(
name|i
operator|=
name|chars_read
operator|-
literal|1
init|;
name|lines
operator|&&
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|lines
operator|--
expr_stmt|;
block|}
comment|/* If this is the first line, then the file contains exactly the      number of lines we want to truncate to, so we don't need to do      anything.  It's the first line if we don't find a newline between      the current value of i and 0.  Otherwise, write from the start of      this line until the end of the buffer. */
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Write only if there are more lines in the file than we want to      truncate to. */
if|if
condition|(
name|i
operator|&&
operator|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|write
argument_list|(
name|file
argument_list|,
name|buffer
operator|+
name|i
argument_list|,
name|finfo
operator|.
name|st_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|truncate_exit
label|:
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HISTORY_APPEND
value|0
end_define

begin_define
define|#
directive|define
name|HISTORY_OVERWRITE
value|1
end_define

begin_comment
comment|/* Workhorse function for writing history.  Writes NELEMENT entries    from the history list to FILENAME.  OVERWRITE is non-zero if you    wish to replace FILENAME with the entries. */
end_comment

begin_function
specifier|static
name|int
name|history_do_write
parameter_list|(
name|filename
parameter_list|,
name|nelements
parameter_list|,
name|overwrite
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|nelements
decl_stmt|,
name|overwrite
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|history_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|int
name|file
decl_stmt|,
name|mode
decl_stmt|;
name|mode
operator|=
name|overwrite
condition|?
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
else|:
name|O_WRONLY
operator||
name|O_APPEND
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|output
argument_list|,
name|mode
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|output
condition|)
name|free
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|nelements
operator|>
name|history_length
condition|)
name|nelements
operator|=
name|history_length
expr_stmt|;
comment|/* Build a buffer of all the lines to write, and write them in one syscall.      Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
block|{
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|buffer_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Calculate the total number of bytes to write. */
for|for
control|(
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|buffer_size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
comment|/* Allocate the buffer, and fill it. */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|buffer_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|write
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|free
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Append NELEMENT entries to FILENAME.  The entries appended are from    the end of the list minus NELEMENTs up to the end of the list. */
end_comment

begin_function
name|int
name|append_history
parameter_list|(
name|nelements
parameter_list|,
name|filename
parameter_list|)
name|int
name|nelements
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|nelements
argument_list|,
name|HISTORY_APPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite FILENAME with the current history.  If FILENAME is NULL,    then write the history list to ~/.history.  Values returned    are as in read_history ().*/
end_comment

begin_function
name|int
name|write_history
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|history_length
argument_list|,
name|HISTORY_OVERWRITE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry at the current position, as determined by    history_offset.  If there is no entry there, return a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|()
block|{
if|if
condition|(
operator|(
name|history_offset
operator|==
name|history_length
operator|)
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Back up history_offset to the previous history entry, and return    a pointer to that entry.  If there is no previous entry then return    a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|()
block|{
if|if
condition|(
operator|!
name|history_offset
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
operator|--
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move history_offset forward to the next history entry, and return    a pointer to that entry.  If there is no next entry then return a    NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|()
block|{
if|if
condition|(
name|history_offset
operator|==
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
operator|++
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the current history array.  The caller has to be carefull, since this    is the actual array of data, and could be bashed or made corrupt easily.    The array is terminated with a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
modifier|*
name|history_list
parameter_list|()
block|{
return|return
operator|(
name|the_history
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry which is logically at OFFSET in the history array.    OFFSET is relative to history_base. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|int
name|local_index
init|=
name|offset
operator|-
name|history_base
decl_stmt|;
if|if
condition|(
name|local_index
operator|>=
name|history_length
operator|||
name|local_index
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|the_history
index|[
name|local_index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING in the history list.  DIR is< 0 for searching    backwards.  POS is an absolute index into the history list at    which point to begin searching. */
end_comment

begin_function
name|int
name|history_search_pos
parameter_list|(
name|string
parameter_list|,
name|dir
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|old
init|=
name|where_history
argument_list|()
decl_stmt|;
name|history_set_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_search
argument_list|(
name|string
argument_list|,
name|dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Make the current history item be the one at POS, an absolute index.    Returns zero if POS is out of range, else non-zero. */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|pos
parameter_list|)
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|>
name|history_length
operator|||
name|pos
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|history_offset
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Expansion			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Hairy history expansion on text, not tokens.  This is of general    use, and thus belongs in this library. */
end_comment

begin_comment
comment|/* The last string searched for in a !?string? search. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the event specified at TEXT + OFFSET modifying OFFSET to    point to after the event specifier.  Just a pointer to the history    line is returned; NULL is returned in the event of a bad specifier.    You pass STRING with *INDEX equal to the history_expansion_char that    begins this specification.    DELIMITING_QUOTE is a character that is allowed to end the string    specification for what to search for in addition to the normal    characters `:', ` ', `\t', `\n', and sometimes `?'.    So you might call this function like:    line = get_history_event ("!echo:p",&index, 0);  */
end_comment

begin_function
name|char
modifier|*
name|get_history_event
parameter_list|(
name|string
parameter_list|,
name|caller_index
parameter_list|,
name|delimiting_quote
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|caller_index
decl_stmt|;
name|int
name|delimiting_quote
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
name|int
name|which
decl_stmt|,
name|sign
init|=
literal|1
decl_stmt|;
name|int
name|local_index
decl_stmt|,
name|search_mode
decl_stmt|,
name|substring_okay
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* The event can be specified in a number of ways.       !!   the previous command      !n   command line N      !-n  current command-line minus N      !str the most recent command starting with STR      !?str[?] 	  the most recent command containing STR       All values N are determined via HISTORY_BASE. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Move on to the specification. */
name|i
operator|++
expr_stmt|;
define|#
directive|define
name|RETURN_ENTRY
parameter_list|(
name|e
parameter_list|,
name|w
parameter_list|)
define|\
value|return ((e = history_get (w)) ? e->line : (char *)NULL)
comment|/* Handle !! case. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|which
operator|=
name|history_base
operator|+
operator|(
name|history_length
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
name|RETURN_ENTRY
argument_list|(
name|entry
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
comment|/* Hack case of numeric line specification. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|digit_p
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Get the extent of the digits and compute the value. */
for|for
control|(
name|which
operator|=
literal|0
init|;
name|digit_p
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|which
operator|=
operator|(
name|which
operator|*
literal|10
operator|)
operator|+
name|digit_value
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|which
operator|=
operator|(
name|history_length
operator|+
name|history_base
operator|)
operator|-
name|which
expr_stmt|;
name|RETURN_ENTRY
argument_list|(
name|entry
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
comment|/* This must be something to search for.  If the spec begins with      a '?', then the string may be anywhere on the line.  Otherwise,      the string must be found at the start of a line. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
block|{
name|substring_okay
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Only a closing `?' or a newline delimit a substring search string. */
for|for
control|(
name|local_index
operator|=
name|i
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|substring_okay
operator|&&
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|':'
operator|||
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
name|member
argument_list|(
name|c
argument_list|,
literal|";&()|<>"
argument_list|)
operator|||
endif|#
directive|endif
comment|/* SHELL */
name|string
index|[
name|i
index|]
operator|==
name|delimiting_quote
operator|)
operator|)
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|substring_okay
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'?'
operator|)
condition|)
break|break;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|local_index
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
operator|&
name|string
index|[
name|local_index
index|]
argument_list|,
operator|(
name|i
operator|-
name|local_index
operator|)
argument_list|)
expr_stmt|;
name|temp
index|[
name|i
operator|-
name|local_index
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|substring_okay
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
define|#
directive|define
name|FAIL_SEARCH
parameter_list|()
define|\
value|do { history_offset = history_length; free (temp) ; return (char *)NULL; } while (0)
name|search_mode
operator|=
name|substring_okay
condition|?
name|NON_ANCHORED_SEARCH
else|:
name|ANCHORED_SEARCH
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|local_index
operator|=
name|history_search_internal
argument_list|(
name|temp
argument_list|,
operator|-
literal|1
argument_list|,
name|search_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_index
operator|<
literal|0
condition|)
name|FAIL_SEARCH
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_index
operator|==
literal|0
operator|||
name|substring_okay
condition|)
block|{
name|entry
operator|=
name|current_history
argument_list|()
expr_stmt|;
name|history_offset
operator|=
name|history_length
expr_stmt|;
comment|/* If this was a substring search, then remember the 	     string that we matched for word substitution. */
if|if
condition|(
name|substring_okay
condition|)
block|{
if|if
condition|(
name|search_string
condition|)
name|free
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
name|search_string
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|->
name|line
operator|)
return|;
block|}
if|if
condition|(
name|history_offset
condition|)
name|history_offset
operator|--
expr_stmt|;
else|else
name|FAIL_SEARCH
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|FAIL_SEARCH
undef|#
directive|undef
name|RETURN_ENTRY
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_comment
comment|/* Function for extracting single-quoted strings.  Used for inhibiting    history expansion within single quotes. */
end_comment

begin_comment
comment|/* Extract the contents of STRING as if it is enclosed in single quotes.    SINDEX, when passed in, is the offset of the character immediately    following the opening single quote; on exit, SINDEX is left pointing    to the closing single quote. */
end_comment

begin_function
specifier|static
name|void
name|rl_string_extract_single_quoted
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|sindex
decl_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|'\''
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|quote_breaks
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|len
init|=
literal|3
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|len
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|len
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
block|}
name|r
operator|=
name|ret
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|&&
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
else|else
operator|*
name|r
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHELL */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hist_error
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|current
parameter_list|,
name|errtype
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|start
decl_stmt|,
name|current
decl_stmt|,
name|errtype
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|emsg
decl_stmt|;
name|int
name|ll
decl_stmt|,
name|elen
decl_stmt|;
name|ll
operator|=
name|current
operator|-
name|start
expr_stmt|;
switch|switch
condition|(
name|errtype
condition|)
block|{
case|case
name|EVENT_NOT_FOUND
case|:
name|emsg
operator|=
literal|"event not found"
expr_stmt|;
name|elen
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|BAD_WORD_SPEC
case|:
name|emsg
operator|=
literal|"bad word specifier"
expr_stmt|;
name|elen
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|SUBST_FAILED
case|:
name|emsg
operator|=
literal|"substitution failed"
expr_stmt|;
name|elen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|BAD_MODIFIER
case|:
name|emsg
operator|=
literal|"unrecognized history modifier"
expr_stmt|;
name|elen
operator|=
literal|29
expr_stmt|;
break|break;
default|default:
name|emsg
operator|=
literal|"unknown expansion error"
expr_stmt|;
name|elen
operator|=
literal|23
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|xmalloc
argument_list|(
name|ll
operator|+
name|elen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|s
operator|+
name|start
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|temp
index|[
name|ll
index|]
operator|=
literal|':'
expr_stmt|;
name|temp
index|[
name|ll
operator|+
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|temp
operator|+
name|ll
operator|+
literal|2
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a history substitution string from STR starting at *IPTR    and return it.  The length is returned in LENPTR.     A backslash can quote the delimiter.  If the string is the    empty string, the previous pattern is used.  If there is    no previous pattern for the lhs, the last history search    string is used.     If IS_RHS is 1, we ignore empty strings and set the pattern    to "" anyway.  subst_lhs is not changed if the lhs is empty;    subst_rhs is allowed to be set to the empty string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_subst_pattern
parameter_list|(
name|str
parameter_list|,
name|iptr
parameter_list|,
name|delimiter
parameter_list|,
name|is_rhs
parameter_list|,
name|lenptr
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|iptr
decl_stmt|,
name|delimiter
decl_stmt|,
name|is_rhs
decl_stmt|,
decl|*
name|lenptr
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|si
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|i
operator|=
operator|*
name|iptr
expr_stmt|;
for|for
control|(
name|si
operator|=
name|i
init|;
name|str
index|[
name|si
index|]
operator|&&
name|str
index|[
name|si
index|]
operator|!=
name|delimiter
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|str
index|[
name|si
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|si
operator|+
literal|1
index|]
operator|==
name|delimiter
condition|)
name|si
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|>
name|i
operator|||
name|is_rhs
condition|)
block|{
name|s
operator|=
name|xmalloc
argument_list|(
name|si
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|k
operator|<
name|si
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
comment|/* Remove a backslash quoting the search string delimiter. */
if|if
condition|(
name|str
index|[
name|k
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|k
operator|+
literal|1
index|]
operator|==
name|delimiter
condition|)
name|k
operator|++
expr_stmt|;
name|s
index|[
name|j
index|]
operator|=
name|str
index|[
name|k
index|]
expr_stmt|;
block|}
name|s
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lenptr
condition|)
operator|*
name|lenptr
operator|=
name|j
expr_stmt|;
block|}
name|i
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|iptr
operator|=
name|i
expr_stmt|;
return|return
name|s
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|postproc_subst_rhs
parameter_list|()
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|new_size
decl_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|new_size
operator|=
name|subst_rhs_len
operator|+
name|subst_lhs_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|subst_rhs_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subst_rhs
index|[
name|i
index|]
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|j
operator|+
name|subst_lhs_len
operator|>=
name|new_size
condition|)
name|new
operator|=
name|xrealloc
argument_list|(
name|new
argument_list|,
operator|(
name|new_size
operator|=
name|new_size
operator|*
literal|2
operator|+
name|subst_lhs_len
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|+
name|j
argument_list|,
name|subst_lhs
argument_list|)
expr_stmt|;
name|j
operator|+=
name|subst_lhs_len
expr_stmt|;
block|}
else|else
block|{
comment|/* a single backslash protects the `&' from lhs interpolation */
if|if
condition|(
name|subst_rhs
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|subst_rhs
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'&'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|new_size
condition|)
name|new
operator|=
name|xrealloc
argument_list|(
name|new
argument_list|,
name|new_size
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|new
index|[
name|j
operator|++
index|]
operator|=
name|subst_rhs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|new
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|subst_rhs
argument_list|)
expr_stmt|;
name|subst_rhs
operator|=
name|new
expr_stmt|;
name|subst_rhs_len
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the bulk of a history specifier starting at STRING[START].    Returns 0 if everything is OK, -1 if an error occurred, and 1    if the `p' modifier was supplied and the caller should just print    the returned string.  Returns the new index into string in    *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */
end_comment

begin_function
specifier|static
name|int
name|history_expand_internal
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|,
name|end_index_ptr
parameter_list|,
name|ret_string
parameter_list|,
name|current_line
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|,
decl|*
name|end_index_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ret_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|current_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for !# */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|starting_index
decl_stmt|;
name|int
name|substitute_globally
decl_stmt|,
name|want_quotes
decl_stmt|,
name|print_only
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|word_spec
decl_stmt|;
name|int
name|result_len
decl_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|result_len
operator|=
literal|128
argument_list|)
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
comment|/* If it is followed by something that starts a word specifier,      then !! is implied as the event specifier. */
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|":$*%^"
argument_list|)
condition|)
block|{
name|char
name|fake_s
index|[
literal|3
index|]
decl_stmt|;
name|int
name|fake_i
init|=
literal|0
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|fake_s
index|[
literal|0
index|]
operator|=
name|fake_s
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|fake_s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|fake_s
argument_list|,
operator|&
name|fake_i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|event
operator|=
name|current_line
expr_stmt|;
block|}
else|else
block|{
name|int
name|quoted_search_delimiter
init|=
literal|0
decl_stmt|;
comment|/* If the character before this `!' is a double or single 	 quote, then this expansion takes place inside of the 	 quoted string.  If we have to search for some text ("!foo"), 	 allow the delimiter to end the search string. */
if|if
condition|(
name|i
operator|&&
operator|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\''
operator|||
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
name|quoted_search_delimiter
operator|=
name|string
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|quoted_search_delimiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|event
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|start
argument_list|,
name|i
argument_list|,
name|EVENT_NOT_FOUND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If a word specifier is found, then do what that requires. */
name|starting_index
operator|=
name|i
expr_stmt|;
name|word_spec
operator|=
name|get_history_word_specifier
argument_list|(
name|string
argument_list|,
name|event
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* There is no such thing as a `malformed word specifier'.  However,      it is possible for a specifier that has no match.  In that case,      we complain. */
if|if
condition|(
name|word_spec
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|error_pointer
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|BAD_WORD_SPEC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If no word specifier, than the thing of interest was the event. */
if|if
condition|(
operator|!
name|word_spec
condition|)
name|temp
operator|=
name|savestring
argument_list|(
name|event
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|savestring
argument_list|(
name|word_spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word_spec
argument_list|)
expr_stmt|;
block|}
comment|/* Perhaps there are other modifiers involved.  Do what they say. */
name|want_quotes
operator|=
name|substitute_globally
operator|=
name|print_only
operator|=
literal|0
expr_stmt|;
name|starting_index
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|c
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
block|{
name|substitute_globally
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|c
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|BAD_MODIFIER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
case|case
literal|'q'
case|:
name|want_quotes
operator|=
literal|'q'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|want_quotes
operator|=
literal|'x'
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SHELL */
comment|/* :p means make this the last executed line.  So we 	     return an error state after adding this line to the 	     history. */
case|case
literal|'p'
case|:
name|print_only
operator|++
expr_stmt|;
break|break;
comment|/* :t discards all but the last part of the pathname. */
case|case
literal|'t'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
block|{
name|tstr
operator|++
expr_stmt|;
name|t
operator|=
name|savestring
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|t
expr_stmt|;
block|}
break|break;
comment|/* :h discards the last part of a pathname. */
case|case
literal|'h'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
break|break;
comment|/* :r discards the suffix. */
case|case
literal|'r'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
break|break;
comment|/* :e discards everything but the suffix. */
case|case
literal|'e'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
block|{
name|t
operator|=
name|savestring
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|t
expr_stmt|;
block|}
break|break;
comment|/* :s/this/that substitutes `that' for the first 	   occurrence of `this'.  :gs/this/that substitutes `that' 	   for each occurrence of `this'.  :& repeats the last 	   substitution.  :g& repeats the last substitution 	   globally. */
case|case
literal|'&'
case|:
case|case
literal|'s'
case|:
block|{
name|char
modifier|*
name|new_event
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|failed
decl_stmt|,
name|si
decl_stmt|,
name|l_temp
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
else|else
break|break;
comment|/* no search delimiter */
name|i
operator|+=
literal|3
expr_stmt|;
name|t
operator|=
name|get_subst_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|delimiter
argument_list|,
literal|0
argument_list|,
operator|&
name|subst_lhs_len
argument_list|)
expr_stmt|;
comment|/* An empty substitution lhs with no previous substitution 		   uses the last search string as the lhs. */
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|subst_lhs
condition|)
name|free
argument_list|(
name|subst_lhs
argument_list|)
expr_stmt|;
name|subst_lhs
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|subst_lhs
condition|)
block|{
if|if
condition|(
name|search_string
operator|&&
operator|*
name|search_string
condition|)
block|{
name|subst_lhs
operator|=
name|savestring
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
name|subst_lhs_len
operator|=
name|strlen
argument_list|(
name|subst_lhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subst_lhs
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|subst_lhs_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If there is no lhs, the substitution can't succeed. */
if|if
condition|(
name|subst_lhs_len
operator|==
literal|0
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|SUBST_FAILED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|subst_rhs
condition|)
name|free
argument_list|(
name|subst_rhs
argument_list|)
expr_stmt|;
name|subst_rhs
operator|=
name|get_subst_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|delimiter
argument_list|,
literal|1
argument_list|,
operator|&
name|subst_rhs_len
argument_list|)
expr_stmt|;
comment|/* If `&' appears in the rhs, it's supposed to be replaced 		   with the lhs. */
if|if
condition|(
name|member
argument_list|(
literal|'&'
argument_list|,
name|subst_rhs
argument_list|)
condition|)
name|postproc_subst_rhs
argument_list|()
expr_stmt|;
block|}
else|else
name|i
operator|+=
literal|2
expr_stmt|;
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Ignore impossible cases. */
if|if
condition|(
name|subst_lhs_len
operator|>
name|l_temp
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|SUBST_FAILED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Find the first occurrence of THIS in TEMP. */
name|si
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|failed
operator|=
literal|1
init|;
operator|(
name|si
operator|+
name|subst_lhs_len
operator|)
operator|<=
name|l_temp
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|STREQN
argument_list|(
name|temp
operator|+
name|si
argument_list|,
name|subst_lhs
argument_list|,
name|subst_lhs_len
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|subst_rhs_len
operator|-
name|subst_lhs_len
operator|+
name|l_temp
decl_stmt|;
name|new_event
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
argument_list|,
name|temp
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
argument_list|,
name|subst_rhs
argument_list|,
name|subst_rhs_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
operator|+
name|subst_rhs_len
argument_list|,
name|temp
operator|+
name|si
operator|+
name|subst_lhs_len
argument_list|,
name|l_temp
operator|-
operator|(
name|si
operator|+
name|subst_lhs_len
operator|)
argument_list|)
expr_stmt|;
name|new_event
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|new_event
expr_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|substitute_globally
condition|)
block|{
name|si
operator|+=
name|subst_rhs_len
expr_stmt|;
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|substitute_globally
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|substitute_globally
operator|>
literal|1
condition|)
block|{
name|substitute_globally
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* don't want to increment i */
block|}
if|if
condition|(
name|failed
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't want to increment i */
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|SUBST_FAILED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|i
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Done with modfiers. */
comment|/* Believe it or not, we have to back the pointer up by one. */
operator|--
name|i
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
if|if
condition|(
name|want_quotes
condition|)
block|{
name|char
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|want_quotes
operator|==
literal|'q'
condition|)
name|x
operator|=
name|single_quote
argument_list|(
name|temp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_quotes
operator|==
literal|'x'
condition|)
name|x
operator|=
name|quote_breaks
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|x
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SHELL */
name|n
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|result_len
condition|)
name|result
operator|=
name|xrealloc
argument_list|(
name|result
argument_list|,
name|n
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|end_index_ptr
operator|=
name|i
expr_stmt|;
operator|*
name|ret_string
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|print_only
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Expand the string STRING, placing the result into OUTPUT, a pointer    to a string.  Returns:    -1) If there was an error in expansion.    0) If no expansions took place (or, if the only change in       the text was the de-slashifying of the history expansion       character)    1) If expansions did take place    2) If the `p' modifier was given and the caller should print the result    If an error ocurred in expansion, then OUTPUT contains a descriptive   error message. */
end_comment

begin_define
define|#
directive|define
name|ADD_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|do \ 	  { \ 	    int sl = strlen (s); \ 	    j += sl; \ 	    if (j>= result_len) \ 	      { \ 		while (j>= result_len) \ 		  result_len += 128; \ 		result = xrealloc (result, result_len); \ 	      } \ 	    strcpy (result + j - sl, s); \ 	  } \ 	while (0)
end_define

begin_define
define|#
directive|define
name|ADD_CHAR
parameter_list|(
name|c
parameter_list|)
define|\
value|do \ 	  { \ 	    if (j>= result_len - 1) \ 	      result = xrealloc (result, result_len += 64); \ 	    result[j++] = c; \ 	    result[j] = '\0'; \ 	  } \ 	while (0)
end_define

begin_function
name|int
name|history_expand
parameter_list|(
name|hstring
parameter_list|,
name|output
parameter_list|)
name|char
modifier|*
name|hstring
decl_stmt|;
name|char
modifier|*
modifier|*
name|output
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|l
decl_stmt|,
name|passc
decl_stmt|,
name|cc
decl_stmt|,
name|modified
decl_stmt|,
name|eindex
decl_stmt|,
name|only_printing
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The output string, and its length. */
name|int
name|result_len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Used when adding the string. */
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Setting the history expansion character to 0 inhibits all      history expansion. */
if|if
condition|(
name|history_expansion_char
operator|==
literal|0
condition|)
block|{
operator|*
name|output
operator|=
name|savestring
argument_list|(
name|hstring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Prepare the buffer for printing error messages. */
name|result
operator|=
name|xmalloc
argument_list|(
name|result_len
operator|=
literal|256
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|only_printing
operator|=
name|modified
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|hstring
argument_list|)
expr_stmt|;
comment|/* Grovel the string.  Only backslash can quote the history escape      character.  We also handle arg specifiers. */
comment|/* Before we grovel forever, see if the history_expansion_char appears      anywhere within the text. */
comment|/* The quick substitution character is a history expansion all right.  That      is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,      that is the substitution that we do. */
if|if
condition|(
name|hstring
index|[
literal|0
index|]
operator|==
name|history_subst_char
condition|)
block|{
name|string
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|5
argument_list|)
expr_stmt|;
name|string
index|[
literal|0
index|]
operator|=
name|string
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|string
index|[
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
name|string
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
name|strcpy
argument_list|(
name|string
operator|+
literal|4
argument_list|,
name|hstring
argument_list|)
expr_stmt|;
name|l
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|string
operator|=
name|hstring
expr_stmt|;
comment|/* If not quick substitution, still maybe have to do expansion. */
comment|/* `!' followed by one of the characters in history_no_expand_chars 	 is NOT an expansion. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|cc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
if|if
condition|(
operator|!
name|cc
operator|||
name|member
argument_list|(
name|cc
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* The shell uses ! as a pattern negation character 	         in globbing [...] expressions, so let those pass 	         without expansion. */
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'['
operator|)
operator|&&
name|member
argument_list|(
literal|']'
argument_list|,
name|string
operator|+
name|i
operator|+
literal|1
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* SHELL */
else|else
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
elseif|else
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
comment|/* If this is bash, single quotes inhibit history expansion. */
name|i
operator|++
expr_stmt|;
name|rl_string_extract_single_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* If this is bash, allow backslashes to quote single 		 quotes and 		 the history expansion character. */
if|if
condition|(
name|cc
operator|==
literal|'\''
operator|||
name|cc
operator|==
name|history_expansion_char
condition|)
name|i
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SHELL */
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Extract and perform the substitution. */
for|for
control|(
name|passc
operator|=
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tchar
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
name|ADD_CHAR
argument_list|(
name|tchar
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tchar
operator|==
name|history_expansion_char
condition|)
name|tchar
operator|=
operator|-
literal|3
expr_stmt|;
switch|switch
condition|(
name|tchar
condition|)
block|{
default|default:
name|ADD_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|passc
operator|++
expr_stmt|;
name|ADD_CHAR
argument_list|(
name|tchar
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
case|case
literal|'\''
case|:
block|{
comment|/* If this is bash, single quotes inhibit history expansion. */
name|int
name|quote
decl_stmt|,
name|slen
decl_stmt|;
name|quote
operator|=
name|i
operator|++
expr_stmt|;
name|rl_string_extract_single_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|slen
operator|=
name|i
operator|-
name|quote
operator|+
literal|2
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|slen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|quote
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|temp
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* SHELL */
case|case
operator|-
literal|3
case|:
comment|/* history_expansion_char */
name|cc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If the history_expansion_char is followed by one of the 	     characters in history_no_expand_chars, then it is not a 	     candidate for expansion of any kind. */
if|if
condition|(
name|member
argument_list|(
name|cc
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
block|{
name|ADD_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|NO_BANG_HASH_MODIFIERS
argument_list|)
comment|/* There is something that is listed as a `word specifier' in csh 	     documentation which means `the expanded text to this point'. 	     That is not a word specifier, it is an event specifier.  If we 	     don't want to allow modifiers with `!#', just stick the current 	     output line in again. */
if|if
condition|(
name|cc
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|result
condition|)
block|{
name|temp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|r
operator|=
name|history_expand_internal
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
operator|&
name|eindex
argument_list|,
operator|&
name|temp
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
operator|*
name|output
operator|=
name|temp
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|hstring
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|temp
condition|)
block|{
name|modified
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|temp
condition|)
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|only_printing
operator|=
name|r
operator|==
literal|1
expr_stmt|;
name|i
operator|=
name|eindex
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|output
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|hstring
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_printing
condition|)
block|{
name|add_history
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|modified
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a consed string which is the word specified in SPEC, and found    in FROM.  NULL is returned if there is no spec.  The address of    ERROR_POINTER is returned if the word specified cannot be found.    CALLER_INDEX is the offset in SPEC to start looking; it is updated    to point to just after the last character parsed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_history_word_specifier
parameter_list|(
name|spec
parameter_list|,
name|from
parameter_list|,
name|caller_index
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|caller_index
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|int
name|expecting_word_spec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* The range of words to return doesn't exist yet. */
name|first
operator|=
name|last
operator|=
literal|0
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* If we found a colon, then this *must* be a word specification.  If      it isn't, then it is an error. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|expecting_word_spec
operator|++
expr_stmt|;
block|}
comment|/* Handle special cases first. */
comment|/* `%' is the word last searched for. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|search_string
condition|?
name|savestring
argument_list|(
name|search_string
argument_list|)
else|:
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
comment|/* `*' matches all of the arguments, but not the command. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|history_arg_extract
argument_list|(
literal|1
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
condition|?
name|result
else|:
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
comment|/* `$' is last arg. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|history_arg_extract
argument_list|(
literal|'$'
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
comment|/* Try to get FIRST and LAST figured out. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
name|first
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
condition|)
name|first
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
operator|&&
name|expecting_word_spec
condition|)
block|{
for|for
control|(
name|first
operator|=
literal|0
init|;
name|digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|first
operator|=
operator|(
name|first
operator|*
literal|10
operator|)
operator|+
name|digit_value
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* no valid `first' for word specifier */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
operator|||
name|spec
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
name|last
operator|=
operator|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
operator|)
condition|?
literal|1
else|:
literal|'$'
expr_stmt|;
comment|/* x* abbreviates x-$ */
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
name|last
operator|=
name|first
expr_stmt|;
else|else
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|last
operator|=
literal|0
init|;
name|digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|last
operator|=
operator|(
name|last
operator|*
literal|10
operator|)
operator|+
name|digit_value
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|last
operator|=
literal|'$'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|spec
index|[
name|i
index|]
operator|||
name|spec
index|[
name|i
index|]
operator|==
literal|':'
condition|)
comment|/* could be modifier separator */
name|last
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* x- abbreviates x-$ omitting word `$' */
block|}
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|last
operator|>=
name|first
operator|||
name|last
operator|==
literal|'$'
operator|||
name|last
operator|<
literal|0
condition|)
name|result
operator|=
name|history_arg_extract
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
condition|?
name|result
else|:
operator|(
name|char
operator|*
operator|)
operator|&
name|error_pointer
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Extract the args specified, starting at FIRST, and ending at LAST.    The args are taken from STRING.  If either FIRST or LAST is< 0,    then make that arg count from the right (subtract from the number of    tokens, so that FIRST = -1 means the next to last token on the line).    If LAST is `$' the last arg from STRING is used. */
end_comment

begin_function
name|char
modifier|*
name|history_arg_extract
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|string
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
comment|/* XXX - think about making history_tokenize return a struct array,      each struct in array being a string and a length to avoid the      calls to strlen below. */
if|if
condition|(
operator|(
name|list
operator|=
name|history_tokenize
argument_list|(
name|string
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|list
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
name|last
operator|=
name|len
operator|+
name|last
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
name|first
operator|=
name|len
operator|+
name|first
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|'$'
condition|)
name|last
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|'$'
condition|)
name|first
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|last
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|>=
name|len
operator|||
name|last
operator|>
name|len
operator|||
name|first
operator|<
literal|0
operator|||
name|last
operator|<
literal|0
operator|||
name|first
operator|>
name|last
condition|)
name|result
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|size
operator|+=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|result
operator|+
name|offset
argument_list|,
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|last
condition|)
block|{
name|result
index|[
name|offset
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|result
index|[
name|offset
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|slashify_in_quotes
value|"\\`\"$"
end_define

begin_comment
comment|/* Return an array of tokens, much as the shell might.  The tokens are    parsed out of STRING. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|result_index
decl_stmt|,
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
name|i
operator|=
name|result_index
operator|=
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Get a token, and stuff it into RESULT.  The tokens are split      exactly where the shell would split them. */
while|while
condition|(
name|string
index|[
name|i
index|]
condition|)
block|{
name|int
name|delimiter
init|=
literal|0
decl_stmt|;
comment|/* Skip leading whitespace. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|string
index|[
name|i
index|]
operator|||
name|string
index|[
name|i
index|]
operator|==
name|history_comment_char
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"()\n"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"<>;&|$"
argument_list|)
condition|)
block|{
name|int
name|peek
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|peek
operator|==
name|string
index|[
name|i
index|]
operator|&&
name|peek
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|peek
operator|==
literal|'<'
operator|&&
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'-'
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|peek
operator|==
literal|'&'
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'>'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'<'
operator|)
operator|)
operator|||
operator|(
operator|(
name|peek
operator|==
literal|'>'
operator|)
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'&'
operator|)
operator|)
operator|||
operator|(
operator|(
name|peek
operator|==
literal|'('
operator|)
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'$'
operator|)
operator|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
block|}
comment|/* Get word from string + i; */
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"\"'`"
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
for|for
control|(
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|delimiter
operator|!=
literal|'\''
operator|&&
operator|(
name|delimiter
operator|!=
literal|'"'
operator|||
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|slashify_in_quotes
argument_list|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|delimiter
operator|&&
name|string
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|delimiter
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|delimiter
operator|&&
operator|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|" \t\n;&()|<>"
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|delimiter
operator|&&
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"\"'`"
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
block|}
name|got_token
label|:
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>=
name|size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
operator|(
name|size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
index|[
name|result_index
index|]
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
index|[
operator|++
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*				Test Code			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|main
parameter_list|()
block|{
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"history%% "
argument_list|)
expr_stmt|;
name|t
operator|=
name|gets
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|int
name|result
decl_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|result
operator|=
name|history_expand
argument_list|(
name|line
argument_list|,
operator|&
name|expansion
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
continue|continue;
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"save"
argument_list|)
operator|==
literal|0
condition|)
name|write_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|read_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|HIST_ENTRY
modifier|*
modifier|*
name|the_list
init|=
name|history_list
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|the_list
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|the_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d: %s\n"
argument_list|,
name|i
operator|+
name|history_base
argument_list|,
name|the_list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"delete"
argument_list|,
name|strlen
argument_list|(
literal|"delete"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|which
decl_stmt|;
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|line
operator|+
name|strlen
argument_list|(
literal|"delete"
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|which
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|remove_history
argument_list|(
name|which
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No such entry %d\n"
argument_list|,
name|which
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"non-numeric arg given to `delete'\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_escape
end_escape

begin_comment
comment|/* * Local variables: * compile-command: "gcc -g -DTEST -o history history.c" * end: */
end_comment

end_unit

