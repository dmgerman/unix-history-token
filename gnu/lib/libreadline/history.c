begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* History.c -- standalone history library */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_ALLOCA_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sparc || HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GNU_C__ */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|savestring
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|strcpy
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
value|strcpy (xmalloc (1 + strlen (x)), (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|whitespace
end_ifndef

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == ' ') || ((c) == '\t'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit
end_ifndef

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|error_pointer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|get_history_word_specifier
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* An array of HIST_ENTRY.  This is where we store the history. */
end_comment

begin_decl_stmt
specifier|static
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have enforced a limit on the amount of    history that we save. */
end_comment

begin_decl_stmt
name|int
name|history_stifled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If HISTORY_STIFLED is non-zero, then this is the maximum number of    entries to remember. */
end_comment

begin_decl_stmt
name|int
name|max_input_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current location of the interactive history pointer.  Just makes    life easier for outside callers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of strings currently stored in the input_history list. */
end_comment

begin_decl_stmt
name|int
name|history_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current number of slots allocated to the input_history. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots to increase the_history by. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HISTORY_GROW_SIZE
value|50
end_define

begin_comment
comment|/* The character that represents the start of a history expansion    request.  This is usually `!'. */
end_comment

begin_decl_stmt
name|char
name|history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that invokes word substitution if found at the start of    a line.  This is usually `^'. */
end_comment

begin_decl_stmt
name|char
name|history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During tokenization, if this character is seen as the first character    of a word, then it, and all subsequent characters upto a newline are    ignored.  For a Bourne shell, this should be '#'.  Bash special cases    the interactive comment character to not be a comment delimiter. */
end_comment

begin_decl_stmt
name|char
name|history_comment_char
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters which inhibit the expansion of text if found    immediately following history_expansion_char. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|history_no_expand_chars
init|=
literal|" \t\n\r="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The logical `base' of the history array.  It defaults to 1. */
end_comment

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current HISTORY_STATE of the history. */
end_comment

begin_function
name|HISTORY_STATE
modifier|*
name|history_get_history_state
parameter_list|()
block|{
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|HISTORY_STATE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HISTORY_STATE
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|entries
operator|=
name|the_history
expr_stmt|;
name|state
operator|->
name|offset
operator|=
name|history_offset
expr_stmt|;
name|state
operator|->
name|length
operator|=
name|history_length
expr_stmt|;
name|state
operator|->
name|size
operator|=
name|history_size
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the state of the current history array to STATE. */
end_comment

begin_function
name|void
name|history_set_history_state
parameter_list|(
name|state
parameter_list|)
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
block|{
name|the_history
operator|=
name|state
operator|->
name|entries
expr_stmt|;
name|history_offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
name|history_length
operator|=
name|state
operator|->
name|length
expr_stmt|;
name|history_size
operator|=
name|state
operator|->
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a session in which the history functions might be used.  This    initializes interactive variables. */
end_comment

begin_function
name|void
name|using_history
parameter_list|()
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes that the primary history entries are using.    This just adds up the lengths of the_history->lines. */
end_comment

begin_function
name|int
name|history_total_bytes
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|the_history
operator|&&
name|the_history
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|result
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Place STRING at the end of the history list.  The data field    is  set to NULL. */
end_comment

begin_function
name|void
name|add_history
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|history_stifled
operator|&&
operator|(
name|history_length
operator|==
name|max_input_history
operator|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the history is stifled, and history_length is zero, 	 and it equals max_input_history, we don't save items. */
if|if
condition|(
operator|!
name|history_length
condition|)
return|return;
comment|/* If there is something in the slot, then remove it. */
if|if
condition|(
name|the_history
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_base
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|history_size
condition|)
block|{
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|history_size
operator|=
name|DEFAULT_HISTORY_GROW_SIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|history_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_length
operator|==
operator|(
name|history_size
operator|-
literal|1
operator|)
condition|)
block|{
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_history
argument_list|,
operator|(
operator|(
name|history_size
operator|+=
name|DEFAULT_HISTORY_GROW_SIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|history_length
operator|++
expr_stmt|;
block|}
block|}
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the history entry at WHICH have LINE and DATA.  This returns    the old entry so you can dispose of the data.  In the case of an    invalid WHICH, a NULL pointer is returned. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|replace_history_entry
parameter_list|(
name|which
parameter_list|,
name|line
parameter_list|,
name|data
parameter_list|)
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|old_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
name|old_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|the_history
index|[
name|which
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|old_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the magic number which says what history element we are    looking at now.  In this implementation, it returns history_offset. */
end_comment

begin_function
name|int
name|where_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search the history for STRING, starting at history_offset.    If DIRECTION< 0, then the search is through previous entries, else    through subsequent.  If ANCHORED is non-zero, the string must    appear at the beginning of a history line, otherwise, the string    may appear anywhere in the line.  If the string is found, then    current_history () is the history entry, and the value of this    function is the offset in the line of that history entry that the    string was found in.  Otherwise, nothing is changed, and a -1 is    returned. */
end_comment

begin_define
define|#
directive|define
name|ANCHORED_SEARCH
value|1
end_define

begin_define
define|#
directive|define
name|NON_ANCHORED_SEARCH
value|0
end_define

begin_function
specifier|static
name|int
name|history_search_internal
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|,
name|anchored
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|,
name|anchored
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|history_offset
decl_stmt|;
specifier|register
name|int
name|reverse
init|=
operator|(
name|direction
operator|<
literal|0
operator|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|string_len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
comment|/* Take care of trivial cases first. */
if|if
condition|(
operator|!
name|history_length
operator|||
operator|(
operator|(
name|i
operator|==
name|history_length
operator|)
operator|&&
operator|!
name|reverse
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|reverse
operator|&&
operator|(
name|i
operator|==
name|history_length
operator|)
condition|)
name|i
operator|--
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Search each line in the history list for STRING. */
comment|/* At limit for direction? */
if|if
condition|(
operator|(
name|reverse
operator|&&
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|reverse
operator|&&
name|i
operator|==
name|history_length
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|line
operator|=
name|the_history
index|[
name|i
index|]
operator|->
name|line
expr_stmt|;
name|index
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* If STRING is longer than line, no match. */
if|if
condition|(
name|string_len
operator|>
name|index
condition|)
goto|goto
name|next_line
goto|;
comment|/* Handle anchored searches first. */
if|if
condition|(
name|anchored
operator|==
name|ANCHORED_SEARCH
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
name|line
argument_list|,
name|string_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|next_line
goto|;
block|}
comment|/* Do substring search. */
if|if
condition|(
name|reverse
condition|)
block|{
name|index
operator|-=
name|string_len
expr_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|index
argument_list|,
name|string_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
name|index
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|int
name|limit
init|=
name|index
operator|-
name|string_len
operator|+
literal|1
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|index
argument_list|,
name|string_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
block|}
name|next_line
label|:
if|if
condition|(
name|reverse
condition|)
name|i
operator|--
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a non-anchored search for STRING through the history in DIRECTION. */
end_comment

begin_function
name|int
name|history_search
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
return|return
operator|(
name|history_search_internal
argument_list|(
name|string
argument_list|,
name|direction
argument_list|,
name|NON_ANCHORED_SEARCH
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do an anchored search for string through the history in DIRECTION. */
end_comment

begin_function
name|int
name|history_search_prefix
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
return|return
operator|(
name|history_search_internal
argument_list|(
name|string
argument_list|,
name|direction
argument_list|,
name|ANCHORED_SEARCH
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove history element WHICH from the history.  The removed    element is returned to you so you can free the line, data,    and containing structure. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|remove_history
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|return_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
operator|||
operator|!
name|history_length
condition|)
name|return_value
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|return_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|which
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_length
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stifle the history list, remembering only MAX number of lines. */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_length
operator|>
name|max
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|history_length
operator|-
name|max
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|history_base
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|max
init|;
name|j
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|the_history
index|[
name|j
index|]
operator|=
name|the_history
index|[
name|i
index|]
expr_stmt|;
name|the_history
index|[
name|j
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|history_length
operator|=
name|j
expr_stmt|;
block|}
name|history_stifled
operator|=
literal|1
expr_stmt|;
name|max_input_history
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop stifling the history.  This returns the previous amount the history  was stifled by.  The value is positive if the history was stifled, negative  if it wasn't. */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|()
block|{
name|int
name|result
init|=
name|max_input_history
decl_stmt|;
if|if
condition|(
name|history_stifled
condition|)
block|{
name|result
operator|=
operator|-
name|result
expr_stmt|;
name|history_stifled
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the string that should be used in the place of this    filename.  This only matters when you don't specify the    filename to read_history (), or write_history (). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|history_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|return_val
init|=
name|filename
condition|?
name|savestring
argument_list|(
name|filename
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|return_val
condition|)
block|{
name|char
modifier|*
name|home
decl_stmt|;
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|home
condition|)
name|home
operator|=
literal|"."
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|home
argument_list|)
operator|+
name|strlen
argument_list|(
literal|".history"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|return_val
argument_list|,
literal|"%s/.history"
argument_list|,
name|home
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the contents of FILENAME to the history list, a line at a time.    If FILENAME is NULL, then read from ~/.history.  Returns 0 if    successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|read_history_range
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a range of lines from FILENAME, adding them to the history list.    Start reading at the FROM'th line and end at the TO'th.  If FROM    is zero, start at the beginning.  If TO is less than FROM, read    until the end of the file.  If FILENAME is NULL, then read from    ~/.history.  Returns 0 if successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history_range
parameter_list|(
name|filename
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|line_start
decl_stmt|,
name|line_end
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|,
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|file
decl_stmt|,
name|current_line
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|input
operator|=
name|history_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|input
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|<
literal|0
operator|)
operator|||
operator|(
name|stat
argument_list|(
name|input
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
goto|goto
name|error_and_exit
goto|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|finfo
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|finfo
operator|.
name|st_size
argument_list|)
operator|!=
name|finfo
operator|.
name|st_size
condition|)
name|error_and_exit
label|:
block|{
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
condition|)
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set TO to larger than end of file if negative. */
if|if
condition|(
name|to
operator|<
literal|0
condition|)
name|to
operator|=
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* Start at beginning of file, work to end. */
name|line_start
operator|=
name|line_end
operator|=
name|current_line
operator|=
literal|0
expr_stmt|;
comment|/* Skip lines until we are at FROM. */
while|while
condition|(
name|line_start
operator|<
name|finfo
operator|.
name|st_size
operator|&&
name|current_line
operator|<
name|from
condition|)
block|{
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|finfo
operator|.
name|st_size
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|line_end
index|]
operator|==
literal|'\n'
condition|)
block|{
name|current_line
operator|++
expr_stmt|;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|current_line
operator|==
name|from
condition|)
break|break;
block|}
block|}
comment|/* If there are lines left to gobble, then gobble them now. */
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|finfo
operator|.
name|st_size
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|line_end
index|]
operator|==
literal|'\n'
condition|)
block|{
name|buffer
index|[
name|line_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|line_start
index|]
condition|)
name|add_history
argument_list|(
name|buffer
operator|+
name|line_start
argument_list|)
expr_stmt|;
name|current_line
operator|++
expr_stmt|;
if|if
condition|(
name|current_line
operator|>=
name|to
condition|)
break|break;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|input
condition|)
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate the history file FNAME, leaving only LINES trailing lines.    If FNAME is NULL, then use ~/.history. */
end_comment

begin_function
name|int
name|history_truncate_file
parameter_list|(
name|fname
parameter_list|,
name|lines
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|int
name|lines
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|file
decl_stmt|,
name|chars_read
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|filename
operator|=
name|history_filename
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|truncate_exit
goto|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|-
literal|1
condition|)
goto|goto
name|truncate_exit
goto|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|finfo
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chars_read
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|finfo
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|<=
literal|0
condition|)
goto|goto
name|truncate_exit
goto|;
comment|/* Count backwards from the end of buffer until we have passed      LINES lines. */
for|for
control|(
name|i
operator|=
name|chars_read
operator|-
literal|1
init|;
name|lines
operator|&&
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|lines
operator|--
expr_stmt|;
block|}
comment|/* If there are fewer lines in the file than we want to truncate to,      then we are all done. */
if|if
condition|(
operator|!
name|i
condition|)
goto|goto
name|truncate_exit
goto|;
comment|/* Otherwise, write from the start of this line until the end of the      buffer. */
for|for
control|(
operator|--
name|i
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|-
literal|1
condition|)
goto|goto
name|truncate_exit
goto|;
name|write
argument_list|(
name|file
argument_list|,
name|buffer
operator|+
name|i
argument_list|,
name|finfo
operator|.
name|st_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|truncate_exit
label|:
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HISTORY_APPEND
value|0
end_define

begin_define
define|#
directive|define
name|HISTORY_OVERWRITE
value|1
end_define

begin_comment
comment|/* Workhorse function for writing history.  Writes NELEMENT entries    from the history list to FILENAME.  OVERWRITE is non-zero if you    wish to replace FILENAME with the entries. */
end_comment

begin_function
specifier|static
name|int
name|history_do_write
parameter_list|(
name|filename
parameter_list|,
name|nelements
parameter_list|,
name|overwrite
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|nelements
decl_stmt|,
name|overwrite
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|history_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|int
name|file
decl_stmt|,
name|mode
decl_stmt|;
if|if
condition|(
name|overwrite
condition|)
name|mode
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
else|else
name|mode
operator|=
name|O_WRONLY
operator||
name|O_APPEND
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|output
argument_list|,
name|mode
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|output
condition|)
name|free
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|nelements
operator|>
name|history_length
condition|)
name|nelements
operator|=
name|history_length
expr_stmt|;
comment|/* Build a buffer of all the lines to write, and write them in one syscall.      Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
block|{
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|buffer_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Calculate the total number of bytes to write. */
for|for
control|(
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|buffer_size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
comment|/* Allocate the buffer, and fill it. */
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buffer_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|write
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|free
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Append NELEMENT entries to FILENAME.  The entries appended are from    the end of the list minus NELEMENTs up to the end of the list. */
end_comment

begin_function
name|int
name|append_history
parameter_list|(
name|nelements
parameter_list|,
name|filename
parameter_list|)
name|int
name|nelements
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|nelements
argument_list|,
name|HISTORY_APPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite FILENAME with the current history.  If FILENAME is NULL,    then write the history list to ~/.history.  Values returned    are as in read_history ().*/
end_comment

begin_function
name|int
name|write_history
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|history_length
argument_list|,
name|HISTORY_OVERWRITE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry at the current position, as determined by    history_offset.  If there is no entry there, return a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|()
block|{
if|if
condition|(
operator|(
name|history_offset
operator|==
name|history_length
operator|)
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Back up history_offset to the previous history entry, and return    a pointer to that entry.  If there is no previous entry then return    a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|()
block|{
if|if
condition|(
operator|!
name|history_offset
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
operator|--
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move history_offset forward to the next history entry, and return    a pointer to that entry.  If there is no next entry then return a    NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|()
block|{
if|if
condition|(
name|history_offset
operator|==
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
operator|++
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the current history array.  The caller has to be carefull, since this    is the actual array of data, and could be bashed or made corrupt easily.    The array is terminated with a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
modifier|*
name|history_list
parameter_list|()
block|{
return|return
operator|(
name|the_history
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry which is logically at OFFSET in the history array.    OFFSET is relative to history_base. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|int
name|local_index
init|=
name|offset
operator|-
name|history_base
decl_stmt|;
if|if
condition|(
name|local_index
operator|>=
name|history_length
operator|||
name|local_index
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|the_history
index|[
name|local_index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING in the history list.  DIR is< 0 for searching    backwards.  POS is an absolute index into the history list at    which point to begin searching. */
end_comment

begin_function
name|int
name|history_search_pos
parameter_list|(
name|string
parameter_list|,
name|dir
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|old
init|=
name|where_history
argument_list|()
decl_stmt|;
name|history_set_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_search
argument_list|(
name|string
argument_list|,
name|dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Make the current history item be the one at POS, an absolute index.    Returns zero if POS is out of range, else non-zero. */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|pos
parameter_list|)
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|>
name|history_length
operator|||
name|pos
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|history_offset
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Expansion			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Hairy history expansion on text, not tokens.  This is of general    use, and thus belongs in this library. */
end_comment

begin_comment
comment|/* The last string searched for in a !?string? search. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the event specified at TEXT + OFFSET modifying OFFSET to    point to after the event specifier.  Just a pointer to the history    line is returned; NULL is returned in the event of a bad specifier.    You pass STRING with *INDEX equal to the history_expansion_char that    begins this specification.    DELIMITING_QUOTE is a character that is allowed to end the string    specification for what to search for in addition to the normal    characters `:', ` ', `\t', `\n', and sometimes `?'.    So you might call this function like:    line = get_history_event ("!echo:p",&index, 0);  */
end_comment

begin_function
name|char
modifier|*
name|get_history_event
parameter_list|(
name|string
parameter_list|,
name|caller_index
parameter_list|,
name|delimiting_quote
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|caller_index
decl_stmt|;
name|int
name|delimiting_quote
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
name|int
name|which
decl_stmt|,
name|sign
init|=
literal|1
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
comment|/* The event can be specified in a number of ways.       !!   the previous command      !n   command line N      !-n  current command-line minus N      !str the most recent command starting with STR      !?str[?] 	  the most recent command containing STR       All values N are determined via HISTORY_BASE. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Move on to the specification. */
name|i
operator|++
expr_stmt|;
comment|/* Handle !! case. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|which
operator|=
name|history_base
operator|+
operator|(
name|history_length
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
goto|goto
name|get_which
goto|;
block|}
comment|/* Hack case of numeric line specification. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|digit
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
comment|/* Get the extent of the digits. */
for|for
control|(
init|;
name|digit
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Get the digit value. */
name|sscanf
argument_list|(
name|string
operator|+
name|start
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|which
argument_list|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|which
operator|=
operator|(
name|history_length
operator|+
name|history_base
operator|)
operator|-
name|which
expr_stmt|;
name|get_which
label|:
if|if
condition|(
name|entry
operator|=
name|history_get
argument_list|(
name|which
argument_list|)
condition|)
return|return
operator|(
name|entry
operator|->
name|line
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* This must be something to search for.  If the spec begins with      a '?', then the string may be anywhere on the line.  Otherwise,      the string must be found at the start of a line. */
block|{
name|int
name|local_index
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|substring_okay
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
block|{
name|substring_okay
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|local_index
operator|=
name|i
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|':'
operator|||
operator|(
name|substring_okay
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'?'
operator|)
operator|||
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|";&()|<>"
argument_list|)
operator|||
endif|#
directive|endif
comment|/* SHELL */
name|string
index|[
name|i
index|]
operator|==
name|delimiting_quote
condition|)
break|break;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|local_index
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
operator|&
name|string
index|[
name|local_index
index|]
argument_list|,
operator|(
name|i
operator|-
name|local_index
operator|)
argument_list|)
expr_stmt|;
name|temp
index|[
name|i
operator|-
name|local_index
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
name|search_again
label|:
name|local_index
operator|=
name|history_search_internal
argument_list|(
name|temp
argument_list|,
operator|-
literal|1
argument_list|,
name|substring_okay
condition|?
name|NON_ANCHORED_SEARCH
else|:
name|ANCHORED_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_index
operator|<
literal|0
condition|)
name|search_lost
label|:
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|local_index
operator|==
literal|0
operator|||
name|substring_okay
condition|)
block|{
name|entry
operator|=
name|current_history
argument_list|()
expr_stmt|;
name|history_offset
operator|=
name|history_length
expr_stmt|;
comment|/* If this was a substring search, then remember the string that 	   we matched for word substitution. */
if|if
condition|(
name|substring_okay
condition|)
block|{
if|if
condition|(
name|search_string
condition|)
name|free
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
name|search_string
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|entry
operator|->
name|line
operator|)
return|;
block|}
if|if
condition|(
name|history_offset
condition|)
name|history_offset
operator|--
expr_stmt|;
else|else
goto|goto
name|search_lost
goto|;
goto|goto
name|search_again
goto|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_comment
comment|/* Function for extracting single-quoted strings.  Used for inhibiting    history expansion within single quotes. */
end_comment

begin_comment
comment|/* Extract the contents of STRING as if it is enclosed in single quotes.    SINDEX, when passed in, is the offset of the character immediately    following the opening single quote; on exit, SINDEX is left pointing    to the closing single quote. */
end_comment

begin_function
specifier|static
name|void
name|rl_string_extract_single_quoted
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|sindex
decl_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|'\''
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHELL */
end_comment

begin_comment
comment|/* Expand the string STRING, placing the result into OUTPUT, a pointer    to a string.  Returns:     0) If no expansions took place (or, if the only change in       the text was the de-slashifying of the history expansion       character)    1) If expansions did take place   -1) If there was an error in expansion.    If an error ocurred in expansion, then OUTPUT contains a descriptive   error message. */
end_comment

begin_function
name|int
name|history_expand
parameter_list|(
name|string
parameter_list|,
name|output
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|output
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|word_spec_error
init|=
literal|0
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|modified
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|word_spec
decl_stmt|,
modifier|*
name|event
decl_stmt|;
name|int
name|starting_index
decl_stmt|,
name|only_printing
init|=
literal|0
decl_stmt|,
name|substitute_globally
init|=
literal|0
decl_stmt|;
comment|/* The output string, and its length. */
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Used in add_string; */
name|char
modifier|*
name|temp
decl_stmt|,
name|tt
index|[
literal|2
index|]
decl_stmt|,
name|tbl
index|[
literal|3
index|]
decl_stmt|;
comment|/* Prepare the buffer for printing error messages. */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|=
literal|256
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|tt
index|[
literal|1
index|]
operator|=
name|tbl
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tbl
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|tbl
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
comment|/* Grovel the string.  Only backslash can quote the history escape      character.  We also handle arg specifiers. */
comment|/* Before we grovel forever, see if the history_expansion_char appears      anywhere within the text. */
comment|/* The quick substitution character is a history expansion all right.  That      is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,      that is the substitution that we do. */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
name|history_subst_char
condition|)
block|{
name|char
modifier|*
name|format_string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|format_string
argument_list|,
literal|"%c%c:s%s"
argument_list|,
name|history_expansion_char
argument_list|,
name|history_expansion_char
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|string
operator|=
name|format_string
expr_stmt|;
name|l
operator|+=
literal|4
expr_stmt|;
goto|goto
name|grovel
goto|;
block|}
comment|/* If not quick substitution, still maybe have to do expansion. */
comment|/* `!' followed by one of the characters in history_no_expand_chars      is NOT an expansion. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
if|if
condition|(
operator|!
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|||
name|member
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* The shell uses ! as a pattern negation character in globbing [...] 	   expressions, so let those pass without expansion. */
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'['
operator|)
operator|&&
name|member
argument_list|(
literal|']'
argument_list|,
name|string
operator|+
name|i
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* SHELL */
else|else
goto|goto
name|grovel
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
elseif|else
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
comment|/* If this is bash, single quotes inhibit history expansion. */
name|i
operator|++
expr_stmt|;
name|rl_string_extract_single_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* If this is bash, allow backslashes to quote single quotes and 	     the history expansion character. */
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\''
operator|||
operator|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|history_expansion_char
operator|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SHELL */
block|}
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|grovel
label|:
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|int
name|passc
init|=
literal|0
decl_stmt|;
name|int
name|tchar
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tchar
operator|==
name|history_expansion_char
condition|)
name|tchar
operator|=
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
goto|goto
name|add_char
goto|;
block|}
switch|switch
condition|(
name|tchar
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|temp
operator|=
name|tbl
expr_stmt|;
goto|goto
name|do_add
goto|;
block|}
else|else
block|{
name|passc
operator|++
expr_stmt|;
goto|goto
name|add_char
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
case|case
literal|'\''
case|:
block|{
comment|/* If this is bash, single quotes inhibit history expansion. */
name|int
name|quote
init|=
name|i
decl_stmt|,
name|slen
decl_stmt|;
operator|++
name|i
expr_stmt|;
name|rl_string_extract_single_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|slen
operator|=
name|i
operator|-
name|quote
operator|+
literal|2
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|slen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|quote
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|temp
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|do_add
goto|;
block|}
endif|#
directive|endif
comment|/* SHELL */
comment|/* case history_expansion_char: */
case|case
operator|-
literal|3
case|:
name|starting_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|cc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If the history_expansion_char is followed by one of the 	     characters in history_no_expand_chars, then it is not a 	     candidate for expansion of any kind. */
if|if
condition|(
name|member
argument_list|(
name|cc
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
goto|goto
name|add_char
goto|;
comment|/* There is something that is listed as a `word specifier' in csh 	     documentation which means `the expanded text to this point'. 	     That is not a word specifier, it is an event specifier. */
if|if
condition|(
name|cc
operator|==
literal|'#'
condition|)
goto|goto
name|hack_pound_sign
goto|;
comment|/* If it is followed by something that starts a word specifier, 	     then !! is implied as the event specifier. */
if|if
condition|(
name|member
argument_list|(
name|cc
argument_list|,
literal|":$*%^"
argument_list|)
condition|)
block|{
name|char
name|fake_s
index|[
literal|3
index|]
decl_stmt|;
name|int
name|fake_i
init|=
literal|0
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|fake_s
index|[
literal|0
index|]
operator|=
name|fake_s
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|fake_s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|fake_s
argument_list|,
operator|&
name|fake_i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|quoted_search_delimiter
init|=
literal|0
decl_stmt|;
comment|/* If the character before this `!' is a double or single 		 quote, then this expansion takes place inside of the 		 quoted string.  If we have to search for some text ("!foo"), 		 allow the delimiter to end the search string. */
if|if
condition|(
name|i
operator|&&
operator|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\''
operator|||
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
name|quoted_search_delimiter
operator|=
name|string
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|quoted_search_delimiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|event
condition|)
name|event_not_found
label|:
block|{
name|int
name|ll
init|=
literal|1
operator|+
operator|(
name|i
operator|-
name|starting_index
operator|)
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|ll
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|starting_index
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|temp
index|[
name|ll
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%s: %s."
argument_list|,
name|temp
argument_list|,
name|word_spec_error
condition|?
literal|"Bad word specifier"
else|:
literal|"Event not found"
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|result
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If a word specifier is found, then do what that requires. */
name|starting_index
operator|=
name|i
expr_stmt|;
name|word_spec
operator|=
name|get_history_word_specifier
argument_list|(
name|string
argument_list|,
name|event
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* There is no such thing as a `malformed word specifier'.  However, 	     it is possible for a specifier that has no match.  In that case, 	     we complain. */
if|if
condition|(
name|word_spec
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|error_pointer
condition|)
block|{
name|word_spec_error
operator|++
expr_stmt|;
goto|goto
name|event_not_found
goto|;
block|}
comment|/* If no word specifier, than the thing of interest was the event. */
if|if
condition|(
operator|!
name|word_spec
condition|)
name|temp
operator|=
name|event
expr_stmt|;
else|else
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|word_spec
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|word_spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word_spec
argument_list|)
expr_stmt|;
block|}
comment|/* Perhaps there are other modifiers involved.  Do what they say. */
name|hack_specials
label|:
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|tstr
decl_stmt|;
switch|switch
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
comment|/* :p means make this the last executed line.  So we 		     return an error state after adding this line to the 		     history. */
case|case
literal|'p'
case|:
name|only_printing
operator|++
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :t discards all but the last part of the pathname. */
case|case
literal|'t'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
name|temp
operator|=
operator|++
name|tstr
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :h discards the last part of a pathname. */
case|case
literal|'h'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :r discards the suffix. */
case|case
literal|'r'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :e discards everything but the suffix. */
case|case
literal|'e'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
name|temp
operator|=
name|tstr
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :s/this/that substitutes `this' for `that'. */
comment|/* :gs/this/that substitutes `this' for `that' globally. */
case|case
literal|'g'
case|:
ifdef|#
directive|ifdef
name|NOTYET
comment|/* :g/this/that is equivalent to :gs/this/that */
name|substitute_globally
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'s'
condition|)
name|i
operator|++
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'s'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|substitute_globally
operator|=
literal|1
expr_stmt|;
goto|goto
name|substitute
goto|;
block|}
endif|#
directive|endif
else|else
case|case
literal|'s'
case|:
name|substitute
label|:
block|{
name|char
modifier|*
name|this
decl_stmt|,
modifier|*
name|that
decl_stmt|,
modifier|*
name|new_event
decl_stmt|;
name|int
name|delimiter
init|=
literal|0
decl_stmt|;
name|int
name|si
decl_stmt|,
name|l_this
decl_stmt|,
name|l_that
decl_stmt|,
name|l_temp
init|=
name|strlen
argument_list|(
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|2
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|delimiter
condition|)
break|break;
name|i
operator|+=
literal|3
expr_stmt|;
comment|/* Get THIS. */
for|for
control|(
name|si
operator|=
name|i
init|;
name|string
index|[
name|si
index|]
operator|&&
name|string
index|[
name|si
index|]
operator|!=
name|delimiter
condition|;
name|si
operator|++
control|)
empty_stmt|;
name|l_this
operator|=
operator|(
name|si
operator|-
name|i
operator|)
expr_stmt|;
name|this
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|l_this
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|this
argument_list|,
name|string
operator|+
name|i
argument_list|,
name|l_this
argument_list|)
expr_stmt|;
name|this
index|[
name|l_this
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|string
index|[
name|si
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Get THAT. */
for|for
control|(
name|si
operator|=
name|i
init|;
name|string
index|[
name|si
index|]
operator|&&
name|string
index|[
name|si
index|]
operator|!=
name|delimiter
condition|;
name|si
operator|++
control|)
empty_stmt|;
name|l_that
operator|=
operator|(
name|si
operator|-
name|i
operator|)
expr_stmt|;
name|that
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|l_that
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|that
argument_list|,
name|string
operator|+
name|i
argument_list|,
name|l_that
argument_list|)
expr_stmt|;
name|that
index|[
name|l_that
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|string
index|[
name|si
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Ignore impossible cases. */
if|if
condition|(
name|l_this
operator|>
name|l_temp
condition|)
goto|goto
name|cant_substitute
goto|;
comment|/* Find the first occurrence of THIS in TEMP. */
name|si
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|si
operator|+
name|l_this
operator|)
operator|<=
name|l_temp
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|temp
operator|+
name|si
argument_list|,
name|this
argument_list|,
name|l_this
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new_event
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
name|l_that
operator|-
name|l_this
operator|)
operator|+
name|l_temp
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
argument_list|,
name|temp
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
argument_list|,
name|that
argument_list|,
name|l_that
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
operator|+
name|l_that
argument_list|,
name|temp
operator|+
name|si
operator|+
name|l_this
argument_list|,
name|l_temp
operator|-
operator|(
name|si
operator|+
name|l_this
operator|)
argument_list|)
expr_stmt|;
name|new_event
index|[
operator|(
name|l_that
operator|-
name|l_this
operator|)
operator|+
name|l_temp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|new_event
expr_stmt|;
if|if
condition|(
name|substitute_globally
condition|)
block|{
name|si
operator|+=
name|l_that
expr_stmt|;
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|substitute_globally
operator|++
expr_stmt|;
continue|continue;
block|}
goto|goto
name|hack_specials
goto|;
block|}
name|cant_substitute
label|:
if|if
condition|(
name|substitute_globally
operator|>
literal|1
condition|)
block|{
name|substitute_globally
operator|=
literal|0
expr_stmt|;
goto|goto
name|hack_specials
goto|;
block|}
goto|goto
name|event_not_found
goto|;
block|}
comment|/* :# is the line so far.  Note that we have to 		     alloca () it since RESULT could be realloc ()'ed 		     below in add_string. */
case|case
literal|'#'
case|:
name|hack_pound_sign
label|:
if|if
condition|(
name|result
condition|)
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
literal|""
expr_stmt|;
name|next_special
label|:
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|hack_specials
goto|;
block|}
block|}
comment|/* Believe it or not, we have to back the pointer up by one. */
operator|--
name|i
expr_stmt|;
goto|goto
name|add_string
goto|;
comment|/* A regular character.  Just add it to the output string. */
default|default:
name|add_char
label|:
name|tt
index|[
literal|0
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
name|temp
operator|=
name|tt
expr_stmt|;
goto|goto
name|do_add
goto|;
name|add_string
label|:
name|modified
operator|++
expr_stmt|;
name|do_add
label|:
name|j
operator|+=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|>
operator|(
name|len
operator|-
literal|1
operator|)
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|len
operator|+=
literal|256
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
operator|(
name|j
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|output
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|only_printing
condition|)
block|{
name|add_history
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|modified
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a consed string which is the word specified in SPEC, and found    in FROM.  NULL is returned if there is no spec.  The address of    ERROR_POINTER is returned if the word specified cannot be found.    CALLER_INDEX is the offset in SPEC to start looking; it is updated    to point to just after the last character parsed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_history_word_specifier
parameter_list|(
name|spec
parameter_list|,
name|from
parameter_list|,
name|caller_index
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|caller_index
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|int
name|expecting_word_spec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|history_arg_extract
parameter_list|()
function_decl|;
comment|/* The range of words to return doesn't exist yet. */
name|first
operator|=
name|last
operator|=
literal|0
expr_stmt|;
comment|/* If we found a colon, then this *must* be a word specification.  If      it isn't, then it is an error. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|i
operator|++
operator|,
name|expecting_word_spec
operator|++
expr_stmt|;
comment|/* Handle special cases first. */
comment|/* `%' is the word last searched for. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|search_string
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|search_string
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
comment|/* `*' matches all of the arguments, but not the command. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
name|char
modifier|*
name|star_result
decl_stmt|;
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|star_result
operator|=
name|history_arg_extract
argument_list|(
literal|1
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|star_result
condition|)
name|star_result
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|star_result
operator|)
return|;
block|}
comment|/* `$' is last arg. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|history_arg_extract
argument_list|(
literal|'$'
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
comment|/* Try to get FIRST and LAST figured out. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'-'
operator|||
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_last
goto|;
block|}
if|if
condition|(
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
operator|&&
name|expecting_word_spec
condition|)
block|{
name|sscanf
argument_list|(
name|spec
operator|+
name|i
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|get_last
label|:
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_args
goto|;
block|}
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|last
operator|=
name|first
expr_stmt|;
goto|goto
name|get_args
goto|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|spec
operator|+
name|i
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|last
operator|=
literal|'$'
expr_stmt|;
block|}
name|get_args
label|:
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|last
operator|>=
name|first
condition|)
name|result
operator|=
name|history_arg_extract
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|error_pointer
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* Extract the args specified, starting at FIRST, and ending at LAST.    The args are taken from STRING.  If either FIRST or LAST is< 0,    then make that arg count from the right (subtract from the number of    tokens, so that FIRST = -1 means the next to last token on the line). */
end_comment

begin_function
name|char
modifier|*
name|history_arg_extract
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|string
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|history_tokenize
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|history_tokenize
argument_list|(
name|string
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|list
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
name|last
operator|=
name|len
operator|+
name|last
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
name|first
operator|=
name|len
operator|+
name|first
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|'$'
condition|)
name|last
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|'$'
condition|)
name|first
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|last
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|len
operator|||
name|last
operator|>
name|len
operator|||
name|first
operator|<
literal|0
operator|||
name|last
operator|<
literal|0
condition|)
name|result
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size
operator|=
operator|(
literal|2
operator|+
name|l
operator|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|size
operator|+=
operator|(
literal|2
operator|+
name|l
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|offset
argument_list|,
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|last
condition|)
block|{
name|strcpy
argument_list|(
name|result
operator|+
name|offset
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|slashify_in_quotes
value|"\\`\"$"
end_define

begin_comment
comment|/* Return an array of tokens, much as the shell might.  The tokens are    parsed out of STRING. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|result_index
decl_stmt|,
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
name|i
operator|=
name|result_index
operator|=
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Get a token, and stuff it into RESULT.  The tokens are split      exactly where the shell would split them. */
name|get_token
label|:
comment|/* Skip leading whitespace. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|string
index|[
name|i
index|]
operator|||
name|string
index|[
name|i
index|]
operator|==
name|history_comment_char
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"()\n"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"<>;&|$"
argument_list|)
condition|)
block|{
name|int
name|peek
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|peek
operator|==
name|string
index|[
name|i
index|]
operator|&&
name|peek
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|peek
operator|==
literal|'<'
operator|&&
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'-'
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|peek
operator|==
literal|'&'
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'>'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'<'
operator|)
operator|)
operator|||
operator|(
operator|(
name|peek
operator|==
literal|'>'
operator|)
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'&'
operator|)
operator|)
operator|||
operator|(
operator|(
name|peek
operator|==
literal|'('
operator|)
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'$'
operator|)
operator|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
block|}
comment|/* Get word from string + i; */
block|{
name|int
name|delimiter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"\"'`"
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
for|for
control|(
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|delimiter
operator|!=
literal|'\''
condition|)
if|if
condition|(
operator|(
name|delimiter
operator|!=
literal|'"'
operator|)
operator|||
operator|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|slashify_in_quotes
argument_list|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|delimiter
operator|&&
name|string
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|delimiter
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|delimiter
operator|&&
operator|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|" \t\n;&()|<>"
argument_list|)
operator|)
condition|)
goto|goto
name|got_token
goto|;
if|if
condition|(
operator|!
name|delimiter
operator|&&
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"\"'`"
argument_list|)
condition|)
block|{
name|delimiter
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
block|}
name|got_token
label|:
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>=
name|size
condition|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size
operator|=
literal|10
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
operator|(
name|size
operator|+=
literal|10
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
index|[
name|result_index
index|]
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result_index
operator|++
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
goto|goto
name|get_token
goto|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*				Test Code			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|main
parameter_list|()
block|{
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"history%% "
argument_list|)
expr_stmt|;
name|t
operator|=
name|gets
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|int
name|result
decl_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|result
operator|=
name|history_expand
argument_list|(
name|line
argument_list|,
operator|&
name|expansion
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
continue|continue;
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"save"
argument_list|)
operator|==
literal|0
condition|)
name|write_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|read_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|HIST_ENTRY
modifier|*
modifier|*
name|the_list
init|=
name|history_list
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|the_list
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|the_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d: %s\n"
argument_list|,
name|i
operator|+
name|history_base
argument_list|,
name|the_list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"delete"
argument_list|,
name|strlen
argument_list|(
literal|"delete"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|which
decl_stmt|;
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|line
operator|+
name|strlen
argument_list|(
literal|"delete"
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|which
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|remove_history
argument_list|(
name|which
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No such entry %d\n"
argument_list|,
name|which
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"non-numeric arg given to `delete'\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_escape
end_escape

begin_comment
comment|/* * Local variables: * compile-command: "gcc -g -DTEST -o history history.c" * end: */
end_comment

end_unit

