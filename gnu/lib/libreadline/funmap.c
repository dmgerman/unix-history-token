begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* funmap.c -- attach names to functions. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUFSIZ
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUFSIZ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|"rlconf.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_function_decl
specifier|static
name|int
name|qsort_string_compare
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FUNMAP
modifier|*
modifier|*
name|funmap
init|=
operator|(
name|FUNMAP
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|funmap_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|funmap_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After initializing the function map, this is the index of the first    program specific function. */
end_comment

begin_decl_stmt
name|int
name|funmap_program_specific_entry_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FUNMAP
name|default_funmap
index|[]
init|=
block|{
block|{
literal|"abort"
block|,
name|rl_abort
block|}
block|,
block|{
literal|"accept-line"
block|,
name|rl_newline
block|}
block|,
block|{
literal|"arrow-key-prefix"
block|,
name|rl_arrow_keys
block|}
block|,
block|{
literal|"backward-char"
block|,
name|rl_backward
block|}
block|,
block|{
literal|"backward-delete-char"
block|,
name|rl_rubout
block|}
block|,
block|{
literal|"backward-kill-line"
block|,
name|rl_backward_kill_line
block|}
block|,
block|{
literal|"backward-kill-word"
block|,
name|rl_backward_kill_word
block|}
block|,
block|{
literal|"backward-word"
block|,
name|rl_backward_word
block|}
block|,
block|{
literal|"beginning-of-history"
block|,
name|rl_beginning_of_history
block|}
block|,
block|{
literal|"beginning-of-line"
block|,
name|rl_beg_of_line
block|}
block|,
block|{
literal|"call-last-kbd-macro"
block|,
name|rl_call_last_kbd_macro
block|}
block|,
block|{
literal|"capitalize-word"
block|,
name|rl_capitalize_word
block|}
block|,
block|{
literal|"clear-screen"
block|,
name|rl_clear_screen
block|}
block|,
block|{
literal|"complete"
block|,
name|rl_complete
block|}
block|,
block|{
literal|"delete-char"
block|,
name|rl_delete
block|}
block|,
block|{
literal|"delete-horizontal-space"
block|,
name|rl_delete_horizontal_space
block|}
block|,
block|{
literal|"digit-argument"
block|,
name|rl_digit_argument
block|}
block|,
block|{
literal|"do-lowercase-version"
block|,
name|rl_do_lowercase_version
block|}
block|,
block|{
literal|"downcase-word"
block|,
name|rl_downcase_word
block|}
block|,
block|{
literal|"dump-functions"
block|,
name|rl_dump_functions
block|}
block|,
block|{
literal|"emacs-editing-mode"
block|,
name|rl_emacs_editing_mode
block|}
block|,
block|{
literal|"end-kbd-macro"
block|,
name|rl_end_kbd_macro
block|}
block|,
block|{
literal|"end-of-history"
block|,
name|rl_end_of_history
block|}
block|,
block|{
literal|"end-of-line"
block|,
name|rl_end_of_line
block|}
block|,
block|{
literal|"forward-char"
block|,
name|rl_forward
block|}
block|,
block|{
literal|"forward-search-history"
block|,
name|rl_forward_search_history
block|}
block|,
block|{
literal|"forward-word"
block|,
name|rl_forward_word
block|}
block|,
block|{
literal|"history-search-backward"
block|,
name|rl_history_search_backward
block|}
block|,
block|{
literal|"history-search-forward"
block|,
name|rl_history_search_forward
block|}
block|,
block|{
literal|"insert-completions"
block|,
name|rl_insert_completions
block|}
block|,
block|{
literal|"kill-whole-line"
block|,
name|rl_kill_full_line
block|}
block|,
block|{
literal|"kill-line"
block|,
name|rl_kill_line
block|}
block|,
block|{
literal|"kill-word"
block|,
name|rl_kill_word
block|}
block|,
block|{
literal|"next-history"
block|,
name|rl_get_next_history
block|}
block|,
block|{
literal|"non-incremental-forward-search-history"
block|,
name|rl_noninc_forward_search
block|}
block|,
block|{
literal|"non-incremental-reverse-search-history"
block|,
name|rl_noninc_reverse_search
block|}
block|,
block|{
literal|"non-incremental-forward-search-history-again"
block|,
name|rl_noninc_forward_search_again
block|}
block|,
block|{
literal|"non-incremental-reverse-search-history-again"
block|,
name|rl_noninc_reverse_search_again
block|}
block|,
block|{
literal|"possible-completions"
block|,
name|rl_possible_completions
block|}
block|,
block|{
literal|"previous-history"
block|,
name|rl_get_previous_history
block|}
block|,
block|{
literal|"quoted-insert"
block|,
name|rl_quoted_insert
block|}
block|,
block|{
literal|"re-read-init-file"
block|,
name|rl_re_read_init_file
block|}
block|,
block|{
literal|"redraw-current-line"
block|,
name|rl_refresh_line
block|}
block|,
block|{
literal|"reverse-search-history"
block|,
name|rl_reverse_search_history
block|}
block|,
block|{
literal|"revert-line"
block|,
name|rl_revert_line
block|}
block|,
block|{
literal|"self-insert"
block|,
name|rl_insert
block|}
block|,
block|{
literal|"start-kbd-macro"
block|,
name|rl_start_kbd_macro
block|}
block|,
block|{
literal|"tab-insert"
block|,
name|rl_tab_insert
block|}
block|,
block|{
literal|"tilde-expand"
block|,
name|rl_tilde_expand
block|}
block|,
block|{
literal|"transpose-chars"
block|,
name|rl_transpose_chars
block|}
block|,
block|{
literal|"transpose-words"
block|,
name|rl_transpose_words
block|}
block|,
block|{
literal|"tty-status"
block|,
name|rl_tty_status
block|}
block|,
block|{
literal|"undo"
block|,
name|rl_undo_command
block|}
block|,
block|{
literal|"universal-argument"
block|,
name|rl_universal_argument
block|}
block|,
block|{
literal|"unix-line-discard"
block|,
name|rl_unix_line_discard
block|}
block|,
block|{
literal|"unix-word-rubout"
block|,
name|rl_unix_word_rubout
block|}
block|,
block|{
literal|"upcase-word"
block|,
name|rl_upcase_word
block|}
block|,
block|{
literal|"yank"
block|,
name|rl_yank
block|}
block|,
block|{
literal|"yank-last-arg"
block|,
name|rl_yank_last_arg
block|}
block|,
block|{
literal|"yank-nth-arg"
block|,
name|rl_yank_nth_arg
block|}
block|,
block|{
literal|"yank-pop"
block|,
name|rl_yank_pop
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
block|{
literal|"vi-append-eol"
block|,
name|rl_vi_append_eol
block|}
block|,
block|{
literal|"vi-append-mode"
block|,
name|rl_vi_append_mode
block|}
block|,
block|{
literal|"vi-arg-digit"
block|,
name|rl_vi_arg_digit
block|}
block|,
block|{
literal|"vi-bWord"
block|,
name|rl_vi_bWord
block|}
block|,
block|{
literal|"vi-bracktype"
block|,
name|rl_vi_bracktype
block|}
block|,
block|{
literal|"vi-bword"
block|,
name|rl_vi_bword
block|}
block|,
block|{
literal|"vi-change-case"
block|,
name|rl_vi_change_case
block|}
block|,
block|{
literal|"vi-change-char"
block|,
name|rl_vi_change_char
block|}
block|,
block|{
literal|"vi-change-to"
block|,
name|rl_vi_change_to
block|}
block|,
block|{
literal|"vi-char-search"
block|,
name|rl_vi_char_search
block|}
block|,
block|{
literal|"vi-column"
block|,
name|rl_vi_column
block|}
block|,
block|{
literal|"vi-comment"
block|,
name|rl_vi_comment
block|}
block|,
block|{
literal|"vi-complete"
block|,
name|rl_vi_complete
block|}
block|,
block|{
literal|"vi-delete"
block|,
name|rl_vi_delete
block|}
block|,
block|{
literal|"vi-delete-to"
block|,
name|rl_vi_delete_to
block|}
block|,
block|{
literal|"vi-eWord"
block|,
name|rl_vi_eWord
block|}
block|,
block|{
literal|"vi-editing-mode"
block|,
name|rl_vi_editing_mode
block|}
block|,
block|{
literal|"vi-end-word"
block|,
name|rl_vi_end_word
block|}
block|,
block|{
literal|"vi-eof-maybe"
block|,
name|rl_vi_eof_maybe
block|}
block|,
block|{
literal|"vi-eword"
block|,
name|rl_vi_eword
block|}
block|,
block|{
literal|"vi-fWord"
block|,
name|rl_vi_fWord
block|}
block|,
block|{
literal|"vi-first-print"
block|,
name|rl_vi_first_print
block|}
block|,
block|{
literal|"vi-fword"
block|,
name|rl_vi_fword
block|}
block|,
block|{
literal|"vi-insert-beg"
block|,
name|rl_vi_insert_beg
block|}
block|,
block|{
literal|"vi-insertion-mode"
block|,
name|rl_vi_insertion_mode
block|}
block|,
block|{
literal|"vi-match"
block|,
name|rl_vi_match
block|}
block|,
block|{
literal|"vi-movement-mode"
block|,
name|rl_vi_movement_mode
block|}
block|,
block|{
literal|"vi-next-word"
block|,
name|rl_vi_next_word
block|}
block|,
block|{
literal|"vi-overstrike"
block|,
name|rl_vi_overstrike
block|}
block|,
block|{
literal|"vi-overstrike-delete"
block|,
name|rl_vi_overstrike_delete
block|}
block|,
block|{
literal|"vi-prev-word"
block|,
name|rl_vi_prev_word
block|}
block|,
block|{
literal|"vi-put"
block|,
name|rl_vi_put
block|}
block|,
block|{
literal|"vi-redo"
block|,
name|rl_vi_redo
block|}
block|,
block|{
literal|"vi-replace"
block|,
name|rl_vi_replace
block|}
block|,
block|{
literal|"vi-search"
block|,
name|rl_vi_search
block|}
block|,
block|{
literal|"vi-search-again"
block|,
name|rl_vi_search_again
block|}
block|,
block|{
literal|"vi-subst"
block|,
name|rl_vi_subst
block|}
block|,
block|{
literal|"vi-tilde-expand"
block|,
name|rl_vi_tilde_expand
block|}
block|,
block|{
literal|"vi-yank-arg"
block|,
name|rl_vi_yank_arg
block|}
block|,
block|{
literal|"vi-yank-to"
block|,
name|rl_vi_yank_to
block|}
block|,
endif|#
directive|endif
comment|/* VI_MODE */
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|Function
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|rl_add_funmap_entry
argument_list|(
argument|name
argument_list|,
argument|function
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|funmap_entry
operator|+
literal|2
operator|>=
name|funmap_size
condition|)
if|if
condition|(
operator|!
name|funmap
condition|)
name|funmap
operator|=
operator|(
name|FUNMAP
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|funmap_size
operator|=
literal|80
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FUNMAP
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|funmap
operator|=
operator|(
name|FUNMAP
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|funmap
argument_list|,
operator|(
name|funmap_size
operator|+=
literal|80
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FUNMAP
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|funmap
index|[
name|funmap_entry
index|]
operator|=
operator|(
name|FUNMAP
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FUNMAP
argument_list|)
argument_list|)
expr_stmt|;
name|funmap
index|[
name|funmap_entry
index|]
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|funmap
index|[
name|funmap_entry
index|]
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|funmap
index|[
operator|++
name|funmap_entry
index|]
operator|=
operator|(
name|FUNMAP
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|funmap_entry
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|funmap_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make the funmap contain all of the default entries. */
end_comment

begin_function
name|void
name|rl_initialize_funmap
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|funmap_initialized
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|default_funmap
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|rl_add_funmap_entry
argument_list|(
name|default_funmap
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|default_funmap
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|funmap_initialized
operator|=
literal|1
expr_stmt|;
name|funmap_program_specific_entry_start
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce a NULL terminated array of known function names.  The array    is sorted.  The array itself is allocated, but not the strings inside.    You should free () the array when you done, but not the pointrs. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|rl_funmap_names
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|result_size
decl_stmt|,
name|result_index
decl_stmt|;
name|result_size
operator|=
name|result_index
operator|=
literal|0
expr_stmt|;
comment|/* Make sure that the function map has been initialized. */
name|rl_initialize_funmap
argument_list|()
expr_stmt|;
for|for
control|(
name|result_index
operator|=
literal|0
init|;
name|funmap
index|[
name|result_index
index|]
condition|;
name|result_index
operator|++
control|)
block|{
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>
name|result_size
condition|)
block|{
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|result_size
operator|=
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|result_size
operator|+=
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
index|]
operator|=
name|funmap
index|[
name|result_index
index|]
operator|->
name|name
expr_stmt|;
name|result
index|[
name|result_index
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|qsort
argument_list|(
name|result
argument_list|,
name|result_index
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|qsort_string_compare
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stupid comparison routine for qsort () ing strings. */
end_comment

begin_function
specifier|static
name|int
name|qsort_string_compare
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|*
operator|*
name|s1
operator|-
operator|*
operator|*
name|s2
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/* Things that mean `Control'. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|possible_control_prefixes
index|[]
init|=
block|{
literal|"Control-"
block|,
literal|"C-"
block|,
literal|"CTRL-"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|possible_meta_prefixes
index|[]
init|=
block|{
literal|"Meta"
block|,
literal|"M-"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

end_unit

