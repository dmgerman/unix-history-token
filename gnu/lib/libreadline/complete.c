begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* complete.c -- filename completion for readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_SYS_FILE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_SYS_FILE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_GETPW_DECLS
argument_list|)
end_if

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !HAVE_GETPW_DECLS */
end_comment

begin_comment
comment|/* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|isc386
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* isc386&& _POSIX_SOURCE */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_comment
comment|/* Possible values for do_replace in rl_complete_internal. */
end_comment

begin_define
define|#
directive|define
name|NO_MATCH
value|0
end_define

begin_define
define|#
directive|define
name|SINGLE_MATCH
value|1
end_define

begin_define
define|#
directive|define
name|MULT_MATCH
value|2
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rl_copy_text
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Function
modifier|*
name|rl_last_func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_editing_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screenwidth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined and used in this file. */
end_comment

begin_function_decl
name|char
modifier|*
name|filename_completion_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|completion_matches
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_strings
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|rl_strpbrk
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing on a directory name.  The function is called with    the address of a string (the current directory name) as an arg. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_directory_completion_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means readline completion functions perform tilde expansion. */
end_comment

begin_decl_stmt
name|int
name|rl_complete_with_tilde_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, non-unique completions always show the list of matches. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_show_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|X_OK
argument_list|)
end_if

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|stat_char
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero means add an additional character to each filename displayed    during listing completion iff rl_filename_completion_desired which helps    to indicate the type of file being listed. */
end_comment

begin_decl_stmt
name|int
name|rl_visible_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	Completion matching, from readline's point of view.	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Pointer to the generator function for completion_matches ().    NULL means to use filename_entry_function (), the default filename    completer. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_completion_entry_function
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to alternative function to create matches.    Function is called with TEXT, START, and END.    START and END are indices in RL_LINE_BUFFER saying what the boundaries    of TEXT are.    If this function exists and returns NULL then call the value of    rl_completion_entry_function to try to match, otherwise use the    array of strings returned. */
end_comment

begin_decl_stmt
name|CPPFunction
modifier|*
name|rl_attempted_completion_function
init|=
operator|(
name|CPPFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to suppress normal filename completion after the    user-specified completion function has been called. */
end_comment

begin_decl_stmt
name|int
name|rl_attempted_completion_over
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variable states what happened during the last completion attempt. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|completion_changed_buffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complete the word at or before point.  You have supplied the function    that does the initial simple matching selection algorithm (see    completion_matches ()).  The default is to do filename completion. */
end_comment

begin_macro
name|rl_complete
argument_list|(
argument|ignore
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|rl_last_func
operator|==
name|rl_complete
operator|&&
operator|!
name|completion_changed_buffer
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_all
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'!'
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* List the possible completions.  See description of rl_complete (). */
end_comment

begin_macro
name|rl_possible_completions
argument_list|(
argument|ignore
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rl_insert_completions
argument_list|(
argument|ignore
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* The user must press "y" or "n". Non-zero return means "y" pressed. */
end_comment

begin_macro
name|get_y_or_n
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|' '
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
literal|'N'
operator|||
name|c
operator|==
name|RUBOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|ABORT_CHAR
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Up to this many items will be displayed in response to a    possible-completions call.  After that, we ask the user if    she is sure she wants to see them all. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_query_items
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic list of characters that signal a break between words for the    completer routine.  The contents of this variable is what breaks words    in the shell, i.e. " \t\n\"\\'`@$><=" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_basic_word_break_characters
init|=
literal|" \t\n\"\\'`@$><=;|&{("
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters that signal a break between words for    rl_complete_internal.  The default list is the contents of    rl_basic_word_break_characters.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_completer_word_break_characters
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters which can be used to quote a substring of the line.    Completion occurs on the entire substring, and within the substring    rl_completer_word_break_characters are treated as any other character,    unless they also appear within this list. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_completer_quote_characters
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that are word break characters, but should be left    in TEXT when it is passed to the completion function.  The shell uses    this to help determine what kind of completing to do. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_special_prefixes
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then disallow duplicates in the matches. */
end_comment

begin_decl_stmt
name|int
name|rl_ignore_completion_duplicates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be treated    as filenames.  This is ALWAYS zero on entry, and can only be changed    within a completion entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_completion_desired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be quoted using    double quotes (or an application-specific quoting mechanism) if the    filename contains any characters in rl_word_break_chars.  This is    ALWAYS non-zero on entry, and can only be changed within a completion    entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_quoting_desired
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function, if defined, is called by the completer when real    filename completion is done, after all the matching names have been    generated. It is passed a (char**) known as matches in the code below.    It consists of a NULL-terminated array of pointers to potential    matching strings.  The 1st element (matches[0]) is the maximal    substring that is common to all matches. This function can re-arrange    the list of matches as required, but all elements of the array must be    free()'d if they are deleted. The main intent of this function is    to implement FIGNORE a la SunOS csh. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_ignore_some_completions_function
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_comment
comment|/* A function to strip quotes that are not protected by backquotes.  It    allows single quotes to appear within double quotes, and vice versa.    It should be smarter.  It's fairly shell-specific, hence the SHELL    definition wrapper. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_delete_quotes
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|l
decl_stmt|,
name|quoted
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|quoted
operator|=
literal|0
operator|,
name|p
operator|=
name|text
operator|,
name|r
operator|=
name|ret
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
comment|/* Allow backslash-quoted characters to pass through unscathed. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
continue|continue;
comment|/* Close quote. */
if|if
condition|(
name|quoted
operator|&&
operator|*
name|p
operator|==
name|quoted
condition|)
block|{
name|quoted
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Open quote. */
if|if
condition|(
name|quoted
operator|==
literal|0
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
condition|)
block|{
name|quoted
operator|=
operator|*
name|p
expr_stmt|;
continue|continue;
block|}
operator|*
name|r
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHELL */
end_comment

begin_comment
comment|/* Return the portion of PATHNAME that should be output when listing    possible completions.  If we are hacking filename completion, we    are only interested in the basename, the portion following the    final slash.  Otherwise, we return what we were passed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable_part
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
name|temp
operator|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
return|return
operator|(
name|pathname
operator|)
return|;
else|else
return|return
operator|(
operator|++
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we    are using it, check for and output a single character for `special'    filenames.  Return 1 if we printed an extension character, 0 if not. */
end_comment

begin_function
specifier|static
name|int
name|print_filename
parameter_list|(
name|to_print
parameter_list|,
name|full_pathname
parameter_list|)
name|char
modifier|*
name|to_print
decl_stmt|,
decl|*
name|full_pathname
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
name|fputs
argument_list|(
name|to_print
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|new_full_pathname
decl_stmt|;
name|int
name|extension_char
init|=
literal|0
decl_stmt|,
name|slen
decl_stmt|,
name|tlen
decl_stmt|;
name|fputs
argument_list|(
name|to_print
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
name|rl_visible_stats
condition|)
block|{
comment|/* If to_print != full_pathname, to_print is the basename of the 	 path passed.  In this case, we try to expand the directory 	 name before checking for the stat character. */
if|if
condition|(
name|to_print
operator|!=
name|full_pathname
condition|)
block|{
comment|/* Terminate the directory name. */
name|c
operator|=
name|to_print
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|to_print
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|tilde_expand
argument_list|(
name|full_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_directory_completion_hook
condition|)
call|(
modifier|*
name|rl_directory_completion_hook
call|)
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|strlen
argument_list|(
name|to_print
argument_list|)
expr_stmt|;
name|new_full_pathname
operator|=
name|xmalloc
argument_list|(
name|slen
operator|+
name|tlen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_full_pathname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|new_full_pathname
index|[
name|slen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|new_full_pathname
operator|+
name|slen
operator|+
literal|1
argument_list|,
name|to_print
argument_list|)
expr_stmt|;
name|extension_char
operator|=
name|stat_char
argument_list|(
name|new_full_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_full_pathname
argument_list|)
expr_stmt|;
name|to_print
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|tilde_expand
argument_list|(
name|full_pathname
argument_list|)
expr_stmt|;
name|extension_char
operator|=
name|stat_char
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension_char
condition|)
name|putc
argument_list|(
name|extension_char
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
return|return
operator|(
name|extension_char
operator|!=
literal|0
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* VISIBLE_STATS */
block|}
end_block

begin_comment
comment|/* Complete the word at or before point.    WHAT_TO_DO says what to do with the completion.    `?' means list the possible completions.    TAB means do standard completion.    `*' means insert all of the possible completions.    `!' means to do standard completion, and list all possible completions if    there is more than one. */
end_comment

begin_macro
name|rl_complete_internal
argument_list|(
argument|what_to_do
argument_list|)
end_macro

begin_decl_stmt
name|int
name|what_to_do
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|Function
modifier|*
name|our_func
decl_stmt|;
name|int
name|start
decl_stmt|,
name|scan
decl_stmt|,
name|end
decl_stmt|,
name|delimiter
init|=
literal|0
decl_stmt|,
name|pass_next
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|,
modifier|*
name|saved_line_buffer
decl_stmt|;
name|char
modifier|*
name|replacement
decl_stmt|;
name|char
name|quote_char
init|=
literal|'\0'
decl_stmt|;
name|int
name|found_quote
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rl_line_buffer
condition|)
name|saved_line_buffer
operator|=
name|savestring
argument_list|(
name|rl_line_buffer
argument_list|)
expr_stmt|;
else|else
name|saved_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|rl_completion_entry_function
condition|)
name|our_func
operator|=
name|rl_completion_entry_function
expr_stmt|;
else|else
name|our_func
operator|=
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
expr_stmt|;
comment|/* Only the completion entry function can change these. */
name|rl_filename_completion_desired
operator|=
literal|0
expr_stmt|;
name|rl_filename_quoting_desired
operator|=
literal|1
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word. */
name|end
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
block|{
if|if
condition|(
name|rl_completer_quote_characters
condition|)
block|{
comment|/* We have a list of characters which can be used in pairs to 	     quote substrings for the completer.  Try to find the start 	     of an unclosed quoted substring. */
comment|/* FOUND_QUOTE is set so we know what kind of quotes we found. */
for|for
control|(
name|scan
operator|=
name|pass_next
operator|=
literal|0
init|;
name|scan
operator|<
name|end
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|pass_next
condition|)
block|{
name|pass_next
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rl_line_buffer
index|[
name|scan
index|]
operator|==
literal|'\\'
condition|)
block|{
name|pass_next
operator|=
literal|1
expr_stmt|;
name|found_quote
operator||=
literal|4
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char. */
if|if
condition|(
name|rl_line_buffer
index|[
name|scan
index|]
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close.  Abandon this substring. */
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_quote_characters
argument_list|,
name|rl_line_buffer
index|[
name|scan
index|]
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted substring. */
name|quote_char
operator|=
name|rl_line_buffer
index|[
name|scan
index|]
expr_stmt|;
name|rl_point
operator|=
name|scan
operator|+
literal|1
expr_stmt|;
comment|/* Shell-like quoting conventions. */
if|if
condition|(
name|quote_char
operator|==
literal|'\''
condition|)
name|found_quote
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_char
operator|==
literal|'"'
condition|)
name|found_quote
operator||=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|end
condition|)
block|{
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* We didn't find an unclosed quoted substring upon which to do 	     completion, so use the word break characters to find the 	     substring on which to complete. */
while|while
condition|(
operator|--
name|rl_point
condition|)
block|{
name|scan
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|scan
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* Don't let word break characters in quoted substrings break 		 words for the completer. */
if|if
condition|(
name|found_quote
operator|&&
name|char_is_quoted
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* SHELL */
comment|/* Convoluted code, but it avoids an n^2 algorithm with calls 	      	 to char_is_quoted. */
break|break;
block|}
block|}
comment|/* If we are at an unquoted word break, then advance past it. */
name|scan
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
if|if
condition|(
operator|(
name|found_quote
operator|==
literal|0
operator|||
name|char_is_quoted
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|scan
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|scan
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* If the character that caused the word break was a quoting 	     character, then remember it as the delimiter. */
if|if
condition|(
name|strchr
argument_list|(
literal|"\"'"
argument_list|,
name|scan
argument_list|)
operator|&&
operator|(
name|end
operator|-
name|rl_point
operator|)
operator|>
literal|1
condition|)
name|delimiter
operator|=
name|scan
expr_stmt|;
comment|/* If the character isn't needed to determine something special 	     about what kind of completion to perform, then advance past it. */
if|if
condition|(
operator|!
name|rl_special_prefixes
operator|||
name|strchr
argument_list|(
name|rl_special_prefixes
argument_list|,
name|scan
argument_list|)
operator|==
literal|0
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
comment|/* At this point, we know we have an open quote if quote_char != '\0'. */
name|start
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
name|text
operator|=
name|rl_copy_text
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* If the user wants to TRY to complete, but then wants to give      up and use the default completion function, they set the      variable rl_attempted_completion_function. */
if|if
condition|(
name|rl_attempted_completion_function
condition|)
block|{
name|matches
operator|=
call|(
modifier|*
name|rl_attempted_completion_function
call|)
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|||
name|rl_attempted_completion_over
condition|)
block|{
name|rl_attempted_completion_over
operator|=
literal|0
expr_stmt|;
name|our_func
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
goto|goto
name|after_usual_completion
goto|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* Beware -- we're stripping the quotes here.  Do this only if we know      we are doing filename completion. */
if|if
condition|(
name|found_quote
operator|&&
name|our_func
operator|==
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
condition|)
block|{
comment|/* delete single and double quotes */
name|replacement
operator|=
name|_delete_quotes
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|=
name|replacement
expr_stmt|;
name|replacement
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SHELL */
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
name|our_func
argument_list|)
expr_stmt|;
name|after_usual_completion
label|:
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|should_quote
decl_stmt|;
comment|/* It seems to me that in all the cases we handle we would like 	 to ignore duplicate possiblilities.  Scan for the text to 	 insert being identical to the other completions. */
if|if
condition|(
name|rl_ignore_completion_duplicates
condition|)
block|{
name|char
modifier|*
name|lowest_common
decl_stmt|;
name|int
name|j
decl_stmt|,
name|newlen
init|=
literal|0
decl_stmt|;
name|char
name|dead_slot
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp_array
decl_stmt|;
comment|/* Sort the items. */
comment|/* It is safe to sort this array, because the lowest common 	     denominator found in matches[0] will remain in place. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Try sorting the array without matches[0], since we need it to 	     stay in place no matter what. */
if|if
condition|(
name|i
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_strings
argument_list|)
expr_stmt|;
comment|/* Remember the lowest common denominator for it may be unique. */
name|lowest_common
operator|=
name|savestring
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
name|matches
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|matches
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
expr_stmt|;
block|}
else|else
name|newlen
operator|++
expr_stmt|;
block|}
comment|/* We have marked all the dead slots with (char *)&dead_slot. 	     Copy all the non-dead entries into a new array. */
name|temp_array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|3
operator|+
name|newlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
condition|)
name|temp_array
index|[
name|j
operator|++
index|]
operator|=
name|matches
index|[
name|i
index|]
expr_stmt|;
block|}
name|temp_array
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
condition|)
name|free
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
name|temp_array
expr_stmt|;
comment|/* Place the lowest common denominator back in [0]. */
name|matches
index|[
literal|0
index|]
operator|=
name|lowest_common
expr_stmt|;
comment|/* If there is one string left, and it is identical to the 	     lowest common denominator, then the LCD is the string to 	     insert. */
if|if
condition|(
name|j
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|matches
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matches
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|matches
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|what_to_do
condition|)
block|{
case|case
name|TAB
case|:
case|case
literal|'!'
case|:
comment|/* If we are matching filenames, then here is our chance to 	     do clever processing by re-examining the list.  Call the 	     ignore function with the array as a parameter.  It can 	     munge the array, deleting matches as it desires. */
if|if
condition|(
name|rl_ignore_some_completions_function
operator|&&
name|our_func
operator|==
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|rl_ignore_some_completions_function
argument_list|)
argument_list|(
name|matches
argument_list|)
expr_stmt|;
comment|/* If we are doing completion on quoted substrings, and any matches 	     contain any of the completer_word_break_characters, then auto- 	     matically prepend the substring with a quote character (just pick 	     the first one from the list of such) if it does not already begin 	     with a quote string.  FIXME: Need to remove any such automatically 	     inserted quote character when it no longer is necessary, such as 	     if we change the string we are completing on and the new set of 	     matches don't require a quoted substring. */
name|replacement
operator|=
name|matches
index|[
literal|0
index|]
expr_stmt|;
name|should_quote
operator|=
name|matches
index|[
literal|0
index|]
operator|&&
name|rl_completer_quote_characters
operator|&&
name|rl_filename_completion_desired
operator|&&
name|rl_filename_quoting_desired
expr_stmt|;
if|if
condition|(
name|should_quote
condition|)
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
name|should_quote
operator|=
name|should_quote
operator|&&
operator|(
operator|!
name|quote_char
operator|||
name|quote_char
operator|==
literal|'"'
operator|)
expr_stmt|;
else|#
directive|else
name|should_quote
operator|=
name|should_quote
operator|&&
operator|!
name|quote_char
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|should_quote
condition|)
block|{
name|int
name|do_replace
decl_stmt|;
name|do_replace
operator|=
name|NO_MATCH
expr_stmt|;
comment|/* If there is a single match, see if we need to quote it. 		 This also checks whether the common prefix of several 		 matches needs to be quoted.  If the common prefix should 		 not be checked, add !matches[1] to the if clause. */
name|should_quote
operator|=
name|rl_strpbrk
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|rl_completer_word_break_characters
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
name|should_quote
operator|=
name|should_quote
operator|||
name|rl_strpbrk
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
literal|"#$`"
argument_list|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|should_quote
condition|)
name|do_replace
operator|=
name|matches
index|[
literal|1
index|]
condition|?
name|MULT_MATCH
else|:
name|SINGLE_MATCH
expr_stmt|;
if|if
condition|(
name|do_replace
operator|!=
name|NO_MATCH
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* Quote the replacement, since we found an 		     embedded word break character in a potential 		     match. */
name|char
modifier|*
name|rtext
decl_stmt|,
modifier|*
name|mtext
decl_stmt|;
name|int
name|rlen
decl_stmt|;
specifier|extern
name|char
modifier|*
name|double_quote
parameter_list|()
function_decl|;
comment|/* in builtins/common.c */
comment|/* If DO_REPLACE == MULT_MATCH, it means that there is 		     more than one match.  In this case, we do not add 		     the closing quote or attempt to perform tilde 		     expansion.  If DO_REPLACE == SINGLE_MATCH, we try 		     to perform tilde expansion, because double quotes 		     inhibit tilde expansion by the shell. */
name|mtext
operator|=
name|matches
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mtext
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|do_replace
operator|==
name|SINGLE_MATCH
condition|)
name|mtext
operator|=
name|tilde_expand
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rtext
operator|=
name|double_quote
argument_list|(
name|mtext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtext
operator|!=
name|matches
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|mtext
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|strlen
argument_list|(
name|rtext
argument_list|)
expr_stmt|;
name|replacement
operator|=
name|xmalloc
argument_list|(
name|rlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If we're completing on a quoted string where the user 		     has already supplied the opening quote, we don't want 		     the quote in the replacement text, and we reset 		     QUOTE_CHAR to 0 to avoid an extra closing quote. */
if|if
condition|(
name|quote_char
operator|==
literal|'"'
condition|)
block|{
name|strcpy
argument_list|(
name|replacement
argument_list|,
name|rtext
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rlen
operator|--
expr_stmt|;
name|quote_char
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|replacement
argument_list|,
name|rtext
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_replace
operator|==
name|MULT_MATCH
condition|)
name|replacement
index|[
name|rlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|rtext
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SHELL */
comment|/* Found an embedded word break character in a potential 		     match, so we need to prepend a quote character if we 		     are replacing the completion string. */
name|replacement
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|quote_char
operator|=
operator|*
name|rl_completer_quote_characters
expr_stmt|;
operator|*
name|replacement
operator|=
name|quote_char
expr_stmt|;
name|strcpy
argument_list|(
name|replacement
operator|+
literal|1
argument_list|,
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHELL */
block|}
block|}
if|if
condition|(
name|replacement
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
name|rl_insert_text
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|replacement
operator|!=
name|matches
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
comment|/* If there are more matches, ring the bell to indicate. 	     If this was the only match, and we are hacking files, 	     check the file to see if it was a directory.  If so, 	     add a '/' to the name.  If not, and we are at the end 	     of the line, then add a space. */
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|what_to_do
operator|==
literal|'!'
condition|)
goto|goto
name|display_matches
goto|;
comment|/* XXX */
elseif|else
if|if
condition|(
name|rl_editing_mode
operator|!=
name|vi_mode
condition|)
name|ding
argument_list|()
expr_stmt|;
comment|/* There are other matches remaining. */
block|}
else|else
block|{
name|char
name|temp_string
index|[
literal|4
index|]
decl_stmt|;
name|int
name|temp_string_index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|quote_char
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|quote_char
expr_stmt|;
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|delimiter
condition|?
name|delimiter
else|:
literal|' '
expr_stmt|;
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|tilde_expand
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|'/'
condition|)
name|rl_insert_text
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'*'
case|:
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
while|while
condition|(
name|matches
index|[
name|i
index|]
condition|)
block|{
name|rl_insert_text
argument_list|(
name|matches
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_insert_text
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
block|{
name|int
name|len
decl_stmt|,
name|count
decl_stmt|,
name|limit
decl_stmt|,
name|max
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
comment|/* Handle simple case first.  What if there is only one answer? */
if|if
condition|(
operator|!
name|matches
index|[
literal|1
index|]
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* There is more than one answer.  Find out how many there are, 	       and find out what the maximum printed length of a single entry 	       is. */
name|display_matches
label|:
for|for
control|(
name|max
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|name_length
decl_stmt|;
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|max
condition|)
name|max
operator|=
name|name_length
expr_stmt|;
block|}
name|len
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* If there are many items, then ask the user if she 	       really wants to see them all. */
if|if
condition|(
name|len
operator|>=
name|rl_completion_query_items
condition|)
block|{
name|crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"There are %d possibilities.  Do you really"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"wish to see them all? (y or n)"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_y_or_n
argument_list|()
condition|)
block|{
name|crlf
argument_list|()
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
comment|/* How many items of MAX length can we fit in the screen window? */
name|max
operator|+=
literal|2
expr_stmt|;
name|limit
operator|=
name|screenwidth
operator|/
name|max
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|1
operator|&&
operator|(
name|limit
operator|*
name|max
operator|==
name|screenwidth
operator|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Avoid a possible floating exception.  If max> screenwidth, 	       limit will be 0 and a divide-by-zero fault will result. */
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
literal|1
expr_stmt|;
comment|/* How many iterations of the printing loop? */
name|count
operator|=
operator|(
name|len
operator|+
operator|(
name|limit
operator|-
literal|1
operator|)
operator|)
operator|/
name|limit
expr_stmt|;
comment|/* Watch out for special case.  If LEN is less than LIMIT, then 	       just do the inner printing loop. 	       0< len<= limit  implies  count = 1. */
comment|/* Sort the items if they are not already sorted. */
if|if
condition|(
operator|!
name|rl_ignore_completion_duplicates
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_strings
argument_list|)
expr_stmt|;
comment|/* Print the sorted items, up-and-down alphabetically, like 	       ls might. */
name|crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|i
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|>
name|len
operator|||
operator|!
name|matches
index|[
name|l
index|]
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|printed_length
decl_stmt|;
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
name|printed_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|printed_length
operator|+=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_length
condition|;
name|k
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
block|}
name|l
operator|+=
name|count
expr_stmt|;
block|}
name|crlf
argument_list|()
expr_stmt|;
block|}
name|restart
label|:
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nreadline: bad value for what_to_do in rl_complete\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see if the line has changed through all of this manipulation. */
if|if
condition|(
name|saved_line_buffer
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rl_line_buffer
argument_list|,
name|saved_line_buffer
argument_list|)
operator|!=
literal|0
condition|)
name|completion_changed_buffer
operator|=
literal|1
expr_stmt|;
else|else
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_comment
comment|/* Return the character which best describes FILENAME.      `@' for symbolic links      `/' for directories      `*' for executables      `=' for sockets */
end_comment

begin_function
specifier|static
name|int
name|stat_char
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|int
name|character
decl_stmt|,
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
name|r
operator|=
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|character
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'/'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISLNK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISSOCK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'='
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISSOCK */
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|character
operator|=
literal|'*'
expr_stmt|;
block|}
return|return
operator|(
name|character
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_comment
comment|/* Stupid comparison routine for qsort () ing strings. */
end_comment

begin_function
specifier|static
name|int
name|compare_strings
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|*
operator|*
name|s1
operator|-
operator|*
operator|*
name|s2
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* A completion function for usernames.    TEXT contains a partial username preceded by a random    character (usually `~').  */
end_comment

begin_function
name|char
modifier|*
name|username_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
else|#
directive|else
comment|/* !__GO32__ */
specifier|static
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|struct
name|passwd
modifier|*
name|entry
decl_stmt|;
specifier|static
name|int
name|namelen
decl_stmt|,
name|first_char
decl_stmt|,
name|first_char_loc
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
if|if
condition|(
name|username
condition|)
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|first_char
operator|=
operator|*
name|text
expr_stmt|;
if|if
condition|(
name|first_char
operator|==
literal|'~'
condition|)
name|first_char_loc
operator|=
literal|1
expr_stmt|;
else|else
name|first_char_loc
operator|=
literal|0
expr_stmt|;
name|username
operator|=
name|savestring
argument_list|(
operator|&
name|text
index|[
name|first_char_loc
index|]
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|entry
operator|=
name|getpwent
argument_list|()
condition|)
block|{
comment|/* Null usernames should result in all users as possible completions. */
if|if
condition|(
name|namelen
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|username
index|[
literal|0
index|]
operator|==
name|entry
operator|->
name|pw_name
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|username
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
init|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|pw_name
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|value
operator|=
operator|*
name|text
expr_stmt|;
name|strcpy
argument_list|(
name|value
operator|+
name|first_char_loc
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_char
operator|==
literal|'~'
condition|)
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			     Completion				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means that case is not significant in completion. */
end_comment

begin_decl_stmt
name|int
name|completion_case_fold
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an array of (char *) which is a list of completions for TEXT.    If there are no completions, return a NULL pointer.    The first entry in the returned array is the substitution for TEXT.    The remaining entries are the possible completions.    The array is terminated with a NULL pointer.     ENTRY_FUNCTION is a function of two args, and returns a (char *).      The first argument is TEXT.      The second is a state argument; it should be zero on the first call, and      non-zero on subsequent calls.  It returns a NULL pointer to the caller      when there are no more matches.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|completion_matches
parameter_list|(
name|text
parameter_list|,
name|entry_function
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|CPFunction
modifier|*
name|entry_function
decl_stmt|;
block|{
comment|/* Number of slots in match_list. */
name|int
name|match_list_size
decl_stmt|;
comment|/* The list of matches. */
name|char
modifier|*
modifier|*
name|match_list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|match_list_size
operator|=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Number of matches actually found. */
name|int
name|matches
init|=
literal|0
decl_stmt|;
comment|/* Temporary string binder. */
name|char
modifier|*
name|string
decl_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|string
operator|=
call|(
modifier|*
name|entry_function
call|)
argument_list|(
name|text
argument_list|,
name|matches
argument_list|)
condition|)
block|{
if|if
condition|(
name|matches
operator|+
literal|1
operator|==
name|match_list_size
condition|)
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|match_list
argument_list|,
operator|(
operator|(
name|match_list_size
operator|+=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
operator|++
name|matches
index|]
operator|=
name|string
expr_stmt|;
name|match_list
index|[
name|matches
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were any matches, then look through them finding out the      lowest common denominator.  That then becomes match_list[0]. */
if|if
condition|(
name|matches
condition|)
block|{
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|low
init|=
literal|100000
decl_stmt|;
comment|/* Count of max-matched characters. */
comment|/* If only one match, just use that. */
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|match_list
index|[
literal|0
index|]
operator|=
name|match_list
index|[
literal|1
index|]
expr_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, compare each member of the list with 	     the next, finding out where they stop matching. */
while|while
condition|(
name|i
operator|<
name|matches
condition|)
block|{
specifier|register
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|si
decl_stmt|;
if|if
condition|(
name|completion_case_fold
condition|)
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|to_lower
argument_list|(
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|c2
operator|=
name|to_lower
argument_list|(
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
argument_list|)
operator|)
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
else|else
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
operator|)
operator|&&
operator|(
name|c2
operator|=
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
operator|)
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
if|if
condition|(
name|low
operator|>
name|si
condition|)
name|low
operator|=
name|si
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|match_list
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
name|low
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|match_list
index|[
literal|1
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|match_list
index|[
literal|0
index|]
index|[
name|low
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
comment|/* There were no matches. */
block|{
name|free
argument_list|(
name|match_list
argument_list|)
expr_stmt|;
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|match_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Okay, now we write the entry_function for filename completion.  In the    general case.  Note that completion in the shell is a little different    because of all the pathnames that must be followed when looking up the    completion for a command. */
end_comment

begin_function
name|char
modifier|*
name|filename_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|static
name|DIR
modifier|*
name|directory
decl_stmt|;
specifier|static
name|char
modifier|*
name|filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|users_dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|filename_len
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entry
init|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If we don't have any state, then do some initialization. */
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|dirname
condition|)
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|users_dirname
condition|)
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|text
condition|)
name|text
operator|=
literal|"."
expr_stmt|;
name|dirname
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|dirname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
operator|++
name|temp
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|dirname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* We aren't done yet.  We also support the "~user" syntax. */
comment|/* Save the version of the directory that the user typed. */
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|temp_dirname
decl_stmt|;
name|int
name|replace_dirname
decl_stmt|;
name|temp_dirname
operator|=
name|tilde_expand
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|temp_dirname
expr_stmt|;
name|replace_dirname
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rl_directory_completion_hook
condition|)
name|replace_dirname
operator|=
call|(
modifier|*
name|rl_directory_completion_hook
call|)
argument_list|(
operator|&
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|replace_dirname
condition|)
block|{
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
block|}
name|directory
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|filename_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
block|}
comment|/* At this point we should entertain the possibility of hacking wildcarded      filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name      contains globbing characters, then build an array of directories, and      then map over that list while completing. */
comment|/* *** UNIMPLEMENTED *** */
comment|/* Now that we have some state, we can read the directory. */
while|while
condition|(
name|directory
operator|&&
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|directory
argument_list|)
operator|)
condition|)
block|{
comment|/* Special case for no filename. 	 All entries except "." and ".." match. */
if|if
condition|(
operator|!
name|filename_len
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Otherwise, if these match up to the length of filename, then 	     it is a match. */
if|if
condition|(
operator|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|filename
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
operator|)
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
if|if
condition|(
name|directory
condition|)
block|{
name|closedir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|directory
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dirname
condition|)
block|{
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filename
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|users_dirname
condition|)
block|{
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* dirname&& (strcmp (dirname, ".") != 0) */
if|if
condition|(
name|dirname
operator|&&
operator|(
name|dirname
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dirname
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|rl_complete_with_tilde_expansion
operator|&&
operator|*
name|users_dirname
operator|==
literal|'~'
condition|)
block|{
name|int
name|dirlen
init|=
name|strlen
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|dirlen
operator|+
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
comment|/* Canonicalization cuts off any final slash present.  We need 		 to add it back. */
if|if
condition|(
name|dirname
index|[
name|dirlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|temp
index|[
name|dirlen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|users_dirname
argument_list|)
operator|+
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|users_dirname
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|temp
argument_list|,
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
operator|(
name|savestring
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* A function for simple tilde expansion. */
end_comment

begin_function
name|int
name|rl_tilde_expand
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
name|start
operator|=
name|end
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|==
literal|'~'
condition|)
block|{
name|homedir
operator|=
name|tilde_expand
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
goto|goto
name|insert
goto|;
block|}
elseif|else
if|if
condition|(
name|rl_line_buffer
index|[
name|start
index|]
operator|!=
literal|'~'
condition|)
block|{
for|for
control|(
init|;
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|start
index|]
argument_list|)
operator|&&
name|start
operator|>=
literal|0
condition|;
name|start
operator|--
control|)
empty_stmt|;
name|start
operator|++
expr_stmt|;
block|}
name|end
operator|=
name|start
expr_stmt|;
do|do
block|{
name|end
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|end
index|]
argument_list|)
operator|&&
name|end
operator|<
name|rl_end
condition|)
do|;
if|if
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|end
index|]
argument_list|)
operator|||
name|end
operator|>=
name|rl_end
condition|)
name|end
operator|--
expr_stmt|;
comment|/* If the first character of the current word is a tilde, perform      tilde expansion and insert the result.  If not a tilde, do      nothing. */
if|if
condition|(
name|rl_line_buffer
index|[
name|start
index|]
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|rl_line_buffer
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|homedir
operator|=
name|tilde_expand
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|insert
label|:
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
name|rl_insert_text
argument_list|(
name|homedir
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the first occurrence in STRING1 of any character from STRING2.    Return a pointer to the character in STRING1. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rl_strpbrk
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
init|;
operator|*
name|string1
condition|;
name|string1
operator|++
control|)
block|{
for|for
control|(
name|scan
operator|=
name|string2
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|string1
operator|==
operator|*
name|scan
condition|)
block|{
return|return
operator|(
name|string1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

end_unit

