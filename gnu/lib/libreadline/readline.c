begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* readline.c -- a general facility for reading lines of input    with emacs style editing and completion. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_SYS_FILE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_SYS_FILE */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* This is needed to include support for TIOCGWINSZ and window resizing. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF1
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD386
argument_list|)
operator|||
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|FreeBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|_386BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|AIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSF1 || BSD386 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_comment
comment|/* NOTE: Functions and variables prefixed with `_rl_' are    pseudo-global: they are global so they can be shared    between files in the readline library, but are not intended    to be visible to readline callers. */
end_comment

begin_comment
comment|/* Functions imported from other files in the library. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
name|rl_prep_terminal
argument_list|()
decl_stmt|,
name|rl_deprep_terminal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_rl_bind_if_unbound
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* External redisplay functions and variables from display.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|_rl_move_vert
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_erase_at_end_of_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_move_cursor_relative
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|_rl_vis_botlin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_last_c_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_display_fixed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_display_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables imported from complete.c. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_completer_word_break_characters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_basic_word_break_characters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_query_items
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_complete_with_tilde_expansion
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_function_decl
specifier|extern
name|void
name|_rl_vi_set_last
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_vi_reset_last
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_vi_done_inserting
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

begin_comment
comment|/* Forward declarations used in this file. */
end_comment

begin_function_decl
name|void
name|_rl_free_history_entry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_rl_dispatch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_rl_set_screen_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_rl_output_character_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|readline_internal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readline_initialize_everything
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_terminal_io
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_using_history
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|readline_default_bindings
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GO32__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/pc.h>
end_include

begin_undef
undef|#
directive|undef
name|HANDLE_SIGNALS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GO32__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Line editing input utility		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|LibraryVersion
init|=
literal|"2.0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the keymap that is currently in use.    By default, it is the standard emacs keymap. */
end_comment

begin_decl_stmt
name|Keymap
name|_rl_keymap
init|=
name|emacs_standard_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current style of editing. */
end_comment

begin_decl_stmt
name|int
name|rl_editing_mode
init|=
name|emacs_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous command was a kill command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_command_was_kill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current value of the numeric argument specified by the user. */
end_comment

begin_decl_stmt
name|int
name|rl_numeric_arg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if an argument was typed. */
end_comment

begin_decl_stmt
name|int
name|rl_explicit_arg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary value used while generating the argument. */
end_comment

begin_decl_stmt
name|int
name|rl_arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means we have been called at least once before. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this program is running in an EMACS buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|running_in_emacs
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current offset in the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark in the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_mark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make this non-zero to return the current input_line. */
end_comment

begin_decl_stmt
name|int
name|rl_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last function executed by readline. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_last_func
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top level environment for readline_internal (). */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|readline_top_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The streams we interact with. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|in_stream
decl_stmt|,
modifier|*
name|out_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names of the streams that we do input and output to. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|rl_instream
init|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rl_outstream
init|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means echo characters as they are read. */
end_comment

begin_decl_stmt
name|int
name|readline_echoing_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_visible_prompt_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters read in order to type this complete command. */
end_comment

begin_decl_stmt
name|int
name|rl_key_sequence_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then this is the address of a function to call just    before readline_internal () prints the first prompt. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_startup_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we use internally.  You should always refer to RL_LINE_BUFFER. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that can generate an EOF.  Really read from    the terminal driver... just defaulted here. */
end_comment

begin_decl_stmt
name|int
name|_rl_eof_char
init|=
name|CTRL
argument_list|(
literal|'D'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero makes this the next keystroke to read. */
end_comment

begin_decl_stmt
name|int
name|rl_pending_input
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a useful terminal name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_terminal_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to always use horizontal scrolling in line display. */
end_comment

begin_decl_stmt
name|int
name|_rl_horizontal_scroll_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to display an asterisk at the starts of history lines    which have been modified. */
end_comment

begin_decl_stmt
name|int
name|_rl_mark_modified_lines
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The style of `bell' notification preferred.  This can be set to NO_BELL,    AUDIBLE_BELL, or VISIBLE_BELL. */
end_comment

begin_decl_stmt
name|int
name|_rl_bell_preference
init|=
name|AUDIBLE_BELL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line buffer and maintenence. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_line_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_line_buffer_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_BUFFER_SIZE
value|256
end_define

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			`Forward' declarations  		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means do not parse any lines other than comments and    parser directives. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|_rl_parsing_conditionalized_out
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to save keys that we dispatch on in a kbd macro. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defining_kbd_macro
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to convert characters with the meta bit set to    escape-prefixed characters so we can indirect through    emacs_meta_keymap or vi_escape_keymap. */
end_comment

begin_decl_stmt
name|int
name|_rl_convert_meta_chars_to_ascii
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to output characters with the meta bit set directly    rather than as a meta-prefixed escape sequence. */
end_comment

begin_decl_stmt
name|int
name|_rl_output_meta_chars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero tells rl_delete_text and rl_insert_text to not add to    the undo list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|doing_an_undo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Top Level Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means treat 0200 bit in terminal input as Meta bit. */
end_comment

begin_decl_stmt
name|int
name|_rl_meta_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means    none.  A return value of NULL means that EOF was encountered. */
end_comment

begin_function
name|char
modifier|*
name|readline
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|rl_prompt
operator|=
name|prompt
expr_stmt|;
comment|/* If we are at EOF return a NULL string. */
if|if
condition|(
name|rl_pending_input
operator|==
name|EOF
condition|)
block|{
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|rl_visible_prompt_length
operator|=
name|rl_expand_prompt
argument_list|(
name|rl_prompt
argument_list|)
expr_stmt|;
name|rl_initialize
argument_list|()
expr_stmt|;
name|rl_prep_terminal
argument_list|(
name|_rl_meta_flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_set_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|readline_internal
argument_list|()
expr_stmt|;
name|rl_deprep_terminal
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_clear_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a line of input from the global rl_instream, doing output on    the global rl_outstream.    If rl_prompt is non-null, then that is our prompt. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readline_internal
parameter_list|()
block|{
name|int
name|lastc
decl_stmt|,
name|c
decl_stmt|,
name|eof_found
decl_stmt|;
name|in_stream
operator|=
name|rl_instream
expr_stmt|;
name|out_stream
operator|=
name|rl_outstream
expr_stmt|;
name|lastc
operator|=
operator|-
literal|1
expr_stmt|;
name|eof_found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rl_startup_hook
condition|)
call|(
modifier|*
name|rl_startup_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
block|{
if|if
condition|(
name|rl_prompt
condition|)
block|{
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"%s"
argument_list|,
name|rl_prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
while|while
condition|(
operator|!
name|rl_done
condition|)
block|{
name|int
name|lk
init|=
name|last_command_was_kill
decl_stmt|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|setjmp
argument_list|(
name|readline_top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
name|rl_redisplay
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rl_pending_input
condition|)
block|{
comment|/* Then initialize the argument and number of keys read. */
name|rl_init_argument
argument_list|()
expr_stmt|;
name|rl_key_sequence_length
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* EOF typed to a non-blank line is a<NL>. */
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|rl_end
condition|)
name|c
operator|=
name|NEWLINE
expr_stmt|;
comment|/* The character _rl_eof_char typed to blank line, and not as the 	 previous character is interpreted as EOF. */
if|if
condition|(
operator|(
operator|(
name|c
operator|==
name|_rl_eof_char
operator|&&
name|lastc
operator|!=
name|c
operator|)
operator|||
name|c
operator|==
name|EOF
operator|)
operator|&&
operator|!
name|rl_end
condition|)
block|{
name|eof_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|lastc
operator|=
name|c
expr_stmt|;
name|_rl_dispatch
argument_list|(
name|c
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
comment|/* If there was no change in last_command_was_kill, then no kill 	 has taken place.  Note that if input is pending we are reading 	 a prefix command, so nothing has changed yet. */
if|if
condition|(
operator|!
name|rl_pending_input
condition|)
block|{
if|if
condition|(
name|lk
operator|==
name|last_command_was_kill
condition|)
name|last_command_was_kill
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
comment|/* In vi mode, when you exit insert mode, the cursor moves back 	 over the previous character.  We explicitly check for that here. */
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|&&
name|_rl_keymap
operator|==
name|vi_movement_keymap
condition|)
name|rl_vi_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
if|if
condition|(
operator|!
name|rl_done
condition|)
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
comment|/* Restore the original of this history line, iff the line that we      are editing was originally in the history, AND the line has changed. */
block|{
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|current_history
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|&&
name|rl_undo_list
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|savestring
argument_list|(
name|the_line
argument_list|)
decl_stmt|;
name|rl_revert_line
argument_list|()
expr_stmt|;
name|entry
operator|=
name|replace_history_entry
argument_list|(
name|where_history
argument_list|()
argument_list|,
name|the_line
argument_list|,
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|_rl_free_history_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At any rate, it is highly likely that this line has an undo list.  Get      rid of it now. */
if|if
condition|(
name|rl_undo_list
condition|)
name|free_undo_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|eof_found
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
else|else
return|return
operator|(
name|savestring
argument_list|(
name|the_line
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Character Input Buffering       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pop_index
init|=
literal|0
decl_stmt|,
name|push_index
init|=
literal|0
decl_stmt|,
name|ibuffer_len
init|=
literal|511
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ibuffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-null means it is a pointer to a function to run while waiting for    character input. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_event_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|any_typein
value|(push_index != pop_index)
end_define

begin_comment
comment|/* Add KEY to the buffer of characters to be read. */
end_comment

begin_macro
name|rl_stuff_char
argument_list|(
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|key
operator|==
name|EOF
condition|)
block|{
name|key
operator|=
name|NEWLINE
expr_stmt|;
name|rl_pending_input
operator|=
name|EOF
expr_stmt|;
block|}
name|ibuffer
index|[
name|push_index
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|push_index
operator|>=
name|ibuffer_len
condition|)
name|push_index
operator|=
literal|0
expr_stmt|;
return|return
name|push_index
return|;
block|}
end_block

begin_comment
comment|/* Return the amount of space available in the    buffer for stuffing characters. */
end_comment

begin_function
name|int
name|ibuffer_space
parameter_list|()
block|{
if|if
condition|(
name|pop_index
operator|>
name|push_index
condition|)
return|return
operator|(
name|pop_index
operator|-
name|push_index
operator|)
return|;
else|else
return|return
operator|(
name|ibuffer_len
operator|-
operator|(
name|push_index
operator|-
name|pop_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a key from the buffer of characters to be read.    Return the key in KEY.    Result is KEY if there was a key, or 0 if there wasn't. */
end_comment

begin_function
name|int
name|rl_get_char
parameter_list|(
name|key
parameter_list|)
name|int
modifier|*
name|key
decl_stmt|;
block|{
if|if
condition|(
name|push_index
operator|==
name|pop_index
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|key
operator|=
name|ibuffer
index|[
name|pop_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|pop_index
operator|>=
name|ibuffer_len
condition|)
name|pop_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stuff KEY into the *front* of the input buffer.    Returns non-zero if successful, zero if there is    no space left in the buffer. */
end_comment

begin_function
name|int
name|rl_unget_char
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|ibuffer_space
argument_list|()
condition|)
block|{
name|pop_index
operator|--
expr_stmt|;
if|if
condition|(
name|pop_index
operator|<
literal|0
condition|)
name|pop_index
operator|=
name|ibuffer_len
operator|-
literal|1
expr_stmt|;
name|ibuffer
index|[
name|pop_index
index|]
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If a character is available to be read, then read it    and stuff it into IBUFFER.  Otherwise, just return. */
end_comment

begin_function
name|void
name|rl_gather_tyi
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|char
name|input
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|rl_getc
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
condition|)
name|rl_stuff_char
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kbhit
argument_list|()
operator|&&
name|ibuffer_space
argument_list|()
condition|)
name|rl_stuff_char
argument_list|(
name|getkey
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !__GO32__ */
name|int
name|tty
init|=
name|fileno
argument_list|(
name|in_stream
argument_list|)
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|,
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|chars_avail
decl_stmt|;
name|char
name|input
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|chars_avail
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
operator|(
name|flags
operator||
name|O_NDELAY
operator|)
argument_list|)
expr_stmt|;
name|chars_avail
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* O_NDELAY */
comment|/* If there's nothing available, don't waste time trying to read      something. */
if|if
condition|(
name|chars_avail
operator|==
literal|0
condition|)
return|return;
name|tem
operator|=
name|ibuffer_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|>
name|tem
condition|)
name|chars_avail
operator|=
name|tem
expr_stmt|;
comment|/* One cannot read all of the available input.  I can only read a single      character at a time, or else programs which require input can be      thwarted.  If the buffer is larger than one character, I lose.      Damn! */
if|if
condition|(
name|tem
operator|<
name|ibuffer_len
condition|)
name|chars_avail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|chars_avail
operator|--
condition|)
name|rl_stuff_char
argument_list|(
name|rl_getc
argument_list|(
name|in_stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chars_avail
condition|)
name|rl_stuff_char
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

begin_function_decl
specifier|static
name|int
name|next_macro_key
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Read a key, including pending input. */
end_comment

begin_function
name|int
name|rl_read_key
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|rl_key_sequence_length
operator|++
expr_stmt|;
if|if
condition|(
name|rl_pending_input
condition|)
block|{
name|c
operator|=
name|rl_pending_input
expr_stmt|;
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* If input is coming from a macro, then use that. */
if|if
condition|(
name|c
operator|=
name|next_macro_key
argument_list|()
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* If the user has an event function, then call it periodically. */
if|if
condition|(
name|rl_event_hook
condition|)
block|{
while|while
condition|(
name|rl_event_hook
operator|&&
operator|!
name|rl_get_char
argument_list|(
operator|&
name|c
argument_list|)
condition|)
block|{
call|(
modifier|*
name|rl_event_hook
call|)
argument_list|()
expr_stmt|;
name|rl_gather_tyi
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rl_get_char
argument_list|(
operator|&
name|c
argument_list|)
condition|)
name|c
operator|=
name|rl_getc
argument_list|(
name|in_stream
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Found later in this file. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_macro_char
argument_list|()
decl_stmt|,
name|with_macro_input
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do the command associated with KEY in MAP.    If the associated command is really a keymap, then read    another key, and dispatch into that map. */
end_comment

begin_function
name|int
name|_rl_dispatch
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
specifier|register
name|int
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|defining_kbd_macro
condition|)
name|add_macro_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|key
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|key
operator|=
name|UNMETA
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|rl_key_sequence_length
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|key
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
else|else
name|ding
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISFUNC
case|:
block|{
name|Function
modifier|*
name|func
init|=
name|map
index|[
name|key
index|]
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|func
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Special case rl_do_lowercase_version (). */
if|if
condition|(
name|func
operator|==
name|rl_do_lowercase_version
condition|)
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|to_lower
argument_list|(
name|key
argument_list|)
argument_list|,
name|map
argument_list|)
operator|)
return|;
name|r
operator|=
operator|(
operator|*
name|map
index|[
name|key
index|]
operator|.
name|function
operator|)
operator|(
name|rl_numeric_arg
operator|*
name|rl_arg_sign
operator|,
name|key
operator|)
expr_stmt|;
comment|/* If we have input pending, then the last command was a prefix 	       command.  Don't change the state of rl_last_func.  Otherwise, 	       remember the last command executed in this variable. */
if|if
condition|(
operator|!
name|rl_pending_input
condition|)
name|rl_last_func
operator|=
name|map
index|[
name|key
index|]
operator|.
name|function
expr_stmt|;
block|}
else|else
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
break|break;
case|case
name|ISKMAP
case|:
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|newkey
decl_stmt|;
name|rl_key_sequence_length
operator|++
expr_stmt|;
name|newkey
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|r
operator|=
name|_rl_dispatch
argument_list|(
name|newkey
argument_list|,
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|ISMACR
case|:
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|macro
decl_stmt|;
name|macro
operator|=
name|savestring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|with_macro_input
argument_list|(
name|macro
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|&&
name|_rl_keymap
operator|==
name|vi_movement_keymap
operator|&&
name|rl_vi_textmod_command
argument_list|(
name|key
argument_list|)
condition|)
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
name|rl_numeric_arg
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Hacking Keyboard Macros 		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The currently executing macro string.  If this is non-zero,    then it is a malloc ()'ed string where input is coming from. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|executing_macro
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset in the above string to the next character to be read. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_macro_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current macro string being built.  Characters get stuffed    in here by add_macro_char (). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_macro
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the buffer allocated to current_macro. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_macro_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index at which characters are being added to current_macro. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_macro_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A structure used to save nested macro strings.    It is a linked list of string/index for each saved macro. */
end_comment

begin_struct
struct|struct
name|saved_macro
block|{
name|struct
name|saved_macro
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|sindex
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of saved macros. */
end_comment

begin_decl_stmt
name|struct
name|saved_macro
modifier|*
name|macro_list
init|=
operator|(
expr|struct
name|saved_macro
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations of static functions.  Thank you C. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|push_executing_macro
argument_list|()
decl_stmt|,
name|pop_executing_macro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This one has to be declared earlier in the file. */
end_comment

begin_comment
comment|/* static void add_macro_char (); */
end_comment

begin_comment
comment|/* Set up to read subsequent input from STRING.    STRING is free ()'ed when we are done with it. */
end_comment

begin_function
specifier|static
name|void
name|with_macro_input
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|push_executing_macro
argument_list|()
expr_stmt|;
name|executing_macro
operator|=
name|string
expr_stmt|;
name|executing_macro_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next character available from a macro, or 0 if    there are no macro characters. */
end_comment

begin_function
specifier|static
name|int
name|next_macro_key
parameter_list|()
block|{
if|if
condition|(
operator|!
name|executing_macro
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|executing_macro
index|[
name|executing_macro_index
index|]
condition|)
block|{
name|pop_executing_macro
argument_list|()
expr_stmt|;
return|return
operator|(
name|next_macro_key
argument_list|()
operator|)
return|;
block|}
return|return
operator|(
name|executing_macro
index|[
name|executing_macro_index
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Save the currently executing macro on a stack of saved macros. */
end_comment

begin_function
specifier|static
name|void
name|push_executing_macro
parameter_list|()
block|{
name|struct
name|saved_macro
modifier|*
name|saver
decl_stmt|;
name|saver
operator|=
operator|(
expr|struct
name|saved_macro
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_macro
argument_list|)
argument_list|)
expr_stmt|;
name|saver
operator|->
name|next
operator|=
name|macro_list
expr_stmt|;
name|saver
operator|->
name|sindex
operator|=
name|executing_macro_index
expr_stmt|;
name|saver
operator|->
name|string
operator|=
name|executing_macro
expr_stmt|;
name|macro_list
operator|=
name|saver
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard the current macro, replacing it with the one    on the top of the stack of saved macros. */
end_comment

begin_function
specifier|static
name|void
name|pop_executing_macro
parameter_list|()
block|{
if|if
condition|(
name|executing_macro
condition|)
name|free
argument_list|(
name|executing_macro
argument_list|)
expr_stmt|;
name|executing_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|executing_macro_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|macro_list
condition|)
block|{
name|struct
name|saved_macro
modifier|*
name|disposer
init|=
name|macro_list
decl_stmt|;
name|executing_macro
operator|=
name|macro_list
operator|->
name|string
expr_stmt|;
name|executing_macro_index
operator|=
name|macro_list
operator|->
name|sindex
expr_stmt|;
name|macro_list
operator|=
name|macro_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|disposer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a character to the macro being built. */
end_comment

begin_function
specifier|static
name|void
name|add_macro_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|current_macro_index
operator|+
literal|1
operator|>=
name|current_macro_size
condition|)
block|{
if|if
condition|(
operator|!
name|current_macro
condition|)
name|current_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_macro_size
operator|=
literal|25
argument_list|)
expr_stmt|;
else|else
name|current_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_macro
argument_list|,
name|current_macro_size
operator|+=
literal|25
argument_list|)
expr_stmt|;
block|}
name|current_macro
index|[
name|current_macro_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|current_macro
index|[
name|current_macro_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin defining a keyboard macro.    Keystrokes are recorded as they are executed.    End the definition with rl_end_kbd_macro ().    If a numeric argument was explicitly typed, then append this    definition to the end of the existing macro, and start by    re-executing the existing macro. */
end_comment

begin_macro
name|rl_start_kbd_macro
argument_list|(
argument|ignore1
argument_list|,
argument|ignore2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|defining_kbd_macro
condition|)
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
if|if
condition|(
name|current_macro
condition|)
name|with_macro_input
argument_list|(
name|savestring
argument_list|(
name|current_macro
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|current_macro_index
operator|=
literal|0
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Stop defining a keyboard macro.    A numeric argument says to execute the macro right now,    that many times, counting the definition as the first time. */
end_comment

begin_macro
name|rl_end_kbd_macro
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|defining_kbd_macro
condition|)
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|current_macro_index
operator|-=
operator|(
name|rl_key_sequence_length
operator|-
literal|1
operator|)
expr_stmt|;
name|current_macro
index|[
name|current_macro_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rl_call_last_kbd_macro
argument_list|(
operator|--
name|count
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Execute the most recently defined keyboard macro.    COUNT says how many times to execute it. */
end_comment

begin_macro
name|rl_call_last_kbd_macro
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|current_macro
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|defining_kbd_macro
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
comment|/* no recursive macros */
name|current_macro
index|[
operator|--
name|current_macro_index
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* erase this char */
return|return
literal|0
return|;
block|}
while|while
condition|(
name|count
operator|--
condition|)
name|with_macro_input
argument_list|(
name|savestring
argument_list|(
name|current_macro
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|void
name|_rl_kill_kbd_macro
parameter_list|()
block|{
if|if
condition|(
name|current_macro
condition|)
block|{
name|free
argument_list|(
name|current_macro
argument_list|)
expr_stmt|;
name|current_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|current_macro_size
operator|=
name|current_macro_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|executing_macro
condition|)
block|{
name|free
argument_list|(
name|executing_macro
argument_list|)
expr_stmt|;
name|executing_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|executing_macro_index
operator|=
literal|0
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Initializations 			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Initliaze readline (and terminal if not already). */
end_comment

begin_macro
name|rl_initialize
argument_list|()
end_macro

begin_block
block|{
comment|/* If we have never been called before, initialize the      terminal and data structures. */
if|if
condition|(
operator|!
name|rl_initialized
condition|)
block|{
name|readline_initialize_everything
argument_list|()
expr_stmt|;
name|rl_initialized
operator|++
expr_stmt|;
block|}
comment|/* Initalize the current line information. */
name|rl_point
operator|=
name|rl_end
operator|=
literal|0
expr_stmt|;
name|the_line
operator|=
name|rl_line_buffer
expr_stmt|;
name|the_line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We aren't done yet.  We haven't even gotten started yet! */
name|rl_done
operator|=
literal|0
expr_stmt|;
comment|/* Tell the history routines what is going on. */
name|start_using_history
argument_list|()
expr_stmt|;
comment|/* Make the display buffer match the state of the line. */
name|rl_reset_line_state
argument_list|()
expr_stmt|;
comment|/* No such function typed yet. */
name|rl_last_func
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Parsing of key-bindings begins in an enabled state. */
name|_rl_parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Initialize the entire state of the world. */
end_comment

begin_function
specifier|static
name|void
name|readline_initialize_everything
parameter_list|()
block|{
comment|/* Find out if we are running in Emacs. */
name|running_in_emacs
operator|=
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
expr_stmt|;
comment|/* Set up input and output if they are not already set up. */
if|if
condition|(
operator|!
name|rl_instream
condition|)
name|rl_instream
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|rl_outstream
condition|)
name|rl_outstream
operator|=
name|stdout
expr_stmt|;
comment|/* Bind in_stream and out_stream immediately.  These values may change,      but they may also be used before readline_internal () is called. */
name|in_stream
operator|=
name|rl_instream
expr_stmt|;
name|out_stream
operator|=
name|rl_outstream
expr_stmt|;
comment|/* Allocate data structures. */
if|if
condition|(
operator|!
name|rl_line_buffer
condition|)
name|rl_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|rl_line_buffer_len
operator|=
name|DEFAULT_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* Initialize the terminal interface. */
name|init_terminal_io
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
comment|/* Bind tty characters to readline functions. */
name|readline_default_bindings
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !__GO32__ */
comment|/* Initialize the function names. */
name|rl_initialize_funmap
argument_list|()
expr_stmt|;
comment|/* Read in the init file. */
name|rl_read_init_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Override the effect of any `set keymap' assignments in the      inputrc file. */
name|rl_set_keymap_from_edit_mode
argument_list|()
expr_stmt|;
comment|/* If the completion parser's default word break characters haven't      been set yet, then do so now. */
if|if
condition|(
name|rl_completer_word_break_characters
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|rl_completer_word_break_characters
operator|=
name|rl_basic_word_break_characters
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this system allows us to look at the values of the regular    input editing characters, then bind them to their readline    equivalents, iff the characters are not bound to keymaps. */
end_comment

begin_function
specifier|static
name|void
name|readline_default_bindings
parameter_list|()
block|{
name|rltty_set_default_bindings
argument_list|(
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Numeric Arguments			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Handle C-u style numeric args, as well as M--, and M-digits. */
end_comment

begin_function
specifier|static
name|int
name|rl_digit_loop
parameter_list|()
block|{
name|int
name|key
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rl_message
argument_list|(
literal|"(arg: %d) "
argument_list|,
name|rl_arg_sign
operator|*
name|rl_numeric_arg
argument_list|)
expr_stmt|;
name|key
operator|=
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_numeric_arg
operator|=
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|rl_numeric_arg
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
name|rl_explicit_arg
condition|)
block|{
name|rl_numeric_arg
operator|=
literal|1
expr_stmt|;
name|rl_arg_sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rl_clear_message
argument_list|()
expr_stmt|;
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|key
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add the current digit to the argument in progress. */
end_comment

begin_macro
name|rl_digit_argument
argument_list|(
argument|ignore
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_pending_input
operator|=
name|key
expr_stmt|;
return|return
operator|(
name|rl_digit_loop
argument_list|()
operator|)
return|;
block|}
end_block

begin_comment
comment|/* What to do when you abort reading an argument. */
end_comment

begin_macro
name|rl_discard_argument
argument_list|()
end_macro

begin_block
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_init_argument
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Create a default argument. */
end_comment

begin_macro
name|rl_init_argument
argument_list|()
end_macro

begin_block
block|{
name|rl_numeric_arg
operator|=
name|rl_arg_sign
operator|=
literal|1
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* C-u, universal argument.  Multiply the current argument by 4.    Read a key.  If the key has nothing to do with arguments, then    dispatch on it.  If the key is the abort character then abort. */
end_comment

begin_macro
name|rl_universal_argument
argument_list|()
end_macro

begin_block
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
return|return
operator|(
name|rl_digit_loop
argument_list|()
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Terminal and Termcap			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_string_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcap_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means this terminal can't really do anything. */
end_comment

begin_decl_stmt
name|int
name|dumb_term
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.    Unfortunately, PC is a global variable used by the termcap library. */
end_comment

begin_undef
undef|#
directive|undef
name|PC
end_undef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_comment
comment|/* Some strings to control terminal actions.  These are output by tputs (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_goto
decl_stmt|,
modifier|*
name|term_clreol
decl_stmt|,
modifier|*
name|term_cr
decl_stmt|,
modifier|*
name|term_clrpag
decl_stmt|,
modifier|*
name|term_backspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|term_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|screenwidth
decl_stmt|,
name|screenheight
decl_stmt|,
name|screenchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we determine that the terminal can do character insertion. */
end_comment

begin_decl_stmt
name|int
name|terminal_can_insert
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to insert characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_im
decl_stmt|,
modifier|*
name|term_ei
decl_stmt|,
modifier|*
name|term_ic
decl_stmt|,
modifier|*
name|term_ip
decl_stmt|,
modifier|*
name|term_IC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to delete characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_dc
decl_stmt|,
modifier|*
name|term_DC
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
end_if

begin_decl_stmt
name|char
modifier|*
name|term_forward_char
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HACK_TERMCAP_MOTION */
end_comment

begin_comment
comment|/* How to go up a line. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_up
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A visible bell, if the terminal can be made to flash the screen. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that this terminal has a meta key. */
end_comment

begin_decl_stmt
name|int
name|term_has_meta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to write to turn on the meta key, if this term has one. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_mm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to write to turn off the meta key, if this term has one. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_mo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The key sequences output by the arrow keys, if this terminal has any. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_ku
decl_stmt|,
modifier|*
name|term_kd
decl_stmt|,
modifier|*
name|term_kr
decl_stmt|,
modifier|*
name|term_kl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to initialize and reset the arrow keys, if this terminal has any. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_ks
decl_stmt|,
modifier|*
name|term_ke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Re-initialize the terminal considering that the TERM/TERMCAP variable    has changed. */
end_comment

begin_macro
name|rl_reset_terminal
argument_list|(
argument|terminal_name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|terminal_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|init_terminal_io
argument_list|(
name|terminal_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Set readline's idea of the screen size.  TTY is a file descriptor open    to the terminal.  If IGNORE_ENV is true, we do not pay attention to the    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being    non-null serve to check whether or not we have initialized termcap. */
end_comment

begin_function
name|void
name|_rl_set_screen_size
parameter_list|(
name|tty
parameter_list|,
name|ignore_env
parameter_list|)
name|int
name|tty
decl_stmt|,
name|ignore_env
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
name|struct
name|winsize
name|window_size
decl_stmt|;
endif|#
directive|endif
comment|/* TIOCGWINSZ */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|window_size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|screenwidth
operator|=
operator|(
name|int
operator|)
name|window_size
operator|.
name|ws_col
expr_stmt|;
name|screenheight
operator|=
operator|(
name|int
operator|)
name|window_size
operator|.
name|ws_row
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCGWINSZ */
comment|/* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV      is unset. */
if|if
condition|(
name|screenwidth
operator|<=
literal|0
condition|)
block|{
name|char
modifier|*
name|sw
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_env
operator|&&
operator|(
name|sw
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
condition|)
name|screenwidth
operator|=
name|atoi
argument_list|(
name|sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenwidth
operator|<=
literal|0
operator|&&
name|term_string_buffer
condition|)
name|screenwidth
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
block|}
comment|/* Environment variable LINES overrides setting of "li" if IGNORE_ENV      is unset. */
if|if
condition|(
name|screenheight
operator|<=
literal|0
condition|)
block|{
name|char
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_env
operator|&&
operator|(
name|sh
operator|=
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
operator|)
condition|)
name|screenheight
operator|=
name|atoi
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenheight
operator|<=
literal|0
operator|&&
name|term_string_buffer
condition|)
name|screenheight
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
block|}
comment|/* If all else fails, default to 80x24 terminal. */
if|if
condition|(
name|screenwidth
operator|<=
literal|1
condition|)
name|screenwidth
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|screenheight
operator|<=
literal|0
condition|)
name|screenheight
operator|=
literal|24
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* If we're being compiled as part of bash, set the environment      variables $LINES and $COLUMNS to new values. */
name|set_lines_and_columns
argument_list|(
name|screenheight
argument_list|,
name|screenwidth
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|screenwidth
operator|--
expr_stmt|;
name|screenchars
operator|=
name|screenwidth
operator|*
name|screenheight
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|_tc_string
block|{
name|char
modifier|*
name|tc_var
decl_stmt|;
name|char
modifier|*
modifier|*
name|tc_value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This should be kept sorted, just in case we decide to change the    search algorithm to something smarter. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_tc_string
name|tc_strings
index|[]
init|=
block|{
literal|"DC"
block|,
operator|&
name|term_DC
block|,
literal|"IC"
block|,
operator|&
name|term_IC
block|,
literal|"ce"
block|,
operator|&
name|term_clreol
block|,
literal|"cl"
block|,
operator|&
name|term_clrpag
block|,
literal|"cr"
block|,
operator|&
name|term_cr
block|,
literal|"dc"
block|,
operator|&
name|term_dc
block|,
literal|"ei"
block|,
operator|&
name|term_ei
block|,
literal|"ic"
block|,
operator|&
name|term_ic
block|,
literal|"im"
block|,
operator|&
name|term_im
block|,
literal|"kd"
block|,
operator|&
name|term_kd
block|,
literal|"kl"
block|,
operator|&
name|term_kl
block|,
literal|"kr"
block|,
operator|&
name|term_kr
block|,
literal|"ku"
block|,
operator|&
name|term_ku
block|,
literal|"ks"
block|,
operator|&
name|term_ks
block|,
literal|"ke"
block|,
operator|&
name|term_ke
block|,
literal|"le"
block|,
operator|&
name|term_backspace
block|,
literal|"mm"
block|,
operator|&
name|term_mm
block|,
literal|"mo"
block|,
operator|&
name|term_mo
block|,
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
literal|"nd"
block|,
operator|&
name|term_forward_char
block|,
endif|#
directive|endif
literal|"pc"
block|,
operator|&
name|term_pc
block|,
literal|"up"
block|,
operator|&
name|term_up
block|,
literal|"vb"
block|,
operator|&
name|visible_bell
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_TC_STRINGS
value|(sizeof (tc_strings) / sizeof (struct _tc_string))
end_define

begin_comment
comment|/* Read the desired terminal capability strings into BP.  The capabilities    are described in the TC_STRINGS table. */
end_comment

begin_function
specifier|static
name|void
name|get_term_capabilities
parameter_list|(
name|bp
parameter_list|)
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TC_STRINGS
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_value
operator|)
operator|=
name|tgetstr
argument_list|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_var
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|tcap_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_terminal_io
parameter_list|(
name|terminal_name
parameter_list|)
name|char
modifier|*
name|terminal_name
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|screenwidth
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|screenheight
operator|=
name|ScreenRows
argument_list|()
expr_stmt|;
name|screenchars
operator|=
name|screenwidth
operator|*
name|screenheight
expr_stmt|;
name|term_cr
operator|=
literal|"\r"
expr_stmt|;
name|term_im
operator|=
name|term_ei
operator|=
name|term_ic
operator|=
name|term_IC
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|term_up
operator|=
name|term_dc
operator|=
name|term_DC
operator|=
name|visible_bell
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Does the __GO32__ have a meta key?  I don't know. */
name|term_has_meta
operator|=
literal|0
expr_stmt|;
name|term_mm
operator|=
name|term_mo
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* It probably has arrow keys, but I don't know what they are. */
name|term_ku
operator|=
name|term_kd
operator|=
name|term_kr
operator|=
name|term_kl
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
name|term_forward_char
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
name|terminal_can_insert
operator|=
literal|0
expr_stmt|;
return|return;
else|#
directive|else
comment|/* !__GO32__ */
name|char
modifier|*
name|term
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|int
name|tty
decl_stmt|;
name|term
operator|=
name|terminal_name
condition|?
name|terminal_name
else|:
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_string_buffer
condition|)
name|term_string_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_buffer
condition|)
name|term_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|term_string_buffer
expr_stmt|;
name|term_clrpag
operator|=
name|term_cr
operator|=
name|term_clreol
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|term
condition|)
name|term
operator|=
literal|"dumb"
expr_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|term
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|dumb_term
operator|=
literal|1
expr_stmt|;
name|screenwidth
operator|=
literal|79
expr_stmt|;
name|screenheight
operator|=
literal|24
expr_stmt|;
name|screenchars
operator|=
literal|79
operator|*
literal|24
expr_stmt|;
name|term_cr
operator|=
literal|"\r"
expr_stmt|;
name|term_im
operator|=
name|term_ei
operator|=
name|term_ic
operator|=
name|term_IC
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|term_up
operator|=
name|term_dc
operator|=
name|term_DC
operator|=
name|visible_bell
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|term_ku
operator|=
name|term_kd
operator|=
name|term_kl
operator|=
name|term_kr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
name|term_forward_char
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
name|terminal_can_insert
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|get_term_capabilities
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/* Set up the variables that the termcap library expects the application      to provide. */
name|PC
operator|=
name|term_pc
condition|?
operator|*
name|term_pc
else|:
literal|0
expr_stmt|;
name|BC
operator|=
name|term_backspace
expr_stmt|;
name|UP
operator|=
name|term_up
expr_stmt|;
if|if
condition|(
operator|!
name|term_cr
condition|)
name|term_cr
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
name|rl_instream
condition|)
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
else|else
name|tty
operator|=
literal|0
expr_stmt|;
name|screenwidth
operator|=
name|screenheight
operator|=
literal|0
expr_stmt|;
name|_rl_set_screen_size
argument_list|(
name|tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "An application program can assume that the terminal can do       character insertion if *any one of* the capabilities `IC',       `im', `ic' or `ip' is provided."  But we can't do anything if       only `ip' is provided, so... */
name|terminal_can_insert
operator|=
operator|(
name|term_IC
operator|||
name|term_im
operator|||
name|term_ic
operator|)
expr_stmt|;
comment|/* Check to see if this terminal has a meta key and clear the capability      variables if there is none. */
name|term_has_meta
operator|=
operator|(
name|tgetflag
argument_list|(
literal|"km"
argument_list|)
operator|||
name|tgetflag
argument_list|(
literal|"MT"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_has_meta
condition|)
block|{
name|term_mm
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|term_mo
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Attempt to find and bind the arrow keys.  Do not override already      bound keys in an overzealous attempt, however. */
name|_rl_bind_if_unbound
argument_list|(
name|term_ku
argument_list|,
name|rl_get_previous_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
name|term_kd
argument_list|,
name|rl_get_next_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
name|term_kr
argument_list|,
name|rl_forward
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
name|term_kl
argument_list|,
name|rl_backward
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__GO32__ */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rl_get_termcap
parameter_list|(
name|cap
parameter_list|)
name|char
modifier|*
name|cap
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tcap_initialized
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TC_STRINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_var
index|[
literal|0
index|]
operator|==
name|cap
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_var
argument_list|,
name|cap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|*
operator|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_value
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A function for the use of tputs () */
end_comment

begin_function
name|int
name|_rl_output_character_function
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
name|putc
argument_list|(
name|c
argument_list|,
name|out_stream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write COUNT characters from STRING to the output stream. */
end_comment

begin_function
name|void
name|_rl_output_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the cursor back. */
end_comment

begin_macro
name|backspace
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
if|if
condition|(
name|term_backspace
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_backspace
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* !__GO32__ */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\b'
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move to the start of the next line. */
end_comment

begin_macro
name|crlf
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_TTY_DRIVER */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Utility Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return 0 if C is not a member of the class of characters that belong    in words, or 1 if it is. */
end_comment

begin_decl_stmt
name|int
name|allow_pathname_alphabetic_chars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pathname_alphabetic_chars
init|=
literal|"/-_=~.#$"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|alphabetic
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|pure_alphabetic
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|numeric
argument_list|(
name|c
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|allow_pathname_alphabetic_chars
condition|)
return|return
operator|(
name|strchr
argument_list|(
name|pathname_alphabetic_chars
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if C is a numeric character. */
end_comment

begin_function
name|int
name|numeric
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Ring the terminal bell. */
end_comment

begin_function
name|int
name|ding
parameter_list|()
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
switch|switch
condition|(
name|_rl_bell_preference
condition|)
block|{
case|case
name|NO_BELL
case|:
default|default:
break|break;
case|case
name|VISIBLE_BELL
case|:
if|if
condition|(
name|visible_bell
condition|)
block|{
name|tputs
argument_list|(
name|visible_bell
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|AUDIBLE_BELL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\007"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* __GO32__ */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\007"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __GO32__ */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to abort things. */
end_comment

begin_macro
name|rl_abort
argument_list|()
end_macro

begin_block
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_init_argument
argument_list|()
expr_stmt|;
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|executing_macro
condition|)
name|pop_executing_macro
argument_list|()
expr_stmt|;
name|rl_last_func
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
name|longjmp
argument_list|(
name|readline_top_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a copy of the string between FROM and TO.    FROM is inclusive, TO is not. */
end_comment

begin_function
name|char
modifier|*
name|rl_copy_text
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
comment|/* Fix it if the caller is confused. */
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
name|int
name|t
init|=
name|from
decl_stmt|;
name|from
operator|=
name|to
expr_stmt|;
name|to
operator|=
name|t
expr_stmt|;
block|}
name|length
operator|=
name|to
operator|-
name|from
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|copy
argument_list|,
name|the_line
operator|+
name|from
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Increase the size of RL_LINE_BUFFER until it has enough space to hold    LEN characters. */
end_comment

begin_function
name|void
name|rl_extend_line_buffer
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_line_buffer_len
operator|+=
name|DEFAULT_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|the_line
operator|=
name|rl_line_buffer
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insert and Delete			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert a string of text into the line at point.  This is the only    way that you should do insertion.  rl_insert () calls this    function. */
end_comment

begin_macro
name|rl_insert_text
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl_end
operator|+
name|l
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|rl_end
operator|+
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rl_end
init|;
name|i
operator|>=
name|rl_point
condition|;
name|i
operator|--
control|)
name|the_line
index|[
name|i
operator|+
name|l
index|]
operator|=
name|the_line
index|[
name|i
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|the_line
operator|+
name|rl_point
argument_list|,
name|string
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Remember how to undo this if we aren't undoing something. */
if|if
condition|(
operator|!
name|doing_an_undo
condition|)
block|{
comment|/* If possible and desirable, concatenate the undos. */
if|if
condition|(
operator|(
name|l
operator|==
literal|1
operator|)
operator|&&
name|rl_undo_list
operator|&&
operator|(
name|rl_undo_list
operator|->
name|what
operator|==
name|UNDO_INSERT
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|==
name|rl_point
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|-
name|rl_undo_list
operator|->
name|start
operator|<
literal|20
operator|)
condition|)
name|rl_undo_list
operator|->
name|end
operator|++
expr_stmt|;
else|else
name|rl_add_undo
argument_list|(
name|UNDO_INSERT
argument_list|,
name|rl_point
argument_list|,
name|rl_point
operator|+
name|l
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rl_point
operator|+=
name|l
expr_stmt|;
name|rl_end
operator|+=
name|l
expr_stmt|;
name|the_line
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|l
return|;
block|}
end_block

begin_comment
comment|/* Delete the string between FROM and TO.  FROM is    inclusive, TO is not. */
end_comment

begin_macro
name|rl_delete_text
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
specifier|register
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fix it if the caller is confused. */
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
name|int
name|t
init|=
name|from
decl_stmt|;
name|from
operator|=
name|to
expr_stmt|;
name|to
operator|=
name|t
expr_stmt|;
block|}
name|text
operator|=
name|rl_copy_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* Some versions of strncpy() can't handle overlapping arguments. */
name|diff
operator|=
name|to
operator|-
name|from
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<
name|rl_end
operator|-
name|diff
condition|;
name|i
operator|++
control|)
name|the_line
index|[
name|i
index|]
operator|=
name|the_line
index|[
name|i
operator|+
name|diff
index|]
expr_stmt|;
comment|/* Remember how to undo this delete. */
if|if
condition|(
operator|!
name|doing_an_undo
condition|)
name|rl_add_undo
argument_list|(
name|UNDO_DELETE
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_end
operator|-=
name|diff
expr_stmt|;
name|the_line
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Readline character functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is not a gap editor, just a stupid line input routine.  No hair    is involved in writing any of the functions, and none should be. */
end_comment

begin_comment
comment|/* Note that:     rl_end is the place in the string that we would place '\0';    i.e., it is always safe to place '\0' there.     rl_point is the place in the string where the cursor is.  Sometimes    this is the same as rl_end.     Any command that is called interactively receives two arguments.    The first is a count: the numeric arg pased to this command.    The second is the key which invoked this command. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Movement Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Note that if you `optimize' the display for these functions, you cannot    use said functions in other functions which do not do optimizing display.    I.e., you will have to update the data base for rl_redisplay, and you    might as well let rl_redisplay do that job. */
end_comment

begin_comment
comment|/* Move forward COUNT characters. */
end_comment

begin_macro
name|rl_forward
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_backward
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|end
init|=
name|rl_point
operator|+
name|count
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|int
name|lend
init|=
name|rl_end
operator|-
operator|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|)
decl_stmt|;
else|#
directive|else
name|int
name|lend
init|=
name|rl_end
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|end
operator|>
name|lend
condition|)
block|{
name|rl_point
operator|=
name|lend
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move backward COUNT characters. */
end_comment

begin_macro
name|rl_backward
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_forward
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rl_point
operator|<
name|count
condition|)
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|-=
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move to the beginning of the line. */
end_comment

begin_macro
name|rl_beg_of_line
argument_list|()
end_macro

begin_block
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move to the end of the line. */
end_comment

begin_macro
name|rl_end_of_line
argument_list|()
end_macro

begin_block
block|{
name|rl_point
operator|=
name|rl_end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move forward a word.  We do what Emacs does. */
end_comment

begin_macro
name|rl_forward_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_backward_word
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return
literal|0
return|;
comment|/* If we are not in a word, move forward until we are in one. 	 Then, move forward until we hit a non-alphabetic character. */
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
operator|--
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move backward a word.  We do what Emacs does. */
end_comment

begin_macro
name|rl_backward_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_forward_word
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
return|return
literal|0
return|;
comment|/* Like rl_forward_word (), except that we look at the characters 	 just before point. */
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|rl_point
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
else|else
operator|--
name|rl_point
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Clear the current line.  Numeric argument to C-l does this. */
end_comment

begin_macro
name|rl_refresh_line
argument_list|()
end_macro

begin_block
block|{
name|int
name|curr_line
decl_stmt|,
name|nleft
decl_stmt|;
comment|/* Find out whether or not there might be invisible characters in the      editing buffer. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
condition|)
name|nleft
operator|=
name|_rl_last_c_pos
operator|-
name|screenwidth
operator|-
name|rl_visible_prompt_length
expr_stmt|;
else|else
name|nleft
operator|=
name|_rl_last_c_pos
operator|-
name|screenwidth
expr_stmt|;
if|if
condition|(
name|nleft
operator|>
literal|0
condition|)
name|curr_line
operator|=
literal|1
operator|+
name|nleft
operator|/
name|screenwidth
expr_stmt|;
else|else
name|curr_line
operator|=
literal|0
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|curr_line
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|the_line
argument_list|)
expr_stmt|;
comment|/* XXX is this right */
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|width
decl_stmt|,
name|row_start
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|width
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|row_start
operator|=
name|ScreenPrimary
operator|+
operator|(
name|row
operator|*
name|width
operator|)
expr_stmt|;
name|memset
argument_list|(
name|row_start
operator|+
name|col
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|-
name|col
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !__GO32__ */
if|if
condition|(
name|term_clreol
condition|)
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__GO32__ */
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* C-l typed to a line without quoting clears the screen, and then reprints    the prompt and the current input line.  Given a numeric arg, redraw only    the current line. */
end_comment

begin_macro
name|rl_clear_screen
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|rl_refresh_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
if|if
condition|(
name|term_clrpag
condition|)
name|tputs
argument_list|(
name|term_clrpag
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* !__GO32__ */
name|crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|rl_arrow_keys
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|to_upper
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
literal|'A'
case|:
name|rl_get_previous_history
argument_list|(
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|rl_get_next_history
argument_list|(
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|rl_forward
argument_list|(
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|rl_backward
argument_list|(
name|count
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ding
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Text commands				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert the character C at the current location, moving point forward. */
end_comment

begin_macro
name|rl_insert
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can optimize, then do it.  But don't let people crash      readline because of extra large arguments. */
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|count
operator|<
literal|1024
condition|)
block|{
name|string
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1024
condition|)
block|{
name|int
name|decreaser
decl_stmt|;
name|char
name|str
index|[
literal|1024
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|str
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|decreaser
operator|=
operator|(
name|count
operator|>
literal|1024
condition|?
literal|1024
else|:
name|count
operator|)
expr_stmt|;
name|str
index|[
name|decreaser
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|count
operator|-=
name|decreaser
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* We are inserting a single character.      If there is pending input, then make a string of all of the      pending characters that are bound to rl_insert, and insert      them all. */
if|if
condition|(
name|any_typein
condition|)
block|{
name|int
name|key
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|string
operator|=
name|xmalloc
argument_list|(
name|ibuffer_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|rl_get_char
argument_list|(
operator|&
name|key
argument_list|)
operator|)
operator|&&
operator|(
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|function
operator|==
name|rl_insert
operator|)
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|rl_unget_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Inserting a single character. */
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|rl_insert_text
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Insert the next typed character verbatim. */
end_comment

begin_macro
name|rl_quoted_insert
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
return|return
operator|(
name|rl_insert
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Insert a tab character. */
end_comment

begin_macro
name|rl_tab_insert
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_insert
argument_list|(
name|count
argument_list|,
literal|'\t'
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* What to do when a NEWLINE is pressed.  We accept the whole line.    KEY is the key that invoked this command.  I guess it could have    meaning in the future. */
end_comment

begin_macro
name|rl_newline
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_done
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|_rl_vi_done_inserting
argument_list|()
expr_stmt|;
name|_rl_vi_reset_last
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|rl_clean_up_for_exit
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
name|rl_restart_output
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* What to do for some uppercase characters, like meta characters,    and some characters appearing in emacs_ctlx_keymap.  This function    is just a stub, you bind keys to it and the code in _rl_dispatch ()    is special cased. */
end_comment

begin_macro
name|rl_do_lowercase_version
argument_list|(
argument|ignore1
argument_list|,
argument|ignore2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Rubout the character behind point. */
end_comment

begin_macro
name|rl_rubout
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_delete
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rl_point
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
name|rl_backward
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|the_line
index|[
operator|--
name|rl_point
index|]
decl_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
name|_rl_last_c_pos
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|rl_character_len
argument_list|(
name|c
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|_rl_erase_at_end_of_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Delete the character under the cursor.  Given a numeric argument,    kill that many characters instead. */
end_comment

begin_macro
name|rl_delete
argument_list|(
argument|count
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|invoking_key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|rl_rubout
argument_list|(
operator|-
name|count
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
name|rl_forward
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|(
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Delete all spaces and tabs around point. */
end_comment

begin_macro
name|rl_delete_horizontal_space
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|start
init|=
name|rl_point
decl_stmt|;
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
name|start
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|rl_point
condition|)
block|{
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Kill commands				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The next two functions mimic unix line editing behaviour, except they    save the deleted text on the kill ring.  This is safer than not saving    it, and since we have a ring, nobody should get screwed. */
end_comment

begin_comment
comment|/* This does what C-w does in Unix.  We can't prevent people from    using behaviour that they expect. */
end_comment

begin_macro
name|rl_unix_word_rubout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|&&
operator|!
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Here is C-u doing what Unix does.  You don't *have* to use these    key-bindings.  We have a choice of killing the entire line, or    killing from where we are to the start of the line.  We choose the    latter, because if you are a Unix weenie, then you haven't backspaced    into the line at all, and if you aren't, then you know what you are    doing. */
end_comment

begin_macro
name|rl_unix_line_discard
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Commands For Typos			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Random and interesting things in here.  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Changing Case				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The three kinds of things that we know how to do. */
end_comment

begin_define
define|#
directive|define
name|UpCase
value|1
end_define

begin_define
define|#
directive|define
name|DownCase
value|2
end_define

begin_define
define|#
directive|define
name|CapCase
value|3
end_define

begin_function_decl
specifier|static
name|int
name|rl_change_case
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Uppercase the word at point. */
end_comment

begin_macro
name|rl_upcase_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|UpCase
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Lowercase the word at point. */
end_comment

begin_macro
name|rl_downcase_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|DownCase
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Upcase the first letter, downcase the rest. */
end_comment

begin_macro
name|rl_capitalize_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|CapCase
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* The meaty function.    Change the case of COUNT words, performing OP on them.    OP is one of UpCase, DownCase, or CapCase.    If a negative argument is given, leave point where it started,    otherwise, leave it where it moves to. */
end_comment

begin_function
specifier|static
name|int
name|rl_change_case
parameter_list|(
name|count
parameter_list|,
name|op
parameter_list|)
name|int
name|count
decl_stmt|,
name|op
decl_stmt|;
block|{
specifier|register
name|int
name|start
init|=
name|rl_point
decl_stmt|,
name|end
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|rl_forward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|int
name|temp
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|temp
expr_stmt|;
block|}
comment|/* We are going to modify some text, so let's prepare to undo it. */
name|rl_modifying
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
name|end
condition|;
name|start
operator|++
control|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UpCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
name|to_upper
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DownCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
name|to_lower
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CapCase
case|:
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|the_line
index|[
name|start
index|]
operator|=
name|to_upper
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|the_line
index|[
name|start
index|]
operator|=
name|to_lower
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pure_alphabetic
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
condition|)
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|rl_point
operator|=
name|end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Transposition				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Transpose the words at point. */
end_comment

begin_macro
name|rl_transpose_words
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|word1
decl_stmt|,
modifier|*
name|word2
decl_stmt|;
name|int
name|w1_beg
decl_stmt|,
name|w1_end
decl_stmt|,
name|w2_beg
decl_stmt|,
name|w2_end
decl_stmt|;
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
comment|/* Find the two words. */
name|rl_forward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|w2_end
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|w2_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|w1_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|w1_end
operator|=
name|rl_point
expr_stmt|;
comment|/* Do some check to make sure that there really are two words. */
if|if
condition|(
operator|(
name|w1_beg
operator|==
name|w2_beg
operator|)
operator|||
operator|(
name|w2_beg
operator|<
name|w1_end
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the text of the words. */
name|word1
operator|=
name|rl_copy_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|word2
operator|=
name|rl_copy_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
comment|/* We are about to do many insertions and deletions.  Remember them      as one operation. */
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* Do the stuff at word2 first, so that we don't have to worry      about word1 moving. */
name|rl_point
operator|=
name|w2_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|w1_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word2
argument_list|)
expr_stmt|;
comment|/* This is exactly correct since the text before this point has not      changed in length. */
name|rl_point
operator|=
name|w2_end
expr_stmt|;
comment|/* I think that does it. */
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Transpose the characters at point.  If point is at the end of the line,    then transpose the characters before point. */
end_comment

begin_macro
name|rl_transpose_chars
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dummy
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rl_point
operator|||
name|rl_end
operator|<
literal|2
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
operator|--
name|rl_point
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|rl_point
operator|--
expr_stmt|;
name|dummy
index|[
literal|0
index|]
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
name|dummy
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rl_point
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
name|rl_end
condition|)
name|rl_point
operator|=
name|rl_end
expr_stmt|;
elseif|else
if|if
condition|(
name|rl_point
operator|<
literal|0
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_insert_text
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Undo, and Undoing			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The current undo list for THE_LINE. */
end_comment

begin_decl_stmt
name|UNDO_LIST
modifier|*
name|rl_undo_list
init|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember how to undo something.  Concatenate some undos if that    seems right. */
end_comment

begin_function
name|void
name|rl_add_undo
parameter_list|(
name|what
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|text
parameter_list|)
name|enum
name|undo_code
name|what
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|UNDO_LIST
modifier|*
name|temp
init|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|UNDO_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|what
operator|=
name|what
expr_stmt|;
name|temp
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|temp
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|temp
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|rl_undo_list
expr_stmt|;
name|rl_undo_list
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the existing undo list. */
end_comment

begin_function
name|void
name|free_undo_list
parameter_list|()
block|{
while|while
condition|(
name|rl_undo_list
condition|)
block|{
name|UNDO_LIST
modifier|*
name|release
init|=
name|rl_undo_list
decl_stmt|;
name|rl_undo_list
operator|=
name|rl_undo_list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|release
operator|->
name|what
operator|==
name|UNDO_DELETE
condition|)
name|free
argument_list|(
name|release
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|release
argument_list|)
expr_stmt|;
block|}
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the next thing in the list.  Return 0 if there    is nothing to undo, or non-zero if there was. */
end_comment

begin_function
name|int
name|rl_do_undo
parameter_list|()
block|{
name|UNDO_LIST
modifier|*
name|release
decl_stmt|;
name|int
name|waiting_for_begin
init|=
literal|0
decl_stmt|;
name|undo_thing
label|:
if|if
condition|(
operator|!
name|rl_undo_list
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|doing_an_undo
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|rl_undo_list
operator|->
name|what
condition|)
block|{
comment|/* Undoing deletes means inserting some text. */
case|case
name|UNDO_DELETE
case|:
name|rl_point
operator|=
name|rl_undo_list
operator|->
name|start
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rl_undo_list
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rl_undo_list
operator|->
name|text
argument_list|)
expr_stmt|;
break|break;
comment|/* Undoing inserts means deleting some text. */
case|case
name|UNDO_INSERT
case|:
name|rl_delete_text
argument_list|(
name|rl_undo_list
operator|->
name|start
argument_list|,
name|rl_undo_list
operator|->
name|end
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|rl_undo_list
operator|->
name|start
expr_stmt|;
break|break;
comment|/* Undoing an END means undoing everything 'til we get to        a BEGIN. */
case|case
name|UNDO_END
case|:
name|waiting_for_begin
operator|++
expr_stmt|;
break|break;
comment|/* Undoing a BEGIN means that we are done with this group. */
case|case
name|UNDO_BEGIN
case|:
if|if
condition|(
name|waiting_for_begin
condition|)
name|waiting_for_begin
operator|--
expr_stmt|;
else|else
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
name|doing_an_undo
operator|=
literal|0
expr_stmt|;
name|release
operator|=
name|rl_undo_list
expr_stmt|;
name|rl_undo_list
operator|=
name|rl_undo_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|release
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting_for_begin
condition|)
goto|goto
name|undo_thing
goto|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a group.  Subsequent undos are undone as an atomic operation. */
end_comment

begin_macro
name|rl_begin_undo_group
argument_list|()
end_macro

begin_block
block|{
name|rl_add_undo
argument_list|(
name|UNDO_BEGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* End an undo group started with rl_begin_undo_group (). */
end_comment

begin_macro
name|rl_end_undo_group
argument_list|()
end_macro

begin_block
block|{
name|rl_add_undo
argument_list|(
name|UNDO_END
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Save an undo entry for the text from START to END. */
end_comment

begin_macro
name|rl_modifying
argument_list|(
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
name|int
name|t
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|rl_copy_text
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_DELETE
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_INSERT
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Revert the current line to its previous state. */
end_comment

begin_macro
name|rl_revert_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_undo_list
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
while|while
condition|(
name|rl_undo_list
condition|)
name|rl_do_undo
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Do some undoing of things that were done. */
end_comment

begin_macro
name|rl_undo_command
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Nothing to do. */
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_do_undo
argument_list|()
condition|)
name|count
operator|--
expr_stmt|;
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Utilities			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* We already have a history library, and that is what we use to control    the history features of readline.  However, this is our local interface    to the history mechanism. */
end_comment

begin_comment
comment|/* While we are editing the history, this is the saved    version of the original line. */
end_comment

begin_decl_stmt
name|HIST_ENTRY
modifier|*
name|saved_line_for_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the history pointer back to the last entry in the history. */
end_comment

begin_function
specifier|static
name|void
name|start_using_history
parameter_list|()
block|{
name|using_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_line_for_history
condition|)
name|_rl_free_history_entry
argument_list|(
name|saved_line_for_history
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the contents (and containing structure) of a HIST_ENTRY. */
end_comment

begin_function
name|void
name|_rl_free_history_entry
parameter_list|(
name|entry
parameter_list|)
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
if|if
condition|(
name|entry
operator|->
name|line
condition|)
name|free
argument_list|(
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perhaps put back the current line if it has changed. */
end_comment

begin_macro
name|maybe_replace_line
argument_list|()
end_macro

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
name|current_history
argument_list|()
decl_stmt|;
comment|/* If the current line has changed, save the changes. */
if|if
condition|(
name|temp
operator|&&
operator|(
operator|(
name|UNDO_LIST
operator|*
operator|)
operator|(
name|temp
operator|->
name|data
operator|)
operator|!=
name|rl_undo_list
operator|)
condition|)
block|{
name|temp
operator|=
name|replace_history_entry
argument_list|(
name|where_history
argument_list|()
argument_list|,
name|the_line
argument_list|,
name|rl_undo_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Put back the saved_line_for_history if there is one. */
end_comment

begin_macro
name|maybe_unsave_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|saved_line_for_history
condition|)
block|{
name|int
name|line_len
decl_stmt|;
name|line_len
operator|=
name|strlen
argument_list|(
name|saved_line_for_history
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|saved_line_for_history
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|saved_line_for_history
operator|->
name|data
expr_stmt|;
name|_rl_free_history_entry
argument_list|(
name|saved_line_for_history
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
block|}
else|else
name|ding
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Save the current line in saved_line_for_history. */
end_comment

begin_macro
name|maybe_save_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|saved_line_for_history
condition|)
block|{
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|rl_undo_list
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Meta-< goes to the start of the history. */
end_comment

begin_macro
name|rl_beginning_of_history
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|rl_get_previous_history
argument_list|(
literal|1
operator|+
name|where_history
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Meta-> goes to the end of the history.  (The current line). */
end_comment

begin_macro
name|rl_end_of_history
argument_list|()
end_macro

begin_block
block|{
name|maybe_replace_line
argument_list|()
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|maybe_unsave_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move down to the next history line. */
end_comment

begin_macro
name|rl_get_next_history
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_get_previous_history
argument_list|(
operator|-
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
name|maybe_replace_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|temp
operator|=
name|next_history
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
operator|--
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|temp
condition|)
name|maybe_unsave_line
argument_list|()
expr_stmt|;
else|else
block|{
name|int
name|line_len
decl_stmt|;
name|line_len
operator|=
name|strlen
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Get the previous item out of our interactive history, making it the current    line.  If there is no previous history, just ding. */
end_comment

begin_macro
name|rl_get_previous_history
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|old_temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_get_next_history
argument_list|(
operator|-
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
comment|/* If we don't have a line saved, then save this one. */
name|maybe_save_line
argument_list|()
expr_stmt|;
comment|/* If the current line has changed, save the changes. */
name|maybe_replace_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|temp
operator|=
name|previous_history
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
else|else
name|old_temp
operator|=
name|temp
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
comment|/* If there was a large argument, and we moved back to the start of the      history, that is not an error.  So use the last value found. */
if|if
condition|(
operator|!
name|temp
operator|&&
name|old_temp
condition|)
name|temp
operator|=
name|old_temp
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|int
name|line_len
decl_stmt|;
name|line_len
operator|=
name|strlen
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|line_len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Make C be the next command to be executed. */
end_comment

begin_macro
name|rl_execute_next
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_pending_input
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   The Mark and the Region.			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Set the mark at POSITION. */
end_comment

begin_macro
name|rl_set_mark
argument_list|(
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|position
operator|>
name|rl_end
condition|)
return|return
operator|-
literal|1
return|;
name|rl_mark
operator|=
name|position
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Exchange the position of mark and point. */
end_comment

begin_macro
name|rl_exchange_mark_and_point
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_mark
operator|>
name|rl_end
condition|)
name|rl_mark
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rl_mark
operator|==
operator|-
literal|1
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|int
name|temp
init|=
name|rl_point
decl_stmt|;
name|rl_point
operator|=
name|rl_mark
expr_stmt|;
name|rl_mark
operator|=
name|temp
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Killing Mechanism			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* What we assume for a max number of kills. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MAX_KILLS
value|10
end_define

begin_comment
comment|/* The real variable to look at to find out when to flush kills. */
end_comment

begin_decl_stmt
name|int
name|rl_max_kills
init|=
name|DEFAULT_MAX_KILLS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to store killed text. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rl_kill_ring
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where we are in the kill ring. */
end_comment

begin_decl_stmt
name|int
name|rl_kill_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many slots we have in the kill ring. */
end_comment

begin_decl_stmt
name|int
name|rl_kill_ring_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to say that you only want to save a certain amount    of kill material. */
end_comment

begin_macro
name|rl_set_retained_kills
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* The way to kill something.  This appends or prepends to the last    kill, if the last command was a kill command.  if FROM is less    than TO, then the text is appended, otherwise prepended.  If the    last command was not a kill command, then a new slot is made for    this kill. */
end_comment

begin_macro
name|rl_kill_text
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slot
decl_stmt|;
name|char
modifier|*
name|text
init|=
name|rl_copy_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
comment|/* Is there anything to kill? */
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|last_command_was_kill
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Delete the copied text from the line. */
name|rl_delete_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* First, find the slot to work with. */
if|if
condition|(
operator|!
name|last_command_was_kill
condition|)
block|{
comment|/* Get a new slot.  */
if|if
condition|(
operator|!
name|rl_kill_ring
condition|)
block|{
comment|/* If we don't have any defined, then make one. */
name|rl_kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|rl_kill_ring_length
operator|=
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We have to add a new slot on the end, unless we have 	     exceeded the max limit for remembering kills. */
name|slot
operator|=
name|rl_kill_ring_length
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|rl_max_kills
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|rl_kill_ring
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slot
condition|;
name|i
operator|++
control|)
name|rl_kill_ring
index|[
name|i
index|]
operator|=
name|rl_kill_ring
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|rl_kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|rl_kill_ring
argument_list|,
operator|(
operator|(
name|slot
operator|=
operator|(
name|rl_kill_ring_length
operator|+=
literal|1
operator|)
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|slot
operator|--
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|=
name|rl_kill_ring_length
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If the last command was a kill, prepend or append. */
if|if
condition|(
name|last_command_was_kill
operator|&&
name|rl_editing_mode
operator|!=
name|vi_mode
condition|)
block|{
name|char
modifier|*
name|old
init|=
name|rl_kill_ring
index|[
name|slot
index|]
decl_stmt|;
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|old
argument_list|)
operator|+
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|<
name|to
condition|)
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_kill_ring
index|[
name|slot
index|]
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|rl_kill_ring
index|[
name|slot
index|]
operator|=
name|text
expr_stmt|;
block|}
name|rl_kill_index
operator|=
name|slot
expr_stmt|;
name|last_command_was_kill
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Now REMEMBER!  In order to do prepending or appending correctly, kill    commands always make rl_point's original position be the FROM argument,    and rl_point's extent be the TO argument. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Killing Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Delete the word at point, saving the text in the kill ring. */
end_comment

begin_macro
name|rl_kill_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_kill_word
argument_list|(
operator|-
name|count
argument_list|)
operator|)
return|;
else|else
block|{
name|rl_forward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|!=
name|orig_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Rubout the word before point, placing it on the kill ring. */
end_comment

begin_macro
name|rl_backward_kill_word
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_kill_word
argument_list|(
operator|-
name|count
argument_list|)
operator|)
return|;
else|else
block|{
name|rl_backward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|!=
name|orig_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Kill from here to the end of the line.  If DIRECTION is negative, kill    back to the line start instead. */
end_comment

begin_macro
name|rl_kill_line
argument_list|(
argument|direction
argument_list|)
end_macro

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_kill_line
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
block|{
name|rl_end_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|orig_point
operator|!=
name|rl_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Kill backwards to the start of the line.  If DIRECTION is negative, kill    forwards to the line end instead. */
end_comment

begin_macro
name|rl_backward_kill_line
argument_list|(
argument|direction
argument_list|)
end_macro

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_kill_line
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Kill the whole line, no matter where point is. */
end_comment

begin_macro
name|rl_kill_full_line
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_end
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Yank back the last killed text.  This ignores arguments. */
end_comment

begin_macro
name|rl_yank
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|rl_kill_ring
condition|)
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_set_mark
argument_list|(
name|rl_point
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* If the last command was yank, or yank_pop, and the text just    before point is identical to the current kill item, then    delete that text from the line, rotate the index down, and    yank back some other text. */
end_comment

begin_macro
name|rl_yank_pop
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|rl_last_func
operator|!=
name|rl_yank_pop
operator|)
operator|&&
operator|(
name|rl_last_func
operator|!=
name|rl_yank
operator|)
operator|)
operator|||
operator|!
name|rl_kill_ring
condition|)
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rl_point
operator|-
name|l
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|the_line
operator|+
operator|(
name|rl_point
operator|-
name|l
operator|)
argument_list|,
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rl_delete_text
argument_list|(
operator|(
name|rl_point
operator|-
name|l
operator|)
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|-=
name|l
expr_stmt|;
name|rl_kill_index
operator|--
expr_stmt|;
if|if
condition|(
name|rl_kill_index
operator|<
literal|0
condition|)
name|rl_kill_index
operator|=
name|rl_kill_ring_length
operator|-
literal|1
expr_stmt|;
name|rl_yank
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|rl_abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_block

begin_comment
comment|/* Yank the COUNTth argument from the previous history line. */
end_comment

begin_macro
name|rl_yank_nth_arg
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|previous_history
argument_list|()
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|next_history
argument_list|()
expr_stmt|;
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|arg
operator|=
name|history_arg_extract
argument_list|(
name|count
argument_list|,
name|count
argument_list|,
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
comment|/* Vi mode always inserts a space before yanking the argument, and it      inserts it right *after* rl_point. */
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
block|{
name|rl_vi_append_mode
argument_list|()
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
name|rl_insert_text
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* How to toggle back and forth between editing modes. */
end_comment

begin_macro
name|rl_vi_editing_mode
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|rl_editing_mode
operator|=
name|vi_mode
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
end_block

begin_macro
name|rl_emacs_editing_mode
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_editing_mode
operator|=
name|emacs_mode
expr_stmt|;
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			USG (System V) Support			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
name|rl_getc
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
name|getkey
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* __GO32__ */
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* If zero characters are returned, then the file that we are 	 reading from is empty!  Return EOF in that case. */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_NDELAY
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* EWOULDBLOCK */
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|EAGAIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* _POSIX_VERSION&& EAGAIN&& O_NONBLOCK */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
comment|/* If the error that we received was SIGINT, then try again, 	 this is simply an interrupted system call to read (). 	 Otherwise, some error ocurred, also signifying EOF. */
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_MALLOC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Testing Readline			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
end_if

begin_function
name|main
parameter_list|()
block|{
name|HIST_ENTRY
modifier|*
modifier|*
name|history_list
parameter_list|()
function_decl|;
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
literal|"readline% "
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|temp
operator|=
name|readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
comment|/* Test for EOF. */
if|if
condition|(
operator|!
name|temp
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If there is anything on the line, print it and remember it. */
if|if
condition|(
operator|*
name|temp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\r\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|add_history
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* Check for `command' that we handle. */
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|HIST_ENTRY
modifier|*
modifier|*
name|list
init|=
name|history_list
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: %s\r\n"
argument_list|,
name|i
argument_list|,
name|list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Local variables:  * compile-command: "gcc -g -traditional -I. -I.. -DTEST -o readline readline.c keymaps.o funmap.o history.o -ltermcap"  * end:  */
end_comment

end_unit

