begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_probab_prime_p --    An implementation of the probabilistic primality test found in Knuth's    Seminumerical Algorithms book.  If the function mpz_probab_prime_p()    returns 0 then n is not prime.  If it returns 1, then n is 'probably'    prime.  The probability of a false positive is (1/4)**reps, where    reps is the number of internal passes of the probabilistic algorithm.    Knuth indicates that 25 passes are reasonable.  Copyright (C) 1991 Free Software Foundation, Inc. Contributed by John Amanatides.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_function
specifier|static
name|int
name|possibly_prime
parameter_list|(
name|n
parameter_list|,
name|n_minus_1
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|q
parameter_list|,
name|k
parameter_list|)
name|MP_INT
modifier|*
name|n
decl_stmt|,
decl|*
name|n_minus_1
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* find random x s.t. 1< x< n */
do|do
block|{
name|mpz_random
argument_list|(
name|x
argument_list|,
name|mpz_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|mpz_mmod
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mpz_cmp_ui
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
do|;
name|mpz_powm
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|mpz_cmp
argument_list|(
name|y
argument_list|,
name|n_minus_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|mpz_powm_ui
argument_list|(
name|y
argument_list|,
name|y
argument_list|,
literal|2
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_cmp
argument_list|(
name|y
argument_list|,
name|n_minus_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|mpz_probab_prime_p
parameter_list|(
name|m
parameter_list|,
name|reps
parameter_list|)
specifier|const
name|MP_INT
modifier|*
name|m
decl_stmt|;
name|int
name|reps
decl_stmt|;
block|{
name|MP_INT
name|n
decl_stmt|,
name|n_minus_1
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|is_prime
decl_stmt|;
name|mpz_init
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* Take the absolute value of M, to handle positive and negative primes.  */
name|mpz_abs
argument_list|(
operator|&
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
operator|&
name|n
argument_list|,
literal|3
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
operator|&
name|n
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* smallest prime is 2 */
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|mpz_get_ui
argument_list|(
operator|&
name|n
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* even */
name|mpz_init
argument_list|(
operator|&
name|n_minus_1
argument_list|)
expr_stmt|;
name|mpz_sub_ui
argument_list|(
operator|&
name|n_minus_1
argument_list|,
operator|&
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* find q and k, s.t.  n = 1 + 2**k * q */
name|mpz_init_set
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|n_minus_1
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|mpz_get_ui
argument_list|(
operator|&
name|q
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|k
operator|++
expr_stmt|;
name|mpz_div_2exp
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|is_prime
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|&&
name|is_prime
condition|;
name|i
operator|++
control|)
name|is_prime
operator|&=
name|possibly_prime
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|n_minus_1
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|q
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
operator|&
name|n_minus_1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
operator|&
name|y
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
return|return
name|is_prime
return|;
block|}
end_function

end_unit

