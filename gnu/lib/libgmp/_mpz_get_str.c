begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* _mpz_get_str (string, base, mp_src) -- Convert the multiple precision    number MP_SRC to a string STRING of base BASE.  If STRING is NULL    allocate space for the result.  In any case, return a pointer to the    result.  If STRING is not NULL, the caller must ensure enough space is    available to store the result.  Copyright (C) 1991, 1993 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|UMUL_TIME
end_ifndef

begin_define
define|#
directive|define
name|UMUL_TIME
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UDIV_TIME
end_ifndef

begin_define
define|#
directive|define
name|UDIV_TIME
value|UMUL_TIME
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|udiv_qrnndx
parameter_list|(
name|q
parameter_list|,
name|r
parameter_list|,
name|nh
parameter_list|,
name|nl
parameter_list|,
name|d
parameter_list|,
name|di
parameter_list|)
define|\
value|do {									\     unsigned long int _q, _ql, _r;					\     unsigned long int _xh, _xl;						\     umul_ppmm (_q, _ql, (nh), (di));					\     _q += (nh);
comment|/* DI is 2**32 too small.  Compensate */
value|\     if (_q< (nh))							\       {									\
comment|/* Got carry.  Propagate it in the multiplication.  */
value|\ 	umul_ppmm (_xh, _xl, (d), _q);					\ 	_xh += (d);							\       }									\     else								\       umul_ppmm (_xh, _xl, (d), _q);					\     sub_ddmmss (_xh, _r, (nh), (nl), _xh, _xl);				\     if (_xh != 0)							\       {									\ 	sub_ddmmss (_xh, _r, _xh, _r, 0, (d));				\ 	_q += 1;							\ 	if (_xh != 0)							\ 	  {								\ 	    sub_ddmmss (_xh, _r, _xh, _r, 0, (d));			\ 	    _q += 1;							\ 	  }								\       }									\     if (_r>= (d))							\       {									\ 	_r -= (d);							\ 	_q += 1;							\       }									\     (r) = _r;								\     (q) = _q;								\   } while (0)
end_define

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|_mpz_get_str
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|base
parameter_list|,
specifier|const
name|MP_INT
modifier|*
name|m
parameter_list|)
else|#
directive|else
function|_mpz_get_str
parameter_list|(
name|str
parameter_list|,
name|base
parameter_list|,
name|m
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
specifier|const
name|MP_INT
modifier|*
name|m
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_ptr
name|tp
decl_stmt|;
name|mp_size
name|msize
decl_stmt|;
name|mp_limb
name|big_base
decl_stmt|;
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|int
name|normalization_steps
decl_stmt|;
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|mp_limb
name|big_base_inverted
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|unsigned
name|int
name|dig_per_u
decl_stmt|;
name|mp_size
name|out_len
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|num_to_ascii
decl_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
literal|10
expr_stmt|;
name|num_to_ascii
operator|=
literal|"0123456789abcdefghijklmnopqrstuvwxyz"
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
operator|-
name|base
expr_stmt|;
name|num_to_ascii
operator|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
expr_stmt|;
block|}
name|dig_per_u
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_limb
expr_stmt|;
name|out_len
operator|=
name|mpz_sizeinbase
argument_list|(
name|m
argument_list|,
name|base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|big_base
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|big_base
expr_stmt|;
name|msize
operator|=
name|m
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|str
operator|=
operator|(
name|char
operator|*
operator|)
call|(
modifier|*
name|_mp_allocate_func
call|)
argument_list|(
name|out_len
operator|+
operator|(
name|msize
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msize
operator|<
literal|0
condition|)
operator|*
name|str
operator|++
operator|=
literal|'-'
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
name|msize
operator|=
name|ABS
argument_list|(
name|msize
argument_list|)
expr_stmt|;
comment|/* Special case zero, as the code below doesn't handle it.  */
if|if
condition|(
name|msize
operator|==
literal|0
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
if|if
condition|(
operator|(
name|base
operator|&
operator|(
name|base
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The base is a power of 2.  Make conversion from most 	 significant side.  */
name|mp_limb
name|n1
decl_stmt|,
name|n0
decl_stmt|;
name|int
name|bits_per_digit
init|=
name|big_base
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|bit_pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|mask
init|=
operator|(
literal|1
operator|<<
name|bits_per_digit
operator|)
operator|-
literal|1
decl_stmt|;
name|tp
operator|=
name|m
operator|->
name|d
expr_stmt|;
name|n1
operator|=
name|tp
index|[
name|msize
operator|-
literal|1
index|]
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|x
argument_list|,
name|n1
argument_list|)
expr_stmt|;
comment|/* BIT_POS should be R when input ends in least sign. nibble, 	   R + bits_per_digit * n when input ends in n:th least significant 	   nibble. */
block|{
name|int
name|bits
decl_stmt|;
name|bits
operator|=
name|BITS_PER_MP_LIMB
operator|*
name|msize
operator|-
name|x
expr_stmt|;
name|x
operator|=
name|bits
operator|%
name|bits_per_digit
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|bits
operator|+=
name|bits_per_digit
operator|-
name|x
expr_stmt|;
name|bit_pos
operator|=
name|bits
operator|-
operator|(
name|msize
operator|-
literal|1
operator|)
operator|*
name|BITS_PER_MP_LIMB
expr_stmt|;
block|}
comment|/* Fast loop for bit output.  */
name|i
operator|=
name|msize
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bit_pos
operator|-=
name|bits_per_digit
expr_stmt|;
while|while
condition|(
name|bit_pos
operator|>=
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
name|num_to_ascii
index|[
operator|(
name|n1
operator|>>
name|bit_pos
operator|)
operator|&
name|mask
index|]
expr_stmt|;
name|bit_pos
operator|-=
name|bits_per_digit
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
name|n0
operator|=
operator|(
name|n1
operator|<<
operator|-
name|bit_pos
operator|)
operator|&
name|mask
expr_stmt|;
name|n1
operator|=
name|tp
index|[
name|i
index|]
expr_stmt|;
name|bit_pos
operator|+=
name|BITS_PER_MP_LIMB
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|num_to_ascii
index|[
name|n0
operator||
operator|(
name|n1
operator|>>
name|bit_pos
operator|)
index|]
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* General case.  The base is not a power of 2.  Make conversion 	 from least significant end.  */
comment|/* If udiv_qrnnd only handles divisors with the most significant bit 	 set, prepare BIG_BASE for being a divisor by shifting it to the 	 left exactly enough to set the most significant bit.  */
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|big_base
argument_list|)
expr_stmt|;
name|big_base
operator|<<=
name|normalization_steps
expr_stmt|;
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
comment|/* Get the fixed-point approximation to 1/BIG_BASE.  */
name|big_base_inverted
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|big_base_inverted
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|out_len
operator|--
expr_stmt|;
comment|/* now not include terminating \0 */
name|s
operator|+=
name|out_len
expr_stmt|;
comment|/* Allocate temporary space and move the multi prec number to 	 convert there, as we need to overwrite it below, while 	 computing the successive remainders.  */
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
operator|(
name|msize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|m
operator|->
name|d
argument_list|,
name|msize
argument_list|)
expr_stmt|;
while|while
condition|(
name|msize
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|mp_limb
name|n0
decl_stmt|,
name|n1
decl_stmt|;
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
comment|/* If we shifted BIG_BASE above, shift the dividend too, to get 	     the right quotient.  We need to do this every loop, 	     as the intermediate quotients are OK, but the quotient from 	     one turn in the loop is going to be the dividend in the 	     next turn, and the dividend needs to be up-shifted.  */
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|n0
operator|=
name|mpn_lshift
argument_list|(
name|tp
argument_list|,
name|tp
argument_list|,
name|msize
argument_list|,
name|normalization_steps
argument_list|)
expr_stmt|;
comment|/* If the shifting gave a carry out limb, store it and 		 increase the length.  */
if|if
condition|(
name|n0
operator|!=
literal|0
condition|)
block|{
name|tp
index|[
name|msize
index|]
operator|=
name|n0
expr_stmt|;
name|msize
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Divide the number at TP with BIG_BASE to get a quotient and a 	     remainder.  The remainder is our new digit in base BIG_BASE.  */
name|i
operator|=
name|msize
operator|-
literal|1
expr_stmt|;
name|n1
operator|=
name|tp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|n1
operator|>=
name|big_base
condition|)
name|n1
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|msize
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|tp
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|udiv_qrnndx
argument_list|(
name|tp
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|big_base
argument_list|,
name|big_base_inverted
argument_list|)
expr_stmt|;
else|#
directive|else
name|udiv_qrnnd
argument_list|(
name|tp
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|big_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
comment|/* If we shifted above (at previous UDIV_NEEDS_NORMALIZATION tests) 	     the remainder will be up-shifted here.  Compensate.  */
name|n1
operator|>>=
name|normalization_steps
expr_stmt|;
endif|#
directive|endif
comment|/* Convert N1 from BIG_BASE to a string of digits in BASE 	     using single precision operations.  */
for|for
control|(
name|i
operator|=
name|dig_per_u
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
operator|--
name|s
operator|=
name|num_to_ascii
index|[
name|n1
operator|%
name|base
index|]
expr_stmt|;
name|n1
operator|/=
name|base
expr_stmt|;
comment|/* Break from the loop as soon as we would only write zeros.  */
if|if
condition|(
name|n1
operator|==
literal|0
operator|&&
name|msize
operator|==
literal|0
condition|)
break|break;
block|}
block|}
comment|/* There should be no leading zeros.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|str
condition|)
block|{
comment|/* This should be the common case.  */
name|s
index|[
name|out_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|str
operator|+
literal|1
condition|)
block|{
comment|/* The string became 1 digit shorter than its maximum.  */
comment|/* Need to copy it back one char pos.  */
name|out_len
operator|--
expr_stmt|;
ifndef|#
directive|ifndef
name|HAS_MEMMOVE
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|out_len
condition|;
name|i
operator|++
control|)
name|str
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
else|#
directive|else
name|memmove
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|out_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str
index|[
name|out_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Hopefully never.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Ugly, we incremented str for negative numbers.  Fix that here.  */
return|return
name|str
operator|-
operator|(
name|m
operator|->
name|size
operator|<
literal|0
operator|)
return|;
block|}
end_function

end_unit

