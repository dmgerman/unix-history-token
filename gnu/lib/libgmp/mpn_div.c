begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_div -- Divide natural numbers, producing both remainder and    quotient.  Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* Divide num (NUM_PTR/NUM_SIZE) by den (DEN_PTR/DEN_SIZE) and write    the quotient at QUOT_PTR and the remainder at NUM_PTR.     Return 0 or 1, depending on if the quotient size is (NSIZE - DSIZE)    or (NSIZE - DSIZE + 1).     Argument constraints:    1. The most significant bit of d must be set.    2. QUOT_PTR != DEN_PTR and QUOT_PTR != NUM_PTR, i.e. the quotient storage       area must be distinct from either input operands.     The exact sizes of the quotient and remainder must be determined    by the caller, in spite of the return value.  The return value just    informs the caller about if the highest digit is written or not, and    it may very well be 0.  */
end_comment

begin_comment
comment|/* THIS WILL BE IMPROVED SOON.  MORE COMMENTS AND FASTER CODE.  */
end_comment

begin_function
name|mp_size
ifdef|#
directive|ifdef
name|__STDC__
name|mpn_div
parameter_list|(
name|mp_ptr
name|quot_ptr
parameter_list|,
name|mp_ptr
name|num_ptr
parameter_list|,
name|mp_size
name|num_size
parameter_list|,
name|mp_srcptr
name|den_ptr
parameter_list|,
name|mp_size
name|den_size
parameter_list|)
else|#
directive|else
function|mpn_div
parameter_list|(
name|quot_ptr
parameter_list|,
name|num_ptr
parameter_list|,
name|num_size
parameter_list|,
name|den_ptr
parameter_list|,
name|den_size
parameter_list|)
name|mp_ptr
name|quot_ptr
decl_stmt|;
name|mp_ptr
name|num_ptr
decl_stmt|;
name|mp_size
name|num_size
decl_stmt|;
name|mp_srcptr
name|den_ptr
decl_stmt|;
name|mp_size
name|den_size
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size
name|q_is_long
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|den_size
condition|)
block|{
case|case
literal|0
case|:
comment|/* We are asked to divide by zero, so go ahead and do it! 	 (To make the compiler not remove this statement, assign NUM_SIZE 	 and fall through.)  */
name|num_size
operator|=
literal|1
operator|/
name|den_size
expr_stmt|;
case|case
literal|1
case|:
block|{
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|n1
decl_stmt|,
name|n0
decl_stmt|;
name|mp_limb
name|d
decl_stmt|;
name|d
operator|=
name|den_ptr
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
name|num_size
operator|-
literal|1
expr_stmt|;
name|n1
operator|=
name|num_ptr
index|[
name|i
index|]
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|n1
operator|>=
name|d
condition|)
block|{
name|q_is_long
operator|=
literal|1
expr_stmt|;
name|n1
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|num_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|quot_ptr
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|num_ptr
index|[
literal|0
index|]
operator|=
name|n1
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|n0
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|mp_limb
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|num_ptr
operator|+=
name|num_size
operator|-
literal|2
expr_stmt|;
name|d0
operator|=
name|den_ptr
index|[
literal|1
index|]
expr_stmt|;
name|d1
operator|=
name|den_ptr
index|[
literal|0
index|]
expr_stmt|;
name|n0
operator|=
name|num_ptr
index|[
literal|1
index|]
expr_stmt|;
name|n1
operator|=
name|num_ptr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n0
operator|>=
name|d0
condition|)
block|{
name|q_is_long
operator|=
literal|1
expr_stmt|;
name|n1
operator|=
name|n0
expr_stmt|;
name|n0
operator|=
literal|0
expr_stmt|;
name|num_ptr
operator|++
expr_stmt|;
name|num_size
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|num_size
operator|-
name|den_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mp_limb
name|q
decl_stmt|;
name|mp_limb
name|r
decl_stmt|;
name|num_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|n0
operator|==
name|d0
condition|)
block|{
comment|/* Q should be either 111..111 or 111..110.  Need special 		   treatment of this rare case as normal division would 		   give overflow.  */
name|q
operator|=
operator|~
literal|0
expr_stmt|;
name|r
operator|=
name|n1
operator|+
name|d0
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|d0
condition|)
comment|/* Carry in the addition? */
block|{
name|n2
operator|=
name|num_ptr
index|[
literal|0
index|]
expr_stmt|;
name|add_ssaaaa
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|r
operator|-
name|d1
argument_list|,
name|n2
argument_list|,
literal|0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|quot_ptr
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
continue|continue;
block|}
name|n0
operator|=
name|d1
operator|-
operator|(
name|d1
operator|!=
literal|0
operator|)
expr_stmt|;
name|n1
operator|=
operator|-
name|d1
expr_stmt|;
block|}
else|else
block|{
name|udiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|d1
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|n2
operator|=
name|num_ptr
index|[
literal|0
index|]
expr_stmt|;
name|q_test
label|:
if|if
condition|(
name|n0
operator|>
name|r
operator|||
operator|(
name|n0
operator|==
name|r
operator|&&
name|n1
operator|>
name|n2
operator|)
condition|)
block|{
comment|/* The estimated Q was too large.  */
name|q
operator|--
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
literal|0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|r
operator|+=
name|d0
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|d0
condition|)
comment|/* If not carry, test q again.  */
goto|goto
name|q_test
goto|;
block|}
name|quot_ptr
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|r
argument_list|,
name|n2
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|)
expr_stmt|;
block|}
name|num_ptr
index|[
literal|1
index|]
operator|=
name|n0
expr_stmt|;
name|num_ptr
index|[
literal|0
index|]
operator|=
name|n1
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|d0
init|=
name|den_ptr
index|[
name|den_size
operator|-
literal|1
index|]
decl_stmt|;
name|mp_limb
name|d1
init|=
name|den_ptr
index|[
name|den_size
operator|-
literal|2
index|]
decl_stmt|;
name|mp_limb
name|n0
init|=
name|num_ptr
index|[
name|num_size
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|ugly_hack_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n0
operator|>=
name|d0
condition|)
block|{
comment|/* There's a problem with this case, which shows up later in the 	       code.  q becomes 1 (and sometimes 0) the first time when 	       we've been here, and w_cy == 0 after the main do-loops below. 	       But c = num_ptr[j] reads rubbish outside the num_ptr vector! 	       Maybe I can solve this cleanly when I fix the early-end 	       optimization here in the default case.  For now, I change the 	       add_back entering condition, to kludge.  Leaving the stray 	       memref behind!  	       HACK: Added ugly_hack_flag to make it work.  */
name|q_is_long
operator|=
literal|1
expr_stmt|;
name|n0
operator|=
literal|0
expr_stmt|;
name|num_size
operator|++
expr_stmt|;
name|ugly_hack_flag
operator|=
literal|1
expr_stmt|;
block|}
name|num_ptr
operator|+=
name|num_size
expr_stmt|;
name|den_ptr
operator|+=
name|den_size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_size
operator|-
name|den_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mp_limb
name|q
decl_stmt|;
name|mp_limb
name|n1
decl_stmt|;
name|mp_limb
name|w_cy
decl_stmt|;
name|mp_limb
name|d
decl_stmt|,
name|c
decl_stmt|;
name|mp_size
name|j
decl_stmt|;
name|num_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|n0
operator|==
name|d0
condition|)
comment|/* This might over-estimate q, but it's probably not worth 		 the extra code here to find out.  */
name|q
operator|=
operator|~
literal|0
expr_stmt|;
else|else
block|{
name|mp_limb
name|r
decl_stmt|;
name|udiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|num_ptr
index|[
operator|-
literal|1
index|]
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|,
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|n1
operator|>
name|r
operator|||
operator|(
name|n1
operator|==
name|r
operator|&&
name|n0
operator|>
name|num_ptr
index|[
operator|-
literal|2
index|]
operator|)
condition|)
block|{
name|q
operator|--
expr_stmt|;
name|r
operator|+=
name|d0
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|d0
condition|)
comment|/* I.e. "carry in previous addition?"  */
break|break;
name|n1
operator|-=
name|n0
operator|<
name|d1
expr_stmt|;
name|n0
operator|-=
name|d1
expr_stmt|;
block|}
block|}
name|w_cy
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|-
name|den_size
expr_stmt|;
do|do
block|{
name|d
operator|=
name|den_ptr
index|[
name|j
index|]
expr_stmt|;
name|c
operator|=
name|num_ptr
index|[
name|j
index|]
expr_stmt|;
name|umul_ppmm
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|d
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|n0
operator|+=
name|w_cy
expr_stmt|;
name|w_cy
operator|=
operator|(
name|n0
operator|<
name|w_cy
operator|)
operator|+
name|n1
expr_stmt|;
name|n0
operator|=
name|c
operator|-
name|n0
expr_stmt|;
name|num_ptr
index|[
name|j
index|]
operator|=
name|n0
expr_stmt|;
if|if
condition|(
name|n0
operator|>
name|c
condition|)
goto|goto
name|cy_loop
goto|;
name|ncy_loop
label|:
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|ugly_hack_flag
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|ugly_hack_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c
operator|=
name|num_ptr
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|w_cy
condition|)
goto|goto
name|store_q
goto|;
goto|goto
name|add_back
goto|;
do|do
block|{
name|d
operator|=
name|den_ptr
index|[
name|j
index|]
expr_stmt|;
name|c
operator|=
name|num_ptr
index|[
name|j
index|]
expr_stmt|;
name|umul_ppmm
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|d
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|n0
operator|+=
name|w_cy
expr_stmt|;
name|w_cy
operator|=
operator|(
name|n0
operator|<
name|w_cy
operator|)
operator|+
name|n1
expr_stmt|;
name|n0
operator|=
name|c
operator|-
name|n0
operator|-
literal|1
expr_stmt|;
name|num_ptr
index|[
name|j
index|]
operator|=
name|n0
expr_stmt|;
if|if
condition|(
name|n0
operator|<
name|c
condition|)
goto|goto
name|ncy_loop
goto|;
name|cy_loop
label|:
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|ugly_hack_flag
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|ugly_hack_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c
operator|=
name|num_ptr
index|[
name|j
index|]
expr_stmt|;
name|w_cy
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|w_cy
condition|)
goto|goto
name|store_q
goto|;
name|add_back
label|:
name|j
operator|=
operator|-
name|den_size
expr_stmt|;
do|do
block|{
name|d
operator|=
name|den_ptr
index|[
name|j
index|]
expr_stmt|;
name|n0
operator|=
name|num_ptr
index|[
name|j
index|]
operator|+
name|d
expr_stmt|;
name|num_ptr
index|[
name|j
index|]
operator|=
name|n0
expr_stmt|;
if|if
condition|(
name|n0
operator|<
name|d
condition|)
goto|goto
name|ab_cy_loop
goto|;
name|ab_ncy_loop
label|:
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
literal|0
condition|)
do|;
name|abort
argument_list|()
expr_stmt|;
comment|/* We should always have a carry out! */
do|do
block|{
name|d
operator|=
name|den_ptr
index|[
name|j
index|]
expr_stmt|;
name|n0
operator|=
name|num_ptr
index|[
name|j
index|]
operator|+
name|d
operator|+
literal|1
expr_stmt|;
name|num_ptr
index|[
name|j
index|]
operator|=
name|n0
expr_stmt|;
if|if
condition|(
name|n0
operator|>
name|d
condition|)
goto|goto
name|ab_ncy_loop
goto|;
name|ab_cy_loop
label|:
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
literal|0
condition|)
do|;
name|q
operator|--
expr_stmt|;
name|store_q
label|:
name|quot_ptr
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
return|return
name|q_is_long
return|;
block|}
end_function

end_unit

