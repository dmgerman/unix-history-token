begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_divmod_1(quot_ptr, dividend_ptr, dividend_size, divisor_limb) --    Divide (DIVIDEND_PTR,,DIVIDEND_SIZE) by DIVISOR_LIMB.    Write DIVIDEND_SIZE limbs of quotient at QUOT_PTR.    Return the single-limb remainder.    There are no constraints on the value of the divisor.     QUOT_PTR and DIVIDEND_PTR might point to the same limb.  Copyright (C) 1991, 1993 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|UMUL_TIME
end_ifndef

begin_define
define|#
directive|define
name|UMUL_TIME
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UDIV_TIME
end_ifndef

begin_define
define|#
directive|define
name|UDIV_TIME
value|UMUL_TIME
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
end_if

begin_undef
undef|#
directive|undef
name|UDIV_NEEDS_NORMALIZATION
end_undef

begin_define
define|#
directive|define
name|UDIV_NEEDS_NORMALIZATION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|udiv_qrnnd_preinv
parameter_list|(
name|q
parameter_list|,
name|r
parameter_list|,
name|nh
parameter_list|,
name|nl
parameter_list|,
name|d
parameter_list|,
name|di
parameter_list|)
define|\
value|do {									\     unsigned long int _q, _ql, _r;					\     unsigned long int _xh, _xl;						\     umul_ppmm (_q, _ql, (nh), (di));					\     _q += (nh);
comment|/* DI is 2**BITS_PER_MP_LIMB too small.  */
value|\     umul_ppmm (_xh, _xl, _q, (d));					\     sub_ddmmss (_xh, _r, (nh), (nl), _xh, _xl);				\     if (_xh != 0)							\       {									\ 	sub_ddmmss (_xh, _r, _xh, _r, 0, (d));				\ 	_q += 1;							\ 	if (_xh != 0)							\ 	  {								\ 	    sub_ddmmss (_xh, _r, _xh, _r, 0, (d));			\ 	    _q += 1;							\ 	  }								\       }									\     if (_r>= (d))							\       {									\ 	_r -= (d);							\ 	_q += 1;							\       }									\     (r) = _r;								\     (q) = _q;								\   } while (0)
end_define

begin_function
name|mp_limb
ifdef|#
directive|ifdef
name|__STDC__
name|mpn_divmod_1
parameter_list|(
name|mp_ptr
name|quot_ptr
parameter_list|,
name|mp_srcptr
name|dividend_ptr
parameter_list|,
name|mp_size
name|dividend_size
parameter_list|,
name|unsigned
name|long
name|int
name|divisor_limb
parameter_list|)
else|#
directive|else
function|mpn_divmod_1
parameter_list|(
name|quot_ptr
parameter_list|,
name|dividend_ptr
parameter_list|,
name|dividend_size
parameter_list|,
name|divisor_limb
parameter_list|)
name|mp_ptr
name|quot_ptr
decl_stmt|;
name|mp_srcptr
name|dividend_ptr
decl_stmt|;
name|mp_size
name|dividend_size
decl_stmt|;
name|unsigned
name|long
name|int
name|divisor_limb
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|n1
decl_stmt|,
name|n0
decl_stmt|,
name|r
decl_stmt|;
comment|/* Botch: Should this be handled at all?  Rely on callers?  */
if|if
condition|(
name|dividend_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|UDIV_NEEDS_NORMALIZATION
condition|)
block|{
name|int
name|normalization_steps
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|divisor_limb
operator|<<=
name|normalization_steps
expr_stmt|;
name|n1
operator|=
name|dividend_ptr
index|[
name|dividend_size
operator|-
literal|1
index|]
expr_stmt|;
name|r
operator|=
name|n1
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
expr_stmt|;
comment|/* Possible optimization: 	     if (r == 0&& divisor_limb> ((n1<< normalization_steps) 			     | (dividend_ptr[dividend_size - 2]>> ...))) 	     ...one division less... 	     [Don't forget to zero most sign. quotient limb!]  */
comment|/* If multiplication is much faster than division, and the 	     dividend is large, pre-invert the divisor, and use 	     only multiplications in the inner loop.  */
if|if
condition|(
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
operator|&&
name|dividend_size
operator|>=
literal|4
condition|)
block|{
name|mp_limb
name|divisor_limb_inverted
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|/* Compute (2**64 - 2**32 * DIVISOR_LIMB) / DIVISOR_LIMB. 		 The result is an 33-bit approximation to 1/DIVISOR_LIMB, 		 with the most significant bit (weight 2**32) implicit.  */
comment|/* Special case for DIVISOR_LIMB == 100...000.  */
if|if
condition|(
name|divisor_limb
operator|<<
literal|1
operator|==
literal|0
condition|)
name|divisor_limb_inverted
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|udiv_qrnnd
argument_list|(
name|divisor_limb_inverted
argument_list|,
name|dummy
argument_list|,
operator|-
name|divisor_limb
argument_list|,
literal|0
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dividend_size
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd_preinv
argument_list|(
name|quot_ptr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
operator|(
operator|(
name|n1
operator|<<
name|normalization_steps
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
operator|)
operator|)
argument_list|,
name|divisor_limb
argument_list|,
name|divisor_limb_inverted
argument_list|)
expr_stmt|;
name|n1
operator|=
name|n0
expr_stmt|;
block|}
name|udiv_qrnnd_preinv
argument_list|(
name|quot_ptr
index|[
literal|0
index|]
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n1
operator|<<
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|,
name|divisor_limb_inverted
argument_list|)
expr_stmt|;
return|return
name|r
operator|>>
name|normalization_steps
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|dividend_size
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|quot_ptr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
operator|(
operator|(
name|n1
operator|<<
name|normalization_steps
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
operator|)
operator|)
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
name|n1
operator|=
name|n0
expr_stmt|;
block|}
name|udiv_qrnnd
argument_list|(
name|quot_ptr
index|[
literal|0
index|]
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n1
operator|<<
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
return|return
name|r
operator|>>
name|normalization_steps
return|;
block|}
block|}
block|}
comment|/* No normalization needed, either because udiv_qrnnd doesn't require      it, or because DIVISOR_LIMB is already normalized.  */
name|i
operator|=
name|dividend_size
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|divisor_limb
condition|)
block|{
name|r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Callers expect the quotient to be DIVIDEND_SIZE limbs.  Store 	 a leading zero to make that expectation come true.  */
name|quot_ptr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|quot_ptr
index|[
name|i
index|]
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

end_unit

