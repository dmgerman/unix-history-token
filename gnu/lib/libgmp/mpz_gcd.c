begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_gcd -- Calculate the greatest common divisior of two integers.  Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BERKELEY_MP
end_ifndef

begin_decl_stmt
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|mpz_gcd
argument_list|(
name|MP_INT
operator|*
name|w
argument_list|,
specifier|const
name|MP_INT
operator|*
name|u
argument_list|,
specifier|const
name|MP_INT
operator|*
name|v
argument_list|)
else|#
directive|else
name|mpz_gcd
argument_list|(
name|w
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
name|MP_INT
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|MP_INT
modifier|*
name|u
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|MP_INT
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BERKELEY_MP */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|gcd
parameter_list|(
specifier|const
name|MP_INT
modifier|*
name|u
parameter_list|,
specifier|const
name|MP_INT
modifier|*
name|v
parameter_list|,
name|MP_INT
modifier|*
name|w
parameter_list|)
else|#
directive|else
function|gcd
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|,
name|w
parameter_list|)
specifier|const
name|MP_INT
modifier|*
name|u
decl_stmt|;
specifier|const
name|MP_INT
modifier|*
name|v
decl_stmt|;
name|MP_INT
modifier|*
name|w
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BERKELEY_MP */
block|{
name|mp_size
name|usize
decl_stmt|,
name|vsize
decl_stmt|,
name|wsize
decl_stmt|;
name|mp_ptr
name|up_in
decl_stmt|,
name|vp_in
decl_stmt|;
name|mp_ptr
name|up
decl_stmt|,
name|vp
decl_stmt|;
name|mp_ptr
name|wp
decl_stmt|;
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|d
decl_stmt|;
name|int
name|bcnt
decl_stmt|;
name|mp_size
name|w_bcnt
decl_stmt|;
name|mp_limb
name|cy_digit
decl_stmt|;
name|usize
operator|=
name|ABS
argument_list|(
name|u
operator|->
name|size
argument_list|)
expr_stmt|;
name|vsize
operator|=
name|ABS
argument_list|(
name|v
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* GCD(0,v) == v.  */
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|alloc
operator|<
name|vsize
condition|)
name|_mpz_realloc
argument_list|(
name|w
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|w
operator|->
name|size
operator|=
name|vsize
expr_stmt|;
name|MPN_COPY
argument_list|(
name|w
operator|->
name|d
argument_list|,
name|v
operator|->
name|d
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* GCD(0,u) == u.  */
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|alloc
operator|<
name|usize
condition|)
name|_mpz_realloc
argument_list|(
name|w
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|w
operator|->
name|size
operator|=
name|usize
expr_stmt|;
name|MPN_COPY
argument_list|(
name|w
operator|->
name|d
argument_list|,
name|u
operator|->
name|d
argument_list|,
name|usize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make U odd by shifting it down as many bit positions as there      are zero bits.  Put the result in temporary space.  */
name|up
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
name|usize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|up_in
operator|=
name|u
operator|->
name|d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|d
operator|=
name|up_in
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|count_leading_zeros
argument_list|(
name|bcnt
argument_list|,
name|d
operator|&
operator|-
name|d
argument_list|)
expr_stmt|;
name|bcnt
operator|=
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|-
name|bcnt
expr_stmt|;
name|usize
operator|=
name|mpn_rshift
argument_list|(
name|up
argument_list|,
name|up_in
operator|+
name|i
argument_list|,
name|usize
operator|-
name|i
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
name|bcnt
operator|+=
name|i
operator|*
name|BITS_PER_MP_LIMB
expr_stmt|;
name|w_bcnt
operator|=
name|bcnt
expr_stmt|;
comment|/* Make V odd by shifting it down as many bit positions as there      are zero bits.  Put the result in temporary space.  */
name|vp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
name|vsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|vp_in
operator|=
name|v
operator|->
name|d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|d
operator|=
name|vp_in
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|count_leading_zeros
argument_list|(
name|bcnt
argument_list|,
name|d
operator|&
operator|-
name|d
argument_list|)
expr_stmt|;
name|bcnt
operator|=
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|-
name|bcnt
expr_stmt|;
name|vsize
operator|=
name|mpn_rshift
argument_list|(
name|vp
argument_list|,
name|vp_in
operator|+
name|i
argument_list|,
name|vsize
operator|-
name|i
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
comment|/* W_BCNT is set to the minimum of the number of zero bits in U and V.      Thus it represents the number of common 2 factors.  */
name|bcnt
operator|+=
name|i
operator|*
name|BITS_PER_MP_LIMB
expr_stmt|;
if|if
condition|(
name|bcnt
operator|<
name|w_bcnt
condition|)
name|w_bcnt
operator|=
name|bcnt
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|usize
operator|-
name|vsize
operator|!=
literal|0
condition|?
name|usize
operator|-
name|vsize
else|:
name|mpn_cmp
argument_list|(
name|up
argument_list|,
name|vp
argument_list|,
name|usize
argument_list|)
expr_stmt|;
comment|/* If U and V have become equal, we have found the GCD.  */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|/* Replace U by (U - V)>> cnt, with cnt being the least value 	     making U odd again.  */
name|usize
operator|+=
name|mpn_sub
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|d
operator|=
name|up
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|count_leading_zeros
argument_list|(
name|bcnt
argument_list|,
name|d
operator|&
operator|-
name|d
argument_list|)
expr_stmt|;
name|bcnt
operator|=
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|-
name|bcnt
expr_stmt|;
name|usize
operator|=
name|mpn_rshift
argument_list|(
name|up
argument_list|,
name|up
operator|+
name|i
argument_list|,
name|usize
operator|-
name|i
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Replace V by (V - U)>> cnt, with cnt being the least value 	     making V odd again.  */
name|vsize
operator|+=
name|mpn_sub
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|d
operator|=
name|vp
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|count_leading_zeros
argument_list|(
name|bcnt
argument_list|,
name|d
operator|&
operator|-
name|d
argument_list|)
expr_stmt|;
name|bcnt
operator|=
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|-
name|bcnt
expr_stmt|;
name|vsize
operator|=
name|mpn_rshift
argument_list|(
name|vp
argument_list|,
name|vp
operator|+
name|i
argument_list|,
name|vsize
operator|-
name|i
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* GCD(U_IN, V_IN) now is U * 2**W_BCNT.  */
name|wsize
operator|=
name|usize
operator|+
name|w_bcnt
operator|/
name|BITS_PER_MP_LIMB
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|alloc
operator|<
name|wsize
condition|)
name|_mpz_realloc
argument_list|(
name|w
argument_list|,
name|wsize
argument_list|)
expr_stmt|;
name|wp
operator|=
name|w
operator|->
name|d
expr_stmt|;
name|MPN_ZERO
argument_list|(
name|wp
argument_list|,
name|w_bcnt
operator|/
name|BITS_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|cy_digit
operator|=
name|mpn_lshift
argument_list|(
name|wp
operator|+
name|w_bcnt
operator|/
name|BITS_PER_MP_LIMB
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|w_bcnt
operator|%
name|BITS_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|wsize
operator|=
name|usize
operator|+
name|w_bcnt
operator|/
name|BITS_PER_MP_LIMB
expr_stmt|;
if|if
condition|(
name|cy_digit
operator|!=
literal|0
condition|)
block|{
name|wp
index|[
name|wsize
index|]
operator|=
name|cy_digit
expr_stmt|;
name|wsize
operator|++
expr_stmt|;
block|}
name|w
operator|->
name|size
operator|=
name|wsize
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

