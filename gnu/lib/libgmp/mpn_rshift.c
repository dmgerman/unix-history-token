begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_rshift -- Shift right a low-level natural-number integer.  Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_comment
comment|/* Shift U (pointed to by UP and USIZE limbs long) CNT bits to the right    and store the USIZE least significant limbs of the result at WP.    Return the size of the result.     Argument constraints:    0. U must be normalized (i.e. it's most significant limb != 0).    1. 0<= CNT< BITS_PER_MP_LIMB    2. If the result is to be written over the input, WP must be<= UP. */
end_comment

begin_function
name|mp_size
ifdef|#
directive|ifdef
name|__STDC__
name|mpn_rshift
parameter_list|(
name|mp_ptr
name|wp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_size
name|usize
parameter_list|,
name|unsigned
name|cnt
parameter_list|)
else|#
directive|else
function|mpn_rshift
parameter_list|(
name|wp
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|,
name|cnt
parameter_list|)
name|mp_ptr
name|wp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size
name|usize
decl_stmt|;
name|unsigned
name|cnt
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_limb
name|high_limb
decl_stmt|,
name|low_limb
decl_stmt|;
name|unsigned
name|sh_1
decl_stmt|,
name|sh_2
decl_stmt|;
name|mp_size
name|i
decl_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sh_1
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|sh_1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wp
operator|!=
name|up
condition|)
block|{
comment|/* Copy from low end to high end, to allow specified input/output 	     overlapping.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|usize
condition|;
name|i
operator|++
control|)
name|wp
index|[
name|i
index|]
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|usize
return|;
block|}
name|wp
operator|-=
literal|1
expr_stmt|;
name|sh_2
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|sh_1
expr_stmt|;
name|high_limb
operator|=
name|up
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|if (cy_limb != NULL)     *cy_limb = high_limb<< sh_2;
endif|#
directive|endif
name|low_limb
operator|=
name|high_limb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|usize
condition|;
name|i
operator|++
control|)
block|{
name|high_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
name|wp
index|[
name|i
index|]
operator|=
operator|(
name|low_limb
operator|>>
name|sh_1
operator|)
operator||
operator|(
name|high_limb
operator|<<
name|sh_2
operator|)
expr_stmt|;
name|low_limb
operator|=
name|high_limb
expr_stmt|;
block|}
name|low_limb
operator|>>=
name|sh_1
expr_stmt|;
if|if
condition|(
name|low_limb
operator|!=
literal|0
condition|)
block|{
name|wp
index|[
name|i
index|]
operator|=
name|low_limb
expr_stmt|;
return|return
name|usize
return|;
block|}
return|return
name|usize
operator|-
literal|1
return|;
block|}
end_function

end_unit

