begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_fac_ui(result, n) -- Set RESULT to N!.  Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DBG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|mpz_fac_ui
parameter_list|(
name|MP_INT
modifier|*
name|result
parameter_list|,
name|unsigned
name|long
name|int
name|n
parameter_list|)
else|#
directive|else
function|mpz_fac_ui
parameter_list|(
name|result
parameter_list|,
name|n
parameter_list|)
name|MP_INT
modifier|*
name|result
decl_stmt|;
name|unsigned
name|long
name|int
name|n
decl_stmt|;
endif|#
directive|endif
block|{
if|#
directive|if
name|SIMPLE_FAC
comment|/* Be silly.  Just multiply the numbers in ascending order.  O(n**2).  */
name|mp_limb
name|k
decl_stmt|;
name|mpz_set_ui
argument_list|(
name|result
argument_list|,
operator|(
name|mp_limb
operator|)
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|2
init|;
name|k
operator|<=
name|n
condition|;
name|k
operator|++
control|)
name|mpz_mul_ui
argument_list|(
name|result
argument_list|,
name|result
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Be smarter.  Multiply groups of numbers in ascending order until the      product doesn't fit in a limb.  Multiply these partial products in a      balanced binary tree fashion, to make the operand have as equal sizes      as possible.  (When the operands have about the same size, mpn_mul      becomes faster.)  */
name|mp_limb
name|k
decl_stmt|;
name|mp_limb
name|p1
decl_stmt|,
name|p0
decl_stmt|,
name|p
decl_stmt|;
comment|/* Stack of partial products, used to make the computation balanced      (i.e. make the sizes of the multiplication operands equal).  The      topmost position of MP_STACK will contain a one-limb partial product,      the second topmost will contain a two-limb partial product, and so      on.  MP_STACK[0] will contain a partial product with 2**t limbs.      To compute n! MP_STACK needs to be less than      log(n)**2/log(BITS_PER_MP_LIMB), so 30 is surely enough.  */
define|#
directive|define
name|MP_STACK_SIZE
value|30
name|MP_INT
name|mp_stack
index|[
name|MP_STACK_SIZE
index|]
decl_stmt|;
comment|/* TOP is an index into MP_STACK, giving the topmost element.      TOP_LIMIT_SO_FAR is the largets value it has taken so far.  */
name|int
name|top
decl_stmt|,
name|top_limit_so_far
decl_stmt|;
comment|/* Count of the total number of limbs put on MP_STACK so far.  This      variable plays an essential role in making the compututation balanced.      See below.  */
name|unsigned
name|int
name|tree_cnt
decl_stmt|;
name|top
operator|=
name|top_limit_so_far
operator|=
operator|-
literal|1
expr_stmt|;
name|tree_cnt
operator|=
literal|0
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|2
init|;
name|k
operator|<=
name|n
condition|;
name|k
operator|++
control|)
block|{
comment|/* Multiply the partial product in P with K.  */
name|umul_ppmm
argument_list|(
name|p1
argument_list|,
name|p0
argument_list|,
name|p
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* Did we get overflow into the high limb, i.e. is the partial 	 product now more than one limb?  */
if|if
condition|(
name|p1
operator|!=
literal|0
condition|)
block|{
name|tree_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|tree_cnt
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|mp_size
name|i
decl_stmt|;
comment|/* TREE_CNT is even (i.e. we have generated an even number of 		 one-limb partial products), which means that we have a 		 single-limb product on the top of MP_STACK.  */
name|mpz_mul_ui
argument_list|(
operator|&
name|mp_stack
index|[
name|top
index|]
argument_list|,
operator|&
name|mp_stack
index|[
name|top
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If TREE_CNT is divisable by 4, 8,..., we have two 		 similar-sized partial products with 2, 4,... limbs at 		 the topmost two positions of MP_STACK.  Multiply them 		 to form a new partial product with 4, 8,... limbs.  */
for|for
control|(
name|i
operator|=
literal|4
init|;
operator|(
name|tree_cnt
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|mpz_mul
argument_list|(
operator|&
name|mp_stack
index|[
name|top
operator|-
literal|1
index|]
argument_list|,
operator|&
name|mp_stack
index|[
name|top
index|]
argument_list|,
operator|&
name|mp_stack
index|[
name|top
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|top
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Put the single-limb partial product in P on the stack. 		 (The next time we get a single-limb product, we will 		 multiply the two together.)  */
name|top
operator|++
expr_stmt|;
if|if
condition|(
name|top
operator|>
name|top_limit_so_far
condition|)
block|{
if|if
condition|(
name|top
operator|>
name|MP_STACK_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The stack is now bigger than ever, initialize the top 		     element.  */
name|mpz_init_set_ui
argument_list|(
operator|&
name|mp_stack
index|[
name|top
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|top_limit_so_far
operator|++
expr_stmt|;
block|}
else|else
name|mpz_set_ui
argument_list|(
operator|&
name|mp_stack
index|[
name|top
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* We ignored the last result from umul_ppmm.  Put K in P as the 	     first component of the next single-limb partial product.  */
name|p
operator|=
name|k
expr_stmt|;
block|}
else|else
comment|/* We didn't get overflow in umul_ppmm.  Put p0 in P and try 	   with one more value of K.  */
name|p
operator|=
name|p0
expr_stmt|;
block|}
comment|/* We have partial products in mp_stack[0..top], in descending order.      We also have a small partial product in p.      Their product is the final result.  */
if|if
condition|(
name|top
operator|<
literal|0
condition|)
name|mpz_set_ui
argument_list|(
name|result
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|mpz_mul_ui
argument_list|(
name|result
argument_list|,
operator|&
name|mp_stack
index|[
name|top
operator|--
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|top
operator|>=
literal|0
condition|)
name|mpz_mul
argument_list|(
name|result
argument_list|,
name|result
argument_list|,
operator|&
name|mp_stack
index|[
name|top
operator|--
index|]
argument_list|)
expr_stmt|;
comment|/* Free the storage allocated for MP_STACK.  */
for|for
control|(
name|top
operator|=
name|top_limit_so_far
init|;
name|top
operator|>=
literal|0
condition|;
name|top
operator|--
control|)
name|mpz_clear
argument_list|(
operator|&
name|mp_stack
index|[
name|top
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

