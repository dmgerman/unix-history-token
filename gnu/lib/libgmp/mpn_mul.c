begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_mul -- Multiply two natural numbers.  Copyright (C) 1991, 1992 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|MPN_MUL_VERIFY
parameter_list|(
name|res_ptr
parameter_list|,
name|res_size
parameter_list|,
name|op1_ptr
parameter_list|,
name|op1_size
parameter_list|,
name|op2_ptr
parameter_list|,
name|op2_size
parameter_list|)
define|\
value|mpn_mul_verify (res_ptr, res_size, op1_ptr, op1_size, op2_ptr, op2_size)
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
specifier|static
name|void
name|mpn_mul_verify
parameter_list|(
name|res_ptr
parameter_list|,
name|res_size
parameter_list|,
name|op1_ptr
parameter_list|,
name|op1_size
parameter_list|,
name|op2_ptr
parameter_list|,
name|op2_size
parameter_list|)
name|mp_ptr
name|res_ptr
decl_stmt|,
name|op1_ptr
decl_stmt|,
name|op2_ptr
decl_stmt|;
name|mp_size
name|res_size
decl_stmt|,
name|op1_size
decl_stmt|,
name|op2_size
decl_stmt|;
block|{
name|mp_ptr
name|tmp_ptr
decl_stmt|;
name|mp_size
name|tmp_size
decl_stmt|;
name|tmp_ptr
operator|=
name|alloca
argument_list|(
operator|(
name|op1_size
operator|+
name|op2_size
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1_size
operator|>=
name|op2_size
condition|)
name|tmp_size
operator|=
name|mpn_mul_classic
argument_list|(
name|tmp_ptr
argument_list|,
name|op1_ptr
argument_list|,
name|op1_size
argument_list|,
name|op2_ptr
argument_list|,
name|op2_size
argument_list|)
expr_stmt|;
else|else
name|tmp_size
operator|=
name|mpn_mul_classic
argument_list|(
name|tmp_ptr
argument_list|,
name|op2_ptr
argument_list|,
name|op2_size
argument_list|,
name|op1_ptr
argument_list|,
name|op1_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_size
operator|!=
name|res_size
operator|||
name|mpn_cmp
argument_list|(
name|tmp_ptr
argument_list|,
name|res_ptr
argument_list|,
name|tmp_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU MP internal error: Wrong result in mpn_mul.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"op1{%d} = "
argument_list|,
name|op1_size
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|op1_ptr
argument_list|,
name|op1_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"op2{%d} = "
argument_list|,
name|op2_size
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|op2_ptr
argument_list|,
name|op2_size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MPN_MUL_VERIFY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Multiply the natural numbers u (pointed to by UP, with USIZE limbs)    and v (pointed to by VP, with VSIZE limbs), and store the result at    PRODP.  USIZE + VSIZE limbs are always stored, but if the input    operands are normalized, the return value will reflect the true    result size (which is either USIZE + VSIZE, or USIZE + VSIZE -1).     NOTE: The space pointed to by PRODP is overwritten before finished    with U and V, so overlap is an error.     Argument constraints:    1. USIZE>= VSIZE.    2. PRODP != UP and PRODP != VP, i.e. the destination       must be distinct from the multiplier and the multiplicand.  */
end_comment

begin_comment
comment|/* If KARATSUBA_THRESHOLD is not already defined, define it to a    value which is good on most machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KARATSUBA_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|KARATSUBA_THRESHOLD
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The code can't handle KARATSUBA_THRESHOLD smaller than 4.  */
end_comment

begin_if
if|#
directive|if
name|KARATSUBA_THRESHOLD
operator|<
literal|4
end_if

begin_undef
undef|#
directive|undef
name|KARATSUBA_THRESHOLD
end_undef

begin_define
define|#
directive|define
name|KARATSUBA_THRESHOLD
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|mp_size
ifdef|#
directive|ifdef
name|__STDC__
name|mpn_mul
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_size
name|usize
parameter_list|,
name|mp_srcptr
name|vp
parameter_list|,
name|mp_size
name|vsize
parameter_list|)
else|#
directive|else
function|mpn_mul
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|,
name|vp
parameter_list|,
name|vsize
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size
name|usize
decl_stmt|;
name|mp_srcptr
name|vp
decl_stmt|;
name|mp_size
name|vsize
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size
name|n
decl_stmt|;
name|mp_size
name|prod_size
decl_stmt|;
name|mp_limb
name|cy
decl_stmt|;
if|if
condition|(
name|vsize
operator|<
name|KARATSUBA_THRESHOLD
condition|)
block|{
comment|/* Handle simple cases with traditional multiplication.  	 This is the most critical code of the entire function.  All 	 multiplies rely on this, both small and huge.  Small ones arrive 	 here immediately.  Huge ones arrive here as this is the base case 	 for the recursive algorithm below.  */
name|mp_size
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mp_limb
name|prod_low
decl_stmt|,
name|prod_high
decl_stmt|;
name|mp_limb
name|cy_limb
decl_stmt|;
name|mp_limb
name|v_limb
decl_stmt|;
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Offset UP and PRODP so that the inner loop can be faster.  */
name|up
operator|+=
name|usize
expr_stmt|;
name|prodp
operator|+=
name|usize
expr_stmt|;
comment|/* Multiply by the first limb in V separately, as the result can 	 be stored (not added) to PROD.  We also avoid a loop for zeroing.  */
name|v_limb
operator|=
name|vp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|MPN_COPY
argument_list|(
name|prodp
operator|-
name|usize
argument_list|,
name|up
operator|-
name|usize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
else|else
name|MPN_ZERO
argument_list|(
name|prodp
operator|-
name|usize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|cy_limb
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cy_limb
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|-
name|usize
expr_stmt|;
do|do
block|{
name|umul_ppmm
argument_list|(
name|prod_high
argument_list|,
name|prod_low
argument_list|,
name|up
index|[
name|j
index|]
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|add_ssaaaa
argument_list|(
name|cy_limb
argument_list|,
name|prodp
index|[
name|j
index|]
argument_list|,
name|prod_high
argument_list|,
name|prod_low
argument_list|,
literal|0
argument_list|,
name|cy_limb
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
literal|0
condition|)
do|;
block|}
name|prodp
index|[
literal|0
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
comment|/* For each iteration in the outer loop, multiply one limb from 	 U with one limb from V, and add it to PROD.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
name|v_limb
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
name|cy_limb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|cy_limb
operator|=
name|mpn_add
argument_list|(
name|prodp
operator|-
name|usize
argument_list|,
name|prodp
operator|-
name|usize
argument_list|,
name|usize
argument_list|,
name|up
operator|-
name|usize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cy_limb
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|-
name|usize
expr_stmt|;
do|do
block|{
name|umul_ppmm
argument_list|(
name|prod_high
argument_list|,
name|prod_low
argument_list|,
name|up
index|[
name|j
index|]
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|add_ssaaaa
argument_list|(
name|cy_limb
argument_list|,
name|prod_low
argument_list|,
name|prod_high
argument_list|,
name|prod_low
argument_list|,
literal|0
argument_list|,
name|cy_limb
argument_list|)
expr_stmt|;
name|add_ssaaaa
argument_list|(
name|cy_limb
argument_list|,
name|prodp
index|[
name|j
index|]
argument_list|,
name|cy_limb
argument_list|,
name|prod_low
argument_list|,
literal|0
argument_list|,
name|prodp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
literal|0
condition|)
do|;
block|}
name|prodp
index|[
literal|0
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
block|}
return|return
name|usize
operator|+
name|vsize
operator|-
operator|(
name|cy_limb
operator|==
literal|0
operator|)
return|;
block|}
name|n
operator|=
operator|(
name|usize
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* Is USIZE larger than 1.5 times VSIZE?  Avoid Karatsuba's algorithm.  */
if|if
condition|(
literal|2
operator|*
name|usize
operator|>
literal|3
operator|*
name|vsize
condition|)
block|{
comment|/* If U has at least twice as many limbs as V.  Split U in two 	 pieces, U1 and U0, such that U = U0 + U1*(2**BITS_PER_MP_LIMB)**N, 	 and recursively multiply the two pieces separately with V.  */
name|mp_size
name|u0_size
decl_stmt|;
name|mp_ptr
name|tmp
decl_stmt|;
name|mp_size
name|tmp_size
decl_stmt|;
comment|/* V1 (the high part of V) is zero.  */
comment|/* Calculate the length of U0.  It is normally equal to n, but 	 of course not for sure.  */
for|for
control|(
name|u0_size
operator|=
name|n
init|;
name|u0_size
operator|>
literal|0
operator|&&
name|up
index|[
name|u0_size
operator|-
literal|1
index|]
operator|==
literal|0
condition|;
name|u0_size
operator|--
control|)
empty_stmt|;
comment|/* Perform (U0 * V).  */
if|if
condition|(
name|u0_size
operator|>=
name|vsize
condition|)
name|prod_size
operator|=
name|mpn_mul
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
else|else
name|prod_size
operator|=
name|mpn_mul
argument_list|(
name|prodp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|)
expr_stmt|;
name|MPN_MUL_VERIFY
argument_list|(
name|prodp
argument_list|,
name|prod_size
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
comment|/* We have to zero-extend the lower partial product to n limbs, 	 since the mpn_add some lines below expect the first n limbs 	 to be well defined.  (This is normally a no-op.  It may 	 do something when U1 has many leading 0 limbs.) */
while|while
condition|(
name|prod_size
operator|<
name|n
condition|)
name|prodp
index|[
name|prod_size
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
operator|(
name|usize
operator|+
name|vsize
operator|-
name|n
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
comment|/* Perform (U1 * V).  Make sure the first source argument to mpn_mul 	 is not less than the second source argument.  */
if|if
condition|(
name|vsize
operator|<=
name|usize
operator|-
name|n
condition|)
name|tmp_size
operator|=
name|mpn_mul
argument_list|(
name|tmp
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
else|else
name|tmp_size
operator|=
name|mpn_mul
argument_list|(
name|tmp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|)
expr_stmt|;
name|MPN_MUL_VERIFY
argument_list|(
name|tmp
argument_list|,
name|tmp_size
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
comment|/* In this addition hides a potentially large copying of TMP.  */
if|if
condition|(
name|prod_size
operator|-
name|n
operator|>=
name|tmp_size
condition|)
name|cy
operator|=
name|mpn_add
argument_list|(
name|prodp
operator|+
name|n
argument_list|,
name|prodp
operator|+
name|n
argument_list|,
name|prod_size
operator|-
name|n
argument_list|,
name|tmp
argument_list|,
name|tmp_size
argument_list|)
expr_stmt|;
else|else
name|cy
operator|=
name|mpn_add
argument_list|(
name|prodp
operator|+
name|n
argument_list|,
name|tmp
argument_list|,
name|tmp_size
argument_list|,
name|prodp
operator|+
name|n
argument_list|,
name|prod_size
operator|-
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* prodp[prod_size] = cy; */
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|tmp_size
operator|+
name|n
return|;
block|}
else|else
block|{
comment|/* Karatsuba's divide-and-conquer algorithm.  	 Split U in two pieces, U1 and U0, such that 	 U = U0 + U1*(B**n), 	 and V in V1 and V0, such that 	 V = V0 + V1*(B**n).  	 UV is then computed recursively using the identity  		2n   n        n                   n 	 UV = (B  + B )U V + B (U -U )(V -V ) + (B + 1)U V                         1 1      1  0   0  1            0 0  	 Where B = 2**BITS_PER_MP_LIMB.        */
comment|/* It's possible to decrease the temporary allocation by using the 	 prodp area for temporary storage of the middle term, and doing 	 that recursive multiplication first.  (Do this later.)  */
name|mp_size
name|u0_size
decl_stmt|;
name|mp_size
name|v0_size
decl_stmt|;
name|mp_size
name|u0v0_size
decl_stmt|;
name|mp_size
name|u1v1_size
decl_stmt|;
name|mp_ptr
name|temp
decl_stmt|;
name|mp_size
name|temp_size
decl_stmt|;
name|mp_size
name|utem_size
decl_stmt|;
name|mp_size
name|vtem_size
decl_stmt|;
name|mp_ptr
name|ptem
decl_stmt|;
name|mp_size
name|ptem_size
decl_stmt|;
name|int
name|negflg
decl_stmt|;
name|mp_ptr
name|pp
decl_stmt|;
name|pp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
literal|4
operator|*
name|n
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
comment|/* Calculate the lengths of U0 and V0.  They are normally equal 	 to n, but of course not for sure.  */
for|for
control|(
name|u0_size
operator|=
name|n
init|;
name|u0_size
operator|>
literal|0
operator|&&
name|up
index|[
name|u0_size
operator|-
literal|1
index|]
operator|==
literal|0
condition|;
name|u0_size
operator|--
control|)
empty_stmt|;
for|for
control|(
name|v0_size
operator|=
name|n
init|;
name|v0_size
operator|>
literal|0
operator|&&
name|vp
index|[
name|v0_size
operator|-
literal|1
index|]
operator|==
literal|0
condition|;
name|v0_size
operator|--
control|)
empty_stmt|;
comment|/*** 1. PROD]2n..0] := U0 x V0 	    (Recursive call to mpn_mul may NOT overwrite input operands.) 	     ________________  ________________ 	    |________________||____U0 x V0_____|  */
if|if
condition|(
name|u0_size
operator|>=
name|v0_size
condition|)
name|u0v0_size
operator|=
name|mpn_mul
argument_list|(
name|pp
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|,
name|vp
argument_list|,
name|v0_size
argument_list|)
expr_stmt|;
else|else
name|u0v0_size
operator|=
name|mpn_mul
argument_list|(
name|pp
argument_list|,
name|vp
argument_list|,
name|v0_size
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|)
expr_stmt|;
name|MPN_MUL_VERIFY
argument_list|(
name|pp
argument_list|,
name|u0v0_size
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|,
name|vp
argument_list|,
name|v0_size
argument_list|)
expr_stmt|;
comment|/* Zero-extend to 2n limbs. */
while|while
condition|(
name|u0v0_size
operator|<
literal|2
operator|*
name|n
condition|)
name|pp
index|[
name|u0v0_size
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/*** 2. PROD]4n..2n] := U1 x V1 	    (Recursive call to mpn_mul may NOT overwrite input operands.) 	     ________________  ________________ 	    |_____U1 x V1____||____U0 x V0_____|  */
name|u1v1_size
operator|=
name|mpn_mul
argument_list|(
name|pp
operator|+
literal|2
operator|*
name|n
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|,
name|vp
operator|+
name|n
argument_list|,
name|vsize
operator|-
name|n
argument_list|)
expr_stmt|;
name|MPN_MUL_VERIFY
argument_list|(
name|pp
operator|+
literal|2
operator|*
name|n
argument_list|,
name|u1v1_size
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|,
name|vp
operator|+
name|n
argument_list|,
name|vsize
operator|-
name|n
argument_list|)
expr_stmt|;
name|prod_size
operator|=
literal|2
operator|*
name|n
operator|+
name|u1v1_size
expr_stmt|;
comment|/*** 3. PTEM]2n..0] := (U1-U0) x (V0-V1) 	    (Recursive call to mpn_mul may overwrite input operands.) 	     ________________ 	    |_(U1-U0)(V0-V1)_|  */
name|temp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
operator|(
literal|2
operator|*
name|n
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|-
name|n
operator|>
name|u0_size
operator|||
operator|(
name|usize
operator|-
name|n
operator|==
name|u0_size
operator|&&
name|mpn_cmp
argument_list|(
name|up
operator|+
name|n
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|utem_size
operator|=
name|usize
operator|-
name|n
operator|+
name|mpn_sub
argument_list|(
name|temp
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|)
expr_stmt|;
name|negflg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|utem_size
operator|=
name|u0_size
operator|+
name|mpn_sub
argument_list|(
name|temp
argument_list|,
name|up
argument_list|,
name|u0_size
argument_list|,
name|up
operator|+
name|n
argument_list|,
name|usize
operator|-
name|n
argument_list|)
expr_stmt|;
name|negflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vsize
operator|-
name|n
operator|>
name|v0_size
operator|||
operator|(
name|vsize
operator|-
name|n
operator|==
name|v0_size
operator|&&
name|mpn_cmp
argument_list|(
name|vp
operator|+
name|n
argument_list|,
name|vp
argument_list|,
name|v0_size
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|vtem_size
operator|=
name|vsize
operator|-
name|n
operator|+
name|mpn_sub
argument_list|(
name|temp
operator|+
name|n
argument_list|,
name|vp
operator|+
name|n
argument_list|,
name|vsize
operator|-
name|n
argument_list|,
name|vp
argument_list|,
name|v0_size
argument_list|)
expr_stmt|;
name|negflg
operator|^=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vtem_size
operator|=
name|v0_size
operator|+
name|mpn_sub
argument_list|(
name|temp
operator|+
name|n
argument_list|,
name|vp
argument_list|,
name|v0_size
argument_list|,
name|vp
operator|+
name|n
argument_list|,
name|vsize
operator|-
name|n
argument_list|)
expr_stmt|;
comment|/* No change of NEGFLG.  */
block|}
name|ptem
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
literal|2
operator|*
name|n
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|utem_size
operator|>=
name|vtem_size
condition|)
name|ptem_size
operator|=
name|mpn_mul
argument_list|(
name|ptem
argument_list|,
name|temp
argument_list|,
name|utem_size
argument_list|,
name|temp
operator|+
name|n
argument_list|,
name|vtem_size
argument_list|)
expr_stmt|;
else|else
name|ptem_size
operator|=
name|mpn_mul
argument_list|(
name|ptem
argument_list|,
name|temp
operator|+
name|n
argument_list|,
name|vtem_size
argument_list|,
name|temp
argument_list|,
name|utem_size
argument_list|)
expr_stmt|;
name|MPN_MUL_VERIFY
argument_list|(
name|ptem
argument_list|,
name|ptem_size
argument_list|,
name|temp
argument_list|,
name|utem_size
argument_list|,
name|temp
operator|+
name|n
argument_list|,
name|vtem_size
argument_list|)
expr_stmt|;
comment|/*** 4. TEMP]2n..0] := PROD]2n..0] + PROD]4n..2n] 	      ________________ 	     |_____U1 x V1____| 	      ________________ 	     |_____U0_x_V0____|  */
name|cy
operator|=
name|mpn_add
argument_list|(
name|temp
argument_list|,
name|pp
argument_list|,
literal|2
operator|*
name|n
argument_list|,
name|pp
operator|+
literal|2
operator|*
name|n
argument_list|,
name|u1v1_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
block|{
name|temp
index|[
literal|2
operator|*
name|n
index|]
operator|=
name|cy
expr_stmt|;
name|temp_size
operator|=
literal|2
operator|*
name|n
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Normalize temp.  pp[2*n-1] might have been zero in the 	     mpn_add call above, and thus temp might be unnormalized.  */
for|for
control|(
name|temp_size
operator|=
literal|2
operator|*
name|n
init|;
name|temp_size
operator|>
literal|0
operator|&&
name|temp
index|[
name|temp_size
operator|-
literal|1
index|]
operator|==
literal|0
condition|;
name|temp_size
operator|--
control|)
empty_stmt|;
block|}
if|if
condition|(
name|prod_size
operator|-
name|n
operator|>=
name|temp_size
condition|)
name|cy
operator|=
name|mpn_add
argument_list|(
name|pp
operator|+
name|n
argument_list|,
name|pp
operator|+
name|n
argument_list|,
name|prod_size
operator|-
name|n
argument_list|,
name|temp
argument_list|,
name|temp_size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This is a weird special case that should not happen (often)!  */
name|cy
operator|=
name|mpn_add
argument_list|(
name|pp
operator|+
name|n
argument_list|,
name|temp
argument_list|,
name|temp_size
argument_list|,
name|pp
operator|+
name|n
argument_list|,
name|prod_size
operator|-
name|n
argument_list|)
expr_stmt|;
name|prod_size
operator|=
name|temp_size
operator|+
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
block|{
name|pp
index|[
name|prod_size
index|]
operator|=
name|cy
expr_stmt|;
name|prod_size
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|prod_size
operator|>
literal|4
operator|*
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|negflg
condition|)
name|prod_size
operator|=
name|prod_size
operator|+
name|mpn_sub
argument_list|(
name|pp
operator|+
name|n
argument_list|,
name|pp
operator|+
name|n
argument_list|,
name|prod_size
operator|-
name|n
argument_list|,
name|ptem
argument_list|,
name|ptem_size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|prod_size
operator|-
name|n
operator|<
name|ptem_size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cy
operator|=
name|mpn_add
argument_list|(
name|pp
operator|+
name|n
argument_list|,
name|pp
operator|+
name|n
argument_list|,
name|prod_size
operator|-
name|n
argument_list|,
name|ptem
argument_list|,
name|ptem_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
block|{
name|pp
index|[
name|prod_size
index|]
operator|=
name|cy
expr_stmt|;
name|prod_size
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|prod_size
operator|>
literal|4
operator|*
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|MPN_COPY
argument_list|(
name|prodp
argument_list|,
name|pp
argument_list|,
name|prod_size
argument_list|)
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|prod_size
return|;
block|}
block|}
end_function

end_unit

