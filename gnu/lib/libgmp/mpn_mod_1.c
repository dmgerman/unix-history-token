begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_mod_1(dividend_ptr, dividend_size, divisor_limb) --    Divide (DIVIDEND_PTR,,DIVIDEND_SIZE) by DIVISOR_LIMB.    Return the single-limb remainder.    There are no constraints on the value of the divisor.     QUOT_PTR and DIVIDEND_PTR might point to the same limb.  Copyright (C) 1991, 1992 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_function
name|mp_limb
ifdef|#
directive|ifdef
name|__STDC__
name|mpn_mod_1
parameter_list|(
name|mp_srcptr
name|dividend_ptr
parameter_list|,
name|mp_size
name|dividend_size
parameter_list|,
name|unsigned
name|long
name|int
name|divisor_limb
parameter_list|)
else|#
directive|else
function|mpn_mod_1
parameter_list|(
name|dividend_ptr
parameter_list|,
name|dividend_size
parameter_list|,
name|divisor_limb
parameter_list|)
name|mp_srcptr
name|dividend_ptr
decl_stmt|;
name|mp_size
name|dividend_size
decl_stmt|;
name|unsigned
name|long
name|int
name|divisor_limb
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|normalization_steps
decl_stmt|;
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|n1
decl_stmt|,
name|n0
decl_stmt|,
name|r
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|/* Botch: Should this be handled at all?  Rely on callers?  */
if|if
condition|(
name|dividend_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|UDIV_NEEDS_NORMALIZATION
condition|)
block|{
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|divisor_limb
operator|<<=
name|normalization_steps
expr_stmt|;
name|n1
operator|=
name|dividend_ptr
index|[
name|dividend_size
operator|-
literal|1
index|]
expr_stmt|;
name|r
operator|=
name|n1
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
expr_stmt|;
comment|/* Possible optimization: 	  if (r == 0&& divisor_limb> ((n1<< normalization_steps) 				 | (dividend_ptr[dividend_size - 2]>> ...))) 	    ...one division less... 	   */
for|for
control|(
name|i
operator|=
name|dividend_size
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
operator|(
operator|(
name|n1
operator|<<
name|normalization_steps
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
operator|)
operator|)
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
name|n1
operator|=
name|n0
expr_stmt|;
block|}
name|udiv_qrnnd
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n1
operator|<<
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
return|return
name|r
operator|>>
name|normalization_steps
return|;
block|}
block|}
comment|/* No normalization needed, either because udiv_qrnnd doesn't require      it, or because DIVISOR_LIMB is already normalized.  */
name|i
operator|=
name|dividend_size
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|divisor_limb
condition|)
block|{
name|r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|i
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

end_unit

