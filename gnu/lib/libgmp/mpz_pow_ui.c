begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_pow_ui(res, base, exp) -- Set RES to BASE**EXP.  Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BERKELEY_MP
end_ifndef

begin_decl_stmt
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|mpz_pow_ui
argument_list|(
name|MP_INT
operator|*
name|r
argument_list|,
specifier|const
name|MP_INT
operator|*
name|b
argument_list|,
name|unsigned
name|long
name|int
name|e
argument_list|)
else|#
directive|else
name|mpz_pow_ui
argument_list|(
name|r
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
name|MP_INT
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|MP_INT
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|int
name|e
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BERKELEY_MP */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|rpow
parameter_list|(
specifier|const
name|MP_INT
modifier|*
name|b
parameter_list|,
name|signed
name|short
name|int
name|e
parameter_list|,
name|MP_INT
modifier|*
name|r
parameter_list|)
else|#
directive|else
function|rpow
parameter_list|(
name|b
parameter_list|,
name|e
parameter_list|,
name|r
parameter_list|)
specifier|const
name|MP_INT
modifier|*
name|b
decl_stmt|;
name|signed
name|short
name|int
name|e
decl_stmt|;
name|MP_INT
modifier|*
name|r
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BERKELEY_MP */
block|{
name|mp_ptr
name|rp
decl_stmt|,
name|bp
decl_stmt|,
name|tp
decl_stmt|,
name|xp
decl_stmt|;
name|mp_size
name|rsize
decl_stmt|,
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|bsize
operator|=
name|ABS
argument_list|(
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Single out cases that give result == 0 or 1.  These tests are here      to simplify the general code below, not to optimize.  */
if|if
condition|(
name|bsize
operator|==
literal|0
ifdef|#
directive|ifdef
name|BERKELEY_MP
operator|||
name|e
operator|<
literal|0
endif|#
directive|endif
condition|)
block|{
name|r
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
name|r
operator|->
name|d
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|size
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Count the number of leading zero bits of the base's most      significant limb.  */
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|b
operator|->
name|d
index|[
name|bsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Over-estimate space requirements and allocate enough space for the      final result in two temporary areas.  The two areas are used to      alternately hold the input and recieve the product for mpn_mul.      (This scheme is used to fulfill the requirements of mpn_mul; that      the product space may not be the same as any of the input operands.)  */
name|rsize
operator|=
name|bsize
operator|*
name|e
operator|-
name|cnt
operator|*
name|e
operator|/
name|BITS_PER_MP_LIMB
expr_stmt|;
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|alloca
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|d
expr_stmt|;
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|bp
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|bsize
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|cnt
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rsize
operator|=
name|mpn_mul
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|xp
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|&
operator|(
operator|(
name|mp_limb
operator|)
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rsize
operator|=
name|mpn_mul
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|bp
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|xp
expr_stmt|;
block|}
block|}
comment|/* Now then we know the exact space requirements, reallocate if      necessary.  */
if|if
condition|(
name|r
operator|->
name|alloc
operator|<
name|rsize
condition|)
name|_mpz_realloc
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|r
operator|->
name|d
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|r
operator|->
name|size
operator|=
operator|(
name|e
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
name|b
operator|->
name|size
operator|>=
literal|0
condition|?
name|rsize
else|:
operator|-
name|rsize
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

