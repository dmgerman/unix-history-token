begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_lshift -- Shift left low level.  Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU MP Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_comment
comment|/* Shift U (pointed to by UP and USIZE digits long) CNT bits to the left    and store the USIZE least significant digits of the result at WP.    Return the bits shifted out from the most significant digit.     Argument constraints:    0. U must be normalized (i.e. it's most significant digit != 0).    1. 0<= CNT< BITS_PER_MP_LIMB    2. If the result is to be written over the input, WP must be>= UP. */
end_comment

begin_function
name|mp_limb
ifdef|#
directive|ifdef
name|__STDC__
name|mpn_lshift
parameter_list|(
name|mp_ptr
name|wp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_size
name|usize
parameter_list|,
name|unsigned
name|cnt
parameter_list|)
else|#
directive|else
function|mpn_lshift
parameter_list|(
name|wp
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|,
name|cnt
parameter_list|)
name|mp_ptr
name|wp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size
name|usize
decl_stmt|;
name|unsigned
name|cnt
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_limb
name|high_limb
decl_stmt|,
name|low_limb
decl_stmt|;
name|unsigned
name|sh_1
decl_stmt|,
name|sh_2
decl_stmt|;
name|mp_size
name|i
decl_stmt|;
name|mp_limb
name|retval
decl_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sh_1
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|sh_1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wp
operator|!=
name|up
condition|)
block|{
comment|/* Copy from high end to low end, to allow specified input/output 	     overlapping.  */
for|for
control|(
name|i
operator|=
name|usize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|wp
index|[
name|i
index|]
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|wp
operator|+=
literal|1
expr_stmt|;
name|sh_2
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|sh_1
expr_stmt|;
name|i
operator|=
name|usize
operator|-
literal|1
expr_stmt|;
name|low_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
name|retval
operator|=
name|low_limb
operator|>>
name|sh_2
expr_stmt|;
name|high_limb
operator|=
name|low_limb
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|low_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
name|wp
index|[
name|i
index|]
operator|=
operator|(
name|high_limb
operator|<<
name|sh_1
operator|)
operator||
operator|(
name|low_limb
operator|>>
name|sh_2
operator|)
expr_stmt|;
name|high_limb
operator|=
name|low_limb
expr_stmt|;
block|}
name|wp
index|[
name|i
index|]
operator|=
name|high_limb
operator|<<
name|sh_1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

