begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_function
name|unsigned
name|long
name|cputime
parameter_list|()
block|{
name|struct
name|rusage
name|rus
decl_stmt|;
name|getrusage
argument_list|(
literal|0
argument_list|,
operator|&
name|rus
argument_list|)
expr_stmt|;
return|return
name|rus
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|rus
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|/
literal|1000
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CLOCKS_PER_SEC
end_ifndef

begin_define
define|#
directive|define
name|CLOCKS_PER_SEC
value|1000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CLOCKS_PER_SEC
operator|>=
literal|10000
end_if

begin_define
define|#
directive|define
name|CLOCK_TO_MILLISEC
parameter_list|(
name|cl
parameter_list|)
value|((cl) / (CLOCKS_PER_SEC / 1000))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CLOCK_TO_MILLISEC
parameter_list|(
name|cl
parameter_list|)
value|((cl) * 1000 / CLOCKS_PER_SEC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|long
name|cputime
parameter_list|()
block|{
return|return
name|CLOCK_TO_MILLISEC
argument_list|(
name|clock
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|M
value|* 1000000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CLOCK
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__m88k__
argument_list|)
end_if

begin_define
define|#
directive|define
name|CLOCK
value|20 M
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(16.666667 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__m68k__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(20 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_IBMR2
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(25 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(20 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sun__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(20 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__mips
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(40 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__hppa__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(50 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(133 M)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Don't know CLOCK of your machine"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPS
end_ifndef

begin_define
define|#
directive|define
name|OPS
value|20000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE
end_ifndef

begin_define
define|#
directive|define
name|SIZE
value|496
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TIMES
end_ifndef

begin_define
define|#
directive|define
name|TIMES
value|OPS/SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|OPS
end_undef

begin_define
define|#
directive|define
name|OPS
value|(SIZE*TIMES)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|mp_limb_t
name|refmpn_mul_1
parameter_list|(
name|res_ptr
parameter_list|,
name|s1_ptr
parameter_list|,
name|s1_size
parameter_list|,
name|s2_limb
parameter_list|)
specifier|register
name|mp_ptr
name|res_ptr
decl_stmt|;
specifier|register
name|mp_srcptr
name|s1_ptr
decl_stmt|;
name|mp_size_t
name|s1_size
decl_stmt|;
specifier|register
name|mp_limb_t
name|s2_limb
decl_stmt|;
block|{
specifier|register
name|mp_limb_t
name|cy_limb
decl_stmt|;
specifier|register
name|mp_size_t
name|j
decl_stmt|;
specifier|register
name|mp_limb_t
name|prod_high
decl_stmt|,
name|prod_low
decl_stmt|;
comment|/* The loop counter and index J goes from -S1_SIZE to -1.  This way      the loop becomes faster.  */
name|j
operator|=
operator|-
name|s1_size
expr_stmt|;
comment|/* Offset the base pointers to compensate for the negative indices.  */
name|s1_ptr
operator|-=
name|j
expr_stmt|;
name|res_ptr
operator|-=
name|j
expr_stmt|;
name|cy_limb
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|umul_ppmm
argument_list|(
name|prod_high
argument_list|,
name|prod_low
argument_list|,
name|s1_ptr
index|[
name|j
index|]
argument_list|,
name|s2_limb
argument_list|)
expr_stmt|;
name|prod_low
operator|+=
name|cy_limb
expr_stmt|;
name|cy_limb
operator|=
operator|(
name|prod_low
operator|<
name|cy_limb
operator|)
operator|+
name|prod_high
expr_stmt|;
name|res_ptr
index|[
name|j
index|]
operator|=
name|prod_low
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|j
operator|!=
literal|0
condition|)
do|;
return|return
name|cy_limb
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|mp_limb_t
name|s1
index|[
name|SIZE
index|]
decl_stmt|;
name|mp_limb_t
name|dx
index|[
name|SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|mp_limb_t
name|dy
index|[
name|SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|mp_limb_t
name|cyx
decl_stmt|,
name|cyy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|t0
decl_stmt|,
name|t
decl_stmt|;
name|int
name|test
decl_stmt|;
name|mp_limb_t
name|xlimb
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
for|for
control|(
name|test
operator|=
literal|0
init|;
condition|;
name|test
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RANDOM
name|size
operator|=
operator|(
name|random
argument_list|()
operator|%
name|SIZE
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|SIZE
expr_stmt|;
endif|#
directive|endif
name|mpn_random2
argument_list|(
name|s1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mpn_random2
argument_list|(
name|dy
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|%
literal|0x100
operator|==
literal|0
condition|)
name|xlimb
operator|=
literal|0
expr_stmt|;
else|else
name|mpn_random2
argument_list|(
operator|&
name|xlimb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dy
index|[
name|size
operator|+
literal|1
index|]
operator|=
literal|0x12345678
expr_stmt|;
name|dy
index|[
literal|0
index|]
operator|=
literal|0x87654321
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PRINT
argument_list|)
operator|||
name|defined
argument_list|(
name|XPRINT
argument_list|)
name|printf
argument_list|(
literal|"xlimb=%*lX\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|xlimb
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRINT
name|mpn_print
argument_list|(
name|s1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MPN_COPY
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|t0
operator|=
name|cputime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMES
condition|;
name|i
operator|++
control|)
name|cyx
operator|=
name|refmpn_mul_1
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|xlimb
argument_list|)
expr_stmt|;
name|t
operator|=
name|cputime
argument_list|()
operator|-
name|t0
expr_stmt|;
if|#
directive|if
name|TIMES
operator|!=
literal|1
name|printf
argument_list|(
literal|"refmpn_mul_1: %5ldms (%.2f cycles/limb)\n"
argument_list|,
name|t
argument_list|,
operator|(
operator|(
name|double
operator|)
name|t
operator|*
name|CLOCK
operator|)
operator|/
operator|(
name|OPS
operator|*
literal|1000.0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MPN_COPY
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|t0
operator|=
name|cputime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMES
condition|;
name|i
operator|++
control|)
name|cyy
operator|=
name|mpn_mul_1
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|xlimb
argument_list|)
expr_stmt|;
name|t
operator|=
name|cputime
argument_list|()
operator|-
name|t0
expr_stmt|;
if|#
directive|if
name|TIMES
operator|!=
literal|1
name|printf
argument_list|(
literal|"mpn_mul_1:    %5ldms (%.2f cycles/limb)\n"
argument_list|,
name|t
argument_list|,
operator|(
operator|(
name|double
operator|)
name|t
operator|*
name|CLOCK
operator|)
operator|/
operator|(
name|OPS
operator|*
literal|1000.0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cyx
operator|=
name|refmpn_mul_1
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|xlimb
argument_list|)
expr_stmt|;
name|cyy
operator|=
name|mpn_mul_1
argument_list|(
name|dy
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|xlimb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyx
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyy
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dy
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NOCHECK
if|if
condition|(
name|cyx
operator|!=
name|cyy
operator|||
name|mpn_cmp
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|size
operator|+
literal|2
argument_list|)
operator|!=
literal|0
operator|||
name|dx
index|[
name|size
operator|+
literal|1
index|]
operator|!=
literal|0x12345678
operator|||
name|dx
index|[
literal|0
index|]
operator|!=
literal|0x87654321
condition|)
block|{
ifndef|#
directive|ifndef
name|PRINT
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyx
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyy
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dy
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_macro
name|mpn_print
argument_list|(
argument|mp_ptr p
argument_list|,
argument|mp_size_t size
argument_list|)
end_macro

begin_block
block|{
name|mp_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|printf
argument_list|(
literal|"%0*lX"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

