begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_scan0 -- Scan from a given bit position for the next clear bit.  Copyright (C) 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* Design issues:    1. What if starting_bit is not within U?  Caller's problem?    2. Bit index should be 'unsigned'?     Argument constraints:    1. U must sooner ot later have a limb with a clear bit.  */
end_comment

begin_function
name|unsigned
name|long
name|int
if|#
directive|if
name|__STDC__
name|mpn_scan0
parameter_list|(
specifier|register
name|mp_srcptr
name|up
parameter_list|,
specifier|register
name|unsigned
name|long
name|int
name|starting_bit
parameter_list|)
else|#
directive|else
function|mpn_scan0
parameter_list|(
name|up
parameter_list|,
name|starting_bit
parameter_list|)
specifier|register
name|mp_srcptr
name|up
decl_stmt|;
specifier|register
name|unsigned
name|long
name|int
name|starting_bit
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size_t
name|starting_word
decl_stmt|;
name|mp_limb_t
name|alimb
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|mp_srcptr
name|p
decl_stmt|;
comment|/* Start at the word implied by STARTING_BIT.  */
name|starting_word
operator|=
name|starting_bit
operator|/
name|BITS_PER_MP_LIMB
expr_stmt|;
name|p
operator|=
name|up
operator|+
name|starting_word
expr_stmt|;
name|alimb
operator|=
operator|~
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Mask off any bits before STARTING_BIT in the first limb.  */
name|alimb
operator|&=
operator|-
operator|(
name|mp_limb_t
operator|)
literal|1
operator|<<
operator|(
name|starting_bit
operator|%
name|BITS_PER_MP_LIMB
operator|)
expr_stmt|;
while|while
condition|(
name|alimb
operator|==
literal|0
condition|)
name|alimb
operator|=
operator|~
operator|*
name|p
operator|++
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|alimb
operator|&
operator|-
name|alimb
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|-
name|up
operator|)
operator|*
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|-
name|cnt
return|;
block|}
end_function

end_unit

