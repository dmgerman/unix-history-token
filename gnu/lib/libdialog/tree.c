begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tree.c -- implements the 'tree' interface element for libdialog  *  * Author: Anatoly A. Orehovsky (tolik@mpeks.tomsk.su)  *  * Copyright (c) 1997, Anatoly A. Orehovsky  * 09/28/98 - patched by Anatoly A. Orehovsky (smart_tree())  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|"dialog.priv.h"
end_include

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_comment
comment|/* static utils for make tree */
end_comment

begin_struct
struct|struct
name|leaf
block|{
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of leaf */
name|unsigned
name|char
modifier|*
name|branches
decl_stmt|;
comment|/* branches that going by leaf */
name|unsigned
name|char
name|slip
decl_stmt|;
comment|/* slip of leaf*/
name|int
name|shift
decl_stmt|;
comment|/* shift relative root of tree */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|mk_slip
parameter_list|(
name|struct
name|leaf
name|array
index|[]
parameter_list|,
name|int
name|arr_size
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|shift
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* make tree from file  *  * filename	- name of file with like find(1) output  * p_names	- pointer to array of strings  * p_size	- pointer to size of array  * FS		- fields separator  * p_array	- pointer to array of leafs  *  * return values:  * 0		- ok and names by p_names, size by p_size, array by p_array set  * -1		- memory allocation error (errno set)  */
end_comment

begin_function_decl
specifier|static
name|int
name|mk_ftree
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
modifier|*
name|p_names
parameter_list|,
name|int
modifier|*
name|p_size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|struct
name|leaf
modifier|*
modifier|*
name|p_array
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* make tree from array  *  * names	- array of strings  * size		- size of array  * FS		- fields separator  * p_array	- pointer to array of leafs  *  * return values:  * 0		- ok and array by p_array set  * -1		- memory allocation error (errno set)  */
end_comment

begin_function_decl
specifier|static
name|int
name|mk_tree
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|struct
name|leaf
modifier|*
modifier|*
name|p_array
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* free memory from tree (leafs)  *  * return values:  * nothing  */
end_comment

begin_function_decl
specifier|static
name|void
name|free_leafs
parameter_list|(
name|struct
name|leaf
modifier|*
name|array
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* free memory from source data for tree (names)  *  * return values:  * if 0<= choice<= size - pointer to name from names,   *	and memory for name not released (must be freed later)  * else - NULL (recomended choice -1 for it)  */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|free_names
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|choice
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* end of static utils for make tree */
end_comment

begin_comment
comment|/* static utils for ftree */
end_comment

begin_comment
comment|/* control struct for queue */
end_comment

begin_struct
struct|struct
name|queue
block|{
name|int
name|size
decl_stmt|;
comment|/* size of queue */
name|struct
name|m_queue
modifier|*
name|first
decl_stmt|;
comment|/* begin of queue */
name|struct
name|m_queue
modifier|*
name|last
decl_stmt|;
comment|/* end of queue */
block|}
struct|;
end_struct

begin_comment
comment|/* queue member */
end_comment

begin_struct
struct|struct
name|m_queue
block|{
name|void
modifier|*
name|pointer
decl_stmt|;
comment|/* queue member */
name|struct
name|m_queue
modifier|*
name|next
decl_stmt|;
comment|/* next queue member */
block|}
struct|;
end_struct

begin_comment
comment|/* init struct queue by zeros */
end_comment

begin_function_decl
specifier|static
name|void
name|init_queue
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* add pointer to queue */
end_comment

begin_comment
comment|/* return - pointer or NULL if error */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|p2_queue
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|void
modifier|*
name|pointer
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* get first from queue */
end_comment

begin_comment
comment|/* return - pointer or NULL if queue is empty */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|first_queue
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* make zero terminated array from queue */
end_comment

begin_comment
comment|/* return - pointer to array or NULL if error */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
modifier|*
name|q2arr
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|int
name|depth
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* smart_tree (for like find(1) with -d flag output compliance) */
end_comment

begin_comment
comment|/* return - not NULL or NULL if malloc error */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|smart_tree
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|unsigned
name|char
modifier|*
name|current
parameter_list|,
name|unsigned
name|char
modifier|*
name|prev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* end of static utils for ftree */
end_comment

begin_comment
comment|/* static utils for saved_tree */
end_comment

begin_comment
comment|/* saved values for unique tree */
end_comment

begin_struct
struct|struct
name|saved_tree
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* names + */
name|int
name|size
decl_stmt|;
comment|/* size + */
name|unsigned
name|char
name|FS
decl_stmt|;
comment|/* FS + */
name|int
name|height
decl_stmt|;
comment|/* height + */
name|int
name|width
decl_stmt|;
comment|/* width + */
name|int
name|menu_height
decl_stmt|;
comment|/* menu_height - unique for treebox ? */
name|int
name|ch
decl_stmt|;
comment|/* saved ch - choice */
name|int
name|sc
decl_stmt|;
comment|/* saved sc - scroll */
block|}
struct|;
end_struct

begin_comment
comment|/* search saved tree within queue */
end_comment

begin_comment
comment|/* return - struct saved_tree * or NULL if not found */
end_comment

begin_function_decl
specifier|static
name|struct
name|saved_tree
modifier|*
name|search_saved_tree
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|menu_height
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* end of static utils for saved_tree */
end_comment

begin_function_decl
specifier|static
name|void
name|print_item
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|struct
name|leaf
name|item
parameter_list|,
name|int
name|choice
parameter_list|,
name|int
name|selected
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_position
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|cur_pos
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|menu_width
decl_stmt|,
name|item_x
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|dialog_treemenu
parameter_list|(
name|unsigned
name|char
modifier|*
name|title
parameter_list|,
name|unsigned
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|menu_height
parameter_list|,
name|int
name|item_no
parameter_list|,
name|struct
name|leaf
name|items
index|[]
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|,
name|int
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Display a menu for choosing among a number of options  */
end_comment

begin_function
specifier|static
name|int
name|dialog_treemenu
parameter_list|(
name|unsigned
name|char
modifier|*
name|title
parameter_list|,
name|unsigned
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|menu_height
parameter_list|,
name|int
name|item_no
parameter_list|,
name|struct
name|leaf
name|items
index|[]
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|,
name|int
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|cur_x
decl_stmt|,
name|cur_y
decl_stmt|,
name|box_x
decl_stmt|,
name|box_y
decl_stmt|,
name|key
init|=
literal|0
decl_stmt|,
name|button
init|=
literal|0
decl_stmt|,
name|choice
init|=
literal|0
decl_stmt|,
name|l
decl_stmt|,
name|scroll
init|=
literal|0
decl_stmt|,
name|max_choice
decl_stmt|,
name|redraw_menu
init|=
name|FALSE
decl_stmt|;
name|WINDOW
modifier|*
name|dialog
decl_stmt|,
modifier|*
name|menu
decl_stmt|;
if|if
condition|(
name|ch
condition|)
comment|/* restore menu item info */
name|choice
operator|=
operator|*
name|ch
expr_stmt|;
if|if
condition|(
name|sc
condition|)
name|scroll
operator|=
operator|*
name|sc
expr_stmt|;
name|max_choice
operator|=
name|MIN
argument_list|(
name|menu_height
argument_list|,
name|item_no
argument_list|)
expr_stmt|;
name|item_x
operator|=
literal|0
expr_stmt|;
comment|/* Find length of longest item in order to center menu */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|item_no
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|branches
argument_list|)
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
name|item_x
operator|=
name|MAX
argument_list|(
name|item_x
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|<
literal|0
condition|)
name|height
operator|=
name|strheight
argument_list|(
name|prompt
argument_list|)
operator|+
name|menu_height
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|strwidth
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|j
operator|=
operator|(
operator|(
name|title
operator|!=
name|NULL
operator|)
condition|?
name|strwidth
argument_list|(
name|title
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|width
operator|=
name|MAX
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|width
operator|=
name|MAX
argument_list|(
name|width
argument_list|,
name|item_x
operator|+
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
name|width
operator|=
name|MAX
argument_list|(
name|width
argument_list|,
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|COLS
condition|)
name|width
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|height
operator|>
name|LINES
condition|)
name|height
operator|=
name|LINES
expr_stmt|;
comment|/* center dialog box on screen */
name|x
operator|=
operator|(
name|COLS
operator|-
name|width
operator|)
operator|/
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|LINES
operator|-
name|height
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NCURSES
if|if
condition|(
name|use_shadow
condition|)
name|draw_shadow
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dialog
operator|=
name|newwin
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog
operator|==
name|NULL
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnewwin(%d,%d,%d,%d) failed, maybe wrong dims\n"
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|keypad
argument_list|(
name|dialog
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|draw_box
argument_list|(
name|dialog
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|dialog_attr
argument_list|,
name|border_attr
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|border_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|height
operator|-
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|ACS_LTEE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|dialog
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|ACS_RTEE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|height
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|dialog
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|title
operator|!=
name|NULL
condition|)
block|{
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|title_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|-
name|strlen
argument_list|(
name|title
argument_list|)
operator|)
operator|/
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|dialog
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|print_autowrap
argument_list|(
name|dialog
argument_list|,
name|prompt
argument_list|,
name|height
operator|-
literal|1
argument_list|,
name|width
operator|-
literal|2
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|menu_width
operator|=
name|width
operator|-
literal|6
expr_stmt|;
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|box_y
operator|=
name|cur_y
operator|+
literal|1
expr_stmt|;
name|box_x
operator|=
operator|(
name|width
operator|-
name|menu_width
operator|)
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
comment|/* create new window for the menu */
name|menu
operator|=
name|subwin
argument_list|(
name|dialog
argument_list|,
name|menu_height
argument_list|,
name|menu_width
argument_list|,
name|y
operator|+
name|box_y
operator|+
literal|1
argument_list|,
name|x
operator|+
name|box_x
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|==
name|NULL
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nsubwin(dialog,%d,%d,%d,%d) failed, maybe wrong dims\n"
argument_list|,
name|menu_height
argument_list|,
name|menu_width
argument_list|,
name|y
operator|+
name|box_y
operator|+
literal|1
argument_list|,
name|x
operator|+
name|box_x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|keypad
argument_list|(
name|menu
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* draw a box around the menu items */
name|draw_box
argument_list|(
name|dialog
argument_list|,
name|box_y
argument_list|,
name|box_x
argument_list|,
name|menu_height
operator|+
literal|2
argument_list|,
name|menu_width
operator|+
literal|2
argument_list|,
name|menubox_border_attr
argument_list|,
name|menubox_attr
argument_list|)
expr_stmt|;
name|item_x
operator|=
literal|1
expr_stmt|;
comment|/* Print the menu */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_choice
condition|;
name|i
operator|++
control|)
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|i
operator|)
index|]
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|choice
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|print_arrows
argument_list|(
name|dialog
argument_list|,
name|scroll
argument_list|,
name|menu_height
argument_list|,
name|item_no
argument_list|,
name|box_x
argument_list|,
name|box_y
argument_list|,
name|item_x
argument_list|,
name|cur_x
argument_list|,
name|cur_y
argument_list|)
expr_stmt|;
name|print_position
argument_list|(
name|dialog
argument_list|,
name|box_x
operator|+
name|menu_width
argument_list|,
name|box_y
operator|+
name|menu_height
argument_list|,
name|scroll
operator|+
name|choice
argument_list|,
name|item_no
argument_list|)
expr_stmt|;
name|display_helpline
argument_list|(
name|dialog
argument_list|,
name|height
operator|-
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|x
operator|=
name|width
operator|/
literal|2
operator|-
literal|11
expr_stmt|;
name|y
operator|=
name|height
operator|-
literal|2
expr_stmt|;
name|print_button
argument_list|(
name|dialog
argument_list|,
literal|"Cancel"
argument_list|,
name|y
argument_list|,
name|x
operator|+
literal|14
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|print_button
argument_list|(
name|dialog
argument_list|,
literal|"  OK  "
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
while|while
condition|(
name|key
operator|!=
name|ESC
condition|)
block|{
name|key
operator|=
name|wgetch
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
comment|/* Check if key pressed matches first character of any item tag in menu */
if|if
condition|(
name|key
operator|==
name|KEY_UP
operator|||
name|key
operator|==
name|KEY_DOWN
operator|||
name|key
operator|==
literal|'-'
operator|||
name|key
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|KEY_UP
operator|||
name|key
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|choice
condition|)
block|{
if|if
condition|(
name|scroll
condition|)
block|{
ifdef|#
directive|ifdef
name|BROKEN_WSCRL
comment|/* wscrl() in ncurses 1.8.1 seems to be broken, causing a segmentation        violation when scrolling windows of height = 4, so scrolling is not        used for now */
name|scroll
operator|--
expr_stmt|;
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Save cursor position */
comment|/* Reprint menu to scroll down */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_choice
condition|;
name|i
operator|++
control|)
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|i
operator|)
index|]
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|choice
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Scroll menu down */
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Save cursor position */
if|if
condition|(
name|menu_height
operator|>
literal|1
condition|)
block|{
comment|/* De-highlight current first item before scrolling down */
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
name|scroll
index|]
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|menu
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wscrl
argument_list|(
name|menu
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|menu
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|scroll
operator|--
expr_stmt|;
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
name|scroll
index|]
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wnoutrefresh
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|print_arrows
argument_list|(
name|dialog
argument_list|,
name|scroll
argument_list|,
name|menu_height
argument_list|,
name|item_no
argument_list|,
name|box_x
argument_list|,
name|box_y
argument_list|,
name|item_x
argument_list|,
name|cur_x
argument_list|,
name|cur_y
argument_list|)
expr_stmt|;
name|print_position
argument_list|(
name|dialog
argument_list|,
name|box_x
operator|+
name|menu_width
argument_list|,
name|box_y
operator|+
name|menu_height
argument_list|,
name|scroll
operator|+
name|choice
argument_list|,
name|item_no
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Restore cursor to previous position */
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* wait for another key press */
block|}
else|else
name|i
operator|=
name|choice
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|KEY_DOWN
operator|||
name|key
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|choice
operator|==
name|max_choice
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|scroll
operator|+
name|choice
operator|<
name|item_no
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|BROKEN_WSCRL
comment|/* wscrl() in ncurses 1.8.1 seems to be broken, causing a segmentation        violation when scrolling windows of height = 4, so scrolling is not        used for now */
name|scroll
operator|++
expr_stmt|;
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Save cursor position */
comment|/* Reprint menu to scroll up */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_choice
condition|;
name|i
operator|++
control|)
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|i
operator|)
index|]
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|choice
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Scroll menu up */
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Save cursor position */
if|if
condition|(
name|menu_height
operator|>
literal|1
condition|)
block|{
comment|/* De-highlight current last item before scrolling up */
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|max_choice
operator|-
literal|1
operator|)
index|]
argument_list|,
name|max_choice
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|menu
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|scroll
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|menu
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|scroll
operator|++
expr_stmt|;
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|max_choice
operator|-
literal|1
operator|)
index|]
argument_list|,
name|max_choice
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wnoutrefresh
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|print_arrows
argument_list|(
name|dialog
argument_list|,
name|scroll
argument_list|,
name|menu_height
argument_list|,
name|item_no
argument_list|,
name|box_x
argument_list|,
name|box_y
argument_list|,
name|item_x
argument_list|,
name|cur_x
argument_list|,
name|cur_y
argument_list|)
expr_stmt|;
name|print_position
argument_list|(
name|dialog
argument_list|,
name|box_x
operator|+
name|menu_width
argument_list|,
name|box_y
operator|+
name|menu_height
argument_list|,
name|scroll
operator|+
name|choice
argument_list|,
name|item_no
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Restore cursor to previous position */
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* wait for another key press */
block|}
else|else
name|i
operator|=
name|choice
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|choice
condition|)
block|{
comment|/* De-highlight current item */
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Save cursor position */
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|choice
operator|)
index|]
argument_list|,
name|choice
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Highlight new item */
name|choice
operator|=
name|i
expr_stmt|;
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|choice
operator|)
index|]
argument_list|,
name|choice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|print_position
argument_list|(
name|dialog
argument_list|,
name|box_x
operator|+
name|menu_width
argument_list|,
name|box_y
operator|+
name|menu_height
argument_list|,
name|scroll
operator|+
name|choice
argument_list|,
name|item_no
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Restore cursor to previous position */
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* wait for another key press */
block|}
comment|/* save info about menu item position */
if|if
condition|(
name|ch
condition|)
operator|*
name|ch
operator|=
name|choice
expr_stmt|;
if|if
condition|(
name|sc
condition|)
operator|*
name|sc
operator|=
name|scroll
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|KEY_PPAGE
case|:
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
if|if
condition|(
name|scroll
operator|>
name|menu_height
condition|)
block|{
comment|/* can we go up? */
name|scroll
operator|-=
operator|(
name|menu_height
operator|)
expr_stmt|;
block|}
else|else
block|{
name|scroll
operator|=
literal|0
expr_stmt|;
block|}
name|redraw_menu
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|KEY_NPAGE
case|:
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|scroll
operator|+
name|menu_height
operator|>=
name|item_no
operator|-
literal|1
operator|-
name|menu_height
condition|)
block|{
comment|/* can we go down a full page? */
name|scroll
operator|=
name|item_no
operator|-
name|menu_height
expr_stmt|;
if|if
condition|(
name|scroll
operator|<
literal|0
condition|)
name|scroll
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scroll
operator|+=
name|menu_height
expr_stmt|;
block|}
name|redraw_menu
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|KEY_HOME
case|:
case|case
literal|'g'
case|:
name|scroll
operator|=
literal|0
expr_stmt|;
name|choice
operator|=
literal|0
expr_stmt|;
name|redraw_menu
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|KEY_END
case|:
case|case
literal|'G'
case|:
name|scroll
operator|=
name|item_no
operator|-
name|menu_height
expr_stmt|;
if|if
condition|(
name|scroll
operator|<
literal|0
condition|)
name|scroll
operator|=
literal|0
expr_stmt|;
name|choice
operator|=
name|max_choice
operator|-
literal|1
expr_stmt|;
name|redraw_menu
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
case|case
literal|'o'
case|:
name|delwin
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|scroll
operator|+
name|choice
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
name|delwin
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|KEY_BTAB
case|:
case|case
name|TAB
case|:
case|case
name|KEY_LEFT
case|:
case|case
name|KEY_RIGHT
case|:
if|if
condition|(
operator|!
name|button
condition|)
block|{
name|button
operator|=
literal|1
expr_stmt|;
comment|/* Indicates "Cancel" button is selected */
name|print_button
argument_list|(
name|dialog
argument_list|,
literal|"  OK  "
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|print_button
argument_list|(
name|dialog
argument_list|,
literal|"Cancel"
argument_list|,
name|y
argument_list|,
name|x
operator|+
literal|14
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|button
operator|=
literal|0
expr_stmt|;
comment|/* Indicates "OK" button is selected */
name|print_button
argument_list|(
name|dialog
argument_list|,
literal|"Cancel"
argument_list|,
name|y
argument_list|,
name|x
operator|+
literal|14
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|print_button
argument_list|(
name|dialog
argument_list|,
literal|"  OK  "
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|delwin
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|button
condition|)
operator|*
name|result
operator|=
name|scroll
operator|+
name|choice
expr_stmt|;
return|return
name|button
return|;
case|case
name|ESC
case|:
break|break;
case|case
name|KEY_F
argument_list|(
literal|1
argument_list|)
case|:
case|case
literal|'?'
case|:
name|display_helpfile
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|redraw_menu
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_choice
condition|;
name|i
operator|++
control|)
block|{
name|print_item
argument_list|(
name|menu
argument_list|,
name|items
index|[
operator|(
name|scroll
operator|+
name|i
operator|)
index|]
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|choice
argument_list|)
expr_stmt|;
block|}
name|wnoutrefresh
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Save cursor position */
name|print_arrows
argument_list|(
name|dialog
argument_list|,
name|scroll
argument_list|,
name|menu_height
argument_list|,
name|item_no
argument_list|,
name|box_x
argument_list|,
name|box_y
argument_list|,
name|item_x
argument_list|,
name|cur_x
argument_list|,
name|cur_y
argument_list|)
expr_stmt|;
name|print_position
argument_list|(
name|dialog
argument_list|,
name|box_x
operator|+
name|menu_width
argument_list|,
name|box_y
operator|+
name|menu_height
argument_list|,
name|scroll
operator|+
name|choice
argument_list|,
name|item_no
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Restore cursor to previous position */
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|redraw_menu
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|delwin
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* ESC pressed */
block|}
end_function

begin_comment
comment|/* End of dialog_treemenu() */
end_comment

begin_comment
comment|/*  * Print menu item  */
end_comment

begin_function
specifier|static
name|void
name|print_item
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|struct
name|leaf
name|item
parameter_list|,
name|int
name|choice
parameter_list|,
name|int
name|selected
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
name|menu_width
operator|-
literal|2
decl_stmt|;
name|char
modifier|*
name|branches
init|=
name|item
operator|.
name|branches
decl_stmt|;
comment|/* Clear 'residue' of last item */
name|wattrset
argument_list|(
name|win
argument_list|,
name|menubox_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|choice
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|menu_width
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|choice
argument_list|,
name|item_x
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|branches
operator|&&
name|j
condition|)
block|{
switch|switch
condition|(
operator|*
name|branches
operator|++
condition|)
block|{
case|case
literal|' '
case|:
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|waddch
argument_list|(
name|win
argument_list|,
name|ACS_VLINE
argument_list|)
expr_stmt|;
block|}
name|j
operator|--
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
name|j
condition|)
block|{
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
condition|)
block|{
switch|switch
condition|(
name|item
operator|.
name|slip
condition|)
block|{
case|case
literal|'+'
case|:
name|waddch
argument_list|(
name|win
argument_list|,
name|ACS_LTEE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
name|waddch
argument_list|(
name|win
argument_list|,
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
block|}
name|j
operator|--
expr_stmt|;
block|}
name|i
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
name|j
condition|)
block|{
name|waddch
argument_list|(
name|win
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|selected
condition|?
name|item_selected_attr
else|:
name|item_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|waddnstr
argument_list|(
name|win
argument_list|,
name|item
operator|.
name|name
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of print_item() */
end_comment

begin_comment
comment|/*  * Print current position  */
end_comment

begin_function
specifier|static
name|void
name|print_position
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|cur_pos
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|percent
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|position_indicator_attr
argument_list|)
expr_stmt|;
name|percent
operator|=
name|cur_pos
operator|==
name|size
operator|-
literal|1
condition|?
literal|100
else|:
operator|(
name|cur_pos
operator|*
literal|100
operator|)
operator|/
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|x
operator|-
literal|6
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"(%3d%%)"
argument_list|,
name|percent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of print_position() */
end_comment

begin_comment
comment|/*  * Display a tree menu from file  *  * filename	- file with like find(1) output  * FS		- fields separator  * title	- title of dialog box  * prompt	- prompt text into dialog box  * height	- height of dialog box  * width	- width of dialog box  * menu_height	- height of menu box  * result	- pointer to char array  *  * return values:  * -1		- ESC pressed  * 0		- Ok, result set (must be freed later)  * 1		- Cancel  */
end_comment

begin_function
name|int
name|dialog_ftree
parameter_list|(
name|unsigned
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|unsigned
name|char
modifier|*
name|title
parameter_list|,
name|unsigned
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|menu_height
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|retcode
decl_stmt|,
name|choice
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|leaf
modifier|*
name|items
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
if|if
condition|(
name|mk_ftree
argument_list|(
name|filename
argument_list|,
operator|&
name|names
argument_list|,
operator|&
name|size
argument_list|,
name|FS
argument_list|,
operator|&
name|items
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"dialog_ftree"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndialog_ftree: file %s is empty\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|retcode
operator|=
name|dialog_treemenu
argument_list|(
name|title
argument_list|,
name|prompt
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|menu_height
argument_list|,
name|size
argument_list|,
name|items
argument_list|,
operator|&
name|choice
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_leafs
argument_list|(
name|items
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retcode
condition|)
operator|*
name|result
operator|=
name|free_names
argument_list|(
name|names
argument_list|,
name|size
argument_list|,
name|choice
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|free_names
argument_list|(
name|names
argument_list|,
name|size
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/* End of dialog_ftree() */
end_comment

begin_comment
comment|/*  * Display a tree menu from array  *  * names	- array with like find(1) output  * size		- size of array  * FS		- fields separator  * title	- title of dialog box  * prompt	- prompt text into dialog box  * height	- height of dialog box  * width	- width of dialog box  * menu_height	- height of menu box  * result	- pointer to char array  *  * return values:  * -1		- ESC pressed  * 0		- Ok, result set  * 1		- Cancel  */
end_comment

begin_function
name|int
name|dialog_tree
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|unsigned
name|char
modifier|*
name|title
parameter_list|,
name|unsigned
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|menu_height
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|retcode
decl_stmt|,
name|choice
decl_stmt|;
name|struct
name|leaf
modifier|*
name|items
decl_stmt|;
name|struct
name|saved_tree
modifier|*
name|st
decl_stmt|;
specifier|static
name|struct
name|queue
modifier|*
name|q_saved_tree
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndialog_tree: source array is empty\n"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mk_tree
argument_list|(
name|names
argument_list|,
name|size
argument_list|,
name|FS
argument_list|,
operator|&
name|items
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"dialog_tree"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* is tree saved ? */
if|if
condition|(
operator|!
operator|(
name|st
operator|=
name|search_saved_tree
argument_list|(
name|q_saved_tree
argument_list|,
name|names
argument_list|,
name|size
argument_list|,
name|FS
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|menu_height
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|q_saved_tree
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|q_saved_tree
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|queue
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"dialog_tree"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|st
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_tree
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"dialog_tree"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|names
operator|=
name|names
expr_stmt|;
name|st
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|st
operator|->
name|FS
operator|=
name|FS
expr_stmt|;
name|st
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|st
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|st
operator|->
name|menu_height
operator|=
name|menu_height
expr_stmt|;
if|if
condition|(
operator|!
name|p2_queue
argument_list|(
name|q_saved_tree
argument_list|,
name|st
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"dialog_tree"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|retcode
operator|=
name|dialog_treemenu
argument_list|(
name|title
argument_list|,
name|prompt
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|menu_height
argument_list|,
name|size
argument_list|,
name|items
argument_list|,
operator|&
name|choice
argument_list|,
operator|&
operator|(
name|st
operator|->
name|ch
operator|)
argument_list|,
operator|&
operator|(
name|st
operator|->
name|sc
operator|)
argument_list|)
expr_stmt|;
name|free_leafs
argument_list|(
name|items
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retcode
condition|)
operator|*
name|result
operator|=
name|names
index|[
name|choice
index|]
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/* End of dialog_tree() */
end_comment

begin_comment
comment|/* utils for ftree */
end_comment

begin_comment
comment|/* init struct queue by zeros */
end_comment

begin_function
specifier|static
name|void
name|init_queue
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|queue
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add pointer to queue */
end_comment

begin_comment
comment|/* return - pointer or NULL if error */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|p2_queue
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|void
modifier|*
name|pointer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|queue
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|queue
operator|->
name|first
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|queue
operator|->
name|first
operator|=
name|queue
operator|->
name|last
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m_queue
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|queue
operator|->
name|last
operator|->
name|next
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m_queue
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|queue
operator|->
name|last
operator|=
name|queue
operator|->
name|last
operator|->
name|next
expr_stmt|;
block|}
name|queue
operator|->
name|size
operator|++
expr_stmt|;
return|return
name|queue
operator|->
name|last
operator|->
name|pointer
operator|=
name|pointer
return|;
block|}
end_function

begin_comment
comment|/* get first from queue */
end_comment

begin_comment
comment|/* return - pointer or NULL if queue is empty */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|first_queue
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|)
block|{
name|void
modifier|*
name|retval
decl_stmt|;
name|struct
name|m_queue
modifier|*
name|new_first
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|||
operator|!
name|queue
operator|->
name|first
operator|||
operator|!
name|queue
operator|->
name|size
condition|)
return|return
name|NULL
return|;
name|retval
operator|=
name|queue
operator|->
name|first
operator|->
name|pointer
expr_stmt|;
name|new_first
operator|=
name|queue
operator|->
name|first
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|queue
operator|->
name|first
argument_list|)
expr_stmt|;
name|queue
operator|->
name|first
operator|=
name|new_first
expr_stmt|;
name|queue
operator|->
name|size
operator|--
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* make zero terminated array from queue */
end_comment

begin_comment
comment|/* return - pointer to array or NULL if error */
end_comment

begin_function
specifier|static
name|void
modifier|*
modifier|*
name|q2arr
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|mono
decl_stmt|,
modifier|*
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|||
operator|!
name|queue
operator|->
name|first
operator|||
operator|!
name|queue
operator|->
name|size
condition|)
return|return
name|NULL
return|;
comment|/* memory allocation for array */
if|if
condition|(
operator|!
operator|(
name|mono
operator|=
name|end
operator|=
name|malloc
argument_list|(
name|depth
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|depth
operator|--
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|end
operator|++
operator|=
name|first_queue
argument_list|(
name|queue
argument_list|)
operator|)
condition|)
break|break;
block|}
operator|*
name|end
operator|=
name|NULL
expr_stmt|;
return|return
name|mono
return|;
block|}
end_function

begin_comment
comment|/*  * smart_tree (for like find(1) with -d flag output compliance)  *  * return values:  * NULL - malloc error  * not NULL - ok  *  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|smart_tree
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|unsigned
name|char
modifier|*
name|current
parameter_list|,
name|unsigned
name|char
modifier|*
name|prev
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|pcurrent
init|=
name|current
decl_stmt|,
modifier|*
name|pprev
init|=
name|prev
decl_stmt|,
modifier|*
name|toqueue
decl_stmt|;
specifier|register
name|char
name|break_flag
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|pcurrent
operator|&&
operator|*
name|pprev
condition|)
block|{
if|if
condition|(
operator|*
name|pcurrent
operator|==
operator|*
name|pprev
condition|)
block|{
name|pcurrent
operator|++
expr_stmt|;
name|pprev
operator|++
expr_stmt|;
block|}
else|else
block|{
name|break_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|pprev
operator|||
name|break_flag
condition|)
block|{
if|if
condition|(
operator|*
name|pcurrent
operator|==
name|FS
condition|)
block|{
name|pcurrent
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|*
name|prev
operator|)
operator|&&
operator|(
operator|*
name|pcurrent
operator|)
condition|)
block|{
name|unsigned
name|char
name|tchar
init|=
operator|*
name|pcurrent
decl_stmt|;
operator|*
name|pcurrent
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toqueue
operator|=
name|strdup
argument_list|(
name|current
argument_list|)
operator|)
condition|)
block|{
operator|*
name|pcurrent
operator|=
name|tchar
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|p2_queue
argument_list|(
name|queue
argument_list|,
name|toqueue
argument_list|)
condition|)
block|{
operator|*
name|pcurrent
operator|=
name|tchar
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|pcurrent
operator|=
name|tchar
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|pcurrent
condition|)
block|{
if|if
condition|(
operator|*
name|pcurrent
operator|==
name|FS
condition|)
block|{
operator|*
name|pcurrent
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|toqueue
operator|=
name|strdup
argument_list|(
name|current
argument_list|)
operator|)
condition|)
block|{
operator|*
name|pcurrent
operator|=
name|FS
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|p2_queue
argument_list|(
name|queue
argument_list|,
name|toqueue
argument_list|)
condition|)
block|{
operator|*
name|pcurrent
operator|=
name|FS
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|pcurrent
operator|=
name|FS
expr_stmt|;
block|}
name|pcurrent
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p2_queue
argument_list|(
name|queue
argument_list|,
name|current
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|current
return|;
block|}
end_function

begin_comment
comment|/* end of utils for ftree */
end_comment

begin_comment
comment|/* utils for make tree */
end_comment

begin_comment
comment|/* if error - return -1 */
end_comment

begin_function
specifier|static
name|int
name|mk_slip
parameter_list|(
name|struct
name|leaf
name|array
index|[]
parameter_list|,
name|int
name|arr_size
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|int
name|t_number
decl_stmt|;
name|int
name|t_shift
decl_stmt|;
if|if
condition|(
name|number
operator|>
name|arr_size
operator|-
literal|1
condition|)
return|return
name|number
operator|-
literal|1
return|;
name|t_shift
operator|=
name|shift
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|array
index|[
name|number
index|]
operator|.
name|branches
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|t_shift
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|array
index|[
name|number
index|]
operator|.
name|branches
argument_list|,
literal|' '
argument_list|,
name|t_shift
argument_list|)
expr_stmt|;
name|t_number
operator|=
name|number
expr_stmt|;
while|while
condition|(
name|array
index|[
name|number
index|]
operator|.
name|shift
operator|<
name|array
index|[
name|t_number
operator|+
literal|1
index|]
operator|.
name|shift
condition|)
block|{
name|t_number
operator|=
name|mk_slip
argument_list|(
name|array
argument_list|,
name|arr_size
argument_list|,
name|t_number
operator|+
literal|1
argument_list|,
name|t_shift
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_number
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|t_number
operator|==
name|arr_size
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|array
index|[
name|number
index|]
operator|.
name|shift
operator|==
name|array
index|[
name|t_number
operator|+
literal|1
index|]
operator|.
name|shift
condition|)
name|array
index|[
name|number
index|]
operator|.
name|slip
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
operator|(
name|array
index|[
name|number
index|]
operator|.
name|shift
operator|>
name|array
index|[
name|t_number
operator|+
literal|1
index|]
operator|.
name|shift
operator|)
operator|||
name|t_number
operator|==
name|arr_size
operator|-
literal|1
condition|)
name|array
index|[
name|number
index|]
operator|.
name|slip
operator|=
literal|'`'
expr_stmt|;
return|return
name|t_number
return|;
block|}
end_function

begin_comment
comment|/* mk_slip() */
end_comment

begin_comment
comment|/* make tree from file  *  * filename	- name of file with like find(1) output  * p_names	- pointer to array of strings  * p_size	- pointer to size of array  * FS		- fields separator  * p_array	- pointer to array of leafs  *  * return values:  * 0		- ok and names by p_names, size by p_size, array by p_array set  * -1		- memory allocation error (errno set)  */
end_comment

begin_function
specifier|static
name|int
name|mk_ftree
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
modifier|*
name|p_names
parameter_list|,
name|int
modifier|*
name|p_size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|struct
name|leaf
modifier|*
modifier|*
name|p_array
parameter_list|)
block|{
name|int
name|NR
decl_stmt|;
comment|/* number of input records */
name|struct
name|queue
name|queue
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|sstring
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|FILE
modifier|*
name|input_file
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|input_file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|init_queue
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|string
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* read input file into queue */
while|while
condition|(
name|fgets
argument_list|(
name|string
argument_list|,
name|BUFSIZ
argument_list|,
name|input_file
argument_list|)
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\n'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|string
operator|=
name|realloc
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|smart_tree
argument_list|(
operator|&
name|queue
argument_list|,
name|FS
argument_list|,
name|string
argument_list|,
name|sstring
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|sstring
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|string
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* read input file into queue */
if|if
condition|(
name|fclose
argument_list|(
name|input_file
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|NR
operator|=
name|queue
operator|.
name|size
operator|)
condition|)
block|{
operator|*
name|p_size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* make array from queue */
if|if
condition|(
operator|!
operator|(
name|names
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|q2arr
argument_list|(
operator|&
name|queue
argument_list|,
name|NR
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|p_names
operator|=
name|names
expr_stmt|;
operator|*
name|p_size
operator|=
name|NR
expr_stmt|;
comment|/* make tree from array */
return|return
name|mk_tree
argument_list|(
name|names
argument_list|,
name|NR
argument_list|,
name|FS
argument_list|,
name|p_array
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* mk_ftree */
end_comment

begin_comment
comment|/* make tree from array  *  * names	- array of strings  * size		- size of array  * FS		- fields separator  * p_array	- pointer to array of leafs  *  * return values:  * 0		- ok and array by p_array set  * -1		- memory allocation error (errno set)  */
end_comment

begin_function
specifier|static
name|int
name|mk_tree
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|struct
name|leaf
modifier|*
modifier|*
name|p_array
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|leaf
modifier|*
name|array
decl_stmt|;
comment|/* make array of leafs */
if|if
condition|(
operator|!
operator|(
name|array
operator|=
name|calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|leaf
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* init leafs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|in_string
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|in_string
operator|=
name|name
operator|=
name|names
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|in_string
condition|)
block|{
if|if
condition|(
operator|*
name|in_string
operator|==
name|FS
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
operator|*
operator|(
name|in_string
operator|+
literal|1
operator|)
condition|)
name|name
operator|=
name|in_string
expr_stmt|;
else|else
block|{
name|shift
operator|++
expr_stmt|;
name|name
operator|=
name|in_string
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|in_string
operator|++
expr_stmt|;
block|}
name|array
index|[
name|i
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|array
index|[
name|i
index|]
operator|.
name|shift
operator|=
name|shift
expr_stmt|;
name|array
index|[
name|i
index|]
operator|.
name|slip
operator|=
literal|'\0'
expr_stmt|;
name|array
index|[
name|i
index|]
operator|.
name|branches
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* init leafs */
comment|/* make slips */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|i
operator|=
name|mk_slip
argument_list|(
name|array
argument_list|,
name|size
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* make slips */
comment|/* make branches */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|src
init|=
name|array
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|branches
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
init|=
name|array
index|[
name|i
index|]
operator|.
name|branches
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
operator|*
name|dst
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dst
condition|)
switch|switch
condition|(
name|array
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|slip
condition|)
block|{
case|case
literal|'+'
case|:
operator|*
name|dst
operator|=
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
block|}
block|}
comment|/* make branches */
operator|*
name|p_array
operator|=
name|array
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* mk_tree() */
end_comment

begin_comment
comment|/* free memory from tree (leafs)  *  * return values:  * nothing  */
end_comment

begin_function
specifier|static
name|void
name|free_leafs
parameter_list|(
name|struct
name|leaf
modifier|*
name|array
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|leaf
modifier|*
name|p_array
init|=
name|array
decl_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
name|free
argument_list|(
name|array
operator|++
operator|->
name|branches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* free_leafs() */
end_comment

begin_comment
comment|/* free memory from source data for tree (names)  *  * return values:  * if 0<= choice<= size - pointer to name from names,   *	and memory for name not released (must be freed later)  * else - NULL (recomended choice -1 for it)  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|free_names
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|choice
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|p_names
init|=
name|names
decl_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|choice
operator|--
condition|)
name|retval
operator|=
operator|*
name|names
operator|++
expr_stmt|;
else|else
name|free
argument_list|(
operator|*
name|names
operator|++
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p_names
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* free_names() */
end_comment

begin_comment
comment|/* end of utils for make tree */
end_comment

begin_comment
comment|/* static utils for saved_tree */
end_comment

begin_comment
comment|/* search saved tree within queue */
end_comment

begin_comment
comment|/* return - struct *saved_tree or NULL if not found */
end_comment

begin_function
specifier|static
name|struct
name|saved_tree
modifier|*
name|search_saved_tree
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|size
parameter_list|,
name|unsigned
name|char
name|FS
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|menu_height
parameter_list|)
block|{
name|struct
name|m_queue
modifier|*
name|member
decl_stmt|;
name|struct
name|saved_tree
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|||
operator|!
name|names
operator|||
operator|!
name|FS
operator|||
operator|!
name|height
operator|||
operator|!
name|width
operator|||
operator|!
name|menu_height
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|member
operator|=
name|queue
operator|->
name|first
operator|)
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|member
operator|->
name|next
condition|)
block|{
name|retval
operator|=
name|member
operator|->
name|pointer
expr_stmt|;
if|if
condition|(
operator|(
name|names
operator|==
name|retval
operator|->
name|names
operator|)
operator|&&
operator|(
name|size
operator|==
name|retval
operator|->
name|size
operator|)
operator|&&
operator|(
name|FS
operator|==
name|retval
operator|->
name|FS
operator|)
operator|&&
operator|(
name|height
operator|==
name|retval
operator|->
name|height
operator|)
operator|&&
operator|(
name|width
operator|==
name|retval
operator|->
name|width
operator|)
operator|&&
operator|(
name|menu_height
operator|==
name|retval
operator|->
name|menu_height
operator|)
condition|)
return|return
name|retval
return|;
name|member
operator|=
name|member
operator|->
name|next
expr_stmt|;
block|}
name|retval
operator|=
name|member
operator|->
name|pointer
expr_stmt|;
if|if
condition|(
operator|(
name|names
operator|==
name|retval
operator|->
name|names
operator|)
operator|&&
operator|(
name|size
operator|==
name|retval
operator|->
name|size
operator|)
operator|&&
operator|(
name|FS
operator|==
name|retval
operator|->
name|FS
operator|)
operator|&&
operator|(
name|height
operator|==
name|retval
operator|->
name|height
operator|)
operator|&&
operator|(
name|width
operator|==
name|retval
operator|->
name|width
operator|)
operator|&&
operator|(
name|menu_height
operator|==
name|retval
operator|->
name|menu_height
operator|)
condition|)
return|return
name|retval
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* end of static utils for saved_tree */
end_comment

end_unit

