begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  dialog - Display simple dialog boxes from shell scripts  *  *  AUTHOR: Savio Lam (lam836@cs.cuhk.hk)  *  *  This program is free software; you can redistribute it and/or  *  modify it under the terms of the GNU General Public License  *  as published by the Free Software Foundation; either version 2  *  of the License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  *  *  HISTORY:  *  *  17/12/93 - Version 0.1 released.  *  *  19/12/93 - menu will now scroll if there are more items than can fit  *             on the screen.  *           - added 'checklist', a dialog box with a list of options that  *             can be turned on or off. A list of options that are on is  *             returned on exit.  *  *  20/12/93 - Version 0.15 released.  *  *  29/12/93 - Incorporated patch from Patrick J. Volkerding  *             (volkerdi@mhd1.moorhead.msus.edu) that made these changes:  *             - increased MAX_LEN to 2048  *             - added 'infobox', equivalent to a message box without pausing  *             - added option '--clear' that will clear the screen  *             - Explicit line breaking when printing prompt text can be  *               invoked by real newline '\n' besides the string "\n"  *           - an optional parameter '--title<string>' can be used to  *             specify a title string for the dialog box  *  *  03/01/94 - added 'textbox', a dialog box for displaying text from a file.  *           - Version 0.2 released.  *  *  04/01/94 - some fixes and improvements for 'textbox':  *             - fixed a bug that will cause a segmentation violation when a  *               line is longer than MAX_LEN characters. Lines will now be  *               truncated if they are longer than MAX_LEN characters.  *             - removed wrefresh() from print_line(). This will increase  *               efficiency of print_page() which calls print_line().  *             - display current position in the form of percentage into file.  *           - Version 0.21 released.  *  *  05/01/94 - some changes for faster screen update.  *  *  07/01/94 - much more flexible color settings. Can use all 16 colors  *             (8 normal, 8 highlight) of the Linux console.  *  *  08/01/94 - added run-time configuration using configuration file.  *  *  09/01/94 - some minor bug fixes and cleanups for menubox, checklist and  *             textbox.  *  *  11/01/94 - added a man page.  *  *  13/01/94 - some changes for easier porting to other Unix systems (tested  *             on Ultrix, SunOS and HPUX)  *           - Version 0.3 released.  *  *  08/06/94 - Patches by Stuart Herbert - S.Herbert@shef.ac.uk  * 	       Fixed attr_clear and the textbox stuff to work with ncurses 1.8.5  * 	       Fixed the wordwrap routine - it'll actually wrap properly now  *	       Added a more 3D look to everything - having your own rc file could  *	         prove 'interesting' to say the least :-)  *             Added radiolist option  *	     - Version 0.4 released.  */
end_comment

begin_define
define|#
directive|define
name|__DIALOG_MAIN__
end_define

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|"dialog.priv.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NCURSES
end_ifdef

begin_include
include|#
directive|include
file|"colors.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are two "secret" globals that can be fiddled to make a dialog  * come up someplace other than a "centered" calculation for X,Y  */
end_comment

begin_decl_stmt
name|int
name|DialogX
decl_stmt|,
name|DialogY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This "secret" global allows you to change the behavior of an input field */
end_comment

begin_decl_stmt
name|int
name|DialogInputAttrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Do some initialization for dialog  */
end_comment

begin_function
name|void
name|init_dialog
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|LOCALE
argument_list|)
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_NCURSES
if|if
condition|(
name|parse_rc
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* Read the configuration file */
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|initscr
argument_list|()
operator|==
name|NULL
condition|)
block|{
comment|/* Init curses */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nCurses initialization error.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NCURSES
if|if
condition|(
name|use_colors
operator|||
name|use_shadow
condition|)
comment|/* Set up colors */
name|color_setup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Set screen to screen attribute */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|DialogX
operator|=
name|DialogY
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of init_dialog() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NCURSES
end_ifdef

begin_comment
comment|/*  * Setup for color display  */
end_comment

begin_function
name|void
name|color_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
comment|/* Terminal supports color? */
name|start_color
argument_list|()
expr_stmt|;
comment|/* Initialize color pairs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATTRIBUTE_COUNT
condition|;
name|i
operator|++
control|)
name|init_pair
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|color_table
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|color_table
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Setup color attributes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATTRIBUTE_COUNT
condition|;
name|i
operator|++
control|)
name|attributes
index|[
name|i
index|]
operator|=
name|C_ATTR
argument_list|(
name|color_table
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End of color_setup() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set window to attribute 'attr'  */
end_comment

begin_function
name|void
name|attr_clear
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|chtype
name|attr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|attr
argument_list|)
expr_stmt|;
comment|/* Set window to attribute 'attr' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End of attr_clear() */
end_comment

begin_comment
comment|/*  * Print a string of text in a window, automatically wrap around to the  * next line if the string is too long to fit on one line. Note that the  * string may contain "\n" to represent a newline character or the real  * newline '\n', but in that case, auto wrap around will be disabled.  */
end_comment

begin_function
name|void
name|print_autowrap
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|unsigned
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|maxwidth
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|center
parameter_list|,
name|int
name|rawmode
parameter_list|)
block|{
name|int
name|cur_x
decl_stmt|,
name|cur_y
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
name|tempstr
index|[
name|MAX_LEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|word
decl_stmt|,
modifier|*
name|tempptr
decl_stmt|,
modifier|*
name|tempptr1
decl_stmt|;
name|chtype
name|ostuff
index|[
literal|132
index|]
decl_stmt|,
name|attrs
init|=
literal|0
decl_stmt|,
name|init_bottom
init|=
literal|0
decl_stmt|;
name|wsetscrreg
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tempstr
argument_list|,
name|prompt
argument_list|,
name|MAX_LEN
argument_list|)
expr_stmt|;
name|tempstr
index|[
name|MAX_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|rawmode
operator|&&
name|strstr
argument_list|(
name|tempstr
argument_list|,
literal|"\\n"
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|strchr
argument_list|(
name|tempstr
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Prompt contains "\n" or '\n' */
name|word
operator|=
name|tempstr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tempptr
operator|=
name|rawmode
condition|?
name|NULL
else|:
name|strstr
argument_list|(
name|word
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
name|tempptr1
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempptr
operator|==
name|NULL
operator|&&
name|tempptr1
operator|==
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|tempptr
operator|==
name|NULL
condition|)
block|{
comment|/* No more "\n" */
name|tempptr
operator|=
name|tempptr1
expr_stmt|;
name|tempptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tempptr1
operator|==
name|NULL
condition|)
block|{
comment|/* No more '\n' */
name|tempptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempptr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Prompt contains both "\n" and '\n' */
if|if
condition|(
name|strlen
argument_list|(
name|tempptr
argument_list|)
operator|-
literal|2
operator|<
name|strlen
argument_list|(
name|tempptr1
argument_list|)
operator|-
literal|1
condition|)
block|{
name|tempptr
operator|=
name|tempptr1
expr_stmt|;
name|tempptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|tempptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempptr
operator|++
expr_stmt|;
block|}
block|}
name|waddstr
argument_list|(
name|win
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|tempptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|cur_y
operator|>
name|height
condition|)
block|{
name|cur_y
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|init_bottom
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
name|ostuff
index|[
name|i
index|]
operator|=
name|mvwinch
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|width
init|;
name|i
operator|<
name|maxwidth
condition|;
name|i
operator|++
control|)
name|ostuff
index|[
name|i
index|]
operator|=
name|mvwinch
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|getattrs
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|init_bottom
operator|=
literal|1
expr_stmt|;
block|}
name|scrollok
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|win
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
block|{
name|wattrset
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
operator|&
name|A_ATTRIBUTES
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|maxwidth
condition|;
name|i
operator|++
control|)
block|{
name|wattrset
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
operator|&
name|A_ATTRIBUTES
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
operator|=
name|x
argument_list|)
expr_stmt|;
block|}
name|waddstr
argument_list|(
name|win
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|center
operator|&&
name|strlen
argument_list|(
name|tempstr
argument_list|)
operator|<=
name|width
operator|-
name|x
operator|*
literal|2
condition|)
block|{
comment|/* If prompt is short */
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
operator|(
name|width
operator|-
name|strlen
argument_list|(
name|tempstr
argument_list|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
name|tempstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|center
operator|&&
name|strlen
argument_list|(
name|tempstr
argument_list|)
operator|<=
name|width
operator|-
name|cur_x
condition|)
block|{
comment|/* If prompt is short */
name|waddstr
argument_list|(
name|win
argument_list|,
name|tempstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|tempstr
decl_stmt|;
comment|/* Print prompt word by word, wrap around if necessary */
while|while
condition|(
operator|(
name|word
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|"\t\n "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|loop
decl_stmt|;
name|unsigned
name|char
name|sc
decl_stmt|;
if|if
condition|(
operator|*
name|word
operator|==
literal|'\0'
condition|)
continue|continue;
do|do
block|{
name|loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cur_x
operator|+
name|strlen
argument_list|(
name|word
argument_list|)
operator|>=
name|width
operator|+
literal|1
condition|)
block|{
comment|/* wrap around to next line */
if|if
condition|(
name|x
operator|+
name|strlen
argument_list|(
name|word
argument_list|)
operator|>=
name|width
operator|+
literal|1
condition|)
block|{
name|sc
operator|=
name|word
index|[
name|width
operator|-
name|cur_x
operator|-
literal|1
index|]
expr_stmt|;
name|word
index|[
name|width
operator|-
name|cur_x
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
index|[
name|width
operator|-
name|cur_x
operator|-
literal|1
index|]
operator|=
name|sc
expr_stmt|;
name|word
operator|+=
name|width
operator|-
name|cur_x
operator|-
literal|1
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|1
expr_stmt|;
block|}
name|cur_y
operator|++
expr_stmt|;
name|cur_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|cur_y
operator|>
name|height
condition|)
block|{
name|cur_y
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|init_bottom
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
name|ostuff
index|[
name|i
index|]
operator|=
name|mvwinch
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|width
init|;
name|i
operator|<
name|maxwidth
condition|;
name|i
operator|++
control|)
name|ostuff
index|[
name|i
index|]
operator|=
name|mvwinch
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|getattrs
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|init_bottom
operator|=
literal|1
expr_stmt|;
block|}
name|scrollok
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|win
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
block|{
name|wattrset
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
operator|&
name|A_ATTRIBUTES
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|maxwidth
condition|;
name|i
operator|++
control|)
block|{
name|wattrset
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
operator|&
name|A_ATTRIBUTES
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|ostuff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|cur_x
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* End of print_autowrap() */
end_comment

begin_comment
comment|/*  * Print a button  */
end_comment

begin_function
name|void
name|print_button
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|unsigned
name|char
modifier|*
name|label
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|selected
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|temp
decl_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|selected
condition|?
name|button_active_attr
else|:
name|button_inactive_attr
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
name|selected
condition|?
literal|"["
else|:
literal|" "
argument_list|)
expr_stmt|;
name|temp
operator|=
name|strspn
argument_list|(
name|label
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|label
operator|+=
name|temp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|temp
condition|;
name|i
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|selected
condition|?
name|button_key_active_attr
else|:
name|button_key_inactive_attr
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|label
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|selected
condition|?
name|button_active_attr
else|:
name|button_inactive_attr
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
name|label
operator|+
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
name|selected
condition|?
literal|"]"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|temp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of print_button() */
end_comment

begin_comment
comment|/*  * Draw a rectangular box with line drawing characters  */
end_comment

begin_function
name|void
name|draw_box
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|chtype
name|box
parameter_list|,
name|chtype
name|border
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
operator|+
name|i
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|j
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|border
operator||
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|height
operator|-
literal|1
operator|&&
operator|!
name|j
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|border
operator||
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
operator|&&
name|j
operator|==
name|width
operator|-
literal|1
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|box
operator||
name|ACS_URCORNER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|height
operator|-
literal|1
operator|&&
name|j
operator|==
name|width
operator|-
literal|1
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|box
operator||
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|border
operator||
name|ACS_HLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|height
operator|-
literal|1
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|box
operator||
name|ACS_HLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|j
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|border
operator||
name|ACS_VLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
name|width
operator|-
literal|1
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|box
operator||
name|ACS_VLINE
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|win
argument_list|,
name|box
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End of draw_box() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NCURSES
end_ifdef

begin_comment
comment|/*  * Draw shadows along the right and bottom edge to give a more 3D look  * to the boxes  */
end_comment

begin_function
name|void
name|draw_shadow
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|chtype
name|attrs
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
comment|/* Whether terminal supports color? */
name|getbegyx
argument_list|(
name|win
argument_list|,
name|sy
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|getattrs
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|+
name|height
operator|<
name|getmaxy
argument_list|(
name|win
argument_list|)
condition|)
block|{
comment|/* small touch */
name|wattrset
argument_list|(
name|win
argument_list|,
name|A_INVIS
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
operator|+
name|height
argument_list|,
name|x
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|+
name|x
operator|+
literal|2
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* end touch */
name|wattrset
argument_list|(
name|win
argument_list|,
name|shadow_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
operator|+
name|height
argument_list|,
name|x
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|+
name|x
operator|+
literal|2
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|mvwinch
argument_list|(
name|newscr
argument_list|,
name|sy
operator|+
name|y
operator|+
name|height
argument_list|,
name|sx
operator|+
name|x
operator|+
literal|2
operator|+
name|i
argument_list|)
operator|&
name|A_CHARTEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|+
name|width
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|y
operator|+
literal|1
init|;
name|i
operator|<
name|y
operator|+
name|height
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|getmaxy
argument_list|(
name|win
argument_list|)
condition|)
block|{
comment|/* small touch */
name|wattrset
argument_list|(
name|win
argument_list|,
name|A_INVIS
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|i
argument_list|,
name|x
operator|+
name|width
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|width
operator|+
literal|1
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* end touch */
name|wattrset
argument_list|(
name|win
argument_list|,
name|shadow_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|i
argument_list|,
name|x
operator|+
name|width
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|mvwinch
argument_list|(
name|newscr
argument_list|,
name|sy
operator|+
name|i
argument_list|,
name|sx
operator|+
name|x
operator|+
name|width
argument_list|)
operator|&
name|A_CHARTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|width
operator|+
literal|1
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
name|mvwinch
argument_list|(
name|newscr
argument_list|,
name|sy
operator|+
name|i
argument_list|,
name|sx
operator|+
name|x
operator|+
name|width
operator|+
literal|1
argument_list|)
operator|&
name|A_CHARTEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End of draw_shadow() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dialog_clear_norefresh
parameter_list|(
name|void
parameter_list|)
block|{
name|attr_clear
argument_list|(
name|stdscr
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|,
name|screen_attr
argument_list|)
expr_stmt|;
name|touchwin
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dialog_clear
parameter_list|(
name|void
parameter_list|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dialog_update
parameter_list|(
name|void
parameter_list|)
block|{
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_dialog
parameter_list|(
name|void
parameter_list|)
block|{
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|strwidth
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|incr
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
for|for
control|(
name|start
operator|=
name|s
operator|=
name|p
init|;
condition|;
name|start
operator|=
operator|(
name|s
operator|+=
name|incr
operator|)
control|)
block|{
name|s1
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|s2
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
name|s
operator|=
name|s1
expr_stmt|;
elseif|else
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
name|s
operator|=
name|s2
expr_stmt|;
else|else
name|s
operator|=
name|MIN
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
name|incr
operator|=
literal|1
operator|+
operator|(
name|s
operator|==
name|s2
operator|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|i
condition|)
name|i
operator|=
name|len
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|i
condition|)
name|i
operator|=
name|len
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|strheight
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|,
name|incr
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
for|for
control|(
name|s
operator|=
name|p
init|;
condition|;
name|s
operator|+=
name|incr
control|)
block|{
name|s1
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|s2
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
name|s
operator|=
name|s1
expr_stmt|;
elseif|else
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
name|s
operator|=
name|s2
expr_stmt|;
else|else
name|s
operator|=
name|MIN
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
name|incr
operator|=
literal|1
operator|+
operator|(
name|s
operator|==
name|s2
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|print_arrows
parameter_list|(
name|WINDOW
modifier|*
name|dialog
parameter_list|,
name|int
name|scroll
parameter_list|,
name|int
name|menu_height
parameter_list|,
name|int
name|item_no
parameter_list|,
name|int
name|box_x
parameter_list|,
name|int
name|box_y
parameter_list|,
name|int
name|tag_x
parameter_list|,
name|int
name|cur_x
parameter_list|,
name|int
name|cur_y
parameter_list|)
block|{
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|scroll
condition|?
name|uarrow_attr
else|:
name|menubox_attr
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
condition|?
name|ACS_UARROW
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|2
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
condition|?
literal|'('
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|3
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
condition|?
literal|'-'
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|4
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
condition|?
literal|')'
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
operator|+
name|menu_height
operator|+
literal|1
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|scroll
operator|+
name|menu_height
operator|<
name|item_no
condition|?
name|darrow_attr
else|:
name|menubox_border_attr
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
operator|+
name|menu_height
operator|<
name|item_no
condition|?
name|ACS_DARROW
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
operator|+
name|menu_height
operator|+
literal|1
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|2
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
operator|+
name|menu_height
operator|<
name|item_no
condition|?
literal|'('
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
operator|+
name|menu_height
operator|+
literal|1
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|3
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
operator|+
name|menu_height
operator|<
name|item_no
condition|?
literal|'+'
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|box_y
operator|+
name|menu_height
operator|+
literal|1
argument_list|,
name|box_x
operator|+
name|tag_x
operator|+
literal|4
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|dialog
argument_list|,
name|scroll
operator|+
name|menu_height
operator|<
name|item_no
condition|?
literal|')'
else|:
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|dialog
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
comment|/* Restore cursor position */
block|}
end_function

end_unit

