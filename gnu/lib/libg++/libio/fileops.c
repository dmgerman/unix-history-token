begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_comment
comment|/*  written by Per Bothner (bothner@cygnus.com) */
end_comment

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* An fstream can be in at most one of put mode, get mode, or putback mode.    Putback mode is a variant of get mode.     In a filebuf, there is only one current position, instead of two    separate get and put pointers.  In get mode, the current posistion    is that of gptr(); in put mode that of pptr().     The position in the buffer that corresponds to the position    in external file system is file_ptr().    This is normally egptr(), except in putback mode, when it is _save_egptr.    If the field _fb._offset is>= 0, it gives the offset in    the file as a whole corresponding to eGptr(). (???)     PUT MODE:    If a filebuf is in put mode, pbase() is non-NULL and equal to base().    Also, epptr() == ebuf().    Also, eback() == gptr()&& gptr() == egptr().    The un-flushed character are those between pbase() and pptr().    GET MODE:    If a filebuf is in get or putback mode, eback() != egptr().    In get mode, the unread characters are between gptr() and egptr().    The OS file position corresponds to that of egptr().    PUTBACK MODE:    Putback mode is used to remember "excess" characters that have    been sputbackc'd in a separate putback buffer.    In putback mode, the get buffer points to the special putback buffer.    The unread characters are the characters between gptr() and egptr()    in the putback buffer, as well as the area between save_gptr()    and save_egptr(), which point into the original reserve buffer.    (The pointers save_gptr() and save_egptr() are the values    of gptr() and egptr() at the time putback mode was entered.)    The OS position corresponds to that of save_egptr().        LINE BUFFERED OUTPUT:    During line buffered output, pbase()==base()&& epptr()==base().    However, ptr() may be anywhere between base() and ebuf().    This forces a call to filebuf::overflow(int C) on every put.    If there is more space in the buffer, and C is not a '\n',    then C is inserted, and pptr() incremented.        UNBUFFERED STREAMS:    If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer. */
end_comment

begin_define
define|#
directive|define
name|CLOSED_FILEBUF_FLAGS
define|\
value|(_IO_IS_FILEBUF+_IO_NO_READS+_IO_NO_WRITES+_IO_TIED_PUT_GET)
end_define

begin_function
name|void
name|_IO_file_init
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_0
expr_stmt|;
name|fp
operator|->
name|_IO_file_flags
operator||=
name|CLOSED_FILEBUF_FLAGS
expr_stmt|;
name|_IO_link_in
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_fileno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_IO_file_close_it
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|status
operator|=
name|fp
operator|->
name|_jumps
operator|->
name|__close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Free buffer. */
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_IO_un_link
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator|=
name|_IO_MAGIC
operator||
name|CLOSED_FILEBUF_FLAGS
expr_stmt|;
name|fp
operator|->
name|_fileno
operator|=
name|EOF
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_0
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|_IO_file_finish
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_DELETE_DONT_CLOSE
operator|)
condition|)
name|fp
operator|->
name|_jumps
operator|->
name|__close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|_IO_default_finish
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_file_fopen
parameter_list|(
name|fp
parameter_list|,
name|filename
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|oflags
init|=
literal|0
decl_stmt|,
name|omode
decl_stmt|;
name|int
name|read_write
decl_stmt|,
name|fdesc
decl_stmt|;
name|int
name|oprot
init|=
literal|0666
decl_stmt|;
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
operator|*
name|mode
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
name|omode
operator|=
name|O_RDONLY
expr_stmt|;
name|read_write
operator|=
name|_IO_NO_WRITES
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|omode
operator|=
name|O_WRONLY
expr_stmt|;
name|oflags
operator|=
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
name|read_write
operator|=
name|_IO_NO_READS
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|omode
operator|=
name|O_WRONLY
expr_stmt|;
name|oflags
operator|=
name|O_CREAT
operator||
name|O_APPEND
expr_stmt|;
name|read_write
operator|=
name|_IO_NO_READS
operator||
name|_IO_IS_APPENDING
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
operator|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|mode
index|[
literal|1
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
name|omode
operator|=
name|O_RDWR
expr_stmt|;
name|read_write
operator|&=
name|_IO_IS_APPENDING
expr_stmt|;
block|}
name|fdesc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|omode
operator||
name|oflags
argument_list|,
name|oprot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdesc
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|_fileno
operator|=
name|fdesc
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
name|read_write
argument_list|,
name|_IO_NO_READS
operator|+
name|_IO_NO_WRITES
operator|+
name|_IO_IS_APPENDING
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_write
operator|&
name|_IO_IS_APPENDING
condition|)
if|if
condition|(
name|fp
operator|->
name|_jumps
operator|->
name|__seekoff
argument_list|(
name|fp
argument_list|,
operator|(
name|_IO_off_t
operator|)
literal|0
argument_list|,
name|_IO_seek_end
argument_list|)
operator|==
name|_IO_pos_BAD
condition|)
return|return
name|NULL
return|;
name|_IO_link_in
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_file_attach
parameter_list|(
name|fp
parameter_list|,
name|fd
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|_IO_file_is_open
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|_fileno
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
operator|(
name|_IO_NO_READS
operator|+
name|_IO_NO_WRITES
operator|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_DELETE_DONT_CLOSE
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_setbuf
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|_IO_ssize_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|_IO_default_setbuf
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_IO_do_write
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|to_do
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|to_do
decl_stmt|;
block|{
name|_IO_size_t
name|count
decl_stmt|;
if|if
condition|(
name|to_do
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_IS_APPENDING
condition|)
comment|/* On a system without a proper O_APPEND implementation,        you would need to sys_seek(0, SEEK_END) here, but is        is not needed nor desirable for Unix- or Posix-like systems.        Instead, just indicate that offset (before and after) is        unpredictable. */
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|_IO_read_end
operator|!=
name|fp
operator|->
name|_IO_write_base
condition|)
block|{
name|_IO_pos_t
name|new_pos
init|=
name|fp
operator|->
name|_jumps
operator|->
name|__seek
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_write_base
operator|-
name|fp
operator|->
name|_IO_read_end
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_pos
operator|==
name|_IO_pos_BAD
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_offset
operator|=
name|new_pos
expr_stmt|;
block|}
name|count
operator|=
name|fp
operator|->
name|_jumps
operator|->
name|__write
argument_list|(
name|fp
argument_list|,
name|data
argument_list|,
name|to_do
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_cur_column
condition|)
name|fp
operator|->
name|_cur_column
operator|=
name|_IO_adjust_column
argument_list|(
name|fp
operator|->
name|_cur_column
operator|-
literal|1
argument_list|,
name|data
argument_list|,
name|to_do
argument_list|)
operator|+
literal|1
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|+
name|_IO_UNBUFFERED
operator|)
condition|?
name|fp
operator|->
name|_IO_buf_base
else|:
name|fp
operator|->
name|_IO_buf_end
expr_stmt|;
return|return
name|count
operator|!=
name|to_do
condition|?
name|EOF
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_underflow
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_ssize_t
name|count
decl_stmt|;
if|#
directive|if
literal|0
comment|/* SysV does not make this test; take it out for compatibility */
block|if (fp->_flags& _IO_EOF_SEEN)     return (EOF);
endif|#
directive|endif
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_READS
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
name|_IO_doallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Flush all line buffered files before reading. */
comment|/* FIXME This can/should be moved to genops ?? */
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator||
name|_IO_UNBUFFERED
operator|)
condition|)
name|_IO_flush_all_linebuffered
argument_list|()
expr_stmt|;
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|count
operator|=
name|fp
operator|->
name|_jumps
operator|->
name|__read
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|fp
operator|->
name|_flags
operator||=
name|_IO_EOF_SEEN
expr_stmt|;
else|else
name|fp
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
operator|,
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_buf_base
operator|+
name|count
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_offset
operator|!=
name|_IO_pos_BAD
condition|)
name|_IO_pos_adjust
argument_list|(
name|fp
operator|->
name|_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_overflow
parameter_list|(
name|f
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
condition|)
comment|/* SET ERROR */
return|return
name|EOF
return|;
comment|/* If current reading or no buffer allocated. */
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Allocate a buffer if needed. */
if|if
condition|(
name|f
operator|->
name|_IO_buf_base
operator|==
literal|0
condition|)
block|{
name|_IO_doallocbuf
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|_IO_read_end
operator|=
name|f
operator|->
name|_IO_buf_base
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|=
name|f
operator|->
name|_IO_buf_base
expr_stmt|;
block|}
else|else
comment|/* Must be currently reading. */
name|f
operator|->
name|_IO_write_ptr
operator|=
name|f
operator|->
name|_IO_read_ptr
expr_stmt|;
name|f
operator|->
name|_IO_write_base
operator|=
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
name|f
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_IO_buf_end
expr_stmt|;
name|f
operator|->
name|_IO_read_base
operator|=
name|f
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_IO_read_end
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|+
name|_IO_UNBUFFERED
condition|)
name|f
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
name|f
operator|->
name|_flags
operator||=
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
return|;
if|if
condition|(
name|f
operator|->
name|_IO_write_ptr
operator|==
name|f
operator|->
name|_IO_buf_end
condition|)
comment|/* Buffer is really full */
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
operator|*
name|f
operator|->
name|_IO_write_ptr
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
operator|||
operator|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|)
operator|&&
name|ch
operator|==
literal|'\n'
operator|)
condition|)
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|ch
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_sync
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_size_t
name|delta
decl_stmt|;
comment|/*    char* ptr = cur_ptr(); */
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
condition|)
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
name|delta
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|delta
operator|-=
name|eGptr
argument_list|()
operator|-
name|Gbase
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_IO_off_t
name|new_pos
init|=
name|fp
operator|->
name|_jumps
operator|->
name|__seek
argument_list|(
name|fp
argument_list|,
name|delta
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_pos
operator|==
operator|(
name|_IO_off_t
operator|)
name|EOF
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_offset
operator|=
name|new_pos
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
comment|/* FIXME: Cleanup - can this be shared? */
comment|/*    setg(base(), ptr, ptr); */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_file_seekoff
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|_IO_seekflags
name|mode
decl_stmt|;
block|{
name|_IO_pos_t
name|result
decl_stmt|;
name|_IO_off_t
name|delta
decl_stmt|,
name|new_offset
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|dir
init|=
name|mode
operator|&
literal|3
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|_IO_seek_not_in
operator|)
operator|&&
operator|(
name|mode
operator|&
name|_IO_seek_not_out
operator|)
condition|)
name|dir
operator|=
name|_IO_seek_cur
operator|,
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Don't move any pointers. */
comment|/* Flush unwritten characters.      (This may do an unneeded write if we seek within the buffer.      But to be able to switch to reading, we would need to set      egptr to ptr.  That can't be done in the current design,      which assumes file_ptr() is eGptr.  Anyway, since we probably      end up flushing when we close(), it doesn't make much difference.)      FIXME: simulate mem-papped files. */
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
operator|||
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
block|{
name|_IO_doallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|_IO_seek_cur
case|:
if|if
condition|(
name|fp
operator|->
name|_offset
operator|==
name|_IO_pos_BAD
condition|)
goto|goto
name|dumb
goto|;
comment|/* Adjust for read-ahead (bytes is buffer). */
name|offset
operator|-=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
comment|/* Make offset absolute, assuming current pointer is file_ptr(). */
name|offset
operator|+=
name|_IO_pos_as_off
argument_list|(
name|fp
operator|->
name|_offset
argument_list|)
expr_stmt|;
name|dir
operator|=
name|_IO_seek_set
expr_stmt|;
break|break;
case|case
name|_IO_seek_set
case|:
break|break;
case|case
name|_IO_seek_end
case|:
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_jumps
operator|->
name|__stat
argument_list|(
name|fp
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|st
operator|.
name|st_size
expr_stmt|;
name|dir
operator|=
name|_IO_seek_set
expr_stmt|;
block|}
else|else
goto|goto
name|dumb
goto|;
block|}
block|}
comment|/* At this point, dir==_IO_seek_set. */
ifdef|#
directive|ifdef
name|TODO
comment|/* If destination is within current buffer, optimize: */
if|if
condition|(
name|fp
operator|->
name|_offset
operator|!=
name|IO_pos_BAD
operator|&&
name|fp
operator|->
name|_IO_read_base
operator|!=
name|NULL
condition|)
block|{
comment|/* Offset relative to start of main get area. */
name|_IO_pos_t
name|rel_offset
init|=
name|offset
operator|-
name|_fb
operator|.
name|_offset
operator|+
operator|(
name|eGptr
argument_list|()
operator|-
name|Gbase
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|rel_offset
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_offset
operator|<=
name|_IO_read_end
operator|-
name|_IO_read_base
condition|)
block|{
name|_IO_setg
argument_list|(
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|rel_offset
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
comment|/* If we have streammarkers, seek forward by reading ahead. */
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|to_skip
init|=
name|rel_offset
operator|-
operator|(
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
decl_stmt|;
if|if
condition|(
name|ignore
argument_list|(
name|to_skip
argument_list|)
operator|!=
name|to_skip
condition|)
goto|goto
name|dumb
goto|;
return|return
name|offset
return|;
block|}
block|}
if|if
condition|(
name|rel_offset
operator|<
literal|0
operator|&&
name|rel_offset
operator|>=
name|Bbase
argument_list|()
operator|-
name|Bptr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gbump
argument_list|(
name|fp
operator|->
name|_IO_read_end
operator|+
name|rel_offset
operator|-
name|fp
operator|->
name|_IO_read_ptr
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
block|}
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Try to seek to a block boundary, to improve kernel page management. */
name|new_offset
operator|=
name|offset
operator|&
operator|~
operator|(
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
operator|-
literal|1
operator|)
expr_stmt|;
name|delta
operator|=
name|offset
operator|-
name|new_offset
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
condition|)
block|{
name|new_offset
operator|=
name|offset
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|=
name|fp
operator|->
name|_jumps
operator|->
name|__seek
argument_list|(
name|fp
argument_list|,
name|new_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|count
operator|=
name|fp
operator|->
name|_jumps
operator|->
name|__read
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|delta
condition|)
block|{
comment|/* We weren't allowed to read, but try to seek the remainder. */
name|offset
operator|=
name|count
operator|==
name|EOF
condition|?
name|delta
else|:
name|delta
operator|-
name|count
expr_stmt|;
name|dir
operator|=
name|_IO_seek_cur
expr_stmt|;
goto|goto
name|dumb
goto|;
block|}
block|}
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|delta
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|count
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|result
operator|+
name|count
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
name|dumb
label|:
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|result
operator|=
name|fp
operator|->
name|_jumps
operator|->
name|__seek
argument_list|(
name|fp
argument_list|,
name|offset
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|result
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_file_read
parameter_list|(
name|fp
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|_IO_ssize_t
name|size
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IO_ssize_t
name|count
init|=
name|_IO_read
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|count
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
name|count
return|;
block|}
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_file_seek
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
return|return
name|_IO_lseek
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|,
name|offset
argument_list|,
name|dir
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_stat
parameter_list|(
name|fp
parameter_list|,
name|st
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|st
decl_stmt|;
block|{
return|return
name|_IO_fstat
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|st
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_IO_file_close
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|_IO_close
argument_list|(
name|fp
operator|->
name|_fileno
argument_list|)
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_file_write
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_ssize_t
name|n
decl_stmt|;
block|{
name|_IO_ssize_t
name|to_do
init|=
name|n
decl_stmt|;
while|while
condition|(
name|to_do
operator|>
literal|0
condition|)
block|{
name|_IO_ssize_t
name|count
init|=
name|_IO_write
argument_list|(
name|f
operator|->
name|_fileno
argument_list|,
name|data
argument_list|,
name|to_do
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|EOF
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
else|else
endif|#
directive|endif
block|{
name|f
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
break|break;
block|}
block|}
name|to_do
operator|-=
name|count
expr_stmt|;
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|count
operator|)
expr_stmt|;
block|}
name|n
operator|-=
name|to_do
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|_offset
operator|>=
literal|0
condition|)
name|f
operator|->
name|_offset
operator|+=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_file_xsputn
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
init|=
name|data
decl_stmt|;
name|_IO_size_t
name|to_do
init|=
name|n
decl_stmt|;
name|int
name|must_flush
init|=
literal|0
decl_stmt|;
name|_IO_size_t
name|count
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* This is an optimized implementation.      If the amount to be written straddles a block boundary      (or the filebuf is unbuffered), use sys_write directly. */
comment|/* First figure out how much space is available in the buffer. */
name|count
operator|=
name|f
operator|->
name|_IO_write_end
operator|-
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
comment|/* Space available. */
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|)
operator|&&
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|count
operator|=
name|f
operator|->
name|_IO_buf_end
operator|-
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|n
condition|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|+
name|n
init|;
name|p
operator|>
name|s
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'\n'
condition|)
block|{
name|count
operator|=
name|p
operator|-
name|s
operator|+
literal|1
expr_stmt|;
name|must_flush
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Then fill the buffer. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|to_do
condition|)
name|count
operator|=
name|to_do
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
name|memcpy
argument_list|(
name|f
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|f
operator|->
name|_IO_write_ptr
decl_stmt|;
specifier|register
name|int
name|i
init|=
operator|(
name|int
operator|)
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|f
operator|->
name|_IO_write_ptr
operator|+=
name|count
expr_stmt|;
name|to_do
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|to_do
operator|+
name|must_flush
operator|>
literal|0
condition|)
block|{
name|_IO_size_t
name|block_size
decl_stmt|,
name|dont_write
decl_stmt|;
comment|/* Next flush the (full) buffer. */
if|if
condition|(
name|__overflow
argument_list|(
name|f
argument_list|,
name|EOF
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|n
operator|-
name|to_do
return|;
comment|/* Try to maintain alignment: write a whole number of blocks. 	 dont_write is what gets left over. */
name|block_size
operator|=
name|f
operator|->
name|_IO_buf_end
operator|-
name|f
operator|->
name|_IO_buf_base
expr_stmt|;
name|dont_write
operator|=
name|block_size
operator|>=
literal|128
condition|?
name|to_do
operator|%
name|block_size
else|:
literal|0
expr_stmt|;
name|count
operator|=
name|to_do
operator|-
name|dont_write
expr_stmt|;
if|if
condition|(
name|_IO_do_write
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|n
operator|-
name|to_do
return|;
name|to_do
operator|=
name|dont_write
expr_stmt|;
comment|/* Now write out the remainder.  Normally, this will fit in the 	 buffer, but it's somewhat messier for line-buffered files, 	 so we let _IO_default_xsputn handle the general case. */
if|if
condition|(
name|dont_write
condition|)
name|to_do
operator|-=
name|_IO_default_xsputn
argument_list|(
name|f
argument_list|,
name|s
operator|+
name|count
argument_list|,
name|dont_write
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|-
name|to_do
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work in progress */
end_comment

begin_comment
unit|_IO_size_t _IO_file_xsgetn(fp, data, n)      _IO_FILE *fp;      void *data;      _IO_size_t n; {   register _IO_size_t more = n;   register char *s = data;   for (;;)     {       _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;
comment|/* Data available. */
end_comment

begin_if
unit|if (count> 0) 	{ 	  if (count> more) 	    count = more; 	  if (count> 20) 	    { 	      memcpy(s, fp->_IO_read_ptr, count); 	      s += count; 	      fp->_IO_read_ptr += count; 	    } 	  else if (count<= 0) 	    count = 0; 	  else 	    { 	      register char *p = fp->_IO_read_ptr; 	      register int i = (int)count; 	      while (--i>= 0) *s++ = *p++; 	      fp->_IO_read_ptr = p;             }             more -= count;         }
if|#
directive|if
literal|0
end_if

begin_comment
unit|if (! _IO_in put_mode (fp)&& ! _IO_have_markers (fp)&& ! IO_have_backup (fp)) 	{
comment|/* This is an optimization of _IO_file_underflow */
end_comment

begin_comment
unit|if (fp->_flags& _IO_NO_READS) 	    break;
comment|/* If we're reading a lot of data, don't bother allocating 	     a buffer.  But if we're only reading a bit, perhaps we should ??*/
end_comment

begin_endif
unit|if (count<= 512&& fp->_IO_buf_base == NULL) 	    _IO_doallocbuf(fp); 	  if (fp->_flags& (_IO_LINE_BUF|_IO_UNBUFFERED)) 	    _IO_flush_all_linebuffered();  	  _IO_switch_to_get_mode(fp); ???; 	  count = fp->_jumps->__read (fp, s, more); 	  if (count<= 0) 	     { 	       if (count == 0) 		 fp->_flags |= _IO_EOF_SEEN; 	       else 		 fp->_flags |= _IO_ERR_SEEN, count = 0; 	     } 	   	  s += count; 	  more -= count; 	}
endif|#
directive|endif
end_endif

begin_endif
unit|if (more == 0 || __underflow(fp) == EOF) 	break;     }   return n - more; }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|_IO_jump_t
name|_IO_file_jumps
init|=
block|{
name|_IO_file_overflow
block|,
name|_IO_file_underflow
block|,
name|_IO_file_xsputn
block|,
name|_IO_default_xsgetn
block|,
name|_IO_file_read
block|,
name|_IO_file_write
block|,
name|_IO_file_doallocate
block|,
name|_IO_default_pbackfail
block|,
name|_IO_file_setbuf
block|,
name|_IO_file_sync
block|,
name|_IO_file_finish
block|,
name|_IO_file_close
block|,
name|_IO_file_stat
block|,
name|_IO_file_seek
block|,
name|_IO_file_seekoff
block|,
name|_IO_default_seekpos
block|,
name|_IO_default_uflow
block|}
decl_stmt|;
end_decl_stmt

end_unit

