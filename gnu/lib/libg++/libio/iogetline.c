begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Algorithm based on that used by Berkeley pre-4.4 fgets implementation.     Read chars into buf (of size n), until delim is seen.    Return number of chars read (at most n).    Does not put a terminating '\0' in buf.    If extract_delim< 0, leave delimiter unread.    If extract_delim> 0, insert delim in output. */
end_comment

begin_function
name|_IO_size_t
name|_IO_getline
parameter_list|(
name|fp
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|,
name|delim
parameter_list|,
name|extract_delim
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|int
name|extract_delim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
do|do
block|{
name|_IO_ssize_t
name|len
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
if|if
condition|(
name|__underflow
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
break|break;
else|else
name|len
operator|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|n
condition|)
name|len
operator|=
name|n
expr_stmt|;
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|delim
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|_IO_size_t
name|old_len
init|=
name|ptr
operator|-
name|buf
decl_stmt|;
name|len
operator|=
name|t
operator|-
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
if|if
condition|(
name|extract_delim
operator|>=
literal|0
condition|)
block|{
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|extract_delim
operator|>
literal|0
condition|)
name|len
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|t
expr_stmt|;
return|return
name|old_len
operator|+
name|len
return|;
block|}
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|+=
name|len
expr_stmt|;
name|ptr
operator|+=
name|len
expr_stmt|;
name|n
operator|-=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|!=
literal|0
condition|)
do|;
return|return
name|ptr
operator|-
name|buf
return|;
block|}
end_function

end_unit

