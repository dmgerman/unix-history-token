begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1990 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"%W% (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/*  * Actual printf innards.  *  * This code is large and complicated...  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define FLOATING_POINT to get floating point.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FLOATING_POINT
end_ifndef

begin_define
define|#
directive|define
name|FLOATING_POINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of configuration stuff */
end_comment

begin_comment
comment|/*  * Helper "class" for `fprintf to unbuffered': creates a  * temporary buffer. */
end_comment

begin_struct
struct|struct
name|helper_file
block|{
name|struct
name|_IO_FILE_plus
name|_f
decl_stmt|;
name|_IO_FILE
modifier|*
name|_put_stream
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|_IO_helper_overflow
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|_IO_FILE
modifier|*
name|target
init|=
operator|(
operator|(
expr|struct
name|helper_file
operator|*
operator|)
name|fp
operator|)
operator|->
name|_put_stream
decl_stmt|;
name|int
name|used
init|=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
decl_stmt|;
if|if
condition|(
name|used
condition|)
block|{
name|_IO_sputn
argument_list|(
name|target
argument_list|,
name|fp
operator|->
name|_IO_write_base
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|-=
name|used
expr_stmt|;
block|}
return|return
name|_IO_putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|_IO_jump_t
name|_IO_helper_jumps
init|=
block|{
name|_IO_helper_overflow
block|,
name|_IO_default_underflow
block|,
name|_IO_default_xsputn
block|,
name|_IO_default_xsgetn
block|,
name|_IO_default_read
block|,
name|_IO_default_write
block|,
name|_IO_default_doallocate
block|,
name|_IO_default_pbackfail
block|,
name|_IO_default_setbuf
block|,
name|_IO_default_sync
block|,
name|_IO_default_finish
block|,
name|_IO_default_close
block|,
name|_IO_default_stat
block|,
name|_IO_default_seek
block|,
name|_IO_default_seekoff
block|,
name|_IO_default_seekpos
block|,
name|_IO_default_uflow
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|helper_vfprintf
parameter_list|(
name|fp
parameter_list|,
name|fmt0
parameter_list|,
name|ap
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt0
decl_stmt|;
name|_IO_va_list
name|ap
decl_stmt|;
block|{
name|char
name|buf
index|[
name|_IO_BUFSIZ
index|]
decl_stmt|;
name|struct
name|helper_file
name|helper
decl_stmt|;
specifier|register
name|_IO_FILE
modifier|*
name|hp
init|=
operator|(
name|_IO_FILE
operator|*
operator|)
operator|&
name|helper
decl_stmt|;
name|int
name|result
decl_stmt|,
name|to_flush
decl_stmt|;
comment|/* initialize helper */
name|helper
operator|.
name|_put_stream
operator|=
name|fp
expr_stmt|;
name|hp
operator|->
name|_IO_write_base
operator|=
name|buf
expr_stmt|;
name|hp
operator|->
name|_IO_write_ptr
operator|=
name|buf
expr_stmt|;
name|hp
operator|->
name|_IO_write_end
operator|=
name|buf
operator|+
name|_IO_BUFSIZ
expr_stmt|;
name|hp
operator|->
name|_IO_file_flags
operator|=
name|_IO_MAGIC
operator||
name|_IO_NO_READS
expr_stmt|;
name|hp
operator|->
name|_jumps
operator|=
operator|&
name|_IO_helper_jumps
expr_stmt|;
comment|/* Now print to helper instead. */
name|result
operator|=
name|_IO_vfprintf
argument_list|(
name|hp
argument_list|,
name|fmt0
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* Now flush anything from the helper to the fp. */
if|if
condition|(
operator|(
name|to_flush
operator|=
name|hp
operator|->
name|_IO_write_ptr
operator|-
name|hp
operator|->
name|_IO_write_base
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|_IO_sputn
argument_list|(
name|fp
argument_list|,
name|hp
operator|->
name|_IO_write_base
argument_list|,
name|to_flush
argument_list|)
operator|!=
name|to_flush
condition|)
return|return
name|EOF
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATING_POINT
end_ifdef

begin_include
include|#
directive|include
file|"floatio.h"
end_include

begin_define
define|#
directive|define
name|BUF
value|(MAXEXP+MAXFRACT+1)
end_define

begin_comment
comment|/* + decimal point */
end_comment

begin_define
define|#
directive|define
name|DEFPREC
value|6
end_define

begin_decl_stmt
specifier|extern
name|double
name|modf
name|__P
argument_list|(
operator|(
name|double
operator|,
name|double
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no FLOATING_POINT */
end_comment

begin_define
define|#
directive|define
name|BUF
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLOATING_POINT */
end_comment

begin_comment
comment|/*  * Macros for converting digits to letters and vice versa  */
end_comment

begin_define
define|#
directive|define
name|to_digit
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_define
define|#
directive|define
name|is_digit
parameter_list|(
name|c
parameter_list|)
value|((unsigned)to_digit(c)<= 9)
end_define

begin_define
define|#
directive|define
name|to_char
parameter_list|(
name|n
parameter_list|)
value|((n) + '0')
end_define

begin_comment
comment|/*  * Flags used during conversion.  */
end_comment

begin_define
define|#
directive|define
name|LONGINT
value|0x01
end_define

begin_comment
comment|/* long integer */
end_comment

begin_define
define|#
directive|define
name|LONGDBL
value|0x02
end_define

begin_comment
comment|/* long double; unimplemented */
end_comment

begin_define
define|#
directive|define
name|SHORTINT
value|0x04
end_define

begin_comment
comment|/* short integer */
end_comment

begin_define
define|#
directive|define
name|ALT
value|0x08
end_define

begin_comment
comment|/* alternate form */
end_comment

begin_define
define|#
directive|define
name|LADJUST
value|0x10
end_define

begin_comment
comment|/* left adjustment */
end_comment

begin_define
define|#
directive|define
name|ZEROPAD
value|0x20
end_define

begin_comment
comment|/* zero (as opposed to blank) pad */
end_comment

begin_define
define|#
directive|define
name|HEXPREFIX
value|0x40
end_define

begin_comment
comment|/* add 0x or 0X prefix */
end_comment

begin_function
name|int
name|_IO_vfprintf
parameter_list|(
name|fp
parameter_list|,
name|fmt0
parameter_list|,
name|ap
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt0
decl_stmt|;
name|_IO_va_list
name|ap
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format string */
specifier|register
name|int
name|ch
decl_stmt|;
comment|/* character from fmt */
specifier|register
name|int
name|n
decl_stmt|;
comment|/* handy integer (short term usage) */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* handy char pointer (short term usage) */
specifier|const
name|char
modifier|*
name|fmark
decl_stmt|;
comment|/* for remembering a place in fmt */
specifier|register
name|int
name|flags
decl_stmt|;
comment|/* flags as above */
name|int
name|ret
decl_stmt|;
comment|/* return value accumulator */
name|int
name|width
decl_stmt|;
comment|/* width from format (%8d), or 0 */
name|int
name|prec
decl_stmt|;
comment|/* precision from format (%.3d), or -1 */
name|char
name|sign
decl_stmt|;
comment|/* sign prefix (' ', '+', '-', or \0) */
ifdef|#
directive|ifdef
name|FLOATING_POINT
name|int
name|softsign
decl_stmt|;
comment|/* temporary negative sign for floats */
name|double
name|_double
decl_stmt|;
comment|/* double precision arguments %[eEfgG] */
ifndef|#
directive|ifndef
name|_IO_USE_DTOA
name|int
name|fpprec
decl_stmt|;
comment|/* `extra' floating precision in [eEfgG] */
endif|#
directive|endif
endif|#
directive|endif
name|unsigned
name|long
name|_ulong
decl_stmt|;
comment|/* integer arguments %[diouxX] */
enum|enum
block|{
name|OCT
block|,
name|DEC
block|,
name|HEX
block|}
name|base
enum|;
comment|/* base for [diouxX] conversion */
name|int
name|dprec
decl_stmt|;
comment|/* a copy of prec if [diouxX], 0 otherwise */
name|int
name|dpad
decl_stmt|;
comment|/* extra 0 padding needed for integers */
name|int
name|fieldsz
decl_stmt|;
comment|/* field size expanded by sign, dpad etc */
comment|/* The initialization of 'size' is to suppress a warning that 	   'size' might be used unitialized.  It seems gcc can't 	   quite grok this spaghetti code ... */
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* size of converted field or string */
name|char
name|buf
index|[
name|BUF
index|]
decl_stmt|;
comment|/* space for %c, %[diouxX], %[eEfgG] */
name|char
name|ox
index|[
literal|2
index|]
decl_stmt|;
comment|/* space for 0x hex-prefix */
comment|/* 	 * BEWARE, these `goto error' on error, and PAD uses `n'. 	 */
define|#
directive|define
name|PRINT
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|)
define|\
value|do { if (_IO_sputn(fp,ptr, len) != len) goto error; } while (0)
define|#
directive|define
name|PAD_SP
parameter_list|(
name|howmany
parameter_list|)
value|if (_IO_padn(fp, ' ', howmany)< (howmany)) goto error;
define|#
directive|define
name|PAD_0
parameter_list|(
name|howmany
parameter_list|)
value|if (_IO_padn(fp, '0', howmany)< (howmany)) goto error;
comment|/* 	 * To extend shorts properly, we need both signed and unsigned 	 * argument extraction methods. 	 */
define|#
directive|define
name|SARG
parameter_list|()
define|\
value|(flags&LONGINT ? va_arg(ap, long) : \ 	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \ 	    (long)va_arg(ap, int))
define|#
directive|define
name|UARG
parameter_list|()
define|\
value|(flags&LONGINT ? va_arg(ap, unsigned long) : \ 	    flags&SHORTINT ? (unsigned long)(unsigned short)va_arg(ap, int) : \ 	    (unsigned long)va_arg(ap, unsigned int))
comment|/* optimise stderr (and other unbuffered Unix files) */
if|if
condition|(
name|fp
operator|->
name|_IO_file_flags
operator|&
name|_IO_UNBUFFERED
condition|)
return|return
name|helper_vfprintf
argument_list|(
name|fp
argument_list|,
name|fmt0
argument_list|,
name|ap
argument_list|)
return|;
name|fmt
operator|=
name|fmt0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Scan the format for conversions (`%' character). 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|fmark
operator|=
name|fmt
init|;
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'%'
condition|;
name|fmt
operator|++
control|)
comment|/* void */
empty_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|fmt
operator|-
name|fmark
operator|)
operator|!=
literal|0
condition|)
block|{
name|PRINT
argument_list|(
name|fmark
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
goto|goto
name|done
goto|;
name|fmt
operator|++
expr_stmt|;
comment|/* skip over '%' */
name|flags
operator|=
literal|0
expr_stmt|;
name|dprec
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FLOATING_POINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_IO_USE_DTOA
argument_list|)
name|fpprec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|width
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
name|sign
operator|=
literal|'\0'
expr_stmt|;
name|rflag
label|:
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|' '
case|:
comment|/* 			 * ``If the space and + flags both appear, the space 			 * flag will be ignored.'' 			 *	-- ANSI X3J11 			 */
if|if
condition|(
operator|!
name|sign
condition|)
name|sign
operator|=
literal|' '
expr_stmt|;
goto|goto
name|rflag
goto|;
case|case
literal|'#'
case|:
name|flags
operator||=
name|ALT
expr_stmt|;
goto|goto
name|rflag
goto|;
case|case
literal|'*'
case|:
comment|/* 			 * ``A negative field width argument is taken as a 			 * - flag followed by a positive field width.'' 			 *	-- ANSI X3J11 			 * They don't exclude field widths read from args. 			 */
if|if
condition|(
operator|(
name|width
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|rflag
goto|;
name|width
operator|=
operator|-
name|width
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'-'
case|:
name|flags
operator||=
name|LADJUST
expr_stmt|;
name|flags
operator|&=
operator|~
name|ZEROPAD
expr_stmt|;
comment|/* '-' disables '0' */
goto|goto
name|rflag
goto|;
case|case
literal|'+'
case|:
name|sign
operator|=
literal|'+'
expr_stmt|;
goto|goto
name|rflag
goto|;
case|case
literal|'.'
case|:
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|==
literal|'*'
condition|)
block|{
name|n
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|prec
operator|=
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|n
expr_stmt|;
goto|goto
name|rflag
goto|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|is_digit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|to_digit
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
name|prec
operator|=
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|n
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'0'
case|:
comment|/* 			 * ``Note that 0 is taken as a flag, not as the 			 * beginning of a field width.'' 			 *	-- ANSI X3J11 			 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LADJUST
operator|)
condition|)
name|flags
operator||=
name|ZEROPAD
expr_stmt|;
comment|/* '-' disables '0' */
goto|goto
name|rflag
goto|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|to_digit
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|is_digit
argument_list|(
name|ch
argument_list|)
condition|)
do|;
name|width
operator|=
name|n
expr_stmt|;
goto|goto
name|reswitch
goto|;
ifdef|#
directive|ifdef
name|FLOATING_POINT
case|case
literal|'L'
case|:
name|flags
operator||=
name|LONGDBL
expr_stmt|;
goto|goto
name|rflag
goto|;
endif|#
directive|endif
case|case
literal|'h'
case|:
name|flags
operator||=
name|SHORTINT
expr_stmt|;
goto|goto
name|rflag
goto|;
case|case
literal|'l'
case|:
name|flags
operator||=
name|LONGINT
expr_stmt|;
goto|goto
name|rflag
goto|;
case|case
literal|'c'
case|:
operator|*
operator|(
name|cp
operator|=
name|buf
operator|)
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|sign
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|flags
operator||=
name|LONGINT
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
name|_ulong
operator|=
name|SARG
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|_ulong
operator|<
literal|0
condition|)
block|{
name|_ulong
operator|=
operator|-
name|_ulong
expr_stmt|;
name|sign
operator|=
literal|'-'
expr_stmt|;
block|}
name|base
operator|=
name|DEC
expr_stmt|;
goto|goto
name|number
goto|;
ifdef|#
directive|ifdef
name|FLOATING_POINT
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|_double
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_IO_USE_DTOA
block|{
name|int
name|fmt_flags
init|=
literal|0
decl_stmt|;
name|int
name|fill
init|=
literal|' '
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ALT
condition|)
name|fmt_flags
operator||=
name|_IO_SHOWPOINT
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LADJUST
condition|)
name|fmt_flags
operator||=
name|_IO_LEFT
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ZEROPAD
condition|)
name|fmt_flags
operator||=
name|_IO_INTERNAL
operator|,
name|fill
operator|=
literal|'0'
expr_stmt|;
name|n
operator|=
name|_IO_outfloat
argument_list|(
name|_double
argument_list|,
name|fp
argument_list|,
name|ch
argument_list|,
name|width
argument_list|,
name|prec
operator|<
literal|0
condition|?
name|DEFPREC
else|:
name|prec
argument_list|,
name|fmt_flags
argument_list|,
name|sign
argument_list|,
name|fill
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
name|ret
operator|+=
name|n
expr_stmt|;
block|}
comment|/* CHECK ERROR! */
continue|continue;
else|#
directive|else
comment|/* 			 * don't do unrealistic precision; just pad it with 			 * zeroes later, so buffer size stays rational. 			 */
if|if
condition|(
name|prec
operator|>
name|MAXFRACT
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|!=
literal|'g'
operator|&&
name|ch
operator|!=
literal|'G'
operator|)
operator|||
operator|(
name|flags
operator|&
name|ALT
operator|)
condition|)
name|fpprec
operator|=
name|prec
operator|-
name|MAXFRACT
expr_stmt|;
name|prec
operator|=
name|MAXFRACT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
operator|-
literal|1
condition|)
name|prec
operator|=
name|DEFPREC
expr_stmt|;
comment|/* __cvt_double may have to round up before the 			   "start" of its buffer, i.e. 			   ``intf("%.2f", (double)9.999);''; 			   if the first character is still NUL, it did. 			   softsign avoids negative 0 if _double< 0 but 			   no significant digits will be shown. */
name|cp
operator|=
name|buf
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
name|__cvt_double
argument_list|(
name|_double
argument_list|,
name|prec
argument_list|,
name|flags
argument_list|,
operator|&
name|softsign
argument_list|,
name|ch
argument_list|,
name|cp
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softsign
condition|)
name|sign
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
comment|/* FLOATING_POINT */
case|case
literal|'n'
case|:
if|if
condition|(
name|flags
operator|&
name|LONGINT
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
operator|*
argument_list|)
operator|=
name|ret
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SHORTINT
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|ret
expr_stmt|;
else|else
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|ret
expr_stmt|;
continue|continue;
comment|/* no output */
case|case
literal|'O'
case|:
name|flags
operator||=
name|LONGINT
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'o'
case|:
name|_ulong
operator|=
name|UARG
argument_list|()
expr_stmt|;
name|base
operator|=
name|OCT
expr_stmt|;
goto|goto
name|nosign
goto|;
case|case
literal|'p'
case|:
comment|/* 			 * ``The argument shall be a pointer to void.  The 			 * value of the pointer is converted to a sequence 			 * of printable characters, in an implementation- 			 * defined manner.'' 			 *	-- ANSI X3J11 			 */
comment|/* NOSTRICT */
name|_ulong
operator|=
operator|(
name|unsigned
name|long
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|base
operator|=
name|HEX
expr_stmt|;
name|flags
operator||=
name|HEXPREFIX
expr_stmt|;
name|ch
operator|=
literal|'x'
expr_stmt|;
goto|goto
name|nosign
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|cp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cp
operator|=
literal|"(null)"
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
literal|0
condition|)
block|{
comment|/* 				 * can't use strlen; can only look for the 				 * NUL in the first `prec' characters, and 				 * strlen() will go further. 				 */
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|prec
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
name|p
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|prec
condition|)
name|size
operator|=
name|prec
expr_stmt|;
block|}
else|else
name|size
operator|=
name|prec
expr_stmt|;
block|}
else|else
name|size
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|flags
operator||=
name|LONGINT
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'u'
case|:
name|_ulong
operator|=
name|UARG
argument_list|()
expr_stmt|;
name|base
operator|=
name|DEC
expr_stmt|;
goto|goto
name|nosign
goto|;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
name|_ulong
operator|=
name|UARG
argument_list|()
expr_stmt|;
name|base
operator|=
name|HEX
expr_stmt|;
comment|/* leading 0x/X only if non-zero */
if|if
condition|(
name|flags
operator|&
name|ALT
operator|&&
name|_ulong
operator|!=
literal|0
condition|)
name|flags
operator||=
name|HEXPREFIX
expr_stmt|;
comment|/* unsigned conversions */
name|nosign
label|:
name|sign
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * ``... diouXx conversions ... if a precision is 			 * specified, the 0 flag will be ignored.'' 			 *	-- ANSI X3J11 			 */
name|number
label|:
if|if
condition|(
operator|(
name|dprec
operator|=
name|prec
operator|)
operator|>=
literal|0
condition|)
name|flags
operator|&=
operator|~
name|ZEROPAD
expr_stmt|;
comment|/* 			 * ``The result of converting a zero value with an 			 * explicit precision of zero is no characters.'' 			 *	-- ANSI X3J11 			 */
name|cp
operator|=
name|buf
operator|+
name|BUF
expr_stmt|;
if|if
condition|(
name|_ulong
operator|!=
literal|0
operator|||
name|prec
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|xdigs
decl_stmt|;
comment|/* digits for [xX] conversion */
comment|/* 				 * unsigned mod is hard, and unsigned mod 				 * by a constant is easier than that by 				 * a variable; hence this switch. 				 */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
name|OCT
case|:
do|do
block|{
operator|*
operator|--
name|cp
operator|=
name|to_char
argument_list|(
name|_ulong
operator|&
literal|7
argument_list|)
expr_stmt|;
name|_ulong
operator|>>=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|_ulong
condition|)
do|;
comment|/* handle octal leading 0 */
if|if
condition|(
name|flags
operator|&
name|ALT
operator|&&
operator|*
name|cp
operator|!=
literal|'0'
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
name|DEC
case|:
comment|/* many numbers are 1 digit */
while|while
condition|(
name|_ulong
operator|>=
literal|10
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
name|to_char
argument_list|(
name|_ulong
operator|%
literal|10
argument_list|)
expr_stmt|;
name|_ulong
operator|/=
literal|10
expr_stmt|;
block|}
operator|*
operator|--
name|cp
operator|=
name|to_char
argument_list|(
name|_ulong
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEX
case|:
if|if
condition|(
name|ch
operator|==
literal|'X'
condition|)
name|xdigs
operator|=
literal|"0123456789ABCDEF"
expr_stmt|;
else|else
comment|/* ch == 'x' || ch == 'p' */
name|xdigs
operator|=
literal|"0123456789abcdef"
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|cp
operator|=
name|xdigs
index|[
name|_ulong
operator|&
literal|15
index|]
expr_stmt|;
name|_ulong
operator|>>=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|_ulong
condition|)
do|;
break|break;
default|default:
name|cp
operator|=
literal|"bug in vform: bad base"
expr_stmt|;
goto|goto
name|skipsize
goto|;
block|}
block|}
name|size
operator|=
name|buf
operator|+
name|BUF
operator|-
name|cp
expr_stmt|;
name|skipsize
label|:
break|break;
default|default:
comment|/* "%?" prints ?, unless ? is NUL */
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
goto|goto
name|done
goto|;
comment|/* pretend it was %c with argument ch */
name|cp
operator|=
name|buf
expr_stmt|;
operator|*
name|cp
operator|=
name|ch
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|sign
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
comment|/* 		 * All reasonable formats wind up here.  At this point, 		 * `cp' points to a string which (if not flags&LADJUST) 		 * should be padded out to `width' places.  If 		 * flags&ZEROPAD, it should first be prefixed by any 		 * sign or other prefix; otherwise, it should be blank 		 * padded before the prefix is emitted.  After any 		 * left-hand padding and prefixing, emit zeroes 		 * required by a decimal [diouxX] precision, then print 		 * the string proper, then emit zeroes required by any 		 * leftover floating precision; finally, if LADJUST, 		 * pad with blanks. 		 */
comment|/* 		 * compute actual size, so we know how much to pad. 		 */
if|#
directive|if
name|defined
argument_list|(
name|FLOATING_POINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_IO_USE_DTOA
argument_list|)
name|fieldsz
operator|=
name|size
operator|+
name|fpprec
expr_stmt|;
else|#
directive|else
name|fieldsz
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
name|dpad
operator|=
name|dprec
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|dpad
operator|<
literal|0
condition|)
name|dpad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|fieldsz
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|HEXPREFIX
condition|)
name|fieldsz
operator|+=
literal|2
expr_stmt|;
name|fieldsz
operator|+=
name|dpad
expr_stmt|;
comment|/* right-adjusting blank padding */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LADJUST
operator||
name|ZEROPAD
operator|)
operator|)
operator|==
literal|0
condition|)
name|PAD_SP
argument_list|(
name|width
operator|-
name|fieldsz
argument_list|)
expr_stmt|;
comment|/* prefix */
if|if
condition|(
name|sign
condition|)
block|{
name|PRINT
argument_list|(
operator|&
name|sign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HEXPREFIX
condition|)
block|{
name|ox
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|ox
index|[
literal|1
index|]
operator|=
name|ch
expr_stmt|;
name|PRINT
argument_list|(
name|ox
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* right-adjusting zero padding */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LADJUST
operator||
name|ZEROPAD
operator|)
operator|)
operator|==
name|ZEROPAD
condition|)
name|PAD_0
argument_list|(
name|width
operator|-
name|fieldsz
argument_list|)
expr_stmt|;
comment|/* leading zeroes from decimal precision */
name|PAD_0
argument_list|(
name|dpad
argument_list|)
expr_stmt|;
comment|/* the string or number proper */
name|PRINT
argument_list|(
name|cp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FLOATING_POINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_IO_USE_DTOA
argument_list|)
comment|/* trailing f.p. zeroes */
name|PAD_0
argument_list|(
name|fpprec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* left-adjusting padding (always blank) */
if|if
condition|(
name|flags
operator|&
name|LADJUST
condition|)
name|PAD_SP
argument_list|(
name|width
operator|-
name|fieldsz
argument_list|)
expr_stmt|;
comment|/* finally, adjust ret */
name|ret
operator|+=
name|width
operator|>
name|fieldsz
condition|?
name|width
else|:
name|fieldsz
expr_stmt|;
block|}
name|done
label|:
return|return
name|ret
return|;
name|error
label|:
return|return
name|EOF
return|;
comment|/* NOTREACHED */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FLOATING_POINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_IO_USE_DTOA
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|exponent
parameter_list|(
specifier|register
name|char
modifier|*
name|p
parameter_list|,
specifier|register
name|int
name|exp
parameter_list|,
name|int
name|fmtch
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|char
name|expbuf
index|[
name|MAXEXP
index|]
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|fmtch
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
block|{
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
name|t
operator|=
name|expbuf
operator|+
name|MAXEXP
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|9
condition|)
block|{
do|do
block|{
operator|*
operator|--
name|t
operator|=
name|to_char
argument_list|(
name|exp
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|exp
operator|/=
literal|10
operator|)
operator|>
literal|9
condition|)
do|;
operator|*
operator|--
name|t
operator|=
name|to_char
argument_list|(
name|exp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
operator|<
name|expbuf
operator|+
name|MAXEXP
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|to_char
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|round
parameter_list|(
name|double
name|fract
parameter_list|,
name|int
modifier|*
name|exp
parameter_list|,
specifier|register
name|char
modifier|*
name|start
parameter_list|,
specifier|register
name|char
modifier|*
name|end
parameter_list|,
name|char
name|ch
parameter_list|,
name|int
modifier|*
name|signp
parameter_list|)
block|{
name|double
name|tmp
decl_stmt|;
if|if
condition|(
name|fract
condition|)
operator|(
name|void
operator|)
name|modf
argument_list|(
name|fract
operator|*
literal|10
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|to_digit
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|4
condition|)
for|for
control|(
init|;
condition|;
operator|--
name|end
control|)
block|{
if|if
condition|(
operator|*
name|end
operator|==
literal|'.'
condition|)
operator|--
name|end
expr_stmt|;
if|if
condition|(
operator|++
operator|*
name|end
operator|<=
literal|'9'
condition|)
break|break;
operator|*
name|end
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|start
condition|)
block|{
if|if
condition|(
name|exp
condition|)
block|{
comment|/* e/E; increment exponent */
operator|*
name|end
operator|=
literal|'1'
expr_stmt|;
operator|++
operator|*
name|exp
expr_stmt|;
block|}
else|else
block|{
comment|/* f; add extra digit */
operator|*
operator|--
name|end
operator|=
literal|'1'
expr_stmt|;
operator|--
name|start
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* ``"%.3f", (double)-0.0004'' gives you a negative 0. */
elseif|else
if|if
condition|(
operator|*
name|signp
operator|==
literal|'-'
condition|)
for|for
control|(
init|;
condition|;
operator|--
name|end
control|)
block|{
if|if
condition|(
operator|*
name|end
operator|==
literal|'.'
condition|)
operator|--
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'0'
condition|)
break|break;
if|if
condition|(
name|end
operator|==
name|start
condition|)
operator|*
name|signp
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__cvt_double
parameter_list|(
name|double
name|number
parameter_list|,
specifier|register
name|int
name|prec
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|signp
parameter_list|,
name|int
name|fmtch
parameter_list|,
name|char
modifier|*
name|startp
parameter_list|,
name|char
modifier|*
name|endp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|double
name|fract
decl_stmt|;
name|int
name|dotrim
init|=
literal|0
decl_stmt|,
name|expcnt
decl_stmt|,
name|gformat
init|=
literal|0
decl_stmt|;
name|double
name|integer
decl_stmt|,
name|tmp
decl_stmt|;
name|expcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
name|number
operator|=
operator|-
name|number
expr_stmt|;
operator|*
name|signp
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
operator|*
name|signp
operator|=
literal|0
expr_stmt|;
name|fract
operator|=
name|modf
argument_list|(
name|number
argument_list|,
operator|&
name|integer
argument_list|)
expr_stmt|;
comment|/* get an extra slot for rounding. */
name|t
operator|=
operator|++
name|startp
expr_stmt|;
comment|/* 	 * get integer portion of number; put into the end of the buffer; the 	 * .01 is added for modf(356.0 / 10,&integer) returning .59999999... 	 */
for|for
control|(
name|p
operator|=
name|endp
operator|-
literal|1
init|;
name|integer
condition|;
operator|++
name|expcnt
control|)
block|{
name|tmp
operator|=
name|modf
argument_list|(
name|integer
operator|/
literal|10
argument_list|,
operator|&
name|integer
argument_list|)
expr_stmt|;
operator|*
name|p
operator|--
operator|=
name|to_char
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|tmp
operator|+
literal|.01
operator|)
operator|*
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fmtch
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
comment|/* reverse integer into beginning of buffer */
if|if
condition|(
name|expcnt
condition|)
for|for
control|(
init|;
operator|++
name|p
operator|<
name|endp
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
control|)
empty_stmt|;
else|else
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
comment|/* 		 * if precision required or alternate flag set, add in a 		 * decimal point. 		 */
if|if
condition|(
name|prec
operator|||
name|flags
operator|&
name|ALT
condition|)
operator|*
name|t
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* if requires more precision and some fraction left */
if|if
condition|(
name|fract
condition|)
block|{
if|if
condition|(
name|prec
condition|)
do|do
block|{
name|fract
operator|=
name|modf
argument_list|(
name|fract
operator|*
literal|10
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|to_char
argument_list|(
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|prec
operator|&&
name|fract
condition|)
do|;
if|if
condition|(
name|fract
condition|)
name|startp
operator|=
name|round
argument_list|(
name|fract
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|startp
argument_list|,
name|t
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
name|signp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|prec
operator|--
condition|;
operator|*
name|t
operator|++
operator|=
literal|'0'
control|)
empty_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|eformat
label|:
if|if
condition|(
name|expcnt
condition|)
block|{
operator|*
name|t
operator|++
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|prec
operator|||
name|flags
operator|&
name|ALT
condition|)
operator|*
name|t
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* if requires more precision and some integer left */
for|for
control|(
init|;
name|prec
operator|&&
operator|++
name|p
operator|<
name|endp
condition|;
operator|--
name|prec
control|)
operator|*
name|t
operator|++
operator|=
operator|*
name|p
expr_stmt|;
comment|/* 			 * if done precision and more of the integer component, 			 * round using it; adjust fract so we don't re-round 			 * later. 			 */
if|if
condition|(
operator|!
name|prec
operator|&&
operator|++
name|p
operator|<
name|endp
condition|)
block|{
name|fract
operator|=
literal|0
expr_stmt|;
name|startp
operator|=
name|round
argument_list|(
operator|(
name|double
operator|)
literal|0
argument_list|,
operator|&
name|expcnt
argument_list|,
name|startp
argument_list|,
name|t
operator|-
literal|1
argument_list|,
operator|*
name|p
argument_list|,
name|signp
argument_list|)
expr_stmt|;
block|}
comment|/* adjust expcnt for digit in front of decimal */
operator|--
name|expcnt
expr_stmt|;
block|}
comment|/* until first fractional digit, decrement exponent */
elseif|else
if|if
condition|(
name|fract
condition|)
block|{
comment|/* adjust expcnt for digit in front of decimal */
for|for
control|(
name|expcnt
operator|=
operator|-
literal|1
init|;
condition|;
operator|--
name|expcnt
control|)
block|{
name|fract
operator|=
name|modf
argument_list|(
name|fract
operator|*
literal|10
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
break|break;
block|}
operator|*
name|t
operator|++
operator|=
name|to_char
argument_list|(
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|||
name|flags
operator|&
name|ALT
condition|)
operator|*
name|t
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|prec
operator|||
name|flags
operator|&
name|ALT
condition|)
operator|*
name|t
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* if requires more precision and some fraction left */
if|if
condition|(
name|fract
condition|)
block|{
if|if
condition|(
name|prec
condition|)
do|do
block|{
name|fract
operator|=
name|modf
argument_list|(
name|fract
operator|*
literal|10
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|to_char
argument_list|(
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|prec
operator|&&
name|fract
condition|)
do|;
if|if
condition|(
name|fract
condition|)
name|startp
operator|=
name|round
argument_list|(
name|fract
argument_list|,
operator|&
name|expcnt
argument_list|,
name|startp
argument_list|,
name|t
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
name|signp
argument_list|)
expr_stmt|;
block|}
comment|/* if requires more precision */
for|for
control|(
init|;
name|prec
operator|--
condition|;
operator|*
name|t
operator|++
operator|=
literal|'0'
control|)
empty_stmt|;
comment|/* unless alternate flag, trim any g/G format trailing 0's */
if|if
condition|(
name|gformat
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ALT
operator|)
condition|)
block|{
while|while
condition|(
name|t
operator|>
name|startp
operator|&&
operator|*
operator|--
name|t
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'.'
condition|)
operator|--
name|t
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
name|t
operator|=
name|exponent
argument_list|(
name|t
argument_list|,
name|expcnt
argument_list|,
name|fmtch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
comment|/* a precision of 0 is treated as a precision of 1. */
if|if
condition|(
operator|!
name|prec
condition|)
operator|++
name|prec
expr_stmt|;
comment|/* 		 * ``The style used depends on the value converted; style e 		 * will be used only if the exponent resulting from the 		 * conversion is less than -4 or greater than the precision.'' 		 *	-- ANSI X3J11 		 */
if|if
condition|(
name|expcnt
operator|>
name|prec
operator|||
operator|(
operator|!
name|expcnt
operator|&&
name|fract
operator|&&
name|fract
operator|<
literal|.0001
operator|)
condition|)
block|{
comment|/* 			 * g/G format counts "significant digits, not digits of 			 * precision; for the e/E format, this just causes an 			 * off-by-one problem, i.e. g/G considers the digit 			 * before the decimal point significant and e/E doesn't 			 * count it as precision. 			 */
operator|--
name|prec
expr_stmt|;
name|fmtch
operator|-=
literal|2
expr_stmt|;
comment|/* G->E, g->e */
name|gformat
operator|=
literal|1
expr_stmt|;
goto|goto
name|eformat
goto|;
block|}
comment|/* 		 * reverse integer into beginning of buffer, 		 * note, decrement precision 		 */
if|if
condition|(
name|expcnt
condition|)
for|for
control|(
init|;
operator|++
name|p
operator|<
name|endp
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|,
operator|--
name|prec
control|)
empty_stmt|;
else|else
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
comment|/* 		 * if precision required or alternate flag set, add in a 		 * decimal point.  If no digits yet, add in leading 0. 		 */
if|if
condition|(
name|prec
operator|||
name|flags
operator|&
name|ALT
condition|)
block|{
name|dotrim
operator|=
literal|1
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
name|dotrim
operator|=
literal|0
expr_stmt|;
comment|/* if requires more precision and some fraction left */
if|if
condition|(
name|fract
condition|)
block|{
if|if
condition|(
name|prec
condition|)
block|{
comment|/* If no integer part, don't count initial 				 * zeros as significant digits. */
do|do
block|{
name|fract
operator|=
name|modf
argument_list|(
name|fract
operator|*
literal|10
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|to_char
argument_list|(
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|tmp
operator|&&
operator|!
name|expcnt
condition|)
do|;
while|while
condition|(
operator|--
name|prec
operator|&&
name|fract
condition|)
block|{
name|fract
operator|=
name|modf
argument_list|(
name|fract
operator|*
literal|10
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|to_char
argument_list|(
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fract
condition|)
name|startp
operator|=
name|round
argument_list|(
name|fract
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|startp
argument_list|,
name|t
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
name|signp
argument_list|)
expr_stmt|;
block|}
comment|/* alternate format, adds 0's for precision, else trim 0's */
if|if
condition|(
name|flags
operator|&
name|ALT
condition|)
for|for
control|(
init|;
name|prec
operator|--
condition|;
operator|*
name|t
operator|++
operator|=
literal|'0'
control|)
empty_stmt|;
elseif|else
if|if
condition|(
name|dotrim
condition|)
block|{
while|while
condition|(
name|t
operator|>
name|startp
operator|&&
operator|*
operator|--
name|t
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'.'
condition|)
operator|++
name|t
expr_stmt|;
block|}
block|}
return|return
operator|(
name|t
operator|-
name|startp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(FLOATING_POINT)&& !defined(_IO_USE_DTOA) */
end_comment

end_unit

