begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_include
include|#
directive|include
file|"strfile.h"
end_include

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|LEN
parameter_list|(
name|fp
parameter_list|)
value|(((_IO_strfile*)(fp))->_s._len)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_comment
comment|/* An "unbounded buffer" is when a buffer is supplied, but with no    specified length.  An example is the buffer argument to sprintf.    */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_IO_str_init_static
parameter_list|(
name|fp
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|,
name|pstart
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|pstart
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* If size is negative 'the characters are assumed to 	 continue indefinitely.'  This is kind of messy ... */
if|#
directive|if
literal|1
name|int
name|s
decl_stmt|;
name|size
operator|=
literal|512
expr_stmt|;
comment|/* Try increasing powers of 2, as long as we don't wrap around. 	 This can lose in pathological cases (ptr near the end 	 of the address space).  A better solution might be to 	 adjust the size on underflow/overflow.  FIXME. */
for|for
control|(
name|s
init|;
name|s
operator|=
literal|2
operator|*
name|size
operator|,
name|s
operator|>
literal|0
operator|&&
name|ptr
operator|+
name|s
operator|>
name|ptr
operator|&&
name|s
operator|<
literal|0x4000000L
condition|;
control|)
name|size
operator|=
name|s
expr_stmt|;
name|size
operator|=
name|s
expr_stmt|;
else|#
directive|else
comment|/* The following semi-portable kludge assumes that 	 sizeof(unsigned long) == sizeof(char*). Hence, 	 (unsigned long)(-1) should be the largest possible address. */
name|unsigned
name|long
name|highest
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/* Pointers are signed on some brain-damaged systems, in 	 which case we divide by two to get the maximum signed address. */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|highest
operator|<
name|ptr
condition|)
name|highest
operator|>>=
literal|1
expr_stmt|;
name|size
operator|=
operator|(
name|char
operator|*
operator|)
name|highest
operator|-
name|ptr
expr_stmt|;
endif|#
directive|endif
block|}
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|ptr
argument_list|,
name|ptr
operator|+
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|pstart
condition|)
block|{
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|pstart
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|pstart
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
block|}
name|LEN
argument_list|(
name|fp
argument_list|)
operator|=
name|size
expr_stmt|;
comment|/* A null _allocate_buffer function flags the strfile as being static. */
operator|(
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
operator|(
name|fp
operator|)
operator|)
operator|->
name|_s
operator|.
name|_allocate_buffer
operator|)
operator|=
operator|(
name|_IO_alloc_type
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_str_init_readonly
parameter_list|(
name|fp
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|_IO_str_init_static
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_file_flags
operator||=
name|_IO_NO_WRITES
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_IO_str_overflow
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|flush_only
init|=
name|c
operator|==
name|EOF
decl_stmt|;
name|_IO_size_t
name|pos
init|=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
decl_stmt|;
name|_IO_size_t
name|get_pos
init|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
condition|)
return|return
name|flush_only
condition|?
literal|0
else|:
name|EOF
return|;
if|if
condition|(
name|pos
operator|>
name|LEN
argument_list|(
name|fp
argument_list|)
condition|)
name|LEN
argument_list|(
name|fp
argument_list|)
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_TIED_PUT_GET
operator|)
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|pos
operator|=
name|get_pos
expr_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
name|get_pos
operator|=
name|LEN
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>=
name|_IO_blen
argument_list|(
name|fp
argument_list|)
operator|+
name|flush_only
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
condition|)
comment|/* not allowed to enlarge */
block|{
ifdef|#
directive|ifdef
name|TODO
if|if
condition|(
name|indefinite
name|size
condition|)
block|{
name|fp
operator|->
name|_IO_buf_end
operator|+=
literal|512
expr_stmt|;
block|}
else|else
endif|#
directive|endif
return|return
name|EOF
return|;
block|}
else|else
block|{
name|char
modifier|*
name|new_buf
decl_stmt|;
name|_IO_size_t
name|new_size
init|=
literal|2
operator|*
name|_IO_blen
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|new_buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_allocate_buffer
operator|)
operator|(
name|new_size
operator|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|==
name|NULL
condition|)
block|{
comment|/*	  __ferror(fp) = 1; */
return|return
name|EOF
return|;
block|}
name|memcpy
argument_list|(
name|new_buf
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|_IO_blen
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (lenp ==&LEN(fp))
comment|/* use '\0'-filling */
block|memset(new_buf + pos, 0, blen() - pos);
endif|#
directive|endif
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
condition|)
block|{
operator|(
operator|*
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_free_buffer
operator|)
operator|(
name|fp
operator|->
name|_IO_buf_base
operator|)
expr_stmt|;
comment|/* Make sure _IO_setb won't try to delete _IO_buf_base. */
name|fp
operator|->
name|_IO_buf_base
operator|=
name|NULL
expr_stmt|;
block|}
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|new_buf
argument_list|,
name|new_buf
operator|+
name|new_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|new_buf
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_end
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
operator|+
name|pos
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
operator|+
name|get_pos
expr_stmt|;
empty_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_buf_base
operator|+
name|LEN
argument_list|(
name|fp
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
operator|!
name|flush_only
condition|)
operator|*
name|fp
operator|->
name|_IO_write_ptr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|_IO_str_underflow
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_size_t
name|ppos
init|=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
decl_stmt|;
if|if
condition|(
name|ppos
operator|>
name|LEN
argument_list|(
name|fp
argument_list|)
condition|)
name|LEN
argument_list|(
name|fp
argument_list|)
operator|=
name|ppos
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_TIED_PUT_GET
operator|)
operator|&&
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|LEN
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_IO_read_ptr
return|;
else|else
return|return
name|EOF
return|;
block|}
end_function

begin_function
name|_IO_ssize_t
name|_IO_str_count
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_ssize_t
name|put_len
init|=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
decl_stmt|;
if|if
condition|(
name|put_len
operator|<
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_len
condition|)
name|put_len
operator|=
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_len
expr_stmt|;
return|return
name|put_len
return|;
block|}
end_function

begin_function
name|_IO_pos_t
name|_IO_str_seekoff
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off_t
name|offset
decl_stmt|;
name|_IO_seekflags
name|mode
decl_stmt|;
block|{
name|_IO_ssize_t
name|cur_size
init|=
name|_IO_str_count
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|_IO_pos_t
name|new_pos
init|=
name|EOF
decl_stmt|;
name|int
name|dir
init|=
name|mode
operator|&
literal|3
decl_stmt|;
comment|/* Move the get pointer, if requested. */
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|_IO_seek_not_in
operator|)
condition|)
block|{
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|_IO_seek_end
case|:
name|offset
operator|+=
name|cur_size
expr_stmt|;
break|break;
case|case
name|_IO_seek_cur
case|:
name|offset
operator|+=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
break|break;
default|default:
comment|/* case _IO_seek_set: */
break|break;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
name|_IO_size_t
operator|)
name|offset
operator|>
name|cur_size
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|offset
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|cur_size
expr_stmt|;
name|new_pos
operator|=
name|offset
expr_stmt|;
block|}
comment|/* Move the put pointer, if requested. */
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|_IO_seek_not_out
operator|)
condition|)
block|{
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|_IO_seek_end
case|:
name|offset
operator|+=
name|cur_size
expr_stmt|;
break|break;
case|case
name|_IO_seek_cur
case|:
name|offset
operator|+=
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
expr_stmt|;
break|break;
default|default:
comment|/* case _IO_seek_set: */
break|break;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
name|_IO_size_t
operator|)
name|offset
operator|>
name|cur_size
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_base
operator|+
name|offset
expr_stmt|;
name|new_pos
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|new_pos
return|;
block|}
end_function

begin_function
name|int
name|_IO_str_pbackfail
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
name|_IO_default_pbackfail
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_IO_str_finish
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
operator|(
operator|(
operator|(
name|_IO_strfile
operator|*
operator|)
name|fp
operator|)
operator|->
name|_s
operator|.
name|_free_buffer
operator|)
operator|(
name|fp
operator|->
name|_IO_buf_base
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_buf_base
operator|=
name|NULL
expr_stmt|;
name|_IO_default_finish
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|_IO_jump_t
name|_IO_str_jumps
init|=
block|{
name|_IO_str_overflow
block|,
name|_IO_str_underflow
block|,
name|_IO_default_xsputn
block|,
name|_IO_default_xsgetn
block|,
name|_IO_default_read
block|,
name|_IO_default_write
block|,
name|_IO_default_doallocate
block|,
name|_IO_str_pbackfail
block|,
name|_IO_default_setbuf
block|,
name|_IO_default_sync
block|,
name|_IO_str_finish
block|,
name|_IO_default_close
block|,
name|_IO_default_stat
block|,
name|_IO_default_seek
block|,
name|_IO_str_seekoff
block|,
name|_IO_default_seekpos
block|,
name|_IO_default_uflow
block|}
decl_stmt|;
end_decl_stmt

end_unit

