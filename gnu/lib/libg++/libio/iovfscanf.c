begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/* Extensively hacked for GNU iostream by Per Bothner 1991, 1992, 1993.    Changes copyright Free Software Foundation 1992, 1993. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"%W% (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<libioP.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FLOATING_POINT
end_ifndef

begin_define
define|#
directive|define
name|FLOATING_POINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATING_POINT
end_ifdef

begin_include
include|#
directive|include
file|"floatio.h"
end_include

begin_define
define|#
directive|define
name|BUF
value|(MAXEXP+MAXFRACT+3)
end_define

begin_comment
comment|/* 3 = sign + decimal point + NUL */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUF
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Flags used during conversion.  */
end_comment

begin_define
define|#
directive|define
name|LONG
value|0x01
end_define

begin_comment
comment|/* l: long or double */
end_comment

begin_define
define|#
directive|define
name|LONGDBL
value|0x02
end_define

begin_comment
comment|/* L: long double; unimplemented */
end_comment

begin_define
define|#
directive|define
name|SHORT
value|0x04
end_define

begin_comment
comment|/* h: short */
end_comment

begin_define
define|#
directive|define
name|SUPPRESS
value|0x08
end_define

begin_comment
comment|/* suppress assignment */
end_comment

begin_define
define|#
directive|define
name|POINTER
value|0x10
end_define

begin_comment
comment|/* weird %p pointer (`fake hex') */
end_comment

begin_define
define|#
directive|define
name|NOSKIP
value|0x20
end_define

begin_comment
comment|/* do not skip blanks */
end_comment

begin_define
define|#
directive|define
name|WIDTH
value|0x40
end_define

begin_comment
comment|/* width */
end_comment

begin_comment
comment|/*  * The following are used in numeric conversions only:  * SIGNOK, NDIGITS, DPTOK, and EXPOK are for floating point;  * SIGNOK, NDIGITS, PFXOK, and NZDIGITS are for integral.  */
end_comment

begin_define
define|#
directive|define
name|SIGNOK
value|0x40
end_define

begin_comment
comment|/* +/- is (still) legal */
end_comment

begin_define
define|#
directive|define
name|NDIGITS
value|0x80
end_define

begin_comment
comment|/* no digits detected */
end_comment

begin_define
define|#
directive|define
name|DPTOK
value|0x100
end_define

begin_comment
comment|/* (float) decimal point is still legal */
end_comment

begin_define
define|#
directive|define
name|EXPOK
value|0x200
end_define

begin_comment
comment|/* (float) exponent (e+3, etc) still legal */
end_comment

begin_define
define|#
directive|define
name|PFXOK
value|0x100
end_define

begin_comment
comment|/* 0x prefix is (still) legal */
end_comment

begin_define
define|#
directive|define
name|NZDIGITS
value|0x200
end_define

begin_comment
comment|/* no zero digits detected */
end_comment

begin_comment
comment|/*  * Conversion types.  */
end_comment

begin_define
define|#
directive|define
name|CT_CHAR
value|0
end_define

begin_comment
comment|/* %c conversion */
end_comment

begin_define
define|#
directive|define
name|CT_CCL
value|1
end_define

begin_comment
comment|/* %[...] conversion */
end_comment

begin_define
define|#
directive|define
name|CT_STRING
value|2
end_define

begin_comment
comment|/* %s conversion */
end_comment

begin_define
define|#
directive|define
name|CT_INT
value|3
end_define

begin_comment
comment|/* integer, i.e., strtol or strtoul */
end_comment

begin_define
define|#
directive|define
name|CT_FLOAT
value|4
end_define

begin_comment
comment|/* floating, i.e., strtod */
end_comment

begin_define
define|#
directive|define
name|u_char
value|unsigned char
end_define

begin_define
define|#
directive|define
name|u_long
value|unsigned long
end_define

begin_decl_stmt
specifier|extern
name|u_long
name|strtoul
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|strtol
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
modifier|*
name|__sccl
name|__P
argument_list|(
operator|(
name|char
operator|*
name|tab
operator|,
specifier|const
name|u_char
operator|*
name|fmt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_USE_DTOA
end_ifndef

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If errp != NULL, *errp|=1 if we see a premature EOF;    *errp|=2 if we an invalid character. */
end_comment

begin_function
name|int
name|_IO_vfscanf
parameter_list|(
name|fp
parameter_list|,
name|fmt0
parameter_list|,
name|ap
parameter_list|,
name|errp
parameter_list|)
specifier|register
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt0
decl_stmt|;
name|_IO_va_list
name|ap
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
specifier|register
specifier|const
name|u_char
modifier|*
name|fmt
init|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|fmt0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* character from format, or conversion */
specifier|register
name|_IO_ssize_t
name|width
decl_stmt|;
comment|/* field width, or 0 */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* points into all kinds of strings */
specifier|register
name|int
name|n
decl_stmt|;
comment|/* handy integer */
specifier|register
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* flags as defined above */
specifier|register
name|char
modifier|*
name|p0
decl_stmt|;
comment|/* saves original value of p when necessary */
name|int
name|nassigned
decl_stmt|;
comment|/* number of fields assigned */
name|int
name|nread
decl_stmt|;
comment|/* number of characters consumed from fp */
comment|/* Assignments to base and ccfn are just to suppress warnings from gcc.*/
name|int
name|base
init|=
literal|0
decl_stmt|;
comment|/* base argument to strtol/strtoul */
typedef|typedef
name|u_long
argument_list|(
argument|*strtoulfn
argument_list|)
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|strtoulfn
name|ccfn
init|=
literal|0
decl_stmt|;
comment|/* conversion function (strtol/strtoul) */
name|char
name|ccltab
index|[
literal|256
index|]
decl_stmt|;
comment|/* character class table for %[...] */
name|char
name|buf
index|[
name|BUF
index|]
decl_stmt|;
comment|/* buffer for numeric conversions */
name|int
name|seen_eof
init|=
literal|0
decl_stmt|;
comment|/* `basefix' is used to avoid `if' tests in the integer scanner */
specifier|static
name|short
name|basefix
index|[
literal|17
index|]
init|=
block|{
literal|10
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
name|nassigned
operator|=
literal|0
expr_stmt|;
name|nread
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|_IO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|seen_eof
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|_IO_ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
name|nread
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
goto|goto
name|literal
goto|;
name|width
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 		 * switch on the format.  continue if done; 		 * break once format type is derived. 		 */
name|again
label|:
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|literal
label|:
name|n
operator|=
name|_IO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|EOF
condition|)
goto|goto
name|eof_failure
goto|;
if|if
condition|(
name|n
operator|!=
name|c
condition|)
block|{
name|_IO_ungetc
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|match_failure
goto|;
block|}
name|nread
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|flags
condition|)
goto|goto
name|control_failure
goto|;
name|flags
operator|=
name|SUPPRESS
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'l'
case|:
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|SUPPRESS
operator||
name|WIDTH
operator|)
condition|)
goto|goto
name|control_failure
goto|;
name|flags
operator||=
name|LONG
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'L'
case|:
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|SUPPRESS
operator||
name|WIDTH
operator|)
condition|)
goto|goto
name|control_failure
goto|;
name|flags
operator||=
name|LONGDBL
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'h'
case|:
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|SUPPRESS
operator||
name|WIDTH
operator|)
condition|)
goto|goto
name|control_failure
goto|;
name|flags
operator||=
name|SHORT
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|SUPPRESS
operator||
name|WIDTH
operator|)
condition|)
goto|goto
name|control_failure
goto|;
name|flags
operator||=
name|WIDTH
expr_stmt|;
name|width
operator|=
name|width
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* 		 * Conversions. 		 * Those marked `compat' are for 4.[123]BSD compatibility. 		 * 		 * (According to ANSI, E and X formats are supposed 		 * to the same as e and x.  Sorry about that.) 		 */
case|case
literal|'D'
case|:
comment|/* compat */
name|flags
operator||=
name|LONG
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'d'
case|:
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
operator|(
name|strtoulfn
operator|)
name|strtol
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
operator|(
name|strtoulfn
operator|)
name|strtol
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* compat */
name|flags
operator||=
name|LONG
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'o'
case|:
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
name|strtoul
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
name|strtoul
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
name|flags
operator||=
name|PFXOK
expr_stmt|;
comment|/* enable 0x prefixing */
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
name|strtoul
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FLOATING_POINT
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
name|c
operator|=
name|CT_FLOAT
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|c
operator|=
name|CT_STRING
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|fmt
operator|=
name|__sccl
argument_list|(
name|ccltab
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|flags
operator||=
name|NOSKIP
expr_stmt|;
name|c
operator|=
name|CT_CCL
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flags
operator||=
name|NOSKIP
expr_stmt|;
name|c
operator|=
name|CT_CHAR
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pointer format is like hex */
name|flags
operator||=
name|POINTER
operator||
name|PFXOK
expr_stmt|;
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
name|strtoul
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|flags
operator|&
name|SUPPRESS
condition|)
comment|/* ??? */
continue|continue;
if|if
condition|(
name|flags
operator|&
name|SHORT
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|nread
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LONG
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
operator|*
argument_list|)
operator|=
name|nread
expr_stmt|;
else|else
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|nread
expr_stmt|;
continue|continue;
comment|/* 		 * Disgusting backwards compatibility hacks.	XXX 		 */
case|case
literal|'\0'
case|:
comment|/* compat */
name|nassigned
operator|=
name|EOF
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
comment|/* compat */
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|flags
operator||=
name|LONG
expr_stmt|;
name|c
operator|=
name|CT_INT
expr_stmt|;
name|ccfn
operator|=
operator|(
name|strtoulfn
operator|)
name|strtol
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
break|break;
block|}
comment|/* 		 * We have a conversion that requires input. 		 */
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|eof_failure
goto|;
comment|/* 		 * Consume leading white space, except for formats 		 * that suppress this. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|NOSKIP
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
name|nread
operator|++
expr_stmt|;
name|n
operator|=
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|EOF
condition|)
goto|goto
name|eof_failure
goto|;
block|}
comment|/* Note that there is at least one character in 		       the buffer, so conversions that do not set NOSKIP 		       can no longer result in an input failure. */
block|}
comment|/* 		 * Do the conversion. 		 */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CT_CHAR
case|:
comment|/* scan arbitrary characters (sets NOSKIP) */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
comment|/* FIXME! */
name|width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SUPPRESS
condition|)
block|{
name|_IO_size_t
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
if|if
condition|(
name|n
operator|<
operator|(
name|int
operator|)
name|width
condition|)
block|{
name|sum
operator|+=
name|n
expr_stmt|;
name|width
operator|-=
name|n
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|__underflow
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
goto|goto
name|eof_failure
goto|;
else|else
block|{
name|seen_eof
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|sum
operator|+=
name|width
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|+=
name|width
expr_stmt|;
break|break;
block|}
block|}
name|nread
operator|+=
name|sum
expr_stmt|;
block|}
else|else
block|{
name|_IO_size_t
name|r
init|=
call|(
modifier|*
name|fp
operator|->
name|_jumps
operator|->
name|__xsgetn
call|)
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|width
condition|)
goto|goto
name|eof_failure
goto|;
name|nread
operator|+=
name|r
expr_stmt|;
name|nassigned
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CT_CCL
case|:
comment|/* scan a (nonempty) character class (sets NOSKIP) */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* `infinity' */
comment|/* take only those things in the class */
if|if
condition|(
name|flags
operator|&
name|SUPPRESS
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ccltab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
index|]
condition|)
block|{
name|n
operator|++
operator|,
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|eof_failure
goto|;
name|seen_eof
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|match_failure
goto|;
block|}
else|else
block|{
name|p0
operator|=
name|p
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccltab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
index|]
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|p0
condition|)
goto|goto
name|eof_failure
goto|;
name|seen_eof
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|n
operator|=
name|p
operator|-
name|p0
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|match_failure
goto|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nassigned
operator|++
expr_stmt|;
block|}
name|nread
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|CT_STRING
case|:
comment|/* like CCL, but zero-length string OK,& no NOSKIP */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SUPPRESS
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
argument_list|)
condition|)
block|{
name|n
operator|++
operator|,
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|seen_eof
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|nread
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|p0
operator|=
name|p
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|width
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|seen_eof
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nread
operator|+=
name|p
operator|-
name|p0
expr_stmt|;
name|nassigned
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
name|CT_INT
case|:
comment|/* scan an integer as if by strtol/strtoul */
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|width
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
name|width
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|flags
operator||=
name|SIGNOK
operator||
name|NDIGITS
operator||
name|NZDIGITS
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|width
condition|;
name|width
operator|--
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
comment|/* 				 * Switch on the character; `goto ok' 				 * if we accept it as a part of number. 				 */
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 				 * The digit 0 is always legal, but is 				 * special.  For %i conversions, if no 				 * digits (zero or nonzero) have been 				 * scanned (only signs), we will have 				 * base==0.  In that case, we should set 				 * it to 8 and enable 0x prefixing. 				 * Also, if we have not scanned zero digits 				 * before this, do not turn off prefixing 				 * (someone else will turn it off if we 				 * have scanned any nonzero digits). 				 */
case|case
literal|'0'
case|:
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|flags
operator||=
name|PFXOK
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|NZDIGITS
condition|)
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|NZDIGITS
operator||
name|NDIGITS
operator|)
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|PFXOK
operator||
name|NDIGITS
operator|)
expr_stmt|;
goto|goto
name|ok
goto|;
comment|/* 1 through 7 always legal */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|base
operator|=
name|basefix
index|[
name|base
index|]
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|PFXOK
operator||
name|NDIGITS
operator|)
expr_stmt|;
goto|goto
name|ok
goto|;
comment|/* digits 8 and 9 ok iff decimal or hex */
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|base
operator|=
name|basefix
index|[
name|base
index|]
expr_stmt|;
if|if
condition|(
name|base
operator|<=
literal|8
condition|)
break|break;
comment|/* not legal here */
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|PFXOK
operator||
name|NDIGITS
operator|)
expr_stmt|;
goto|goto
name|ok
goto|;
comment|/* letters ok iff hex */
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
comment|/* no need to fix base here */
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
break|break;
comment|/* not legal here */
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|PFXOK
operator||
name|NDIGITS
operator|)
expr_stmt|;
goto|goto
name|ok
goto|;
comment|/* sign ok only as first character */
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|flags
operator|&
name|SIGNOK
condition|)
block|{
name|flags
operator|&=
operator|~
name|SIGNOK
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
break|break;
comment|/* x ok iff flag still set& 2nd char */
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|flags
operator|&
name|PFXOK
operator|&&
name|p
operator|==
name|buf
operator|+
literal|1
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
comment|/* if %i */
name|flags
operator|&=
operator|~
name|PFXOK
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
break|break;
block|}
comment|/* 				 * If we got here, c is not a legal character 				 * for a number.  Stop accumulating digits. 				 */
break|break;
name|ok
label|:
comment|/* 				 * c is legal: store it and look at the next. 				 */
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|seen_eof
operator|++
expr_stmt|;
break|break;
comment|/* EOF */
block|}
block|}
comment|/* 			 * If we had only a sign, it is no good; push 			 * back the sign.  If the number ends in `x', 			 * it was [sign] '0' 'x', so push back the x 			 * and treat it as [sign] '0'. 			 */
if|if
condition|(
name|flags
operator|&
name|NDIGITS
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|(
name|void
operator|)
name|_IO_ungetc
argument_list|(
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|--
name|p
argument_list|,
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|match_failure
goto|;
block|}
name|c
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|)
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
condition|)
block|{
operator|--
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|_IO_ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SUPPRESS
operator|)
operator|==
literal|0
condition|)
block|{
name|u_long
name|res
decl_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|res
operator|=
call|(
modifier|*
name|ccfn
call|)
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|POINTER
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
operator|*
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|res
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SHORT
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|res
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LONG
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
operator|*
argument_list|)
operator|=
name|res
expr_stmt|;
else|else
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|res
expr_stmt|;
name|nassigned
operator|++
expr_stmt|;
block|}
name|nread
operator|+=
name|p
operator|-
name|buf
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FLOATING_POINT
case|case
name|CT_FLOAT
case|:
comment|/* scan a floating point number as if by strtod */
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|width
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
name|width
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|flags
operator||=
name|SIGNOK
operator||
name|NDIGITS
operator||
name|DPTOK
operator||
name|EXPOK
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|width
condition|;
name|width
operator|--
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
comment|/* 				 * This code mimicks the integer conversion 				 * code, but is much simpler. 				 */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|NDIGITS
operator|)
expr_stmt|;
goto|goto
name|fok
goto|;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|flags
operator|&
name|SIGNOK
condition|)
block|{
name|flags
operator|&=
operator|~
name|SIGNOK
expr_stmt|;
goto|goto
name|fok
goto|;
block|}
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|flags
operator|&
name|DPTOK
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|SIGNOK
operator||
name|DPTOK
operator|)
expr_stmt|;
goto|goto
name|fok
goto|;
block|}
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
comment|/* no exponent without some digits */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|NDIGITS
operator||
name|EXPOK
operator|)
operator|)
operator|==
name|EXPOK
condition|)
block|{
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
operator|(
name|EXPOK
operator||
name|DPTOK
operator|)
operator|)
operator||
name|SIGNOK
operator||
name|NDIGITS
expr_stmt|;
goto|goto
name|fok
goto|;
block|}
break|break;
block|}
break|break;
name|fok
label|:
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|_IO_peekc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|seen_eof
operator|++
expr_stmt|;
break|break;
comment|/* EOF */
block|}
block|}
comment|/* 			 * If no digits, might be missing exponent digits 			 * (just give back the exponent) or might be missing 			 * regular digits, but had sign and/or decimal point. 			 */
if|if
condition|(
name|flags
operator|&
name|NDIGITS
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EXPOK
condition|)
block|{
comment|/* no digits at all */
while|while
condition|(
name|p
operator|>
name|buf
condition|)
name|_IO_ungetc
argument_list|(
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|--
name|p
argument_list|,
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|match_failure
goto|;
block|}
comment|/* just a bad exponent (e and maybe sign) */
name|c
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'e'
operator|&&
name|c
operator|!=
literal|'E'
condition|)
block|{
operator|(
name|void
operator|)
name|_IO_ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* sign */
name|c
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|--
name|p
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|_IO_ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SUPPRESS
operator|)
operator|==
literal|0
condition|)
block|{
name|double
name|res
decl_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_IO_USE_DTOA
name|res
operator|=
name|_IO_strtod
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|res
operator|=
name|atof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|LONG
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
operator|*
argument_list|)
operator|=
name|res
expr_stmt|;
else|else
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
operator|=
name|res
expr_stmt|;
name|nassigned
operator|++
expr_stmt|;
block|}
name|nread
operator|+=
name|p
operator|-
name|buf
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FLOATING_POINT */
block|}
block|}
name|eof_failure
label|:
name|seen_eof
operator|++
expr_stmt|;
name|input_failure
label|:
if|if
condition|(
name|nassigned
operator|==
literal|0
condition|)
name|nassigned
operator|=
operator|-
literal|1
expr_stmt|;
name|control_failure
label|:
name|match_failure
label|:
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator||=
literal|2
expr_stmt|;
name|done
label|:
if|if
condition|(
name|errp
operator|&&
name|seen_eof
condition|)
operator|*
name|errp
operator||=
literal|1
expr_stmt|;
return|return
operator|(
name|nassigned
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the given table from the scanset at the given format  * (just after `[').  Return a pointer to the character past the  * closing `]'.  The table has a 1 wherever characters should be  * considered part of the scanset.  */
end_comment

begin_function
specifier|static
specifier|const
name|u_char
modifier|*
name|__sccl
parameter_list|(
name|tab
parameter_list|,
name|fmt
parameter_list|)
specifier|register
name|char
modifier|*
name|tab
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|fmt
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|v
decl_stmt|;
comment|/* first `clear' the whole table */
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
comment|/* first char hat => negated scanset */
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|v
operator|=
literal|1
expr_stmt|;
comment|/* default => accept */
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
comment|/* get new first char */
block|}
else|else
name|v
operator|=
literal|0
expr_stmt|;
comment|/* default => reject */
comment|/* should probably use memset here */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
name|tab
index|[
name|n
index|]
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
name|fmt
operator|-
literal|1
operator|)
return|;
comment|/* format ended before closing ] */
comment|/* 	 * Now set the entries corresponding to the actual scanset 	 * to the opposite of the above. 	 * 	 * The first character may be ']' (or '-') without being special; 	 * the last character may be '-'. 	 */
name|v
operator|=
literal|1
operator|-
name|v
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tab
index|[
name|c
index|]
operator|=
name|v
expr_stmt|;
comment|/* take character c */
name|doswitch
label|:
name|n
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
comment|/* and examine the next */
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* format ended too soon */
return|return
operator|(
name|fmt
operator|-
literal|1
operator|)
return|;
case|case
literal|'-'
case|:
comment|/* 			 * A scanset of the form 			 *	[01+-] 			 * is defined as `the digit 0, the digit 1, 			 * the character +, the character -', but 			 * the effect of a scanset such as 			 *	[a-zA-Z0-9] 			 * is implementation defined.  The V7 Unix 			 * scanf treats `a-z' as `the letters a through 			 * z', but treats `a-a' as `the letter a, the 			 * character -, and the letter a'. 			 * 			 * For compatibility, the `-' is not considerd 			 * to define a range if the character following 			 * it is either a close bracket (required by ANSI) 			 * or is not numerically greater than the character 			 * we just stored in the table (c). 			 */
name|n
operator|=
operator|*
name|fmt
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|']'
operator|||
name|n
operator|<
name|c
condition|)
block|{
name|c
operator|=
literal|'-'
expr_stmt|;
break|break;
comment|/* resume the for(;;) */
block|}
name|fmt
operator|++
expr_stmt|;
do|do
block|{
comment|/* fill in the range */
name|tab
index|[
operator|++
name|c
index|]
operator|=
name|v
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|<
name|n
condition|)
do|;
if|#
directive|if
literal|1
comment|/* XXX another disgusting compatibility hack */
comment|/* 			 * Alas, the V7 Unix scanf also treats formats 			 * such as [a-c-e] as `the letters a through e'. 			 * This too is permitted by the standard.... 			 */
goto|goto
name|doswitch
goto|;
else|#
directive|else
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
name|fmt
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
return|return
operator|(
name|fmt
operator|)
return|;
endif|#
directive|endif
break|break;
case|case
literal|']'
case|:
comment|/* end of scanset */
return|return
operator|(
name|fmt
operator|)
return|;
default|default:
comment|/* just another character */
name|c
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

end_unit

