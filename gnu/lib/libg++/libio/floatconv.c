begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_include
include|#
directive|include
file|<libioP.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DTOA
end_ifdef

begin_comment
comment|/****************************************************************  *  * The author of this software is David M. Gay.  *  * Copyright (c) 1991 by AT&T.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose without fee is hereby granted, provided that this entire notice  * is included in all copies of any software which is or includes a copy  * or modification of this software and in all copies of the supporting  * documentation for such software.  *  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.  *  ***************************************************************/
end_comment

begin_comment
comment|/* Some cleaning up by Per Bothner, bothner@cygnus.com, 1992, 1993.    Re-written to not need static variables    (except result, result_k, HIWORD, LOWORD). */
end_comment

begin_comment
comment|/* Please send bug reports to         David M. Gay         AT&T Bell Laboratories, Room 2C-463         600 Mountain Avenue         Murray Hill, NJ 07974-2070         U.S.A.         dmg@research.att.com or research!dmg  */
end_comment

begin_comment
comment|/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.  *  * This strtod returns a nearest machine number to the input decimal  * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are  * broken by the IEEE round-even rule.  Otherwise ties are broken by  * biased rounding (add half and chop).  *  * Inspired loosely by William D. Clinger's paper "How to Read Floating  * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].  *  * Modifications:  *  *      1. We only require IEEE, IBM, or VAX double-precision  *              arithmetic (not IEEE double-extended).  *      2. We get by with floating-point arithmetic in a case that  *              Clinger missed -- when we're computing d * 10^n  *              for a small integer d and the integer n is not too  *              much larger than 22 (the maximum integer k for which  *              we can represent 10^k exactly), we may be able to  *              compute (d*10^k) * 10^(e-k) with just one roundoff.  *      3. Rather than a bit-at-a-time adjustment of the binary  *              result in the hard case, we use floating-point  *              arithmetic to determine the adjustment to within  *              one bit; only in really hard cases do we need to  *              compute a second residual.  *      4. Because of 3., we don't need a large table of powers of 10  *              for ten-to-e (just some small tables, e.g. of 10^k  *              for 0<= k<= 22).  */
end_comment

begin_comment
comment|/*  * #define IEEE_8087 for IEEE-arithmetic machines where the least  *      significant byte has the lowest address.  * #define IEEE_MC68k for IEEE-arithmetic machines where the most  *      significant byte has the lowest address.  * #define Sudden_Underflow for IEEE-format machines without gradual  *      underflow (i.e., that flush to zero on underflow).  * #define IBM for IBM mainframe-style floating-point arithmetic.  * #define VAX for VAX-style floating-point arithmetic.  * #define Unsigned_Shifts if>> does treats its left operand as unsigned.  * #define No_leftright to omit left-right logic in fast floating-point  *      computation of dtoa.  * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.  * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines  *      that use extended-precision instructions to compute rounded  *      products and quotients) with IBM.  * #define ROUND_BIASED for IEEE-format with biased rounding.  * #define Inaccurate_Divide for IEEE-format with correctly rounded  *      products but inaccurate quotients, e.g., for Intel i860.  * #define KR_headers for old-style C function headers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|Bug
parameter_list|(
name|x
parameter_list|)
value|{fprintf(stderr, "%s\n", x); exit(1);}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_define
define|#
directive|define
name|CONST
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONST
end_define

begin_define
define|#
directive|define
name|KR_headers
end_define

begin_comment
comment|/* In this case, we assume IEEE floats. */
end_comment

begin_define
define|#
directive|define
name|FLT_ROUNDS
value|1
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|2
end_define

begin_define
define|#
directive|define
name|DBL_MANT_DIG
value|53
end_define

begin_define
define|#
directive|define
name|DBL_DIG
value|15
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|308
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__MATH_H__
end_ifndef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Unsigned_Shifts
end_ifdef

begin_define
define|#
directive|define
name|Sign_Extend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (b< 0) a |= 0xffff0000;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Sign_Extend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_comment
comment|/*no-op*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i860__
argument_list|)
operator|||
name|defined
argument_list|(
name|clipper
argument_list|)
end_if

begin_define
define|#
directive|define
name|IEEE_8087
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MIPSEL
argument_list|)
operator|||
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_define
define|#
directive|define
name|IEEE_8087
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|||
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|MIPSEB
argument_list|)
end_if

begin_define
define|#
directive|define
name|IEEE_MC68k
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_8087
argument_list|)
operator|+
name|defined
argument_list|(
name|IEEE_MC68k
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
operator|+
name|defined
argument_list|(
name|IBM
argument_list|)
operator|!=
literal|1
end_if

begin_if
if|#
directive|if
name|FLT_RADIX
operator|==
literal|16
end_if

begin_define
define|#
directive|define
name|IBM
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|DBL_MANT_DIG
operator|==
literal|56
end_if

begin_define
define|#
directive|define
name|VAX
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|DBL_MANT_DIG
operator|==
literal|53
operator|&&
name|DBL_MAX_10_EXP
operator|==
literal|308
end_if

begin_define
define|#
directive|define
name|IEEE_Unknown
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|Exactly
name|one
name|of
name|IEEE_8087
decl_stmt|,
name|IEEE_MC68k
decl_stmt|,
name|VAX
decl_stmt|,
name|or
name|IBM
name|should
name|be
name|defined
operator|.
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
decl|typedef
name|_G_uint32_t
name|unsigned32
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_8087
end_ifdef

begin_define
define|#
directive|define
name|HIWORD
value|1
end_define

begin_define
define|#
directive|define
name|LOWORD
value|0
end_define

begin_define
define|#
directive|define
name|TEST_ENDIANNESS
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_MC68k
argument_list|)
end_if

begin_define
define|#
directive|define
name|HIWORD
value|0
end_define

begin_define
define|#
directive|define
name|LOWORD
value|1
end_define

begin_define
define|#
directive|define
name|TEST_ENDIANNESS
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|HIWORD
init|=
operator|-
literal|1
decl_stmt|,
name|LOWORD
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|test_endianness
parameter_list|()
block|{
union|union
name|doubleword
block|{
name|double
name|d
decl_stmt|;
name|unsigned32
name|u
index|[
literal|2
index|]
decl_stmt|;
block|}
name|dw
union|;
name|dw
operator|.
name|d
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|dw
operator|.
name|u
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
comment|/* big-endian */
name|HIWORD
operator|=
literal|0
operator|,
name|LOWORD
operator|=
literal|1
expr_stmt|;
else|else
name|HIWORD
operator|=
literal|1
operator|,
name|LOWORD
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TEST_ENDIANNESS
value|if (HIWORD<0) test_endianness();
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|union {   double d;   unsigned32 x[2]; } _temp;
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((unsigned32 *)&x)[HIWORD]
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|word0
parameter_list|(
name|X
parameter_list|)
value|(_temp.d = X, _temp.x[HIWORD])
end_define

begin_define
define|#
directive|define
name|setword0
parameter_list|(
name|D
parameter_list|,
name|X
parameter_list|)
value|(_temp.d = D, _temp.x[HIWORD] = X, D = _temp.d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((unsigned32 *)&x)[LOWORD]
end_define

begin_comment
comment|/* The following definition of Storeinc is appropriate for MIPS processors. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_8087
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(((unsigned short *)a)[1] = (unsigned short)b, \ ((unsigned short *)a)[0] = (unsigned short)c, a++)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_MC68k
argument_list|)
end_if

begin_define
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(((unsigned short *)a)[0] = (unsigned short)b, \ ((unsigned short *)a)[1] = (unsigned short)c, a++)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(*a++ = b<< 16 | c& 0xffff)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define P DBL_MANT_DIG */
end_comment

begin_comment
comment|/* Ten_pmax = floor(P*log(2)/log(5)) */
end_comment

begin_comment
comment|/* Bletch = (highest power of 2< DBL_MAX_10_EXP) / 16 */
end_comment

begin_comment
comment|/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
end_comment

begin_comment
comment|/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_8087
argument_list|)
operator|+
name|defined
argument_list|(
name|IEEE_MC68k
argument_list|)
operator|+
name|defined
argument_list|(
name|IEEE_Unknown
argument_list|)
end_if

begin_define
define|#
directive|define
name|Exp_shift
value|20
end_define

begin_define
define|#
directive|define
name|Exp_shift1
value|20
end_define

begin_define
define|#
directive|define
name|Exp_msk1
value|0x100000
end_define

begin_define
define|#
directive|define
name|Exp_msk11
value|0x100000
end_define

begin_define
define|#
directive|define
name|Exp_mask
value|0x7ff00000
end_define

begin_define
define|#
directive|define
name|P
value|53
end_define

begin_define
define|#
directive|define
name|Bias
value|1023
end_define

begin_define
define|#
directive|define
name|IEEE_Arith
end_define

begin_define
define|#
directive|define
name|Emin
value|(-1022)
end_define

begin_define
define|#
directive|define
name|Exp_1
value|0x3ff00000
end_define

begin_define
define|#
directive|define
name|Exp_11
value|0x3ff00000
end_define

begin_define
define|#
directive|define
name|Ebits
value|11
end_define

begin_define
define|#
directive|define
name|Frac_mask
value|0xfffff
end_define

begin_define
define|#
directive|define
name|Frac_mask1
value|0xfffff
end_define

begin_define
define|#
directive|define
name|Ten_pmax
value|22
end_define

begin_define
define|#
directive|define
name|Bletch
value|0x10
end_define

begin_define
define|#
directive|define
name|Bndry_mask
value|0xfffff
end_define

begin_define
define|#
directive|define
name|Bndry_mask1
value|0xfffff
end_define

begin_define
define|#
directive|define
name|LSB
value|1
end_define

begin_define
define|#
directive|define
name|Sign_bit
value|0x80000000
end_define

begin_define
define|#
directive|define
name|Log2P
value|1
end_define

begin_define
define|#
directive|define
name|Tiny0
value|0
end_define

begin_define
define|#
directive|define
name|Tiny1
value|1
end_define

begin_define
define|#
directive|define
name|Quick_max
value|14
end_define

begin_define
define|#
directive|define
name|Int_max
value|14
end_define

begin_define
define|#
directive|define
name|Infinite
parameter_list|(
name|x
parameter_list|)
value|(word0(x) == 0x7ff00000)
end_define

begin_comment
comment|/* sufficient test for here */
end_comment

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|Sudden_Underflow
end_undef

begin_define
define|#
directive|define
name|Sudden_Underflow
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_define
define|#
directive|define
name|Exp_shift
value|24
end_define

begin_define
define|#
directive|define
name|Exp_shift1
value|24
end_define

begin_define
define|#
directive|define
name|Exp_msk1
value|0x1000000
end_define

begin_define
define|#
directive|define
name|Exp_msk11
value|0x1000000
end_define

begin_define
define|#
directive|define
name|Exp_mask
value|0x7f000000
end_define

begin_define
define|#
directive|define
name|P
value|14
end_define

begin_define
define|#
directive|define
name|Bias
value|65
end_define

begin_define
define|#
directive|define
name|Exp_1
value|0x41000000
end_define

begin_define
define|#
directive|define
name|Exp_11
value|0x41000000
end_define

begin_define
define|#
directive|define
name|Ebits
value|8
end_define

begin_comment
comment|/* exponent has 7 bits, but 8 is the right value in b2d */
end_comment

begin_define
define|#
directive|define
name|Frac_mask
value|0xffffff
end_define

begin_define
define|#
directive|define
name|Frac_mask1
value|0xffffff
end_define

begin_define
define|#
directive|define
name|Bletch
value|4
end_define

begin_define
define|#
directive|define
name|Ten_pmax
value|22
end_define

begin_define
define|#
directive|define
name|Bndry_mask
value|0xefffff
end_define

begin_define
define|#
directive|define
name|Bndry_mask1
value|0xffffff
end_define

begin_define
define|#
directive|define
name|LSB
value|1
end_define

begin_define
define|#
directive|define
name|Sign_bit
value|0x80000000
end_define

begin_define
define|#
directive|define
name|Log2P
value|4
end_define

begin_define
define|#
directive|define
name|Tiny0
value|0x100000
end_define

begin_define
define|#
directive|define
name|Tiny1
value|0
end_define

begin_define
define|#
directive|define
name|Quick_max
value|14
end_define

begin_define
define|#
directive|define
name|Int_max
value|15
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VAX */
end_comment

begin_define
define|#
directive|define
name|Exp_shift
value|23
end_define

begin_define
define|#
directive|define
name|Exp_shift1
value|7
end_define

begin_define
define|#
directive|define
name|Exp_msk1
value|0x80
end_define

begin_define
define|#
directive|define
name|Exp_msk11
value|0x800000
end_define

begin_define
define|#
directive|define
name|Exp_mask
value|0x7f80
end_define

begin_define
define|#
directive|define
name|P
value|56
end_define

begin_define
define|#
directive|define
name|Bias
value|129
end_define

begin_define
define|#
directive|define
name|Exp_1
value|0x40800000
end_define

begin_define
define|#
directive|define
name|Exp_11
value|0x4080
end_define

begin_define
define|#
directive|define
name|Ebits
value|8
end_define

begin_define
define|#
directive|define
name|Frac_mask
value|0x7fffff
end_define

begin_define
define|#
directive|define
name|Frac_mask1
value|0xffff007f
end_define

begin_define
define|#
directive|define
name|Ten_pmax
value|24
end_define

begin_define
define|#
directive|define
name|Bletch
value|2
end_define

begin_define
define|#
directive|define
name|Bndry_mask
value|0xffff007f
end_define

begin_define
define|#
directive|define
name|Bndry_mask1
value|0xffff007f
end_define

begin_define
define|#
directive|define
name|LSB
value|0x10000
end_define

begin_define
define|#
directive|define
name|Sign_bit
value|0x8000
end_define

begin_define
define|#
directive|define
name|Log2P
value|1
end_define

begin_define
define|#
directive|define
name|Tiny0
value|0x80
end_define

begin_define
define|#
directive|define
name|Tiny1
value|0
end_define

begin_define
define|#
directive|define
name|Quick_max
value|15
end_define

begin_define
define|#
directive|define
name|Int_max
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IEEE_Arith
end_ifndef

begin_define
define|#
directive|define
name|ROUND_BIASED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RND_PRODQUOT
end_ifdef

begin_define
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_prod(a, b)
end_define

begin_define
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_quot(a, b)
end_define

begin_decl_stmt
specifier|extern
name|double
name|rnd_prod
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|,
name|rnd_quot
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a *= b
end_define

begin_define
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a /= b
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Big0
value|(Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
end_define

begin_define
define|#
directive|define
name|Big1
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|Kmax
value|15
end_define

begin_comment
comment|/* (1<<BIGINT_MINIMUM_K) is the minimum number of words to allocate    in a Bigint.  dtoa usually manages with 1<<2, and has not been    known to need more than 1<<3.  */
end_comment

begin_define
define|#
directive|define
name|BIGINT_MINIMUM_K
value|3
end_define

begin_struct
struct|struct
name|Bigint
block|{
name|struct
name|Bigint
modifier|*
name|next
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* Parameter given to Balloc(k) */
name|int
name|maxwds
decl_stmt|;
comment|/* Allocated space: equals 1<<k. */
name|short
name|on_stack
decl_stmt|;
comment|/* 1 if stack-allocated. */
name|short
name|sign
decl_stmt|;
comment|/* 0 if value is positive or zero; 1 if negative. */
name|int
name|wds
decl_stmt|;
comment|/* Current length. */
name|unsigned32
name|x
index|[
literal|1
operator|<<
name|BIGINT_MINIMUM_K
index|]
decl_stmt|;
comment|/* Actually: x[maxwds] */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BIGINT_HEADER_SIZE
define|\
value|(sizeof(Bigint) - (1<<BIGINT_MINIMUM_K) * sizeof(unsigned32))
end_define

begin_typedef
typedef|typedef
name|struct
name|Bigint
name|Bigint
typedef|;
end_typedef

begin_comment
comment|/* Initialize a stack-allocated Bigint. */
end_comment

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|Binit
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|v
argument_list|)
name|Bigint
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|v
operator|)
endif|#
directive|endif
block|{
name|v
operator|->
name|on_stack
operator|=
literal|1
block|;
name|v
operator|->
name|k
operator|=
name|BIGINT_MINIMUM_K
block|;
name|v
operator|->
name|maxwds
operator|=
literal|1
operator|<<
name|BIGINT_MINIMUM_K
block|;
name|v
operator|->
name|sign
operator|=
name|v
operator|->
name|wds
operator|=
literal|0
block|;
return|return
name|v
return|;
block|}
end_expr_stmt

begin_comment
comment|/* Allocate a Bigint with '1<<k' big digits. */
end_comment

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|Balloc
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|k
argument_list|)
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|int
name|k
operator|)
endif|#
directive|endif
block|{
name|int
name|x
block|;
name|Bigint
operator|*
name|rv
block|;
if|if
condition|(
name|k
operator|<
name|BIGINT_MINIMUM_K
condition|)
name|k
operator|=
name|BIGINT_MINIMUM_K
expr_stmt|;
name|x
operator|=
literal|1
operator|<<
name|k
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|=
operator|(
name|Bigint
operator|*
operator|)
name|malloc
argument_list|(
name|BIGINT_HEADER_SIZE
operator|+
name|x
operator|*
sizeof|sizeof
argument_list|(
name|unsigned32
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|->
name|k
operator|=
name|k
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|->
name|maxwds
operator|=
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|->
name|sign
operator|=
name|rv
operator|->
name|wds
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|->
name|on_stack
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|rv
return|;
end_return

begin_decl_stmt
unit|}  static
name|void
name|Bfree
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|v
argument_list|)
name|Bigint
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|v
operator|)
endif|#
directive|endif
block|{
if|if
condition|(
name|v
operator|&&
operator|!
name|v
operator|->
name|on_stack
condition|)
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|Bcopy
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
name|Bigint
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|x
operator|,
name|Bigint
operator|*
name|y
operator|)
endif|#
directive|endif
block|{
specifier|register
name|unsigned32
operator|*
name|xp
block|,
operator|*
name|yp
block|;
specifier|register
name|int
name|i
operator|=
name|y
operator|->
name|wds
block|;
name|x
operator|->
name|sign
operator|=
name|y
operator|->
name|sign
block|;
name|x
operator|->
name|wds
operator|=
name|i
block|;
for|for
control|(
name|xp
operator|=
name|x
operator|->
name|x
operator|,
name|yp
operator|=
name|y
operator|->
name|x
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|xp
operator|++
operator|=
operator|*
name|yp
operator|++
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/* Make sure b has room for at least 1<<k big digits. */
end_comment

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|Brealloc
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|k
operator|)
endif|#
directive|endif
block|{
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
name|Balloc
argument_list|(
name|k
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|b
operator|->
name|k
operator|>=
name|k
condition|)
return|return
name|b
return|;
else|else
block|{
name|Bigint
modifier|*
name|rv
init|=
name|Balloc
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|Bcopy
argument_list|(
name|rv
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_if

begin_comment
unit|}
comment|/* Return b*m+a.  b is modified.    Assumption:  0xFFFF*m+a fits in 32 bits. */
end_comment

begin_decl_stmt
unit|static
name|Bigint
modifier|*
name|multadd
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|m
argument_list|,
name|a
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m
decl_stmt|,
name|a
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|m
operator|,
name|int
name|a
operator|)
endif|#
directive|endif
block|{
name|int
name|i
block|,
name|wds
block|;
name|unsigned32
operator|*
name|x
block|,
name|y
block|;
name|unsigned32
name|xi
block|,
name|z
block|;
name|wds
operator|=
name|b
operator|->
name|wds
block|;
name|x
operator|=
name|b
operator|->
name|x
block|;
name|i
operator|=
literal|0
block|;
do|do
block|{
name|xi
operator|=
operator|*
name|x
expr_stmt|;
name|y
operator|=
operator|(
name|xi
operator|&
literal|0xffff
operator|)
operator|*
name|m
operator|+
name|a
expr_stmt|;
name|z
operator|=
operator|(
name|xi
operator|>>
literal|16
operator|)
operator|*
name|m
operator|+
operator|(
name|y
operator|>>
literal|16
operator|)
expr_stmt|;
name|a
operator|=
call|(
name|int
call|)
argument_list|(
name|z
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|x
operator|++
operator|=
operator|(
name|z
operator|<<
literal|16
operator|)
operator|+
operator|(
name|y
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|i
operator|<
name|wds
condition|)
empty_stmt|;
end_while

begin_if
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|wds
operator|>=
name|b
operator|->
name|maxwds
condition|)
name|b
operator|=
name|Brealloc
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|x
index|[
name|wds
operator|++
index|]
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|wds
expr_stmt|;
block|}
end_if

begin_return
return|return
name|b
return|;
end_return

begin_decl_stmt
unit|}  static
name|Bigint
modifier|*
name|s2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y9
argument_list|)
name|Bigint
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nd0
decl_stmt|,
name|nd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned32
name|y9
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|result
operator|,
name|CONST
name|char
operator|*
name|s
operator|,
name|int
name|nd0
operator|,
name|int
name|nd
operator|,
name|unsigned32
name|y9
operator|)
endif|#
directive|endif
block|{
name|int
name|i
block|,
name|k
block|;
name|long
name|x
block|,
name|y
block|;
name|x
operator|=
operator|(
name|nd
operator|+
literal|8
operator|)
operator|/
literal|9
block|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|y
operator|=
literal|1
init|;
name|x
operator|>
name|y
condition|;
name|y
operator|<<=
literal|1
operator|,
name|k
operator|++
control|)
empty_stmt|;
name|result
operator|=
name|Brealloc
argument_list|(
name|result
argument_list|,
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
literal|9
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|9
operator|<
name|nd0
condition|)
block|{
name|s
operator|+=
literal|9
expr_stmt|;
do|do
name|result
operator|=
name|multadd
argument_list|(
name|result
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
name|nd0
condition|)
do|;
name|s
operator|++
expr_stmt|;
block|}
else|else
name|s
operator|+=
literal|10
expr_stmt|;
end_if

begin_for
for|for
control|(
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|multadd
argument_list|(
name|result
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|result
return|;
end_return

begin_decl_stmt
unit|}  static
name|int
name|hi0bits
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|x
argument_list|)
decl|register
name|unsigned32
name|x
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
specifier|register
name|unsigned32
name|x
operator|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|k
operator|=
literal|0
block|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
condition|)
block|{
name|k
operator|=
literal|16
expr_stmt|;
name|x
operator|<<=
literal|16
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|8
expr_stmt|;
name|x
operator|<<=
literal|8
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|4
expr_stmt|;
name|x
operator|<<=
literal|4
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
name|x
operator|<<=
literal|2
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x40000000
operator|)
condition|)
return|return
literal|32
return|;
block|}
end_if

begin_return
return|return
name|k
return|;
end_return

begin_decl_stmt
unit|}  static
name|int
name|lo0bits
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|y
argument_list|)
name|unsigned32
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|unsigned32
operator|*
name|y
operator|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|k
block|;
specifier|register
name|unsigned32
name|x
operator|=
operator|*
name|y
block|;
if|if
condition|(
name|x
operator|&
literal|7
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|&
literal|2
condition|)
block|{
operator|*
name|y
operator|=
name|x
operator|>>
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|y
operator|=
name|x
operator|>>
literal|2
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|2
return|;
end_return

begin_expr_stmt
unit|}         k
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|k
operator|=
literal|16
expr_stmt|;
name|x
operator|>>=
literal|16
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xff
operator|)
condition|)
block|{
name|k
operator|+=
literal|8
expr_stmt|;
name|x
operator|>>=
literal|8
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xf
operator|)
condition|)
block|{
name|k
operator|+=
literal|4
expr_stmt|;
name|x
operator|>>=
literal|4
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x3
operator|)
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
name|x
operator|>>=
literal|2
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|1
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|&
literal|1
condition|)
return|return
literal|32
return|;
block|}
end_if

begin_expr_stmt
operator|*
name|y
operator|=
name|x
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|k
return|;
end_return

begin_decl_stmt
unit|}  static
name|Bigint
modifier|*
name|i2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|result
argument_list|,
name|i
argument_list|)
name|Bigint
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|result
operator|,
name|int
name|i
operator|)
endif|#
directive|endif
block|{
name|result
operator|=
name|Brealloc
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
block|;
name|result
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|i
block|;
name|result
operator|->
name|wds
operator|=
literal|1
block|;
return|return
name|result
return|;
block|}
end_expr_stmt

begin_comment
comment|/* Do: c = a * b. */
end_comment

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|mult
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|c
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|c
operator|,
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|int
name|k
block|,
name|wa
block|,
name|wb
block|,
name|wc
block|;
name|unsigned32
name|carry
block|,
name|y
block|,
name|z
block|;
name|unsigned32
operator|*
name|x
block|,
operator|*
name|xa
block|,
operator|*
name|xae
block|,
operator|*
name|xb
block|,
operator|*
name|xbe
block|,
operator|*
name|xc
block|,
operator|*
name|xc0
block|;
name|unsigned32
name|z2
block|;
if|if
condition|(
name|a
operator|->
name|wds
operator|<
name|b
operator|->
name|wds
condition|)
block|{
name|Bigint
modifier|*
name|tmp
init|=
name|a
decl_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|tmp
expr_stmt|;
block|}
name|k
operator|=
name|a
operator|->
name|k
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wa
operator|=
name|a
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wb
operator|=
name|b
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wc
operator|=
name|wa
operator|+
name|wb
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|wc
operator|>
name|a
operator|->
name|maxwds
condition|)
name|k
operator|++
expr_stmt|;
end_if

begin_expr_stmt
name|c
operator|=
name|Brealloc
argument_list|(
name|c
argument_list|,
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|x
operator|=
name|c
operator|->
name|x
operator|,
name|xa
operator|=
name|x
operator|+
name|wc
init|;
name|x
operator|<
name|xa
condition|;
name|x
operator|++
control|)
operator|*
name|x
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|xa
operator|=
name|a
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xae
operator|=
name|xa
operator|+
name|wa
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xbe
operator|=
name|xb
operator|+
name|wb
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xc0
operator|=
name|c
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|xb
operator|<
name|xbe
condition|;
name|xb
operator|++
operator|,
name|xc0
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|=
operator|*
name|xb
operator|&
literal|0xffff
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|(
operator|*
name|x
operator|&
literal|0xffff
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|z2
operator|=
operator|(
operator|*
name|x
operator|++
operator|>>
literal|16
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|>>
literal|16
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z2
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z2
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|carry
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|=
operator|*
name|xb
operator|>>
literal|16
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|z2
operator|=
operator|*
name|xc
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|(
operator|*
name|x
operator|&
literal|0xffff
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|>>
literal|16
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|z2
operator|=
operator|(
operator|*
name|x
operator|++
operator|>>
literal|16
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z2
operator|>>
literal|16
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|z2
expr_stmt|;
block|}
block|}
end_for

begin_for
for|for
control|(
name|xc0
operator|=
name|c
operator|->
name|x
operator|,
name|xc
operator|=
name|xc0
operator|+
name|wc
init|;
name|wc
operator|>
literal|0
operator|&&
operator|!
operator|*
operator|--
name|xc
condition|;
operator|--
name|wc
control|)
empty_stmt|;
end_for

begin_expr_stmt
name|c
operator|->
name|wds
operator|=
name|wc
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|c
return|;
end_return

begin_comment
unit|}
comment|/* Returns b*(5**k).  b is modified. */
end_comment

begin_comment
comment|/* Re-written by Per Bothner to not need a static list. */
end_comment

begin_decl_stmt
unit|static
name|Bigint
modifier|*
name|pow5mult
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|k
operator|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|p05
index|[
literal|6
index|]
operator|=
block|{
literal|5
block|,
literal|25
block|,
literal|125
block|,
literal|625
block|,
literal|3125
block|,
literal|15625
block|}
block|;
for|for
control|(
init|;
name|k
operator|>
literal|6
condition|;
name|k
operator|-=
literal|6
control|)
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|15625
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* b *= 5**6 */
end_comment

begin_if
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|b
return|;
else|else
return|return
name|multadd
argument_list|(
name|b
argument_list|,
name|p05
index|[
name|k
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
return|;
end_if

begin_comment
unit|}
comment|/* Re-written by Per Bothner so shift can be in place. */
end_comment

begin_decl_stmt
unit|static
name|Bigint
modifier|*
name|lshift
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|k
operator|)
endif|#
directive|endif
block|{
name|int
name|i
block|;
name|unsigned32
operator|*
name|x
block|,
operator|*
name|x1
block|,
operator|*
name|xe
block|;
name|int
name|old_wds
operator|=
name|b
operator|->
name|wds
block|;
name|int
name|n
operator|=
name|k
operator|>>
literal|5
block|;
name|int
name|k1
operator|=
name|b
operator|->
name|k
block|;
name|int
name|n1
operator|=
name|n
operator|+
name|old_wds
operator|+
literal|1
block|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|b
return|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
name|b
operator|->
name|maxwds
init|;
name|n1
operator|>
name|i
condition|;
name|i
operator|<<=
literal|1
control|)
name|k1
operator|++
expr_stmt|;
end_for

begin_expr_stmt
name|b
operator|=
name|Brealloc
argument_list|(
name|b
argument_list|,
name|k1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xe
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Source limit */
end_comment

begin_expr_stmt
name|x
operator|=
name|xe
operator|+
name|old_wds
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Source pointer */
end_comment

begin_expr_stmt
name|x1
operator|=
name|x
operator|+
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Destination pointer */
end_comment

begin_if
if|if
condition|(
name|k
operator|&=
literal|0x1f
condition|)
block|{
name|int
name|k1
init|=
literal|32
operator|-
name|k
decl_stmt|;
name|unsigned32
name|z
init|=
operator|*
operator|--
name|x
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|x1
operator|=
operator|(
name|z
operator|>>
name|k1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|n1
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|>
name|xe
condition|)
block|{
name|unsigned32
name|w
init|=
operator|*
operator|--
name|x
decl_stmt|;
operator|*
operator|--
name|x1
operator|=
operator|(
name|z
operator|<<
name|k
operator|)
operator||
operator|(
name|w
operator|>>
name|k1
operator|)
expr_stmt|;
name|z
operator|=
name|w
expr_stmt|;
block|}
operator|*
operator|--
name|x1
operator|=
name|z
operator|<<
name|k
expr_stmt|;
block|}
else|else
do|do
block|{
operator|*
operator|--
name|x1
operator|=
operator|*
operator|--
name|x
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
name|xe
condition|)
do|;
end_if

begin_while
while|while
condition|(
name|x1
operator|>
name|xe
condition|)
operator|*
operator|--
name|x1
operator|=
literal|0
expr_stmt|;
end_while

begin_expr_stmt
name|b
operator|->
name|wds
operator|=
name|n1
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|b
return|;
end_return

begin_decl_stmt
unit|}  static
name|int
name|cmp
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|unsigned32
operator|*
name|xa
block|,
operator|*
name|xa0
block|,
operator|*
name|xb
block|,
operator|*
name|xb0
block|;
name|int
name|i
block|,
name|j
block|;
name|i
operator|=
name|a
operator|->
name|wds
block|;
name|j
operator|=
name|b
operator|->
name|wds
block|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
operator|!
name|a
operator|->
name|x
index|[
name|i
operator|-
literal|1
index|]
condition|)
name|Bug
argument_list|(
literal|"cmp called with a->x[a->wds-1] == 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>
literal|1
operator|&&
operator|!
name|b
operator|->
name|x
index|[
name|j
operator|-
literal|1
index|]
condition|)
name|Bug
argument_list|(
literal|"cmp called with b->x[b->wds-1] == 0"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|i
operator|-=
name|j
condition|)
return|return
name|i
return|;
end_if

begin_expr_stmt
name|xa0
operator|=
name|a
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xa
operator|=
name|xa0
operator|+
name|j
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb0
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb
operator|=
name|xb0
operator|+
name|j
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|--
name|xa
operator|!=
operator|*
operator|--
name|xb
condition|)
return|return
operator|*
name|xa
operator|<
operator|*
name|xb
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
name|xa
operator|<=
name|xa0
condition|)
break|break;
block|}
end_for

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/* Do: c = a-b. */
end_comment

begin_decl_stmt
unit|static
name|Bigint
modifier|*
name|diff
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|c
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|c
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|c
operator|,
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|int
name|i
block|,
name|wa
block|,
name|wb
block|;
name|long
name|borrow
block|,
name|y
block|;
comment|/* We need signed shifts here. */
name|unsigned32
operator|*
name|xa
block|,
operator|*
name|xae
block|,
operator|*
name|xb
block|,
operator|*
name|xbe
block|,
operator|*
name|xc
block|;
name|long
name|z
block|;
name|i
operator|=
name|cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
block|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|c
operator|=
name|Brealloc
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|Bigint
modifier|*
name|tmp
init|=
name|a
decl_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|tmp
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|c
operator|=
name|Brealloc
argument_list|(
name|c
argument_list|,
name|a
operator|->
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|c
operator|->
name|sign
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wa
operator|=
name|a
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xa
operator|=
name|a
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xae
operator|=
name|xa
operator|+
name|wa
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wb
operator|=
name|b
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xbe
operator|=
name|xb
operator|+
name|wb
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xc
operator|=
name|c
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|borrow
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
name|y
operator|=
operator|(
operator|*
name|xa
operator|&
literal|0xffff
operator|)
operator|-
operator|(
operator|*
name|xb
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|xa
operator|++
operator|>>
literal|16
operator|)
operator|-
operator|(
operator|*
name|xb
operator|++
operator|>>
literal|16
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|xb
operator|<
name|xbe
condition|)
do|;
end_do

begin_while
while|while
condition|(
name|xa
operator|<
name|xae
condition|)
block|{
name|y
operator|=
operator|(
operator|*
name|xa
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|xa
operator|++
operator|>>
literal|16
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_while

begin_while
while|while
condition|(
operator|!
operator|*
operator|--
name|xc
condition|)
name|wa
operator|--
expr_stmt|;
end_while

begin_expr_stmt
name|c
operator|->
name|wds
operator|=
name|wa
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|c
return|;
end_return

begin_decl_stmt
unit|}  static
name|double
name|ulp
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|x
argument_list|)
name|double
name|x
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|x
operator|)
endif|#
directive|endif
block|{
specifier|register
name|long
name|L
block|;
name|double
name|a
block|;
name|L
operator|=
operator|(
name|word0
argument_list|(
name|x
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
block|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|L
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
name|L
operator||=
name|Exp_msk1
operator|>>
literal|4
expr_stmt|;
endif|#
directive|endif
name|word0
argument_list|(
name|a
argument_list|)
operator|=
name|L
expr_stmt|;
name|word1
argument_list|(
name|a
argument_list|)
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
block|}
end_expr_stmt

begin_else
else|else
block|{
name|L
operator|=
operator|-
name|L
operator|>>
name|Exp_shift
expr_stmt|;
if|if
condition|(
name|L
operator|<
name|Exp_shift
condition|)
block|{
name|word0
argument_list|(
name|a
argument_list|)
operator|=
literal|0x80000
operator|>>
name|L
expr_stmt|;
name|word1
argument_list|(
name|a
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|word0
argument_list|(
name|a
argument_list|)
operator|=
literal|0
expr_stmt|;
name|L
operator|-=
name|Exp_shift
expr_stmt|;
name|word1
argument_list|(
name|a
argument_list|)
operator|=
name|L
operator|>=
literal|31
condition|?
literal|1
else|:
literal|1
operator|<<
literal|31
operator|-
name|L
expr_stmt|;
block|}
block|}
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|a
return|;
end_return

begin_decl_stmt
unit|}  static
name|double
name|b2d
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|e
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|int
operator|*
name|e
operator|)
endif|#
directive|endif
block|{
name|unsigned32
operator|*
name|xa
block|,
operator|*
name|xa0
block|,
name|w
block|,
name|y
block|,
name|z
block|;
name|int
name|k
block|;
name|double
name|d
block|;
ifdef|#
directive|ifdef
name|VAX
name|unsigned32
name|d0
block|,
name|d1
block|;
else|#
directive|else
define|#
directive|define
name|d0
value|word0(d)
define|#
directive|define
name|d1
value|word1(d)
endif|#
directive|endif
name|xa0
operator|=
name|a
operator|->
name|x
block|;
name|xa
operator|=
name|xa0
operator|+
name|a
operator|->
name|wds
block|;
name|y
operator|=
operator|*
operator|--
name|xa
block|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|y
condition|)
name|Bug
argument_list|(
literal|"zero y in b2d"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|hi0bits
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|e
operator|=
literal|32
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|<
name|Ebits
condition|)
block|{
name|d0
operator|=
name|Exp_1
operator||
name|y
operator|>>
name|Ebits
operator|-
name|k
expr_stmt|;
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|d1
operator|=
name|y
operator|<<
operator|(
literal|32
operator|-
name|Ebits
operator|)
operator|+
name|k
operator||
name|w
operator|>>
name|Ebits
operator|-
name|k
expr_stmt|;
goto|goto
name|ret_d
goto|;
block|}
end_if

begin_expr_stmt
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|-=
name|Ebits
condition|)
block|{
name|d0
operator|=
name|Exp_1
operator||
name|y
operator|<<
name|k
operator||
name|z
operator|>>
literal|32
operator|-
name|k
expr_stmt|;
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|d1
operator|=
name|z
operator|<<
name|k
operator||
name|y
operator|>>
literal|32
operator|-
name|k
expr_stmt|;
block|}
else|else
block|{
name|d0
operator|=
name|Exp_1
operator||
name|y
expr_stmt|;
name|d1
operator|=
name|z
expr_stmt|;
block|}
end_if

begin_label
name|ret_d
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_expr_stmt
name|word0
argument_list|(
name|d
argument_list|)
operator|=
name|d0
operator|>>
literal|16
operator||
name|d0
operator|<<
literal|16
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|word1
argument_list|(
name|d
argument_list|)
operator|=
name|d1
operator|>>
literal|16
operator||
name|d1
operator|<<
literal|16
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|d0
end_undef

begin_undef
undef|#
directive|undef
name|d1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|d
return|;
end_return

begin_decl_stmt
unit|}  static
name|Bigint
modifier|*
name|d2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|result
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|bits
argument_list|)
name|Bigint
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|e
decl_stmt|,
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|result
operator|,
name|double
name|d
operator|,
name|int
operator|*
name|e
operator|,
name|int
operator|*
name|bits
operator|)
endif|#
directive|endif
block|{
name|int
name|de
block|,
name|i
block|,
name|k
block|;
name|unsigned32
operator|*
name|x
block|,
name|y
block|,
name|z
block|;
ifdef|#
directive|ifdef
name|VAX
name|unsigned32
name|d0
block|,
name|d1
block|;
name|d0
operator|=
name|word0
argument_list|(
name|d
argument_list|)
operator|>>
literal|16
operator||
name|word0
argument_list|(
name|d
argument_list|)
operator|<<
literal|16
block|;
name|d1
operator|=
name|word1
argument_list|(
name|d
argument_list|)
operator|>>
literal|16
operator||
name|word1
argument_list|(
name|d
argument_list|)
operator|<<
literal|16
block|;
else|#
directive|else
define|#
directive|define
name|d0
value|word0(d)
define|#
directive|define
name|d1
value|word1(d)
endif|#
directive|endif
name|result
operator|=
name|Brealloc
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
block|;
name|x
operator|=
name|result
operator|->
name|x
block|;
name|z
operator|=
name|d0
operator|&
name|Frac_mask
block|;
name|d0
operator|&=
literal|0x7fffffff
block|;
comment|/* clear sign bit, which we ignore */
name|de
operator|=
call|(
name|int
call|)
argument_list|(
name|d0
operator|>>
name|Exp_shift
argument_list|)
block|;
comment|/* The exponent part of d. */
comment|/* Put back the suppressed high-order bit, if normalized. */
ifndef|#
directive|ifndef
name|IBM
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|de
condition|)
endif|#
directive|endif
name|z
operator||=
name|Exp_msk11
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|y
operator|=
name|d1
condition|)
block|{
if|if
condition|(
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|y
argument_list|)
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator||
name|z
operator|<<
literal|32
operator|-
name|k
expr_stmt|;
name|z
operator|>>=
name|k
expr_stmt|;
block|}
else|else
name|x
index|[
literal|0
index|]
operator|=
name|y
expr_stmt|;
name|i
operator|=
name|result
operator|->
name|wds
operator|=
operator|(
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|z
condition|)
name|Bug
argument_list|(
literal|"Zero passed to d2b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
name|i
operator|=
name|result
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|k
operator|+=
literal|32
expr_stmt|;
block|}
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|Sudden_Underflow
end_ifndef

begin_if
if|if
condition|(
name|de
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
operator|*
name|e
operator|=
operator|(
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
literal|4
operator|*
name|P
operator|+
literal|8
operator|-
name|k
operator|-
name|hi0bits
argument_list|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Frac_mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|e
operator|=
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
name|P
operator|-
name|k
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
block|}
else|else
block|{
operator|*
name|e
operator|=
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|+
literal|1
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
literal|32
operator|*
name|i
operator|-
name|hi0bits
argument_list|(
name|x
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|result
return|;
end_return

begin_undef
unit|}
undef|#
directive|undef
name|d0
end_undef

begin_undef
undef|#
directive|undef
name|d1
end_undef

begin_decl_stmt
unit|static
name|double
name|ratio
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|double
name|da
block|,
name|db
block|;
name|int
name|k
block|,
name|ka
block|,
name|kb
block|;
name|da
operator|=
name|b2d
argument_list|(
name|a
argument_list|,
operator|&
name|ka
argument_list|)
block|;
name|db
operator|=
name|b2d
argument_list|(
name|b
argument_list|,
operator|&
name|kb
argument_list|)
block|;
name|k
operator|=
name|ka
operator|-
name|kb
operator|+
literal|32
operator|*
operator|(
name|a
operator|->
name|wds
operator|-
name|b
operator|->
name|wds
operator|)
block|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|word0
argument_list|(
name|da
argument_list|)
operator|+=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|da
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|word0
argument_list|(
name|db
argument_list|)
operator|+=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|db
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
end_else

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|word0
argument_list|(
name|da
argument_list|)
operator|+=
name|k
operator|*
name|Exp_msk1
expr_stmt|;
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|word0
argument_list|(
name|db
argument_list|)
operator|+=
name|k
operator|*
name|Exp_msk1
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|da
operator|/
name|db
return|;
end_return

begin_decl_stmt
unit|}  static
name|double
name|tens
index|[]
init|=
block|{
literal|1e0
block|,
literal|1e1
block|,
literal|1e2
block|,
literal|1e3
block|,
literal|1e4
block|,
literal|1e5
block|,
literal|1e6
block|,
literal|1e7
block|,
literal|1e8
block|,
literal|1e9
block|,
literal|1e10
block|,
literal|1e11
block|,
literal|1e12
block|,
literal|1e13
block|,
literal|1e14
block|,
literal|1e15
block|,
literal|1e16
block|,
literal|1e17
block|,
literal|1e18
block|,
literal|1e19
block|,
literal|1e20
block|,
literal|1e21
block|,
literal|1e22
ifdef|#
directive|ifdef
name|VAX
block|,
literal|1e23
block|,
literal|1e24
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
ifdef|#
directive|ifdef
name|IEEE_Arith
name|bigtens
index|[]
init|=
block|{
literal|1e16
block|,
literal|1e32
block|,
literal|1e64
block|,
literal|1e128
block|,
literal|1e256
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|,
literal|1e-128
block|,
literal|1e-256
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|n_bigtens
value|5
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_expr_stmt
name|bigtens
index|[]
operator|=
block|{
literal|1e16
block|,
literal|1e32
block|,
literal|1e64
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|n_bigtens
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|bigtens
index|[]
operator|=
block|{
literal|1e16
block|,
literal|1e32
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|n_bigtens
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|double
name|_IO_strtod
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|s00
argument_list|,
name|se
argument_list|)
name|CONST
name|char
modifier|*
name|s00
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|se
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s00
operator|,
name|char
operator|*
operator|*
name|se
operator|)
endif|#
directive|endif
block|{
name|int
name|bb2
block|,
name|bb5
block|,
name|bbe
block|,
name|bd2
block|,
name|bd5
block|,
name|bbbits
block|,
name|bs2
block|,
name|c
block|,
name|dsign
block|,
name|e
block|,
name|e1
block|,
name|esign
block|,
name|i
block|,
name|j
block|,
name|k
block|,
name|nd
block|,
name|nd0
block|,
name|nf
block|,
name|nz
block|,
name|nz0
block|,
name|sign
block|;
name|CONST
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|,
operator|*
name|s1
block|;
name|double
name|aadj
block|,
name|aadj1
block|,
name|adj
block|,
name|rv
block|,
name|rv0
block|;
name|long
name|L
block|;
name|unsigned32
name|y
block|,
name|z
block|;
name|Bigint
name|_bb
block|,
name|_b_avail
block|,
name|_bd
block|,
name|_bd0
block|,
name|_bs
block|,
name|_delta
block|;
name|Bigint
operator|*
name|bb
operator|=
name|Binit
argument_list|(
operator|&
name|_bb
argument_list|)
block|;
name|Bigint
operator|*
name|bd
operator|=
name|Binit
argument_list|(
operator|&
name|_bd
argument_list|)
block|;
name|Bigint
operator|*
name|bd0
operator|=
name|Binit
argument_list|(
operator|&
name|_bd0
argument_list|)
block|;
name|Bigint
operator|*
name|bs
operator|=
name|Binit
argument_list|(
operator|&
name|_bs
argument_list|)
block|;
name|Bigint
operator|*
name|b_avail
operator|=
name|Binit
argument_list|(
operator|&
name|_b_avail
argument_list|)
block|;
name|Bigint
operator|*
name|delta
operator|=
name|Binit
argument_list|(
operator|&
name|_delta
argument_list|)
block|;
name|TEST_ENDIANNESS
block|;
name|sign
operator|=
name|nz0
operator|=
name|nz
operator|=
literal|0
block|;
name|rv
operator|=
literal|0.
block|;
for|for
control|(
name|s
operator|=
name|s00
init|;
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
operator|++
name|s
condition|)
goto|goto
name|break2
goto|;
comment|/* no break */
case|case
literal|0
case|:
comment|/* "+" and "-" should be reported as an error? */
name|sign
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
continue|continue;
default|default:
goto|goto
name|break2
goto|;
block|}
name|break2
operator|:
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
name|nz0
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|s0
operator|=
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|nd
operator|=
name|nf
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|nd
operator|++
operator|,
name|s
operator|++
control|)
if|if
condition|(
name|nd
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<
literal|16
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
end_for

begin_expr_stmt
name|nd0
operator|=
name|nd
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
for|for
control|(
init|;
name|c
operator|==
literal|'0'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|nf
operator|+=
name|nz
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_dig
goto|;
block|}
goto|goto
name|dig_done
goto|;
block|}
for|for
control|(
init|;
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
block|{
name|have_dig
label|:
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|-=
literal|'0'
condition|)
block|{
name|nf
operator|+=
name|nz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|*=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_if

begin_label
name|dig_done
label|:
end_label

begin_expr_stmt
name|e
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|&&
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|s00
operator|=
name|s
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|e
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|e
operator|=
literal|10
operator|*
name|e
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|s1
operator|>
literal|8
condition|)
comment|/* Avoid confusion from exponents                                          * so large that e might overflow.                                          */
name|e
operator|=
literal|9999999
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|s00
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|e1
operator|=
name|e
operator|-=
name|nf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now we have nd0 digits, starting at s0, followed by a          * decimal point, followed by nd-nd0 digits.  The number we're          * after is the integer represented by those digits times          * 10**e */
end_comment

begin_if
if|if
condition|(
operator|!
name|nd0
condition|)
name|nd0
operator|=
name|nd
expr_stmt|;
end_if

begin_expr_stmt
name|k
operator|=
name|nd
operator|<
name|DBL_DIG
operator|+
literal|1
condition|?
name|nd
else|:
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>
literal|9
condition|)
name|rv
operator|=
name|tens
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|rv
operator|+
name|z
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
ifndef|#
directive|ifndef
name|RND_PRODQUOT
operator|&&
name|FLT_ROUNDS
operator|==
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|e
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
goto|goto
name|vax_ovfl_check
goto|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
endif|#
directive|endif
block|}
name|i
operator|=
name|DBL_DIG
operator|-
name|nd
expr_stmt|;
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
operator|+
name|i
condition|)
block|{
comment|/* A fancier test would sometimes let us do                                  * this for larger i values.                                  */
name|e
operator|-=
name|i
expr_stmt|;
name|rv
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX exponent range is so narrow we must                                  * worry about overflow here...                                  */
name|vax_ovfl_check
label|:
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
ifndef|#
directive|ifndef
name|Inaccurate_Divide
elseif|else
if|if
condition|(
name|e
operator|>=
operator|-
name|Ten_pmax
condition|)
block|{
comment|/* rv = */
name|rounded_quotient
argument_list|(
name|rv
argument_list|,
name|tens
index|[
operator|-
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
block|}
end_if

begin_expr_stmt
name|e1
operator|+=
name|nd
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Get starting approximation = rv * 10**e1 */
end_comment

begin_if
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|e1
operator|&
literal|15
condition|)
name|rv
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|DBL_MAX_10_EXP
condition|)
block|{
name|ovfl
label|:
name|errno
operator|=
name|ERANGE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
comment|/* SunOS defines HUGE_VAL as __infinity(), which is in libm. */
undef|#
directive|undef
name|HUGE_VAL
endif|#
directive|endif
ifndef|#
directive|ifndef
name|HUGE_VAL
define|#
directive|define
name|HUGE_VAL
value|1.7976931348623157E+308
endif|#
directive|endif
name|rv
operator|=
name|HUGE_VAL
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|e1
operator|>>=
literal|4
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|rv
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could overflow. */
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|rv
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
if|if
condition|(
name|z
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
block|{
comment|/* set to largest number */
comment|/* (Can't trust DBL_MAX) */
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|e1
operator|&
literal|15
condition|)
name|rv
operator|/=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
name|e1
operator|>>=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could underflow. */
name|rv0
operator|=
name|rv
expr_stmt|;
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
name|rv
operator|=
literal|2.
operator|*
name|rv0
expr_stmt|;
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
name|undfl
label|:
name|rv
operator|=
literal|0.
expr_stmt|;
name|errno
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
comment|/* The refinement below will clean                                  * this approximation up.                                  */
block|}
block|}
block|}
end_if

begin_comment
comment|/* Now the hard part -- adjusting rv to the correct value.*/
end_comment

begin_comment
comment|/* Put digits into bd: true value = bd * 10^e */
end_comment

begin_expr_stmt
name|bd0
operator|=
name|s2b
argument_list|(
name|bd0
argument_list|,
name|s0
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bd
operator|=
name|Brealloc
argument_list|(
name|bd
argument_list|,
name|bd0
operator|->
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|Bcopy
argument_list|(
name|bd
argument_list|,
name|bd0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|d2b
argument_list|(
name|bb
argument_list|,
name|rv
argument_list|,
operator|&
name|bbe
argument_list|,
operator|&
name|bbbits
argument_list|)
expr_stmt|;
comment|/* rv = bb * 2^bbe */
name|bs
operator|=
name|i2b
argument_list|(
name|bs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
condition|)
block|{
name|bb2
operator|=
name|bb5
operator|=
literal|0
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|bb2
operator|=
name|bb5
operator|=
operator|-
name|e
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bbe
operator|>=
literal|0
condition|)
name|bb2
operator|+=
name|bbe
expr_stmt|;
else|else
name|bd2
operator|-=
name|bbe
expr_stmt|;
name|bs2
operator|=
name|bb2
expr_stmt|;
ifdef|#
directive|ifdef
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
name|j
operator|=
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbbits
operator|+
operator|(
operator|(
name|bbe
operator|+
name|bbbits
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|i
operator|=
name|bbe
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(rv) */
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
comment|/* denormal */
name|j
operator|=
name|bbe
operator|+
operator|(
name|P
operator|-
name|Emin
operator|)
expr_stmt|;
else|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
name|bb2
operator|+=
name|j
expr_stmt|;
name|bd2
operator|+=
name|j
expr_stmt|;
name|i
operator|=
name|bb2
operator|<
name|bd2
condition|?
name|bb2
else|:
name|bd2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bs2
condition|)
name|i
operator|=
name|bs2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bb2
operator|-=
name|i
expr_stmt|;
name|bd2
operator|-=
name|i
expr_stmt|;
name|bs2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bb5
operator|>
literal|0
condition|)
block|{
name|Bigint
modifier|*
name|b_tmp
decl_stmt|;
name|bs
operator|=
name|pow5mult
argument_list|(
name|bs
argument_list|,
name|bb5
argument_list|)
expr_stmt|;
name|b_tmp
operator|=
name|mult
argument_list|(
name|b_avail
argument_list|,
name|bs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|b_avail
operator|=
name|bb
expr_stmt|;
name|bb
operator|=
name|b_tmp
expr_stmt|;
block|}
if|if
condition|(
name|bb2
operator|>
literal|0
condition|)
name|bb
operator|=
name|lshift
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd5
operator|>
literal|0
condition|)
name|bd
operator|=
name|pow5mult
argument_list|(
name|bd
argument_list|,
name|bd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd2
operator|>
literal|0
condition|)
name|bd
operator|=
name|lshift
argument_list|(
name|bd
argument_list|,
name|bd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs2
operator|>
literal|0
condition|)
name|bs
operator|=
name|lshift
argument_list|(
name|bs
argument_list|,
name|bs2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|delta
argument_list|,
name|bb
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|dsign
operator|=
name|delta
operator|->
name|sign
expr_stmt|;
name|delta
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than half an ulp -- check for                          * special case of mantissa a power of two.                          */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
break|break;
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|drop_down
goto|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* exactly half-way between */
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask1
operator|)
operator|==
name|Bndry_mask1
operator|&&
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
comment|/*boundary case -- increment exponent*/
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|+
name|Exp_msk1
ifdef|#
directive|ifdef
name|IBM
operator||
name|Exp_msk1
operator|>>
literal|4
endif|#
directive|endif
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
operator|)
operator|&&
operator|!
name|word1
argument_list|(
name|rv
argument_list|)
condition|)
block|{
name|drop_down
label|:
comment|/* boundary case -- decrement exponent */
ifdef|#
directive|ifdef
name|Sudden_Underflow
name|L
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|L
operator|<
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
name|L
operator|<=
name|Exp_msk1
condition|)
endif|#
directive|endif
goto|goto
name|undfl
goto|;
name|L
operator|-=
name|Exp_msk1
expr_stmt|;
else|#
directive|else
name|L
operator|=
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|L
operator||
name|Bndry_mask1
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0xffffffff
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
continue|continue;
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
operator|!
operator|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|&
name|LSB
operator|)
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|dsign
condition|)
name|rv
operator|+=
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
else|else
block|{
name|rv
operator|-=
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
operator|!
name|rv
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
block|}
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|(
name|aadj
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|)
operator|<=
literal|2.
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
name|aadj
operator|=
name|aadj1
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
name|Tiny1
operator|&&
operator|!
name|word0
argument_list|(
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
name|aadj
operator|=
literal|1.
expr_stmt|;
name|aadj1
operator|=
operator|-
literal|1.
expr_stmt|;
block|}
else|else
block|{
comment|/* special case -- power of FLT_RADIX to be */
comment|/* rounded down... */
if|if
condition|(
name|aadj
operator|<
literal|2.
operator|/
name|FLT_RADIX
condition|)
name|aadj
operator|=
literal|1.
operator|/
name|FLT_RADIX
expr_stmt|;
else|else
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
operator|-
name|aadj
expr_stmt|;
block|}
block|}
else|else
block|{
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
switch|switch
condition|(
name|FLT_ROUNDS
condition|)
block|{
case|case
literal|2
case|:
comment|/* towards +infinity */
name|aadj1
operator|-=
literal|0.5
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* towards 0 */
case|case
literal|3
case|:
comment|/* towards -infinity */
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|FLT_ROUNDS
operator|==
literal|0
condition|)
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
endif|#
directive|endif
block|}
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
comment|/* Check for overflow */
if|if
condition|(
name|y
operator|==
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|)
condition|)
block|{
name|rv0
operator|=
name|rv
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>=
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
block|{
if|if
condition|(
name|word0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big0
operator|&&
name|word1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
continue|continue;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|rv0
operator|=
name|rv
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|word0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny0
operator|&&
name|word1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny1
condition|)
goto|goto
name|undfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
continue|continue;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
block|}
else|#
directive|else
comment|/* Compute adj so that the IEEE rounding rules will                          * correctly round rv + adj in some half-way cases.                          * If rv * ulp(rv) is denormalized (i.e.,                          * y<= (P-1)*Exp_msk1), we must adjust aadj to avoid                          * trouble from bits lost to denormalization;                          * example: 1.2e-307 .                          */
if|if
condition|(
name|y
operator|<=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
operator|&&
name|aadj
operator|>=
literal|1.
condition|)
block|{
name|aadj1
operator|=
call|(
name|double
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
name|aadj
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsign
condition|)
name|aadj1
operator|=
operator|-
name|aadj1
expr_stmt|;
block|}
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
endif|#
directive|endif
block|}
name|z
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|z
condition|)
block|{
comment|/* Can we stop now? */
name|L
operator|=
operator|(
name|long
operator|)
name|aadj
expr_stmt|;
name|aadj
operator|-=
name|L
expr_stmt|;
comment|/* The tolerances below are conservative. */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|||
name|aadj
operator|>
literal|.5000001
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|/
name|FLT_RADIX
condition|)
break|break;
block|}
block|}
end_for

begin_expr_stmt
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|b_avail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|ret
label|:
end_label

begin_if
if|if
condition|(
name|se
condition|)
operator|*
name|se
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
end_if

begin_return
return|return
name|sign
condition|?
operator|-
name|rv
else|:
name|rv
return|;
end_return

begin_decl_stmt
unit|}  static
name|int
name|quorem
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|,
modifier|*
name|S
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|Bigint
operator|*
name|S
operator|)
endif|#
directive|endif
block|{
name|int
name|n
block|;
name|long
name|borrow
block|,
name|y
block|;
name|unsigned32
name|carry
block|,
name|q
block|,
name|ys
block|;
name|unsigned32
operator|*
name|bx
block|,
operator|*
name|bxe
block|,
operator|*
name|sx
block|,
operator|*
name|sxe
block|;
name|long
name|z
block|;
name|unsigned32
name|si
block|,
name|zs
block|;
name|n
operator|=
name|S
operator|->
name|wds
block|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*debug*/
if|if
condition|(
name|b
operator|->
name|wds
operator|>
name|n
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversize b in quorem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|b
operator|->
name|wds
operator|<
name|n
condition|)
return|return
literal|0
return|;
end_if

begin_expr_stmt
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sxe
operator|=
name|sx
operator|+
operator|--
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|q
operator|=
operator|*
name|bxe
operator|/
operator|(
operator|*
name|sxe
operator|+
literal|1
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ensure q<= true quotient */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*debug*/
end_comment

begin_if
if|if
condition|(
name|q
operator|>
literal|9
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversized quotient in quorem"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|q
condition|)
block|{
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|*
name|q
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
do|do
block|{
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|q
return|;
end_return

begin_comment
unit|}
comment|/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.  *  * Inspired by "How to Print Floating-Point Numbers Accurately" by  * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].  *  * Modifications:  *      1. Rather than iterating, we use a simple numeric overestimate  *         to determine k = floor(log10(d)).  We scale relevant  *         quantities using O(log2(k)) rather than O(k) multiplications.  *      2. For some modes> 2 (corresponding to ecvt and fcvt), we don't  *         try to generate digits strictly left to right.  Instead, we  *         compute with fewer bits and propagate the carry if necessary  *         when rounding the final digit up.  This is often faster.  *      3. Under the assumption that input will be rounded nearest,  *         mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.  *         That is, we allow equality in stopping tests when the  *         round-nearest rule will give the same floating-point value  *         as would satisfaction of the stopping test with strict  *         inequality.  *      4. We remove common factors of powers of 2 from relevant  *         quantities.  *      5. When converting floating-point integers less than 1e16,  *         we use floating-point arithmetic rather than resorting  *         to multiple-precision integers.  *      6. When asked to produce fewer than 15 digits, we first try  *         to get by with floating-point arithmetic; we resort to  *         multiple-precision integer arithmetic only if we cannot  *         guarantee that the floating-point calculation has given  *         the correctly rounded result.  For k requested digits and  *         "uniformly" distributed input, the probability is  *         something like 10^(k-15) that we must resort to the long  *         calculation.  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|_IO_dtoa
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
argument|d
argument_list|,
argument|mode
argument_list|,
argument|ndigits
argument_list|,
argument|decpt
argument_list|,
argument|sign
argument_list|,
argument|rve
argument_list|)
name|double
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|,
name|ndigits
decl_stmt|,
modifier|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rve
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|d
operator|,
name|int
name|mode
operator|,
name|int
name|ndigits
operator|,
name|int
operator|*
name|decpt
operator|,
name|int
operator|*
name|sign
operator|,
name|char
operator|*
operator|*
name|rve
operator|)
endif|#
directive|endif
block|{
comment|/*     Arguments ndigits, decpt, sign are similar to those         of ecvt and fcvt; trailing zeros are suppressed from         the returned string.  If not null, *rve is set to point         to the end of the return value.  If d is +-Infinity or NaN,         then *decpt is set to 9999.          mode:                 0 ==> shortest string that yields d when read in                         and rounded to nearest.                 1 ==> like 0, but with Steele& White stopping rule;                         e.g. with IEEE P754 arithmetic , mode 0 gives                         1e23 whereas mode 1 gives 9.999999999999999e22.                 2 ==> max(1,ndigits) significant digits.  This gives a                         return value similar to that of ecvt, except                         that trailing zeros are suppressed.                 3 ==> through ndigits past the decimal point.  This                         gives a return value similar to that from fcvt,                         except that trailing zeros are suppressed, and                         ndigits can be negative.                 4-9 should give the same return values as 2-3, i.e.,                         4<= mode<= 9 ==> same return as mode                         2 + (mode& 1).  These modes are mainly for                         debugging; often they run slower but sometimes                         faster than modes 2-3.                 4,5,8,9 ==> left-to-right digit generation.                 6-9 ==> don't try fast floating-point estimate                         (if applicable).                  Values of mode other than 0-9 are treated as mode 0.                  Sufficient space is allocated to the return value                 to hold the suppressed trailing zeros.         */
name|int
name|bbits
block|,
name|b2
block|,
name|b5
block|,
name|be
block|,
name|dig
block|,
name|i
block|,
name|ieps
block|,
name|ilim
block|,
name|ilim0
block|,
name|ilim1
block|,
name|j
block|,
name|j1
block|,
name|k
block|,
name|k0
block|,
name|k_check
block|,
name|leftright
block|,
name|m2
block|,
name|m5
block|,
name|s2
block|,
name|s5
block|,
name|spec_case
block|,
name|try_quick
block|;
name|long
name|L
block|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|int
name|denorm
block|;
endif|#
directive|endif
name|Bigint
name|_b_avail
block|,
name|_b
block|,
name|_mhi
block|,
name|_mlo
block|,
name|_S
block|;
name|Bigint
operator|*
name|b_avail
operator|=
name|Binit
argument_list|(
operator|&
name|_b_avail
argument_list|)
block|;
name|Bigint
operator|*
name|b
operator|=
name|Binit
argument_list|(
operator|&
name|_b
argument_list|)
block|;
name|Bigint
operator|*
name|S
operator|=
name|Binit
argument_list|(
operator|&
name|_S
argument_list|)
block|;
comment|/* mhi and mlo are only set and used if leftright. */
name|Bigint
operator|*
name|mhi
operator|=
name|NULL
block|,
operator|*
name|mlo
operator|=
name|NULL
block|;
name|double
name|d2
block|,
name|ds
block|,
name|eps
block|;
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|;
specifier|static
name|Bigint
operator|*
name|result
operator|=
name|NULL
block|;
specifier|static
name|int
name|result_k
block|;
name|TEST_ENDIANNESS
block|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* result is contains a string, so its fields (interpreted 		   as a Bigint have been trashed.  Restore them. 		   This is a really ugly interface - result should 		   not be static, since that is not thread-safe.  FIXME. */
name|result
operator|->
name|k
operator|=
name|result_k
expr_stmt|;
name|result
operator|->
name|maxwds
operator|=
literal|1
operator|<<
name|result_k
expr_stmt|;
name|result
operator|->
name|on_stack
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Sign_bit
condition|)
block|{
comment|/* set sign for everything, including 0's and NaNs */
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|word0
argument_list|(
name|d
argument_list|)
operator|&=
operator|~
name|Sign_bit
expr_stmt|;
comment|/* clear sign bit */
block|}
else|else
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_Arith
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_if
if|if
condition|(
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|==
name|Exp_mask
condition|)
else|#
directive|else
if|if
condition|(
name|word0
argument_list|(
name|d
argument_list|)
operator|==
literal|0x8000
condition|)
endif|#
directive|endif
block|{
comment|/* Infinity or NaN */
operator|*
name|decpt
operator|=
literal|9999
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE_Arith
if|if
condition|(
operator|!
name|word1
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
literal|0xfffff
operator|)
condition|)
block|{
name|s
operator|=
literal|"Infinity"
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
operator|+
literal|8
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|s
operator|=
literal|"NaN"
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
operator|+
literal|3
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_expr_stmt
name|d
operator|+=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* normalize */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|!
name|d
condition|)
block|{
operator|*
name|decpt
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_if

begin_expr_stmt
name|b
operator|=
name|d2b
argument_list|(
name|b
argument_list|,
name|d
argument_list|,
operator|&
name|be
argument_list|,
operator|&
name|bbits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|word0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|Sudden_Underflow
end_ifndef

begin_if
if|if
condition|(
name|i
condition|)
block|{
endif|#
directive|endif
name|d2
operator|=
name|d
expr_stmt|;
name|word0
argument_list|(
name|d2
argument_list|)
operator|&=
name|Frac_mask1
expr_stmt|;
name|word0
argument_list|(
name|d2
argument_list|)
operator||=
name|Exp_11
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|j
operator|=
literal|11
operator|-
name|hi0bits
argument_list|(
name|word0
argument_list|(
name|d2
argument_list|)
operator|&
name|Frac_mask
argument_list|)
condition|)
name|d2
operator|/=
literal|1
operator|<<
name|j
expr_stmt|;
endif|#
directive|endif
name|i
operator|-=
name|Bias
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
name|i
operator|<<=
literal|2
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* d is denormalized */
name|unsigned32
name|x
decl_stmt|;
name|i
operator|=
name|bbits
operator|+
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|i
operator|>
literal|32
condition|?
name|word0
argument_list|(
name|d
argument_list|)
operator|<<
literal|64
operator|-
name|i
operator||
name|word1
argument_list|(
name|d
argument_list|)
operator|>>
name|i
operator|-
literal|32
else|:
name|word1
argument_list|(
name|d
argument_list|)
operator|<<
literal|32
operator|-
name|i
expr_stmt|;
name|d2
operator|=
name|x
expr_stmt|;
name|word0
argument_list|(
name|d2
argument_list|)
operator|-=
literal|31
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* adjust exponent */
name|i
operator|-=
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|denorm
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Now i is the unbiased base-2 exponent. */
end_comment

begin_comment
comment|/* log(x)       ~=~ log(1.5) + (x-1.5)/1.5          * log10(x)      =  log(x) / log(10)          *              ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))          * log10(d) = i*log(2)/log(10) + log10(d2)          *          * This suggests computing an approximation k to log10(d) by          *          * k = i*0.301029995663981          *      + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );          *          * We want k to be too large rather than too small.          * The error in the first-order Taylor series approximation          * is in our favor, so we just round up the constant enough          * to compensate for any error in the multiplication of          * (i) by 0.301029995663981; since |i|<= 1077,          * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,          * adding 1e-13 to the constant term more than suffices.          * Hence we adjust the constant term to 0.1760912590558.          * (We could get a more accurate k by invoking log10,          *  but this is probably not worthwhile.)          */
end_comment

begin_expr_stmt
name|ds
operator|=
operator|(
name|d2
operator|-
literal|1.5
operator|)
operator|*
literal|0.289529654602168
operator|+
literal|0.1760912590558
operator|+
name|i
operator|*
literal|0.301029995663981
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|k
operator|=
operator|(
name|int
operator|)
name|ds
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ds
operator|<
literal|0.
operator|&&
name|ds
operator|!=
name|k
condition|)
name|k
operator|--
expr_stmt|;
end_if

begin_comment
comment|/* want k = floor(ds) */
end_comment

begin_expr_stmt
name|k_check
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Ten_pmax
condition|)
block|{
if|if
condition|(
name|d
operator|<
name|tens
index|[
name|k
index|]
condition|)
name|k
operator|--
expr_stmt|;
name|k_check
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|j
operator|=
name|bbits
operator|-
name|i
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|b2
operator|=
literal|0
expr_stmt|;
name|s2
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|=
operator|-
name|j
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
block|{
name|b5
operator|=
literal|0
expr_stmt|;
name|s5
operator|=
name|k
expr_stmt|;
name|s2
operator|+=
name|k
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|-=
name|k
expr_stmt|;
name|b5
operator|=
operator|-
name|k
expr_stmt|;
name|s5
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|9
condition|)
name|mode
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|try_quick
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|mode
operator|>
literal|5
condition|)
block|{
name|mode
operator|-=
literal|4
expr_stmt|;
name|try_quick
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|leftright
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ilim
operator|=
name|ilim1
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|18
expr_stmt|;
name|ndigits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|4
case|:
if|if
condition|(
name|ndigits
operator|<=
literal|0
condition|)
name|ndigits
operator|=
literal|1
expr_stmt|;
name|ilim
operator|=
name|ilim1
operator|=
name|i
operator|=
name|ndigits
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|5
case|:
name|i
operator|=
name|ndigits
operator|+
name|k
operator|+
literal|1
expr_stmt|;
name|ilim
operator|=
name|i
expr_stmt|;
name|ilim1
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
end_switch

begin_comment
comment|/* i is now an upper bound of the number of digits to generate. */
end_comment

begin_expr_stmt
name|j
operator|=
sizeof|sizeof
argument_list|(
name|unsigned32
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|BIGINT_MINIMUM_K
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The test is<= so as to allow room for the final '\0'. */
end_comment

begin_for
for|for
control|(
name|result_k
operator|=
name|BIGINT_MINIMUM_K
init|;
name|BIGINT_HEADER_SIZE
operator|+
name|j
operator|<=
name|i
condition|;
name|j
operator|<<=
literal|1
control|)
name|result_k
operator|++
expr_stmt|;
end_for

begin_if
if|if
condition|(
operator|!
name|result
operator|||
name|result_k
operator|>
name|result
operator|->
name|k
condition|)
block|{
name|Bfree
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|Balloc
argument_list|(
name|result_k
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|s
operator|=
name|s0
operator|=
operator|(
name|char
operator|*
operator|)
name|result
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ilim
operator|>=
literal|0
operator|&&
name|ilim
operator|<=
name|Quick_max
operator|&&
name|try_quick
condition|)
block|{
comment|/* Try to get by with floating-point arithmetic. */
name|i
operator|=
literal|0
expr_stmt|;
name|d2
operator|=
name|d
expr_stmt|;
name|k0
operator|=
name|k
expr_stmt|;
name|ilim0
operator|=
name|ilim
expr_stmt|;
name|ieps
operator|=
literal|2
expr_stmt|;
comment|/* conservative */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|ds
operator|=
name|tens
index|[
name|k
operator|&
literal|0xf
index|]
expr_stmt|;
name|j
operator|=
name|k
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|Bletch
condition|)
block|{
comment|/* prevent overflows */
name|j
operator|&=
name|Bletch
operator|-
literal|1
expr_stmt|;
name|d
operator|/=
name|bigtens
index|[
name|n_bigtens
operator|-
literal|1
index|]
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|ds
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
operator|/=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j1
operator|=
operator|-
name|k
condition|)
block|{
name|d
operator|*=
name|tens
index|[
name|j1
operator|&
literal|0xf
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|j1
operator|>>
literal|4
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|d
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k_check
operator|&&
name|d
operator|<
literal|1.
operator|&&
name|ilim
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ilim1
operator|<=
literal|0
condition|)
goto|goto
name|fast_failed
goto|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
name|k
operator|--
expr_stmt|;
name|d
operator|*=
literal|10.
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
name|eps
operator|=
name|ieps
operator|*
name|d
operator|+
literal|7.
expr_stmt|;
name|word0
argument_list|(
name|eps
argument_list|)
operator|-=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|ilim
operator|==
literal|0
condition|)
block|{
name|d
operator|-=
literal|5.
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|eps
condition|)
goto|goto
name|one_digit
goto|;
if|if
condition|(
name|d
operator|<
operator|-
name|eps
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|fast_failed
goto|;
block|}
ifndef|#
directive|ifndef
name|No_leftright
if|if
condition|(
name|leftright
condition|)
block|{
comment|/* Use Steele& White method of only                          * generating digits needed.                          */
name|eps
operator|=
literal|0.5
operator|/
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
operator|-
name|eps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|L
operator|=
operator|(
name|long
operator|)
name|d
expr_stmt|;
name|d
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|eps
condition|)
goto|goto
name|ret1
goto|;
if|if
condition|(
literal|1.
operator|-
name|d
operator|<
name|eps
condition|)
goto|goto
name|bump_up
goto|;
if|if
condition|(
operator|++
name|i
operator|>=
name|ilim
condition|)
break|break;
name|eps
operator|*=
literal|10.
expr_stmt|;
name|d
operator|*=
literal|10.
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Generate ilim digits, then fix them up. */
name|eps
operator|*=
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
operator|,
name|d
operator|*=
literal|10.
control|)
block|{
name|L
operator|=
operator|(
name|long
operator|)
name|d
expr_stmt|;
name|d
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
if|if
condition|(
name|d
operator|>
literal|0.5
operator|+
name|eps
condition|)
goto|goto
name|bump_up
goto|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0.5
operator|-
name|eps
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|No_leftright
block|}
endif|#
directive|endif
name|fast_failed
label|:
name|s
operator|=
name|s0
expr_stmt|;
name|d
operator|=
name|d2
expr_stmt|;
name|k
operator|=
name|k0
expr_stmt|;
name|ilim
operator|=
name|ilim0
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Do we have a "small" integer? */
end_comment

begin_if
if|if
condition|(
name|be
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Int_max
condition|)
block|{
comment|/* Yes. */
name|ds
operator|=
name|tens
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|ndigits
operator|<
literal|0
operator|&&
name|ilim
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|d
operator|<=
literal|5
operator|*
name|ds
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|one_digit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|L
operator|=
call|(
name|long
call|)
argument_list|(
name|d
operator|/
name|ds
argument_list|)
expr_stmt|;
name|d
operator|-=
name|L
operator|*
name|ds
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
comment|/* If FLT_ROUNDS == 2, L will usually be high by 1 */
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|L
operator|--
expr_stmt|;
name|d
operator|+=
name|ds
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
name|d
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|ds
operator|||
name|d
operator|==
name|ds
operator|&&
name|L
operator|&
literal|1
condition|)
block|{
name|bump_up
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|d
operator|*=
literal|10.
operator|)
condition|)
break|break;
block|}
goto|goto
name|ret1
goto|;
block|}
end_if

begin_expr_stmt
name|m2
operator|=
name|b2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m5
operator|=
name|b5
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
name|i
operator|=
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
condition|?
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|+
literal|1
operator|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbits
operator|+
operator|(
operator|(
name|bbits
operator|+
name|be
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
literal|1
operator|+
name|P
operator|-
name|bbits
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|j
operator|=
name|ilim
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|m5
operator|>=
name|j
condition|)
name|m5
operator|-=
name|j
expr_stmt|;
else|else
block|{
name|s5
operator|+=
name|j
operator|-=
name|m5
expr_stmt|;
name|b5
operator|+=
name|j
expr_stmt|;
name|m5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|ilim
operator|)
operator|<
literal|0
condition|)
block|{
name|m2
operator|-=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|b2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
name|mhi
operator|=
name|i2b
argument_list|(
name|Binit
argument_list|(
operator|&
name|_mhi
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|m2
operator|>
literal|0
operator|&&
name|s2
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|m2
operator|<
name|s2
condition|?
name|m2
else|:
name|s2
expr_stmt|;
name|b2
operator|-=
name|i
expr_stmt|;
name|m2
operator|-=
name|i
expr_stmt|;
name|s2
operator|-=
name|i
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|b5
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m5
operator|>
literal|0
condition|)
block|{
name|Bigint
modifier|*
name|b_tmp
decl_stmt|;
name|mhi
operator|=
name|pow5mult
argument_list|(
name|mhi
argument_list|,
name|m5
argument_list|)
expr_stmt|;
name|b_tmp
operator|=
name|mult
argument_list|(
name|b_avail
argument_list|,
name|mhi
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b_avail
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b_tmp
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|=
name|b5
operator|-
name|m5
condition|)
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|b5
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|S
operator|=
name|i2b
argument_list|(
name|S
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|s5
operator|>
literal|0
condition|)
name|S
operator|=
name|pow5mult
argument_list|(
name|S
argument_list|,
name|s5
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Check for special case that d is a normalized power of 2. */
end_comment

begin_if
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|word1
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Bndry_mask
operator|)
ifndef|#
directive|ifndef
name|Sudden_Underflow
operator|&&
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Exp_mask
endif|#
directive|endif
condition|)
block|{
comment|/* The special case */
name|b2
operator|+=
name|Log2P
expr_stmt|;
name|s2
operator|+=
name|Log2P
expr_stmt|;
name|spec_case
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|spec_case
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Arrange for convenient computation of quotients:          * shift left if necessary so divisor has 4 leading 0 bits.          *          * Perhaps we should just compute leading 28 bits of S once          * and for all and pass them and a shift to quorem, so it          * can do shifts and ors to compute the numerator for q.          */
end_comment

begin_if
if|if
condition|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0x1f
condition|)
name|i
operator|=
literal|32
operator|-
name|i
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|i
operator|>
literal|4
condition|)
block|{
name|i
operator|-=
literal|4
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|i
operator|+=
literal|28
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|b2
operator|>
literal|0
condition|)
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
name|b2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|s2
operator|>
literal|0
condition|)
name|S
operator|=
name|lshift
argument_list|(
name|S
argument_list|,
name|s2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|k_check
condition|)
block|{
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|<
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we botched the k estimate */
if|if
condition|(
name|leftright
condition|)
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|ilim
operator|<=
literal|0
operator|&&
name|mode
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|cmp
argument_list|(
name|b
argument_list|,
name|S
operator|=
name|multadd
argument_list|(
name|S
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* no digits, fcvt style */
name|no_digits
label|:
name|k
operator|=
operator|-
literal|1
operator|-
name|ndigits
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|one_digit
label|:
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
name|k
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_if

begin_if
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m2
operator|>
literal|0
condition|)
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|/* Compute mlo -- check for special case                  * that d is a normalized power of 2.                  */
if|if
condition|(
name|spec_case
condition|)
block|{
name|mlo
operator|=
name|Brealloc
argument_list|(
name|Binit
argument_list|(
operator|&
name|_mlo
argument_list|)
argument_list|,
name|mhi
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|mlo
argument_list|,
name|mhi
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
block|}
else|else
name|mlo
operator|=
name|mhi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
comment|/* Do we yet have the shortest decimal string                          * that will round to d?                          */
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|b_avail
operator|=
name|diff
argument_list|(
name|b_avail
argument_list|,
name|S
argument_list|,
name|mhi
argument_list|)
expr_stmt|;
comment|/* b_avail = S - mi */
name|j1
operator|=
name|b_avail
operator|->
name|sign
condition|?
literal|1
else|:
name|cmp
argument_list|(
name|b
argument_list|,
name|b_avail
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
name|j1
operator|==
literal|0
operator|&&
operator|!
name|mode
operator|&&
operator|!
operator|(
name|word1
argument_list|(
name|d
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|dig
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|j
operator|<
literal|0
operator|||
name|j
operator|==
literal|0
operator|&&
operator|!
name|mode
ifndef|#
directive|ifndef
name|ROUND_BIASED
operator|&&
operator|!
operator|(
name|word1
argument_list|(
name|d
argument_list|)
operator|&
literal|1
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j1
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j1
operator|>
literal|0
operator|||
name|j1
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
operator|&&
name|dig
operator|++
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
block|{
comment|/* possible if i == 1 */
name|round_9_up
label|:
operator|*
name|s
operator|++
operator|=
literal|'9'
expr_stmt|;
goto|goto
name|roundoff
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
operator|+
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlo
operator|==
name|mhi
condition|)
name|mlo
operator|=
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|mlo
operator|=
name|multadd
argument_list|(
name|mlo
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|s
operator|++
operator|=
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Round off last digit */
end_comment

begin_expr_stmt
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>
literal|0
operator|||
name|j
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
condition|)
block|{
name|roundoff
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
block|}
end_if

begin_label
name|ret
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|b_avail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|mhi
condition|)
block|{
if|if
condition|(
name|mlo
operator|&&
name|mlo
operator|!=
name|mhi
condition|)
name|Bfree
argument_list|(
name|mlo
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|mhi
argument_list|)
expr_stmt|;
block|}
end_if

begin_label
name|ret1
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|s
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|decpt
operator|=
name|k
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
expr_stmt|;
end_if

begin_return
return|return
name|s0
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DTOA */
end_comment

end_unit

