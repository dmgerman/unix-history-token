begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	Copyright (C) 1992, 1993 Free Software Foundation, Inc.  This file is part of the librx library.  Librx is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Librx is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU Library General Public License along with this software; see the file COPYING.LIB.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* NOTE!!!  AIX is so losing it requires this to be the first thing in the   * file.   * Do not put ANYTHING before it!    */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
name|char
name|rx_version_string
index|[]
init|=
literal|"GNU Rx version 0.06"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ``Too hard!'' 			 *	    -- anon. 			 */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isgraph
end_ifndef

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|c
parameter_list|)
value|(isprint (c)&& !isspace (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_typedef
typedef|typedef
name|char
name|boolean
typedef|;
end_typedef

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RX_DECL
end_ifndef

begin_define
define|#
directive|define
name|RX_DECL
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GCC__
end_ifndef

begin_undef
undef|#
directive|undef
name|__inline__
end_undef

begin_define
define|#
directive|define
name|__inline__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Emacs already defines alloca, sometimes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_comment
comment|/* Make alloca work the best possible way.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_if
if|#
directive|if
name|HAVE_ALLOCA_H
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ or HAVE_ALLOCA_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_AIX
end_ifndef

begin_comment
comment|/* Already did AIX, up at the top.  */
end_comment

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not alloca */
end_comment

begin_comment
comment|/* Memory management and stuff for emacs. */
end_comment

begin_define
define|#
directive|define
name|CHARBITS
value|8
end_define

begin_define
define|#
directive|define
name|remalloc
parameter_list|(
name|M
parameter_list|,
name|S
parameter_list|)
value|(M ? realloc (M, S) : malloc (S))
end_define

begin_comment
comment|/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we  * use `alloca' instead of `malloc' for the backtracking stack.  *  * Emacs will die miserably if we don't do this.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX_MALLOC
end_ifdef

begin_define
define|#
directive|define
name|REGEX_ALLOCATE
value|malloc
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not REGEX_MALLOC  */
end_comment

begin_define
define|#
directive|define
name|REGEX_ALLOCATE
value|alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REGEX_MALLOC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RX_WANT_RX_DEFS
end_ifdef

begin_define
define|#
directive|define
name|RX_DECL
value|extern
end_define

begin_define
define|#
directive|define
name|RX_DEF_QUAL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RX_WANT_RX_DEFS
end_define

begin_define
define|#
directive|define
name|RX_DECL
value|static
end_define

begin_define
define|#
directive|define
name|RX_DEF_QUAL
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"rx.h"
end_include

begin_undef
undef|#
directive|undef
name|RX_DECL
end_undef

begin_define
define|#
directive|define
name|RX_DECL
value|RX_DEF_QUAL
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTAX_TABLE
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|re_syntax_table
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_comment
comment|/* RX_DECL char re_syntax_table[CHAR_SET_SIZE]; */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|init_syntax_once
argument_list|(
name|void
argument_list|)
else|#
directive|else
decl|static
name|void
name|init_syntax_once
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|bzero
argument_list|(
name|re_syntax_table
argument_list|,
sizeof|sizeof
name|re_syntax_table
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'A'
init|;
name|c
operator|<=
literal|'Z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
name|re_syntax_table
index|[
literal|'_'
index|]
operator|=
name|Sword
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Compile with `-DRX_DEBUG' and use the following flags.  *  * Debugging flags:  *   	rx_debug - print information as a regexp is compiled  * 	rx_debug_trace - print information as a regexp is executed  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RX_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|rx_debug_compile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rx_debug_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
modifier|*
name|dbug_rxb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|side_effect_printer
function_decl|)
parameter_list|(
name|struct
name|rx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|side_effect_printer
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|static
name|void
name|print_cset
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|rx_Bitset
name|cset
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|print_cset
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|print_rexp
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|node
argument_list|,
name|int
name|depth
argument_list|,
name|side_effect_printer
name|seprint
argument_list|,
name|FILE
operator|*
name|fp
argument_list|)
else|#
directive|else
decl|static
name|void
name|print_rexp
argument_list|(
name|rx
argument_list|,
name|node
argument_list|,
name|depth
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|side_effect_printer
name|seprint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|node
condition|)
return|return;
else|else
block|{
switch|switch
condition|(
name|node
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_cset
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|cset
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s%s\n"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|node
operator|->
name|type
operator|==
name|r_opt
condition|?
literal|"opt"
else|:
literal|"star"
argument_list|)
expr_stmt|;
name|print_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|depth
operator|+
literal|3
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_2phase_star
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s2phase star\n"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|depth
operator|+
literal|3
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|print_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|depth
operator|+
literal|3
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_alternate
case|:
case|case
name|r_concat
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s%s\n"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|node
operator|->
name|type
operator|==
name|r_alternate
condition|?
literal|"alt"
else|:
literal|"concat"
argument_list|)
expr_stmt|;
name|print_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|depth
operator|+
literal|3
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|print_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|depth
operator|+
literal|3
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_side_effect
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*sSide effect: "
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|seprint
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|side_effect
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|print_nfa
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|n
argument_list|,
name|side_effect_printer
name|seprint
argument_list|,
name|FILE
operator|*
name|fp
argument_list|)
else|#
directive|else
decl|static
name|void
name|print_nfa
argument_list|(
name|rx
argument_list|,
name|n
argument_list|,
name|seprint
argument_list|,
name|fp
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|side_effect_printer
name|seprint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
while|while
condition|(
name|n
condition|)
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
init|=
name|n
operator|->
name|edges
decl_stmt|;
name|struct
name|rx_possible_future
modifier|*
name|ec
init|=
name|n
operator|->
name|futures
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"node %d %s\n"
argument_list|,
name|n
operator|->
name|id
argument_list|,
name|n
operator|->
name|is_final
condition|?
literal|"final"
else|:
operator|(
name|n
operator|->
name|is_start
condition|?
literal|"start"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"   edge to %d, "
argument_list|,
name|e
operator|->
name|dest
operator|->
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|ne_epsilon
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"epsilon\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ne_side_effect
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"side effect "
argument_list|)
expr_stmt|;
name|seprint
argument_list|(
name|rx
argument_list|,
name|e
operator|->
name|params
operator|.
name|side_effect
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ne_cset
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"cset "
argument_list|)
expr_stmt|;
name|print_cset
argument_list|(
name|rx
argument_list|,
name|e
operator|->
name|params
operator|.
name|cset
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|ec
condition|)
block|{
name|int
name|x
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|s
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|l
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"   eclosure to {"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ec
operator|->
name|destset
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|cdr
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d "
argument_list|,
name|s
operator|->
name|car
operator|->
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"} ("
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|ec
operator|->
name|effects
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|cdr
control|)
block|{
name|seprint
argument_list|(
name|rx
argument_list|,
name|l
operator|->
name|car
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|ec
operator|=
name|ec
operator|->
name|next
expr_stmt|;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|efnames
index|[]
init|=
block|{
literal|"bogon"
block|,
literal|"re_se_try"
block|,
literal|"re_se_pushback"
block|,
literal|"re_se_push0"
block|,
literal|"re_se_pushpos"
block|,
literal|"re_se_chkpos"
block|,
literal|"re_se_poppos"
block|,
literal|"re_se_at_dot"
block|,
literal|"re_se_syntax"
block|,
literal|"re_se_not_syntax"
block|,
literal|"re_se_begbuf"
block|,
literal|"re_se_hat"
block|,
literal|"re_se_wordbeg"
block|,
literal|"re_se_wordbound"
block|,
literal|"re_se_notwordbound"
block|,
literal|"re_se_wordend"
block|,
literal|"re_se_endbuf"
block|,
literal|"re_se_dollar"
block|,
literal|"re_se_fail"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|efnames2
index|[]
init|=
block|{
literal|"re_se_win"
literal|"re_se_lparen"
block|,
literal|"re_se_rparen"
block|,
literal|"re_se_backref"
block|,
literal|"re_se_iter"
block|,
literal|"re_se_end_iter"
block|,
literal|"re_se_tv"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inx_names
index|[]
init|=
block|{
literal|"rx_backtrack_point"
block|,
literal|"rx_do_side_effects"
block|,
literal|"rx_cache_miss"
block|,
literal|"rx_next_char"
block|,
literal|"rx_backtrack"
block|,
literal|"rx_error_inx"
block|,
literal|"rx_num_instructions"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|re_seprint
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|void
operator|*
name|effect
argument_list|,
name|FILE
operator|*
name|fp
argument_list|)
else|#
directive|else
decl|static
name|void
name|re_seprint
argument_list|(
name|rx
argument_list|,
name|effect
argument_list|,
name|fp
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|effect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|effect
operator|<
literal|0
condition|)
name|fputs
argument_list|(
name|efnames
index|[
operator|-
operator|(
name|int
operator|)
name|effect
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dbug_rxb
condition|)
block|{
name|struct
name|re_se_params
modifier|*
name|p
init|=
operator|&
name|dbug_rxb
operator|->
name|se_params
index|[
operator|(
name|int
operator|)
name|effect
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s(%d,%d)"
argument_list|,
name|efnames2
index|[
name|p
operator|->
name|se
index|]
argument_list|,
name|p
operator|->
name|op1
argument_list|,
name|p
operator|->
name|op2
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[complex op # %d]"
argument_list|,
operator|(
name|int
operator|)
name|effect
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* These are so the regex.c regression tests will compile. */
end_comment

begin_function
name|void
name|print_compiled_pattern
parameter_list|(
name|rxb
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|print_fastmap
parameter_list|(
name|fm
parameter_list|)
name|char
modifier|*
name|fm
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RX_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This page: Bitsets.  Completely unintersting. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|int
name|rx_bitset_is_equal
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|int
name|rx_bitset_is_equal
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
name|RX_subset
name|s
init|=
name|b
index|[
literal|0
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
operator|~
name|a
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|a
index|[
name|x
index|]
operator|==
name|b
index|[
name|x
index|]
condition|;
operator|--
name|x
control|)
empty_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
return|return
operator|!
name|x
operator|&&
name|s
operator|==
name|a
index|[
literal|0
index|]
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|int
name|rx_bitset_is_subset
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|int
name|rx_bitset_is_subset
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
init|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|x
operator|--
operator|&&
operator|(
name|a
index|[
name|x
index|]
operator|&
name|b
index|[
name|x
index|]
operator|)
operator|==
name|a
index|[
name|x
index|]
condition|)
empty_stmt|;
return|return
name|x
operator|==
operator|-
literal|1
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|int
name|rx_bitset_empty
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|set
argument_list|)
else|#
directive|else
name|RX_DECL
name|int
name|rx_bitset_empty
argument_list|(
name|size
argument_list|,
name|set
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|set
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
name|RX_subset
name|s
init|=
name|set
index|[
literal|0
index|]
decl_stmt|;
name|set
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
operator|!
name|set
index|[
name|x
index|]
condition|;
operator|--
name|x
control|)
empty_stmt|;
name|set
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
return|return
operator|!
name|s
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_null
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_null
argument_list|(
name|size
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|bzero
argument_list|(
name|b
argument_list|,
name|rx_sizeof_bitset
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_universe
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_universe
argument_list|(
name|size
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
init|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
decl_stmt|;
while|while
condition|(
name|x
operator|--
condition|)
operator|*
name|b
operator|++
operator|=
operator|~
operator|(
name|RX_subset
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_complement
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_complement
argument_list|(
name|size
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
init|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
decl_stmt|;
while|while
condition|(
name|x
operator|--
condition|)
block|{
operator|*
name|b
operator|=
operator|~
operator|*
name|b
expr_stmt|;
operator|++
name|b
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_assign
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_assign
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|a
index|[
name|x
index|]
operator|=
name|b
index|[
name|x
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_union
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_union
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|a
index|[
name|x
index|]
operator||=
name|b
index|[
name|x
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_intersection
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_intersection
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|a
index|[
name|x
index|]
operator|&=
name|b
index|[
name|x
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_difference
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_difference
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|a
index|[
name|x
index|]
operator|&=
operator|~
name|b
index|[
name|x
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_revdifference
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_revdifference
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|a
index|[
name|x
index|]
operator|=
operator|~
name|a
index|[
name|x
index|]
operator|&
name|b
index|[
name|x
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_bitset_xor
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|a
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_bitset_xor
argument_list|(
name|size
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|a
index|[
name|x
index|]
operator|^=
name|b
index|[
name|x
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|unsigned
name|long
name|rx_bitset_hash
argument_list|(
name|int
name|size
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
name|unsigned
name|long
name|rx_bitset_hash
argument_list|(
name|size
argument_list|,
name|b
argument_list|)
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
name|unsigned
name|long
name|hash
init|=
operator|(
name|unsigned
name|long
operator|)
name|rx_bitset_hash
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rx_bitset_numb_subsets
argument_list|(
name|size
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
name|hash
operator|^=
name|rx_bitset_subset_val
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_block

begin_decl_stmt
name|RX_DECL
name|RX_subset
name|rx_subset_singletons
index|[
name|RX_subset_bits
index|]
init|=
block|{
literal|0x1
block|,
literal|0x2
block|,
literal|0x4
block|,
literal|0x8
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x100
block|,
literal|0x200
block|,
literal|0x400
block|,
literal|0x800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0x10000
block|,
literal|0x20000
block|,
literal|0x40000
block|,
literal|0x80000
block|,
literal|0x100000
block|,
literal|0x200000
block|,
literal|0x400000
block|,
literal|0x800000
block|,
literal|0x1000000
block|,
literal|0x2000000
block|,
literal|0x4000000
block|,
literal|0x8000000
block|,
literal|0x10000000
block|,
literal|0x20000000
block|,
literal|0x40000000
block|,
literal|0x80000000
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RX_DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|print_cset
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|rx_Bitset
name|cset
argument_list|,
name|FILE
operator|*
name|fp
argument_list|)
else|#
directive|else
decl|static
name|void
name|print_cset
argument_list|(
name|rx
argument_list|,
name|cset
argument_list|,
name|fp
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|cset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
name|fputc
argument_list|(
literal|'['
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|rx
operator|->
name|local_cset_size
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|isprint
argument_list|(
name|x
argument_list|)
operator|&&
name|RX_bitset_member
argument_list|(
name|cset
argument_list|,
name|x
argument_list|)
condition|)
name|fputc
argument_list|(
name|x
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|']'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  RX_DEBUG */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|rx_hash_masks
index|[
literal|4
index|]
init|=
block|{
literal|0x12488421
block|,
literal|0x96699669
block|,
literal|0xbe7dd7eb
block|,
literal|0xffffffff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash tables */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_hash_item
modifier|*
name|rx_hash_find
argument_list|(
expr|struct
name|rx_hash
operator|*
name|table
argument_list|,
name|unsigned
name|long
name|hash
argument_list|,
name|void
operator|*
name|value
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_hash_item
modifier|*
name|rx_hash_find
argument_list|(
name|table
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|rx_hash_eq
name|eq
init|=
name|rules
operator|->
name|eq
decl_stmt|;
name|int
name|maskc
init|=
literal|0
decl_stmt|;
name|long
name|mask
init|=
name|rx_hash_masks
index|[
literal|0
index|]
decl_stmt|;
name|int
name|bucket
init|=
operator|(
name|hash
operator|&
name|mask
operator|)
operator|%
literal|13
decl_stmt|;
while|while
condition|(
name|table
operator|->
name|children
index|[
name|bucket
index|]
condition|)
block|{
name|table
operator|=
name|table
operator|->
name|children
index|[
name|bucket
index|]
expr_stmt|;
operator|++
name|maskc
expr_stmt|;
name|mask
operator|=
name|rx_hash_masks
index|[
name|maskc
index|]
expr_stmt|;
name|bucket
operator|=
operator|(
name|hash
operator|&
name|mask
operator|)
operator|%
literal|13
expr_stmt|;
block|}
block|{
name|struct
name|rx_hash_item
modifier|*
name|it
init|=
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
decl_stmt|;
while|while
condition|(
name|it
condition|)
if|if
condition|(
name|eq
argument_list|(
name|it
operator|->
name|data
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|it
return|;
else|else
name|it
operator|=
name|it
operator|->
name|next_same_hash
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_hash_item
modifier|*
name|rx_hash_store
argument_list|(
expr|struct
name|rx_hash
operator|*
name|table
argument_list|,
name|unsigned
name|long
name|hash
argument_list|,
name|void
operator|*
name|value
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_hash_item
modifier|*
name|rx_hash_store
argument_list|(
name|table
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|rx_hash_eq
name|eq
init|=
name|rules
operator|->
name|eq
decl_stmt|;
name|int
name|maskc
init|=
literal|0
decl_stmt|;
name|long
name|mask
init|=
name|rx_hash_masks
index|[
literal|0
index|]
decl_stmt|;
name|int
name|bucket
init|=
operator|(
name|hash
operator|&
name|mask
operator|)
operator|%
literal|13
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|table
operator|->
name|children
index|[
name|bucket
index|]
condition|)
block|{
name|table
operator|=
name|table
operator|->
name|children
index|[
name|bucket
index|]
expr_stmt|;
operator|++
name|maskc
expr_stmt|;
name|mask
operator|=
name|rx_hash_masks
index|[
name|maskc
index|]
expr_stmt|;
name|bucket
operator|=
operator|(
name|hash
operator|&
name|mask
operator|)
operator|%
literal|13
expr_stmt|;
operator|++
name|depth
expr_stmt|;
block|}
block|{
name|struct
name|rx_hash_item
modifier|*
name|it
init|=
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
decl_stmt|;
while|while
condition|(
name|it
condition|)
if|if
condition|(
name|eq
argument_list|(
name|it
operator|->
name|data
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|it
return|;
else|else
name|it
operator|=
name|it
operator|->
name|next_same_hash
expr_stmt|;
block|}
block|{
if|if
condition|(
operator|(
name|depth
operator|<
literal|3
operator|)
operator|&&
operator|(
name|table
operator|->
name|bucket_size
index|[
name|bucket
index|]
operator|>=
literal|4
operator|)
condition|)
block|{
name|struct
name|rx_hash
modifier|*
name|newtab
init|=
operator|(
operator|(
expr|struct
name|rx_hash
operator|*
operator|)
name|rules
operator|->
name|hash_alloc
argument_list|(
name|rules
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|newtab
condition|)
goto|goto
name|add_to_bucket
goto|;
name|bzero
argument_list|(
name|newtab
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newtab
argument_list|)
argument_list|)
expr_stmt|;
name|newtab
operator|->
name|parent
operator|=
name|table
expr_stmt|;
block|{
name|struct
name|rx_hash_item
modifier|*
name|them
init|=
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
decl_stmt|;
name|unsigned
name|long
name|newmask
init|=
name|rx_hash_masks
index|[
name|maskc
operator|+
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|them
condition|)
block|{
name|struct
name|rx_hash_item
modifier|*
name|save
init|=
name|them
operator|->
name|next_same_hash
decl_stmt|;
name|int
name|new_buck
init|=
operator|(
name|them
operator|->
name|hash
operator|&
name|newmask
operator|)
operator|%
literal|13
decl_stmt|;
name|them
operator|->
name|next_same_hash
operator|=
name|newtab
operator|->
name|buckets
index|[
name|new_buck
index|]
expr_stmt|;
name|newtab
operator|->
name|buckets
index|[
name|new_buck
index|]
operator|=
name|them
expr_stmt|;
name|them
operator|->
name|table
operator|=
name|newtab
expr_stmt|;
name|them
operator|=
name|save
expr_stmt|;
operator|++
name|newtab
operator|->
name|bucket_size
index|[
name|new_buck
index|]
expr_stmt|;
operator|++
name|newtab
operator|->
name|refs
expr_stmt|;
block|}
name|table
operator|->
name|refs
operator|=
operator|(
name|table
operator|->
name|refs
operator|-
name|table
operator|->
name|bucket_size
index|[
name|bucket
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|table
operator|->
name|bucket_size
index|[
name|bucket
index|]
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|children
index|[
name|bucket
index|]
operator|=
name|newtab
expr_stmt|;
name|table
operator|=
name|newtab
expr_stmt|;
name|bucket
operator|=
operator|(
name|hash
operator|&
name|newmask
operator|)
operator|%
literal|13
expr_stmt|;
block|}
block|}
block|}
name|add_to_bucket
label|:
block|{
name|struct
name|rx_hash_item
modifier|*
name|it
init|=
operator|(
operator|(
expr|struct
name|rx_hash_item
operator|*
operator|)
name|rules
operator|->
name|hash_item_alloc
argument_list|(
name|rules
argument_list|,
name|value
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|it
condition|)
return|return
literal|0
return|;
name|it
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|it
operator|->
name|table
operator|=
name|table
expr_stmt|;
comment|/* DATA and BINDING are to be set in hash_item_alloc */
name|it
operator|->
name|next_same_hash
operator|=
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
expr_stmt|;
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
operator|=
name|it
expr_stmt|;
operator|++
name|table
operator|->
name|bucket_size
index|[
name|bucket
index|]
expr_stmt|;
operator|++
name|table
operator|->
name|refs
expr_stmt|;
return|return
name|it
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_hash_free
argument_list|(
expr|struct
name|rx_hash_item
operator|*
name|it
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_hash_free
argument_list|(
name|it
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash_item
modifier|*
name|it
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|it
condition|)
block|{
name|struct
name|rx_hash
modifier|*
name|table
init|=
name|it
operator|->
name|table
decl_stmt|;
name|unsigned
name|long
name|hash
init|=
name|it
operator|->
name|hash
decl_stmt|;
name|int
name|depth
init|=
operator|(
name|table
operator|->
name|parent
condition|?
operator|(
name|table
operator|->
name|parent
operator|->
name|parent
condition|?
operator|(
name|table
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
condition|?
literal|3
else|:
literal|2
operator|)
else|:
literal|1
operator|)
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|bucket
init|=
operator|(
name|hash
operator|&
name|rx_hash_masks
index|[
name|depth
index|]
operator|)
operator|%
literal|13
decl_stmt|;
name|struct
name|rx_hash_item
modifier|*
modifier|*
name|pos
init|=
operator|&
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|pos
operator|!=
name|it
condition|)
name|pos
operator|=
operator|&
operator|(
operator|*
name|pos
operator|)
operator|->
name|next_same_hash
expr_stmt|;
operator|*
name|pos
operator|=
name|it
operator|->
name|next_same_hash
expr_stmt|;
name|rules
operator|->
name|free_hash_item
argument_list|(
name|it
argument_list|,
name|rules
argument_list|)
expr_stmt|;
operator|--
name|table
operator|->
name|bucket_size
index|[
name|bucket
index|]
expr_stmt|;
operator|--
name|table
operator|->
name|refs
expr_stmt|;
while|while
condition|(
operator|!
name|table
operator|->
name|refs
operator|&&
name|depth
condition|)
block|{
name|struct
name|rx_hash
modifier|*
name|save
init|=
name|table
decl_stmt|;
name|table
operator|=
name|table
operator|->
name|parent
expr_stmt|;
operator|--
name|depth
expr_stmt|;
name|bucket
operator|=
operator|(
name|hash
operator|&
name|rx_hash_masks
index|[
name|depth
index|]
operator|)
operator|%
literal|13
expr_stmt|;
operator|--
name|table
operator|->
name|refs
expr_stmt|;
name|table
operator|->
name|children
index|[
name|bucket
index|]
operator|=
literal|0
expr_stmt|;
name|rules
operator|->
name|free_hash
argument_list|(
name|save
argument_list|,
name|rules
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_free_hash_table
argument_list|(
expr|struct
name|rx_hash
operator|*
name|tab
argument_list|,
name|rx_hash_freefn
name|freefn
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_free_hash_table
argument_list|(
name|tab
argument_list|,
name|freefn
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash
modifier|*
name|tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_hash_freefn
name|freefn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|13
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|tab
operator|->
name|children
index|[
name|x
index|]
condition|)
block|{
name|rx_free_hash_table
argument_list|(
name|tab
operator|->
name|children
index|[
name|x
index|]
argument_list|,
name|freefn
argument_list|,
name|rules
argument_list|)
expr_stmt|;
name|rules
operator|->
name|free_hash
argument_list|(
name|tab
operator|->
name|children
index|[
name|x
index|]
argument_list|,
name|rules
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rx_hash_item
modifier|*
name|them
init|=
name|tab
operator|->
name|buckets
index|[
name|x
index|]
decl_stmt|;
while|while
condition|(
name|them
condition|)
block|{
name|struct
name|rx_hash_item
modifier|*
name|that
init|=
name|them
decl_stmt|;
name|them
operator|=
name|that
operator|->
name|next_same_hash
expr_stmt|;
name|freefn
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|rules
operator|->
name|free_hash_item
argument_list|(
name|that
argument_list|,
name|rules
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Utilities for manipulating bitset represntations of characters sets. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|rx_Bitset
name|rx_cset
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|)
else|#
directive|else
name|RX_DECL
name|rx_Bitset
name|rx_cset
argument_list|(
name|rx
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|rx_Bitset
name|b
init|=
operator|(
name|rx_Bitset
operator|)
name|malloc
argument_list|(
name|rx_sizeof_bitset
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|rx_bitset_null
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|rx_Bitset
name|rx_copy_cset
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|rx_Bitset
name|a
argument_list|)
else|#
directive|else
name|RX_DECL
name|rx_Bitset
name|rx_copy_cset
argument_list|(
name|rx
argument_list|,
name|a
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|a
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
name|rx
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
condition|)
name|rx_bitset_union
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
name|cs
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_free_cset
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|rx_Bitset
name|c
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_free_cset
argument_list|(
name|rx
argument_list|,
name|c
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|c
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|c
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Hash table memory allocation policy for the regexp compiler */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_hash
modifier|*
name|compiler_hash_alloc
argument_list|(
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
decl|static struct
name|rx_hash
modifier|*
name|compiler_hash_alloc
argument_list|(
name|rules
argument_list|)
decl|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
return|return
operator|(
expr|struct
name|rx_hash
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_hash
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_hash_item
modifier|*
name|compiler_hash_item_alloc
argument_list|(
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|,
name|void
operator|*
name|value
argument_list|)
else|#
directive|else
decl|static struct
name|rx_hash_item
modifier|*
name|compiler_hash_item_alloc
argument_list|(
name|rules
argument_list|,
name|value
argument_list|)
decl|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_hash_item
modifier|*
name|it
decl_stmt|;
name|it
operator|=
operator|(
expr|struct
name|rx_hash_item
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
condition|)
block|{
name|it
operator|->
name|data
operator|=
name|value
expr_stmt|;
name|it
operator|->
name|binding
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|it
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|compiler_free_hash
argument_list|(
expr|struct
name|rx_hash
operator|*
name|tab
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
decl|static
name|void
name|compiler_free_hash
argument_list|(
name|tab
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash
modifier|*
name|tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|compiler_free_hash_item
argument_list|(
expr|struct
name|rx_hash_item
operator|*
name|item
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
decl|static
name|void
name|compiler_free_hash_item
argument_list|(
name|item
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash_item
modifier|*
name|item
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|item
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page: REXP_NODE (expression tree) structures. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rexp_node
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|enum
name|rexp_node_type
name|type
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|type
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rexp_node_type
name|type
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|rexp_node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|n
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_comment
comment|/* free_rexp_node assumes that the bitset passed to rx_mk_r_cset  * can be freed using rx_free_cset.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_cset
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|rx_Bitset
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_cset
argument_list|(
name|rx
argument_list|,
name|b
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_cset
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
name|n
operator|->
name|params
operator|.
name|cset
operator|=
name|b
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_concat
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|a
argument_list|,
expr|struct
name|rexp_node
operator|*
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_concat
argument_list|(
name|rx
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_concat
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
name|b
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_alternate
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|a
argument_list|,
expr|struct
name|rexp_node
operator|*
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_alternate
argument_list|(
name|rx
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_alternate
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
name|b
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_opt
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|a
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_opt
argument_list|(
name|rx
argument_list|,
name|a
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_opt
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_star
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|a
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_star
argument_list|(
name|rx
argument_list|,
name|a
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_star
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_2phase_star
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|a
argument_list|,
expr|struct
name|rexp_node
operator|*
name|b
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_2phase_star
argument_list|(
name|rx
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_2phase_star
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
name|b
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_side_effect
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|rx_side_effect
name|a
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_side_effect
argument_list|(
name|rx
argument_list|,
name|a
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_side_effect
name|a
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_side_effect
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|side_effect
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_data
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|void
operator|*
name|a
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_mk_r_data
argument_list|(
name|rx
argument_list|,
name|a
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|r_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_free_rexp
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|node
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|node
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|node
condition|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
if|if
condition|(
name|node
operator|->
name|params
operator|.
name|cset
condition|)
name|rx_free_cset
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
case|case
name|r_side_effect
case|:
break|break;
case|case
name|r_concat
case|:
case|case
name|r_alternate
case|:
case|case
name|r_2phase_star
case|:
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
expr_stmt|;
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_data
case|:
comment|/* This shouldn't occur. */
break|break;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_copy_rexp
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|node
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rexp_node
modifier|*
name|rx_copy_rexp
argument_list|(
name|rx
argument_list|,
name|node
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|node
condition|)
return|return
literal|0
return|;
else|else
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rexp_node
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|node
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
name|n
operator|->
name|params
operator|.
name|cset
operator|=
name|rx_copy_cset
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|params
operator|.
name|cset
condition|)
block|{
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|r_side_effect
case|:
name|n
operator|->
name|params
operator|.
name|side_effect
operator|=
name|node
operator|->
name|params
operator|.
name|side_effect
expr_stmt|;
break|break;
case|case
name|r_concat
case|:
case|case
name|r_alternate
case|:
case|case
name|r_opt
case|:
case|case
name|r_2phase_star
case|:
case|case
name|r_star
case|:
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|rx_copy_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
expr_stmt|;
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
name|rx_copy_rexp
argument_list|(
name|rx
argument_list|,
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|&&
operator|!
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|)
operator|||
operator|(
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|&&
operator|!
name|n
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|)
condition|)
block|{
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|r_data
case|:
comment|/* shouldn't happen */
break|break;
block|}
return|return
name|n
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page: functions to build and destroy graphs that describe nfa's */
end_comment

begin_comment
comment|/* Constructs a new nfa node. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_nfa_state
modifier|*
name|rx_nfa_state
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_nfa_state
modifier|*
name|rx_nfa_state
argument_list|(
name|rx
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
init|=
operator|(
expr|struct
name|rx_nfa_state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
name|bzero
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|rx
operator|->
name|nfa_states
expr_stmt|;
name|rx
operator|->
name|nfa_states
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_free_nfa_state
argument_list|(
expr|struct
name|rx_nfa_state
operator|*
name|n
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_free_nfa_state
argument_list|(
name|n
argument_list|)
decl|struct
name|rx_nfa_state
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This looks up an nfa node, given a numeric id.  Numeric id's are  * assigned after the nfa has been built.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_nfa_state
modifier|*
name|rx_id_to_nfa_state
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|int
name|id
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_nfa_state
modifier|*
name|rx_id_to_nfa_state
argument_list|(
name|rx
argument_list|,
name|id
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|rx
operator|->
name|nfa_states
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|n
operator|->
name|id
operator|==
name|id
condition|)
return|return
name|n
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* This adds an edge between two nodes, but doesn't initialize the   * edge label.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_nfa_edge
modifier|*
name|rx_nfa_edge
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|enum
name|rx_nfa_etype
name|type
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|start
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|dest
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_nfa_edge
modifier|*
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|dest
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rx_nfa_etype
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
expr|struct
name|rx_nfa_edge
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
name|e
operator|->
name|next
operator|=
name|start
operator|->
name|edges
expr_stmt|;
name|start
operator|->
name|edges
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|dest
expr_stmt|;
return|return
name|e
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_free_nfa_edge
argument_list|(
expr|struct
name|rx_nfa_edge
operator|*
name|e
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_free_nfa_edge
argument_list|(
name|e
argument_list|)
decl|struct
name|rx_nfa_edge
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This constructs a POSSIBLE_FUTURE, which is a kind epsilon-closure  * of an NFA.  These are added to an nfa automaticly by eclose_nfa.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_possible_future
modifier|*
name|rx_possible_future
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_se_list
operator|*
name|effects
argument_list|)
else|#
directive|else
decl|static struct
name|rx_possible_future
modifier|*
name|rx_possible_future
argument_list|(
name|rx
argument_list|,
name|effects
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_se_list
modifier|*
name|effects
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_possible_future
modifier|*
name|ec
decl_stmt|;
name|ec
operator|=
operator|(
expr|struct
name|rx_possible_future
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ec
condition|)
return|return
literal|0
return|;
name|ec
operator|->
name|destset
operator|=
literal|0
expr_stmt|;
name|ec
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ec
operator|->
name|effects
operator|=
name|effects
expr_stmt|;
return|return
name|ec
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|rx_free_possible_future
argument_list|(
expr|struct
name|rx_possible_future
operator|*
name|pf
argument_list|)
else|#
directive|else
decl|static
name|void
name|rx_free_possible_future
argument_list|(
name|pf
argument_list|)
decl|struct
name|rx_possible_future
modifier|*
name|pf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pf
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_free_nfa
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_free_nfa
argument_list|(
name|rx
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
while|while
condition|(
name|rx
operator|->
name|nfa_states
condition|)
block|{
while|while
condition|(
name|rx
operator|->
name|nfa_states
operator|->
name|edges
condition|)
block|{
switch|switch
condition|(
name|rx
operator|->
name|nfa_states
operator|->
name|edges
operator|->
name|type
condition|)
block|{
case|case
name|ne_cset
case|:
name|rx_free_cset
argument_list|(
name|rx
argument_list|,
name|rx
operator|->
name|nfa_states
operator|->
name|edges
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|rx
operator|->
name|nfa_states
operator|->
name|edges
expr_stmt|;
name|rx
operator|->
name|nfa_states
operator|->
name|edges
operator|=
name|rx
operator|->
name|nfa_states
operator|->
name|edges
operator|->
name|next
expr_stmt|;
name|rx_free_nfa_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while (rx->nfa_states->edges) */
block|{
comment|/* Iterate over the partial epsilon closures of rx->nfa_states */
name|struct
name|rx_possible_future
modifier|*
name|pf
init|=
name|rx
operator|->
name|nfa_states
operator|->
name|futures
decl_stmt|;
while|while
condition|(
name|pf
condition|)
block|{
name|struct
name|rx_possible_future
modifier|*
name|pft
init|=
name|pf
decl_stmt|;
name|pf
operator|=
name|pf
operator|->
name|next
expr_stmt|;
name|rx_free_possible_future
argument_list|(
name|pft
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|rx
operator|->
name|nfa_states
expr_stmt|;
name|rx
operator|->
name|nfa_states
operator|=
name|rx
operator|->
name|nfa_states
operator|->
name|next
expr_stmt|;
name|rx_free_nfa_state
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page: translating a pattern expression into an nfa and doing the   * static part of the nfa->super-nfa translation.  */
end_comment

begin_comment
comment|/* This is the thompson regexp->nfa algorithm.   * It is modified to allow for `side-effect epsilons.'  Those are  * edges that are taken whenever a similar epsilon edge would be,  * but which imply that some side effect occurs when the edge   * is taken.  *  * Side effects are used to model parts of the pattern langauge   * that are not regular (in the formal sense).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|int
name|rx_build_nfa
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
operator|*
name|start
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
operator|*
name|end
argument_list|)
else|#
directive|else
name|RX_DECL
name|int
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|edge
decl_stmt|;
comment|/* Start& end nodes may have been allocated by the caller. */
operator|*
name|start
operator|=
operator|*
name|start
condition|?
operator|*
name|start
else|:
name|rx_nfa_state
argument_list|(
name|rx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|start
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rexp
condition|)
block|{
operator|*
name|end
operator|=
operator|*
name|start
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|end
operator|=
operator|*
name|end
condition|?
operator|*
name|end
else|:
name|rx_nfa_state
argument_list|(
name|rx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|end
condition|)
block|{
name|rx_free_nfa_state
argument_list|(
operator|*
name|start
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_data
case|:
return|return
literal|0
return|;
case|case
name|r_cset
case|:
name|edge
operator|=
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_cset
argument_list|,
operator|*
name|start
argument_list|,
operator|*
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
condition|)
return|return
literal|0
return|;
name|edge
operator|->
name|params
operator|.
name|cset
operator|=
name|rx_copy_cset
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|params
operator|.
name|cset
condition|)
block|{
name|rx_free_nfa_edge
argument_list|(
name|edge
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
name|r_opt
case|:
return|return
operator|(
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
operator|*
name|start
argument_list|,
operator|*
name|end
argument_list|)
operator|)
return|;
case|case
name|r_star
case|:
block|{
name|struct
name|rx_nfa_state
modifier|*
name|star_start
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|star_end
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
operator|&
name|star_start
argument_list|,
operator|&
name|star_end
argument_list|)
operator|&&
name|star_start
operator|&&
name|star_end
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|star_start
argument_list|,
name|star_end
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
operator|*
name|start
argument_list|,
name|star_start
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|star_end
argument_list|,
operator|*
name|end
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|star_end
argument_list|,
name|star_start
argument_list|)
operator|)
return|;
block|}
case|case
name|r_2phase_star
case|:
block|{
name|struct
name|rx_nfa_state
modifier|*
name|star_start
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|star_end
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|loop_exp_start
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|loop_exp_end
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
operator|&
name|star_start
argument_list|,
operator|&
name|star_end
argument_list|)
operator|&&
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
operator|&
name|loop_exp_start
argument_list|,
operator|&
name|loop_exp_end
argument_list|)
operator|&&
name|star_start
operator|&&
name|star_end
operator|&&
name|loop_exp_end
operator|&&
name|loop_exp_start
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|star_start
argument_list|,
operator|*
name|end
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
operator|*
name|start
argument_list|,
name|star_start
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|star_end
argument_list|,
operator|*
name|end
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|star_end
argument_list|,
name|loop_exp_start
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|loop_exp_end
argument_list|,
name|star_start
argument_list|)
operator|)
return|;
block|}
case|case
name|r_concat
case|:
block|{
name|struct
name|rx_nfa_state
modifier|*
name|shared
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|start
argument_list|,
operator|&
name|shared
argument_list|)
operator|&&
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
operator|&
name|shared
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
case|case
name|r_alternate
case|:
block|{
name|struct
name|rx_nfa_state
modifier|*
name|ls
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|le
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|rs
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|re
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
operator|&
name|ls
argument_list|,
operator|&
name|le
argument_list|)
operator|&&
name|rx_build_nfa
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
operator|&
name|rs
argument_list|,
operator|&
name|re
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
operator|*
name|start
argument_list|,
name|ls
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
operator|*
name|start
argument_list|,
name|rs
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|le
argument_list|,
operator|*
name|end
argument_list|)
operator|&&
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_epsilon
argument_list|,
name|re
argument_list|,
operator|*
name|end
argument_list|)
operator|)
return|;
block|}
case|case
name|r_side_effect
case|:
name|edge
operator|=
name|rx_nfa_edge
argument_list|(
name|rx
argument_list|,
name|ne_side_effect
argument_list|,
operator|*
name|start
argument_list|,
operator|*
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
condition|)
return|return
literal|0
return|;
name|edge
operator|->
name|params
operator|.
name|side_effect
operator|=
name|rexp
operator|->
name|params
operator|.
name|side_effect
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* RX_NAME_NFA_STATES identifies all nodes with outgoing non-epsilon  * transitions.  Only these nodes can occur in super-states.    * All nodes are given an integer id.   * The id is non-negative if the node has non-epsilon out-transitions, negative  * otherwise (this is because we want the non-negative ids to be used as   * array indexes in a few places).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_name_nfa_states
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_name_nfa_states
argument_list|(
name|rx
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
init|=
name|rx
operator|->
name|nfa_states
decl_stmt|;
name|rx
operator|->
name|nodec
operator|=
literal|0
expr_stmt|;
name|rx
operator|->
name|epsnodec
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
init|=
name|n
operator|->
name|edges
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|is_start
condition|)
name|n
operator|->
name|eclosure_needed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|ne_epsilon
case|:
case|case
name|ne_side_effect
case|:
break|break;
case|case
name|ne_cset
case|:
name|n
operator|->
name|id
operator|=
name|rx
operator|->
name|nodec
operator|++
expr_stmt|;
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|from_n
init|=
name|n
operator|->
name|edges
decl_stmt|;
while|while
condition|(
name|from_n
condition|)
block|{
name|from_n
operator|->
name|dest
operator|->
name|eclosure_needed
operator|=
literal|1
expr_stmt|;
name|from_n
operator|=
name|from_n
operator|->
name|next
expr_stmt|;
block|}
block|}
goto|goto
name|cont
goto|;
block|}
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
name|n
operator|->
name|id
operator|=
name|rx
operator|->
name|epsnodec
operator|--
expr_stmt|;
name|cont
label|:
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|rx
operator|->
name|epsnodec
operator|=
operator|-
name|rx
operator|->
name|epsnodec
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page: data structures for the static part of the nfa->supernfa  * translation.  *  * There are side effect lists -- lists of side effects occuring  * along an uninterrupted, acyclic path of side-effect epsilon edges.  * Such paths are collapsed to single edges in the course of computing  * epsilon closures.  Such single edges are labled with a list of all  * the side effects entailed in crossing them.  Like lists of side  * effects are made == by the constructors below.  *  * There are also nfa state sets.  These are used to hold a list of all  * states reachable from a starting state for a given type of transition  * and side effect list.   These are also hash-consed.  */
end_comment

begin_comment
comment|/* The next several functions compare, construct, etc. lists of side  * effects.  See ECLOSE_NFA (below) for details.  */
end_comment

begin_comment
comment|/* Ordering of rx_se_list  * (-1, 0, 1 return value convention).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|se_list_cmp
parameter_list|(
name|void
modifier|*
name|va
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|)
else|#
directive|else
function|static int  se_list_cmp
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
name|void
modifier|*
name|va
decl_stmt|;
name|void
modifier|*
name|vb
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|rx_se_list
modifier|*
name|a
init|=
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|va
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|b
init|=
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
operator|(
name|va
operator|==
name|vb
operator|)
condition|?
literal|0
else|:
operator|(
operator|!
name|va
condition|?
operator|-
literal|1
else|:
operator|(
operator|!
name|vb
condition|?
literal|1
else|:
operator|(
operator|(
name|long
operator|)
name|a
operator|->
name|car
operator|<
operator|(
name|long
operator|)
name|b
operator|->
name|car
condition|?
literal|1
else|:
operator|(
operator|(
name|long
operator|)
name|a
operator|->
name|car
operator|>
operator|(
name|long
operator|)
name|b
operator|->
name|car
condition|?
operator|-
literal|1
else|:
name|se_list_cmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|a
operator|->
name|cdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|b
operator|->
name|cdr
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|se_list_equal
parameter_list|(
name|void
modifier|*
name|va
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|)
else|#
directive|else
function|static int  se_list_equal
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
name|void
modifier|*
name|va
decl_stmt|;
name|void
modifier|*
name|vb
decl_stmt|;
endif|#
directive|endif
block|{
return|return
operator|!
operator|(
name|se_list_cmp
argument_list|(
name|va
argument_list|,
name|vb
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|rx_hash_rules
name|se_list_hash_rules
init|=
block|{
name|se_list_equal
block|,
name|compiler_hash_alloc
block|,
name|compiler_free_hash
block|,
name|compiler_hash_item_alloc
block|,
name|compiler_free_hash_item
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_se_list
modifier|*
name|side_effect_cons
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|void
operator|*
name|se
argument_list|,
expr|struct
name|rx_se_list
operator|*
name|list
argument_list|)
else|#
directive|else
decl|static struct
name|rx_se_list
modifier|*
name|side_effect_cons
argument_list|(
name|rx
argument_list|,
name|se
argument_list|,
name|list
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|se
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_se_list
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_se_list
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
literal|0
return|;
name|l
operator|->
name|car
operator|=
name|se
expr_stmt|;
name|l
operator|->
name|cdr
operator|=
name|list
expr_stmt|;
return|return
name|l
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_se_list
modifier|*
name|hash_cons_se_prog
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_hash
operator|*
name|memo
argument_list|,
name|void
operator|*
name|car
argument_list|,
expr|struct
name|rx_se_list
operator|*
name|cdr
argument_list|)
else|#
directive|else
decl|static struct
name|rx_se_list
modifier|*
name|hash_cons_se_prog
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|car
argument_list|,
name|cdr
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash
modifier|*
name|memo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|car
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_se_list
modifier|*
name|cdr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|long
name|hash
init|=
operator|(
name|long
operator|)
name|car
operator|^
operator|(
name|long
operator|)
name|cdr
decl_stmt|;
name|struct
name|rx_se_list
name|template
decl_stmt|;
name|template
operator|.
name|car
operator|=
name|car
expr_stmt|;
name|template
operator|.
name|cdr
operator|=
name|cdr
expr_stmt|;
block|{
name|struct
name|rx_hash_item
modifier|*
name|it
init|=
name|rx_hash_store
argument_list|(
name|memo
argument_list|,
name|hash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|template
argument_list|,
operator|&
name|se_list_hash_rules
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|it
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|it
operator|->
name|data
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|template
condition|)
block|{
name|struct
name|rx_se_list
modifier|*
name|consed
decl_stmt|;
name|consed
operator|=
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|consed
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|consed
operator|=
name|template
expr_stmt|;
name|it
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|consed
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|it
operator|->
name|data
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_se_list
modifier|*
name|hash_se_prog
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_hash
operator|*
name|memo
argument_list|,
expr|struct
name|rx_se_list
operator|*
name|prog
argument_list|)
else|#
directive|else
decl|static struct
name|rx_se_list
modifier|*
name|hash_se_prog
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|prog
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash
modifier|*
name|memo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_se_list
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_se_list
modifier|*
name|answer
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|prog
condition|)
block|{
name|answer
operator|=
name|hash_cons_se_prog
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|prog
operator|->
name|car
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
return|return
literal|0
return|;
name|prog
operator|=
name|prog
operator|->
name|cdr
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|nfa_set_cmp
parameter_list|(
name|void
modifier|*
name|va
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|)
else|#
directive|else
function|static int  nfa_set_cmp
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
name|void
modifier|*
name|va
decl_stmt|;
name|void
modifier|*
name|vb
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|rx_nfa_state_set
modifier|*
name|a
init|=
operator|(
expr|struct
name|rx_nfa_state_set
operator|*
operator|)
name|va
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|b
init|=
operator|(
expr|struct
name|rx_nfa_state_set
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
operator|(
name|va
operator|==
name|vb
operator|)
condition|?
literal|0
else|:
operator|(
operator|!
name|va
condition|?
operator|-
literal|1
else|:
operator|(
operator|!
name|vb
condition|?
literal|1
else|:
operator|(
name|a
operator|->
name|car
operator|->
name|id
operator|<
name|b
operator|->
name|car
operator|->
name|id
condition|?
literal|1
else|:
operator|(
name|a
operator|->
name|car
operator|->
name|id
operator|>
name|b
operator|->
name|car
operator|->
name|id
condition|?
operator|-
literal|1
else|:
name|nfa_set_cmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|a
operator|->
name|cdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|b
operator|->
name|cdr
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|nfa_set_equal
parameter_list|(
name|void
modifier|*
name|va
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|)
else|#
directive|else
function|static int  nfa_set_equal
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
name|void
modifier|*
name|va
decl_stmt|;
name|void
modifier|*
name|vb
decl_stmt|;
endif|#
directive|endif
block|{
return|return
operator|!
name|nfa_set_cmp
argument_list|(
name|va
argument_list|,
name|vb
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|rx_hash_rules
name|nfa_set_hash_rules
init|=
block|{
name|nfa_set_equal
block|,
name|compiler_hash_alloc
block|,
name|compiler_free_hash
block|,
name|compiler_hash_item_alloc
block|,
name|compiler_free_hash_item
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_nfa_state_set
modifier|*
name|nfa_set_cons
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_hash
operator|*
name|memo
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|state
argument_list|,
expr|struct
name|rx_nfa_state_set
operator|*
name|set
argument_list|)
else|#
directive|else
decl|static struct
name|rx_nfa_state_set
modifier|*
name|nfa_set_cons
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|state
argument_list|,
name|set
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash
modifier|*
name|memo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state_set
modifier|*
name|set
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_state_set
name|template
decl_stmt|;
name|struct
name|rx_hash_item
modifier|*
name|node
decl_stmt|;
name|template
operator|.
name|car
operator|=
name|state
expr_stmt|;
name|template
operator|.
name|cdr
operator|=
name|set
expr_stmt|;
name|node
operator|=
name|rx_hash_store
argument_list|(
name|memo
argument_list|,
operator|(
operator|(
operator|(
name|long
operator|)
name|state
operator|)
operator|>>
literal|8
operator|)
operator|^
operator|(
name|long
operator|)
name|set
argument_list|,
operator|&
name|template
argument_list|,
operator|&
name|nfa_set_hash_rules
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|node
operator|->
name|data
operator|==
operator|&
name|template
condition|)
block|{
name|struct
name|rx_nfa_state_set
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
expr|struct
name|rx_nfa_state_set
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
literal|0
return|;
operator|*
name|l
operator|=
name|template
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|rx_nfa_state_set
operator|*
operator|)
name|node
operator|->
name|data
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_nfa_state_set
modifier|*
name|nfa_set_enjoin
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_hash
operator|*
name|memo
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|state
argument_list|,
expr|struct
name|rx_nfa_state_set
operator|*
name|set
argument_list|)
else|#
directive|else
decl|static struct
name|rx_nfa_state_set
modifier|*
name|nfa_set_enjoin
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|state
argument_list|,
name|set
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash
modifier|*
name|memo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state_set
modifier|*
name|set
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|set
operator|||
name|state
operator|->
name|id
operator|<
name|set
operator|->
name|car
operator|->
name|id
condition|)
return|return
name|nfa_set_cons
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|state
argument_list|,
name|set
argument_list|)
return|;
if|if
condition|(
name|state
operator|->
name|id
operator|==
name|set
operator|->
name|car
operator|->
name|id
condition|)
return|return
name|set
return|;
else|else
block|{
name|struct
name|rx_nfa_state_set
modifier|*
name|newcdr
init|=
name|nfa_set_enjoin
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|state
argument_list|,
name|set
operator|->
name|cdr
argument_list|)
decl_stmt|;
if|if
condition|(
name|newcdr
operator|!=
name|set
operator|->
name|cdr
condition|)
name|set
operator|=
name|nfa_set_cons
argument_list|(
name|rx
argument_list|,
name|memo
argument_list|,
name|set
operator|->
name|car
argument_list|,
name|newcdr
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page: computing epsilon closures.  The closures aren't total.  * Each node's closures are partitioned according to the side effects entailed  * along the epsilon edges.  Return true on success.  */
end_comment

begin_struct
struct|struct
name|eclose_frame
block|{
name|struct
name|rx_se_list
modifier|*
name|prog_backwards
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|eclose_node
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|outnode
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|node
argument_list|,
expr|struct
name|eclose_frame
operator|*
name|frame
argument_list|)
else|#
directive|else
decl|static
name|int
name|eclose_node
argument_list|(
name|rx
argument_list|,
name|outnode
argument_list|,
name|node
argument_list|,
name|frame
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|outnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|eclose_frame
modifier|*
name|frame
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
init|=
name|node
operator|->
name|edges
decl_stmt|;
comment|/* For each node, we follow all epsilon paths to build the closure.    * The closure omits nodes that have only epsilon edges.    * The closure is split into partial closures -- all the states in    * a partial closure are reached by crossing the same list of    * of side effects (though not necessarily the same path).    */
if|if
condition|(
name|node
operator|->
name|mark
condition|)
return|return
literal|1
return|;
name|node
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|id
operator|>=
literal|0
operator|||
name|node
operator|->
name|is_final
condition|)
block|{
name|struct
name|rx_possible_future
modifier|*
modifier|*
name|ec
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|prog_in_order
init|=
operator|(
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|hash_se_prog
argument_list|(
name|rx
argument_list|,
operator|&
name|rx
operator|->
name|se_list_memo
argument_list|,
name|frame
operator|->
name|prog_backwards
argument_list|)
operator|)
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|ec
operator|=
operator|&
name|outnode
operator|->
name|futures
expr_stmt|;
while|while
condition|(
operator|*
name|ec
condition|)
block|{
name|cmp
operator|=
name|se_list_cmp
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
name|ec
operator|)
operator|->
name|effects
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prog_in_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
break|break;
name|ec
operator|=
operator|&
operator|(
operator|*
name|ec
operator|)
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|ec
operator|||
operator|(
name|cmp
operator|<
literal|0
operator|)
condition|)
block|{
name|struct
name|rx_possible_future
modifier|*
name|saved
init|=
operator|*
name|ec
decl_stmt|;
operator|*
name|ec
operator|=
name|rx_possible_future
argument_list|(
name|rx
argument_list|,
name|prog_in_order
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ec
operator|)
operator|->
name|next
operator|=
name|saved
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ec
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node
operator|->
name|id
operator|>=
literal|0
condition|)
block|{
operator|(
operator|*
name|ec
operator|)
operator|->
name|destset
operator|=
name|nfa_set_enjoin
argument_list|(
name|rx
argument_list|,
operator|&
name|rx
operator|->
name|set_list_memo
argument_list|,
name|node
argument_list|,
operator|(
operator|*
name|ec
operator|)
operator|->
name|destset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|ec
operator|)
operator|->
name|destset
condition|)
return|return
literal|0
return|;
block|}
block|}
while|while
condition|(
name|e
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|ne_epsilon
case|:
if|if
condition|(
operator|!
name|eclose_node
argument_list|(
name|rx
argument_list|,
name|outnode
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|frame
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|ne_side_effect
case|:
block|{
name|frame
operator|->
name|prog_backwards
operator|=
name|side_effect_cons
argument_list|(
name|rx
argument_list|,
name|e
operator|->
name|params
operator|.
name|side_effect
argument_list|,
name|frame
operator|->
name|prog_backwards
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame
operator|->
name|prog_backwards
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|eclose_node
argument_list|(
name|rx
argument_list|,
name|outnode
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|frame
argument_list|)
condition|)
return|return
literal|0
return|;
block|{
name|struct
name|rx_se_list
modifier|*
name|dying
init|=
name|frame
operator|->
name|prog_backwards
decl_stmt|;
name|frame
operator|->
name|prog_backwards
operator|=
name|frame
operator|->
name|prog_backwards
operator|->
name|cdr
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dying
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
name|node
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|int
name|rx_eclose_nfa
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|)
else|#
directive|else
name|RX_DECL
name|int
name|rx_eclose_nfa
argument_list|(
name|rx
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
init|=
name|rx
operator|->
name|nfa_states
decl_stmt|;
name|struct
name|eclose_frame
name|frame
decl_stmt|;
specifier|static
name|int
name|rx_id
init|=
literal|0
decl_stmt|;
name|frame
operator|.
name|prog_backwards
operator|=
literal|0
expr_stmt|;
name|rx
operator|->
name|rx_id
operator|=
name|rx_id
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rx
operator|->
name|se_list_memo
argument_list|,
sizeof|sizeof
argument_list|(
name|rx
operator|->
name|se_list_memo
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rx
operator|->
name|set_list_memo
argument_list|,
sizeof|sizeof
argument_list|(
name|rx
operator|->
name|set_list_memo
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|futures
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|eclosure_needed
operator|&&
operator|!
name|eclose_node
argument_list|(
name|rx
argument_list|,
name|n
argument_list|,
name|n
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* clear_marks (rx); */
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* This deletes epsilon edges from an NFA.  After running eclose_node,  * we have no more need for these edges.  They are removed to simplify  * further operations on the NFA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_delete_epsilon_transitions
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_delete_epsilon_transitions
argument_list|(
name|rx
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
init|=
name|rx
operator|->
name|nfa_states
decl_stmt|;
name|struct
name|rx_nfa_edge
modifier|*
modifier|*
name|e
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|e
operator|=
operator|&
name|n
operator|->
name|edges
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|e
operator|)
operator|->
name|type
condition|)
block|{
case|case
name|ne_epsilon
case|:
case|case
name|ne_side_effect
case|:
name|t
operator|=
operator|*
name|e
expr_stmt|;
operator|*
name|e
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|rx_free_nfa_edge
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|e
operator|=
operator|&
operator|(
operator|*
name|e
operator|)
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page: storing the nfa in a contiguous region of memory for  * subsequent conversion to a super-nfa.  */
end_comment

begin_comment
comment|/* This is for qsort on an array of nfa_states. The order  * is based on state ids and goes   *		[0...MAX][MIN..-1] where (MAX>=0) and (MIN<0)  * This way, positive ids double as array indices.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|nfacmp
parameter_list|(
name|void
modifier|*
name|va
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|)
else|#
directive|else
function|static int  nfacmp
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
name|void
modifier|*
name|va
decl_stmt|;
name|void
modifier|*
name|vb
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|a
init|=
operator|(
expr|struct
name|rx_nfa_state
operator|*
operator|*
operator|)
name|va
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|b
init|=
operator|(
expr|struct
name|rx_nfa_state
operator|*
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
operator|*
name|a
operator|==
operator|*
name|b
comment|/*&&&& 3.18 */
condition|?
literal|0
else|:
operator|(
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|id
operator|<
literal|0
operator|)
operator|==
operator|(
operator|(
operator|*
name|b
operator|)
operator|->
name|id
operator|<
literal|0
operator|)
condition|?
operator|(
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|id
operator|<
operator|(
operator|*
name|b
operator|)
operator|->
name|id
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
else|:
operator|(
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|id
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|count_hash_nodes
argument_list|(
expr|struct
name|rx_hash
operator|*
name|st
argument_list|)
else|#
directive|else
decl|static
name|int
name|count_hash_nodes
argument_list|(
name|st
argument_list|)
decl|struct
name|rx_hash
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|13
condition|;
operator|++
name|x
control|)
name|count
operator|+=
operator|(
operator|(
name|st
operator|->
name|children
index|[
name|x
index|]
operator|)
condition|?
name|count_hash_nodes
argument_list|(
name|st
operator|->
name|children
index|[
name|x
index|]
argument_list|)
else|:
name|st
operator|->
name|bucket_size
index|[
name|x
index|]
operator|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|se_memo_freer
argument_list|(
expr|struct
name|rx_hash_item
operator|*
name|node
argument_list|)
else|#
directive|else
decl|static
name|void
name|se_memo_freer
argument_list|(
name|node
argument_list|)
decl|struct
name|rx_hash_item
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|nfa_set_freer
argument_list|(
expr|struct
name|rx_hash_item
operator|*
name|node
argument_list|)
else|#
directive|else
decl|static
name|void
name|nfa_set_freer
argument_list|(
name|node
argument_list|)
decl|struct
name|rx_hash_item
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This copies an entire NFA into a single malloced block of memory.  * Mostly this is for compatability with regex.c, though it is convenient  * to have the nfa nodes in an array.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|int
name|rx_compactify_nfa
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|void
operator|*
operator|*
name|mem
argument_list|,
name|unsigned
name|long
operator|*
name|size
argument_list|)
else|#
directive|else
name|RX_DECL
name|int
name|rx_compactify_nfa
argument_list|(
name|rx
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
modifier|*
name|mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
modifier|*
name|size
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|total_nodec
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|n
decl_stmt|;
name|int
name|edgec
init|=
literal|0
decl_stmt|;
name|int
name|eclosec
init|=
literal|0
decl_stmt|;
name|int
name|se_list_consc
init|=
name|count_hash_nodes
argument_list|(
operator|&
name|rx
operator|->
name|se_list_memo
argument_list|)
decl_stmt|;
name|int
name|nfa_setc
init|=
name|count_hash_nodes
argument_list|(
operator|&
name|rx
operator|->
name|set_list_memo
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* This takes place in two stages.   First, the total size of the    * nfa is computed, then structures are copied.      */
name|n
operator|=
name|rx
operator|->
name|nfa_states
expr_stmt|;
name|total_nodec
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
init|=
name|n
operator|->
name|edges
decl_stmt|;
name|struct
name|rx_possible_future
modifier|*
name|ec
init|=
name|n
operator|->
name|futures
decl_stmt|;
operator|++
name|total_nodec
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
operator|++
name|edgec
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|ec
condition|)
block|{
operator|++
name|eclosec
expr_stmt|;
name|ec
operator|=
name|ec
operator|->
name|next
expr_stmt|;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|total_size
operator|=
operator|(
name|total_nodec
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_state
argument_list|)
operator|+
name|edgec
operator|*
name|rx_sizeof_bitset
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|)
operator|+
name|edgec
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_edge
argument_list|)
operator|+
name|nfa_setc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_state_set
argument_list|)
operator|+
name|eclosec
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_possible_future
argument_list|)
operator|+
name|se_list_consc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_se_list
argument_list|)
operator|+
name|rx
operator|->
name|reserved
operator|)
expr_stmt|;
if|if
condition|(
name|total_size
operator|>
operator|*
name|size
condition|)
block|{
operator|*
name|mem
operator|=
name|remalloc
argument_list|(
operator|*
name|mem
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mem
condition|)
operator|*
name|size
operator|=
name|total_size
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* Now we've allocated the memory; this copies the NFA. */
block|{
specifier|static
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|scratch
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|scratch_alloc
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|state_base
init|=
operator|(
expr|struct
name|rx_nfa_state
operator|*
operator|)
operator|*
name|mem
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|new_state
init|=
name|state_base
decl_stmt|;
name|struct
name|rx_nfa_edge
modifier|*
name|new_edge
init|=
operator|(
expr|struct
name|rx_nfa_edge
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|state_base
operator|+
name|total_nodec
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_state
argument_list|)
operator|)
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|new_se_list
init|=
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_edge
operator|+
name|edgec
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_edge
argument_list|)
operator|)
decl_stmt|;
name|struct
name|rx_possible_future
modifier|*
name|new_close
init|=
operator|(
operator|(
expr|struct
name|rx_possible_future
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_se_list
operator|+
name|se_list_consc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_se_list
argument_list|)
operator|)
operator|)
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|new_nfa_set
init|=
operator|(
operator|(
expr|struct
name|rx_nfa_state_set
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_close
operator|+
name|eclosec
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_possible_future
argument_list|)
operator|)
operator|)
decl_stmt|;
name|char
modifier|*
name|new_bitset
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|new_nfa_set
operator|+
name|nfa_setc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_state_set
argument_list|)
operator|)
decl_stmt|;
name|int
name|x
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|scratch_alloc
operator|<
name|total_nodec
condition|)
block|{
name|scratch
operator|=
operator|(
operator|(
expr|struct
name|rx_nfa_state
operator|*
operator|*
operator|)
name|remalloc
argument_list|(
name|scratch
argument_list|,
name|total_nodec
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|scratch
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|scratch
condition|)
name|scratch_alloc
operator|=
name|total_nodec
expr_stmt|;
else|else
block|{
name|scratch_alloc
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|n
operator|=
name|rx
operator|->
name|nfa_states
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|scratch
index|[
name|x
operator|++
index|]
operator|=
name|n
expr_stmt|;
name|qsort
argument_list|(
name|scratch
argument_list|,
name|total_nodec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_nfa_state
operator|*
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|nfacmp
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|total_nodec
condition|;
operator|++
name|x
control|)
block|{
name|struct
name|rx_possible_future
modifier|*
name|eclose
init|=
name|scratch
index|[
name|x
index|]
operator|->
name|futures
decl_stmt|;
name|struct
name|rx_nfa_edge
modifier|*
name|edge
init|=
name|scratch
index|[
name|x
index|]
operator|->
name|edges
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|cn
init|=
name|new_state
operator|++
decl_stmt|;
name|cn
operator|->
name|futures
operator|=
literal|0
expr_stmt|;
name|cn
operator|->
name|edges
operator|=
literal|0
expr_stmt|;
name|cn
operator|->
name|next
operator|=
operator|(
name|x
operator|==
name|total_nodec
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
operator|(
name|cn
operator|+
literal|1
operator|)
expr_stmt|;
name|cn
operator|->
name|id
operator|=
name|scratch
index|[
name|x
index|]
operator|->
name|id
expr_stmt|;
name|cn
operator|->
name|is_final
operator|=
name|scratch
index|[
name|x
index|]
operator|->
name|is_final
expr_stmt|;
name|cn
operator|->
name|is_start
operator|=
name|scratch
index|[
name|x
index|]
operator|->
name|is_start
expr_stmt|;
name|cn
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|edge
condition|)
block|{
name|int
name|indx
init|=
operator|(
name|edge
operator|->
name|dest
operator|->
name|id
operator|<
literal|0
condition|?
operator|(
name|total_nodec
operator|+
name|edge
operator|->
name|dest
operator|->
name|id
operator|)
else|:
name|edge
operator|->
name|dest
operator|->
name|id
operator|)
decl_stmt|;
name|struct
name|rx_nfa_edge
modifier|*
name|e
init|=
name|new_edge
operator|++
decl_stmt|;
name|rx_Bitset
name|cset
init|=
operator|(
name|rx_Bitset
operator|)
name|new_bitset
decl_stmt|;
name|new_bitset
operator|+=
name|rx_sizeof_bitset
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|)
expr_stmt|;
name|rx_bitset_null
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|cset
argument_list|)
expr_stmt|;
name|rx_bitset_union
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|cset
argument_list|,
name|edge
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|cn
operator|->
name|edges
expr_stmt|;
name|cn
operator|->
name|edges
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|edge
operator|->
name|type
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|state_base
operator|+
name|indx
expr_stmt|;
name|e
operator|->
name|params
operator|.
name|cset
operator|=
name|cset
expr_stmt|;
name|edge
operator|=
name|edge
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|eclose
condition|)
block|{
name|struct
name|rx_possible_future
modifier|*
name|ec
init|=
name|new_close
operator|++
decl_stmt|;
name|struct
name|rx_hash_item
modifier|*
name|sp
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
modifier|*
name|sepos
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|sesrc
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|destlst
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
modifier|*
name|destpos
decl_stmt|;
name|ec
operator|->
name|next
operator|=
name|cn
operator|->
name|futures
expr_stmt|;
name|cn
operator|->
name|futures
operator|=
name|ec
expr_stmt|;
for|for
control|(
name|sepos
operator|=
operator|&
name|ec
operator|->
name|effects
operator|,
name|sesrc
operator|=
name|eclose
operator|->
name|effects
init|;
name|sesrc
condition|;
name|sesrc
operator|=
name|sesrc
operator|->
name|cdr
operator|,
name|sepos
operator|=
operator|&
operator|(
operator|*
name|sepos
operator|)
operator|->
name|cdr
control|)
block|{
name|sp
operator|=
name|rx_hash_find
argument_list|(
operator|&
name|rx
operator|->
name|se_list_memo
argument_list|,
operator|(
name|long
operator|)
name|sesrc
operator|->
name|car
operator|^
operator|(
name|long
operator|)
name|sesrc
operator|->
name|cdr
argument_list|,
name|sesrc
argument_list|,
operator|&
name|se_list_hash_rules
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|binding
condition|)
block|{
name|sesrc
operator|=
operator|(
expr|struct
name|rx_se_list
operator|*
operator|)
name|sp
operator|->
name|binding
expr_stmt|;
break|break;
block|}
operator|*
name|new_se_list
operator|=
operator|*
name|sesrc
expr_stmt|;
name|sp
operator|->
name|binding
operator|=
operator|(
name|void
operator|*
operator|)
name|new_se_list
expr_stmt|;
operator|*
name|sepos
operator|=
name|new_se_list
expr_stmt|;
operator|++
name|new_se_list
expr_stmt|;
block|}
operator|*
name|sepos
operator|=
name|sesrc
expr_stmt|;
for|for
control|(
name|destpos
operator|=
operator|&
name|ec
operator|->
name|destset
operator|,
name|destlst
operator|=
name|eclose
operator|->
name|destset
init|;
name|destlst
condition|;
name|destpos
operator|=
operator|&
operator|(
operator|*
name|destpos
operator|)
operator|->
name|cdr
operator|,
name|destlst
operator|=
name|destlst
operator|->
name|cdr
control|)
block|{
name|sp
operator|=
name|rx_hash_find
argument_list|(
operator|&
name|rx
operator|->
name|set_list_memo
argument_list|,
operator|(
operator|(
operator|(
operator|(
name|long
operator|)
name|destlst
operator|->
name|car
operator|)
operator|>>
literal|8
operator|)
operator|^
operator|(
name|long
operator|)
name|destlst
operator|->
name|cdr
operator|)
argument_list|,
name|destlst
argument_list|,
operator|&
name|nfa_set_hash_rules
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|binding
condition|)
block|{
name|destlst
operator|=
operator|(
expr|struct
name|rx_nfa_state_set
operator|*
operator|)
name|sp
operator|->
name|binding
expr_stmt|;
break|break;
block|}
operator|*
name|new_nfa_set
operator|=
operator|*
name|destlst
expr_stmt|;
name|new_nfa_set
operator|->
name|car
operator|=
name|state_base
operator|+
name|destlst
operator|->
name|car
operator|->
name|id
expr_stmt|;
name|sp
operator|->
name|binding
operator|=
operator|(
name|void
operator|*
operator|)
name|new_nfa_set
expr_stmt|;
operator|*
name|destpos
operator|=
name|new_nfa_set
expr_stmt|;
operator|++
name|new_nfa_set
expr_stmt|;
block|}
operator|*
name|destpos
operator|=
name|destlst
expr_stmt|;
name|eclose
operator|=
name|eclose
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|rx_free_hash_table
argument_list|(
operator|&
name|rx
operator|->
name|se_list_memo
argument_list|,
name|se_memo_freer
argument_list|,
operator|&
name|se_list_hash_rules
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rx
operator|->
name|se_list_memo
argument_list|,
sizeof|sizeof
argument_list|(
name|rx
operator|->
name|se_list_memo
argument_list|)
argument_list|)
expr_stmt|;
name|rx_free_hash_table
argument_list|(
operator|&
name|rx
operator|->
name|set_list_memo
argument_list|,
name|nfa_set_freer
argument_list|,
operator|&
name|nfa_set_hash_rules
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rx
operator|->
name|set_list_memo
argument_list|,
sizeof|sizeof
argument_list|(
name|rx
operator|->
name|set_list_memo
argument_list|)
argument_list|)
expr_stmt|;
name|rx_free_nfa
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|rx
operator|->
name|nfa_states
operator|=
operator|(
expr|struct
name|rx_nfa_state
operator|*
operator|)
operator|*
name|mem
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The functions in the next several pages define the lazy-NFA-conversion used  * by matchers.  The input to this construction is an NFA such as   * is built by compactify_nfa (rx.c).  The output is the superNFA.  */
end_comment

begin_comment
comment|/* Match engines can use arbitrary values for opcodes.  So, the parse tree   * is built using instructions names (enum rx_opcode), but the superstate  * nfa is populated with mystery opcodes (void *).  *  * For convenience, here is an id table.  The opcodes are == to their inxs  *  * The lables in re_search_2 would make good values for instructions.  */
end_comment

begin_decl_stmt
name|void
modifier|*
name|rx_id_instruction_table
index|[
name|rx_num_instructions
index|]
init|=
block|{
operator|(
name|void
operator|*
operator|)
name|rx_backtrack_point
block|,
operator|(
name|void
operator|*
operator|)
name|rx_do_side_effects
block|,
operator|(
name|void
operator|*
operator|)
name|rx_cache_miss
block|,
operator|(
name|void
operator|*
operator|)
name|rx_next_char
block|,
operator|(
name|void
operator|*
operator|)
name|rx_backtrack
block|,
operator|(
name|void
operator|*
operator|)
name|rx_error_inx
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Memory mgt. for superstate graphs. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rx_cache_malloc
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
name|int
name|bytes
argument_list|)
else|#
directive|else
decl|static
name|char
modifier|*
name|rx_cache_malloc
argument_list|(
name|cache
argument_list|,
name|bytes
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
while|while
condition|(
name|cache
operator|->
name|bytes_left
operator|<
name|bytes
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|memory_pos
condition|)
name|cache
operator|->
name|memory_pos
operator|=
name|cache
operator|->
name|memory_pos
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|memory_pos
condition|)
block|{
name|cache
operator|->
name|morecore
argument_list|(
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|memory_pos
condition|)
return|return
literal|0
return|;
block|}
name|cache
operator|->
name|bytes_left
operator|=
name|cache
operator|->
name|memory_pos
operator|->
name|bytes
expr_stmt|;
name|cache
operator|->
name|memory_addr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|cache
operator|->
name|memory_pos
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rx_blocklist
argument_list|)
operator|)
expr_stmt|;
block|}
name|cache
operator|->
name|bytes_left
operator|-=
name|bytes
expr_stmt|;
block|{
name|char
modifier|*
name|addr
init|=
name|cache
operator|->
name|memory_addr
decl_stmt|;
name|cache
operator|->
name|memory_addr
operator|+=
name|bytes
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|rx_cache_free
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
expr|struct
name|rx_freelist
operator|*
operator|*
name|freelist
argument_list|,
name|char
operator|*
name|mem
argument_list|)
else|#
directive|else
decl|static
name|void
name|rx_cache_free
argument_list|(
name|cache
argument_list|,
name|freelist
argument_list|,
name|mem
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_freelist
modifier|*
modifier|*
name|freelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mem
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_freelist
modifier|*
name|it
init|=
operator|(
expr|struct
name|rx_freelist
operator|*
operator|)
name|mem
decl_stmt|;
name|it
operator|->
name|next
operator|=
operator|*
name|freelist
expr_stmt|;
operator|*
name|freelist
operator|=
name|it
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The partially instantiated superstate graph has a transition   * table at every node.  There is one entry for every character.  * This fills in the transition for a set.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|install_transition
argument_list|(
expr|struct
name|rx_superstate
operator|*
name|super
argument_list|,
expr|struct
name|rx_inx
operator|*
name|answer
argument_list|,
name|rx_Bitset
name|trcset
argument_list|)
else|#
directive|else
decl|static
name|void
name|install_transition
argument_list|(
name|super
argument_list|,
name|answer
argument_list|,
name|trcset
argument_list|)
decl|struct
name|rx_superstate
modifier|*
name|super
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_inx
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|trcset
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_inx
modifier|*
name|transitions
init|=
name|super
operator|->
name|transitions
decl_stmt|;
name|int
name|chr
decl_stmt|;
for|for
control|(
name|chr
operator|=
literal|0
init|;
name|chr
operator|<
literal|256
condition|;
control|)
if|if
condition|(
operator|!
operator|*
name|trcset
condition|)
block|{
operator|++
name|trcset
expr_stmt|;
name|chr
operator|+=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|RX_subset
name|sub
init|=
operator|*
name|trcset
decl_stmt|;
name|RX_subset
name|mask
init|=
literal|1
decl_stmt|;
name|int
name|bound
init|=
name|chr
operator|+
literal|32
decl_stmt|;
while|while
condition|(
name|chr
operator|<
name|bound
condition|)
block|{
if|if
condition|(
name|sub
operator|&
name|mask
condition|)
name|transitions
index|[
name|chr
index|]
operator|=
operator|*
name|answer
expr_stmt|;
operator|++
name|chr
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
operator|++
name|trcset
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|qlen
argument_list|(
expr|struct
name|rx_superstate
operator|*
name|q
argument_list|)
else|#
directive|else
decl|static
name|int
name|qlen
argument_list|(
name|q
argument_list|)
decl|struct
name|rx_superstate
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
literal|0
return|;
for|for
control|(
name|it
operator|=
name|q
operator|->
name|next_recyclable
init|;
name|it
operator|!=
name|q
condition|;
name|it
operator|=
name|it
operator|->
name|next_recyclable
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|check_cache
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|)
else|#
directive|else
decl|static
name|void
name|check_cache
argument_list|(
name|cache
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_cache
modifier|*
name|you_fucked_up
init|=
literal|0
decl_stmt|;
name|int
name|total
init|=
name|cache
operator|->
name|superstates
decl_stmt|;
name|int
name|semi
init|=
name|cache
operator|->
name|semifree_superstates
decl_stmt|;
if|if
condition|(
name|semi
operator|!=
name|qlen
argument_list|(
name|cache
operator|->
name|semifree_superstate
argument_list|)
condition|)
name|check_cache
argument_list|(
name|you_fucked_up
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|total
operator|-
name|semi
operator|)
operator|!=
name|qlen
argument_list|(
name|cache
operator|->
name|lru_superstate
argument_list|)
condition|)
name|check_cache
argument_list|(
name|you_fucked_up
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When a superstate is old and neglected, it can enter a   * semi-free state.  A semi-free state is slated to die.  * Incoming transitions to a semi-free state are re-written  * to cause an (interpreted) fault when they are taken.  * The fault handler revives the semi-free state, patches  * incoming transitions back to normal, and continues.  *  * The idea is basicly to free in two stages, aborting   * between the two if the state turns out to be useful again.  * When a free is aborted, the rescued superstate is placed  * in the most-favored slot to maximize the time until it  * is next semi-freed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|semifree_superstate
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|)
else|#
directive|else
decl|static
name|void
name|semifree_superstate
argument_list|(
name|cache
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|disqualified
init|=
name|cache
operator|->
name|semifree_superstates
decl_stmt|;
if|if
condition|(
name|disqualified
operator|==
name|cache
operator|->
name|superstates
condition|)
return|return;
while|while
condition|(
name|cache
operator|->
name|lru_superstate
operator|->
name|locks
condition|)
block|{
name|cache
operator|->
name|lru_superstate
operator|=
name|cache
operator|->
name|lru_superstate
operator|->
name|next_recyclable
expr_stmt|;
operator|++
name|disqualified
expr_stmt|;
if|if
condition|(
name|disqualified
operator|==
name|cache
operator|->
name|superstates
condition|)
return|return;
block|}
block|{
name|struct
name|rx_superstate
modifier|*
name|it
init|=
name|cache
operator|->
name|lru_superstate
decl_stmt|;
name|it
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|it
operator|->
name|prev_recyclable
expr_stmt|;
name|it
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|it
operator|->
name|next_recyclable
expr_stmt|;
name|cache
operator|->
name|lru_superstate
operator|=
operator|(
name|it
operator|==
name|it
operator|->
name|next_recyclable
condition|?
literal|0
else|:
name|it
operator|->
name|next_recyclable
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|semifree_superstate
condition|)
block|{
name|cache
operator|->
name|semifree_superstate
operator|=
name|it
expr_stmt|;
name|it
operator|->
name|next_recyclable
operator|=
name|it
expr_stmt|;
name|it
operator|->
name|prev_recyclable
operator|=
name|it
expr_stmt|;
block|}
else|else
block|{
name|it
operator|->
name|prev_recyclable
operator|=
name|cache
operator|->
name|semifree_superstate
operator|->
name|prev_recyclable
expr_stmt|;
name|it
operator|->
name|next_recyclable
operator|=
name|cache
operator|->
name|semifree_superstate
expr_stmt|;
name|it
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|it
expr_stmt|;
name|it
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|it
expr_stmt|;
block|}
block|{
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
name|it
operator|->
name|is_semifree
operator|=
literal|1
expr_stmt|;
operator|++
name|cache
operator|->
name|semifree_superstates
expr_stmt|;
name|df
operator|=
name|it
operator|->
name|transition_refs
expr_stmt|;
if|if
condition|(
name|df
condition|)
block|{
name|df
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|df
operator|=
name|it
operator|->
name|transition_refs
init|;
name|df
condition|;
name|df
operator|=
name|df
operator|->
name|next_same_dest
control|)
block|{
name|df
operator|->
name|future_frame
operator|.
name|inx
operator|=
name|cache
operator|->
name|instruction_table
index|[
name|rx_cache_miss
index|]
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data_2
operator|=
operator|(
name|void
operator|*
operator|)
name|df
expr_stmt|;
comment|/* If there are any NEXT-CHAR instruction frames that 	       * refer to this state, we convert them to CACHE-MISS frames. 	       */
if|if
condition|(
operator|!
name|df
operator|->
name|effects
operator|&&
operator|(
name|df
operator|->
name|edge
operator|->
name|options
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|==
name|df
operator|->
name|edge
operator|->
name|options
operator|)
condition|)
name|install_transition
argument_list|(
name|df
operator|->
name|present
argument_list|,
operator|&
name|df
operator|->
name|future_frame
argument_list|,
name|df
operator|->
name|edge
operator|->
name|cset
argument_list|)
expr_stmt|;
block|}
name|df
operator|=
name|it
operator|->
name|transition_refs
expr_stmt|;
name|df
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
name|df
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|refresh_semifree_superstate
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
expr|struct
name|rx_superstate
operator|*
name|super
argument_list|)
else|#
directive|else
decl|static
name|void
name|refresh_semifree_superstate
argument_list|(
name|cache
argument_list|,
name|super
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superstate
modifier|*
name|super
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
if|if
condition|(
name|super
operator|->
name|transition_refs
condition|)
block|{
name|super
operator|->
name|transition_refs
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|df
operator|=
name|super
operator|->
name|transition_refs
init|;
name|df
condition|;
name|df
operator|=
name|df
operator|->
name|next_same_dest
control|)
block|{
name|df
operator|->
name|future_frame
operator|.
name|inx
operator|=
name|cache
operator|->
name|instruction_table
index|[
name|rx_next_char
index|]
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|super
operator|->
name|transitions
expr_stmt|;
comment|/* CACHE-MISS instruction frames that refer to this state, 	   * must be converted to NEXT-CHAR frames. 	   */
if|if
condition|(
operator|!
name|df
operator|->
name|effects
operator|&&
operator|(
name|df
operator|->
name|edge
operator|->
name|options
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|==
name|df
operator|->
name|edge
operator|->
name|options
operator|)
condition|)
name|install_transition
argument_list|(
name|df
operator|->
name|present
argument_list|,
operator|&
name|df
operator|->
name|future_frame
argument_list|,
name|df
operator|->
name|edge
operator|->
name|cset
argument_list|)
expr_stmt|;
block|}
name|super
operator|->
name|transition_refs
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
name|super
operator|->
name|transition_refs
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|semifree_superstate
operator|==
name|super
condition|)
name|cache
operator|->
name|semifree_superstate
operator|=
operator|(
name|super
operator|->
name|prev_recyclable
operator|==
name|super
condition|?
literal|0
else|:
name|super
operator|->
name|prev_recyclable
operator|)
expr_stmt|;
name|super
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|super
operator|->
name|prev_recyclable
expr_stmt|;
name|super
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|super
operator|->
name|next_recyclable
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|lru_superstate
condition|)
operator|(
name|cache
operator|->
name|lru_superstate
operator|=
name|super
operator|->
name|next_recyclable
operator|=
name|super
operator|->
name|prev_recyclable
operator|=
name|super
operator|)
expr_stmt|;
else|else
block|{
name|super
operator|->
name|next_recyclable
operator|=
name|cache
operator|->
name|lru_superstate
expr_stmt|;
name|super
operator|->
name|prev_recyclable
operator|=
name|cache
operator|->
name|lru_superstate
operator|->
name|prev_recyclable
expr_stmt|;
name|super
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|super
expr_stmt|;
name|super
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|super
expr_stmt|;
block|}
name|super
operator|->
name|is_semifree
operator|=
literal|0
expr_stmt|;
operator|--
name|cache
operator|->
name|semifree_superstates
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|rx_refresh_this_superstate
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
expr|struct
name|rx_superstate
operator|*
name|superstate
argument_list|)
else|#
directive|else
decl|static
name|void
name|rx_refresh_this_superstate
argument_list|(
name|cache
argument_list|,
name|superstate
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superstate
modifier|*
name|superstate
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|superstate
operator|->
name|is_semifree
condition|)
name|refresh_semifree_superstate
argument_list|(
name|cache
argument_list|,
name|superstate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cache
operator|->
name|lru_superstate
operator|==
name|superstate
condition|)
name|cache
operator|->
name|lru_superstate
operator|=
name|superstate
operator|->
name|next_recyclable
expr_stmt|;
elseif|else
if|if
condition|(
name|superstate
operator|!=
name|cache
operator|->
name|lru_superstate
operator|->
name|prev_recyclable
condition|)
block|{
name|superstate
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|superstate
operator|->
name|prev_recyclable
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|superstate
operator|->
name|next_recyclable
expr_stmt|;
name|superstate
operator|->
name|next_recyclable
operator|=
name|cache
operator|->
name|lru_superstate
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|=
name|cache
operator|->
name|lru_superstate
operator|->
name|prev_recyclable
expr_stmt|;
name|superstate
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|superstate
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|superstate
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|release_superset_low
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
expr|struct
name|rx_superset
operator|*
name|set
argument_list|)
else|#
directive|else
decl|static
name|void
name|release_superset_low
argument_list|(
name|cache
argument_list|,
name|set
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superset
modifier|*
name|set
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
operator|--
name|set
operator|->
name|refs
condition|)
block|{
if|if
condition|(
name|set
operator|->
name|cdr
condition|)
name|release_superset_low
argument_list|(
name|cache
argument_list|,
name|set
operator|->
name|cdr
argument_list|)
expr_stmt|;
name|set
operator|->
name|starts_for
operator|=
literal|0
expr_stmt|;
name|rx_hash_free
argument_list|(
name|rx_hash_find
argument_list|(
operator|&
name|cache
operator|->
name|superset_table
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|set
operator|->
name|car
operator|^
name|set
operator|->
name|id
operator|^
operator|(
name|unsigned
name|long
operator|)
name|set
operator|->
name|cdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|set
argument_list|,
operator|&
name|cache
operator|->
name|superset_hash_rules
argument_list|)
argument_list|,
operator|&
name|cache
operator|->
name|superset_hash_rules
argument_list|)
expr_stmt|;
name|rx_cache_free
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_supersets
argument_list|,
operator|(
name|char
operator|*
operator|)
name|set
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_release_superset
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_superset
operator|*
name|set
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_release_superset
argument_list|(
name|rx
argument_list|,
name|set
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superset
modifier|*
name|set
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|release_superset_low
argument_list|(
name|rx
operator|->
name|cache
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This tries to add a new superstate to the superstate freelist.  * It might, as a result, free some edge pieces or hash tables.  * If nothing can be freed because too many locks are being held, fail.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|rx_really_free_superstate
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|)
else|#
directive|else
decl|static
name|int
name|rx_really_free_superstate
argument_list|(
name|cache
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|locked_superstates
init|=
literal|0
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|superstates
condition|)
return|return
literal|0
return|;
block|{
comment|/* This is a total guess.  The idea is that we should expect as      * many misses as we've recently experienced.  I.e., cache->misses      * should be the same as cache->semifree_superstates.      */
while|while
condition|(
operator|(
name|cache
operator|->
name|hits
operator|+
name|cache
operator|->
name|misses
operator|)
operator|>
name|cache
operator|->
name|superstates_allowed
condition|)
block|{
name|cache
operator|->
name|hits
operator|>>=
literal|1
expr_stmt|;
name|cache
operator|->
name|misses
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|cache
operator|->
name|hits
operator|+
name|cache
operator|->
name|misses
operator|)
operator|*
name|cache
operator|->
name|semifree_superstates
operator|)
operator|<
operator|(
name|cache
operator|->
name|superstates
operator|*
name|cache
operator|->
name|misses
operator|)
condition|)
block|{
name|semifree_superstate
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|semifree_superstate
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|cache
operator|->
name|semifree_superstate
operator|&&
name|cache
operator|->
name|semifree_superstate
operator|->
name|locks
condition|)
block|{
name|refresh_semifree_superstate
argument_list|(
name|cache
argument_list|,
name|cache
operator|->
name|semifree_superstate
argument_list|)
expr_stmt|;
operator|++
name|locked_superstates
expr_stmt|;
if|if
condition|(
name|locked_superstates
operator|==
name|cache
operator|->
name|superstates
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cache
operator|->
name|semifree_superstate
condition|)
block|{
name|it
operator|=
name|cache
operator|->
name|semifree_superstate
expr_stmt|;
name|it
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|it
operator|->
name|prev_recyclable
expr_stmt|;
name|it
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|it
operator|->
name|next_recyclable
expr_stmt|;
name|cache
operator|->
name|semifree_superstate
operator|=
operator|(
operator|(
name|it
operator|==
name|it
operator|->
name|next_recyclable
operator|)
condition|?
literal|0
else|:
name|it
operator|->
name|next_recyclable
operator|)
expr_stmt|;
operator|--
name|cache
operator|->
name|semifree_superstates
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|cache
operator|->
name|lru_superstate
operator|->
name|locks
condition|)
block|{
name|cache
operator|->
name|lru_superstate
operator|=
name|cache
operator|->
name|lru_superstate
operator|->
name|next_recyclable
expr_stmt|;
operator|++
name|locked_superstates
expr_stmt|;
if|if
condition|(
name|locked_superstates
operator|==
name|cache
operator|->
name|superstates
condition|)
return|return
literal|0
return|;
block|}
name|it
operator|=
name|cache
operator|->
name|lru_superstate
expr_stmt|;
name|it
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|it
operator|->
name|prev_recyclable
expr_stmt|;
name|it
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|it
operator|->
name|next_recyclable
expr_stmt|;
name|cache
operator|->
name|lru_superstate
operator|=
operator|(
operator|(
name|it
operator|==
name|it
operator|->
name|next_recyclable
operator|)
condition|?
literal|0
else|:
name|it
operator|->
name|next_recyclable
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|transition_refs
condition|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
for|for
control|(
name|df
operator|=
name|it
operator|->
name|transition_refs
operator|,
name|df
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
literal|0
init|;
name|df
condition|;
name|df
operator|=
name|df
operator|->
name|next_same_dest
control|)
block|{
name|df
operator|->
name|future_frame
operator|.
name|inx
operator|=
name|cache
operator|->
name|instruction_table
index|[
name|rx_cache_miss
index|]
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data_2
operator|=
operator|(
name|void
operator|*
operator|)
name|df
expr_stmt|;
name|df
operator|->
name|future
operator|=
literal|0
expr_stmt|;
block|}
name|it
operator|->
name|transition_refs
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
name|it
operator|->
name|transition_refs
expr_stmt|;
block|}
block|{
name|struct
name|rx_super_edge
modifier|*
name|tc
init|=
name|it
operator|->
name|edges
decl_stmt|;
while|while
condition|(
name|tc
condition|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
name|struct
name|rx_super_edge
modifier|*
name|tct
init|=
name|tc
operator|->
name|next
decl_stmt|;
name|df
operator|=
name|tc
operator|->
name|options
expr_stmt|;
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|df
condition|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|dft
init|=
name|df
decl_stmt|;
name|df
operator|=
name|df
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dft
operator|->
name|future
operator|&&
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|==
name|dft
condition|)
block|{
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|=
name|dft
operator|->
name|next_same_dest
expr_stmt|;
if|if
condition|(
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|==
name|dft
condition|)
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|=
literal|0
expr_stmt|;
block|}
name|dft
operator|->
name|next_same_dest
operator|->
name|prev_same_dest
operator|=
name|dft
operator|->
name|prev_same_dest
expr_stmt|;
name|dft
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
name|dft
operator|->
name|next_same_dest
expr_stmt|;
name|rx_cache_free
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_discernable_futures
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dft
argument_list|)
expr_stmt|;
block|}
name|rx_cache_free
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_transition_classes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tc
argument_list|)
expr_stmt|;
name|tc
operator|=
name|tct
expr_stmt|;
block|}
block|}
if|if
condition|(
name|it
operator|->
name|contents
operator|->
name|superstate
operator|==
name|it
condition|)
name|it
operator|->
name|contents
operator|->
name|superstate
operator|=
literal|0
expr_stmt|;
name|release_superset_low
argument_list|(
name|cache
argument_list|,
name|it
operator|->
name|contents
argument_list|)
expr_stmt|;
name|rx_cache_free
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_superstates
argument_list|,
operator|(
name|char
operator|*
operator|)
name|it
argument_list|)
expr_stmt|;
operator|--
name|cache
operator|->
name|superstates
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rx_cache_get
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
expr|struct
name|rx_freelist
operator|*
operator|*
name|freelist
argument_list|)
else|#
directive|else
decl|static
name|char
modifier|*
name|rx_cache_get
argument_list|(
name|cache
argument_list|,
name|freelist
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_freelist
modifier|*
modifier|*
name|freelist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
while|while
condition|(
operator|!
operator|*
name|freelist
operator|&&
name|rx_really_free_superstate
argument_list|(
name|cache
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|freelist
condition|)
return|return
literal|0
return|;
block|{
name|struct
name|rx_freelist
modifier|*
name|it
init|=
operator|*
name|freelist
decl_stmt|;
operator|*
name|freelist
operator|=
name|it
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|it
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rx_cache_malloc_or_get
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|,
expr|struct
name|rx_freelist
operator|*
operator|*
name|freelist
argument_list|,
name|int
name|bytes
argument_list|)
else|#
directive|else
decl|static
name|char
modifier|*
name|rx_cache_malloc_or_get
argument_list|(
name|cache
argument_list|,
name|freelist
argument_list|,
name|bytes
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_freelist
modifier|*
modifier|*
name|freelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
operator|*
name|freelist
condition|)
block|{
name|char
modifier|*
name|answer
init|=
name|rx_cache_malloc
argument_list|(
name|cache
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
condition|)
return|return
name|answer
return|;
block|}
return|return
name|rx_cache_get
argument_list|(
name|cache
argument_list|,
name|freelist
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rx_cache_get_superstate
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|)
else|#
directive|else
decl|static
name|char
modifier|*
name|rx_cache_get_superstate
argument_list|(
name|cache
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
modifier|*
name|answer
decl_stmt|;
name|int
name|bytes
init|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_superstate
argument_list|)
operator|+
name|cache
operator|->
name|local_cset_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_inx
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|free_superstates
operator|&&
operator|(
name|cache
operator|->
name|superstates
operator|<
name|cache
operator|->
name|superstates_allowed
operator|)
condition|)
block|{
name|answer
operator|=
name|rx_cache_malloc
argument_list|(
name|cache
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
condition|)
block|{
operator|++
name|cache
operator|->
name|superstates
expr_stmt|;
return|return
name|answer
return|;
block|}
block|}
name|answer
operator|=
name|rx_cache_get
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_superstates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
name|answer
operator|=
name|rx_cache_malloc
argument_list|(
name|cache
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
condition|)
operator|++
name|cache
operator|->
name|superstates_allowed
expr_stmt|;
block|}
operator|++
name|cache
operator|->
name|superstates
expr_stmt|;
return|return
name|answer
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|supersetcmp
parameter_list|(
name|void
modifier|*
name|va
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|)
else|#
directive|else
function|static int supersetcmp
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
name|void
modifier|*
name|va
decl_stmt|;
name|void
modifier|*
name|vb
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|rx_superset
modifier|*
name|a
init|=
operator|(
expr|struct
name|rx_superset
operator|*
operator|)
name|va
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|b
init|=
operator|(
expr|struct
name|rx_superset
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|a
operator|&&
name|b
operator|&&
operator|(
name|a
operator|->
name|car
operator|==
name|b
operator|->
name|car
operator|)
operator|&&
operator|(
name|a
operator|->
name|cdr
operator|==
name|b
operator|->
name|cdr
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_hash_item
modifier|*
name|superset_allocator
argument_list|(
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|,
name|void
operator|*
name|val
argument_list|)
else|#
directive|else
decl|static struct
name|rx_hash_item
modifier|*
name|superset_allocator
argument_list|(
name|rules
argument_list|,
name|val
argument_list|)
decl|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_cache
modifier|*
name|cache
init|=
operator|(
operator|(
expr|struct
name|rx_cache
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rules
operator|-
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|rx_cache
operator|*
operator|)
literal|0
operator|)
operator|->
name|superset_hash_rules
argument_list|)
operator|)
operator|)
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|template
init|=
operator|(
expr|struct
name|rx_superset
operator|*
operator|)
name|val
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|newset
init|=
operator|(
operator|(
expr|struct
name|rx_superset
operator|*
operator|)
name|rx_cache_malloc_or_get
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_supersets
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|template
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|newset
condition|)
return|return
literal|0
return|;
name|newset
operator|->
name|refs
operator|=
literal|0
expr_stmt|;
name|newset
operator|->
name|car
operator|=
name|template
operator|->
name|car
expr_stmt|;
name|newset
operator|->
name|id
operator|=
name|template
operator|->
name|car
operator|->
name|id
expr_stmt|;
name|newset
operator|->
name|cdr
operator|=
name|template
operator|->
name|cdr
expr_stmt|;
name|newset
operator|->
name|superstate
operator|=
literal|0
expr_stmt|;
name|rx_protect_superset
argument_list|(
name|rx
argument_list|,
name|template
operator|->
name|cdr
argument_list|)
expr_stmt|;
name|newset
operator|->
name|hash_item
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|newset
expr_stmt|;
name|newset
operator|->
name|hash_item
operator|.
name|binding
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|newset
operator|->
name|hash_item
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_hash
modifier|*
name|super_hash_allocator
argument_list|(
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
decl|static struct
name|rx_hash
modifier|*
name|super_hash_allocator
argument_list|(
name|rules
argument_list|)
decl|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_cache
modifier|*
name|cache
init|=
operator|(
operator|(
expr|struct
name|rx_cache
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rules
operator|-
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|rx_cache
operator|*
operator|)
literal|0
operator|)
operator|->
name|superset_hash_rules
argument_list|)
operator|)
operator|)
decl_stmt|;
return|return
operator|(
operator|(
expr|struct
name|rx_hash
operator|*
operator|)
name|rx_cache_malloc_or_get
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_hash
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_hash
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|super_hash_liberator
argument_list|(
expr|struct
name|rx_hash
operator|*
name|hash
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
decl|static
name|void
name|super_hash_liberator
argument_list|(
name|hash
argument_list|,
name|rules
argument_list|)
decl|struct
name|rx_hash
modifier|*
name|hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_cache
modifier|*
name|cache
init|=
operator|(
operator|(
expr|struct
name|rx_cache
operator|*
operator|)
operator|(
name|char
operator|*
operator|)
name|rules
operator|-
call|(
name|long
call|)
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|rx_cache
operator|*
operator|)
literal|0
operator|)
operator|->
name|superset_hash_rules
argument_list|)
operator|)
decl_stmt|;
name|rx_cache_free
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_hash
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hash
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|superset_hash_item_liberator
argument_list|(
expr|struct
name|rx_hash_item
operator|*
name|it
argument_list|,
expr|struct
name|rx_hash_rules
operator|*
name|rules
argument_list|)
else|#
directive|else
decl|static
name|void
name|superset_hash_item_liberator
argument_list|(
name|it
argument_list|,
name|rules
argument_list|)
comment|/* Well, it does ya know. */
decl|struct
name|rx_hash_item
modifier|*
name|it
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_hash_rules
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{ }
end_block

begin_decl_stmt
name|int
name|rx_cache_bound
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rx_default_cache_got
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|int
name|bytes_for_cache_size
parameter_list|(
name|int
name|supers
parameter_list|,
name|int
name|cset_size
parameter_list|)
else|#
directive|else
function|static int bytes_for_cache_size
parameter_list|(
name|supers
parameter_list|,
name|cset_size
parameter_list|)
name|int
name|supers
decl_stmt|;
name|int
name|cset_size
decl_stmt|;
endif|#
directive|endif
block|{
comment|/* What the hell is this? !!!*/
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|supers
operator|*
operator|(
operator|(
literal|1.03
operator|*
call|(
name|float
call|)
argument_list|(
name|rx_sizeof_bitset
argument_list|(
name|cset_size
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rx_super_edge
argument_list|)
argument_list|)
operator|)
operator|+
operator|(
literal|1.80
operator|*
operator|(
name|float
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|rx_possible_future
argument_list|)
operator|)
operator|+
call|(
name|float
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_superstate
argument_list|)
operator|+
name|cset_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rx_inx
argument_list|)
argument_list|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|rx_morecore
argument_list|(
expr|struct
name|rx_cache
operator|*
name|cache
argument_list|)
else|#
directive|else
decl|static
name|void
name|rx_morecore
argument_list|(
name|cache
argument_list|)
decl|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|rx_default_cache_got
operator|>=
name|rx_cache_bound
condition|)
return|return;
name|rx_default_cache_got
operator|+=
literal|16
expr_stmt|;
name|cache
operator|->
name|superstates_allowed
operator|=
name|rx_cache_bound
expr_stmt|;
block|{
name|struct
name|rx_blocklist
modifier|*
modifier|*
name|pos
init|=
operator|&
name|cache
operator|->
name|memory
decl_stmt|;
name|int
name|size
init|=
name|bytes_for_cache_size
argument_list|(
literal|16
argument_list|,
name|cache
operator|->
name|local_cset_size
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|pos
condition|)
name|pos
operator|=
operator|&
operator|(
operator|*
name|pos
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pos
operator|=
operator|(
operator|(
expr|struct
name|rx_blocklist
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rx_blocklist
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pos
condition|)
return|return;
operator|(
operator|*
name|pos
operator|)
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|->
name|bytes
operator|=
name|size
expr_stmt|;
name|cache
operator|->
name|memory_pos
operator|=
operator|*
name|pos
expr_stmt|;
name|cache
operator|->
name|memory_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|pos
operator|+
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pos
argument_list|)
expr_stmt|;
name|cache
operator|->
name|bytes_left
operator|=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|rx_cache
name|default_cache
init|=
block|{
block|{
name|supersetcmp
block|,
name|super_hash_allocator
block|,
name|super_hash_liberator
block|,
name|superset_allocator
block|,
name|superset_hash_item_liberator
block|,   }
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|rx_morecore
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|128
block|,
literal|256
block|,
name|rx_id_instruction_table
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This adds an element to a superstate set.  These sets are lists, such  * that lists with == elements are ==.  The empty set is returned by  * superset_cons (rx, 0, 0) and is NOT equivelent to   * (struct rx_superset)0.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_superset
modifier|*
name|rx_superset_cons
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|car
argument_list|,
expr|struct
name|rx_superset
operator|*
name|cdr
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_superset
modifier|*
name|rx_superset_cons
argument_list|(
name|rx
argument_list|,
name|car
argument_list|,
name|cdr
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|car
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superset
modifier|*
name|cdr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_cache
modifier|*
name|cache
init|=
name|rx
operator|->
name|cache
decl_stmt|;
if|if
condition|(
operator|!
name|car
operator|&&
operator|!
name|cdr
condition|)
block|{
if|if
condition|(
operator|!
name|cache
operator|->
name|empty_superset
condition|)
block|{
name|cache
operator|->
name|empty_superset
operator|=
operator|(
operator|(
expr|struct
name|rx_superset
operator|*
operator|)
name|rx_cache_malloc_or_get
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_supersets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_superset
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|empty_superset
condition|)
return|return
literal|0
return|;
name|bzero
argument_list|(
name|cache
operator|->
name|empty_superset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_superset
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|empty_superset
operator|->
name|refs
operator|=
literal|1000
expr_stmt|;
block|}
return|return
name|cache
operator|->
name|empty_superset
return|;
block|}
block|{
name|struct
name|rx_superset
name|template
decl_stmt|;
name|struct
name|rx_hash_item
modifier|*
name|hit
decl_stmt|;
name|template
operator|.
name|car
operator|=
name|car
expr_stmt|;
name|template
operator|.
name|cdr
operator|=
name|cdr
expr_stmt|;
name|template
operator|.
name|id
operator|=
name|car
operator|->
name|id
expr_stmt|;
name|hit
operator|=
name|rx_hash_store
argument_list|(
operator|&
name|cache
operator|->
name|superset_table
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|car
operator|^
name|car
operator|->
name|id
operator|^
operator|(
name|unsigned
name|long
operator|)
name|cdr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|template
argument_list|,
operator|&
name|cache
operator|->
name|superset_hash_rules
argument_list|)
expr_stmt|;
return|return
operator|(
name|hit
condition|?
operator|(
expr|struct
name|rx_superset
operator|*
operator|)
name|hit
operator|->
name|data
else|:
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* This computes a union of two NFA state sets.  The sets do not have the  * same representation though.  One is a RX_SUPERSET structure (part  * of the superstate NFA) and the other is an NFA_STATE_SET (part of the NFA).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_superset
modifier|*
name|rx_superstate_eclosure_union
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_superset
operator|*
name|set
argument_list|,
expr|struct
name|rx_nfa_state_set
operator|*
name|ecl
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_superset
modifier|*
name|rx_superstate_eclosure_union
argument_list|(
name|rx
argument_list|,
name|set
argument_list|,
name|ecl
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superset
modifier|*
name|set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state_set
modifier|*
name|ecl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|ecl
condition|)
return|return
name|set
return|;
if|if
condition|(
operator|!
name|set
operator|->
name|car
condition|)
return|return
name|rx_superset_cons
argument_list|(
name|rx
argument_list|,
name|ecl
operator|->
name|car
argument_list|,
name|rx_superstate_eclosure_union
argument_list|(
name|rx
argument_list|,
name|set
argument_list|,
name|ecl
operator|->
name|cdr
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|set
operator|->
name|car
operator|==
name|ecl
operator|->
name|car
condition|)
return|return
name|rx_superstate_eclosure_union
argument_list|(
name|rx
argument_list|,
name|set
argument_list|,
name|ecl
operator|->
name|cdr
argument_list|)
return|;
block|{
name|struct
name|rx_superset
modifier|*
name|tail
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|first
decl_stmt|;
if|if
condition|(
name|set
operator|->
name|car
operator|>
name|ecl
operator|->
name|car
condition|)
block|{
name|tail
operator|=
name|rx_superstate_eclosure_union
argument_list|(
name|rx
argument_list|,
name|set
operator|->
name|cdr
argument_list|,
name|ecl
argument_list|)
expr_stmt|;
name|first
operator|=
name|set
operator|->
name|car
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|=
name|rx_superstate_eclosure_union
argument_list|(
name|rx
argument_list|,
name|set
argument_list|,
name|ecl
operator|->
name|cdr
argument_list|)
expr_stmt|;
name|first
operator|=
name|ecl
operator|->
name|car
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tail
condition|)
return|return
literal|0
return|;
else|else
block|{
name|struct
name|rx_superset
modifier|*
name|answer
decl_stmt|;
name|answer
operator|=
name|rx_superset_cons
argument_list|(
name|rx
argument_list|,
name|first
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
name|rx_protect_superset
argument_list|(
name|rx
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|rx_release_superset
argument_list|(
name|rx
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|answer
return|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * This makes sure that a list of rx_distinct_futures contains  * a future for each possible set of side effects in the eclosure  * of a given state.  This is some of the work of filling in a  * superstate transition.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_distinct_future
modifier|*
name|include_futures
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_distinct_future
operator|*
name|df
argument_list|,
expr|struct
name|rx_nfa_state
operator|*
name|state
argument_list|,
expr|struct
name|rx_superstate
operator|*
name|superstate
argument_list|)
else|#
directive|else
decl|static struct
name|rx_distinct_future
modifier|*
name|include_futures
argument_list|(
name|rx
argument_list|,
name|df
argument_list|,
name|state
argument_list|,
name|superstate
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_nfa_state
modifier|*
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superstate
modifier|*
name|superstate
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_possible_future
modifier|*
name|future
decl_stmt|;
name|struct
name|rx_cache
modifier|*
name|cache
init|=
name|rx
operator|->
name|cache
decl_stmt|;
for|for
control|(
name|future
operator|=
name|state
operator|->
name|futures
init|;
name|future
condition|;
name|future
operator|=
name|future
operator|->
name|next
control|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|dfp
decl_stmt|;
name|struct
name|rx_distinct_future
modifier|*
name|insert_before
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|df
condition|)
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dfp
operator|=
name|df
init|;
name|dfp
condition|;
name|dfp
operator|=
name|dfp
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
control|)
if|if
condition|(
name|dfp
operator|->
name|effects
operator|==
name|future
operator|->
name|effects
condition|)
break|break;
else|else
block|{
name|int
name|order
init|=
name|rx
operator|->
name|se_list_cmp
argument_list|(
name|rx
argument_list|,
name|dfp
operator|->
name|effects
argument_list|,
name|future
operator|->
name|effects
argument_list|)
decl_stmt|;
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
name|insert_before
operator|=
name|dfp
expr_stmt|;
name|dfp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|df
condition|)
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
name|df
expr_stmt|;
if|if
condition|(
operator|!
name|dfp
condition|)
block|{
name|dfp
operator|=
operator|(
operator|(
expr|struct
name|rx_distinct_future
operator|*
operator|)
name|rx_cache_malloc_or_get
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|free_discernable_futures
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_distinct_future
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dfp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|df
condition|)
block|{
name|df
operator|=
name|insert_before
operator|=
name|dfp
expr_stmt|;
name|df
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|=
name|df
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insert_before
condition|)
name|insert_before
operator|=
name|df
expr_stmt|;
elseif|else
if|if
condition|(
name|insert_before
operator|==
name|df
condition|)
name|df
operator|=
name|dfp
expr_stmt|;
name|dfp
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
name|insert_before
expr_stmt|;
name|dfp
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|=
name|insert_before
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
expr_stmt|;
name|dfp
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
name|dfp
expr_stmt|;
name|dfp
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|=
name|dfp
expr_stmt|;
name|dfp
operator|->
name|next_same_dest
operator|=
name|dfp
operator|->
name|prev_same_dest
operator|=
name|dfp
expr_stmt|;
name|dfp
operator|->
name|future
operator|=
literal|0
expr_stmt|;
name|dfp
operator|->
name|present
operator|=
name|superstate
expr_stmt|;
name|dfp
operator|->
name|future_frame
operator|.
name|inx
operator|=
name|rx
operator|->
name|instruction_table
index|[
name|rx_cache_miss
index|]
expr_stmt|;
name|dfp
operator|->
name|future_frame
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|dfp
operator|->
name|future_frame
operator|.
name|data_2
operator|=
operator|(
name|void
operator|*
operator|)
name|dfp
expr_stmt|;
name|dfp
operator|->
name|side_effects_frame
operator|.
name|inx
operator|=
name|rx
operator|->
name|instruction_table
index|[
name|rx_do_side_effects
index|]
expr_stmt|;
name|dfp
operator|->
name|side_effects_frame
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|dfp
operator|->
name|side_effects_frame
operator|.
name|data_2
operator|=
operator|(
name|void
operator|*
operator|)
name|dfp
expr_stmt|;
name|dfp
operator|->
name|effects
operator|=
name|future
operator|->
name|effects
expr_stmt|;
block|}
block|}
return|return
name|df
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This constructs a new superstate from its state set.  The only   * complexity here is memory management.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_superstate
modifier|*
name|rx_superstate
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_superset
operator|*
name|set
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_superstate
modifier|*
name|rx_superstate
argument_list|(
name|rx
argument_list|,
name|set
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superset
modifier|*
name|set
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_cache
modifier|*
name|cache
init|=
name|rx
operator|->
name|cache
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|superstate
init|=
literal|0
decl_stmt|;
comment|/* Does the superstate already exist in the cache? */
if|if
condition|(
name|set
operator|->
name|superstate
condition|)
block|{
if|if
condition|(
name|set
operator|->
name|superstate
operator|->
name|rx_id
operator|!=
name|rx
operator|->
name|rx_id
condition|)
block|{
comment|/* Aha.  It is in the cache, but belongs to a superstate 	   * that refers to an NFA that no longer exists. 	   * (We know it no longer exists because it was evidently 	   *  stored in the same region of memory as the current nfa 	   *  yet it has a different id.) 	   */
name|superstate
operator|=
name|set
operator|->
name|superstate
expr_stmt|;
if|if
condition|(
operator|!
name|superstate
operator|->
name|is_semifree
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|lru_superstate
operator|==
name|superstate
condition|)
block|{
name|cache
operator|->
name|lru_superstate
operator|=
name|superstate
operator|->
name|next_recyclable
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|lru_superstate
operator|==
name|superstate
condition|)
name|cache
operator|->
name|lru_superstate
operator|=
literal|0
expr_stmt|;
block|}
block|{
name|superstate
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|superstate
operator|->
name|prev_recyclable
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|superstate
operator|->
name|next_recyclable
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|semifree_superstate
condition|)
block|{
operator|(
name|cache
operator|->
name|semifree_superstate
operator|=
name|superstate
operator|->
name|next_recyclable
operator|=
name|superstate
operator|->
name|prev_recyclable
operator|=
name|superstate
operator|)
expr_stmt|;
block|}
else|else
block|{
name|superstate
operator|->
name|next_recyclable
operator|=
name|cache
operator|->
name|semifree_superstate
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|=
name|cache
operator|->
name|semifree_superstate
operator|->
name|prev_recyclable
expr_stmt|;
name|superstate
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|superstate
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|superstate
expr_stmt|;
name|cache
operator|->
name|semifree_superstate
operator|=
name|superstate
expr_stmt|;
block|}
operator|++
name|cache
operator|->
name|semifree_superstates
expr_stmt|;
block|}
block|}
name|set
operator|->
name|superstate
operator|=
literal|0
expr_stmt|;
goto|goto
name|handle_cache_miss
goto|;
block|}
operator|++
name|cache
operator|->
name|hits
expr_stmt|;
name|superstate
operator|=
name|set
operator|->
name|superstate
expr_stmt|;
name|rx_refresh_this_superstate
argument_list|(
name|cache
argument_list|,
name|superstate
argument_list|)
expr_stmt|;
return|return
name|superstate
return|;
block|}
name|handle_cache_miss
label|:
comment|/* This point reached only for cache misses. */
operator|++
name|cache
operator|->
name|misses
expr_stmt|;
if|#
directive|if
name|RX_DEBUG
if|if
condition|(
name|rx_debug_trace
operator|>
literal|1
condition|)
block|{
name|struct
name|rx_superset
modifier|*
name|setp
init|=
name|set
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Building a superstet %d(%d): "
argument_list|,
name|rx
operator|->
name|rx_id
argument_list|,
name|set
argument_list|)
expr_stmt|;
while|while
condition|(
name|setp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|setp
operator|->
name|id
argument_list|)
expr_stmt|;
name|setp
operator|=
name|setp
operator|->
name|cdr
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%d)\n"
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|superstate
operator|=
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
name|rx_cache_get_superstate
argument_list|(
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|superstate
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|cache
operator|->
name|lru_superstate
condition|)
operator|(
name|cache
operator|->
name|lru_superstate
operator|=
name|superstate
operator|->
name|next_recyclable
operator|=
name|superstate
operator|->
name|prev_recyclable
operator|=
name|superstate
operator|)
expr_stmt|;
else|else
block|{
name|superstate
operator|->
name|next_recyclable
operator|=
name|cache
operator|->
name|lru_superstate
expr_stmt|;
name|superstate
operator|->
name|prev_recyclable
operator|=
name|cache
operator|->
name|lru_superstate
operator|->
name|prev_recyclable
expr_stmt|;
operator|(
name|superstate
operator|->
name|prev_recyclable
operator|->
name|next_recyclable
operator|=
name|superstate
operator|->
name|next_recyclable
operator|->
name|prev_recyclable
operator|=
name|superstate
operator|)
expr_stmt|;
block|}
name|superstate
operator|->
name|rx_id
operator|=
name|rx
operator|->
name|rx_id
expr_stmt|;
name|superstate
operator|->
name|transition_refs
operator|=
literal|0
expr_stmt|;
name|superstate
operator|->
name|locks
operator|=
literal|0
expr_stmt|;
name|superstate
operator|->
name|is_semifree
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|superstate
operator|=
name|superstate
expr_stmt|;
name|superstate
operator|->
name|contents
operator|=
name|set
expr_stmt|;
name|rx_protect_superset
argument_list|(
name|rx
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|superstate
operator|->
name|edges
operator|=
literal|0
expr_stmt|;
block|{
name|int
name|x
decl_stmt|;
comment|/* None of the transitions from this superstate are known yet. */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|rx
operator|->
name|local_cset_size
condition|;
operator|++
name|x
control|)
comment|/*&&&&& 3.8 % */
block|{
name|struct
name|rx_inx
modifier|*
name|ifr
init|=
operator|&
name|superstate
operator|->
name|transitions
index|[
name|x
index|]
decl_stmt|;
name|ifr
operator|->
name|inx
operator|=
name|rx
operator|->
name|instruction_table
index|[
name|rx_cache_miss
index|]
expr_stmt|;
name|ifr
operator|->
name|data
operator|=
name|ifr
operator|->
name|data_2
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|superstate
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This computes the destination set of one edge of the superstate NFA.  * Note that a RX_DISTINCT_FUTURE is a superstate edge.  * Returns 0 on an allocation failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|solve_destination
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_distinct_future
operator|*
name|df
argument_list|)
else|#
directive|else
decl|static
name|int
name|solve_destination
argument_list|(
name|rx
argument_list|,
name|df
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_super_edge
modifier|*
name|tc
init|=
name|df
operator|->
name|edge
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|nfa_state
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|nil_set
init|=
name|rx_superset_cons
argument_list|(
name|rx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|solution
init|=
name|nil_set
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|dest
decl_stmt|;
name|rx_protect_superset
argument_list|(
name|rx
argument_list|,
name|solution
argument_list|)
expr_stmt|;
comment|/* Iterate over all NFA states in the state set of this superstate. */
for|for
control|(
name|nfa_state
operator|=
name|df
operator|->
name|present
operator|->
name|contents
init|;
name|nfa_state
operator|->
name|car
condition|;
name|nfa_state
operator|=
name|nfa_state
operator|->
name|cdr
control|)
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
decl_stmt|;
comment|/* Iterate over all edges of each NFA state. */
for|for
control|(
name|e
operator|=
name|nfa_state
operator|->
name|car
operator|->
name|edges
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
comment|/* If we find an edge that is labeled with  	 * the characters we are solving for..... 	 */
if|if
condition|(
name|rx_bitset_is_subset
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|tc
operator|->
name|cset
argument_list|,
name|e
operator|->
name|params
operator|.
name|cset
argument_list|)
condition|)
block|{
name|struct
name|rx_nfa_state
modifier|*
name|n
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|struct
name|rx_possible_future
modifier|*
name|pf
decl_stmt|;
comment|/* ....search the partial epsilon closures of the destination 	     * of that edge for a path that involves the same set of 	     * side effects we are solving for. 	     * If we find such a RX_POSSIBLE_FUTURE, we add members to the 	     * stateset we are computing. 	     */
for|for
control|(
name|pf
operator|=
name|n
operator|->
name|futures
init|;
name|pf
condition|;
name|pf
operator|=
name|pf
operator|->
name|next
control|)
if|if
condition|(
name|pf
operator|->
name|effects
operator|==
name|df
operator|->
name|effects
condition|)
block|{
name|struct
name|rx_superset
modifier|*
name|old_sol
decl_stmt|;
name|old_sol
operator|=
name|solution
expr_stmt|;
name|solution
operator|=
name|rx_superstate_eclosure_union
argument_list|(
name|rx
argument_list|,
name|solution
argument_list|,
name|pf
operator|->
name|destset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|solution
condition|)
return|return
literal|0
return|;
name|rx_protect_superset
argument_list|(
name|rx
argument_list|,
name|solution
argument_list|)
expr_stmt|;
name|rx_release_superset
argument_list|(
name|rx
argument_list|,
name|old_sol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* It is possible that the RX_DISTINCT_FUTURE we are working on has     * the empty set of NFA states as its definition.  In that case, this    * is a failure point.    */
if|if
condition|(
name|solution
operator|==
name|nil_set
condition|)
block|{
name|df
operator|->
name|future_frame
operator|.
name|inx
operator|=
operator|(
name|void
operator|*
operator|)
name|rx_backtrack
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|future_frame
operator|.
name|data_2
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|dest
operator|=
name|rx_superstate
argument_list|(
name|rx
argument_list|,
name|solution
argument_list|)
expr_stmt|;
name|rx_release_superset
argument_list|(
name|rx
argument_list|,
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
return|return
literal|0
return|;
block|{
name|struct
name|rx_distinct_future
modifier|*
name|dft
decl_stmt|;
name|dft
operator|=
name|df
expr_stmt|;
name|df
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dft
condition|)
block|{
name|dft
operator|->
name|future
operator|=
name|dest
expr_stmt|;
name|dft
operator|->
name|future_frame
operator|.
name|inx
operator|=
name|rx
operator|->
name|instruction_table
index|[
name|rx_next_char
index|]
expr_stmt|;
name|dft
operator|->
name|future_frame
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|dest
operator|->
name|transitions
expr_stmt|;
name|dft
operator|=
name|dft
operator|->
name|next_same_dest
expr_stmt|;
block|}
name|df
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
name|df
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dest
operator|->
name|transition_refs
condition|)
name|dest
operator|->
name|transition_refs
operator|=
name|df
expr_stmt|;
else|else
block|{
name|struct
name|rx_distinct_future
modifier|*
name|dft
init|=
name|dest
operator|->
name|transition_refs
operator|->
name|next_same_dest
decl_stmt|;
name|dest
operator|->
name|transition_refs
operator|->
name|next_same_dest
operator|=
name|df
operator|->
name|next_same_dest
expr_stmt|;
name|df
operator|->
name|next_same_dest
operator|->
name|prev_same_dest
operator|=
name|dest
operator|->
name|transition_refs
expr_stmt|;
name|df
operator|->
name|next_same_dest
operator|=
name|dft
expr_stmt|;
name|dft
operator|->
name|prev_same_dest
operator|=
name|df
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* This takes a superstate and a character, and computes some edges  * from the superstate NFA.  In particular, this computes all edges  * that lead from SUPERSTATE given CHR.   This function also   * computes the set of characters that share this edge set.  * This returns 0 on allocation error.  * The character set and list of edges are returned through   * the paramters CSETOUT and DFOUT. } */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|compute_super_edge
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_distinct_future
operator|*
operator|*
name|dfout
argument_list|,
name|rx_Bitset
name|csetout
argument_list|,
expr|struct
name|rx_superstate
operator|*
name|superstate
argument_list|,
name|unsigned
name|char
name|chr
argument_list|)
else|#
directive|else
decl|static
name|int
name|compute_super_edge
argument_list|(
name|rx
argument_list|,
name|dfout
argument_list|,
name|csetout
argument_list|,
name|superstate
argument_list|,
name|chr
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_distinct_future
modifier|*
modifier|*
name|dfout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|csetout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superstate
modifier|*
name|superstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|chr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_superset
modifier|*
name|stateset
init|=
name|superstate
operator|->
name|contents
decl_stmt|;
comment|/* To compute the set of characters that share edges with CHR,     * we start with the full character set, and subtract.    */
name|rx_bitset_universe
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|csetout
argument_list|)
expr_stmt|;
operator|*
name|dfout
operator|=
literal|0
expr_stmt|;
comment|/* Iterate over the NFA states in the superstate state-set. */
while|while
condition|(
name|stateset
operator|->
name|car
condition|)
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|stateset
operator|->
name|car
operator|->
name|edges
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|RX_bitset_member
argument_list|(
name|e
operator|->
name|params
operator|.
name|cset
argument_list|,
name|chr
argument_list|)
condition|)
block|{
comment|/* If we find an NFA edge that applies, we make sure there 	     * are corresponding edges in the superstate NFA. 	     */
block|{
name|struct
name|rx_distinct_future
modifier|*
name|saved
decl_stmt|;
name|saved
operator|=
operator|*
name|dfout
expr_stmt|;
operator|*
name|dfout
operator|=
name|include_futures
argument_list|(
name|rx
argument_list|,
operator|*
name|dfout
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|superstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|dfout
condition|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|saved
expr_stmt|;
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|df
condition|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|dft
decl_stmt|;
name|dft
operator|=
name|df
expr_stmt|;
name|df
operator|=
name|df
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dft
operator|->
name|future
operator|&&
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|==
name|dft
condition|)
block|{
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|=
name|dft
operator|->
name|next_same_dest
expr_stmt|;
if|if
condition|(
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|==
name|dft
condition|)
name|dft
operator|->
name|future
operator|->
name|transition_refs
operator|=
literal|0
expr_stmt|;
block|}
name|dft
operator|->
name|next_same_dest
operator|->
name|prev_same_dest
operator|=
name|dft
operator|->
name|prev_same_dest
expr_stmt|;
name|dft
operator|->
name|prev_same_dest
operator|->
name|next_same_dest
operator|=
name|dft
operator|->
name|next_same_dest
expr_stmt|;
name|rx_cache_free
argument_list|(
name|rx
operator|->
name|cache
argument_list|,
operator|&
name|rx
operator|->
name|cache
operator|->
name|free_discernable_futures
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dft
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/* We also trim the character set a bit. */
name|rx_bitset_intersection
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|csetout
argument_list|,
name|e
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* An edge that doesn't apply at least tells us some characters 	   * that don't share the same edge set as CHR. 	   */
name|rx_bitset_difference
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|csetout
argument_list|,
name|e
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
name|stateset
operator|=
name|stateset
operator|->
name|cdr
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This is a constructor for RX_SUPER_EDGE structures.  These are  * wrappers for lists of superstate NFA edges that share character sets labels.  * If a transition class contains more than one rx_distinct_future (superstate  * edge), then it represents a non-determinism in the superstate NFA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rx_super_edge
modifier|*
name|rx_super_edge
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_superstate
operator|*
name|super
argument_list|,
name|rx_Bitset
name|cset
argument_list|,
expr|struct
name|rx_distinct_future
operator|*
name|df
argument_list|)
else|#
directive|else
decl|static struct
name|rx_super_edge
modifier|*
name|rx_super_edge
argument_list|(
name|rx
argument_list|,
name|super
argument_list|,
name|cset
argument_list|,
name|df
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superstate
modifier|*
name|super
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|cset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rx_super_edge
modifier|*
name|tc
init|=
operator|(
expr|struct
name|rx_super_edge
operator|*
operator|)
name|rx_cache_malloc_or_get
argument_list|(
name|rx
operator|->
name|cache
argument_list|,
operator|&
name|rx
operator|->
name|cache
operator|->
name|free_transition_classes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_super_edge
argument_list|)
operator|+
name|rx_sizeof_bitset
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tc
condition|)
return|return
literal|0
return|;
name|tc
operator|->
name|next
operator|=
name|super
operator|->
name|edges
expr_stmt|;
name|super
operator|->
name|edges
operator|=
name|tc
expr_stmt|;
name|tc
operator|->
name|rx_backtrack_frame
operator|.
name|inx
operator|=
name|rx
operator|->
name|instruction_table
index|[
name|rx_backtrack_point
index|]
expr_stmt|;
name|tc
operator|->
name|rx_backtrack_frame
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|rx_backtrack_frame
operator|.
name|data_2
operator|=
operator|(
name|void
operator|*
operator|)
name|tc
expr_stmt|;
name|tc
operator|->
name|options
operator|=
name|df
expr_stmt|;
name|tc
operator|->
name|cset
operator|=
call|(
name|rx_Bitset
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tc
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tc
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bitset_assign
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|,
name|tc
operator|->
name|cset
argument_list|,
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
condition|)
block|{
name|struct
name|rx_distinct_future
modifier|*
name|dfp
init|=
name|df
decl_stmt|;
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dfp
condition|)
block|{
name|dfp
operator|->
name|edge
operator|=
name|tc
expr_stmt|;
name|dfp
operator|=
name|dfp
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
expr_stmt|;
block|}
name|df
operator|->
name|next_same_super_edge
index|[
literal|1
index|]
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|=
name|df
expr_stmt|;
block|}
return|return
name|tc
return|;
block|}
end_block

begin_comment
comment|/* There are three kinds of cache miss.  The first occurs when a  * transition is taken that has never been computed during the  * lifetime of the source superstate.  That cache miss is handled by  * calling COMPUTE_SUPER_EDGE.  The second kind of cache miss  * occurs when the destination superstate of a transition doesn't  * exist.  SOLVE_DESTINATION is used to construct the destination superstate.  * Finally, the third kind of cache miss occurs when the destination  * superstate of a transition is in a `semi-free state'.  That case is  * handled by UNFREE_SUPERSTATE.  *  * The function of HANDLE_CACHE_MISS is to figure out which of these  * cases applies.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|install_partial_transition
argument_list|(
expr|struct
name|rx_superstate
operator|*
name|super
argument_list|,
expr|struct
name|rx_inx
operator|*
name|answer
argument_list|,
name|RX_subset
name|set
argument_list|,
name|int
name|offset
argument_list|)
else|#
directive|else
decl|static
name|void
name|install_partial_transition
argument_list|(
name|super
argument_list|,
name|answer
argument_list|,
name|set
argument_list|,
name|offset
argument_list|)
decl|struct
name|rx_superstate
modifier|*
name|super
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_inx
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RX_subset
name|set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|start
init|=
name|offset
decl_stmt|;
name|int
name|end
init|=
name|start
operator|+
literal|32
decl_stmt|;
name|RX_subset
name|pos
init|=
literal|1
decl_stmt|;
name|struct
name|rx_inx
modifier|*
name|transitions
init|=
name|super
operator|->
name|transitions
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|set
operator|&
name|pos
condition|)
name|transitions
index|[
name|start
index|]
operator|=
operator|*
name|answer
expr_stmt|;
name|pos
operator|<<=
literal|1
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|struct
name|rx_inx
modifier|*
name|rx_handle_cache_miss
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_superstate
operator|*
name|super
argument_list|,
name|unsigned
name|char
name|chr
argument_list|,
name|void
operator|*
name|data
argument_list|)
else|#
directive|else
name|RX_DECL
decl|struct
name|rx_inx
modifier|*
name|rx_handle_cache_miss
argument_list|(
name|rx
argument_list|,
name|super
argument_list|,
name|chr
argument_list|,
name|data
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_superstate
modifier|*
name|super
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|chr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|offset
init|=
name|chr
operator|/
name|RX_subset_bits
decl_stmt|;
name|struct
name|rx_distinct_future
modifier|*
name|df
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|df
condition|)
comment|/* must be the shared_cache_miss_frame */
block|{
comment|/* Perhaps this is just a transition waiting to be filled. */
name|struct
name|rx_super_edge
modifier|*
name|tc
decl_stmt|;
name|RX_subset
name|mask
init|=
name|rx_subset_singletons
index|[
name|chr
operator|%
name|RX_subset_bits
index|]
decl_stmt|;
for|for
control|(
name|tc
operator|=
name|super
operator|->
name|edges
init|;
name|tc
condition|;
name|tc
operator|=
name|tc
operator|->
name|next
control|)
if|if
condition|(
name|tc
operator|->
name|cset
index|[
name|offset
index|]
operator|&
name|mask
condition|)
block|{
name|struct
name|rx_inx
modifier|*
name|answer
decl_stmt|;
name|df
operator|=
name|tc
operator|->
name|options
expr_stmt|;
name|answer
operator|=
operator|(
operator|(
name|tc
operator|->
name|options
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|!=
name|tc
operator|->
name|options
operator|)
condition|?
operator|&
name|tc
operator|->
name|rx_backtrack_frame
else|:
operator|(
name|df
operator|->
name|effects
condition|?
operator|&
name|df
operator|->
name|side_effects_frame
else|:
operator|&
name|df
operator|->
name|future_frame
operator|)
operator|)
expr_stmt|;
name|install_partial_transition
argument_list|(
name|super
argument_list|,
name|answer
argument_list|,
name|tc
operator|->
name|cset
index|[
name|offset
index|]
argument_list|,
name|offset
operator|*
literal|32
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/* Otherwise, it's a flushed or  newly encountered edge. */
block|{
name|char
name|cset_space
index|[
literal|1024
index|]
decl_stmt|;
comment|/* this limit is far from unreasonable */
name|rx_Bitset
name|trcset
decl_stmt|;
name|struct
name|rx_inx
modifier|*
name|answer
decl_stmt|;
if|if
condition|(
name|rx_sizeof_bitset
argument_list|(
name|rx
operator|->
name|local_cset_size
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|cset_space
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the arbitrary limit is hit, always fail */
comment|/* cleanly. */
name|trcset
operator|=
operator|(
name|rx_Bitset
operator|)
name|cset_space
expr_stmt|;
name|rx_lock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compute_super_edge
argument_list|(
name|rx
argument_list|,
operator|&
name|df
argument_list|,
name|trcset
argument_list|,
name|super
argument_list|,
name|chr
argument_list|)
condition|)
block|{
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|df
condition|)
comment|/* We just computed the fail transition. */
block|{
specifier|static
name|struct
name|rx_inx
name|shared_fail_frame
init|=
block|{
operator|(
name|void
operator|*
operator|)
name|rx_backtrack
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|answer
operator|=
operator|&
name|shared_fail_frame
expr_stmt|;
block|}
else|else
block|{
name|tc
operator|=
name|rx_super_edge
argument_list|(
name|rx
argument_list|,
name|super
argument_list|,
name|trcset
argument_list|,
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tc
condition|)
block|{
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|answer
operator|=
operator|(
operator|(
name|tc
operator|->
name|options
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|!=
name|tc
operator|->
name|options
operator|)
condition|?
operator|&
name|tc
operator|->
name|rx_backtrack_frame
else|:
operator|(
name|df
operator|->
name|effects
condition|?
operator|&
name|df
operator|->
name|side_effects_frame
else|:
operator|&
name|df
operator|->
name|future_frame
operator|)
operator|)
expr_stmt|;
block|}
name|install_partial_transition
argument_list|(
name|super
argument_list|,
name|answer
argument_list|,
name|trcset
index|[
name|offset
index|]
argument_list|,
name|offset
operator|*
literal|32
argument_list|)
expr_stmt|;
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|df
operator|->
name|future
condition|)
comment|/* A cache miss on an edge with a future? Must be 			* a semi-free destination. */
block|{
if|if
condition|(
name|df
operator|->
name|future
operator|->
name|is_semifree
condition|)
name|refresh_semifree_superstate
argument_list|(
name|rx
operator|->
name|cache
argument_list|,
name|df
operator|->
name|future
argument_list|)
expr_stmt|;
return|return
operator|&
name|df
operator|->
name|future_frame
return|;
block|}
else|else
comment|/* no future superstate on an existing edge */
block|{
name|rx_lock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|solve_destination
argument_list|(
name|rx
argument_list|,
name|df
argument_list|)
condition|)
block|{
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|df
operator|->
name|effects
operator|&&
operator|(
name|df
operator|->
name|edge
operator|->
name|options
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|==
name|df
operator|->
name|edge
operator|->
name|options
operator|)
condition|)
name|install_partial_transition
argument_list|(
name|super
argument_list|,
operator|&
name|df
operator|->
name|future_frame
argument_list|,
name|df
operator|->
name|edge
operator|->
name|cset
index|[
name|offset
index|]
argument_list|,
name|offset
operator|*
literal|32
argument_list|)
expr_stmt|;
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|super
argument_list|)
expr_stmt|;
return|return
operator|&
name|df
operator|->
name|future_frame
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The rest of the code provides a regex.c compatable interface. */
end_comment

begin_decl_stmt
name|__const__
name|char
modifier|*
name|re_error_msg
index|[]
init|=
block|{
literal|0
block|,
comment|/* REG_NOUT */
literal|"No match"
block|,
comment|/* REG_NOMATCH */
literal|"Invalid regular expression"
block|,
comment|/* REG_BADPAT */
literal|"Invalid collation character"
block|,
comment|/* REG_ECOLLATE */
literal|"Invalid character class name"
block|,
comment|/* REG_ECTYPE */
literal|"Trailing backslash"
block|,
comment|/* REG_EESCAPE */
literal|"Invalid back reference"
block|,
comment|/* REG_ESUBREG */
literal|"Unmatched [ or [^"
block|,
comment|/* REG_EBRACK */
literal|"Unmatched ( or \\("
block|,
comment|/* REG_EPAREN */
literal|"Unmatched \\{"
block|,
comment|/* REG_EBRACE */
literal|"Invalid content of \\{\\}"
block|,
comment|/* REG_BADBR */
literal|"Invalid range end"
block|,
comment|/* REG_ERANGE */
literal|"Memory exhausted"
block|,
comment|/* REG_ESPACE */
literal|"Invalid preceding regular expression"
block|,
comment|/* REG_BADRPT */
literal|"Premature end of regular expression"
block|,
comment|/* REG_EEND */
literal|"Regular expression too big"
block|,
comment|/* REG_ESIZE */
literal|"Unmatched ) or \\)"
block|,
comment|/* REG_ERPAREN */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*   * Macros used while compiling patterns.  *  * By convention, PEND points just past the end of the uncompiled pattern,  * P points to the read position in the pattern.  `translate' is the name  * of the translation table (`TRANSLATE' is the name of a macro that looks  * things up in `translate').  */
end_comment

begin_comment
comment|/*  * Fetch the next character in the uncompiled pattern---translating it   * if necessary. *Also cast from a signed character in the constant  * string passed to us by the user to an unsigned char that we can use  * as an array index (in, e.g., `translate').  */
end_comment

begin_define
define|#
directive|define
name|PATFETCH
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (unsigned char) *p++;						\     c = translate[c];		 					\  } while (0)
end_define

begin_comment
comment|/*   * Fetch the next character in the uncompiled pattern, with no  * translation.  */
end_comment

begin_define
define|#
directive|define
name|PATFETCH_RAW
parameter_list|(
name|c
parameter_list|)
define|\
value|do {if (p == pend) return REG_EEND;					\     c = (unsigned char) *p++; 						\   } while (0)
end_define

begin_comment
comment|/* Go backwards one character in the pattern.  */
end_comment

begin_define
define|#
directive|define
name|PATUNFETCH
value|p--
end_define

begin_define
define|#
directive|define
name|TRANSLATE
parameter_list|(
name|d
parameter_list|)
value|translate[(unsigned char) (d)]
end_define

begin_typedef
typedef|typedef
name|unsigned
name|regnum_t
typedef|;
end_typedef

begin_comment
comment|/* Since offsets can go either forwards or backwards, this type needs to  * be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|pattern_offset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|rexp_node
modifier|*
modifier|*
name|top_expression
decl_stmt|;
comment|/* was begalt */
name|struct
name|rexp_node
modifier|*
modifier|*
name|last_expression
decl_stmt|;
comment|/* was laststart */
name|pattern_offset_t
name|inner_group_offset
decl_stmt|;
name|regnum_t
name|regnum
decl_stmt|;
block|}
name|compile_stack_elt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|compile_stack_elt_t
modifier|*
name|stack
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|unsigned
name|avail
decl_stmt|;
comment|/* Offset of next open position.  */
block|}
name|compile_stack_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INIT_COMPILE_STACK_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|COMPILE_STACK_EMPTY
value|(compile_stack.avail == 0)
end_define

begin_define
define|#
directive|define
name|COMPILE_STACK_FULL
value|(compile_stack.avail == compile_stack.size)
end_define

begin_comment
comment|/* The next available element.  */
end_comment

begin_define
define|#
directive|define
name|COMPILE_STACK_TOP
value|(compile_stack.stack[compile_stack.avail])
end_define

begin_comment
comment|/* Set the bit for character C in a list.  */
end_comment

begin_define
define|#
directive|define
name|SET_LIST_BIT
parameter_list|(
name|c
parameter_list|)
define|\
value|(b[((unsigned char) (c)) / CHARBITS]               \    |= 1<< (((unsigned char) c) % CHARBITS))
end_define

begin_comment
comment|/* Get the next unsigned number in the uncompiled pattern.  */
end_comment

begin_define
define|#
directive|define
name|GET_UNSIGNED_NUMBER
parameter_list|(
name|num
parameter_list|)
define|\
value|{ if (p != pend)							\      {									\        PATFETCH (c); 							\        while (isdigit (c)) 						\          { 								\            if (num< 0)							\               num = 0;							\            num = num * 10 + c - '0'; 					\            if (p == pend) 						\               break; 							\            PATFETCH (c);						\          } 								\        } 								\     }
end_define

begin_define
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|6
end_define

begin_comment
comment|/* Namely, `xdigit'.  */
end_comment

begin_define
define|#
directive|define
name|IS_CHAR_CLASS
parameter_list|(
name|string
parameter_list|)
define|\
value|(!strcmp (string, "alpha") || !strcmp (string, "upper")		\     || !strcmp (string, "lower") || !strcmp (string, "digit")		\     || !strcmp (string, "alnum") || !strcmp (string, "xdigit")		\     || !strcmp (string, "space") || !strcmp (string, "print")		\     || !strcmp (string, "punct") || !strcmp (string, "graph")		\     || !strcmp (string, "cntrl") || !strcmp (string, "blank"))
end_define

begin_escape
end_escape

begin_comment
comment|/* These predicates are used in regex_compile. */
end_comment

begin_comment
comment|/* P points to just after a ^ in PATTERN.  Return true if that ^ comes  * after an alternative or a begin-subexpression.  We assume there is at  * least one character before the ^.    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|boolean
name|at_begline_loc_p
parameter_list|(
name|__const__
name|char
modifier|*
name|pattern
parameter_list|,
name|__const__
name|char
modifier|*
name|p
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|)
else|#
directive|else
function|static boolean at_begline_loc_p
parameter_list|(
name|pattern
parameter_list|,
name|p
parameter_list|,
name|syntax
parameter_list|)
name|__const__
name|char
modifier|*
name|pattern
decl_stmt|;
name|__const__
name|char
modifier|*
name|p
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
endif|#
directive|endif
block|{
name|__const__
name|char
modifier|*
name|prev
init|=
name|p
operator|-
literal|2
decl_stmt|;
name|boolean
name|prev_prev_backslash
init|=
operator|(
operator|(
name|prev
operator|>
name|pattern
operator|)
operator|&&
operator|(
name|prev
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
decl_stmt|;
return|return
operator|(
comment|/* After a subexpression?  */
operator|(
operator|(
operator|*
name|prev
operator|==
literal|'('
operator|)
operator|&&
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
operator|||
name|prev_prev_backslash
operator|)
operator|)
operator|||
comment|/* After an alternative?  */
operator|(
operator|(
operator|*
name|prev
operator|==
literal|'|'
operator|)
operator|&&
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
operator|||
name|prev_prev_backslash
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The dual of at_begline_loc_p.  This one is for $.  We assume there is  * at least one character after the $, i.e., `P< PEND'.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|boolean
name|at_endline_loc_p
parameter_list|(
name|__const__
name|char
modifier|*
name|p
parameter_list|,
name|__const__
name|char
modifier|*
name|pend
parameter_list|,
name|int
name|syntax
parameter_list|)
else|#
directive|else
function|static boolean at_endline_loc_p
parameter_list|(
name|p
parameter_list|,
name|pend
parameter_list|,
name|syntax
parameter_list|)
name|__const__
name|char
modifier|*
name|p
decl_stmt|;
name|__const__
name|char
modifier|*
name|pend
decl_stmt|;
name|int
name|syntax
decl_stmt|;
endif|#
directive|endif
block|{
name|__const__
name|char
modifier|*
name|next
init|=
name|p
decl_stmt|;
name|boolean
name|next_backslash
init|=
operator|(
operator|*
name|next
operator|==
literal|'\\'
operator|)
decl_stmt|;
name|__const__
name|char
modifier|*
name|next_next
init|=
operator|(
name|p
operator|+
literal|1
operator|<
name|pend
operator|)
condition|?
operator|(
name|p
operator|+
literal|1
operator|)
else|:
literal|0
decl_stmt|;
return|return
operator|(
comment|/* Before a subexpression?  */
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|?
operator|(
operator|*
name|next
operator|==
literal|')'
operator|)
else|:
operator|(
name|next_backslash
operator|&&
name|next_next
operator|&&
operator|(
operator|*
name|next_next
operator|==
literal|')'
operator|)
operator|)
operator|)
operator|||
comment|/* Before an alternative?  */
operator|(
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|?
operator|(
operator|*
name|next
operator|==
literal|'|'
operator|)
else|:
operator|(
name|next_backslash
operator|&&
name|next_next
operator|&&
operator|(
operator|*
name|next_next
operator|==
literal|'|'
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|unsigned
name|char
name|rx_id_translation
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiler keeps an inverted translation table.  * This looks up/inititalize elements.  * VALID is an array of booleans that validate CACHE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|rx_Bitset
name|inverse_translation
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|char
operator|*
name|valid
argument_list|,
name|rx_Bitset
name|cache
argument_list|,
name|unsigned
name|char
operator|*
name|translate
argument_list|,
name|int
name|c
argument_list|)
else|#
directive|else
decl|static
name|rx_Bitset
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|valid
argument_list|,
name|cache
argument_list|,
name|translate
argument_list|,
name|c
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|rx_Bitset
name|cs
init|=
name|cache
operator|+
name|c
operator|*
name|rx_bitset_numb_subsets
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
index|[
name|c
index|]
condition|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|c_tr
init|=
name|TRANSLATE
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|rx_bitset_null
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
operator|++
name|x
control|)
comment|/*&&&& 13.37 */
if|if
condition|(
name|TRANSLATE
argument_list|(
name|x
argument_list|)
operator|==
name|c_tr
condition|)
name|RX_bitset_enjoin
argument_list|(
name|cs
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|valid
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|cs
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* More subroutine declarations and macros for regex_compile.  */
end_comment

begin_comment
comment|/* Returns true if REGNUM is in one of COMPILE_STACK's elements and     false if it's not.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|boolean
name|group_in_compile_stack
parameter_list|(
name|compile_stack_type
name|compile_stack
parameter_list|,
name|regnum_t
name|regnum
parameter_list|)
else|#
directive|else
function|static boolean group_in_compile_stack
parameter_list|(
name|compile_stack
parameter_list|,
name|regnum
parameter_list|)
name|compile_stack_type
name|compile_stack
decl_stmt|;
name|regnum_t
name|regnum
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|this_element
decl_stmt|;
for|for
control|(
name|this_element
operator|=
name|compile_stack
operator|.
name|avail
operator|-
literal|1
init|;
name|this_element
operator|>=
literal|0
condition|;
name|this_element
operator|--
control|)
if|if
condition|(
name|compile_stack
operator|.
name|stack
index|[
name|this_element
index|]
operator|.
name|regnum
operator|==
name|regnum
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Read the ending character of a range (in a bracket expression) from the  * uncompiled pattern *P_PTR (which ends at PEND).  We assume the  * starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)  * Then we set the translation of all bits between the starting and  * ending characters (inclusive) in the compiled pattern B.  *   * Return an error code.  *   * We use these short variable names so we can use the same macros as  * `regex_compile' itself.    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|reg_errcode_t
name|compile_range
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|rx_Bitset
name|cs
argument_list|,
name|__const__
name|char
operator|*
operator|*
name|p_ptr
argument_list|,
name|__const__
name|char
operator|*
name|pend
argument_list|,
name|unsigned
name|char
operator|*
name|translate
argument_list|,
name|reg_syntax_t
name|syntax
argument_list|,
name|rx_Bitset
name|inv_tr
argument_list|,
name|char
operator|*
name|valid_inv_tr
argument_list|)
else|#
directive|else
decl|static
name|reg_errcode_t
name|compile_range
argument_list|(
name|rxb
argument_list|,
name|cs
argument_list|,
name|p_ptr
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|inv_tr
argument_list|,
name|valid_inv_tr
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|cs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
modifier|*
name|p_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|pend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reg_syntax_t
name|syntax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_Bitset
name|inv_tr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|valid_inv_tr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|unsigned
name|this_char
decl_stmt|;
name|__const__
name|char
modifier|*
name|p
init|=
operator|*
name|p_ptr
decl_stmt|;
name|unsigned
name|char
name|range_end
decl_stmt|;
name|unsigned
name|char
name|range_start
init|=
name|TRANSLATE
argument_list|(
name|p
index|[
operator|-
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_ERANGE
return|;
name|PATFETCH
argument_list|(
name|range_end
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|range_start
operator|>
name|range_end
condition|)
return|return
name|syntax
operator|&
name|RE_NO_EMPTY_RANGES
condition|?
name|REG_ERANGE
else|:
name|REG_NOERROR
return|;
for|for
control|(
name|this_char
operator|=
name|range_start
init|;
name|this_char
operator|<=
name|range_end
condition|;
name|this_char
operator|++
control|)
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|valid_inv_tr
argument_list|,
name|inv_tr
argument_list|,
name|translate
argument_list|,
name|this_char
argument_list|)
decl_stmt|;
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This searches a regexp for backreference side effects.  * It fills in the array OUT with 1 at the index of every register pair  * referenced by a backreference.  *  * This is used to help optimize patterns for searching.  The information is  * useful because, if the caller doesn't want register values, backreferenced  * registers are the only registers for which we need rx_backtrack.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
specifier|static
name|void
name|find_backrefs
parameter_list|(
name|char
modifier|*
name|out
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|rexp
parameter_list|,
name|struct
name|re_se_params
modifier|*
name|params
parameter_list|)
else|#
directive|else
function|static void find_backrefs
parameter_list|(
name|out
parameter_list|,
name|rexp
parameter_list|,
name|params
parameter_list|)
name|char
modifier|*
name|out
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
name|struct
name|re_se_params
modifier|*
name|params
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|rexp
condition|)
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
return|return;
case|case
name|r_alternate
case|:
case|case
name|r_concat
case|:
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
case|case
name|r_2phase_star
case|:
name|find_backrefs
argument_list|(
name|out
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|find_backrefs
argument_list|(
name|out
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return;
case|case
name|r_side_effect
case|:
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|params
index|[
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
index|]
operator|.
name|se
operator|==
name|re_se_backref
operator|)
condition|)
name|out
index|[
name|params
index|[
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
index|]
operator|.
name|op1
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 0 unless the pattern can match the empty string. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|compute_fastset
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|)
else|#
directive|else
decl|static
name|int
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_data
case|:
return|return
literal|1
return|;
case|case
name|r_cset
case|:
block|{
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|rxb
operator|->
name|fastset
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|cset
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|r_concat
case|:
return|return
operator|(
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
operator|&&
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|r_2phase_star
case|:
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* compute_fastset (rxb, rexp->params.pair.right);  nope... */
return|return
literal|1
return|;
case|case
name|r_alternate
case|:
return|return
operator|!
operator|!
operator|(
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
operator|+
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|r_side_effect
case|:
return|return
literal|1
return|;
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* returns  *  1 -- yes, definately anchored by the given side effect.  *  2 -- maybe anchored, maybe the empty string.  *  0 -- definately not anchored  *  There is simply no other possibility.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|is_anchored
argument_list|(
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|,
name|rx_side_effect
name|se
argument_list|)
else|#
directive|else
decl|static
name|int
name|is_anchored
argument_list|(
name|rexp
argument_list|,
name|se
argument_list|)
decl|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_side_effect
name|se
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|2
return|;
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
return|return
literal|0
return|;
case|case
name|r_concat
case|:
case|case
name|r_2phase_star
case|:
block|{
name|int
name|l
init|=
name|is_anchored
argument_list|(
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|se
argument_list|)
decl_stmt|;
return|return
operator|(
name|l
operator|==
literal|2
condition|?
name|is_anchored
argument_list|(
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|se
argument_list|)
else|:
name|l
operator|)
return|;
block|}
case|case
name|r_alternate
case|:
block|{
name|int
name|l
init|=
name|is_anchored
argument_list|(
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|se
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|l
condition|?
name|is_anchored
argument_list|(
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|se
argument_list|)
else|:
literal|0
decl_stmt|;
return|return
name|MAX
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
return|;
block|}
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
return|return
name|is_anchored
argument_list|(
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|se
argument_list|)
condition|?
literal|2
else|:
literal|0
return|;
case|case
name|r_side_effect
case|:
return|return
operator|(
operator|(
name|rexp
operator|->
name|params
operator|.
name|side_effect
operator|==
name|se
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
return|;
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This removes register assignments that aren't required by backreferencing.  * This can speed up explore_future, especially if it eliminates  * non-determinism in the superstate NFA.  *   * NEEDED is an array of characters, presumably filled in by FIND_BACKREFS.  * The non-zero elements of the array indicate which register assignments  * can NOT be removed from the expression.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|rexp_node
modifier|*
name|remove_unecessary_side_effects
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
name|char
operator|*
name|needed
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|,
expr|struct
name|re_se_params
operator|*
name|params
argument_list|)
else|#
directive|else
decl|static struct
name|rexp_node
modifier|*
name|remove_unecessary_side_effects
argument_list|(
name|rx
argument_list|,
name|needed
argument_list|,
name|rexp
argument_list|,
name|params
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|needed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_se_params
modifier|*
name|params
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|rexp_node
modifier|*
name|l
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|0
return|;
else|else
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
return|return
name|rexp
return|;
case|case
name|r_alternate
case|:
case|case
name|r_concat
case|:
case|case
name|r_2phase_star
case|:
name|l
operator|=
name|remove_unecessary_side_effects
argument_list|(
name|rx
argument_list|,
name|needed
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|r
operator|=
name|remove_unecessary_side_effects
argument_list|(
name|rx
argument_list|,
name|needed
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|&&
name|r
operator|)
operator|||
operator|(
name|rexp
operator|->
name|type
operator|!=
name|r_concat
operator|)
condition|)
block|{
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
name|r
expr_stmt|;
return|return
name|rexp
return|;
block|}
else|else
block|{
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|)
expr_stmt|;
return|return
name|l
condition|?
name|l
else|:
name|r
return|;
block|}
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
name|l
operator|=
name|remove_unecessary_side_effects
argument_list|(
name|rx
argument_list|,
name|needed
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
name|l
expr_stmt|;
return|return
name|rexp
return|;
block|}
else|else
block|{
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|r_side_effect
case|:
block|{
name|int
name|se
init|=
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
decl_stmt|;
if|if
condition|(
operator|(
name|se
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|enum
name|re_side_effects
operator|)
name|params
index|[
name|se
index|]
operator|.
name|se
operator|==
name|re_se_lparen
operator|)
operator|||
operator|(
operator|(
expr|enum
name|re_side_effects
operator|)
name|params
index|[
name|se
index|]
operator|.
name|se
operator|==
name|re_se_rparen
operator|)
operator|)
operator|&&
operator|(
name|params
index|[
name|se
index|]
operator|.
name|op1
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|needed
index|[
name|params
index|[
name|se
index|]
operator|.
name|op1
index|]
operator|)
condition|)
block|{
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|rexp
return|;
block|}
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pointless_if_repeated
argument_list|(
expr|struct
name|rexp_node
operator|*
name|node
argument_list|,
expr|struct
name|re_se_params
operator|*
name|params
argument_list|)
else|#
directive|else
decl|static
name|int
name|pointless_if_repeated
argument_list|(
name|node
argument_list|,
name|params
argument_list|)
decl|struct
name|rexp_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_se_params
modifier|*
name|params
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|node
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|node
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
return|return
literal|0
return|;
case|case
name|r_alternate
case|:
case|case
name|r_concat
case|:
case|case
name|r_2phase_star
case|:
return|return
operator|(
name|pointless_if_repeated
argument_list|(
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
operator|&&
name|pointless_if_repeated
argument_list|(
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|params
argument_list|)
operator|)
return|;
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
return|return
name|pointless_if_repeated
argument_list|(
name|node
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
return|;
case|case
name|r_side_effect
case|:
switch|switch
condition|(
operator|(
operator|(
name|long
operator|)
name|node
operator|->
name|params
operator|.
name|side_effect
operator|<
literal|0
operator|)
condition|?
operator|(
expr|enum
name|re_side_effects
operator|)
name|node
operator|->
name|params
operator|.
name|side_effect
else|:
operator|(
expr|enum
name|re_side_effects
operator|)
name|params
index|[
operator|(
name|long
operator|)
name|node
operator|->
name|params
operator|.
name|side_effect
index|]
operator|.
name|se
condition|)
block|{
case|case
name|re_se_try
case|:
case|case
name|re_se_at_dot
case|:
case|case
name|re_se_begbuf
case|:
case|case
name|re_se_hat
case|:
case|case
name|re_se_wordbeg
case|:
case|case
name|re_se_wordbound
case|:
case|case
name|re_se_notwordbound
case|:
case|case
name|re_se_wordend
case|:
case|case
name|re_se_endbuf
case|:
case|case
name|re_se_dollar
case|:
case|case
name|re_se_fail
case|:
case|case
name|re_se_win
case|:
return|return
literal|1
return|;
case|case
name|re_se_lparen
case|:
case|case
name|re_se_rparen
case|:
case|case
name|re_se_iter
case|:
case|case
name|re_se_end_iter
case|:
case|case
name|re_se_syntax
case|:
case|case
name|re_se_not_syntax
case|:
case|case
name|re_se_backref
case|:
return|return
literal|0
return|;
block|}
case|case
name|r_data
case|:
default|default:
return|return
literal|0
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|registers_on_stack
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|,
name|int
name|in_danger
argument_list|,
expr|struct
name|re_se_params
operator|*
name|params
argument_list|)
else|#
directive|else
decl|static
name|int
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
argument_list|,
name|in_danger
argument_list|,
name|params
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_danger
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_se_params
modifier|*
name|params
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|0
return|;
else|else
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
return|return
literal|0
return|;
case|case
name|r_alternate
case|:
case|case
name|r_concat
case|:
return|return
operator|(
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|in_danger
argument_list|,
name|params
argument_list|)
operator|||
operator|(
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|in_danger
argument_list|,
name|params
argument_list|)
operator|)
operator|)
return|;
case|case
name|r_opt
case|:
return|return
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
literal|0
argument_list|,
name|params
argument_list|)
return|;
case|case
name|r_star
case|:
return|return
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
literal|1
argument_list|,
name|params
argument_list|)
return|;
case|case
name|r_2phase_star
case|:
return|return
operator|(
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
literal|1
argument_list|,
name|params
argument_list|)
operator|||
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
literal|1
argument_list|,
name|params
argument_list|)
operator|)
return|;
case|case
name|r_side_effect
case|:
block|{
name|int
name|se
init|=
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
decl_stmt|;
if|if
condition|(
name|in_danger
operator|&&
operator|(
name|se
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|params
index|[
name|se
index|]
operator|.
name|op1
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|enum
name|re_side_effects
operator|)
name|params
index|[
name|se
index|]
operator|.
name|se
operator|==
name|re_se_lparen
operator|)
operator|||
operator|(
operator|(
expr|enum
name|re_side_effects
operator|)
name|params
index|[
name|se
index|]
operator|.
name|se
operator|==
name|re_se_rparen
operator|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|idempotent_complex_se
index|[]
init|=
block|{
define|#
directive|define
name|RX_WANT_SE_DEFS
value|1
undef|#
directive|undef
name|RX_DEF_SE
undef|#
directive|undef
name|RX_DEF_CPLX_SE
define|#
directive|define
name|RX_DEF_SE
parameter_list|(
name|IDEM
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
define|#
directive|define
name|RX_DEF_CPLX_SE
parameter_list|(
name|IDEM
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|IDEM,
include|#
directive|include
file|"rx.h"
undef|#
directive|undef
name|RX_DEF_SE
undef|#
directive|undef
name|RX_DEF_CPLX_SE
undef|#
directive|undef
name|RX_WANT_SE_DEFS
literal|23
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|idempotent_se
index|[]
init|=
block|{
literal|13
block|,
define|#
directive|define
name|RX_WANT_SE_DEFS
value|1
undef|#
directive|undef
name|RX_DEF_SE
undef|#
directive|undef
name|RX_DEF_CPLX_SE
define|#
directive|define
name|RX_DEF_SE
parameter_list|(
name|IDEM
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|IDEM,
define|#
directive|define
name|RX_DEF_CPLX_SE
parameter_list|(
name|IDEM
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
include|#
directive|include
file|"rx.h"
undef|#
directive|undef
name|RX_DEF_SE
undef|#
directive|undef
name|RX_DEF_CPLX_SE
undef|#
directive|undef
name|RX_WANT_SE_DEFS
literal|42
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|has_any_se
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|)
else|#
directive|else
decl|static
name|int
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
return|return
literal|0
return|;
case|case
name|r_side_effect
case|:
return|return
literal|1
return|;
case|case
name|r_2phase_star
case|:
case|case
name|r_concat
case|:
case|case
name|r_alternate
case|:
return|return
operator|(
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
operator|||
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
return|return
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
return|;
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This must be called AFTER `convert_hard_loops' for a given REXP. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|has_non_idempotent_epsilon_path
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|,
expr|struct
name|re_se_params
operator|*
name|params
argument_list|)
else|#
directive|else
decl|static
name|int
name|has_non_idempotent_epsilon_path
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|,
name|params
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_se_params
modifier|*
name|params
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
case|case
name|r_star
case|:
return|return
literal|0
return|;
case|case
name|r_side_effect
case|:
return|return
operator|!
operator|(
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
operator|>
literal|0
condition|?
name|idempotent_complex_se
index|[
name|params
index|[
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
index|]
operator|.
name|se
index|]
else|:
name|idempotent_se
index|[
operator|-
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
index|]
operator|)
return|;
case|case
name|r_alternate
case|:
return|return
operator|(
name|has_non_idempotent_epsilon_path
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
operator|||
name|has_non_idempotent_epsilon_path
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|params
argument_list|)
operator|)
return|;
case|case
name|r_2phase_star
case|:
case|case
name|r_concat
case|:
return|return
operator|(
name|has_non_idempotent_epsilon_path
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
operator|&&
name|has_non_idempotent_epsilon_path
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|params
argument_list|)
operator|)
return|;
case|case
name|r_opt
case|:
return|return
name|has_non_idempotent_epsilon_path
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|params
argument_list|)
return|;
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This computes rougly what it's name suggests.   It can (and does) go wrong   * in the direction of returning spurious 0 without causing disasters.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|begins_with_complex_se
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|)
else|#
directive|else
decl|static
name|int
name|begins_with_complex_se
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
return|return
literal|0
return|;
case|case
name|r_side_effect
case|:
return|return
operator|(
operator|(
name|long
operator|)
name|rexp
operator|->
name|params
operator|.
name|side_effect
operator|>=
literal|0
operator|)
return|;
case|case
name|r_alternate
case|:
return|return
operator|(
name|begins_with_complex_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
operator|&&
name|begins_with_complex_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|r_concat
case|:
return|return
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
return|;
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
case|case
name|r_2phase_star
case|:
return|return
literal|0
return|;
block|}
comment|/* this should never happen */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This destructively removes some of the re_se_tv side effects from   * a rexp tree.  In particular, during parsing re_se_tv was inserted on the  * right half of every | to guarantee that posix path preference could be   * honored.  This function removes some which it can be determined aren't   * needed.    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|speed_up_alt
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rexp_node
operator|*
name|rexp
argument_list|,
name|int
name|unposix
argument_list|)
else|#
directive|else
decl|static
name|void
name|speed_up_alt
argument_list|(
name|rx
argument_list|,
name|rexp
argument_list|,
name|unposix
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rexp_node
modifier|*
name|rexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unposix
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
operator|!
name|rexp
condition|)
return|return;
switch|switch
condition|(
name|rexp
operator|->
name|type
condition|)
block|{
case|case
name|r_cset
case|:
case|case
name|r_data
case|:
case|case
name|r_side_effect
case|:
return|return;
case|case
name|r_opt
case|:
case|case
name|r_star
case|:
name|speed_up_alt
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|unposix
argument_list|)
expr_stmt|;
return|return;
case|case
name|r_2phase_star
case|:
case|case
name|r_concat
case|:
name|speed_up_alt
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|unposix
argument_list|)
expr_stmt|;
name|speed_up_alt
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|unposix
argument_list|)
expr_stmt|;
return|return;
case|case
name|r_alternate
case|:
comment|/* the right child is guaranteed to be (concat re_se_tv<subexp>) */
name|speed_up_alt
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|,
name|unposix
argument_list|)
expr_stmt|;
name|speed_up_alt
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|,
name|unposix
argument_list|)
expr_stmt|;
if|if
condition|(
name|unposix
operator|||
operator|(
name|begins_with_complex_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|->
name|params
operator|.
name|pair
operator|.
name|right
argument_list|)
operator|||
name|has_any_se
argument_list|(
name|rx
argument_list|,
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|left
argument_list|)
operator|)
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|conc
init|=
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
decl_stmt|;
name|rexp
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
name|conc
operator|->
name|params
operator|.
name|pair
operator|.
name|right
expr_stmt|;
name|conc
operator|->
name|params
operator|.
name|pair
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|rx_free_rexp
argument_list|(
name|rx
argument_list|,
name|conc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.    Returns one of error codes defined in `regex.h', or zero for success.     Assumes the `allocated' (and perhaps `buffer') and `translate'    fields are set in BUFP on entry.     If it succeeds, results are put in BUFP (if it returns an error, the    contents of BUFP are undefined):      `buffer' is the compiled pattern;      `syntax' is set to SYNTAX;      `used' is set to the length of the compiled pattern;      `fastmap_accurate' is set to zero;      `re_nsub' is set to the number of groups in PATTERN;      `not_bol' and `not_eol' are set to zero.        The `fastmap' and `newline_anchor' fields are neither    examined nor set.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|reg_errcode_t
name|rx_compile
argument_list|(
name|__const__
name|char
operator|*
name|pattern
argument_list|,
name|int
name|size
argument_list|,
name|reg_syntax_t
name|syntax
argument_list|,
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|)
else|#
directive|else
name|RX_DECL
name|reg_errcode_t
name|rx_compile
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
name|syntax
argument_list|,
name|rxb
argument_list|)
name|__const__
name|char
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reg_syntax_t
name|syntax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|RX_subset
name|inverse_translate
index|[
name|CHAR_SET_SIZE
operator|*
name|rx_bitset_numb_subsets
argument_list|(
name|CHAR_SET_SIZE
argument_list|)
index|]
decl_stmt|;
name|char
name|validate_inv_tr
index|[
name|CHAR_SET_SIZE
operator|*
name|rx_bitset_numb_subsets
argument_list|(
name|CHAR_SET_SIZE
argument_list|)
index|]
decl_stmt|;
comment|/* We fetch characters from PATTERN here.  Even though PATTERN is      `char *' (i.e., signed), we declare these variables as unsigned, so      they can be reliably used as array indices.  */
specifier|register
name|unsigned
name|char
name|c
decl_stmt|,
name|c1
decl_stmt|;
comment|/* A random tempory spot in PATTERN.  */
name|__const__
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* Keeps track of unclosed groups.  */
name|compile_stack_type
name|compile_stack
decl_stmt|;
comment|/* Points to the current (ending) position in the pattern.  */
name|__const__
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
name|__const__
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
comment|/* How to translate the characters in the pattern.  */
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|rxb
operator|->
name|translate
condition|?
name|rxb
operator|->
name|translate
else|:
name|rx_id_translation
operator|)
decl_stmt|;
comment|/* When parsing is done, this will hold the expression tree. */
name|struct
name|rexp_node
modifier|*
name|rexp
init|=
literal|0
decl_stmt|;
comment|/* In the midst of compilation, this holds onto the regexp     * first parst while rexp goes on to aquire additional constructs.    */
name|struct
name|rexp_node
modifier|*
name|orig_rexp
init|=
literal|0
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|fewer_side_effects
init|=
literal|0
decl_stmt|;
comment|/* This and top_expression are saved on the compile stack. */
name|struct
name|rexp_node
modifier|*
modifier|*
name|top_expression
init|=
operator|&
name|rexp
decl_stmt|;
name|struct
name|rexp_node
modifier|*
modifier|*
name|last_expression
init|=
name|top_expression
decl_stmt|;
comment|/* Parameter to `goto append_node' */
name|struct
name|rexp_node
modifier|*
name|append
decl_stmt|;
comment|/* Counts open-groups as they are encountered.  This is the index of the    * innermost group being compiled.    */
name|regnum_t
name|regnum
init|=
literal|0
decl_stmt|;
comment|/* Place in the uncompiled pattern (i.e., the {) to    * which to go back if the interval is invalid.      */
name|__const__
name|char
modifier|*
name|beg_interval
decl_stmt|;
name|struct
name|re_se_params
modifier|*
name|params
init|=
literal|0
decl_stmt|;
name|int
name|paramc
init|=
literal|0
decl_stmt|;
comment|/* How many complex side effects so far? */
name|rx_side_effect
name|side
decl_stmt|;
comment|/* param to `goto add_side_effect' */
name|bzero
argument_list|(
name|validate_inv_tr
argument_list|,
sizeof|sizeof
argument_list|(
name|validate_inv_tr
argument_list|)
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|instruction_table
operator|=
name|rx_id_instruction_table
expr_stmt|;
comment|/* Initialize the compile stack.  */
name|compile_stack
operator|.
name|stack
operator|=
operator|(
operator|(
name|compile_stack_elt_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|INIT_COMPILE_STACK_SIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|compile_stack_elt_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|compile_stack
operator|.
name|stack
operator|==
literal|0
condition|)
return|return
name|REG_ESPACE
return|;
name|compile_stack
operator|.
name|size
operator|=
name|INIT_COMPILE_STACK_SIZE
expr_stmt|;
name|compile_stack
operator|.
name|avail
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the pattern buffer.  */
name|rxb
operator|->
name|rx
operator|.
name|cache
operator|=
operator|&
name|default_cache
expr_stmt|;
name|rxb
operator|->
name|syntax
operator|=
name|syntax
expr_stmt|;
name|rxb
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|not_bol
operator|=
name|rxb
operator|->
name|not_eol
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|least_subs
operator|=
literal|0
expr_stmt|;
comment|/* Always count groups, whether or not rxb->no_sub is set.      * The whole pattern is implicitly group 0, so counting begins    * with 1.    */
name|rxb
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|emacs
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYNTAX_TABLE
argument_list|)
comment|/* Initialize the syntax table.  */
name|init_syntax_once
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Loop through the uncompiled pattern until we're at the end.  */
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
block|{
if|if
condition|(
comment|/* If at start of pattern, it's an operator.  */
name|p
operator|==
name|pattern
operator|+
literal|1
comment|/* If context independent, it's an operator.  */
operator|||
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
comment|/* Otherwise, depends on what's come before.  */
operator|||
name|at_begline_loc_p
argument_list|(
name|pattern
argument_list|,
name|p
argument_list|,
name|syntax
argument_list|)
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_hat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|REG_ESPACE
return|;
name|append
operator|=
name|n
expr_stmt|;
goto|goto
name|append_node
goto|;
block|}
else|else
goto|goto
name|normal_char
goto|;
block|}
break|break;
case|case
literal|'$'
case|:
block|{
if|if
condition|(
comment|/* If at end of pattern, it's an operator.  */
name|p
operator|==
name|pend
comment|/* If context independent, it's an operator.  */
operator|||
name|syntax
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
comment|/* Otherwise, depends on what's next.  */
operator|||
name|at_endline_loc_p
argument_list|(
name|p
argument_list|,
name|pend
argument_list|,
name|syntax
argument_list|)
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_dollar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|REG_ESPACE
return|;
name|append
operator|=
name|n
expr_stmt|;
goto|goto
name|append_node
goto|;
block|}
else|else
goto|goto
name|normal_char
goto|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|||
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|handle_plus
label|:
case|case
literal|'*'
case|:
comment|/* If there is no previous pattern... */
if|if
condition|(
name|pointless_if_repeated
argument_list|(
operator|*
name|last_expression
argument_list|,
name|params
argument_list|)
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
condition|)
return|return
name|REG_BADRPT
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
block|}
block|{
comment|/* 1 means zero (many) matches is allowed.  */
name|char
name|zero_times_ok
init|=
literal|0
decl_stmt|,
name|many_times_ok
init|=
literal|0
decl_stmt|;
comment|/* If there is a sequence of repetition chars, collapse it                down to just one (the right one).  We can't combine                interval operators with these because of, e.g., `a{2}*',                which should only match an even number of `a's.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|zero_times_ok
operator||=
name|c
operator|!=
literal|'+'
expr_stmt|;
name|many_times_ok
operator||=
name|c
operator|!=
literal|'?'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|||
operator|(
operator|!
operator|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EESCAPE
return|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|==
literal|'+'
operator|||
name|c1
operator|==
literal|'?'
operator|)
condition|)
block|{
name|PATUNFETCH
expr_stmt|;
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
comment|/* If we get here, we found another repeat character.  */
block|}
comment|/* Star, etc. applied to an empty pattern is equivalent                to an empty pattern.  */
if|if
condition|(
operator|!
name|last_expression
condition|)
break|break;
comment|/* Now we know whether or not zero matches is allowed 	     * and also whether or not two or more matches is allowed. 	     */
block|{
name|struct
name|rexp_node
modifier|*
name|inner_exp
init|=
operator|*
name|last_expression
decl_stmt|;
name|int
name|need_sync
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|many_times_ok
operator|&&
name|has_non_idempotent_epsilon_path
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|inner_exp
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|pusher
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_pushpos
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|checker
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_chkpos
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|pushback
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_pushback
argument_list|)
decl_stmt|;
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|lit_t
init|=
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|fake_state
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|pushback
argument_list|,
name|lit_t
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|phase2
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|checker
argument_list|,
name|fake_state
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|popper
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_poppos
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|star
init|=
name|rx_mk_r_2phase_star
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|inner_exp
argument_list|,
name|phase2
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|a
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|pusher
argument_list|,
name|star
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|whole_thing
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|a
argument_list|,
name|popper
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pusher
operator|&&
name|star
operator|&&
name|pushback
operator|&&
name|lit_t
operator|&&
name|fake_state
operator|&&
name|lit_t
operator|&&
name|phase2
operator|&&
name|checker
operator|&&
name|popper
operator|&&
name|a
operator|&&
name|whole_thing
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
name|RX_bitset_enjoin
argument_list|(
name|cs
argument_list|,
literal|'t'
argument_list|)
expr_stmt|;
operator|*
name|last_expression
operator|=
name|whole_thing
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rexp_node
modifier|*
name|star
init|=
operator|(
name|many_times_ok
condition|?
name|rx_mk_r_star
else|:
name|rx_mk_r_opt
operator|)
operator|(
operator|&
name|rxb
operator|->
name|rx
expr|,
operator|*
name|last_expression
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|last_expression
operator|=
name|star
expr_stmt|;
name|need_sync
operator|=
name|has_any_se
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|*
name|last_expression
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zero_times_ok
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|concat
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|inner_exp
argument_list|,
name|rx_copy_rexp
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|*
name|last_expression
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|concat
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|last_expression
operator|=
name|concat
expr_stmt|;
block|}
if|if
condition|(
name|need_sync
condition|)
block|{
name|int
name|sync_se
init|=
name|paramc
decl_stmt|;
name|params
operator|=
operator|(
name|params
condition|?
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|realloc
argument_list|(
name|params
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
operator|*
operator|(
literal|1
operator|+
name|paramc
operator|)
argument_list|)
operator|)
else|:
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|REG_ESPACE
return|;
operator|++
name|paramc
expr_stmt|;
name|params
index|[
name|sync_se
index|]
operator|.
name|se
operator|=
name|re_se_tv
expr_stmt|;
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|sync_se
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
block|}
block|}
comment|/* The old regex.c used to optimize `.*\n'.   	     * Maybe rx should too? 	     */
block|}
break|break;
case|case
literal|'.'
case|:
block|{
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|n
init|=
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cs
operator|&&
name|n
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
name|rx_bitset_universe
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxb
operator|->
name|syntax
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|RX_bitset_remove
argument_list|(
name|cs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxb
operator|->
name|syntax
operator|&
name|RE_DOT_NOT_NULL
operator|)
condition|)
name|RX_bitset_remove
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|append
operator|=
name|n
expr_stmt|;
goto|goto
name|append_node
goto|;
break|break;
block|}
case|case
literal|'['
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EBRACK
return|;
block|{
name|boolean
name|had_char_class
init|=
name|false
decl_stmt|;
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|node
init|=
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|int
name|is_inverted
init|=
operator|*
name|p
operator|==
literal|'^'
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|&&
name|cs
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
comment|/* This branch of the switch is normally exited with 	     *`goto append_node' 	     */
name|append
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|is_inverted
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Remember the first position in the bracket expression.  */
name|p1
operator|=
name|p
expr_stmt|;
comment|/* Read in characters and ranges, setting map bits.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EBRACK
return|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* \ might escape characters inside [...] and [^...].  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EESCAPE
return|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
name|c1
argument_list|)
decl_stmt|;
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Could be the end of the bracket expression.  If it's                    not (i.e., when the bracket expression is `[]' so                    far), the ']' character bit gets set way below.  */
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|p
operator|!=
name|p1
operator|+
literal|1
condition|)
goto|goto
name|finalize_class_and_append
goto|;
comment|/* Look ahead to see if it's a range when the last thing                    was a character class.  */
if|if
condition|(
name|had_char_class
operator|&&
name|c
operator|==
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
return|return
name|REG_ERANGE
return|;
comment|/* Look ahead to see if it's a range when the last thing                    was a character: if this is a hyphen not at the                    beginning or the end of a list, then it's the range                    operator.  */
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
operator|(
name|p
operator|-
literal|2
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'['
operator|)
operator|&&
operator|!
operator|(
name|p
operator|-
literal|3
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|3
index|]
operator|==
literal|'['
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'^'
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|reg_errcode_t
name|ret
init|=
name|compile_range
argument_list|(
name|rxb
argument_list|,
name|cs
argument_list|,
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|inverse_translate
argument_list|,
name|validate_inv_tr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
comment|/* This handles ranges made up of characters only.  */
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* Move past the `-'.  */
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|compile_range
argument_list|(
name|rxb
argument_list|,
name|cs
argument_list|,
operator|&
name|p
argument_list|,
name|pend
argument_list|,
name|translate
argument_list|,
name|syntax
argument_list|,
name|inverse_translate
argument_list|,
name|validate_inv_tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|REG_NOERROR
condition|)
return|return
name|ret
return|;
block|}
comment|/* See if we're at the beginning of a possible character                    class.  */
elseif|else
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_CHAR_CLASSES
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'['
operator|)
operator|&&
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
condition|)
block|{
name|char
name|str
index|[
name|CHAR_CLASS_MAX_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If pattern is `[[:'.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EBRACK
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|']'
operator|||
name|p
operator|==
name|pend
operator|||
name|c1
operator|==
name|CHAR_CLASS_MAX_LENGTH
condition|)
break|break;
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If isn't a word bracketed by `[:' and:`]':                        undo the ending character, the letters, and leave                         the leading `:' and `[' (but set bits for them).  */
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|boolean
name|is_alnum
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"alnum"
argument_list|)
decl_stmt|;
name|boolean
name|is_alpha
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"alpha"
argument_list|)
decl_stmt|;
name|boolean
name|is_blank
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"blank"
argument_list|)
decl_stmt|;
name|boolean
name|is_cntrl
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cntrl"
argument_list|)
decl_stmt|;
name|boolean
name|is_digit
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"digit"
argument_list|)
decl_stmt|;
name|boolean
name|is_graph
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"graph"
argument_list|)
decl_stmt|;
name|boolean
name|is_lower
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
decl_stmt|;
name|boolean
name|is_print
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"print"
argument_list|)
decl_stmt|;
name|boolean
name|is_punct
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"punct"
argument_list|)
decl_stmt|;
name|boolean
name|is_space
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"space"
argument_list|)
decl_stmt|;
name|boolean
name|is_upper
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
decl_stmt|;
name|boolean
name|is_xdigit
init|=
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"xdigit"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_CHAR_CLASS
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|REG_ECTYPE
return|;
comment|/* Throw away the ] at the end of the character                            class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EBRACK
return|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|1
operator|<<
name|CHARBITS
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|is_alnum
operator|&&
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_alpha
operator|&&
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_blank
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_cntrl
operator|&&
name|iscntrl
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_digit
operator|&&
name|isdigit
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_graph
operator|&&
name|isgraph
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_lower
operator|&&
name|islower
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_print
operator|&&
name|isprint
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_punct
operator|&&
name|ispunct
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_space
operator|&&
name|isspace
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_upper
operator|&&
name|isupper
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|(
name|is_xdigit
operator|&&
name|isxdigit
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
name|ch
argument_list|)
decl_stmt|;
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
block|}
name|had_char_class
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
literal|'['
argument_list|)
decl_stmt|;
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
name|had_char_class
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|had_char_class
operator|=
name|false
expr_stmt|;
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|rx_bitset_union
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|finalize_class_and_append
label|:
if|if
condition|(
name|is_inverted
condition|)
block|{
name|rx_bitset_complement
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
condition|)
name|RX_bitset_remove
argument_list|(
name|cs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
goto|goto
name|append_node
goto|;
block|}
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|handle_open
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|handle_close
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NEWLINE_ALT
condition|)
goto|goto
name|handle_alt
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
condition|)
goto|goto
name|handle_alt
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'{'
case|:
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
goto|goto
name|handle_interval
goto|;
else|else
goto|goto
name|normal_char
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
return|return
name|REG_EESCAPE
return|;
comment|/* Do not translate the character after the \, so that we can              distinguish, e.g., \B from \b, even if we normally would              translate, e.g., B to b.  */
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_open
label|:
name|rxb
operator|->
name|re_nsub
operator|++
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
if|if
condition|(
name|COMPILE_STACK_FULL
condition|)
block|{
operator|(
operator|(
name|compile_stack
operator|.
name|stack
operator|)
operator|=
operator|(
name|compile_stack_elt_t
operator|*
operator|)
name|realloc
argument_list|(
name|compile_stack
operator|.
name|stack
argument_list|,
operator|(
name|compile_stack
operator|.
name|size
operator|<<
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|compile_stack_elt_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|compile_stack
operator|.
name|stack
operator|==
literal|0
condition|)
return|return
name|REG_ESPACE
return|;
name|compile_stack
operator|.
name|size
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|last_expression
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|concat
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|*
name|last_expression
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|concat
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|last_expression
operator|=
name|concat
expr_stmt|;
name|last_expression
operator|=
operator|&
name|concat
operator|->
name|params
operator|.
name|pair
operator|.
name|right
expr_stmt|;
block|}
comment|/* 	       * These are the values to restore when we hit end of this                * group.   	       */
name|COMPILE_STACK_TOP
operator|.
name|top_expression
operator|=
name|top_expression
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|last_expression
operator|=
name|last_expression
expr_stmt|;
name|COMPILE_STACK_TOP
operator|.
name|regnum
operator|=
name|regnum
expr_stmt|;
name|compile_stack
operator|.
name|avail
operator|++
expr_stmt|;
name|top_expression
operator|=
name|last_expression
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_close
label|:
comment|/* See similar code for backslashed left paren above.  */
if|if
condition|(
name|COMPILE_STACK_EMPTY
condition|)
if|if
condition|(
name|syntax
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_char
goto|;
else|else
return|return
name|REG_ERPAREN
return|;
comment|/* Since we just checked for an empty stack above, this                  ``can't happen''.  */
block|{
comment|/* We don't just want to restore into `regnum', because                    later groups should continue to be numbered higher,                    as in `(ab)c(de)' -- the second group is #2.  */
name|regnum_t
name|this_group_regnum
decl_stmt|;
name|struct
name|rexp_node
modifier|*
modifier|*
name|inner
init|=
name|top_expression
decl_stmt|;
name|compile_stack
operator|.
name|avail
operator|--
expr_stmt|;
name|top_expression
operator|=
name|COMPILE_STACK_TOP
operator|.
name|top_expression
expr_stmt|;
name|last_expression
operator|=
name|COMPILE_STACK_TOP
operator|.
name|last_expression
expr_stmt|;
name|this_group_regnum
operator|=
name|COMPILE_STACK_TOP
operator|.
name|regnum
expr_stmt|;
block|{
name|int
name|left_se
init|=
name|paramc
decl_stmt|;
name|int
name|right_se
init|=
name|paramc
operator|+
literal|1
decl_stmt|;
name|params
operator|=
operator|(
name|params
condition|?
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|realloc
argument_list|(
name|params
argument_list|,
operator|(
name|paramc
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
else|:
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|REG_ESPACE
return|;
name|paramc
operator|+=
literal|2
expr_stmt|;
name|params
index|[
name|left_se
index|]
operator|.
name|se
operator|=
name|re_se_lparen
expr_stmt|;
name|params
index|[
name|left_se
index|]
operator|.
name|op1
operator|=
name|this_group_regnum
expr_stmt|;
name|params
index|[
name|right_se
index|]
operator|.
name|se
operator|=
name|re_se_rparen
expr_stmt|;
name|params
index|[
name|right_se
index|]
operator|.
name|op1
operator|=
name|this_group_regnum
expr_stmt|;
block|{
name|struct
name|rexp_node
modifier|*
name|left
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|left_se
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|right
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|right_se
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|c1
init|=
operator|(
operator|*
name|inner
condition|?
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|left
argument_list|,
operator|*
name|inner
argument_list|)
else|:
name|left
operator|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|c2
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|c1
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|left
operator|&&
name|right
operator|&&
name|c1
operator|&&
name|c2
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|inner
operator|=
name|c2
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|'|'
case|:
comment|/* `\|'.  */
if|if
condition|(
operator|(
name|syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|||
operator|(
name|syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_alt
label|:
if|if
condition|(
name|syntax
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
block|{
name|struct
name|rexp_node
modifier|*
name|alt
init|=
name|rx_mk_r_alternate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|*
name|top_expression
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alt
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|top_expression
operator|=
name|alt
expr_stmt|;
name|last_expression
operator|=
operator|&
name|alt
operator|->
name|params
operator|.
name|pair
operator|.
name|right
expr_stmt|;
block|{
name|int
name|sync_se
init|=
name|paramc
decl_stmt|;
name|params
operator|=
operator|(
name|params
condition|?
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|realloc
argument_list|(
name|params
argument_list|,
operator|(
name|paramc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
else|:
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|REG_ESPACE
return|;
operator|++
name|paramc
expr_stmt|;
name|params
index|[
name|sync_se
index|]
operator|.
name|se
operator|=
name|re_se_tv
expr_stmt|;
block|{
name|struct
name|rexp_node
modifier|*
name|sync
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|sync_se
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|conc
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|sync
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sync
operator|||
operator|!
name|conc
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|last_expression
operator|=
name|conc
expr_stmt|;
name|last_expression
operator|=
operator|&
name|conc
operator|->
name|params
operator|.
name|pair
operator|.
name|right
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'{'
case|:
comment|/* If \{ is a literal.  */
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
comment|/* If we're at `\{' and it's not the open-interval                          operator.  */
operator|||
operator|(
operator|(
name|syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
operator|)
operator|||
operator|(
name|p
operator|-
literal|2
operator|==
name|pattern
operator|&&
name|p
operator|==
name|pend
operator|)
condition|)
goto|goto
name|normal_backslash
goto|;
name|handle_interval
label|:
block|{
comment|/* If got here, then the syntax allows intervals.  */
comment|/* At least (most) this many matches must be made.  */
name|int
name|lower_bound
init|=
operator|-
literal|1
decl_stmt|,
name|upper_bound
init|=
operator|-
literal|1
decl_stmt|;
name|beg_interval
operator|=
name|p
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
return|return
name|REG_EBRACE
return|;
block|}
name|GET_UNSIGNED_NUMBER
argument_list|(
name|lower_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|GET_UNSIGNED_NUMBER
argument_list|(
name|upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper_bound
operator|<
literal|0
condition|)
name|upper_bound
operator|=
name|RE_DUP_MAX
expr_stmt|;
block|}
else|else
comment|/* Interval such as `{1}' => match exactly once. */
name|upper_bound
operator|=
name|lower_bound
expr_stmt|;
if|if
condition|(
name|lower_bound
operator|<
literal|0
operator|||
name|upper_bound
operator|>
name|RE_DUP_MAX
operator|||
name|lower_bound
operator|>
name|upper_bound
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
return|return
name|REG_BADBR
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
return|return
name|REG_EBRACE
return|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
return|return
name|REG_BADBR
return|;
block|}
comment|/* We just parsed a valid interval.  */
comment|/* If it's invalid to have no preceding re.  */
if|if
condition|(
name|pointless_if_repeated
argument_list|(
operator|*
name|last_expression
argument_list|,
name|params
argument_list|)
condition|)
block|{
if|if
condition|(
name|syntax
operator|&
name|RE_CONTEXT_INVALID_OPS
condition|)
return|return
name|REG_BADRPT
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|unfetch_interval
goto|;
comment|/* was: else laststart = b; */
block|}
comment|/* If the upper bound is zero, don't want to iterate                  * at all. 		 */
if|if
condition|(
name|upper_bound
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|last_expression
condition|)
block|{
name|rx_free_rexp
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|*
name|last_expression
argument_list|)
expr_stmt|;
operator|*
name|last_expression
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
comment|/* Otherwise, we have a nontrivial interval. */
block|{
name|int
name|iter_se
init|=
name|paramc
decl_stmt|;
name|int
name|end_se
init|=
name|paramc
operator|+
literal|1
decl_stmt|;
name|params
operator|=
operator|(
name|params
condition|?
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|realloc
argument_list|(
name|params
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
operator|*
operator|(
literal|2
operator|+
name|paramc
operator|)
argument_list|)
operator|)
else|:
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|REG_ESPACE
return|;
name|paramc
operator|+=
literal|2
expr_stmt|;
name|params
index|[
name|iter_se
index|]
operator|.
name|se
operator|=
name|re_se_iter
expr_stmt|;
name|params
index|[
name|iter_se
index|]
operator|.
name|op1
operator|=
name|lower_bound
expr_stmt|;
name|params
index|[
name|iter_se
index|]
operator|.
name|op2
operator|=
name|upper_bound
expr_stmt|;
name|params
index|[
name|end_se
index|]
operator|.
name|se
operator|=
name|re_se_end_iter
expr_stmt|;
name|params
index|[
name|end_se
index|]
operator|.
name|op1
operator|=
name|lower_bound
expr_stmt|;
name|params
index|[
name|end_se
index|]
operator|.
name|op2
operator|=
name|upper_bound
expr_stmt|;
block|{
name|struct
name|rexp_node
modifier|*
name|push0
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_push0
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|start_one_iter
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|iter_se
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|phase1
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|start_one_iter
argument_list|,
operator|*
name|last_expression
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|pushback
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_pushback
argument_list|)
decl_stmt|;
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|lit_t
init|=
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|phase2
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|pushback
argument_list|,
name|lit_t
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|loop
init|=
name|rx_mk_r_2phase_star
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|phase1
argument_list|,
name|phase2
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|push_n_loop
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|push0
argument_list|,
name|loop
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|final_test
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|end_se
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|full_exp
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|push_n_loop
argument_list|,
name|final_test
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|push0
operator|&&
name|start_one_iter
operator|&&
name|phase1
operator|&&
name|pushback
operator|&&
name|lit_t
operator|&&
name|phase2
operator|&&
name|loop
operator|&&
name|push_n_loop
operator|&&
name|final_test
operator|&&
name|full_exp
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
name|RX_bitset_enjoin
argument_list|(
name|cs
argument_list|,
literal|'t'
argument_list|)
expr_stmt|;
operator|*
name|last_expression
operator|=
name|full_exp
expr_stmt|;
block|}
block|}
name|beg_interval
operator|=
literal|0
expr_stmt|;
block|}
break|break;
name|unfetch_interval
label|:
comment|/* If an invalid interval, match the characters as literals.  */
name|p
operator|=
name|beg_interval
expr_stmt|;
name|beg_interval
operator|=
name|NULL
expr_stmt|;
comment|/* normal_char and normal_backslash need `c'.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|pattern
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
goto|goto
name|normal_backslash
goto|;
block|}
goto|goto
name|normal_char
goto|;
ifdef|#
directive|ifdef
name|emacs
comment|/* There is no way to specify the before_dot and after_dot                operators.  rms says this is ok.  --karl  */
case|case
literal|'='
case|:
name|side
operator|=
name|at_dot
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
block|{
name|rx_Bitset
name|cs
init|=
name|cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|set
init|=
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cs
operator|&&
name|set
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
if|if
condition|(
name|c
operator|==
literal|'S'
condition|)
name|rx_bitset_universe
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|char
name|code
init|=
name|syntax_spec_code
argument_list|(
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|SYNTAX
argument_list|(
name|x
argument_list|)
operator|&
name|code
condition|)
block|{
name|rx_Bitset
name|it
init|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|rx_bitset_xor
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|append_node
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
block|{
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|n
init|=
operator|(
name|cs
condition|?
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cs
operator|&&
name|n
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
if|if
condition|(
name|c
operator|==
literal|'W'
condition|)
name|rx_bitset_universe
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
operator|-
literal|1
init|;
name|x
operator|>
literal|0
condition|;
operator|--
name|x
control|)
if|if
condition|(
name|re_syntax_table
index|[
name|x
index|]
operator|&
name|Sword
condition|)
name|RX_bitset_toggle
argument_list|(
name|cs
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|append
operator|=
name|n
expr_stmt|;
goto|goto
name|append_node
goto|;
block|}
break|break;
comment|/* With a little extra work, some of these side effects could be optimized  * away (basicly by looking at what we already know about the surrounding  * chars).    */
case|case
literal|'<'
case|:
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|re_se_wordbeg
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
case|case
literal|'>'
case|:
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|re_se_wordend
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
case|case
literal|'b'
case|:
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|re_se_wordbound
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
case|case
literal|'B'
case|:
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|re_se_notwordbound
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
case|case
literal|'`'
case|:
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|re_se_begbuf
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
case|case
literal|'\''
case|:
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|re_se_endbuf
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
break|break;
name|add_side_effect
label|:
block|{
name|struct
name|rexp_node
modifier|*
name|se
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|side
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|se
condition|)
return|return
name|REG_ESPACE
return|;
name|append
operator|=
name|se
expr_stmt|;
goto|goto
name|append_node
goto|;
block|}
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_NO_BK_REFS
condition|)
goto|goto
name|normal_char
goto|;
name|c1
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c1
operator|>
name|regnum
condition|)
return|return
name|REG_ESUBREG
return|;
comment|/* Can't back reference to a subexpression if inside of it.  */
if|if
condition|(
name|group_in_compile_stack
argument_list|(
name|compile_stack
argument_list|,
name|c1
argument_list|)
condition|)
return|return
name|REG_ESUBREG
return|;
block|{
name|int
name|backref_se
init|=
name|paramc
decl_stmt|;
name|params
operator|=
operator|(
name|params
condition|?
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|realloc
argument_list|(
name|params
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
operator|*
operator|(
literal|1
operator|+
name|paramc
operator|)
argument_list|)
operator|)
else|:
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|REG_ESPACE
return|;
operator|++
name|paramc
expr_stmt|;
name|params
index|[
name|backref_se
index|]
operator|.
name|se
operator|=
name|re_se_backref
expr_stmt|;
name|params
index|[
name|backref_se
index|]
operator|.
name|op1
operator|=
name|c1
expr_stmt|;
name|side
operator|=
operator|(
name|rx_side_effect
operator|)
name|backref_se
expr_stmt|;
goto|goto
name|add_side_effect
goto|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|handle_plus
goto|;
else|else
goto|goto
name|normal_backslash
goto|;
default|default:
name|normal_backslash
label|:
comment|/* You might think it would be useful for \ to mean                  not to translate; but if we don't translate it                  it will never match anything.  */
name|c
operator|=
name|TRANSLATE
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|normal_char
goto|;
block|}
break|break;
default|default:
comment|/* Expects the character in `c'.  */
name|normal_char
label|:
block|{
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|match
init|=
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|rx_Bitset
name|it
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cs
operator|&&
name|match
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
name|it
operator|=
name|inverse_translation
argument_list|(
name|rxb
argument_list|,
name|validate_inv_tr
argument_list|,
name|inverse_translate
argument_list|,
name|translate
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rx_bitset_union
argument_list|(
name|CHAR_SET_SIZE
argument_list|,
name|cs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|append
operator|=
name|match
expr_stmt|;
name|append_node
label|:
comment|/* This genericly appends the rexp APPEND to *LAST_EXPRESSION 	       * and then parses the next character normally. 	       */
if|if
condition|(
operator|*
name|last_expression
condition|)
block|{
name|struct
name|rexp_node
modifier|*
name|concat
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|*
name|last_expression
argument_list|,
name|append
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|concat
condition|)
return|return
name|REG_ESPACE
return|;
operator|*
name|last_expression
operator|=
name|concat
expr_stmt|;
name|last_expression
operator|=
operator|&
name|concat
operator|->
name|params
operator|.
name|pair
operator|.
name|right
expr_stmt|;
block|}
else|else
operator|*
name|last_expression
operator|=
name|append
expr_stmt|;
block|}
block|}
comment|/* switch (c) */
block|}
comment|/* while p != pend */
block|{
name|int
name|win_se
init|=
name|paramc
decl_stmt|;
name|params
operator|=
operator|(
name|params
condition|?
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|realloc
argument_list|(
name|params
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
operator|*
operator|(
literal|1
operator|+
name|paramc
operator|)
argument_list|)
operator|)
else|:
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|REG_ESPACE
return|;
operator|++
name|paramc
expr_stmt|;
name|params
index|[
name|win_se
index|]
operator|.
name|se
operator|=
name|re_se_win
expr_stmt|;
block|{
name|struct
name|rexp_node
modifier|*
name|se
init|=
name|rx_mk_r_side_effect
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|win_se
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|concat
init|=
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rexp
argument_list|,
name|se
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|se
operator|&&
name|concat
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
name|rexp
operator|=
name|concat
expr_stmt|;
block|}
block|}
comment|/* Through the pattern now.  */
if|if
condition|(
operator|!
name|COMPILE_STACK_EMPTY
condition|)
return|return
name|REG_EPAREN
return|;
name|free
argument_list|(
name|compile_stack
operator|.
name|stack
argument_list|)
expr_stmt|;
name|orig_rexp
operator|=
name|rexp
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
if|if
condition|(
name|rx_debug_compile
condition|)
block|{
name|dbug_rxb
operator|=
name|rxb
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\nCompiling "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|se_params
operator|=
name|params
expr_stmt|;
name|print_rexp
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|orig_rexp
argument_list|,
literal|2
argument_list|,
name|re_seprint
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|{
name|rx_Bitset
name|cs
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|rx_Bitset
name|cs2
init|=
name|rx_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
decl_stmt|;
name|char
modifier|*
name|se_map
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|paramc
argument_list|)
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|new_rexp
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|se_map
argument_list|,
name|paramc
argument_list|)
expr_stmt|;
name|find_backrefs
argument_list|(
name|se_map
argument_list|,
name|rexp
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|fewer_side_effects
operator|=
name|remove_unecessary_side_effects
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|se_map
argument_list|,
name|rx_copy_rexp
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rexp
argument_list|)
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|speed_up_alt
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|speed_up_alt
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|fewer_side_effects
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|syntax_parens
init|=
name|rxb
operator|->
name|syntax_parens
decl_stmt|;
if|if
condition|(
name|syntax_parens
operator|==
operator|(
name|char
operator|*
operator|)
literal|0x1
condition|)
name|rexp
operator|=
name|remove_unecessary_side_effects
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|se_map
argument_list|,
name|rexp
argument_list|,
name|params
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syntax_parens
condition|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|paramc
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
operator|(
name|params
index|[
name|x
index|]
operator|.
name|se
operator|==
name|re_se_lparen
operator|)
operator|||
operator|(
name|params
index|[
name|x
index|]
operator|.
name|se
operator|==
name|re_se_rparen
operator|)
operator|)
operator|&&
operator|(
operator|!
name|syntax_parens
index|[
name|params
index|[
name|x
index|]
operator|.
name|op1
index|]
operator|)
condition|)
name|se_map
index|[
name|x
index|]
operator|=
literal|1
expr_stmt|;
name|rexp
operator|=
name|remove_unecessary_side_effects
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|se_map
argument_list|,
name|rexp
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At least one more optimization would be nice to have here but i ran out       * of time.  The idea would be to delay side effects.        * For examle, `(abc)' is the same thing as `abc()' except that the      * left paren is offset by 3 (which we know at compile time).      * (In this comment, write that second pattern `abc(:3:)'       * where `(:3:' is a syntactic unit.)      *      * Trickier:  `(abc|defg)'  is the same as `(abc(:3:|defg(:4:))'      * (The paren nesting may be hard to follow -- that's an alternation      *	of `abc(:3:' and `defg(:4:' inside (purely syntactic) parens      *  followed by the closing paren from the original expression.)      *      * Neither the expression tree representation nor the the nfa make      * this very easy to write. :(      */
comment|/* What we compile is different than what the parser returns.    * Suppose the parser returns expression R.    * Let R' be R with unnecessary register assignments removed     * (see REMOVE_UNECESSARY_SIDE_EFFECTS, above).    *    * What we will compile is the expression:    *    *    m{try}R{win}\|s{try}R'{win}    *    * {try} and {win} denote side effect epsilons (see EXPLORE_FUTURE).    *     * When trying a match, we insert an `m' at the beginning of the     * string if the user wants registers to be filled, `s' if not.    */
name|new_rexp
operator|=
name|rx_mk_r_alternate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs2
argument_list|)
argument_list|,
name|rexp
argument_list|)
argument_list|,
name|rx_mk_r_concat
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rx_mk_r_cset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|cs
argument_list|)
argument_list|,
name|fewer_side_effects
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|new_rexp
operator|&&
name|cs
operator|&&
name|cs2
operator|)
condition|)
return|return
name|REG_ESPACE
return|;
name|RX_bitset_enjoin
argument_list|(
name|cs2
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* prefixed to the rexp used for matching. */
name|RX_bitset_enjoin
argument_list|(
name|cs
argument_list|,
literal|'\1'
argument_list|)
expr_stmt|;
comment|/* prefixed to the rexp used for searching. */
name|rexp
operator|=
name|new_rexp
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RX_DEBUG
if|if
condition|(
name|rx_debug_compile
condition|)
block|{
name|fputs
argument_list|(
literal|"\n...which is compiled as:\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_rexp
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rexp
argument_list|,
literal|2
argument_list|,
name|re_seprint
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|{
name|struct
name|rx_nfa_state
modifier|*
name|start
init|=
literal|0
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|end
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|rx_build_nfa
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rexp
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
comment|/*  */
else|else
block|{
name|void
modifier|*
name|mem
init|=
operator|(
name|void
operator|*
operator|)
name|rxb
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|long
name|size
init|=
name|rxb
operator|->
name|allocated
decl_stmt|;
name|int
name|start_id
decl_stmt|;
name|char
modifier|*
name|perm_mem
decl_stmt|;
name|int
name|iterator_size
init|=
name|paramc
operator|*
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|end
operator|->
name|is_final
operator|=
literal|1
expr_stmt|;
name|start
operator|->
name|is_start
operator|=
literal|1
expr_stmt|;
name|rx_name_nfa_states
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
expr_stmt|;
name|start_id
operator|=
name|start
operator|->
name|id
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
if|if
condition|(
name|rx_debug_compile
condition|)
block|{
name|fputs
argument_list|(
literal|"...giving the NFA: \n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|dbug_rxb
operator|=
name|rxb
expr_stmt|;
name|print_nfa
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rxb
operator|->
name|rx
operator|.
name|nfa_states
argument_list|,
name|re_seprint
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|rx_eclose_nfa
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
else|else
block|{
name|rx_delete_epsilon_transitions
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|)
expr_stmt|;
comment|/* For compatability reasons, we need to shove the 	     * compiled nfa into one chunk of malloced memory. 	     */
name|rxb
operator|->
name|rx
operator|.
name|reserved
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
operator|*
name|paramc
operator|+
name|rx_sizeof_bitset
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
if|if
condition|(
name|rx_debug_compile
condition|)
block|{
name|dbug_rxb
operator|=
name|rxb
expr_stmt|;
name|fputs
argument_list|(
literal|"...which cooks down (uncompactified) to: \n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_nfa
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rxb
operator|->
name|rx
operator|.
name|nfa_states
argument_list|,
name|re_seprint
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|rx_compactify_nfa
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
operator|&
name|mem
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|REG_ESPACE
return|;
name|rxb
operator|->
name|buffer
operator|=
name|mem
expr_stmt|;
name|rxb
operator|->
name|allocated
operator|=
name|size
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|buffer
operator|=
name|mem
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|allocated
operator|=
name|size
expr_stmt|;
name|perm_mem
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|rxb
operator|->
name|rx
operator|.
name|buffer
operator|+
name|rxb
operator|->
name|rx
operator|.
name|allocated
operator|-
name|rxb
operator|->
name|rx
operator|.
name|reserved
operator|)
expr_stmt|;
name|rxb
operator|->
name|se_params
operator|=
operator|(
operator|(
expr|struct
name|re_se_params
operator|*
operator|)
name|perm_mem
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|params
argument_list|,
name|rxb
operator|->
name|se_params
argument_list|,
name|iterator_size
argument_list|)
expr_stmt|;
name|perm_mem
operator|+=
name|iterator_size
expr_stmt|;
name|rxb
operator|->
name|fastset
operator|=
operator|(
name|rx_Bitset
operator|)
name|perm_mem
expr_stmt|;
name|rxb
operator|->
name|start
operator|=
name|rx_id_to_nfa_state
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|start_id
argument_list|)
expr_stmt|;
block|}
name|rx_bitset_null
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|rxb
operator|->
name|fastset
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|can_match_empty
operator|=
name|compute_fastset
argument_list|(
name|rxb
argument_list|,
name|orig_rexp
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|match_regs_on_stack
operator|=
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|orig_rexp
argument_list|,
literal|0
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|search_regs_on_stack
operator|=
name|registers_on_stack
argument_list|(
name|rxb
argument_list|,
name|fewer_side_effects
argument_list|,
literal|0
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxb
operator|->
name|can_match_empty
condition|)
name|rx_bitset_universe
argument_list|(
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
argument_list|,
name|rxb
operator|->
name|fastset
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|is_anchored
operator|=
name|is_anchored
argument_list|(
name|orig_rexp
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_hat
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|begbuf_only
operator|=
name|is_anchored
argument_list|(
name|orig_rexp
argument_list|,
operator|(
name|rx_side_effect
operator|)
name|re_se_begbuf
argument_list|)
expr_stmt|;
block|}
name|rx_free_rexp
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
condition|)
name|free
argument_list|(
name|params
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
if|if
condition|(
name|rx_debug_compile
condition|)
block|{
name|dbug_rxb
operator|=
name|rxb
expr_stmt|;
name|fputs
argument_list|(
literal|"...which cooks down to: \n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_nfa
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rxb
operator|->
name|rx
operator|.
name|nfa_states
argument_list|,
name|re_seprint
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|REG_NOERROR
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This table gives an error message for each of the error codes listed    in regex.h.  Obviously the order here has to be same as there.  */
end_comment

begin_decl_stmt
name|__const__
name|char
modifier|*
name|rx_error_msg
index|[]
init|=
block|{
literal|0
block|,
comment|/* REG_NOERROR */
literal|"No match"
block|,
comment|/* REG_NOMATCH */
literal|"Invalid regular expression"
block|,
comment|/* REG_BADPAT */
literal|"Invalid collation character"
block|,
comment|/* REG_ECOLLATE */
literal|"Invalid character class name"
block|,
comment|/* REG_ECTYPE */
literal|"Trailing backslash"
block|,
comment|/* REG_EESCAPE */
literal|"Invalid back reference"
block|,
comment|/* REG_ESUBREG */
literal|"Unmatched [ or [^"
block|,
comment|/* REG_EBRACK */
literal|"Unmatched ( or \\("
block|,
comment|/* REG_EPAREN */
literal|"Unmatched \\{"
block|,
comment|/* REG_EBRACE */
literal|"Invalid content of \\{\\}"
block|,
comment|/* REG_BADBR */
literal|"Invalid range end"
block|,
comment|/* REG_ERANGE */
literal|"Memory exhausted"
block|,
comment|/* REG_ESPACE */
literal|"Invalid preceding regular expression"
block|,
comment|/* REG_BADRPT */
literal|"Premature end of regular expression"
block|,
comment|/* REG_EEND */
literal|"Regular expression too big"
block|,
comment|/* REG_ESIZE */
literal|"Unmatched ) or \\)"
block|,
comment|/* REG_ERPAREN */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|char
name|rx_slowmap
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|void
name|rx_blow_up_fastmap
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|)
else|#
directive|else
name|RX_DECL
name|void
name|rx_blow_up_fastmap
argument_list|(
name|rxb
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
operator|++
name|x
control|)
comment|/*&&&& 3.6 % */
name|rxb
operator|->
name|fastmap
index|[
name|x
index|]
operator|=
operator|!
operator|!
name|RX_bitset_member
argument_list|(
name|rxb
operator|->
name|fastset
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|rxb
operator|->
name|fastmap_accurate
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REGEX_MALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|RE_SEARCH_2_FN
value|inner_re_search_2
end_define

begin_define
define|#
directive|define
name|RE_S2_QUAL
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RE_SEARCH_2_FN
value|re_search_2
end_define

begin_define
define|#
directive|define
name|RE_S2_QUAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|re_search_2_closure
block|{
name|__const__
name|char
modifier|*
name|string1
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|__const__
name|char
modifier|*
name|string2
decl_stmt|;
name|int
name|size2
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|__inline__
name|enum
name|rx_get_burst_return
name|re_search_2_get_burst
parameter_list|(
name|pos
parameter_list|,
name|vclosure
parameter_list|,
name|stop
parameter_list|)
name|struct
name|rx_string_position
modifier|*
name|pos
decl_stmt|;
name|void
modifier|*
name|vclosure
decl_stmt|;
name|int
name|stop
decl_stmt|;
block|{
name|struct
name|re_search_2_closure
modifier|*
name|closure
decl_stmt|;
name|closure
operator|=
operator|(
expr|struct
name|re_search_2_closure
operator|*
operator|)
name|vclosure
expr_stmt|;
if|if
condition|(
operator|!
name|closure
operator|->
name|string2
condition|)
block|{
name|int
name|inset
decl_stmt|;
name|inset
operator|=
name|pos
operator|->
name|pos
operator|-
name|pos
operator|->
name|string
expr_stmt|;
if|if
condition|(
operator|(
name|inset
operator|<
literal|0
operator|)
operator|||
operator|(
name|inset
operator|>
name|closure
operator|->
name|size1
operator|)
condition|)
return|return
name|rx_get_burst_no_more
return|;
else|else
block|{
name|pos
operator|->
name|pos
operator|=
name|closure
operator|->
name|string1
operator|+
name|inset
expr_stmt|;
name|pos
operator|->
name|string
operator|=
name|closure
operator|->
name|string1
expr_stmt|;
name|pos
operator|->
name|size
operator|=
name|closure
operator|->
name|size1
expr_stmt|;
name|pos
operator|->
name|end
operator|=
operator|(
operator|(
name|__const__
name|unsigned
name|char
operator|*
operator|)
name|MIN
argument_list|(
name|closure
operator|->
name|string1
operator|+
name|closure
operator|->
name|size1
argument_list|,
name|closure
operator|->
name|string1
operator|+
name|stop
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|pos
operator|->
name|pos
operator|<
name|pos
operator|->
name|end
operator|)
condition|?
name|rx_get_burst_ok
else|:
name|rx_get_burst_no_more
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|closure
operator|->
name|string1
condition|)
block|{
name|int
name|inset
decl_stmt|;
name|inset
operator|=
name|pos
operator|->
name|pos
operator|-
name|pos
operator|->
name|string
expr_stmt|;
name|pos
operator|->
name|pos
operator|=
name|closure
operator|->
name|string2
operator|+
name|inset
expr_stmt|;
name|pos
operator|->
name|string
operator|=
name|closure
operator|->
name|string2
expr_stmt|;
name|pos
operator|->
name|size
operator|=
name|closure
operator|->
name|size2
expr_stmt|;
name|pos
operator|->
name|end
operator|=
operator|(
operator|(
name|__const__
name|unsigned
name|char
operator|*
operator|)
name|MIN
argument_list|(
name|closure
operator|->
name|string2
operator|+
name|closure
operator|->
name|size2
argument_list|,
name|closure
operator|->
name|string2
operator|+
name|stop
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|pos
operator|->
name|pos
operator|<
name|pos
operator|->
name|end
operator|)
condition|?
name|rx_get_burst_ok
else|:
name|rx_get_burst_no_more
operator|)
return|;
block|}
else|else
block|{
name|int
name|inset
decl_stmt|;
name|inset
operator|=
name|pos
operator|->
name|pos
operator|-
name|pos
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|inset
operator|<
name|closure
operator|->
name|size1
condition|)
block|{
name|pos
operator|->
name|pos
operator|=
name|closure
operator|->
name|string1
operator|+
name|inset
expr_stmt|;
name|pos
operator|->
name|string
operator|=
name|closure
operator|->
name|string1
expr_stmt|;
name|pos
operator|->
name|size
operator|=
name|closure
operator|->
name|size1
expr_stmt|;
name|pos
operator|->
name|end
operator|=
operator|(
operator|(
name|__const__
name|unsigned
name|char
operator|*
operator|)
name|MIN
argument_list|(
name|closure
operator|->
name|string1
operator|+
name|closure
operator|->
name|size1
argument_list|,
name|closure
operator|->
name|string1
operator|+
name|stop
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|rx_get_burst_ok
return|;
block|}
else|else
block|{
name|pos
operator|->
name|pos
operator|=
name|closure
operator|->
name|string2
operator|+
name|inset
operator|-
name|closure
operator|->
name|size1
expr_stmt|;
name|pos
operator|->
name|string
operator|=
name|closure
operator|->
name|string2
expr_stmt|;
name|pos
operator|->
name|size
operator|=
name|closure
operator|->
name|size2
expr_stmt|;
name|pos
operator|->
name|end
operator|=
operator|(
operator|(
name|__const__
name|unsigned
name|char
operator|*
operator|)
name|MIN
argument_list|(
name|closure
operator|->
name|string2
operator|+
name|closure
operator|->
name|size2
argument_list|,
name|closure
operator|->
name|string2
operator|+
name|stop
operator|-
name|closure
operator|->
name|size1
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|->
name|offset
operator|=
name|closure
operator|->
name|size1
expr_stmt|;
return|return
operator|(
operator|(
name|pos
operator|->
name|pos
operator|<
name|pos
operator|->
name|end
operator|)
condition|?
name|rx_get_burst_ok
else|:
name|rx_get_burst_no_more
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline__
name|enum
name|rx_back_check_return
name|re_search_2_back_check
parameter_list|(
name|pos
parameter_list|,
name|lparen
parameter_list|,
name|rparen
parameter_list|,
name|translate
parameter_list|,
name|vclosure
parameter_list|,
name|stop
parameter_list|)
name|struct
name|rx_string_position
modifier|*
name|pos
decl_stmt|;
name|int
name|lparen
decl_stmt|;
name|int
name|rparen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
name|void
modifier|*
name|vclosure
decl_stmt|;
name|int
name|stop
decl_stmt|;
block|{
name|struct
name|rx_string_position
name|there
decl_stmt|;
name|struct
name|rx_string_position
name|past
decl_stmt|;
name|there
operator|=
operator|*
name|pos
expr_stmt|;
name|there
operator|.
name|pos
operator|=
name|there
operator|.
name|string
operator|+
name|lparen
operator|-
name|there
operator|.
name|offset
expr_stmt|;
name|re_search_2_get_burst
argument_list|(
operator|&
name|there
argument_list|,
name|vclosure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|past
operator|=
operator|*
name|pos
expr_stmt|;
name|past
operator|.
name|pos
operator|=
name|past
operator|.
name|string
operator|+
name|rparen
operator|-
name|there
operator|.
name|offset
expr_stmt|;
name|re_search_2_get_burst
argument_list|(
operator|&
name|past
argument_list|,
name|vclosure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
operator|++
name|pos
operator|->
name|pos
expr_stmt|;
name|re_search_2_get_burst
argument_list|(
name|pos
argument_list|,
name|vclosure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|there
operator|.
name|pos
operator|!=
name|past
operator|.
name|pos
operator|)
operator|&&
operator|(
name|pos
operator|->
name|pos
operator|!=
name|pos
operator|->
name|end
operator|)
condition|)
if|if
condition|(
name|TRANSLATE
argument_list|(
operator|*
name|there
operator|.
name|pos
argument_list|)
operator|!=
name|TRANSLATE
argument_list|(
operator|*
name|pos
operator|->
name|pos
argument_list|)
condition|)
return|return
name|rx_back_check_fail
return|;
else|else
block|{
operator|++
name|there
operator|.
name|pos
expr_stmt|;
operator|++
name|pos
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|there
operator|.
name|pos
operator|==
name|there
operator|.
name|end
condition|)
name|re_search_2_get_burst
argument_list|(
operator|&
name|there
argument_list|,
name|vclosure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|pos
operator|==
name|pos
operator|->
name|end
condition|)
name|re_search_2_get_burst
argument_list|(
name|pos
argument_list|,
name|vclosure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|there
operator|.
name|pos
operator|!=
name|past
operator|.
name|pos
condition|)
return|return
name|rx_back_check_fail
return|;
operator|--
name|pos
operator|->
name|pos
expr_stmt|;
name|re_search_2_get_burst
argument_list|(
name|pos
argument_list|,
name|vclosure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
return|return
name|rx_back_check_pass
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|re_search_2_fetch_char
parameter_list|(
name|pos
parameter_list|,
name|offset
parameter_list|,
name|app_closure
parameter_list|,
name|stop
parameter_list|)
name|struct
name|rx_string_position
modifier|*
name|pos
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|void
modifier|*
name|app_closure
decl_stmt|;
name|int
name|stop
decl_stmt|;
block|{
name|struct
name|re_search_2_closure
modifier|*
name|closure
decl_stmt|;
name|closure
operator|=
operator|(
expr|struct
name|re_search_2_closure
operator|*
operator|)
name|app_closure
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|*
name|pos
operator|->
name|pos
return|;
if|if
condition|(
name|pos
operator|->
name|pos
operator|==
name|pos
operator|->
name|end
condition|)
return|return
operator|*
name|closure
operator|->
name|string2
return|;
else|else
return|return
operator|*
name|pos
operator|->
name|pos
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RE_S2_QUAL
name|int
name|RE_SEARCH_2_FN
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|__const__
name|char
operator|*
name|string1
argument_list|,
name|int
name|size1
argument_list|,
name|__const__
name|char
operator|*
name|string2
argument_list|,
name|int
name|size2
argument_list|,
name|int
name|startpos
argument_list|,
name|int
name|range
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|stop
argument_list|)
else|#
directive|else
name|RE_S2_QUAL
name|int
name|RE_SEARCH_2_FN
argument_list|(
name|rxb
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|answer
decl_stmt|;
name|struct
name|re_search_2_closure
name|closure
decl_stmt|;
name|closure
operator|.
name|string1
operator|=
name|string1
expr_stmt|;
name|closure
operator|.
name|size1
operator|=
name|size1
expr_stmt|;
name|closure
operator|.
name|string2
operator|=
name|string2
expr_stmt|;
name|closure
operator|.
name|size2
operator|=
name|size2
expr_stmt|;
name|answer
operator|=
name|rx_search
argument_list|(
name|rxb
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|stop
argument_list|,
name|size1
operator|+
name|size2
argument_list|,
name|re_search_2_get_burst
argument_list|,
name|re_search_2_back_check
argument_list|,
name|re_search_2_fetch_char
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|closure
argument_list|,
name|regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|answer
condition|)
block|{
case|case
name|rx_search_continuation
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|rx_search_error
case|:
return|return
operator|-
literal|2
return|;
case|case
name|rx_search_soft_fail
case|:
case|case
name|rx_search_fail
case|:
return|return
operator|-
literal|1
return|;
default|default:
return|return
name|answer
return|;
block|}
block|}
end_block

begin_comment
comment|/* Export rx_search to callers outside this file.  */
end_comment

begin_function
name|int
name|re_rx_search
parameter_list|(
name|rxb
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|stop
parameter_list|,
name|total_size
parameter_list|,
name|get_burst
parameter_list|,
name|back_check
parameter_list|,
name|fetch_char
parameter_list|,
name|app_closure
parameter_list|,
name|regs
parameter_list|,
name|resume_state
parameter_list|,
name|save_state
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
name|int
name|startpos
decl_stmt|;
name|int
name|range
decl_stmt|;
name|int
name|stop
decl_stmt|;
name|int
name|total_size
decl_stmt|;
name|rx_get_burst_fn
name|get_burst
decl_stmt|;
name|rx_back_check_fn
name|back_check
decl_stmt|;
name|rx_fetch_char_fn
name|fetch_char
decl_stmt|;
name|void
modifier|*
name|app_closure
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
name|struct
name|rx_search_state
modifier|*
name|resume_state
decl_stmt|;
name|struct
name|rx_search_state
modifier|*
name|save_state
decl_stmt|;
block|{
return|return
name|rx_search
argument_list|(
name|rxb
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|stop
argument_list|,
name|total_size
argument_list|,
name|get_burst
argument_list|,
name|back_check
argument_list|,
name|fetch_char
argument_list|,
name|app_closure
argument_list|,
name|regs
argument_list|,
name|resume_state
argument_list|,
name|save_state
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REGEX_MALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|int
name|re_search_2
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|__const__
name|char
operator|*
name|string1
argument_list|,
name|int
name|size1
argument_list|,
name|__const__
name|char
operator|*
name|string2
argument_list|,
name|int
name|size2
argument_list|,
name|int
name|startpos
argument_list|,
name|int
name|range
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|stop
argument_list|)
else|#
directive|else
name|int
name|re_search_2
argument_list|(
name|rxb
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|inner_re_search_2
argument_list|(
name|rxb
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Like re_search_2, above, but only one string is specified, and  * doesn't let you say where to stop matching.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|int
name|re_search
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|__const__
name|char
operator|*
name|string
argument_list|,
name|int
name|size
argument_list|,
name|int
name|startpos
argument_list|,
name|int
name|range
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|)
else|#
directive|else
name|int
name|re_search
argument_list|(
name|rxb
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
return|return
name|re_search_2
argument_list|(
name|rxb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|int
name|re_match_2
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|__const__
name|char
operator|*
name|string1
argument_list|,
name|int
name|size1
argument_list|,
name|__const__
name|char
operator|*
name|string2
argument_list|,
name|int
name|size2
argument_list|,
name|int
name|pos
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|int
name|stop
argument_list|)
else|#
directive|else
name|int
name|re_match_2
argument_list|(
name|rxb
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|stop
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|re_registers
name|some_regs
decl_stmt|;
name|regoff_t
name|start
decl_stmt|;
name|regoff_t
name|end
decl_stmt|;
name|int
name|srch
decl_stmt|;
name|int
name|save
init|=
name|rxb
operator|->
name|regs_allocated
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs_to_pass
init|=
name|regs
decl_stmt|;
if|if
condition|(
operator|!
name|regs
condition|)
block|{
name|some_regs
operator|.
name|start
operator|=
operator|&
name|start
expr_stmt|;
name|some_regs
operator|.
name|end
operator|=
operator|&
name|end
expr_stmt|;
name|some_regs
operator|.
name|num_regs
operator|=
literal|1
expr_stmt|;
name|regs_to_pass
operator|=
operator|&
name|some_regs
expr_stmt|;
name|rxb
operator|->
name|regs_allocated
operator|=
name|REGS_FIXED
expr_stmt|;
block|}
name|srch
operator|=
name|re_search_2
argument_list|(
name|rxb
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|regs_to_pass
argument_list|,
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_to_pass
operator|!=
name|regs
condition|)
name|rxb
operator|->
name|regs_allocated
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|srch
operator|<
literal|0
condition|)
return|return
name|srch
return|;
return|return
name|regs_to_pass
operator|->
name|end
index|[
literal|0
index|]
operator|-
name|regs_to_pass
operator|->
name|start
index|[
literal|0
index|]
return|;
block|}
end_block

begin_comment
comment|/* re_match is like re_match_2 except it takes only a single string.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|int
name|re_match
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|__const__
name|char
operator|*
name|string
argument_list|,
name|int
name|size
argument_list|,
name|int
name|pos
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|)
else|#
directive|else
name|int
name|re_match
argument_list|(
name|rxb
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__const__
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
return|return
name|re_match_2
argument_list|(
name|rxb
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can    also be assigned to arbitrarily: each pattern buffer stores its own    syntax, so it can be changed between regex compilations.  */
end_comment

begin_decl_stmt
name|reg_syntax_t
name|re_syntax_options
init|=
name|RE_SYNTAX_EMACS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the precise syntax of regexps for compilation.  This provides    for compatibility for various utilities which historically have    different, incompatible syntaxes.     The argument SYNTAX is a bit mask comprised of the various bits    defined in regex.h.  We return the old syntax.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|reg_syntax_t
name|re_set_syntax
parameter_list|(
name|reg_syntax_t
name|syntax
parameter_list|)
else|#
directive|else
function|reg_syntax_t re_set_syntax
parameter_list|(
name|syntax
parameter_list|)
name|reg_syntax_t
name|syntax
decl_stmt|;
endif|#
directive|endif
block|{
name|reg_syntax_t
name|ret
init|=
name|re_syntax_options
decl_stmt|;
name|re_syntax_options
operator|=
name|syntax
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set REGS to hold NUM_REGS registers, storing them in STARTS and    ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use    this memory for recording register information.  STARTS and ENDS    must be allocated using the malloc library routine, and must each    be at least NUM_REGS * sizeof (regoff_t) bytes long.     If NUM_REGS == 0, then subsequent matches should allocate their own    register data.     Unless this function is called, the first search or match using    PATTERN_BUFFER will allocate its own register data, without    freeing the old data.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|void
name|re_set_registers
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|bufp
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
name|unsigned
name|num_regs
argument_list|,
name|regoff_t
operator|*
name|starts
argument_list|,
name|regoff_t
operator|*
name|ends
argument_list|)
else|#
directive|else
name|void
name|re_set_registers
argument_list|(
name|bufp
argument_list|,
name|regs
argument_list|,
name|num_regs
argument_list|,
name|starts
argument_list|,
name|ends
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|regoff_t
modifier|*
name|starts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|regoff_t
modifier|*
name|ends
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|num_regs
condition|)
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|starts
expr_stmt|;
name|regs
operator|->
name|end
operator|=
name|ends
expr_stmt|;
block|}
else|else
block|{
name|bufp
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
name|regs
operator|->
name|num_regs
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|start
operator|=
name|regs
operator|->
name|end
operator|=
operator|(
name|regoff_t
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|cplx_se_sublist_len
argument_list|(
expr|struct
name|rx_se_list
operator|*
name|list
argument_list|)
else|#
directive|else
decl|static
name|int
name|cplx_se_sublist_len
argument_list|(
name|list
argument_list|)
decl|struct
name|rx_se_list
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|list
operator|->
name|car
operator|>=
literal|0
condition|)
operator|++
name|x
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|cdr
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_block

begin_comment
comment|/* For rx->se_list_cmp */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|posix_se_list_order
argument_list|(
expr|struct
name|rx
operator|*
name|rx
argument_list|,
expr|struct
name|rx_se_list
operator|*
name|a
argument_list|,
expr|struct
name|rx_se_list
operator|*
name|b
argument_list|)
else|#
directive|else
decl|static
name|int
name|posix_se_list_order
argument_list|(
name|rx
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl|struct
name|rx
modifier|*
name|rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_se_list
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_se_list
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|al
init|=
name|cplx_se_sublist_len
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
name|bl
init|=
name|cplx_se_sublist_len
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|al
operator|&&
operator|!
name|bl
condition|)
return|return
operator|(
operator|(
name|a
operator|==
name|b
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|a
operator|<
name|b
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|al
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|bl
condition|)
return|return
literal|1
return|;
else|else
block|{
name|rx_side_effect
modifier|*
name|av
init|=
operator|(
operator|(
name|rx_side_effect
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rx_side_effect
argument_list|)
operator|*
operator|(
name|al
operator|+
literal|1
operator|)
argument_list|)
operator|)
decl_stmt|;
name|rx_side_effect
modifier|*
name|bv
init|=
operator|(
operator|(
name|rx_side_effect
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rx_side_effect
argument_list|)
operator|*
operator|(
name|bl
operator|+
literal|1
operator|)
argument_list|)
operator|)
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|ap
init|=
name|a
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|bp
init|=
name|b
decl_stmt|;
name|int
name|ai
decl_stmt|,
name|bi
decl_stmt|;
for|for
control|(
name|ai
operator|=
name|al
operator|-
literal|1
init|;
name|ai
operator|>=
literal|0
condition|;
operator|--
name|ai
control|)
block|{
while|while
condition|(
operator|(
name|long
operator|)
name|ap
operator|->
name|car
operator|<
literal|0
condition|)
name|ap
operator|=
name|ap
operator|->
name|cdr
expr_stmt|;
name|av
index|[
name|ai
index|]
operator|=
name|ap
operator|->
name|car
expr_stmt|;
name|ap
operator|=
name|ap
operator|->
name|cdr
expr_stmt|;
block|}
name|av
index|[
name|al
index|]
operator|=
operator|(
name|rx_side_effect
operator|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|bi
operator|=
name|bl
operator|-
literal|1
init|;
name|bi
operator|>=
literal|0
condition|;
operator|--
name|bi
control|)
block|{
while|while
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|car
operator|<
literal|0
condition|)
name|bp
operator|=
name|bp
operator|->
name|cdr
expr_stmt|;
name|bv
index|[
name|bi
index|]
operator|=
name|bp
operator|->
name|car
expr_stmt|;
name|bp
operator|=
name|bp
operator|->
name|cdr
expr_stmt|;
block|}
name|bv
index|[
name|bl
index|]
operator|=
operator|(
name|rx_side_effect
operator|)
operator|-
literal|1
expr_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|av
index|[
name|x
index|]
operator|==
name|bv
index|[
name|x
index|]
condition|)
operator|++
name|x
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
operator|(
name|unsigned
operator|*
operator|)
operator|(
name|av
index|[
name|x
index|]
operator|)
operator|<
operator|(
name|unsigned
operator|*
operator|)
operator|(
name|bv
index|[
name|x
index|]
operator|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* re_compile_pattern is the GNU regular expression compiler: it    compiles PATTERN (of length SIZE) and puts the result in RXB.    Returns 0 if the pattern was valid, otherwise an error string.     Assumes the `allocated' (and perhaps `buffer') and `translate' fields    are set in RXB on entry.     We call rx_compile to do the actual compilation.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|__const__
name|char
modifier|*
name|re_compile_pattern
argument_list|(
name|__const__
name|char
operator|*
name|pattern
argument_list|,
name|int
name|length
argument_list|,
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|)
else|#
directive|else
name|__const__
name|char
modifier|*
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|length
argument_list|,
name|rxb
argument_list|)
name|__const__
name|char
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
comment|/* GNU code is written to assume at least RE_NREGS registers will be set      (and at least one extra will be -1).  */
name|rxb
operator|->
name|regs_allocated
operator|=
name|REGS_UNALLOCATED
expr_stmt|;
comment|/* And GNU code determines whether or not to get register information      by passing null for the REGS argument to re_match, etc., not by      setting no_sub.  */
name|rxb
operator|->
name|no_sub
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|local_cset_size
operator|=
literal|256
expr_stmt|;
comment|/* Match anchors at newline.  */
name|rxb
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
name|rxb
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|se_params
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|nodec
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|epsnodec
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|instruction_table
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|nfa_states
operator|=
literal|0
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|se_list_cmp
operator|=
name|posix_se_list_order
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|start_set
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|rx_compile
argument_list|(
name|pattern
argument_list|,
name|length
argument_list|,
name|re_syntax_options
argument_list|,
name|rxb
argument_list|)
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rx_error_msg
index|[
operator|(
name|int
operator|)
name|ret
index|]
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|int
name|re_compile_fastmap
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|)
else|#
directive|else
name|int
name|re_compile_fastmap
argument_list|(
name|rxb
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|rx_blow_up_fastmap
argument_list|(
name|rxb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with 4.2 BSD regex library.  We don't define    them if this is an Emacs or POSIX compilation.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|emacs
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|USE_BSD_REGEX
argument_list|)
end_if

begin_comment
comment|/* BSD has one and only one pattern buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|rx_comp_buf
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|char
modifier|*
name|re_comp
parameter_list|(
name|__const__
name|char
modifier|*
name|s
parameter_list|)
else|#
directive|else
function|char * re_comp
parameter_list|(
name|s
parameter_list|)
name|__const__
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|rx_comp_buf
operator|.
name|buffer
condition|)
return|return
literal|"No previous regular expression"
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rx_comp_buf
operator|.
name|fastmap
condition|)
block|{
name|rx_comp_buf
operator|.
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|<<
name|CHARBITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_comp_buf
operator|.
name|fastmap
condition|)
return|return
literal|"Memory exhausted"
return|;
block|}
comment|/* Since `rx_exec' always passes NULL for the `regs' argument, we      don't need to initialize the pattern buffer fields which affect it.  */
comment|/* Match anchors at newlines.  */
name|rx_comp_buf
operator|.
name|newline_anchor
operator|=
literal|1
expr_stmt|;
name|rx_comp_buf
operator|.
name|re_nsub
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|se_params
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|nodec
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|epsnodec
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|instruction_table
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|nfa_states
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|local_cset_size
operator|=
literal|256
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|se_list_cmp
operator|=
name|posix_se_list_order
expr_stmt|;
name|rx_comp_buf
operator|.
name|rx
operator|.
name|start_set
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|rx_compile
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|re_syntax_options
argument_list|,
operator|&
name|rx_comp_buf
argument_list|)
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, we're discarding `__const__' here.  */
return|return
operator|(
name|char
operator|*
operator|)
name|rx_error_msg
index|[
operator|(
name|int
operator|)
name|ret
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|int
name|re_exec
parameter_list|(
name|__const__
name|char
modifier|*
name|s
parameter_list|)
else|#
directive|else
function|int re_exec
parameter_list|(
name|s
parameter_list|)
name|__const__
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
block|{
name|__const__
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|rx_comp_buf
argument_list|,
name|s
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs and not _POSIX_SOURCE */
end_comment

begin_escape
end_escape

begin_comment
comment|/* POSIX.2 functions.  Don't define these for Emacs.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|emacs
argument_list|)
end_if

begin_comment
comment|/* regcomp takes a regular expression as a string and compiles it.     PREG is a regex_t *.  We do not expect any fields to be initialized,    since POSIX says we shouldn't.  Thus, we set       `buffer' to the compiled pattern;      `used' to the length of the compiled pattern;      `syntax' to RE_SYNTAX_POSIX_EXTENDED if the        REG_EXTENDED bit in CFLAGS is set; otherwise, to        RE_SYNTAX_POSIX_BASIC;      `newline_anchor' to REG_NEWLINE being set in CFLAGS;      `fastmap' and `fastmap_accurate' to zero;      `re_nsub' to the number of subexpressions in PATTERN.     PATTERN is the address of the pattern string.     CFLAGS is a series of bits which affect compilation.       If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we      use POSIX basic syntax.       If REG_NEWLINE is set, then . and [^...] don't match newline.      Also, regexec will try a match beginning after every newline.       If REG_ICASE is set, then we considers upper- and lowercase      versions of letters to be equivalent when matching.       If REG_NOSUB is set, then when PREG is passed to regexec, that      routine will report only success or failure, and nothing about the      registers.     It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for    the return codes and their meanings.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|int
name|regcomp
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|,
name|__const__
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|cflags
parameter_list|)
else|#
directive|else
function|int regcomp
parameter_list|(
name|preg
parameter_list|,
name|pattern
parameter_list|,
name|cflags
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|__const__
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|cflags
decl_stmt|;
endif|#
directive|endif
block|{
name|reg_errcode_t
name|ret
decl_stmt|;
name|unsigned
name|syntax
init|=
name|cflags
operator|&
name|REG_EXTENDED
condition|?
name|RE_SYNTAX_POSIX_EXTENDED
else|:
name|RE_SYNTAX_POSIX_BASIC
decl_stmt|;
comment|/* regex_compile will allocate the space for the compiled pattern.  */
name|preg
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
name|malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preg
operator|->
name|fastmap
condition|)
return|return
name|REG_ESPACE
return|;
name|preg
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|REG_ICASE
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|preg
operator|->
name|translate
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|preg
operator|->
name|translate
condition|)
return|return
operator|(
name|int
operator|)
name|REG_ESPACE
return|;
comment|/* Map uppercase characters to corresponding lowercase ones.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHAR_SET_SIZE
condition|;
name|i
operator|++
control|)
name|preg
operator|->
name|translate
index|[
name|i
index|]
operator|=
name|isupper
argument_list|(
name|i
argument_list|)
condition|?
name|tolower
argument_list|(
name|i
argument_list|)
else|:
name|i
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|translate
operator|=
literal|0
expr_stmt|;
comment|/* If REG_NEWLINE is set, newlines are treated differently.  */
if|if
condition|(
name|cflags
operator|&
name|REG_NEWLINE
condition|)
block|{
comment|/* REG_NEWLINE implies neither . nor [^...] match newline.  */
name|syntax
operator|&=
operator|~
name|RE_DOT_NEWLINE
expr_stmt|;
name|syntax
operator||=
name|RE_HAT_LISTS_NOT_NEWLINE
expr_stmt|;
comment|/* It also changes the matching behavior.  */
name|preg
operator|->
name|newline_anchor
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|preg
operator|->
name|newline_anchor
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|no_sub
operator|=
operator|!
operator|!
operator|(
name|cflags
operator|&
name|REG_NOSUB
operator|)
expr_stmt|;
comment|/* POSIX says a null character in the pattern terminates it, so we      can use strlen here in compiling the pattern.  */
name|preg
operator|->
name|re_nsub
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|se_params
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|nodec
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|epsnodec
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|instruction_table
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|nfa_states
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|local_cset_size
operator|=
literal|256
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|se_list_cmp
operator|=
name|posix_se_list_order
expr_stmt|;
name|preg
operator|->
name|rx
operator|.
name|start_set
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|rx_compile
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|syntax
argument_list|,
name|preg
argument_list|)
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* POSIX doesn't distinguish between an unmatched open-group and an      unmatched close-group: both are REG_EPAREN.  */
if|if
condition|(
name|ret
operator|==
name|REG_ERPAREN
condition|)
name|ret
operator|=
name|REG_EPAREN
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* regexec searches for a given pattern, specified by PREG, in the    string STRING.     If NMATCH is zero or REG_NOSUB was set in the cflags argument to    `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at    least NMATCH elements, and we set them to the offsets of the    corresponding matched substrings.     EFLAGS specifies `execution flags' which affect matching: if    REG_NOTBOL is set, then ^ does not match at the beginning of the    string; if REG_NOTEOL is set, then $ does not match at the end.     We return 0 if we find a match and REG_NOMATCH if not.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|int
name|regexec
parameter_list|(
name|__const__
name|regex_t
modifier|*
name|preg
parameter_list|,
name|__const__
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|nmatch
parameter_list|,
name|regmatch_t
name|pmatch
index|[]
parameter_list|,
name|int
name|eflags
parameter_list|)
else|#
directive|else
function|int regexec
parameter_list|(
name|preg
parameter_list|,
name|string
parameter_list|,
name|nmatch
parameter_list|,
name|pmatch
parameter_list|,
name|eflags
parameter_list|)
name|__const__
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|__const__
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|regmatch_t
name|pmatch
index|[]
decl_stmt|;
name|int
name|eflags
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
name|regex_t
name|private_preg
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|boolean
name|want_reg_info
init|=
operator|!
name|preg
operator|->
name|no_sub
operator|&&
name|nmatch
operator|>
literal|0
decl_stmt|;
name|private_preg
operator|=
operator|*
name|preg
expr_stmt|;
name|private_preg
operator|.
name|not_bol
operator|=
operator|!
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
expr_stmt|;
name|private_preg
operator|.
name|not_eol
operator|=
operator|!
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTEOL
operator|)
expr_stmt|;
comment|/* The user has told us exactly how many registers to return    * information about, via `nmatch'.  We have to pass that on to the    * matching routines.    */
name|private_preg
operator|.
name|regs_allocated
operator|=
name|REGS_FIXED
expr_stmt|;
if|if
condition|(
name|want_reg_info
condition|)
block|{
name|regs
operator|.
name|num_regs
operator|=
name|nmatch
expr_stmt|;
name|regs
operator|.
name|start
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nmatch
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|regs
operator|.
name|end
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nmatch
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|start
operator|==
literal|0
operator|||
name|regs
operator|.
name|end
operator|==
literal|0
condition|)
return|return
operator|(
name|int
operator|)
name|REG_NOMATCH
return|;
block|}
comment|/* Perform the searching operation.  */
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|private_preg
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
comment|/* start: */
literal|0
argument_list|,
comment|/* range: */
name|len
argument_list|,
name|want_reg_info
condition|?
operator|&
name|regs
else|:
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the register information to the POSIX structure.  */
if|if
condition|(
name|want_reg_info
condition|)
block|{
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|nmatch
condition|;
name|r
operator|++
control|)
block|{
name|pmatch
index|[
name|r
index|]
operator|.
name|rm_so
operator|=
name|regs
operator|.
name|start
index|[
name|r
index|]
expr_stmt|;
name|pmatch
index|[
name|r
index|]
operator|.
name|rm_eo
operator|=
name|regs
operator|.
name|end
index|[
name|r
index|]
expr_stmt|;
block|}
block|}
comment|/* If we needed the temporary register info, free the space now.  */
name|free
argument_list|(
name|regs
operator|.
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* We want zero return to mean success, unlike `re_search'.  */
return|return
name|ret
operator|>=
literal|0
condition|?
operator|(
name|int
operator|)
name|REG_NOERROR
else|:
operator|(
name|int
operator|)
name|REG_NOMATCH
return|;
block|}
end_function

begin_comment
comment|/* Returns a message corresponding to an error code, ERRCODE, returned    from either regcomp or regexec.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|size_t
name|regerror
parameter_list|(
name|int
name|errcode
parameter_list|,
name|__const__
name|regex_t
modifier|*
name|preg
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|size_t
name|errbuf_size
parameter_list|)
else|#
directive|else
function|size_t regerror
parameter_list|(
name|errcode
parameter_list|,
name|preg
parameter_list|,
name|errbuf
parameter_list|,
name|errbuf_size
parameter_list|)
name|int
name|errcode
decl_stmt|;
name|__const__
name|regex_t
modifier|*
name|preg
decl_stmt|;
name|char
modifier|*
name|errbuf
decl_stmt|;
name|size_t
name|errbuf_size
decl_stmt|;
endif|#
directive|endif
block|{
name|__const__
name|char
modifier|*
name|msg
init|=
name|rx_error_msg
index|[
name|errcode
index|]
operator|==
literal|0
condition|?
literal|"Success"
else|:
name|rx_error_msg
index|[
name|errcode
index|]
decl_stmt|;
name|size_t
name|msg_size
init|=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* Includes the 0.  */
if|if
condition|(
name|errbuf_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|msg_size
operator|>
name|errbuf_size
condition|)
block|{
name|strncpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbuf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|errbuf
index|[
name|errbuf_size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|msg_size
return|;
block|}
end_function

begin_comment
comment|/* Free dynamically allocated space used by PREG.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|void
name|regfree
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|)
else|#
directive|else
function|void regfree
parameter_list|(
name|preg
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|preg
operator|->
name|buffer
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|preg
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|preg
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|fastmap
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|preg
operator|->
name|fastmap
argument_list|)
expr_stmt|;
name|preg
operator|->
name|fastmap
operator|=
literal|0
expr_stmt|;
name|preg
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|preg
operator|->
name|translate
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|preg
operator|->
name|translate
argument_list|)
expr_stmt|;
name|preg
operator|->
name|translate
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs  */
end_comment

end_unit

