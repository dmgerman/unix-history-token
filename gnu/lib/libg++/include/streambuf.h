begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is part of libio/iostream, providing -*- C++ -*- input/output. Copyright (C) 1993 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_STREAMBUF_H
end_ifndef

begin_define
define|#
directive|define
name|_STREAMBUF_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|interface
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define _G_IO_THROW */
end_comment

begin_comment
comment|/* Not implemented:  ios::failure */
end_comment

begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|<libio.h>
block|}
end_extern

begin_comment
comment|//#include<_G_config.h>
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_IO_NEED_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_va_list
end_ifndef

begin_define
define|#
directive|define
name|_IO_va_list
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EOF
end_ifndef

begin_define
define|#
directive|define
name|EOF
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|NULL
value|((void*)0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_IO_wchar_t
end_ifndef

begin_define
define|#
directive|define
name|_IO_wchar_t
value|short
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|class
name|istream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Work-around for a g++ name mangling bug. Fixed in 2.6. */
end_comment

begin_decl_stmt
name|class
name|ostream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|streambuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|// In case some header files defines these as macros.
end_comment

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_extern
extern|extern
literal|"C"
name|int
name|__underflow
parameter_list|(
name|struct
name|_IO_FILE
modifier|*
parameter_list|)
function_decl|;
end_extern

begin_extern
extern|extern
literal|"C"
name|int
name|__overflow
parameter_list|(
name|struct
name|_IO_FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_extern

begin_typedef
typedef|typedef
name|_IO_off_t
name|streamoff
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_IO_fpos_t
name|streampos
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_IO_ssize_t
name|streamsize
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|__fmtflags
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|__iostate
typedef|;
end_typedef

begin_struct
struct|struct
name|_ios_fields
block|{
comment|// The data members of an ios.
comment|// Directly using _strbuf is dangerous, because the vtable
comment|// pointer can be NULL.  Use rdbuf() when in doubt.
name|streambuf
modifier|*
name|_strbuf
decl_stmt|;
name|ostream
modifier|*
name|_tie
decl_stmt|;
name|int
name|_width
decl_stmt|;
name|__fmtflags
name|_flags
decl_stmt|;
name|_IO_wchar_t
name|_fill
decl_stmt|;
name|__iostate
name|_state
decl_stmt|;
name|__iostate
name|_exceptions
decl_stmt|;
name|int
name|_precision
decl_stmt|;
name|void
modifier|*
name|_arrays
decl_stmt|;
comment|/* Support for ios::iword and ios::pword. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|_IOS_GOOD
value|0
end_define

begin_define
define|#
directive|define
name|_IOS_EOF
value|1
end_define

begin_define
define|#
directive|define
name|_IOS_FAIL
value|2
end_define

begin_define
define|#
directive|define
name|_IOS_BAD
value|4
end_define

begin_define
define|#
directive|define
name|_IO_INPUT
value|1
end_define

begin_define
define|#
directive|define
name|_IO_OUTPUT
value|2
end_define

begin_define
define|#
directive|define
name|_IO_ATEND
value|4
end_define

begin_define
define|#
directive|define
name|_IO_APPEND
value|8
end_define

begin_define
define|#
directive|define
name|_IO_TRUNC
value|16
end_define

begin_define
define|#
directive|define
name|_IO_NOCREATE
value|32
end_define

begin_define
define|#
directive|define
name|_IO_NOREPLACE
value|64
end_define

begin_define
define|#
directive|define
name|_IO_BIN
value|128
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_STREAM_COMPAT
end_ifdef

begin_enum
enum|enum
name|state_value
block|{
name|_good
init|=
name|_IOS_GOOD
block|,
name|_eof
init|=
name|_IOS_EOF
block|,
name|_fail
init|=
name|_IOS_FAIL
block|,
name|_bad
init|=
name|_IOS_BAD
block|}
enum|;
end_enum

begin_enum
enum|enum
name|open_mode
block|{
name|input
init|=
name|_IO_INPUT
block|,
name|output
init|=
name|_IO_OUTPUT
block|,
name|atend
init|=
name|_IO_ATEND
block|,
name|append
init|=
name|_IO_APPEND
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|class
name|ios
range|:
name|public
name|_ios_fields
block|{
name|ios
operator|&
name|operator
operator|=
operator|(
name|ios
operator|&
operator|)
block|;
comment|/* Not allowed! */
name|public
operator|:
typedef|typedef
name|__fmtflags
name|fmtflags
typedef|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|iostate
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|openmode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|streamsize
typedef|;
end_typedef

begin_enum
enum|enum
name|io_state
block|{
name|goodbit
init|=
name|_IOS_GOOD
block|,
name|eofbit
init|=
name|_IOS_EOF
block|,
name|failbit
init|=
name|_IOS_FAIL
block|,
name|badbit
init|=
name|_IOS_BAD
block|}
enum|;
end_enum

begin_enum
enum|enum
name|open_mode
block|{
name|in
init|=
name|_IO_INPUT
block|,
name|out
init|=
name|_IO_OUTPUT
block|,
name|ate
init|=
name|_IO_ATEND
block|,
name|app
init|=
name|_IO_APPEND
block|,
name|trunc
init|=
name|_IO_TRUNC
block|,
name|nocreate
init|=
name|_IO_NOCREATE
block|,
name|noreplace
init|=
name|_IO_NOREPLACE
block|,
name|bin
init|=
name|_IOS_BIN
block|}
enum|;
end_enum

begin_enum
enum|enum
name|seek_dir
block|{
name|beg
block|,
name|cur
block|,
name|end
block|}
enum|;
end_enum

begin_comment
comment|// ANSI: typedef enum seek_dir seekdir; etc
end_comment

begin_comment
comment|// NOTE: If adding flags here, before to update ios::bitalloc().
end_comment

begin_enum
enum|enum
block|{
name|skipws
init|=
name|_IO_SKIPWS
block|,
name|left
init|=
name|_IO_LEFT
block|,
name|right
init|=
name|_IO_RIGHT
block|,
name|internal
init|=
name|_IO_INTERNAL
block|,
name|dec
init|=
name|_IO_DEC
block|,
name|oct
init|=
name|_IO_OCT
block|,
name|hex
init|=
name|_IO_HEX
block|,
name|showbase
init|=
name|_IO_SHOWBASE
block|,
name|showpoint
init|=
name|_IO_SHOWPOINT
block|,
name|uppercase
init|=
name|_IO_UPPERCASE
block|,
name|showpos
init|=
name|_IO_SHOWPOS
block|,
name|scientific
init|=
name|_IO_SCIENTIFIC
block|,
name|fixed
init|=
name|_IO_FIXED
block|,
name|unitbuf
init|=
name|_IO_UNITBUF
block|,
name|stdio
init|=
name|_IO_STDIO
block|,
name|dont_close
init|=
name|_IO_DONT_CLOSE
comment|// Don't delete streambuf on stream destruction
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|// Masks.
name|basefield
init|=
name|dec
operator|+
name|oct
operator|+
name|hex
block|,
name|floatfield
init|=
name|scientific
operator|+
name|fixed
block|,
name|adjustfield
init|=
name|left
operator|+
name|right
operator|+
name|internal
block|}
enum|;
end_enum

begin_ifdef
ifdef|#
directive|ifdef
name|_IO_THROW
end_ifdef

begin_decl_stmt
name|class
name|failure
range|:
name|public
name|xmsg
block|{
name|ios
operator|*
name|_stream
block|;
name|public
operator|:
name|failure
argument_list|(
argument|ios* stream
argument_list|)
block|{
name|_stream
operator|=
name|stream
block|; }
name|failure
argument_list|(
argument|string cause
argument_list|,
argument|ios* stream
argument_list|)
block|{
name|_stream
operator|=
name|stream
block|; }
name|ios
operator|*
name|rdios
argument_list|()
specifier|const
block|{
return|return
name|_stream
return|;
block|}
expr|}
block|;
endif|#
directive|endif
name|ostream
operator|*
name|tie
argument_list|()
specifier|const
block|{
return|return
name|_tie
return|;
block|}
name|ostream
operator|*
name|tie
argument_list|(
argument|ostream* val
argument_list|)
block|{
name|ostream
operator|*
name|save
operator|=
name|_tie
block|;
name|_tie
operator|=
name|val
block|;
return|return
name|save
return|;
block|}
comment|// Methods to change the format state.
name|_IO_wchar_t
name|fill
argument_list|()
specifier|const
block|{
return|return
operator|(
name|_IO_wchar_t
operator|)
name|_fill
return|;
block|}
name|_IO_wchar_t
name|fill
argument_list|(
argument|_IO_wchar_t newf
argument_list|)
block|{
name|_IO_wchar_t
name|oldf
operator|=
operator|(
name|_IO_wchar_t
operator|)
name|_fill
block|;
name|_fill
operator|=
operator|(
name|char
operator|)
name|newf
block|;
return|return
name|oldf
return|;
block|}
name|fmtflags
name|flags
argument_list|()
specifier|const
block|{
return|return
name|_flags
return|;
block|}
name|fmtflags
name|flags
argument_list|(
argument|fmtflags new_val
argument_list|)
block|{
name|fmtflags
name|old_val
operator|=
name|_flags
block|;
name|_flags
operator|=
name|new_val
block|;
return|return
name|old_val
return|;
block|}
name|int
name|precision
argument_list|()
specifier|const
block|{
return|return
name|_precision
return|;
block|}
name|int
name|precision
argument_list|(
argument|int newp
argument_list|)
block|{
name|unsigned
name|short
name|oldp
operator|=
name|_precision
block|;
name|_precision
operator|=
operator|(
name|unsigned
name|short
operator|)
name|newp
block|;
return|return
name|oldp
return|;
block|}
name|fmtflags
name|setf
argument_list|(
argument|fmtflags val
argument_list|)
block|{
name|fmtflags
name|oldbits
operator|=
name|_flags
block|;
name|_flags
operator||=
name|val
block|;
return|return
name|oldbits
return|;
block|}
name|fmtflags
name|setf
argument_list|(
argument|fmtflags val
argument_list|,
argument|fmtflags mask
argument_list|)
block|{
name|fmtflags
name|oldbits
operator|=
name|_flags
block|;
name|_flags
operator|=
operator|(
name|_flags
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|val
operator|&
name|mask
operator|)
block|;
return|return
name|oldbits
return|;
block|}
name|fmtflags
name|unsetf
argument_list|(
argument|fmtflags mask
argument_list|)
block|{
name|fmtflags
name|oldbits
operator|=
name|_flags
block|;
name|_flags
operator|&=
operator|~
name|mask
block|;
return|return
name|oldbits
return|;
block|}
name|int
name|width
argument_list|()
specifier|const
block|{
return|return
name|_width
return|;
block|}
name|int
name|width
argument_list|(
argument|int val
argument_list|)
block|{
name|int
name|save
operator|=
name|_width
block|;
name|_width
operator|=
name|val
block|;
return|return
name|save
return|;
block|}
ifdef|#
directive|ifdef
name|_IO_THROW
name|void
name|_throw_failure
argument_list|()
specifier|const
block|{
name|throw
name|new
name|ios
operator|::
name|failure
argument_list|(
name|this
argument_list|)
block|; }
else|#
directive|else
name|void
name|_throw_failure
argument_list|()
specifier|const
block|{ }
endif|#
directive|endif
name|streambuf
operator|*
name|rdbuf
argument_list|()
specifier|const
block|{
return|return
name|_strbuf
return|;
block|}
ifdef|#
directive|ifdef
name|_STREAM_COMPAT
name|void
name|_IO_fix_vtable
argument_list|()
block|;
comment|/* TEMPORARY - for binary compatibility */
name|void
name|_IO_fix_vtable
argument_list|()
specifier|const
block|;
comment|/* TEMPORARY - for binary compatibility */
endif|#
directive|endif
name|streambuf
operator|*
name|rdbuf
argument_list|(
argument|streambuf *_s
argument_list|)
block|{
name|streambuf
operator|*
name|_old
operator|=
name|_strbuf
block|;
name|_strbuf
operator|=
name|_s
block|;
name|clear
argument_list|()
block|;
return|return
name|_old
return|;
block|}
name|void
name|clear
argument_list|(
argument|iostate state =
literal|0
argument_list|)
block|{
name|_state
operator|=
name|_strbuf
operator|?
name|state
operator|:
name|state
operator||
name|badbit
block|;
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|void
name|set
argument_list|(
argument|iostate flag
argument_list|)
block|{
name|_state
operator||=
name|flag
block|;
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|void
name|setstate
argument_list|(
argument|iostate flag
argument_list|)
block|{
name|_state
operator||=
name|flag
block|;
comment|// ANSI
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
name|int
name|good
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|==
literal|0
return|;
block|}
name|int
name|eof
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|&
name|ios
operator|::
name|eofbit
return|;
block|}
name|int
name|fail
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|&
operator|(
name|ios
operator|::
name|badbit
operator||
name|ios
operator|::
name|failbit
operator|)
return|;
block|}
name|int
name|bad
argument_list|()
specifier|const
block|{
return|return
name|_state
operator|&
name|ios
operator|::
name|badbit
return|;
block|}
name|iostate
name|rdstate
argument_list|()
specifier|const
block|{
return|return
name|_state
return|;
block|}
name|operator
name|void
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|fail
argument_list|()
operator|?
operator|(
name|void
operator|*
operator|)
literal|0
operator|:
operator|(
name|void
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|int
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
name|fail
argument_list|()
return|;
block|}
name|iostate
name|exceptions
argument_list|()
specifier|const
block|{
return|return
name|_exceptions
return|;
block|}
name|void
name|exceptions
argument_list|(
argument|iostate enable
argument_list|)
block|{
name|_exceptions
operator|=
name|enable
block|;
if|if
condition|(
name|_state
operator|&
name|_exceptions
condition|)
name|_throw_failure
argument_list|()
expr_stmt|;
block|}
specifier|static
name|int
name|sync_with_stdio
argument_list|(
argument|int on
argument_list|)
block|;
specifier|static
name|void
name|sync_with_stdio
argument_list|()
block|{
name|sync_with_stdio
argument_list|(
literal|1
argument_list|)
block|; }
specifier|static
name|fmtflags
name|bitalloc
argument_list|()
block|;
specifier|static
name|int
name|xalloc
argument_list|()
block|;
name|void
operator|*
operator|&
name|pword
argument_list|(
name|int
argument_list|)
block|;
name|void
operator|*
name|pword
argument_list|(
argument|int
argument_list|)
specifier|const
block|;
name|long
operator|&
name|iword
argument_list|(
name|int
argument_list|)
block|;
name|long
name|iword
argument_list|(
argument|int
argument_list|)
specifier|const
block|;
ifdef|#
directive|ifdef
name|_STREAM_COMPAT
name|void
name|unset
argument_list|(
argument|state_value flag
argument_list|)
block|{
name|_state
operator|&=
operator|~
name|flag
block|; }
name|void
name|close
argument_list|()
block|;
name|int
name|is_open
argument_list|()
block|;
name|int
name|readable
argument_list|()
block|;
name|int
name|writable
argument_list|()
block|;
endif|#
directive|endif
comment|// Used to initialize standard streams. Not needed in this implementation.
name|class
name|Init
block|{
name|public
operator|:
name|Init
argument_list|()
block|{ }
block|}
block|;
name|protected
operator|:
name|ios
argument_list|(
argument|streambuf* sb =
literal|0
argument_list|,
argument|ostream* tie_to =
literal|0
argument_list|)
block|{
name|init
argument_list|(
name|sb
argument_list|,
name|tie_to
argument_list|)
block|; }
specifier|inline
name|virtual
operator|~
name|ios
argument_list|()
block|;
specifier|inline
name|void
name|init
argument_list|(
name|streambuf
operator|*
name|sb
argument_list|,
name|ostream
operator|*
name|tie
operator|=
literal|0
argument_list|)
block|; }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__GNUG__
operator|==
literal|1
end_if

begin_typedef
typedef|typedef
name|int
name|_seek_dir
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|ios
operator|::
name|seek_dir
name|_seek_dir
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// Magic numbers and bits for the _flags field.
end_comment

begin_comment
comment|// The magic numbers use the high-order bits of _flags;
end_comment

begin_comment
comment|// the remaining bits are abailable for variable flags.
end_comment

begin_comment
comment|// Note: The magic numbers must all be negative if stdio
end_comment

begin_comment
comment|// emulation is desired.
end_comment

begin_comment
comment|// A streammarker remembers a position in a buffer.
end_comment

begin_comment
comment|// You are guaranteed to be able to seek back to it if it is saving().
end_comment

begin_decl_stmt
name|class
name|streammarker
range|:
name|private
name|_IO_marker
block|{
name|friend
name|class
name|streambuf
block|;
name|void
name|set_offset
argument_list|(
argument|int offset
argument_list|)
block|{
name|_pos
operator|=
name|offset
block|; }
name|public
operator|:
name|streammarker
argument_list|(
name|streambuf
operator|*
name|sb
argument_list|)
block|;
operator|~
name|streammarker
argument_list|()
block|;
name|int
name|saving
argument_list|()
block|{
return|return
literal|1
return|;
block|}
name|int
name|delta
argument_list|(
name|streammarker
operator|&
argument_list|)
block|;
name|int
name|delta
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|unsigned
name|__adjust_column
parameter_list|(
name|unsigned
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|streambuf
range|:
name|public
name|_IO_FILE
block|{
comment|// protected??
name|friend
name|class
name|ios
block|;
name|friend
name|class
name|istream
block|;
name|friend
name|class
name|ostream
block|;
name|friend
name|class
name|streammarker
block|;
specifier|const
name|void
operator|*
operator|&
name|_vtable
argument_list|()
block|{
return|return
operator|*
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|_IO_FILE
operator|*
operator|)
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|protected
operator|:
specifier|static
name|streambuf
operator|*
name|_list_all
block|;
comment|/* List of open streambufs. */
name|_IO_FILE
operator|*
operator|&
name|xchain
argument_list|()
block|{
return|return
name|_chain
return|;
block|}
name|void
name|_un_link
argument_list|()
block|;
name|void
name|_link_in
argument_list|()
block|;
name|char
operator|*
name|gptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
operator|?
name|_IO_save_base
operator|:
name|_IO_read_ptr
return|;
block|}
name|char
operator|*
name|pptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_write_ptr
return|;
block|}
name|char
operator|*
name|egptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|?
name|_IO_save_end
else|:
name|_IO_read_end
return|;
block|}
name|char
operator|*
name|epptr
argument_list|()
specifier|const
block|{
return|return
name|_IO_write_end
return|;
block|}
name|char
operator|*
name|pbase
argument_list|()
specifier|const
block|{
return|return
name|_IO_write_base
return|;
block|}
name|char
operator|*
name|eback
argument_list|()
specifier|const
block|{
return|return
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|?
name|_IO_save_base
else|:
name|_IO_read_base
return|;
block|}
name|char
operator|*
name|base
argument_list|()
specifier|const
block|{
return|return
name|_IO_buf_base
return|;
block|}
name|char
operator|*
name|ebuf
argument_list|()
specifier|const
block|{
return|return
name|_IO_buf_end
return|;
block|}
name|int
name|blen
argument_list|()
specifier|const
block|{
return|return
name|_IO_buf_end
operator|-
name|_IO_buf_base
return|;
block|}
name|void
name|xput_char
argument_list|(
argument|char c
argument_list|)
block|{
operator|*
name|_IO_write_ptr
operator|++
operator|=
name|c
block|; }
name|int
name|xflags
argument_list|()
block|{
return|return
name|_IO_file_flags
return|;
block|}
name|int
name|xflags
argument_list|(
argument|int f
argument_list|)
block|{
name|int
name|fl
operator|=
name|_IO_file_flags
block|;
name|_IO_file_flags
operator|=
name|f
block|;
return|return
name|fl
return|;
block|}
name|void
name|xsetflags
argument_list|(
argument|int f
argument_list|)
block|{
name|_IO_file_flags
operator||=
name|f
block|; }
name|void
name|xsetflags
argument_list|(
argument|int f
argument_list|,
argument|int mask
argument_list|)
block|{
name|_IO_file_flags
operator|=
operator|(
name|_IO_file_flags
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|f
operator|&
name|mask
operator|)
block|; }
name|void
name|gbump
argument_list|(
argument|int n
argument_list|)
block|{
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|?
operator|(
name|_IO_save_base
operator|+=
name|n
operator|)
else|:
operator|(
name|_IO_read_ptr
operator|+=
name|n
operator|)
block|;}
name|void
name|pbump
argument_list|(
argument|int n
argument_list|)
block|{
name|_IO_write_ptr
operator|+=
name|n
block|; }
name|void
name|setb
argument_list|(
argument|char* b
argument_list|,
argument|char* eb
argument_list|,
argument|int a=
literal|0
argument_list|)
block|;
name|void
name|setp
argument_list|(
argument|char* p
argument_list|,
argument|char* ep
argument_list|)
block|{
name|_IO_write_base
operator|=
name|_IO_write_ptr
operator|=
name|p
block|;
name|_IO_write_end
operator|=
name|ep
block|; }
name|void
name|setg
argument_list|(
argument|char* eb
argument_list|,
argument|char* g
argument_list|,
argument|char *eg
argument_list|)
block|{
if|if
condition|(
name|_IO_file_flags
operator|&
name|_IO_IN_BACKUP
condition|)
name|_IO_free_backup_area
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|_IO_read_base
operator|=
name|eb
block|;
name|_IO_read_ptr
operator|=
name|g
block|;
name|_IO_read_end
operator|=
name|eg
block|; }
name|char
operator|*
name|shortbuf
argument_list|()
block|{
return|return
name|_shortbuf
return|;
block|}
end_decl_stmt

begin_function
name|int
name|in_backup
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_IN_BACKUP
return|;
block|}
end_function

begin_comment
comment|// The start of the main get area:  FIXME:  wrong for write-mode filebuf?
end_comment

begin_function
name|char
modifier|*
name|Gbase
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_save_base
else|:
name|_IO_read_base
return|;
block|}
end_function

begin_comment
comment|// The end of the main get area:
end_comment

begin_function
name|char
modifier|*
name|eGptr
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_save_end
else|:
name|_IO_read_end
return|;
block|}
end_function

begin_comment
comment|// The start of the backup area:
end_comment

begin_function
name|char
modifier|*
name|Bbase
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_read_base
else|:
name|_IO_save_base
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Bptr
parameter_list|()
block|{
return|return
name|_IO_backup_base
return|;
block|}
end_function

begin_comment
comment|// The end of the backup area:
end_comment

begin_function
name|char
modifier|*
name|eBptr
parameter_list|()
block|{
return|return
name|in_backup
argument_list|()
condition|?
name|_IO_read_end
else|:
name|_IO_save_end
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Nbase
parameter_list|()
block|{
return|return
name|_IO_save_base
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|eNptr
parameter_list|()
block|{
return|return
name|_IO_save_end
return|;
block|}
end_function

begin_function
name|int
name|have_backup
parameter_list|()
block|{
return|return
name|_IO_save_base
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|have_markers
parameter_list|()
block|{
return|return
name|_markers
operator|!=
name|NULL
return|;
block|}
end_function

begin_function_decl
name|void
name|free_backup_area
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|unsave_markers
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Make all streammarkers !saving().
end_comment

begin_function
name|int
name|put_mode
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
return|;
block|}
end_function

begin_function_decl
name|int
name|switch_to_get_mode
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|streambuf
argument_list|(
argument|int flags=
literal|0
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_label
name|public
label|:
end_label

begin_function_decl
specifier|static
name|int
name|flush_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_all_linebuffered
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Flush all line buffered files.
end_comment

begin_function_decl
name|virtual
name|int
name|underflow
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Leave public for now
end_comment

begin_function_decl
name|virtual
name|int
name|overflow
parameter_list|(
name|int
name|c
init|=
name|EOF
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Leave public for now
end_comment

begin_function_decl
name|virtual
name|int
name|doallocate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|streampos
name|sseekoff
parameter_list|(
name|streamoff
parameter_list|,
name|_seek_dir
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|streampos
name|sseekpos
parameter_list|(
name|streampos
name|pos
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|streampos
name|seekoff
parameter_list|(
name|streamoff
parameter_list|,
name|_seek_dir
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|streampos
name|seekpos
parameter_list|(
name|streampos
name|pos
parameter_list|,
name|int
name|mode
init|=
name|ios
operator|::
name|in
operator||
name|ios
operator|::
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|seekmark
parameter_list|(
name|streammarker
modifier|&
name|mark
parameter_list|,
name|int
name|delta
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sputbackc
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sungetc
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|virtual
operator|~
name|streambuf
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|unbuffered
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_UNBUFFERED
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linebuffered
parameter_list|()
block|{
return|return
name|_flags
operator|&
name|_IO_LINE_BUF
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|void
name|unbuffered
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
condition|)
name|_flags
operator||=
name|_IO_UNBUFFERED
expr_stmt|;
else|else
name|_flags
operator|&=
operator|~
name|_IO_UNBUFFERED
expr_stmt|;
block|}
end_function

begin_function
name|void
name|linebuffered
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
condition|)
name|_flags
operator||=
name|_IO_LINE_BUF
expr_stmt|;
else|else
name|_flags
operator|&=
operator|~
name|_IO_LINE_BUF
expr_stmt|;
block|}
end_function

begin_function
name|int
name|allocate
parameter_list|()
block|{
comment|// For AT&T compatibility
if|if
condition|(
name|base
argument_list|()
operator|||
name|unbuffered
argument_list|()
condition|)
return|return
literal|0
return|;
else|else
return|return
name|doallocate
argument_list|()
return|;
block|}
end_function

begin_comment
comment|// Allocate a buffer if needed; use _shortbuf if appropriate.
end_comment

begin_function
name|void
name|allocbuf
parameter_list|()
block|{
if|if
condition|(
name|base
argument_list|()
operator|==
name|NULL
condition|)
name|doallocbuf
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|doallocbuf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|int
name|sync
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|int
name|pbackfail
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|streambuf
modifier|*
name|setbuf
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|in_avail
parameter_list|()
block|{
return|return
name|_IO_read_end
operator|-
name|_IO_read_ptr
return|;
block|}
end_function

begin_function
name|int
name|out_waiting
parameter_list|()
block|{
return|return
name|_IO_write_ptr
operator|-
name|_IO_write_base
return|;
block|}
end_function

begin_function_decl
name|virtual
name|streamsize
name|xsputn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|streamsize
name|sputn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
block|{
return|return
name|xsputn
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function
name|streamsize
name|padn
parameter_list|(
name|char
name|pad
parameter_list|,
name|streamsize
name|n
parameter_list|)
block|{
return|return
name|_IO_padn
argument_list|(
name|this
argument_list|,
name|pad
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|virtual
name|streamsize
name|xsgetn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|streamsize
name|sgetn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|streamsize
name|n
parameter_list|)
block|{
return|return
name|_IO_sgetn
argument_list|(
name|this
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|int
name|ignore
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|int
name|get_column
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|int
name|set_column
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|sgetline
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|_IO_size_t
name|n
parameter_list|,
name|char
name|delim
parameter_list|,
name|int
name|putback_delim
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|sputc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|_IO_putc
argument_list|(
name|c
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sbumpc
parameter_list|()
block|{
return|return
name|_IO_getc
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sgetc
parameter_list|()
block|{
return|return
name|_IO_peekc
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|snextc
parameter_list|()
block|{
if|if
condition|(
name|_IO_read_ptr
operator|>=
name|_IO_read_end
operator|&&
name|__underflow
argument_list|(
name|this
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
else|else
return|return
name|_IO_read_ptr
operator|++
operator|,
name|sgetc
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|stossc
parameter_list|()
block|{
if|if
condition|(
name|_IO_read_ptr
operator|<
name|_IO_read_end
condition|)
name|_IO_read_ptr
operator|++
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|vscan
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
parameter_list|,
name|_IO_va_list
name|ap
parameter_list|,
name|ios
modifier|*
name|stream
init|=
name|NULL
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|scan
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vform
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
parameter_list|,
name|_IO_va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|form
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt0
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work in progress */
end_comment

begin_comment
unit|int column();
comment|// Current column number (of put pointer). -1 is unknown.
end_comment

begin_comment
unit|void column(int c);
comment|// Set column number of put pointer to c.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|virtual
name|streamsize
name|sys_read
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|streamsize
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|streampos
name|sys_seek
parameter_list|(
name|streamoff
parameter_list|,
name|_seek_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|streamsize
name|sys_write
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|streamsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|int
name|sys_stat
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Actually, a (struct stat*)
end_comment

begin_function_decl
name|virtual
name|int
name|sys_close
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|};
comment|// A backupbuf is a streambuf with full backup and savepoints on reading.
end_comment

begin_comment
comment|// All standard streambufs in the GNU iostream library are backupbufs.
end_comment

begin_decl_stmt
name|class
name|filebuf
range|:
name|public
name|streambuf
block|{
name|protected
operator|:
name|void
name|init
argument_list|()
block|;
name|public
operator|:
specifier|static
specifier|const
name|int
name|openprot
block|;
comment|// Non-ANSI AT&T-ism:  Default open protection.
name|filebuf
argument_list|()
block|;
name|filebuf
argument_list|(
argument|int fd
argument_list|)
block|;
name|filebuf
argument_list|(
argument|int fd
argument_list|,
argument|char* p
argument_list|,
argument|int len
argument_list|)
block|;
specifier|static
name|filebuf
operator|*
name|__new
argument_list|()
block|;
operator|~
name|filebuf
argument_list|()
block|;
name|filebuf
operator|*
name|attach
argument_list|(
argument|int fd
argument_list|)
block|;
name|filebuf
operator|*
name|open
argument_list|(
specifier|const
name|char
operator|*
name|filename
argument_list|,
specifier|const
name|char
operator|*
name|mode
argument_list|)
block|;
name|filebuf
operator|*
name|open
argument_list|(
argument|const char *filename
argument_list|,
argument|ios::openmode mode
argument_list|,
argument|int prot =
literal|0664
argument_list|)
block|;
name|virtual
name|int
name|underflow
argument_list|()
block|;
name|virtual
name|int
name|overflow
argument_list|(
argument|int c = EOF
argument_list|)
block|;
name|int
name|is_open
argument_list|()
specifier|const
block|{
return|return
name|_fileno
operator|>=
literal|0
return|;
block|}
name|int
name|fd
argument_list|()
specifier|const
block|{
return|return
name|is_open
argument_list|()
operator|?
name|_fileno
operator|:
name|EOF
return|;
block|}
name|filebuf
operator|*
name|close
argument_list|()
block|;
name|virtual
name|int
name|doallocate
argument_list|()
block|;
name|virtual
name|streampos
name|seekoff
argument_list|(
argument|streamoff
argument_list|,
argument|_seek_dir
argument_list|,
argument|int mode=ios::in|ios::out
argument_list|)
block|;
name|virtual
name|streambuf
operator|*
name|setbuf
argument_list|(
argument|char* p
argument_list|,
argument|int len
argument_list|)
block|;
name|streamsize
name|xsputn
argument_list|(
argument|const char* s
argument_list|,
argument|streamsize n
argument_list|)
block|;
name|streamsize
name|xsgetn
argument_list|(
argument|char* s
argument_list|,
argument|streamsize n
argument_list|)
block|;
name|virtual
name|int
name|sync
argument_list|()
block|;
name|protected
operator|:
comment|// See documentation in filebuf.C.
comment|//    virtual int pbackfail(int c);
name|int
name|is_reading
argument_list|()
block|{
return|return
name|eback
argument_list|()
operator|!=
name|egptr
argument_list|()
return|;
block|}
name|char
operator|*
name|cur_ptr
argument_list|()
block|{
return|return
name|is_reading
argument_list|()
condition|?
name|gptr
argument_list|()
else|:
name|pptr
argument_list|()
return|;
block|}
comment|/* System's idea of pointer */
name|char
operator|*
name|file_ptr
argument_list|()
block|{
return|return
name|eGptr
argument_list|()
return|;
block|}
name|int
name|do_write
argument_list|(
argument|const char *data
argument_list|,
argument|int to_do
argument_list|)
block|;
comment|// Low-level operations (Usually invoke system calls.)
name|virtual
name|streamsize
name|sys_read
argument_list|(
argument|char* buf
argument_list|,
argument|streamsize size
argument_list|)
block|;
name|virtual
name|streampos
name|sys_seek
argument_list|(
name|streamoff
argument_list|,
name|_seek_dir
argument_list|)
block|;
name|virtual
name|streamsize
name|sys_write
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|streamsize
argument_list|)
block|;
name|virtual
name|int
name|sys_stat
argument_list|(
name|void
operator|*
argument_list|)
block|;
comment|// Actually, a (struct stat*)
name|virtual
name|int
name|sys_close
argument_list|()
block|; }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|inline
name|void
name|ios
operator|::
name|init
argument_list|(
argument|streambuf* sb
argument_list|,
argument|ostream* tie_to
argument_list|)
block|{
name|_state
operator|=
name|sb
operator|?
name|ios
operator|::
name|goodbit
operator|:
name|ios
operator|::
name|badbit
block|;
name|_exceptions
operator|=
literal|0
block|;
name|_strbuf
operator|=
name|sb
block|;
name|_tie
operator|=
name|tie_to
block|;
name|_width
operator|=
literal|0
block|;
name|_fill
operator|=
literal|' '
block|;
name|_flags
operator|=
name|ios
operator|::
name|skipws
operator||
name|ios
operator|::
name|dec
block|;
name|_precision
operator|=
literal|6
block|;
name|_arrays
operator|=
literal|0
block|; }
specifier|inline
name|ios
operator|::
operator|~
name|ios
argument_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|_flags
operator|&
operator|(
name|unsigned
name|int
operator|)
name|ios
operator|::
name|dont_close
operator|)
condition|)
name|delete
name|rdbuf
parameter_list|()
function_decl|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _STREAMBUF_H */
end_comment

end_unit

