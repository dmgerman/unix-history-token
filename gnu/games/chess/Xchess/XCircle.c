begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.2 $ on $Date: 86/11/23 17:17:04 $  *           $Source: /users/faustus/xchess/RCS/XCircle.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X11/X10.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|PI
value|3.1415926535897932384
end_define

begin_define
define|#
directive|define
name|MAXVERTS
value|1000
end_define

begin_function
name|void
name|XCircle
parameter_list|(
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|rad
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|pixel
parameter_list|,
name|func
parameter_list|,
name|planes
parameter_list|)
name|Window
name|win
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|rad
decl_stmt|;
name|double
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|pixel
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|func
decl_stmt|,
name|planes
decl_stmt|;
block|{
name|Vertex
name|verts
index|[
name|MAXVERTS
index|]
decl_stmt|;
name|double
name|xp
decl_stmt|,
name|yp
decl_stmt|,
name|ang
decl_stmt|;
name|int
name|lx
decl_stmt|,
name|ly
decl_stmt|,
name|xpt
decl_stmt|,
name|ypt
decl_stmt|,
name|i
decl_stmt|;
name|double
name|gradincr
init|=
literal|2
operator|/
operator|(
name|double
operator|)
name|rad
decl_stmt|;
name|int
name|bk
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|end
operator|>=
name|PI
operator|*
literal|2
condition|)
name|end
operator|-=
name|PI
operator|*
literal|2
expr_stmt|;
while|while
condition|(
name|start
operator|>=
name|PI
operator|*
literal|2
condition|)
name|start
operator|-=
name|PI
operator|*
literal|2
expr_stmt|;
while|while
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|PI
operator|*
literal|2
expr_stmt|;
while|while
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|PI
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|start
condition|)
block|{
if|if
condition|(
name|end
operator|<
name|gradincr
condition|)
name|end
operator|=
name|end
operator|+
name|PI
operator|*
literal|2
operator|-
name|gradincr
operator|/
literal|2
expr_stmt|;
else|else
name|end
operator|-=
name|gradincr
operator|/
literal|2
expr_stmt|;
block|}
for|for
control|(
name|ang
operator|=
name|start
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVERTS
condition|;
control|)
block|{
name|xp
operator|=
name|x
operator|+
name|rad
operator|*
name|cos
argument_list|(
name|ang
argument_list|)
expr_stmt|;
name|yp
operator|=
name|y
operator|+
name|rad
operator|*
name|sin
argument_list|(
name|ang
argument_list|)
expr_stmt|;
name|xpt
operator|=
name|xp
expr_stmt|;
name|ypt
operator|=
name|yp
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|||
operator|(
name|lx
operator|!=
name|xpt
operator|)
operator|||
operator|(
name|ly
operator|!=
name|ypt
operator|)
condition|)
block|{
name|verts
index|[
name|i
index|]
operator|.
name|x
operator|=
name|xpt
expr_stmt|;
name|verts
index|[
name|i
index|]
operator|.
name|y
operator|=
name|ypt
expr_stmt|;
name|verts
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|lx
operator|=
name|xpt
expr_stmt|;
name|ly
operator|=
name|ypt
expr_stmt|;
if|if
condition|(
name|bk
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|ang
operator|<
name|end
operator|)
operator|&&
operator|(
name|ang
operator|+
name|gradincr
operator|>
name|end
operator|)
operator|)
operator|||
operator|(
operator|(
name|end
operator|<
name|start
operator|)
operator|&&
operator|(
name|ang
operator|+
name|gradincr
operator|>
literal|2
operator|*
name|PI
operator|)
operator|&&
operator|(
name|ang
operator|+
name|gradincr
operator|-
literal|2
operator|*
name|PI
operator|>
name|end
operator|)
operator|)
condition|)
block|{
name|ang
operator|=
name|end
expr_stmt|;
name|bk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ang
operator|==
name|end
condition|)
block|{
break|break;
block|}
else|else
block|{
name|ang
operator|+=
name|gradincr
expr_stmt|;
block|}
if|if
condition|(
name|ang
operator|>=
name|PI
operator|*
literal|2
condition|)
name|ang
operator|-=
name|PI
operator|*
literal|2
expr_stmt|;
block|}
comment|/* Now draw the thing.. */
name|XDraw
argument_list|(
name|win
argument_list|,
name|verts
argument_list|,
name|i
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|pixel
argument_list|,
name|func
argument_list|,
name|planes
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
name|VertexCurved
name|is
name|screwed
name|up
end_ifdef

begin_function
name|void
name|XCircle
parameter_list|(
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|rad
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|pixel
parameter_list|,
name|func
parameter_list|,
name|planes
parameter_list|)
name|Window
name|win
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|rad
decl_stmt|;
name|double
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|pixel
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|func
decl_stmt|,
name|planes
decl_stmt|;
block|{
name|Vertex
name|verts
index|[
literal|7
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sv
decl_stmt|,
name|ev
decl_stmt|;
name|int
name|dp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|verts
index|[
name|j
index|]
operator|.
name|x
operator|=
name|x
operator|+
name|rad
operator|*
name|cos
argument_list|(
call|(
name|double
call|)
argument_list|(
name|PI
operator|*
name|i
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|y
operator|=
name|y
operator|+
name|rad
operator|*
name|sin
argument_list|(
call|(
name|double
call|)
argument_list|(
name|PI
operator|*
name|i
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|flags
operator|=
name|VertexCurved
expr_stmt|;
if|if
condition|(
operator|(
name|start
operator|>=
name|PI
operator|*
name|i
operator|/
literal|2
operator|)
operator|&&
operator|(
name|start
operator|<
name|PI
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|&&
operator|(
name|start
operator|!=
name|end
operator|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|x
operator|=
name|x
operator|+
name|rad
operator|*
name|cos
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|y
operator|=
name|y
operator|+
name|rad
operator|*
name|sin
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|flags
operator|=
name|VertexCurved
expr_stmt|;
name|sv
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|end
operator|>=
name|PI
operator|*
name|i
operator|/
literal|2
operator|)
operator|&&
operator|(
name|end
operator|<
name|PI
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|&&
operator|(
name|start
operator|!=
name|end
operator|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|x
operator|=
name|x
operator|+
name|rad
operator|*
name|cos
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|y
operator|=
name|y
operator|+
name|rad
operator|*
name|sin
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|flags
operator|=
name|VertexCurved
expr_stmt|;
name|ev
operator|=
name|j
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
name|verts
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|VertexStartClosed
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|x
operator|=
name|verts
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|y
operator|=
name|verts
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|verts
index|[
name|j
index|]
operator|.
name|flags
operator|=
operator|(
name|verts
index|[
literal|0
index|]
operator|.
name|flags
operator|&
operator|~
name|VertexStartClosed
operator|)
operator||
name|VertexEndClosed
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
condition|)
name|verts
index|[
name|i
operator|%
literal|7
index|]
operator|.
name|flags
operator||=
name|VertexDontDraw
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|7
operator|==
name|ev
condition|)
name|dp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|%
literal|7
operator|==
name|sv
condition|)
name|dp
operator|=
literal|0
expr_stmt|;
block|}
name|XDraw
argument_list|(
name|win
argument_list|,
name|verts
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|pixel
argument_list|,
name|func
argument_list|,
name|planes
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|notdef
end_endif

end_unit

