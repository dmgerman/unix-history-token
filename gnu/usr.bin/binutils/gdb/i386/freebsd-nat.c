begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for BSD Unix running on i386's, for GDB.    Copyright 1988, 1989, 1991, 1992, 1994, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GREGSET_T
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FPREGSET_T
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386v.h */
end_comment

begin_comment
comment|/* symbols like 'tEAX' come from<machine/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tFS
block|,
name|tGS
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|save87
name|pcb_savefpu
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
comment|/* ptrace order, not gcc/gdb order */
name|int
name|r
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|r
argument_list|)
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|inferior_registers
operator|)
operator|+
name|tregmap
index|[
name|r
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
comment|/* ptrace order, not gcc/gdb order */
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|inferior_registers
operator|)
operator|+
name|tregmap
index|[
name|r
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|r
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract the register values out of the core file and store    them where `read_register' will find them.    Extract the floating point state out of the core file and store    it where `float_info' will find it.     CORE_REG_SECT points to the register values themselves, read into memory.    CORE_REG_SIZE is the size of that area.    WHICH says which set of registers we are handling (0 = int, 2 = float          on machines where they are discontiguous).    REG_ADDR is the offset from u.u_ar0 to the register values relative to             core_reg_sect.  This is used with old-fashioned core files to 	    locate the registers in a large upage-plus-stack ".reg" section. 	    Original upage address X is at location core_reg_sect+x+reg_addr.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|CORE_ADDR
name|reg_addr
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|cregno
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|;
name|int
name|bad_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|user
modifier|*
name|tmp_uaddr
decl_stmt|;
comment|/*     * First get virtual address of user structure. Then calculate offset.    */
name|memcpy
argument_list|(
operator|&
name|tmp_uaddr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|user
operator|*
operator|)
name|core_reg_sect
operator|)
operator|->
name|u_kproc
operator|.
name|kp_proc
operator|.
name|p_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_uaddr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|reg_addr
operator|-
operator|(
name|int
operator|)
name|tmp_uaddr
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|cregno
operator|=
name|tregmap
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|cregno
operator|==
name|tGS
condition|)
name|addr
operator|=
name|offsetof
argument_list|(
expr|struct
name|user
argument_list|,
name|u_pcb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|pcb
argument_list|,
name|pcb_gs
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|offset
operator|+
literal|4
operator|*
name|cregno
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
operator|||
name|addr
operator|>=
name|core_reg_size
condition|)
block|{
if|if
condition|(
name|bad_reg
operator|<
literal|0
condition|)
name|bad_reg
operator|=
name|regno
expr_stmt|;
block|}
else|else
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|core_reg_sect
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad_reg
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Register %s not found in core file."
argument_list|,
name|gdb_register_names
index|[
name|bad_reg
index|]
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|offsetof
argument_list|(
expr|struct
name|user
argument_list|,
name|u_pcb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|pcb
argument_list|,
name|pcb_savefpu
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pcb_savefpu
argument_list|,
name|core_reg_sect
operator|+
name|addr
argument_list|,
sizeof|sizeof
name|pcb_savefpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT_INFO
end_ifdef

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* for local_hex_string */
end_comment

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_define
define|#
directive|define
name|curpcb
value|Xcurpcb
end_define

begin_comment
comment|/* XXX avoid leaking declaration from pcb.h */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|curpcb
end_undef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_function_decl
specifier|extern
name|void
name|print_387_control_word
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* i387-tdep.h */
end_comment

begin_function_decl
specifier|extern
name|void
name|print_387_status_word
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|fpstate
value|save87
end_define

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_pcb.pcb_savefpu
end_define

begin_function
specifier|static
name|void
name|i387_to_double
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary    */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_function

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|print_387_status
parameter_list|(
name|status
parameter_list|,
name|ep
parameter_list|)
name|unsigned
name|short
name|status
decl_stmt|;
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"last instruction: "
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"opcode %s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"pc %s:"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|code_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|eip
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"operand %s"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|":%s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|" regno     tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|exp
decl_stmt|;
name|int
name|mantissa_or
decl_stmt|;
name|int
name|normal
decl_stmt|;
name|char
modifier|*
name|sign
decl_stmt|;
name|int
name|st_regno
decl_stmt|;
name|unsigned
name|short
modifier|*
name|usregs
decl_stmt|;
name|double
name|val
decl_stmt|;
comment|/* The physical regno `fpreg' is only relevant as an index into the        * tag word.  Logical `%st' numbers are required for indexing ep->regs.        */
name|st_regno
operator|=
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|&
literal|7
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%%st(%d) %s "
argument_list|,
name|st_regno
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_unfiltered
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf_unfiltered
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf_unfiltered
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf_unfiltered
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
comment|/*        * Handle weird cases better than floatformat_to_double () and        * printf ().        */
name|usregs
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
expr_stmt|;
name|sign
operator|=
name|usregs
index|[
literal|4
index|]
operator|&
literal|0x8000
condition|?
literal|"-"
else|:
literal|""
expr_stmt|;
name|exp
operator|=
name|usregs
index|[
literal|4
index|]
operator|&
literal|0x7fff
expr_stmt|;
name|normal
operator|=
name|usregs
index|[
literal|3
index|]
operator|&
literal|0x8000
expr_stmt|;
name|mantissa_or
operator|=
name|usregs
index|[
literal|0
index|]
operator||
name|usregs
index|[
literal|1
index|]
operator||
name|usregs
index|[
literal|2
index|]
operator||
operator|(
name|usregs
index|[
literal|3
index|]
operator|&
literal|0x7fff
operator|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|normal
condition|)
name|printf_unfiltered
argument_list|(
literal|"Pseudo Denormal (0 as a double)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mantissa_or
operator|==
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"%s0"
argument_list|,
name|sign
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Denormal (0 as a double)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
literal|0x7fff
condition|)
block|{
if|if
condition|(
operator|!
name|normal
condition|)
name|printf_unfiltered
argument_list|(
literal|"Pseudo "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mantissa_or
operator|==
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"%sInf"
argument_list|,
name|sign
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"%s NaN"
argument_list|,
name|usregs
index|[
literal|3
index|]
operator|&
literal|0x4000
condition|?
literal|"Quiet"
else|:
literal|"Signaling"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|normal
condition|)
name|printf_unfiltered
argument_list|(
literal|" (NaN)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|normal
condition|)
name|printf_unfiltered
argument_list|(
literal|"Unnormal (NaN)"
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
comment|/* Use this we stop trapping on overflow.  */
block|floatformat_to_double(&floatformat_i387_ext, 				(char *) ep->regs[st_regno],&val);
else|#
directive|else
name|i387_to_double
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_unfiltered
argument_list|(
literal|"%g"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i386_float_info
parameter_list|()
block|{
name|struct
name|user
name|u
decl_stmt|;
comment|/* just for address computations */
name|int
name|i
decl_stmt|;
comment|/* fpstate defined in<sys/user.h> */
name|struct
name|fpstate
modifier|*
name|fpstatep
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|uaddr
decl_stmt|;
name|char
name|fpvalid
decl_stmt|;
name|unsigned
name|int
name|rounded_addr
decl_stmt|;
name|unsigned
name|int
name|rounded_size
decl_stmt|;
comment|/*extern int corechan;*/
name|int
name|skip
decl_stmt|;
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|U_FPSTATE
argument_list|(
name|u
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
operator|&&
name|core_bfd
operator|==
name|NULL
condition|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
operator|(
operator|(
operator|(
name|uaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|)
operator|-
name|uaddr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|skip
operator|=
name|uaddr
operator|-
name|rounded_addr
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounded_size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rounded_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|fpstatep
operator|=
operator|(
expr|struct
name|fpstate
operator|*
operator|)
operator|(
name|buf
operator|+
name|skip
operator|)
expr_stmt|;
block|}
else|else
name|fpstatep
operator|=
operator|&
name|pcb_savefpu
expr_stmt|;
name|print_387_status
argument_list|(
name|fpstatep
operator|->
name|sv_ex_sw
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|fpstatep
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLOAT_INFO */
end_comment

begin_function
name|int
name|kernel_u_size
parameter_list|()
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
end_ifdef

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_function
name|struct
name|frame_info
modifier|*
name|setup_arbitrary_frame
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"i386 frame specifications require two arguments: sp and pc"
argument_list|)
expr_stmt|;
return|return
name|create_new_frame
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SETUP_ARBITRARY_FRAME */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GREGSET_T
end_ifdef

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gp
parameter_list|)
name|gregset_t
modifier|*
name|gp
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
comment|/* These must be ordered the same as REGISTER_NAMES in      config/i386/tm-i386.h. */
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_eax
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_ecx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_edx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_ebx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_esp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_ebp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_esi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_edi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_eip
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_eflags
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_cs
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_ss
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_ds
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_es
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_fs
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_gs
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GREGSET_T */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FPREGSET_T
end_ifdef

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fp
parameter_list|)
name|fpregset_t
modifier|*
name|fp
decl_stmt|;
block|{
name|memcpy
argument_list|(
operator|&
name|pcb_savefpu
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
name|pcb_savefpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FPREGSET_T */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle aout (trad-core) file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|aout_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
name|fetch_core_registers
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_aout
parameter_list|()
block|{
name|add_core_fns
argument_list|(
operator|&
name|aout_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

