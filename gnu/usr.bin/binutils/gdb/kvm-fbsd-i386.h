begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Kernel core dump functions below target vector, for GDB on FreeBSD/i386.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_function
specifier|static
name|CORE_ADDR
name|ksym_maxuseraddr
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|maxuseraddr
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|maxuseraddr
operator|==
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"PTmap"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|maxuseraddr
operator|=
name|VM_MAXUSER_ADDRESS
expr_stmt|;
block|}
else|else
block|{
name|maxuseraddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxuseraddr
return|;
block|}
end_function

begin_comment
comment|/* Symbol names of kernel entry points.  Use special frames.  */
end_comment

begin_define
define|#
directive|define
name|KSYM_TRAP
value|"calltrap"
end_define

begin_define
define|#
directive|define
name|KSYM_INTR
value|"Xintr"
end_define

begin_define
define|#
directive|define
name|KSYM_FASTINTR
value|"Xfastintr"
end_define

begin_define
define|#
directive|define
name|KSYM_OLDSYSCALL
value|"Xlcall_syscall"
end_define

begin_define
define|#
directive|define
name|KSYM_SYSCALL
value|"Xint0x80_syscall"
end_define

begin_comment
comment|/* The following is FreeBSD-specific hackery to decode special frames    and elide the assembly-language stub.  This could be made faster by    defining a frame_type field in the machine-dependent frame information,    but we don't think that's too important right now.  */
end_comment

begin_enum
enum|enum
name|frametype
block|{
name|tf_normal
block|,
name|tf_trap
block|,
name|tf_interrupt
block|,
name|tf_syscall
block|}
enum|;
end_enum

begin_function
name|CORE_ADDR
name|fbsd_kern_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|this_saved_pc
decl_stmt|;
name|enum
name|frametype
name|frametype
decl_stmt|;
name|this_saved_pc
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|this_saved_pc
argument_list|)
expr_stmt|;
name|frametype
operator|=
name|tf_normal
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_TRAP
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_trap
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_INTR
argument_list|,
name|strlen
argument_list|(
name|KSYM_INTR
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_FASTINTR
argument_list|,
name|strlen
argument_list|(
name|KSYM_FASTINTR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_interrupt
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_SYSCALL
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_OLDSYSCALL
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_syscall
expr_stmt|;
block|}
switch|switch
condition|(
name|frametype
condition|)
block|{
case|case
name|tf_normal
case|:
return|return
operator|(
name|this_saved_pc
operator|)
return|;
define|#
directive|define
name|oEIP
value|offsetof (struct trapframe, tf_eip)
case|case
name|tf_trap
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_interrupt
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
literal|12
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_syscall
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
undef|#
directive|undef
name|oEIP
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_kcore_registers
parameter_list|(
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|noreg
decl_stmt|;
comment|/* Get the register values out of the sys pcb and store them where      `read_register' will find them.  */
comment|/*    * XXX many registers aren't available.    * XXX for the non-core case, the registers are stale - they are for    *     the last context switch to the debugger.    * XXX gcc's register numbers aren't all #defined in tm-i386.h.    */
name|noreg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
comment|/* eax,ecx,edx */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|noreg
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|3
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_ebx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_esp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_ebp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_esi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|7
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_edi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_eip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|14
condition|;
operator|++
name|i
control|)
comment|/* eflags, cs, ss, ds, es, fs */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|noreg
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|15
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_gs
argument_list|)
expr_stmt|;
comment|/* XXX 80387 registers?  */
block|}
end_function

end_unit

