begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle FreeBSD kernel modules as shared libraries.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,    2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_comment
comment|/* XXX, kludge to avoid duplicate definitions while sys/linker.h is used. */
end_comment

begin_define
define|#
directive|define
name|_ELF_COMMON_H
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_struct
struct|struct
name|lm_info
block|{
name|CORE_ADDR
name|address
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|try_modpath
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|guess_modpath
parameter_list|(
name|char
modifier|*
name|modname
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|kgdb_relocate_section_addresses
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|struct
name|section_table
modifier|*
name|sec
parameter_list|)
block|{
name|sec
operator|->
name|addr
operator|+=
name|so
operator|->
name|lm_info
operator|->
name|address
expr_stmt|;
name|sec
operator|->
name|endaddr
operator|+=
name|so
operator|->
name|lm_info
operator|->
name|address
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kgdb_open_symbol_file_object
parameter_list|(
name|void
modifier|*
name|from_ttyp
parameter_list|)
block|{
name|warning
argument_list|(
literal|"kgdb_open_symbol_file_object called\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|kgdb_current_sos
parameter_list|(
name|void
parameter_list|)
block|{
name|linker_file_list_t
name|linker_files
decl_stmt|;
name|struct
name|linker_file
name|lfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|linker_file
modifier|*
name|lfilek
decl_stmt|;
name|struct
name|so_list
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|struct
name|so_list
modifier|*
modifier|*
name|link_ptr
init|=
operator|&
name|head
decl_stmt|;
name|CORE_ADDR
name|lfiles_addr
decl_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"linker_files"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
operator|||
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"failed to find linker_files symbol\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lfiles_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|lfiles_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|linker_files
argument_list|,
sizeof|sizeof
argument_list|(
name|linker_files
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"failed to read linker_files data\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|lfilek
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|linker_files
argument_list|)
init|;
name|lfilek
operator|!=
name|NULL
condition|;
name|lfilek
operator|=
name|TAILQ_NEXT
argument_list|(
operator|&
name|lfile
argument_list|,
name|link
argument_list|)
control|)
block|{
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|errcode
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lfilek
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lfile
argument_list|,
sizeof|sizeof
argument_list|(
name|lfile
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"failed to read linker file data at %p\n"
argument_list|,
name|lfilek
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lfile
operator|.
name|filename
argument_list|,
operator|&
name|buf
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"cannot read linker file pathname: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
literal|3
operator|||
name|strcmp
argument_list|(
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
index|]
argument_list|,
literal|".ko"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm_info
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lm_info
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
operator|->
name|lm_info
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm_info
operator|->
name|address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|lfile
operator|.
name|address
expr_stmt|;
name|strncpy
argument_list|(
name|new
operator|->
name|so_original_name
argument_list|,
name|buf
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|so_original_name
index|[
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|new
operator|->
name|so_name
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
argument_list|,
literal|"%s"
argument_list|,
name|guess_modpath
argument_list|(
name|new
operator|->
name|so_original_name
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|link_ptr
operator|=
name|new
expr_stmt|;
name|link_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kgdb_in_dynsym_resolve_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|warning
argument_list|(
literal|"kgdb_in_dynsym_resolve_code called\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kgdb_special_symbol_handling
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|kgdb_solib_create_inferior_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|inferior_sos
decl_stmt|;
name|inferior_sos
operator|=
name|kgdb_current_sos
argument_list|()
expr_stmt|;
if|if
condition|(
name|inferior_sos
condition|)
block|{
name|solib_add
argument_list|(
name|NULL
argument_list|,
comment|/*from_tty*/
literal|0
argument_list|,
name|NULL
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kgdb_clear_solib
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|kgdb_free_so
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|xfree
argument_list|(
name|so
operator|->
name|lm_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|try_modpath
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|guess_modpath
parameter_list|(
name|char
modifier|*
name|modname
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|,
name|moddir
index|[
literal|128
index|]
decl_stmt|,
name|syspath
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|kernpath
decl_stmt|,
modifier|*
name|objpath
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|version
decl_stmt|;
name|int
name|errcode
decl_stmt|,
name|n
decl_stmt|,
name|syspathlen
decl_stmt|;
comment|/* Set default module location */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/boot/kernel/%s"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* Guess at the subdirectory off sys/modules. XXX, only sometimes correct */
name|n
operator|=
name|strlen
argument_list|(
name|modname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|3
operator|&&
name|strcmp
argument_list|(
operator|&
name|modname
index|[
name|n
operator|-
literal|3
index|]
argument_list|,
literal|".ko"
argument_list|)
operator|==
literal|0
condition|)
name|n
operator|-=
literal|3
expr_stmt|;
name|snprintf
argument_list|(
name|moddir
argument_list|,
sizeof|sizeof
argument_list|(
name|moddir
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
name|n
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* Try to locate the kernel compile location from version[] */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"version"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
operator|||
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find `version' symbol; using default module path\n"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|target_read_string
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|&
name|version
argument_list|,
literal|2048
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"cannot read `version' string; using default module path: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/* Find the kernel build path after user@host: on the second line. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|version
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|kernpath
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|kernpath
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"cannot parse version[]; using default module path\n"
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|kernpath
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/*    * Find the absolute path to src/sys by skipping back over path    * components until we find a "/sys/".    */
name|syspathlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|kernpath
operator|&&
name|syspathlen
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|p
operator|>
name|kernpath
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/sys/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|syspathlen
operator|=
name|p
operator|-
name|kernpath
operator|+
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|>
name|kernpath
condition|)
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|syspathlen
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find /sys/ in `%s'; using default module path\n"
argument_list|,
name|kernpath
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/*    * For kernels compiled with buildkernel, the object path will have    * been prepended to the /sys/ path in `kernpath'.    */
name|objpath
operator|=
name|getenv
argument_list|(
literal|"MAKEOBJDIRPREFIX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|objpath
operator|==
name|NULL
condition|)
name|objpath
operator|=
literal|"/usr/obj"
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|objpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|syspathlen
operator|>
name|n
operator|+
literal|1
operator|&&
name|strncmp
argument_list|(
name|kernpath
argument_list|,
name|objpath
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|kernpath
index|[
name|n
index|]
operator|==
literal|'/'
condition|)
name|snprintf
argument_list|(
name|syspath
argument_list|,
sizeof|sizeof
argument_list|(
name|syspath
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
name|syspathlen
operator|-
name|n
argument_list|,
name|kernpath
operator|+
name|n
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|syspath
argument_list|,
sizeof|sizeof
argument_list|(
name|syspath
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
name|syspathlen
argument_list|,
name|kernpath
argument_list|)
expr_stmt|;
comment|/* Now try to find the module file */
if|if
condition|(
operator|!
name|try_modpath
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"./%s.debug"
argument_list|,
name|modname
argument_list|)
operator|&&
operator|!
name|try_modpath
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"./%s"
argument_list|,
name|modname
argument_list|)
operator|&&
operator|!
name|try_modpath
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/modules%s/modules/%s/%s.debug"
argument_list|,
name|kernpath
argument_list|,
name|syspath
argument_list|,
name|moddir
argument_list|,
name|modname
argument_list|)
operator|&&
operator|!
name|try_modpath
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/modules%s/modules/%s/%s"
argument_list|,
name|kernpath
argument_list|,
name|syspath
argument_list|,
name|moddir
argument_list|,
name|modname
argument_list|)
operator|&&
operator|!
name|try_modpath
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/boot/kernel/%s.debug"
argument_list|,
name|modname
argument_list|)
operator|&&
operator|!
name|try_modpath
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/boot/kernel/%s"
argument_list|,
name|modname
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find file for module %s\n"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_so_ops
name|kgdb_so_ops
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_kgdb_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|kgdb_so_ops
operator|.
name|relocate_section_addresses
operator|=
name|kgdb_relocate_section_addresses
expr_stmt|;
name|kgdb_so_ops
operator|.
name|free_so
operator|=
name|kgdb_free_so
expr_stmt|;
name|kgdb_so_ops
operator|.
name|clear_solib
operator|=
name|kgdb_clear_solib
expr_stmt|;
name|kgdb_so_ops
operator|.
name|solib_create_inferior_hook
operator|=
name|kgdb_solib_create_inferior_hook
expr_stmt|;
name|kgdb_so_ops
operator|.
name|special_symbol_handling
operator|=
name|kgdb_special_symbol_handling
expr_stmt|;
name|kgdb_so_ops
operator|.
name|current_sos
operator|=
name|kgdb_current_sos
expr_stmt|;
name|kgdb_so_ops
operator|.
name|open_symbol_file_object
operator|=
name|kgdb_open_symbol_file_object
expr_stmt|;
name|kgdb_so_ops
operator|.
name|in_dynsym_resolve_code
operator|=
name|kgdb_in_dynsym_resolve_code
expr_stmt|;
block|}
end_function

end_unit

