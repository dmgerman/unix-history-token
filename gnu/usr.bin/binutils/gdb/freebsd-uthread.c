begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Low level interface for debugging FreeBSD user threads for GDB, the GNU debugger.    Copyright 1996, 1999 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module implements a sort of half target that sits between the    machine-independent parts of GDB and the ptrace interface (infptrace.c) to    provide access to the FreeBSD user-mode thread implementation.     FreeBSD threads are true user-mode threads, which are invoked via    the pthread_* interfaces.  These are mostly implemented in    user-space, with all thread context kept in various structures that    live in the user's heap.  For the most part, the kernel has no    knowlege of these threads.     Based largely on hpux-thread.c     */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|child_suppress_run
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target vector for inftarg.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|_initialize_freebsd_uthread
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|main_pid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real process ID */
end_comment

begin_comment
comment|/* Set to true while we are part-way through attaching */
end_comment

begin_decl_stmt
specifier|static
name|int
name|freebsd_uthread_attaching
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|freebsd_uthread_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_run
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|save_inferior_pid
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_inferior_pid
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freebsd_uthread_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_freebsd_uthread_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|freebsd_uthread_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_thread_vector
name|freebsd_uthread_vec
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	save_inferior_pid - Save inferior_pid on the cleanup list 	restore_inferior_pid - Restore inferior_pid from the cleanup list  SYNOPSIS  	struct cleanup *save_inferior_pid () 	void restore_inferior_pid (int pid)  DESCRIPTION  	These two functions act in unison to restore inferior_pid in 	case of an error.  NOTES  	inferior_pid is a global variable that needs to be changed by many of 	these routines before calling functions in procfs.c.  In order to 	guarantee that inferior_pid gets restored (in case of errors), you 	need to call save_inferior_pid before changing it.  At the end of the 	function, you should invoke do_cleanups to restore it.   */
end_comment

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|save_inferior_pid
parameter_list|()
block|{
return|return
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|restore_inferior_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|inferior_pid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_inferior_pid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|inferior_pid
operator|=
name|pid
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|find_active_thread
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cached_pthread
block|{
name|u_int64_t
name|uniqueid
decl_stmt|;
name|int
name|state
decl_stmt|;
name|CORE_ADDR
name|name
decl_stmt|;
name|int
name|ctxtype
decl_stmt|;
union|union
block|{
name|ucontext_t
name|uc
decl_stmt|;
name|jmp_buf
name|jb
decl_stmt|;
block|}
name|ctx
union|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|cached_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cached_pthread
name|cached_pthread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cached_pthread_addr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THREADID_TID
parameter_list|(
name|id
parameter_list|)
value|((id)>> 17)
end_define

begin_define
define|#
directive|define
name|THREADID_PID
parameter_list|(
name|id
parameter_list|)
value|((id)& ((1<< 17) - 1))
end_define

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|idmaplist
argument_list|,
name|idmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|idmap
block|{
name|LIST_ENTRY
argument_list|(
argument|idmap
argument_list|)
name|link
expr_stmt|;
name|u_int64_t
name|uniqueid
decl_stmt|;
name|int
name|tid
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAPHASH_SIZE
value|257
end_define

begin_define
define|#
directive|define
name|TID_MIN
value|1
end_define

begin_define
define|#
directive|define
name|TID_MAX
value|16383
end_define

begin_decl_stmt
specifier|static
name|int
name|tid_to_hash
index|[
name|TID_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to map_hash index */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|idmaplist
name|map_hash
index|[
name|MAPHASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_free_tid
init|=
name|TID_MIN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first available tid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_free_tid
init|=
name|TID_MIN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first unavailable */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_next_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_uniqueid_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_state_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_name_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_curframe_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_sigframe_ctxtype_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_sigframe_ctx_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_PS_RUNNING_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_PS_DEAD_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_CTX_JB_NOSIG_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_CTX_JB_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_CTX_SJB_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_thread_CTX_UC_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uniqueid_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|name_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curframe_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigframe_ctxtype_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigframe_ctx_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PS_RUNNING_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PS_DEAD_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CTX_JB_NOSIG_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CTX_JB_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CTX_SJB_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CTX_UC_value
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNIQUEID_HASH
parameter_list|(
name|id
parameter_list|)
value|(id % MAPHASH_SIZE)
end_define

begin_define
define|#
directive|define
name|TID_ADD1
parameter_list|(
name|tid
parameter_list|)
value|(((tid) + 1) == TID_MAX + 1 \ 				 ? TID_MIN : (tid) + 1)
end_define

begin_define
define|#
directive|define
name|IS_TID_FREE
parameter_list|(
name|tid
parameter_list|)
value|(tid_to_hash[tid] == -1)
end_define

begin_function
specifier|static
name|int
name|get_new_tid
parameter_list|(
name|h
parameter_list|)
name|int
name|h
decl_stmt|;
block|{
name|int
name|tid
init|=
name|next_free_tid
decl_stmt|;
name|tid_to_hash
index|[
name|tid
index|]
operator|=
name|h
expr_stmt|;
name|next_free_tid
operator|=
name|TID_ADD1
argument_list|(
name|next_free_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_free_tid
operator|==
name|last_free_tid
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_free_tid
init|;
name|TID_ADD1
argument_list|(
name|i
argument_list|)
operator|!=
name|last_free_tid
condition|;
name|i
operator|=
name|TID_ADD1
argument_list|(
name|i
argument_list|)
control|)
if|if
condition|(
name|IS_TID_FREE
argument_list|(
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TID_ADD1
argument_list|(
name|i
argument_list|)
operator|==
name|last_free_tid
condition|)
block|{
name|error
argument_list|(
literal|"too many threads"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|next_free_tid
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TID_ADD1
argument_list|(
name|i
argument_list|)
init|;
name|IS_TID_FREE
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|=
name|TID_ADD1
argument_list|(
name|i
argument_list|)
control|)
empty_stmt|;
name|last_free_tid
operator|=
name|i
expr_stmt|;
block|}
return|return
name|tid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_pid
parameter_list|(
name|uniqueid
parameter_list|)
name|u_int64_t
name|uniqueid
decl_stmt|;
block|{
name|int
name|h
init|=
name|UNIQUEID_HASH
argument_list|(
name|uniqueid
argument_list|)
decl_stmt|;
name|struct
name|idmap
modifier|*
name|im
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|im
argument_list|,
argument|&map_hash[h]
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|im
operator|->
name|uniqueid
operator|==
name|uniqueid
condition|)
return|return
operator|(
name|im
operator|->
name|tid
operator|<<
literal|17
operator|)
operator|+
name|main_pid
return|;
name|im
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|idmap
argument_list|)
argument_list|)
expr_stmt|;
name|im
operator|->
name|uniqueid
operator|=
name|uniqueid
expr_stmt|;
name|im
operator|->
name|tid
operator|=
name|get_new_tid
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|map_hash
index|[
name|h
index|]
argument_list|,
name|im
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|im
operator|->
name|tid
operator|<<
literal|17
operator|)
operator|+
name|main_pid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_pid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|tid
init|=
name|THREADID_TID
argument_list|(
name|pid
argument_list|)
decl_stmt|;
name|int
name|h
init|=
name|tid_to_hash
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|idmap
modifier|*
name|im
decl_stmt|;
if|if
condition|(
operator|!
name|tid
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|im
argument_list|,
argument|&map_hash[h]
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|im
operator|->
name|tid
operator|==
name|tid
condition|)
break|break;
if|if
condition|(
operator|!
name|im
condition|)
return|return;
name|LIST_REMOVE
argument_list|(
name|im
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|tid_to_hash
index|[
name|tid
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|im
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|READ_OFFSET
parameter_list|(
name|field
parameter_list|)
value|read_memory(P_thread_##field##_offset,	\ 				       (char *)&field##_offset,	\ 				       sizeof(field##_offset))
end_define

begin_define
define|#
directive|define
name|READ_VALUE
parameter_list|(
name|name
parameter_list|)
value|read_memory(P_thread_##name##_value,	\ 				     (char *)&name##_value,	\ 				     sizeof(name##_value))
end_define

begin_function
specifier|static
name|void
name|read_thread_offsets
parameter_list|()
block|{
name|READ_OFFSET
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|READ_OFFSET
argument_list|(
name|uniqueid
argument_list|)
expr_stmt|;
name|READ_OFFSET
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|READ_OFFSET
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|READ_OFFSET
argument_list|(
name|curframe
argument_list|)
expr_stmt|;
name|READ_OFFSET
argument_list|(
name|sigframe_ctxtype
argument_list|)
expr_stmt|;
name|READ_OFFSET
argument_list|(
name|sigframe_ctx
argument_list|)
expr_stmt|;
name|READ_VALUE
argument_list|(
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|READ_VALUE
argument_list|(
name|PS_DEAD
argument_list|)
expr_stmt|;
name|READ_VALUE
argument_list|(
name|CTX_JB_NOSIG
argument_list|)
expr_stmt|;
name|READ_VALUE
argument_list|(
name|CTX_JB
argument_list|)
expr_stmt|;
name|READ_VALUE
argument_list|(
name|CTX_SJB
argument_list|)
expr_stmt|;
name|READ_VALUE
argument_list|(
name|CTX_UC
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|READ_FIELD
parameter_list|(
name|ptr
parameter_list|,
name|T
parameter_list|,
name|field
parameter_list|,
name|result
parameter_list|)
define|\
value|read_memory ((ptr) + field##_offset, (char *)&(result), sizeof result)
end_define

begin_function
specifier|static
name|u_int64_t
name|read_pthread_uniqueid
parameter_list|(
name|ptr
parameter_list|)
name|CORE_ADDR
name|ptr
decl_stmt|;
block|{
name|u_int64_t
name|uniqueid
decl_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|u_int64_t
argument_list|,
name|uniqueid
argument_list|,
name|uniqueid
argument_list|)
expr_stmt|;
return|return
name|uniqueid
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_pthread_next
parameter_list|(
name|ptr
parameter_list|)
name|CORE_ADDR
name|ptr
decl_stmt|;
block|{
name|CORE_ADDR
name|next
decl_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|CORE_ADDR
argument_list|,
name|next
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_cached_pthread
parameter_list|(
name|ptr
parameter_list|,
name|cache
parameter_list|)
name|CORE_ADDR
name|ptr
decl_stmt|;
name|struct
name|cached_pthread
modifier|*
name|cache
decl_stmt|;
block|{
name|CORE_ADDR
name|curframe_ptr
decl_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|u_int64_t
argument_list|,
name|uniqueid
argument_list|,
name|cache
operator|->
name|uniqueid
argument_list|)
expr_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|int
argument_list|,
name|state
argument_list|,
name|cache
operator|->
name|state
argument_list|)
expr_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|CORE_ADDR
argument_list|,
name|name
argument_list|,
name|cache
operator|->
name|name
argument_list|)
expr_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|CORE_ADDR
argument_list|,
name|curframe
argument_list|,
name|curframe_ptr
argument_list|)
expr_stmt|;
name|READ_FIELD
argument_list|(
name|curframe_ptr
argument_list|,
name|int
argument_list|,
name|sigframe_ctxtype
argument_list|,
name|cache
operator|->
name|ctxtype
argument_list|)
expr_stmt|;
name|READ_FIELD
argument_list|(
name|curframe_ptr
argument_list|,
name|int
argument_list|,
name|sigframe_ctx
argument_list|,
name|cache
operator|->
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_active_thread
parameter_list|()
block|{
name|CORE_ADDR
name|ptr
decl_stmt|;
if|if
condition|(
name|main_pid
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|P_thread_run
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
return|return
name|find_pid
argument_list|(
name|read_pthread_uniqueid
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|find_pthread_addr
name|PARAMS
argument_list|(
operator|(
name|int
name|thread
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cached_pthread
modifier|*
name|find_pthread
name|PARAMS
argument_list|(
operator|(
name|int
name|thread
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|find_pthread_addr
parameter_list|(
name|thread
parameter_list|)
name|int
name|thread
decl_stmt|;
block|{
name|CORE_ADDR
name|ptr
decl_stmt|;
if|if
condition|(
name|thread
operator|==
name|cached_thread
condition|)
return|return
name|cached_pthread_addr
return|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|P_thread_list
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|find_pid
argument_list|(
name|read_pthread_uniqueid
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|==
name|thread
condition|)
block|{
name|cached_thread
operator|=
name|thread
expr_stmt|;
name|cached_pthread_addr
operator|=
name|ptr
expr_stmt|;
name|read_cached_pthread
argument_list|(
name|ptr
argument_list|,
operator|&
name|cached_pthread
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
name|ptr
operator|=
name|read_pthread_next
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cached_pthread
modifier|*
name|find_pthread
parameter_list|(
name|thread
parameter_list|)
name|int
name|thread
decl_stmt|;
block|{
name|CORE_ADDR
name|ptr
decl_stmt|;
if|if
condition|(
name|thread
operator|==
name|cached_thread
condition|)
return|return
operator|&
name|cached_pthread
return|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|P_thread_list
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|find_pid
argument_list|(
name|read_pthread_uniqueid
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|==
name|thread
condition|)
block|{
name|cached_thread
operator|=
name|thread
expr_stmt|;
name|cached_pthread_addr
operator|=
name|ptr
expr_stmt|;
name|read_cached_pthread
argument_list|(
name|ptr
argument_list|,
operator|&
name|cached_pthread
argument_list|)
expr_stmt|;
return|return
operator|&
name|cached_pthread
return|;
block|}
name|ptr
operator|=
name|read_pthread_next
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|error ("Can't find pthread %d,%d", 	 THREADID_TID(thread), THREADID_PID(thread));
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Most target vector functions from here on actually just pass through to    inftarg.c, as they don't need to do anything specific for threads.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_open
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|freebsd_uthread_ops
argument_list|)
expr_stmt|;
name|freebsd_uthread_attaching
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After an attach, see if the target is threaded */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_post_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
name|freebsd_uthread_active
condition|)
block|{
name|read_thread_offsets
argument_list|()
expr_stmt|;
name|main_pid
operator|=
name|pid
expr_stmt|;
name|bind_target_thread_vector
argument_list|(
operator|&
name|freebsd_uthread_vec
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|find_active_thread
argument_list|()
expr_stmt|;
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unpush_target
argument_list|(
operator|&
name|freebsd_uthread_ops
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
name|freebsd_uthread_attaching
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of process PID.  If STEP is nozero, then    just single step it.  If SIGNAL is nonzero, restart it with that    signal activated.  We may have to convert pid from a thread-id to an LWP id    for procfs.  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signo
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
block|{
name|child_ops
operator|.
name|to_resume
argument_list|(
name|pid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return;
block|}
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|pid
operator|=
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|child_ops
operator|.
name|to_resume
argument_list|(
name|pid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|cached_thread
operator|=
literal|0
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for any threads to stop.  We may have to convert PID from a thread id    to a LWP id, and vice versa on the way out.  */
end_comment

begin_function
specifier|static
name|int
name|freebsd_uthread_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|int
name|rtnval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
block|{
return|return
name|child_ops
operator|.
name|to_wait
argument_list|(
name|pid
argument_list|,
name|ourstatus
argument_list|)
return|;
block|}
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
name|pid
operator|=
name|main_pid
expr_stmt|;
name|rtnval
operator|=
name|child_ops
operator|.
name|to_wait
argument_list|(
name|pid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|>=
literal|0
condition|)
block|{
name|rtnval
operator|=
name|find_active_thread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|rtnval
argument_list|)
condition|)
name|add_thread
argument_list|(
name|rtnval
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|rtnval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|sigmap
index|[
name|NUM_REGS
index|]
init|=
comment|/* map reg to sigcontext  */
block|{
literal|12
block|,
comment|/* eax */
literal|11
block|,
comment|/* ecx */
literal|10
block|,
comment|/* edx */
literal|9
block|,
comment|/* ebx */
literal|8
block|,
comment|/* esp */
literal|7
block|,
comment|/* ebp */
literal|6
block|,
comment|/* esi */
literal|5
block|,
comment|/* edi */
literal|15
block|,
comment|/* eip */
literal|17
block|,
comment|/* eflags */
literal|16
block|,
comment|/* cs */
literal|19
block|,
comment|/* ss */
literal|4
block|,
comment|/* ds */
literal|3
block|,
comment|/* es */
literal|2
block|,
comment|/* fs */
literal|1
block|,
comment|/* gs */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|jmpmap
index|[
name|NUM_REGS
index|]
init|=
comment|/* map reg to jmp_buf */
block|{
literal|6
block|,
comment|/* eax */
operator|-
literal|1
block|,
comment|/* ecx */
operator|-
literal|1
block|,
comment|/* edx */
literal|1
block|,
comment|/* ebx */
literal|2
block|,
comment|/* esp */
literal|3
block|,
comment|/* ebp */
literal|4
block|,
comment|/* esi */
literal|5
block|,
comment|/* edi */
literal|0
block|,
comment|/* eip */
operator|-
literal|1
block|,
comment|/* eflags */
operator|-
literal|1
block|,
comment|/* cs */
operator|-
literal|1
block|,
comment|/* ss */
operator|-
literal|1
block|,
comment|/* ds */
operator|-
literal|1
block|,
comment|/* es */
operator|-
literal|1
block|,
comment|/* fs */
operator|-
literal|1
block|,
comment|/* gs */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|sigmap
index|[
name|NUM_REGS
index|]
init|=
comment|/* map reg to sigcontext  */
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
comment|/* v0 - t6 */
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
comment|/* t7 - fp */
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
comment|/* a0 - t9 */
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
comment|/* t10 - zero */
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
comment|/* f0 - f7 */
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
comment|/* f8 - f15 */
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
comment|/* f16 - f23 */
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
comment|/* f24 - f31 */
literal|33
block|,
operator|-
literal|1
comment|/* pc, vfp */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|jmpmap
index|[
name|NUM_REGS
index|]
init|=
block|{
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
comment|/* v0 - t6 */
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
comment|/* t7 - fp */
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
comment|/* a0 - t9 */
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
comment|/* t10 - zero */
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
comment|/* f0 - f7 */
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
comment|/* f8 - f15 */
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
comment|/* f16 - f23 */
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
comment|/* f24 - f31 */
literal|2
block|,
operator|-
literal|1
block|,
comment|/* pc, vfp */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|freebsd_uthread_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|cached_pthread
modifier|*
name|thread
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|register_t
modifier|*
name|regbase
decl_stmt|;
name|char
modifier|*
name|regmap
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
block|{
name|child_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|thread
operator|=
name|find_pthread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|active
operator|=
operator|(
name|inferior_pid
operator|==
name|find_active_thread
argument_list|()
operator|)
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|child_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|first_regno
operator|=
literal|0
expr_stmt|;
name|last_regno
operator|=
name|NUM_REGS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_regno
operator|=
name|regno
expr_stmt|;
name|last_regno
operator|=
name|regno
expr_stmt|;
block|}
if|if
condition|(
name|thread
operator|->
name|ctxtype
operator|==
name|CTX_UC_value
condition|)
block|{
name|regbase
operator|=
operator|(
name|register_t
operator|*
operator|)
operator|&
name|thread
operator|->
name|ctx
operator|.
name|uc
operator|.
name|uc_mcontext
expr_stmt|;
name|regmap
operator|=
name|sigmap
expr_stmt|;
block|}
else|else
block|{
name|regbase
operator|=
operator|(
name|register_t
operator|*
operator|)
operator|&
name|thread
operator|->
name|ctx
operator|.
name|jb
index|[
literal|0
index|]
expr_stmt|;
name|regmap
operator|=
name|jmpmap
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|first_regno
init|;
name|regno
operator|<=
name|last_regno
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regmap
index|[
name|regno
index|]
operator|==
operator|-
literal|1
condition|)
name|child_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regbase
index|[
name|regmap
index|[
name|regno
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freebsd_uthread_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|cached_pthread
modifier|*
name|thread
decl_stmt|;
name|CORE_ADDR
name|ptr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|u_int32_t
modifier|*
name|regbase
decl_stmt|;
name|char
modifier|*
name|regmap
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
block|{
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|thread
operator|=
name|find_pthread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|state
operator|==
name|PS_RUNNING_value
condition|)
block|{
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|first_regno
operator|=
literal|0
expr_stmt|;
name|last_regno
operator|=
name|NUM_REGS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_regno
operator|=
name|regno
expr_stmt|;
name|last_regno
operator|=
name|regno
expr_stmt|;
block|}
if|if
condition|(
name|thread
operator|->
name|ctxtype
operator|==
name|CTX_UC_value
condition|)
block|{
name|regbase
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|thread
operator|->
name|ctx
operator|.
name|uc
operator|.
name|uc_mcontext
expr_stmt|;
name|regmap
operator|=
name|sigmap
expr_stmt|;
block|}
else|else
block|{
name|regbase
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|thread
operator|->
name|ctx
operator|.
name|jb
index|[
literal|0
index|]
expr_stmt|;
name|regmap
operator|=
name|jmpmap
expr_stmt|;
block|}
name|ptr
operator|=
name|find_pthread_addr
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|first_regno
init|;
name|regno
operator|<=
name|last_regno
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regmap
index|[
name|regno
index|]
operator|==
operator|-
literal|1
condition|)
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|u_int32_t
modifier|*
name|reg
init|=
operator|&
name|regbase
index|[
name|regmap
index|[
name|regno
index|]
index|]
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* Hang onto cached value */
name|memcpy
argument_list|(
name|reg
argument_list|,
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And push out to inferior */
name|off
operator|=
operator|(
name|char
operator|*
operator|)
name|reg
operator|-
operator|(
name|char
operator|*
operator|)
name|thread
expr_stmt|;
name|write_memory
argument_list|(
name|ptr
operator|+
name|off
argument_list|,
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_prepare_to_store
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
block|{
name|child_ops
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
return|return;
block|}
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|child_ops
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|freebsd_uthread_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|dowrite
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dowrite
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
block|{
return|return
name|child_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|target
argument_list|)
return|;
block|}
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|retval
operator|=
name|child_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_files_info
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freebsd_uthread_kill_inferior
parameter_list|()
block|{
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|child_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freebsd_uthread_notice_signals
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|child_ops
operator|.
name|to_notice_signals
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork an inferior process, and start debugging it with /proc.  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|&&
name|freebsd_uthread_active
condition|)
block|{
name|read_thread_offsets
argument_list|()
expr_stmt|;
name|main_pid
operator|=
name|inferior_pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|freebsd_uthread_ops
argument_list|)
expr_stmt|;
name|bind_target_thread_vector
argument_list|(
operator|&
name|freebsd_uthread_vec
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|find_active_thread
argument_list|()
expr_stmt|;
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called to find out if the inferior is using threads.    We check for the _thread_run and _thread_list globals. */
end_comment

begin_function
name|void
name|freebsd_uthread_new_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|objfile
condition|)
block|{
name|freebsd_uthread_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_thread_run"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
return|return;
name|P_thread_run
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_thread_list"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
return|return;
name|P_thread_list
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
define|#
directive|define
name|OFFSET_SYM
parameter_list|(
name|field
parameter_list|)
value|"_thread_" #field "_offset"
define|#
directive|define
name|LOOKUP_OFFSET
parameter_list|(
name|field
parameter_list|)
define|\
value|do {									\       ms = lookup_minimal_symbol (OFFSET_SYM(field), NULL, objfile);	\       if (!ms)								\ 	return;								\       P_thread_##field##_offset = SYMBOL_VALUE_ADDRESS (ms);		\   } while (0);
define|#
directive|define
name|VALUE_SYM
parameter_list|(
name|name
parameter_list|)
value|"_thread_" #name "_value"
define|#
directive|define
name|LOOKUP_VALUE
parameter_list|(
name|name
parameter_list|)
define|\
value|do {									\        ms = lookup_minimal_symbol (VALUE_SYM(name), NULL, objfile);	\       if (!ms)								\ 	return;								\       P_thread_##name##_value = SYMBOL_VALUE_ADDRESS (ms);		\   } while (0);
name|LOOKUP_OFFSET
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|LOOKUP_OFFSET
argument_list|(
name|uniqueid
argument_list|)
expr_stmt|;
name|LOOKUP_OFFSET
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|LOOKUP_OFFSET
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOOKUP_OFFSET
argument_list|(
name|curframe
argument_list|)
expr_stmt|;
name|LOOKUP_OFFSET
argument_list|(
name|sigframe_ctxtype
argument_list|)
expr_stmt|;
name|LOOKUP_OFFSET
argument_list|(
name|sigframe_ctx
argument_list|)
expr_stmt|;
name|LOOKUP_VALUE
argument_list|(
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|LOOKUP_VALUE
argument_list|(
name|PS_DEAD
argument_list|)
expr_stmt|;
name|LOOKUP_VALUE
argument_list|(
name|CTX_JB_NOSIG
argument_list|)
expr_stmt|;
name|LOOKUP_VALUE
argument_list|(
name|CTX_JB
argument_list|)
expr_stmt|;
name|LOOKUP_VALUE
argument_list|(
name|CTX_SJB
argument_list|)
expr_stmt|;
name|LOOKUP_VALUE
argument_list|(
name|CTX_UC
argument_list|)
expr_stmt|;
name|freebsd_uthread_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|freebsd_uthread_has_exited
parameter_list|(
name|pid
parameter_list|,
name|wait_status
parameter_list|,
name|exit_status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
name|int
modifier|*
name|exit_status
decl_stmt|;
block|{
name|int
name|t
init|=
name|child_ops
operator|.
name|to_has_exited
argument_list|(
name|pid
argument_list|,
name|wait_status
argument_list|,
name|exit_status
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|main_pid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|freebsd_uthread_mourn_inferior
parameter_list|()
block|{
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
comment|/* don't bother to restore inferior_pid */
name|child_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|freebsd_uthread_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
end_comment

begin_function
specifier|static
name|int
name|freebsd_uthread_can_run
parameter_list|()
block|{
return|return
name|child_suppress_run
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|freebsd_uthread_thread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cached_pthread
modifier|*
name|thread
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|freebsd_uthread_attaching
condition|)
return|return
literal|1
return|;
comment|/*    * We can get called from child_ops.to_wait() which passes the underlying    * pid (without a thread number).    */
if|if
condition|(
name|THREADID_TID
argument_list|(
name|pid
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|find_pthread_addr
argument_list|(
name|pid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|thread
operator|=
name|find_pthread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|thread
operator|->
name|state
operator|!=
name|PS_DEAD_value
operator|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|free_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freebsd_uthread_stop
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|child_ops
operator|.
name|to_stop
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|freebsd_uthread_find_new_threads
parameter_list|()
block|{
name|CORE_ADDR
name|ptr
decl_stmt|;
name|int
name|state
decl_stmt|;
name|u_int64_t
name|uniqueid
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|P_thread_list
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|int
argument_list|,
name|state
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|READ_FIELD
argument_list|(
name|ptr
argument_list|,
name|u_int64_t
argument_list|,
name|uniqueid
argument_list|,
name|uniqueid
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|PS_DEAD_value
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|find_pid
argument_list|(
name|uniqueid
argument_list|)
argument_list|)
condition|)
name|add_thread
argument_list|(
name|find_pid
argument_list|(
name|uniqueid
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|read_pthread_next
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* MUST MATCH enum pthread_state */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|statenames
index|[]
init|=
block|{
literal|"RUNNING"
block|,
literal|"SIGTHREAD"
block|,
literal|"MUTEX_WAIT"
block|,
literal|"COND_WAIT"
block|,
literal|"FDLR_WAIT"
block|,
literal|"FDLW_WAIT"
block|,
literal|"FDR_WAIT"
block|,
literal|"FDW_WAIT"
block|,
literal|"POLL_WAIT"
block|,
literal|"FILE_WAIT"
block|,
literal|"SELECT_WAIT"
block|,
literal|"SLEEP_WAIT"
block|,
literal|"WAIT_WAIT"
block|,
literal|"SIGSUSPEND"
block|,
literal|"SIGWAIT"
block|,
literal|"SPINBLOCK"
block|,
literal|"JOIN"
block|,
literal|"SUSPENDED"
block|,
literal|"DEAD"
block|,
literal|"DEADLOCK"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|freebsd_uthread_get_thread_info
parameter_list|(
name|ref
parameter_list|,
name|selection
parameter_list|,
name|info
parameter_list|)
name|gdb_threadref
modifier|*
name|ref
decl_stmt|;
name|int
name|selection
decl_stmt|;
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|pid
init|=
operator|*
name|ref
decl_stmt|;
name|struct
name|cached_pthread
modifier|*
name|thread
init|=
name|find_pthread
argument_list|(
name|pid
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|memset
argument_list|(
operator|&
name|info
operator|->
name|threadid
argument_list|,
literal|0
argument_list|,
name|OPAQUETHREADBYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|info
operator|->
name|threadid
argument_list|,
name|ref
argument_list|,
sizeof|sizeof
expr|*
name|ref
argument_list|)
expr_stmt|;
name|info
operator|->
name|active
operator|=
name|thread
operator|->
name|state
operator|==
name|PS_RUNNING_value
expr_stmt|;
name|strcpy
argument_list|(
name|info
operator|->
name|display
argument_list|,
name|statenames
index|[
name|thread
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|name
condition|)
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|thread
operator|->
name|name
argument_list|,
name|info
operator|->
name|shortname
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|info
operator|->
name|shortname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|freebsd_uthread_pid_to_str
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"freebsd-uthreads"
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d, thread %d\0"
argument_list|,
name|THREADID_PID
argument_list|(
name|pid
argument_list|)
argument_list|,
name|THREADID_TID
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d\0"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|init_freebsd_uthread_ops
parameter_list|()
block|{
name|freebsd_uthread_ops
operator|.
name|to_shortname
operator|=
literal|"freebsd-uthreads"
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_longname
operator|=
literal|"FreeBSD uthreads"
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_doc
operator|=
literal|"FreeBSD user threads support."
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_open
operator|=
name|freebsd_uthread_open
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_attach
operator|=
name|freebsd_uthread_attach
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_post_attach
operator|=
name|freebsd_uthread_post_attach
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_detach
operator|=
name|freebsd_uthread_detach
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_resume
operator|=
name|freebsd_uthread_resume
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_wait
operator|=
name|freebsd_uthread_wait
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_fetch_registers
operator|=
name|freebsd_uthread_fetch_registers
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_store_registers
operator|=
name|freebsd_uthread_store_registers
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_prepare_to_store
operator|=
name|freebsd_uthread_prepare_to_store
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_xfer_memory
operator|=
name|freebsd_uthread_xfer_memory
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_files_info
operator|=
name|freebsd_uthread_files_info
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_kill
operator|=
name|freebsd_uthread_kill_inferior
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_create_inferior
operator|=
name|freebsd_uthread_create_inferior
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_exited
operator|=
name|freebsd_uthread_has_exited
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_mourn_inferior
operator|=
name|freebsd_uthread_mourn_inferior
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_can_run
operator|=
name|freebsd_uthread_can_run
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_notice_signals
operator|=
name|freebsd_uthread_notice_signals
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_thread_alive
operator|=
name|freebsd_uthread_thread_alive
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_stop
operator|=
name|freebsd_uthread_stop
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_has_thread_control
operator|=
literal|0
expr_stmt|;
name|freebsd_uthread_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
name|freebsd_uthread_vec
operator|.
name|find_new_threads
operator|=
name|freebsd_uthread_find_new_threads
expr_stmt|;
name|freebsd_uthread_vec
operator|.
name|get_thread_info
operator|=
name|freebsd_uthread_get_thread_info
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_freebsd_uthread
parameter_list|()
block|{
name|init_freebsd_uthread_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|freebsd_uthread_ops
argument_list|)
expr_stmt|;
name|child_suppress_run
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

