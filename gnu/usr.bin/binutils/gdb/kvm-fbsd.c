begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Live and postmortem kernel debugging functions for FreeBSD.    Copyright 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|kcore_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kcore_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_kcore_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kcore_xfer_kmem
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xfer_umem
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|ksym_lookup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_pcb
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|curProc
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_proc_context
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|paddr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kcore_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|filename
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kcore_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_proc_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kvtophys
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|physrd
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|u_int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvm_open
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|efile
operator|,
name|char
operator|*
name|cfile
operator|,
name|char
operator|*
name|sfile
operator|,
name|int
name|perm
operator|,
name|char
operator|*
name|errout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvm_close
name|PARAMS
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvm_write
name|PARAMS
argument_list|(
operator|(
name|int
name|core_kd
operator|,
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvm_read
name|PARAMS
argument_list|(
operator|(
name|int
name|core_kd
operator|,
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvm_uread
name|PARAMS
argument_list|(
operator|(
name|int
name|core_kd
operator|,
expr|struct
name|proc
operator|*
name|p
operator|,
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kernel_core_file_hook
name|PARAMS
argument_list|(
operator|(
name|int
name|fd
operator|,
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|kvm_getprocs
name|PARAMS
argument_list|(
operator|(
name|int
name|cfd
operator|,
name|int
name|op
operator|,
name|CORE_ADDR
name|proc
operator|,
name|int
operator|*
name|cnt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|kcore_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_comment
comment|/* Non-zero means we are debugging a kernel core file */
end_comment

begin_decl_stmt
name|int
name|kernel_debugging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kernel_writablecore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|core_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|core_kd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kernel_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the "thing" at kernel address 'addr' into the space pointed to  * by point.  The length of the "thing" is determined by the type of p.  * Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|kvread
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory ((CORE_ADDR)(addr), (char *)(p), sizeof(*(p))))
end_define

begin_comment
comment|/*  * The following is FreeBSD-specific hackery to decode special frames  * and elide the assembly-language stub.  This could be made faster by  * defining a frame_type field in the machine-dependent frame information,  * but we don't think that's too important right now.  */
end_comment

begin_enum
enum|enum
name|frametype
block|{
name|tf_normal
block|,
name|tf_trap
block|,
name|tf_interrupt
block|,
name|tf_syscall
block|}
enum|;
end_enum

begin_function
name|CORE_ADDR
name|fbsd_kern_frame_saved_pc
parameter_list|(
name|fr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fr
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|this_saved_pc
decl_stmt|;
name|enum
name|frametype
name|frametype
decl_stmt|;
name|this_saved_pc
operator|=
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|this_saved_pc
argument_list|)
expr_stmt|;
name|frametype
operator|=
name|tf_normal
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"calltrap"
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_trap
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"Xresume"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_interrupt
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"Xsyscall"
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_syscall
expr_stmt|;
block|}
switch|switch
condition|(
name|frametype
condition|)
block|{
case|case
name|tf_normal
case|:
return|return
operator|(
name|this_saved_pc
operator|)
return|;
define|#
directive|define
name|oEIP
value|offsetof(struct trapframe, tf_eip)
case|case
name|tf_trap
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_interrupt
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|16
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_syscall
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
undef|#
directive|undef
name|oEIP
block|}
block|}
end_function

begin_function
name|CORE_ADDR
name|fbsd_kern_frame_chain
parameter_list|(
name|fr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fr
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|this_saved_pc
decl_stmt|;
name|enum
name|frametype
name|frametype
decl_stmt|;
name|this_saved_pc
operator|=
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|this_saved_pc
argument_list|)
expr_stmt|;
name|frametype
operator|=
name|tf_normal
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"calltrap"
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_trap
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"Xresume"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_interrupt
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_Xsyscall"
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_syscall
expr_stmt|;
block|}
switch|switch
condition|(
name|frametype
condition|)
block|{
case|case
name|tf_normal
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
operator|)
return|;
define|#
directive|define
name|oEBP
value|offsetof(struct trapframe, tf_ebp)
case|case
name|tf_trap
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEBP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_interrupt
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|16
operator|+
name|oEBP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_syscall
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEBP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
undef|#
directive|undef
name|oEBP
block|}
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|proc
modifier|*
name|curProc
parameter_list|()
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|ksym_lookup
argument_list|(
literal|"curproc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Set the process context to that of the proc structure at  * system address paddr.  */
end_comment

begin_function
specifier|static
name|int
name|set_proc_context
parameter_list|(
name|paddr
parameter_list|)
name|CORE_ADDR
name|paddr
decl_stmt|;
block|{
name|struct
name|proc
name|p
decl_stmt|;
if|if
condition|(
name|paddr
operator|<
name|kernel_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cur_proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|paddr
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|set_kernel_boundaries
argument_list|(
name|cur_proc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fetch all registers from core file */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file    and mark data and stack spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kcore_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* Avoid confusion from thread stuff */
if|if
condition|(
name|core_kd
condition|)
block|{
name|kvm_close
argument_list|(
name|core_kd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_file
argument_list|)
expr_stmt|;
name|core_file
operator|=
name|NULL
expr_stmt|;
name|core_kd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd */
end_comment

begin_function
specifier|static
name|void
name|kcore_open
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|pcb
name|pcb
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
comment|/*error (core_kd?*/
name|error
argument_list|(
operator|(
name|core_kd
operator|>=
literal|0
operator|)
condition|?
literal|"No core file specified.  (Use `detach' to stop debugging a core file.)"
else|:
literal|"No core file specified."
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|cp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/*    * gdb doesn't really do anything if the exec-file couldn't    * be opened (in that case exec_bfd is NULL). Usually that's    * no big deal, but kvm_open needs the exec-file's name,    * which results in dereferencing a NULL pointer, a real NO-NO !    * So, check here if the open of the exec-file succeeded.    */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
comment|/* the open failed */
name|error
argument_list|(
literal|"kgdb could not open the exec-file, please check the name you used !"
argument_list|)
expr_stmt|;
name|core_kd
operator|=
name|kvm_open
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|kernel_writablecore
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|"kgdb: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Looks semi-reasonable. Toss the old core file and work on the new. */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more */
name|core_file
operator|=
name|filename
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|kernel_start
operator|=
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* print out the panic string if there is one */
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|addr
operator|!=
literal|0
operator|&&
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ontop
condition|)
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n\ your %s; do ``info files''"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we may need this later */
name|cur_proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|curProc
argument_list|()
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No kernel core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|user
modifier|*
name|uaddr
decl_stmt|;
comment|/* find the pcb for the current process */
if|if
condition|(
name|kvread
argument_list|(
operator|&
name|cur_proc
operator|->
name|p_addr
argument_list|,
operator|&
name|uaddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read u area ptr for proc at %#x"
argument_list|,
name|cur_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_pcb
argument_list|(
name|core_kd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %#x"
argument_list|,
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\t`%s'\n"
argument_list|,
name|core_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kcore_xfer_kmem
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|memaddr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|memaddr
operator|<
name|kernel_start
condition|)
return|return
name|xfer_umem
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
return|;
name|n
operator|=
name|write
condition|?
name|kvm_write
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
else|:
name|kvm_read
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_umem
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|n
decl_stmt|;
name|struct
name|proc
name|proc
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|cur_proc
argument_list|,
operator|&
name|proc
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc at %#x"
argument_list|,
name|cur_proc
argument_list|)
expr_stmt|;
name|n
operator|=
name|kvm_uread
argument_list|(
name|core_kd
argument_list|,
operator|&
name|proc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_proc_cmd
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|paddr
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|kp
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"proc address for new current process"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"not debugging kernel"
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* assume it's a proc pointer if it's in the kernel */
if|if
condition|(
name|paddr
operator|>=
name|kernel_start
condition|)
block|{
if|if
condition|(
name|set_proc_context
argument_list|(
name|paddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kp
operator|=
name|kvm_getprocs
argument_list|(
name|core_kd
argument_list|,
name|KERN_PROC_PID
argument_list|,
name|paddr
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
name|error
argument_list|(
literal|"invalid pid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_proc_context
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|kp
operator|->
name|kp_eproc
operator|.
name|e_paddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|KERNOFF
value|((unsigned)KERNBASE)
end_define

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF)
end_define

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|curpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|found_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|i386tss
name|cts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* substitutes for the stuff in libkvm which doesn't work */
end_comment

begin_comment
comment|/* most of this was taken from the old kgdb */
end_comment

begin_comment
comment|/* we don't need all this stuff, but the call should look the same */
end_comment

begin_function
specifier|static
name|int
name|kvm_open
parameter_list|(
name|efile
parameter_list|,
name|cfile
parameter_list|,
name|sfile
parameter_list|,
name|perm
parameter_list|,
name|errout
parameter_list|)
specifier|const
name|char
modifier|*
name|efile
decl_stmt|;
name|char
modifier|*
name|cfile
decl_stmt|;
name|char
modifier|*
name|sfile
decl_stmt|;
comment|/* makes this kvm_open more compatible to the one in libkvm */
name|int
name|perm
decl_stmt|;
name|char
modifier|*
name|errout
decl_stmt|;
comment|/* makes this kvm_open more compatible to the one in libkvm */
block|{
name|struct
name|stat
name|stb
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|cfd
decl_stmt|;
if|if
condition|(
operator|(
name|cfd
operator|=
name|open
argument_list|(
name|cfile
argument_list|,
name|perm
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|cfd
operator|)
return|;
name|fstat
argument_list|(
name|cfd
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|stb
operator|.
name|st_rdev
operator|==
name|makedev
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|devmem
operator|=
literal|1
expr_stmt|;
name|kfd
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
name|perm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|physrd
argument_list|(
name|cfd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"IdlePTD"
argument_list|)
operator|-
name|KERNOFF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sbr
argument_list|,
sizeof|sizeof
name|sbr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IdlePTD %x\n"
argument_list|,
name|sbr
argument_list|)
expr_stmt|;
name|curpcb
operator|=
name|ksym_lookup
argument_list|(
literal|"curpcb"
argument_list|)
operator|-
name|KERNOFF
expr_stmt|;
name|physrd
argument_list|(
name|cfd
argument_list|,
name|curpcb
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|curpcb
argument_list|,
sizeof|sizeof
name|curpcb
argument_list|)
expr_stmt|;
name|physrd
argument_list|(
name|cfd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"common_tss"
argument_list|)
operator|-
name|KERNOFF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cts
argument_list|,
sizeof|sizeof
name|cts
argument_list|)
expr_stmt|;
name|kstack
operator|=
name|cts
operator|.
name|tss_ksp
expr_stmt|;
name|found_pcb
operator|=
literal|1
expr_stmt|;
comment|/* for vtophys */
if|if
condition|(
operator|!
name|devmem
condition|)
name|read_pcb
argument_list|(
name|cfd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"dumppcb"
argument_list|)
operator|-
name|KERNOFF
argument_list|)
expr_stmt|;
else|else
name|read_pcb
argument_list|(
name|cfd
argument_list|,
name|kvtophys
argument_list|(
name|cfd
argument_list|,
name|kstack
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kvm_close
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
return|return
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kvm_write
parameter_list|(
name|core_kd
parameter_list|,
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|core_kd
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|devmem
condition|)
block|{
if|if
condition|(
name|kfd
operator|>
literal|0
condition|)
block|{
comment|/* 	   * Just like kvm_read, only we write. 	   */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|kfd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"kvm_write:invalid address (%x)"
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cc
operator|=
name|write
argument_list|(
name|kfd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"kvm_write:write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|<
name|len
condition|)
name|error
argument_list|(
literal|"kvm_write:short write"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"kvm_write not implemented for dead kernels\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|int
name|kvm_read
parameter_list|(
name|core_kd
parameter_list|,
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|core_kd
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
return|return
operator|(
name|kernel_core_file_hook
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kvm_uread
parameter_list|(
name|core_kd
parameter_list|,
name|p
parameter_list|,
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|core_kd
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|procfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|ssize_t
name|amount
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|devmem
condition|)
block|{
name|cp
operator|=
name|myaddr
expr_stmt|;
name|sprintf
argument_list|(
name|procfile
argument_list|,
literal|"/proc/%d/mem"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|procfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot open %s"
argument_list|,
name|procfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid address (%x) in %s"
argument_list|,
name|memaddr
argument_list|,
name|procfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|amount
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"error reading %s"
argument_list|,
name|procfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|amount
expr_stmt|;
name|memaddr
operator|+=
name|amount
expr_stmt|;
name|len
operator|-=
name|amount
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
call|(
name|ssize_t
call|)
argument_list|(
name|cp
operator|-
name|myaddr
argument_list|)
return|;
block|}
else|else
return|return
operator|(
name|kernel_core_file_hook
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
name|kp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * try to do what kvm_proclist in libkvm would do  */
end_comment

begin_function
specifier|static
name|int
name|kvm_proclist
parameter_list|(
name|cfd
parameter_list|,
name|pid
parameter_list|,
name|p
parameter_list|,
name|cnt
parameter_list|)
name|int
name|cfd
decl_stmt|,
name|pid
decl_stmt|,
decl|*
name|cnt
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
name|lp
decl_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|lp
operator|.
name|p_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
operator|!
name|kvm_read
argument_list|(
name|cfd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lp
operator|.
name|p_pid
operator|!=
name|pid
condition|)
continue|continue;
name|kp
operator|.
name|kp_eproc
operator|.
name|e_paddr
operator|=
name|p
expr_stmt|;
operator|*
name|cnt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|cnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * try to do what kvm_deadprocs in libkvm would do  */
end_comment

begin_function
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|kvm_deadprocs
parameter_list|(
name|cfd
parameter_list|,
name|pid
parameter_list|,
name|cnt
parameter_list|)
name|int
name|cfd
decl_stmt|,
name|pid
decl_stmt|,
decl|*
name|cnt
decl_stmt|;
end_function

begin_block
block|{
name|CORE_ADDR
name|allproc
decl_stmt|,
name|zombproc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|allproc
operator|=
name|ksym_lookup
argument_list|(
literal|"allproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|cfd
argument_list|,
name|allproc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|kvm_proclist
argument_list|(
name|cfd
argument_list|,
name|pid
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cnt
condition|)
block|{
name|zombproc
operator|=
name|ksym_lookup
argument_list|(
literal|"zombproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|cfd
argument_list|,
name|zombproc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|kvm_proclist
argument_list|(
name|cfd
argument_list|,
name|pid
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|kp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * try to do what kvm_getprocs in libkvm would do  */
end_comment

begin_function
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|kvm_getprocs
parameter_list|(
name|cfd
parameter_list|,
name|op
parameter_list|,
name|proc
parameter_list|,
name|cnt
parameter_list|)
name|int
name|cfd
decl_stmt|,
name|op
decl_stmt|,
decl|*
name|cnt
decl_stmt|;
end_function

begin_decl_stmt
name|CORE_ADDR
name|proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mib
index|[
literal|4
index|]
decl_stmt|,
name|size
decl_stmt|;
operator|*
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* assume it's a pid */
if|if
condition|(
name|devmem
condition|)
block|{
comment|/* "live" kernel, use sysctl */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
name|KERN_PROC_PID
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
operator|(
name|int
operator|)
name|proc
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|kp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
operator|&
name|kp
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"sysctl"
argument_list|)
expr_stmt|;
operator|*
name|cnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
operator|*
name|cnt
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|cnt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|&
name|kp
operator|)
return|;
block|}
else|else
return|return
operator|(
name|kvm_deadprocs
argument_list|(
name|cfd
argument_list|,
operator|(
name|int
operator|)
name|proc
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|physrd
parameter_list|(
name|cfd
parameter_list|,
name|addr
parameter_list|,
name|dat
parameter_list|,
name|len
parameter_list|)
name|int
name|cfd
decl_stmt|;
name|u_int
name|addr
decl_stmt|;
name|char
modifier|*
name|dat
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|lseek
argument_list|(
name|cfd
argument_list|,
operator|(
name|off_t
operator|)
name|addr
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|read
argument_list|(
name|cfd
argument_list|,
name|dat
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|kvtophys
parameter_list|(
name|fd
parameter_list|,
name|addr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|CORE_ADDR
name|v
decl_stmt|;
name|unsigned
name|int
name|pte
decl_stmt|;
specifier|static
name|CORE_ADDR
name|PTD
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|current_ptd
decl_stmt|;
comment|/*    * If we're looking at the kernel stack,    * munge the address to refer to the user space mapping instead;    * that way we get the requested process's kstack, not the running one.    */
comment|/*     * this breaks xlating user addresses from a crash dump so only     * do it for a "live" kernel.     */
if|if
condition|(
name|devmem
operator|&&
name|addr
operator|>=
name|kstack
operator|&&
name|addr
operator|<
name|kstack
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|addr
operator|-
name|kstack
operator|)
operator|+
name|curpcb
expr_stmt|;
comment|/*    * We may no longer have a linear system page table...    *    * Here's the scoop.  IdlePTD contains the physical address    * of a page table directory that always maps the kernel.    * IdlePTD is in memory that is mapped 1-to-1, so we can    * find it easily given its 'virtual' address from ksym_lookup().    * For hysterical reasons, the value of IdlePTD is stored in sbr.    *    * To look up a kernel address, we first convert it to a 1st-level    * address and look it up in IdlePTD.  This gives us the physical    * address of a page table page; we extract the 2nd-level part of    * VA and read the 2nd-level pte.  Finally, we add the offset part    * of the VA into the physical address from the pte and return it.    *    * User addresses are a little more complicated.  If we don't have    * a current PCB from read_pcb(), we use PTD, which is the (fixed)    * virtual address of the current ptd.  Since it's NOT in 1-to-1    * kernel space, we must look it up using IdlePTD.  If we do have    * a pcb, we get the ptd from pcb_ptd.    */
if|if
condition|(
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
name|current_ptd
operator|=
name|sbr
expr_stmt|;
elseif|else
if|if
condition|(
name|found_pcb
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PTD
operator|==
operator|-
literal|1
condition|)
name|PTD
operator|=
name|kvtophys
argument_list|(
name|fd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"PTD"
argument_list|)
argument_list|)
expr_stmt|;
name|current_ptd
operator|=
name|PTD
expr_stmt|;
block|}
else|else
name|current_ptd
operator|=
name|pcb
operator|.
name|pcb_cr3
expr_stmt|;
comment|/*    * Read the first-level page table (ptd).    */
name|v
operator|=
name|current_ptd
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|addr
operator|>>
name|PDRSHIFT
operator|)
operator|*
sizeof|sizeof
name|pte
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|fd
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
name|pte
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|pte
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
comment|/*    * Read the second-level page table.    */
name|v
operator|=
operator|(
name|pte
operator|&
name|PG_FRAME
operator|)
operator|+
operator|(
operator|(
name|addr
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
name|pte
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|fd
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|pte
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
name|addr
operator|=
operator|(
name|pte
operator|&
name|PG_FRAME
operator|)
operator|+
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("vtophys (%x) -> %x\n", oldaddr, addr);
endif|#
directive|endif
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_pcb
parameter_list|(
name|fd
parameter_list|,
name|uaddr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|CORE_ADDR
name|uaddr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|pcb_regs
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
decl_stmt|;
name|int
modifier|*
name|cts_regs
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|cts
decl_stmt|;
name|int
name|eip
decl_stmt|;
name|CORE_ADDR
name|nuaddr
init|=
name|uaddr
decl_stmt|;
comment|/* need this for the `proc' command to work */
if|if
condition|(
name|INKERNEL
argument_list|(
name|uaddr
argument_list|)
condition|)
name|nuaddr
operator|=
name|kvtophys
argument_list|(
name|fd
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|fd
argument_list|,
name|nuaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
name|pcb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot read pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"current pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
comment|/*    * get the register values out of the sys pcb and    * store them where `read_register' will find them.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cts_regs
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
comment|/* eax, ecx, edx */
comment|/* get registers from the pcb */
name|supply_register
argument_list|(
literal|3
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb_regs
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* ebx */
name|supply_register
argument_list|(
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb_regs
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* esp */
name|supply_register
argument_list|(
literal|5
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb_regs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* ebp */
name|supply_register
argument_list|(
literal|6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb_regs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* esi */
name|supply_register
argument_list|(
literal|7
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb_regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* edi */
name|supply_register
argument_list|(
literal|8
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb_regs
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* eip */
name|supply_register
argument_list|(
literal|9
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cts_regs
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* eflags */
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
operator|<
literal|13
condition|;
operator|++
name|i
control|)
comment|/* cs, ss, ds */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cts_regs
index|[
name|i
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|13
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cts_regs
index|[
literal|18
index|]
argument_list|)
expr_stmt|;
comment|/* es */
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
comment|/* fs, gs */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cts_regs
index|[
name|i
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* doesn't work ??? */
comment|/* Hmm... */
block|if (target_read_memory (pcb_regs[5+10]+4,&eip, sizeof eip, 0))     error ("Cannot read PC.");   supply_register (8, (char *)&eip);
comment|/* eip */
endif|#
directive|endif
comment|/* XXX 80387 registers? */
block|}
end_function

begin_comment
comment|/*  * read len bytes from kernel virtual address 'addr' into local  * buffer 'buf'.  Return numbert of bytes if read ok, 0 otherwise.  On read  * errors, portion of buffer not read is zeroed.  */
end_comment

begin_function
specifier|static
name|int
name|kernel_core_file_hook
parameter_list|(
name|fd
parameter_list|,
name|addr
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|paddr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|paddr
operator|=
name|kvtophys
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
operator|~
literal|0
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\000'
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* we can't read across a page boundary */
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|PAGE_SIZE
operator|-
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|physrd
argument_list|(
name|fd
argument_list|,
name|paddr
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|memset
argument_list|(
name|cp
argument_list|,
literal|'\000'
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
name|cp
operator|+=
name|cc
expr_stmt|;
name|addr
operator|+=
name|cc
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|kcore_ops
init|=
block|{
literal|"kcore"
block|,
comment|/* to_shortname */
literal|"Kernel core dump file"
block|,
comment|/* to_longname */
literal|"Use a core file as a target.  Specify the filename of the core file."
block|,
comment|/* to_doc */
name|kcore_open
block|,
comment|/* to_open */
name|kcore_close
block|,
comment|/* to_close */
name|find_default_attach
block|,
comment|/* to_attach */
name|kcore_detach
block|,
comment|/* to_detach */
name|NULL
block|,
comment|/* to_resume */
name|NULL
block|,
comment|/* to_wait */
name|get_kcore_registers
block|,
comment|/* to_fetch_registers */
name|NULL
block|,
comment|/* to_store_registers */
name|NULL
block|,
comment|/* to_prepare_to_store */
name|kcore_xfer_kmem
block|,
comment|/* to_xfer_memory */
name|kcore_files_info
block|,
comment|/* to_files_info */
name|NULL
block|,
comment|/* to_insert_breakpoint */
name|NULL
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|NULL
block|,
comment|/* to_kill */
name|NULL
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|find_default_create_inferior
block|,
comment|/* to_create_inferior */
name|NULL
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
name|NULL
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|kcore_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|0
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|0
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_kcorelow
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc"
argument_list|,
name|class_obscure
argument_list|,
name|set_proc_cmd
argument_list|,
literal|"Set current process context"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

