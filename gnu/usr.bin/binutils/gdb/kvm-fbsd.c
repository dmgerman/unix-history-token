begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Kernel core dump functions below target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This works like "remote" but, you use it like this:  *     target kcore /dev/mem  * or  *     target kcore /var/crash/host/core.0  *  * This way makes it easy to short-circut the whole bfd monster,  * and direct the inferior stuff to our libkvm implementation.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<readline/tilde.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_include
include|#
directive|include
file|"kvm-fbsd-machine.h"
end_include

begin_function_decl
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kcore_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfer_umem
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function_decl
specifier|static
name|int
name|kcore_solib_add_stub
parameter_list|(
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|core_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|core_kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|cur_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|kcore_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kernel_writablecore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the "thing" at kernel address 'addr' into the space pointed to    by point.  The length of the "thing" is determined by the type of p.    Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|kvread
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory ((CORE_ADDR) (addr), (char *) (p), sizeof (*(p))))
end_define

begin_function
specifier|static
name|CORE_ADDR
name|ksym_kernbase
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|kernbase
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|kernbase
operator|==
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"kernbase"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|kernbase
operator|=
name|KERNBASE
expr_stmt|;
block|}
else|else
block|{
name|kernbase
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|kernbase
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KERNOFF
value|(ksym_kernbase ())
end_define

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF)
end_define

begin_function
specifier|static
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Provide the address of an initial PCB to use.    If this is a crash dump, try for "dumppcb".    If no "dumppcb" or it's /dev/mem, use proc0.    Return the core address of the PCB we found.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|initial_pcb
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
comment|/* Make sure things are open...  */
if|if
condition|(
operator|!
name|core_kd
operator|||
operator|!
name|core_file
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If this is NOT /dev/mem try for dumppcb.  */
if|if
condition|(
name|strncmp
argument_list|(
name|core_file
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"dumppcb"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
comment|/* OK, just use thread0's pcb.  Note that curproc might      not exist, and if it does, it will point to gdb.      Therefore, just use proc0 and let the user set      some other context if they care about it.  */
name|addr
operator|=
name|ksym_lookup
argument_list|(
literal|"thread0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot read thread0 pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the PCB address in thread structure.  */
name|addr
operator|+=
name|offsetof
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot read thread0->td_pcb pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* thread0 is wholly in the kernel and cur_proc is only used for      reading user mem, so no point in setting this up.  */
name|cur_proc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|CORE_ADDR
operator|)
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the current context to that of the PCB struct at the system address    passed.  */
end_comment

begin_function
specifier|static
name|int
name|set_context
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|cur_pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %#x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Fetch all registers from core file.  */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack.  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file and mark data and stack    spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kcore_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* Avoid confusion from thread stuff.  */
comment|/* Clear out solib state while the bfd is still open. See      comments in clear_solib in solib.c. */
ifdef|#
directive|ifdef
name|CLEAR_SOLIB
name|CLEAR_SOLIB
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|core_kd
condition|)
block|{
name|kvm_close
argument_list|(
name|core_kd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_file
argument_list|)
expr_stmt|;
name|core_file
operator|=
name|NULL
expr_stmt|;
name|core_kd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd.  */
end_comment

begin_function
specifier|static
name|void
name|kcore_open
parameter_list|(
name|char
modifier|*
name|filename
comment|/* the core file */
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|kvm_t
modifier|*
name|kd
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* The exec file is required for symbols.  */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No kernel exec file specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
condition|)
block|{
name|error
argument_list|(
literal|"No core file specified."
literal|"  (Use `detach' to stop debugging a core file.)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|error
argument_list|(
literal|"No core file specified."
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|cp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|kd
operator|=
name|kvm_open
argument_list|(
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|kernel_writablecore
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Looks semi-reasonable.  Toss the old core file and work on the new.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more.  */
name|core_file
operator|=
name|filename
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
comment|/* Note unpush_target (above) calls kcore_close.  */
name|core_kd
operator|=
name|kd
expr_stmt|;
comment|/* Print out the panic string if there is one.  */
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|addr
operator|!=
literal|0
operator|&&
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf_filtered
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Print all the panic messages if possible.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"panic messages:\n---\n"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"/sbin/dmesg -N %s -M %s | \                  /usr/bin/awk '/^(panic:|Fatal trap) / { printing = 1 } \                                { if (printing) print $0 }'"
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"---\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ontop
condition|)
block|{
comment|/* Add symbols and section mappings for any kernel modules.  */
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|current_target_so_ops
operator|=
operator|&
name|kgdb_so_ops
expr_stmt|;
name|catch_errors
argument_list|(
name|kcore_solib_add_stub
argument_list|,
operator|&
name|from_tty
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n"
literal|"your %s; do ``info files''"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, set up process context, and print the top of stack.  */
operator|(
name|void
operator|)
name|set_context
argument_list|(
name|initial_pcb
argument_list|()
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No kernel core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* XXX - Only read the pcb when set_context() is called.      When looking at a live kernel this may be a problem,      but the user can do another "proc" or "pcb" command to      grab a new copy of the pcb...  */
comment|/* Zero out register set then fill in the ones we know about.  */
name|fetch_kcore_registers
argument_list|(
operator|&
name|cur_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"\t`%s'\n"
argument_list|,
name|core_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|xfer_kmem
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|INKERNEL
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
name|xfer_umem
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
return|;
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|write
condition|)
name|n
operator|=
name|kvm_write
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|kvm_read
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"can not access 0x%x, %s\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|memaddr
argument_list|,
name|kvm_geterr
argument_list|(
name|core_kd
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_umem
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
comment|/* ignored */
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cur_proc
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"---Can't read userspace from dump, or kernel process---\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|write
condition|)
name|error
argument_list|(
literal|"kvm_uwrite unimplemented\n"
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|kvm_uread
argument_list|(
name|core_kd
argument_list|,
name|cur_proc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_proc_cmd
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|,
name|pid_addr
decl_stmt|,
name|first_td
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|kp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"proc address for the new context"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no kernel core file"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|kp
operator|=
name|kvm_getprocs
argument_list|(
name|core_kd
argument_list|,
name|KERN_PROC_PID
argument_list|,
name|addr
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
name|error
argument_list|(
literal|"invalid pid"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|kp
operator|->
name|ki_paddr
expr_stmt|;
name|cur_proc
operator|=
name|kp
expr_stmt|;
block|}
else|else
block|{
comment|/* Update cur_proc.  */
name|pid_addr
operator|=
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|proc
argument_list|,
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|pid_addr
argument_list|,
operator|&
name|pid
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pid ptr"
argument_list|)
expr_stmt|;
name|cur_proc
operator|=
name|kvm_getprocs
argument_list|(
name|core_kd
argument_list|,
name|KERN_PROC_PID
argument_list|,
name|pid
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
name|error
argument_list|(
literal|"invalid pid"
argument_list|)
expr_stmt|;
block|}
comment|/* Find the first thread in the process.  XXXKSE  */
name|addr
operator|+=
name|offsetof
argument_list|(
expr|struct
name|proc
argument_list|,
name|p_threads
operator|.
name|tqh_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|first_td
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read thread ptr"
argument_list|)
expr_stmt|;
comment|/* Read the PCB address in thread structure. */
name|addr
operator|=
name|first_td
operator|+
name|offsetof
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb ptr"
argument_list|)
expr_stmt|;
comment|/* Read the PCB address in proc structure. */
if|if
condition|(
name|set_context
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function
specifier|static
name|int
name|kcore_solib_add_stub
parameter_list|(
name|PTR
name|from_ttyp
parameter_list|)
block|{
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|from_ttyp
argument_list|,
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_ADD */
end_comment

begin_function
name|void
name|_initialize_kcorelow
parameter_list|(
name|void
parameter_list|)
block|{
name|kcore_ops
operator|.
name|to_shortname
operator|=
literal|"kcore"
expr_stmt|;
name|kcore_ops
operator|.
name|to_longname
operator|=
literal|"Kernel core dump file"
expr_stmt|;
name|kcore_ops
operator|.
name|to_doc
operator|=
literal|"Use a core file as a target.  Specify the filename of the core file."
expr_stmt|;
name|kcore_ops
operator|.
name|to_open
operator|=
name|kcore_open
expr_stmt|;
name|kcore_ops
operator|.
name|to_close
operator|=
name|kcore_close
expr_stmt|;
name|kcore_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|kcore_ops
operator|.
name|to_detach
operator|=
name|kcore_detach
expr_stmt|;
name|kcore_ops
operator|.
name|to_fetch_registers
operator|=
name|get_kcore_registers
expr_stmt|;
name|kcore_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_kmem
expr_stmt|;
name|kcore_ops
operator|.
name|to_files_info
operator|=
name|kcore_files_info
expr_stmt|;
name|kcore_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|kcore_ops
operator|.
name|to_stratum
operator|=
name|kcore_stratum
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc"
argument_list|,
name|class_obscure
argument_list|,
name|set_proc_cmd
argument_list|,
literal|"Set current process context"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

