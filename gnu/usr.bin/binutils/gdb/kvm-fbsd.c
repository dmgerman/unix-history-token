begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Kernel core dump functions below target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * This works like "remote" but, you use it like this:  *     target kcore /dev/mem  * or  *     target kcore /var/crash/host/core.0  *  * This way makes it easy to short-circut the whole bfd monster,  * and direct the inferior stuff to our libkvm implementation.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<readline/tilde.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_function_decl
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kcore_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfer_mem
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|mem_attrib
modifier|*
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfer_umem
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function_decl
specifier|static
name|int
name|kcore_solib_add_stub
parameter_list|(
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|core_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|core_kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|cur_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|kcore_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kernel_writablecore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the "thing" at kernel address 'addr' into the space pointed to    by point.  The length of the "thing" is determined by the type of p.    Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|kvread
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory ((CORE_ADDR) (addr), (char *) (p), sizeof (*(p))))
end_define

begin_function
specifier|static
name|CORE_ADDR
name|ksym_kernbase
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|kernbase
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|kernbase
operator|==
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"kernbase"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|kernbase
operator|=
name|KERNBASE
expr_stmt|;
block|}
else|else
block|{
name|kernbase
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|kernbase
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KERNOFF
value|(ksym_kernbase ())
end_define

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF)
end_define

begin_function
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Provide the address of an initial PCB to use.    If this is a crash dump, try for "dumppcb".    If no "dumppcb" or it's /dev/mem, use proc0.    Return the core address of the PCB we found.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|initial_pcb
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
comment|/* Make sure things are open...  */
if|if
condition|(
operator|!
name|core_kd
operator|||
operator|!
name|core_file
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If this is NOT /dev/mem try for dumppcb.  */
if|if
condition|(
name|strncmp
argument_list|(
name|core_file
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"dumppcb"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
comment|/* OK, just use thread0's pcb.  Note that curproc might      not exist, and if it does, it will point to gdb.      Therefore, just use proc0 and let the user set      some other context if they care about it.  */
name|addr
operator|=
name|ksym_lookup
argument_list|(
literal|"thread0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot read thread0 pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the PCB address in thread structure.  */
name|addr
operator|+=
name|offsetof
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot read thread0->td_pcb pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* thread0 is wholly in the kernel and cur_proc is only used for      reading user mem, so no point in setting this up.  */
name|cur_proc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|CORE_ADDR
operator|)
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the current context to that of the PCB struct at the system address    passed.  */
end_comment

begin_function
specifier|static
name|int
name|set_context
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|CORE_ADDR
name|procaddr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|cur_pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %#x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Fetch all registers from core file.  */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack.  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file and mark data and stack    spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kcore_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* Avoid confusion from thread stuff.  */
comment|/* Clear out solib state while the bfd is still open. See      comments in clear_solib in solib.c. */
ifdef|#
directive|ifdef
name|CLEAR_SOLIB
name|CLEAR_SOLIB
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|core_kd
condition|)
block|{
name|kvm_close
argument_list|(
name|core_kd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_file
argument_list|)
expr_stmt|;
name|core_file
operator|=
name|NULL
expr_stmt|;
name|core_kd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd.  */
end_comment

begin_function
specifier|static
name|void
name|kcore_open
parameter_list|(
name|char
modifier|*
name|filename
comment|/* the core file */
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|kvm_t
modifier|*
name|kd
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* The exec file is required for symbols.  */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No kernel exec file specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
condition|)
block|{
name|error
argument_list|(
literal|"No core file specified."
literal|"  (Use `detach' to stop debugging a core file.)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|error
argument_list|(
literal|"No core file specified."
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|cp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|kd
operator|=
name|kvm_open
argument_list|(
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|kernel_writablecore
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Looks semi-reasonable.  Toss the old core file and work on the new.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more.  */
name|core_file
operator|=
name|filename
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
comment|/* Note unpush_target (above) calls kcore_close.  */
name|core_kd
operator|=
name|kd
expr_stmt|;
comment|/* Print out the panic string if there is one.  */
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|addr
operator|!=
literal|0
operator|&&
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf_filtered
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Print all the panic messages if possible.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"panic messages:\n---\n"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"/sbin/dmesg -N %s -M %s | \                  /usr/bin/awk '/^(panic:|Fatal trap) / { printing = 1 } \                                { if (printing) print $0 }'"
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"---\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ontop
condition|)
block|{
comment|/* Add symbols and section mappings for any kernel modules.  */
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|current_target_so_ops
operator|=
operator|&
name|kgdb_so_ops
expr_stmt|;
name|catch_errors
argument_list|(
name|kcore_solib_add_stub
argument_list|,
operator|&
name|from_tty
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n"
literal|"your %s; do ``info files''"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, set up process context, and print the top of stack.  */
operator|(
name|void
operator|)
name|set_context
argument_list|(
name|initial_pcb
argument_list|()
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No kernel core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_include
include|#
directive|include
file|"alpha/tm-alpha.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S0_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|S0_REGNUM
value|(T7_REGNUM+1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|fetch_kcore_registers
argument_list|(
argument|struct pcb *pcbp
argument_list|)
end_macro

begin_block
block|{
comment|/* First clear out any garbage.  */
name|memset
argument_list|(
name|registers
argument_list|,
literal|'\0'
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* SP */
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SP_REGNUM
argument_list|)
index|]
operator|=
name|pcbp
operator|->
name|pcb_hw
operator|.
name|apcb_ksp
expr_stmt|;
comment|/* S0 through S6 */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|S0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|pcbp
operator|->
name|pcb_context
index|[
literal|0
index|]
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PC */
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
operator|=
name|pcbp
operator|->
name|pcb_context
index|[
literal|7
index|]
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|CORE_ADDR
name|fbsd_kern_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|this_saved_pc
decl_stmt|;
name|this_saved_pc
operator|=
name|alpha_frame_saved_pc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|this_saved_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentArith"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentIF"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentInt"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentMM"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentSys"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentUna"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"XentRestart"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
literal|32
operator|*
literal|8
argument_list|,
literal|8
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|this_saved_pc
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __alpha__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
specifier|static
name|CORE_ADDR
name|ksym_maxuseraddr
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|maxuseraddr
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|maxuseraddr
operator|==
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"PTmap"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|maxuseraddr
operator|=
name|VM_MAXUSER_ADDRESS
expr_stmt|;
block|}
else|else
block|{
name|maxuseraddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxuseraddr
return|;
block|}
end_function

begin_comment
comment|/* Symbol names of kernel entry points.  Use special frames.  */
end_comment

begin_define
define|#
directive|define
name|KSYM_TRAP
value|"calltrap"
end_define

begin_define
define|#
directive|define
name|KSYM_INTR
value|"Xintr"
end_define

begin_define
define|#
directive|define
name|KSYM_FASTINTR
value|"Xfastintr"
end_define

begin_define
define|#
directive|define
name|KSYM_OLDSYSCALL
value|"Xlcall_syscall"
end_define

begin_define
define|#
directive|define
name|KSYM_SYSCALL
value|"Xint0x80_syscall"
end_define

begin_comment
comment|/* The following is FreeBSD-specific hackery to decode special frames    and elide the assembly-language stub.  This could be made faster by    defining a frame_type field in the machine-dependent frame information,    but we don't think that's too important right now.  */
end_comment

begin_enum
enum|enum
name|frametype
block|{
name|tf_normal
block|,
name|tf_trap
block|,
name|tf_interrupt
block|,
name|tf_syscall
block|}
enum|;
end_enum

begin_function
name|CORE_ADDR
name|fbsd_kern_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|this_saved_pc
decl_stmt|;
name|enum
name|frametype
name|frametype
decl_stmt|;
name|this_saved_pc
operator|=
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|this_saved_pc
argument_list|)
expr_stmt|;
name|frametype
operator|=
name|tf_normal
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_TRAP
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_trap
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_INTR
argument_list|,
name|strlen
argument_list|(
name|KSYM_INTR
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_FASTINTR
argument_list|,
name|strlen
argument_list|(
name|KSYM_FASTINTR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_interrupt
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_SYSCALL
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|KSYM_OLDSYSCALL
argument_list|)
operator|==
literal|0
condition|)
name|frametype
operator|=
name|tf_syscall
expr_stmt|;
block|}
switch|switch
condition|(
name|frametype
condition|)
block|{
case|case
name|tf_normal
case|:
return|return
operator|(
name|this_saved_pc
operator|)
return|;
define|#
directive|define
name|oEIP
value|offsetof (struct trapframe, tf_eip)
case|case
name|tf_trap
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_interrupt
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|12
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
case|case
name|tf_syscall
case|:
return|return
operator|(
name|read_memory_integer
argument_list|(
name|fr
operator|->
name|frame
operator|+
literal|8
operator|+
name|oEIP
argument_list|,
literal|4
argument_list|)
operator|)
return|;
undef|#
directive|undef
name|oEIP
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fetch_kcore_registers
parameter_list|(
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|noreg
decl_stmt|;
comment|/* Get the register values out of the sys pcb and store them where      `read_register' will find them.  */
comment|/*    * XXX many registers aren't available.    * XXX for the non-core case, the registers are stale - they are for    *     the last context switch to the debugger.    * XXX gcc's register numbers aren't all #defined in tm-i386.h.    */
name|noreg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
comment|/* eax,ecx,edx */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|noreg
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|3
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_ebx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_esp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_ebp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_esi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|7
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_edi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_eip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|14
condition|;
operator|++
name|i
control|)
comment|/* eflags, cs, ss, ds, es, fs */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|noreg
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|15
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_gs
argument_list|)
expr_stmt|;
comment|/* XXX 80387 registers?  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_define
define|#
directive|define
name|SPARC_INTREG_SIZE
value|8
end_define

begin_function
specifier|static
name|void
name|fetch_kcore_registers
parameter_list|(
name|struct
name|pcb
modifier|*
name|pcbp
parameter_list|)
block|{
specifier|static
name|struct
name|frame
name|top
decl_stmt|;
name|CORE_ADDR
name|f_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the register values out of the sys pcb and store them where      `read_register' will find them.  */
comment|/*    * XXX many registers aren't available.    * XXX for the non-core case, the registers are stale - they are for    *     the last context switch to the debugger.    * XXX do something with the floating-point registers?    */
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcbp
operator|->
name|pcb_fp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcbp
operator|->
name|pcb_pc
argument_list|)
expr_stmt|;
name|f_addr
operator|=
name|extract_address
argument_list|(
operator|&
name|pcbp
operator|->
name|pcb_fp
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
comment|/* Load the previous frame by hand (XXX) and supply it. */
name|read_memory
argument_list|(
name|f_addr
operator|+
name|SPOFF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|top
argument_list|,
sizeof|sizeof
argument_list|(
name|top
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
operator|+
name|L0_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|top
operator|.
name|fr_local
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
operator|+
name|I0_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|top
operator|.
name|fr_in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CORE_ADDR
name|fbsd_kern_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|frame
decl_stmt|,
name|pc_addr
decl_stmt|,
name|pc
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* XXX: duplicates fi->extra_info->bottom. */
name|frame
operator|=
operator|(
name|fi
operator|->
name|next
operator|!=
name|NULL
operator|)
condition|?
name|fi
operator|->
name|next
operator|->
name|frame
else|:
name|read_sp
argument_list|()
expr_stmt|;
name|pc_addr
operator|=
name|frame
operator|+
name|offsetof
argument_list|(
expr|struct
name|frame
argument_list|,
name|fr_in
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
define|#
directive|define
name|READ_PC
parameter_list|(
name|pc
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \   read_memory (a, b, SPARC_INTREG_SIZE); \   pc = extract_address (b, SPARC_INTREG_SIZE); \ } while (0)
name|READ_PC
argument_list|(
name|pc
argument_list|,
name|pc_addr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"tl0_"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"btext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"mp_startup"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"fork_trampoline"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	   * Ugly kluge: user space addresses aren't separated from kernel 	   * ones by range; if encountering a trap from user space, just 	   * return a 0 to stop the trace. 	   * Do the same for entry points of kernel processes to avoid 	   * printing garbage. 	   */
name|pc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"tl1_"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pc_addr
operator|=
name|fi
operator|->
name|frame
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|frame
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|trapframe
argument_list|,
name|tf_tpc
argument_list|)
expr_stmt|;
name|READ_PC
argument_list|(
name|pc
argument_list|,
name|pc_addr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __sparc64__ */
end_comment

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* XXX - Only read the pcb when set_context() is called.      When looking at a live kernel this may be a problem,      but the user can do another "proc" or "pcb" command to      grab a new copy of the pcb...  */
comment|/* Zero out register set then fill in the ones we know about.  */
name|fetch_kcore_registers
argument_list|(
operator|&
name|cur_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"\t`%s'\n"
argument_list|,
name|core_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls breakpoint_init_inferior). */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_kmem
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|INKERNEL
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
name|xfer_umem
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
return|;
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|write
condition|)
name|n
operator|=
name|kvm_write
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|kvm_read
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"can not access 0x%x, %s\n"
argument_list|,
name|memaddr
argument_list|,
name|kvm_geterr
argument_list|(
name|core_kd
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_umem
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
comment|/* ignored */
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cur_proc
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"---Can't read userspace from dump, or kernel process---\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|write
condition|)
name|error
argument_list|(
literal|"kvm_uwrite unimplemented\n"
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|kvm_uread
argument_list|(
name|core_kd
argument_list|,
name|cur_proc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_proc_cmd
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|,
name|pid_addr
decl_stmt|,
name|first_td
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|kp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"proc address for the new context"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no kernel core file"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|kp
operator|=
name|kvm_getprocs
argument_list|(
name|core_kd
argument_list|,
name|KERN_PROC_PID
argument_list|,
name|addr
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
name|error
argument_list|(
literal|"invalid pid"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|kp
operator|->
name|ki_paddr
expr_stmt|;
name|cur_proc
operator|=
name|kp
expr_stmt|;
block|}
else|else
block|{
comment|/* Update cur_proc.  */
name|pid_addr
operator|=
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|proc
argument_list|,
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|pid_addr
argument_list|,
operator|&
name|pid
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pid ptr"
argument_list|)
expr_stmt|;
name|cur_proc
operator|=
name|kvm_getprocs
argument_list|(
name|core_kd
argument_list|,
name|KERN_PROC_PID
argument_list|,
name|pid
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
name|error
argument_list|(
literal|"invalid pid"
argument_list|)
expr_stmt|;
block|}
comment|/* Find the first thread in the process.  XXXKSE  */
name|addr
operator|+=
name|offsetof
argument_list|(
expr|struct
name|proc
argument_list|,
name|p_threads
operator|.
name|tqh_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|first_td
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read thread ptr"
argument_list|)
expr_stmt|;
comment|/* Read the PCB address in thread structure. */
name|addr
operator|=
name|first_td
operator|+
name|offsetof
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb ptr"
argument_list|)
expr_stmt|;
comment|/* Read the PCB address in proc structure. */
if|if
condition|(
name|set_context
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function
specifier|static
name|int
name|kcore_solib_add_stub
parameter_list|(
name|PTR
name|from_ttyp
parameter_list|)
block|{
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|from_ttyp
argument_list|,
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_ADD */
end_comment

begin_function
name|void
name|_initialize_kcorelow
parameter_list|(
name|void
parameter_list|)
block|{
name|kcore_ops
operator|.
name|to_shortname
operator|=
literal|"kcore"
expr_stmt|;
name|kcore_ops
operator|.
name|to_longname
operator|=
literal|"Kernel core dump file"
expr_stmt|;
name|kcore_ops
operator|.
name|to_doc
operator|=
literal|"Use a core file as a target.  Specify the filename of the core file."
expr_stmt|;
name|kcore_ops
operator|.
name|to_open
operator|=
name|kcore_open
expr_stmt|;
name|kcore_ops
operator|.
name|to_close
operator|=
name|kcore_close
expr_stmt|;
name|kcore_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|kcore_ops
operator|.
name|to_detach
operator|=
name|kcore_detach
expr_stmt|;
name|kcore_ops
operator|.
name|to_fetch_registers
operator|=
name|get_kcore_registers
expr_stmt|;
name|kcore_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_kmem
expr_stmt|;
name|kcore_ops
operator|.
name|to_files_info
operator|=
name|kcore_files_info
expr_stmt|;
name|kcore_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|kcore_ops
operator|.
name|to_stratum
operator|=
name|kcore_stratum
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc"
argument_list|,
name|class_obscure
argument_list|,
name|set_proc_cmd
argument_list|,
literal|"Set current process context"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

