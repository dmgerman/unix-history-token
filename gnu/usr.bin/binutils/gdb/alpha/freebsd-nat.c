begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for BSD Unix running on i386's, for GDB.    Copyright 1988, 1989, 1991, 1992, 1994, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GREGSET_T
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|kernel_debugging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of elements in jmpbuf */
end_comment

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|8
end_define

begin_comment
comment|/* The definition for JB_PC in machine/reg.h is wrong.    And we can't get at the correct definition in setjmp.h as it is    not always available (eg. if _POSIX_SOURCE is defined which is the    default). As the defintion is unlikely to change (see comment    in<setjmp.h>, define the correct value here.  */
end_comment

begin_undef
undef|#
directive|undef
name|JB_PC
end_undef

begin_define
define|#
directive|define
name|JB_PC
value|2
end_define

begin_comment
comment|/* Figure out where the longjmp will land.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|raw_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|raw_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|regs
decl_stmt|;
comment|/* ptrace order, not gcc/gdb order */
name|struct
name|fpreg
name|fpregs
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|31
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|r
argument_list|)
index|]
argument_list|,
operator|&
name|regs
operator|.
name|r_regs
index|[
name|r
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|32
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|r
operator|+
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|fpregs
operator|.
name|fpr_regs
index|[
name|r
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|regs
operator|.
name|r_regs
index|[
literal|31
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ZERO_REGNUM
argument_list|)
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP_REGNUM
argument_list|)
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|regs
decl_stmt|;
comment|/* ptrace order, not gcc/gdb order */
name|struct
name|fpreg
name|fpregs
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|31
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|regs
operator|.
name|r_regs
index|[
name|r
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|r
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|32
condition|;
name|r
operator|++
control|)
name|memcpy
argument_list|(
operator|&
name|fpregs
operator|.
name|fpr_regs
index|[
name|r
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|r
operator|+
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|regs
operator|.
name|r_regs
index|[
literal|31
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GREGSET_T
end_ifdef

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gp
parameter_list|)
name|gregset_t
modifier|*
name|gp
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
comment|/* These must be ordered the same as REGISTER_NAMES in      config/alpha/tm-alpha.h. */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|31
condition|;
name|regno
operator|++
control|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gp
operator|->
name|r_regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GREGSET_T */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FPREGSET_T
end_ifdef

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fp
parameter_list|)
name|fpregset_t
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|32
condition|;
name|regno
operator|++
control|)
name|supply_register
argument_list|(
name|regno
operator|+
literal|32
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|->
name|fpr_regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FPREGSET_T */
end_comment

begin_comment
comment|/*  * Get registers from a kernel crash dump or live kernel.  * Called by kvm-fbsd.c:get_kcore_registers().  */
end_comment

begin_macro
name|fetch_kcore_registers
argument_list|(
argument|pcbp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pcb
modifier|*
name|pcbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* First clear out any garbage. */
name|memset
argument_list|(
name|registers
argument_list|,
literal|'\0'
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* SP */
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SP_REGNUM
argument_list|)
index|]
operator|=
name|pcbp
operator|->
name|pcb_hw
operator|.
name|apcb_ksp
expr_stmt|;
comment|/* S0 through S6 */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|S0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|pcbp
operator|->
name|pcb_context
index|[
literal|0
index|]
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PC */
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
operator|=
name|pcbp
operator|->
name|pcb_context
index|[
literal|7
index|]
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

