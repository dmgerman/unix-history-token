begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Kernel core dump functions below target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * This works like "remote" but, you use it like this:  *     target kcore /dev/mem  * or  *     target kcore /var/crash/host/core.0  *  * This way makes it easy to short-circut the whole bfd monster,  * and direct the inferior stuff to our libkvm implementation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|kcore_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kcore_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_kcore_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xfer_mem
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xfer_umem
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|core_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|core_kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|cur_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|kcore_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kernel_writablecore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the "thing" at kernel address 'addr' into the space pointed to  * by point.  The length of the "thing" is determined by the type of p.  * Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|kvread
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory((CORE_ADDR)(addr), (char *)(p), sizeof(*(p))))
end_define

begin_function
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Provide the address of an initial PCB to use.  * If this is a crash dump, try for "dumppcb".  * If no "dumppcb" or it's /dev/mem, use proc0.  * Return the core address of the PCB we found.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|initial_pcb
parameter_list|()
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
comment|/* Make sure things are open... */
if|if
condition|(
operator|!
name|core_kd
operator|||
operator|!
name|core_file
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If this is NOT /dev/mem try for dumppcb. */
if|if
condition|(
name|strncmp
argument_list|(
name|core_file
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"dumppcb"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
comment|/*    * OK, just use proc0pcb.  Note that curproc might    * not exist, and if it does, it will point to gdb.    * Therefore, just use proc0 and let the user set    * some other context if they care about it.    */
name|addr
operator|=
name|ksym_lookup
argument_list|(
literal|"proc0paddr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot read proc0paddr pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|CORE_ADDR
operator|)
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the current context to that of the PCB struct  * at the system address passed.  */
end_comment

begin_function
specifier|static
name|int
name|set_context
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|cur_pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %#x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Fetch all registers from core file */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file and mark data and stack    spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kcore_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* Avoid confusion from thread stuff */
if|if
condition|(
name|core_kd
condition|)
block|{
name|kvm_close
argument_list|(
name|core_kd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_file
argument_list|)
expr_stmt|;
name|core_file
operator|=
name|NULL
expr_stmt|;
name|core_kd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd.  */
end_comment

begin_function
specifier|static
name|void
name|kcore_open
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* the core file */
name|int
name|from_tty
decl_stmt|;
block|{
name|kvm_t
modifier|*
name|kd
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* The exec file is required for symbols. */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No kernel exec file specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
condition|)
block|{
name|error
argument_list|(
literal|"No core file specified."
literal|"  (Use `detach' to stop debugging a core file.)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|error
argument_list|(
literal|"No core file specified."
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|cp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|kd
operator|=
name|kvm_open
argument_list|(
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|kernel_writablecore
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Looks semi-reasonable.  Toss the old core file and work on the new.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more */
name|core_file
operator|=
name|filename
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
comment|/* Note unpush_target (above) calls kcore_close. */
name|core_kd
operator|=
name|kd
expr_stmt|;
comment|/* print out the panic string if there is one */
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|addr
operator|!=
literal|0
operator|&&
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf_filtered
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ontop
condition|)
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n\ your %s; do ``info files''"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, set up process context, and print the top of stack */
operator|(
name|void
operator|)
name|set_context
argument_list|(
name|initial_pcb
argument_list|()
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No kernel core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/*    * XXX - Only read the pcb when set_context() is called.    * When looking at a live kernel this may be a problem,    * but the user can do another "proc" or "pcb" command to    * grab a new copy of the pcb...    */
comment|/*    * Zero out register set then fill in the ones we know about.    */
name|fetch_kcore_registers
argument_list|(
operator|&
name|cur_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"\t`%s'\n"
argument_list|,
name|core_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|addr
parameter_list|,
name|contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_kmem
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|if (it is a user address)     return xfer_umem(memaddr, myaddr, len, write);
endif|#
directive|endif
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|write
condition|)
name|n
operator|=
name|kvm_write
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|kvm_read
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"can not access 0x%x, %s\n"
argument_list|,
name|memaddr
argument_list|,
name|kvm_geterr
argument_list|(
name|core_kd
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX */
end_comment

begin_comment
unit|static int xfer_umem (memaddr, myaddr, len, write)   CORE_ADDR memaddr;   char *myaddr;   int len;   int write;
comment|/* ignored */
end_comment

begin_endif
unit|{   int n;   struct proc proc;    if (kvread(cur_proc,&proc))     error("cannot read proc at %#x", cur_proc);   n = kvm_uread(core_kd,&proc, memaddr, myaddr, len) ;    if (n< 0)     return 0;   return n; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|set_proc_cmd
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"proc address for the new context"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no kernel core file"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Read the PCB address in proc structure. */
name|addr
operator|+=
operator|(
name|int
operator|)
operator|&
operator|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
operator|)
operator|->
name|p_addr
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read u area ptr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_context
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_pcb_cmd
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"pcb address for the new context"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no kernel core file"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_context
argument_list|(
name|addr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid pcb address"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_kcorelow
parameter_list|()
block|{
name|kcore_ops
operator|.
name|to_shortname
operator|=
literal|"kcore"
expr_stmt|;
name|kcore_ops
operator|.
name|to_longname
operator|=
literal|"Kernel core dump file"
expr_stmt|;
name|kcore_ops
operator|.
name|to_doc
operator|=
literal|"Use a core file as a target.  Specify the filename of the core file."
expr_stmt|;
name|kcore_ops
operator|.
name|to_open
operator|=
name|kcore_open
expr_stmt|;
name|kcore_ops
operator|.
name|to_close
operator|=
name|kcore_close
expr_stmt|;
name|kcore_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|kcore_ops
operator|.
name|to_detach
operator|=
name|kcore_detach
expr_stmt|;
name|kcore_ops
operator|.
name|to_fetch_registers
operator|=
name|get_kcore_registers
expr_stmt|;
name|kcore_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_kmem
expr_stmt|;
name|kcore_ops
operator|.
name|to_files_info
operator|=
name|kcore_files_info
expr_stmt|;
name|kcore_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|kcore_ops
operator|.
name|to_stratum
operator|=
name|kcore_stratum
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|kcore_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc"
argument_list|,
name|class_obscure
argument_list|,
name|set_proc_cmd
argument_list|,
literal|"Set current process context"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

