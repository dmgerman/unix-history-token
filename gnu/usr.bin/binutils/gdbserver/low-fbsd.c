begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for the remote server for GDB.    Copyright (C) 1995 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/***************Begin MY defs*********************/
end_comment

begin_decl_stmt
name|int
name|quit_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index within `registers' of the first byte of the space for    register N.  */
end_comment

begin_decl_stmt
name|char
name|buf2
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************End MY defs*********************/
end_comment

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|quit
argument_list|()
decl_stmt|,
name|perror_with_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|query
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a vector of program-name and args.    ENV is the environment vector to pass.  */
end_comment

begin_function
name|int
name|create_inferior
parameter_list|(
name|program
parameter_list|,
name|allargs
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
modifier|*
name|allargs
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|ptrace
argument_list|(
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|program
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|program
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
name|PT_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*************inferior_died ();****VK**************/
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
name|int
name|mythread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status */
end_comment

begin_function
name|unsigned
name|char
name|mywait
parameter_list|(
name|status
parameter_list|)
name|char
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|w
decl_stmt|;
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
name|perror_with_name
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = %x \n"
argument_list|,
name|WTERMSIG
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'X'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WTERMSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
name|fetch_inferior_registers
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|myresume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|step
condition|?
name|PT_STEP
else|:
name|PT_CONTINUE
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|offsetof
argument_list|)
end_if

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* U_REGS_OFFSET is the offset of the registers within the u area.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|U_REGS_OFFSET
argument_list|)
end_if

begin_define
define|#
directive|define
name|U_REGS_OFFSET
define|\
value|ptrace (PT_READ_U, inferior_pid, \           (PTRACE_ARG3_TYPE) (offsetof (struct user, u_ar0)), 0) \     - KERNEL_U_ADDR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|int
name|register_addr
parameter_list|(
name|regno
parameter_list|,
name|blockend
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|blockend
decl_stmt|;
block|{
name|int
name|addr
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
name|ARCH_NUM_REGS
condition|)
name|error
argument_list|(
literal|"Invalid register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|REGISTER_U_ADDR
argument_list|(
name|addr
argument_list|,
name|blockend
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|unsigned
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|U_REGS_OFFSET
expr_stmt|;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 	     kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"reading register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
name|error_exit
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers, or just one, from the child process.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
name|U_REGS_OFFSET
decl_stmt|;
name|int
name|scratch
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 		 kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"writing register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_PTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_macro
name|read_inferior_memory
argument_list|(
argument|memaddr
argument_list|,
argument|myaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|initialize
parameter_list|()
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|have_inferior_p
parameter_list|()
block|{
return|return
name|inferior_pid
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Some systems don't provide all the registers on a trap.  Use SS as a    default if so.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|tDS
end_ifndef

begin_define
define|#
directive|define
name|tDS
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tES
end_ifndef

begin_define
define|#
directive|define
name|tES
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tFS
end_ifndef

begin_define
define|#
directive|define
name|tFS
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tGS
end_ifndef

begin_define
define|#
directive|define
name|tGS
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These tables map between the registers on a trap frame, and the register    order used by the rest of GDB.  */
end_comment

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386.h */
end_comment

begin_comment
comment|/* symbols like 'tEAX' come from<machine/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tFS
block|,
name|tGS
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sEAX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|sEAX
block|,
name|sECX
block|,
name|sEDX
block|,
name|sEBX
block|,
name|sESP
block|,
name|sEBP
block|,
name|sESI
block|,
name|sEDI
block|,
name|sEIP
block|,
name|sEFLAGS
block|,
name|sCS
block|,
name|sSS
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No sEAX */
end_comment

begin_comment
comment|/* FreeBSD has decided to collapse the s* and t* symbols.  So if the s*    ones aren't around, use the t* ones for sregmap too.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tFS
block|,
name|tGS
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No sEAX */
end_comment

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the    place where ES is stored.  */
end_comment

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
comment|/* The following condition is a kludge to get at the proper register map      depending upon the state of pcb_flag.      The proper condition would be      if (u.u_pcb.pcb_flag& FM_TRAP)      but that would require a ptrace call here and wouldn't work      for corefiles.  */
if|if
condition|(
name|blockend
operator|<
literal|0x1fcc
condition|)
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|tregmap
index|[
name|regnum
index|]
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|sregmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

end_unit

