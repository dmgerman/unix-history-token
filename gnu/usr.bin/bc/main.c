begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c: The main program for bc.  */
end_comment

begin_comment
comment|/*  This file is part of bc written for MINIX.     Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to     the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.      You may contact the author by:        e-mail:  phil@cs.wwu.edu       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"bcdefs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_comment
comment|/* Variables for processing multiple files. */
end_comment

begin_decl_stmt
name|char
name|first_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The main program for bc. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
comment|/* Initialize many variables. */
name|compile_only
operator|=
name|FALSE
expr_stmt|;
name|use_math
operator|=
name|FALSE
expr_stmt|;
name|warn_not_std
operator|=
name|FALSE
expr_stmt|;
name|std_only
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|interactive
operator|=
name|TRUE
expr_stmt|;
else|else
name|interactive
operator|=
name|FALSE
expr_stmt|;
comment|/* Parse the command line */
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lcisvw"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* compile only */
name|compile_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* math lib */
name|use_math
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* force interactive */
name|interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Non standard features give warnings. */
name|warn_not_std
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Non standard features give errors. */
name|std_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Print the version. */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|BC_VERSION
argument_list|)
expr_stmt|;
break|break;
block|}
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lcisvw"
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the machine.  */
name|init_storage
argument_list|()
expr_stmt|;
name|init_load
argument_list|()
expr_stmt|;
comment|/* Set up interrupts to print a message. */
if|if
condition|(
name|interactive
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
comment|/* Initialize the front end. */
name|init_tree
argument_list|()
expr_stmt|;
name|init_gen
argument_list|()
expr_stmt|;
name|g_argv
operator|=
name|argv
expr_stmt|;
name|g_argc
operator|=
name|argc
expr_stmt|;
name|is_std_in
operator|=
name|FALSE
expr_stmt|;
name|first_file
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|open_new_file
argument_list|()
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Do the parse. */
name|yyparse
argument_list|()
expr_stmt|;
comment|/* End the compile only output with a newline. */
if|if
condition|(
name|compile_only
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the function that opens all the files.    It returns TRUE if the file was opened, otherwise    it returns FALSE. */
end_comment

begin_function
name|int
name|open_new_file
parameter_list|()
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
comment|/* Set the line number. */
name|line_no
operator|=
literal|1
expr_stmt|;
comment|/* Check to see if we are done. */
if|if
condition|(
name|is_std_in
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Open the other files. */
if|if
condition|(
name|use_math
operator|&&
name|first_file
condition|)
block|{
ifdef|#
directive|ifdef
name|BC_MATH_FILE
comment|/* Make the first file be the math library. */
name|new_file
operator|=
name|fopen
argument_list|(
name|BC_MATH_FILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|use_math
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|new_yy_file
argument_list|(
name|new_file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Math Library unavailable.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Load the code from a precompiled version of the math libarary. */
specifier|extern
name|char
name|libmath
index|[]
decl_stmt|;
name|char
name|tmp
decl_stmt|;
comment|/* These MUST be in the order of first mention of each function. 	 That is why "a" comes before "c" even though "a" is defined after 	 after "c".  "a" is used in "s"! */
name|tmp
operator|=
name|lookup
argument_list|(
literal|"e"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"l"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"s"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"a"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"c"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"j"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|load_code
argument_list|(
name|libmath
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* One of the argv values. */
while|while
condition|(
name|optind
operator|<
name|g_argc
condition|)
block|{
name|new_file
operator|=
name|fopen
argument_list|(
name|g_argv
index|[
name|optind
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|new_yy_file
argument_list|(
name|new_file
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s is unavailable.\n"
argument_list|,
name|g_argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we fall through to here, we should return stdin. */
name|new_yy_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|is_std_in
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set yyin to the new file. */
end_comment

begin_function
name|void
name|new_yy_file
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|first_file
condition|)
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|file
expr_stmt|;
name|first_file
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Message to use quit.  */
end_comment

begin_function
name|void
name|use_quit
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\n(interrupt) use quit to exit.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

