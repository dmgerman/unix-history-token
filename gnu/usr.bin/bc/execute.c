begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* execute.c - run a bc program. */
end_comment

begin_comment
comment|/*  This file is part of bc written for MINIX.     Copyright (C) 1991, 1992 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to     the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.      You may contact the author by:        e-mail:  phil@cs.wwu.edu       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"bcdefs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_comment
comment|/* The SIGINT interrupt handling routine. */
end_comment

begin_decl_stmt
name|int
name|had_sigint
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|stop_execution
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|had_sigint
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|rt_error
argument_list|(
literal|"interrupted execution"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the current byte and advance the PC counter. */
end_comment

begin_function
name|unsigned
name|char
name|byte
parameter_list|(
name|pc
parameter_list|)
name|program_counter
modifier|*
name|pc
decl_stmt|;
block|{
name|int
name|seg
decl_stmt|,
name|offset
decl_stmt|;
name|seg
operator|=
name|pc
operator|->
name|pc_addr
operator|>>
name|BC_SEG_LOG
expr_stmt|;
name|offset
operator|=
name|pc
operator|->
name|pc_addr
operator|++
operator|%
name|BC_SEG_SIZE
expr_stmt|;
return|return
operator|(
name|functions
index|[
name|pc
operator|->
name|pc_func
index|]
operator|.
name|f_body
index|[
name|seg
index|]
index|[
name|offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The routine that actually runs the machine. */
end_comment

begin_function
name|void
name|execute
parameter_list|()
block|{
name|int
name|label_num
decl_stmt|,
name|l_gp
decl_stmt|,
name|l_off
decl_stmt|;
name|bc_label_group
modifier|*
name|gp
decl_stmt|;
name|char
name|inst
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|new_func
decl_stmt|;
name|int
name|var_name
decl_stmt|;
name|int
name|const_base
decl_stmt|;
name|bc_num
name|temp_num
decl_stmt|;
name|arg_list
modifier|*
name|auto_list
decl_stmt|;
comment|/* Initialize this run... */
name|pc
operator|.
name|pc_func
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|pc_addr
operator|=
literal|0
expr_stmt|;
name|runtime_error
operator|=
name|FALSE
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
comment|/* Set up the interrupt mechanism for an interactive session. */
if|if
condition|(
name|interactive
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|stop_execution
argument_list|)
expr_stmt|;
name|had_sigint
operator|=
name|FALSE
expr_stmt|;
block|}
while|while
condition|(
name|pc
operator|.
name|pc_addr
operator|<
name|functions
index|[
name|pc
operator|.
name|pc_func
index|]
operator|.
name|f_code_size
operator|&&
operator|!
name|runtime_error
condition|)
block|{
name|inst
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|3
block|{
comment|/* Print out address and the stack before each instruction.*/
name|int
name|depth
decl_stmt|;
name|estack_rec
modifier|*
name|temp
init|=
name|ex_stack
decl_stmt|;
name|printf
argument_list|(
literal|"func=%d addr=%d inst=%c\n"
argument_list|,
name|pc
operator|.
name|pc_func
argument_list|,
name|pc
operator|.
name|pc_addr
argument_list|,
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"empty stack.\n"
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
block|{
name|depth
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"   %d = "
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|out_num
argument_list|(
name|temp
operator|->
name|s_num
argument_list|,
literal|10
argument_list|,
name|out_char
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|s_next
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
switch|switch
condition|(
name|inst
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* increment array variable (Add one). */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|incr_array
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Branch to a label if TOS != 0. Remove value on TOS. */
case|case
literal|'Z'
case|:
comment|/* Branch to a label if TOS == 0. Remove value on TOS. */
name|c_code
operator|=
operator|!
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
case|case
literal|'J'
case|:
comment|/* Jump to a label. */
name|label_num
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Low order bits first. */
name|label_num
operator|+=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|==
literal|'J'
operator|||
operator|(
name|inst
operator|==
literal|'B'
operator|&&
name|c_code
operator|)
operator|||
operator|(
name|inst
operator|==
literal|'Z'
operator|&&
operator|!
name|c_code
operator|)
condition|)
block|{
name|gp
operator|=
name|functions
index|[
name|pc
operator|.
name|pc_func
index|]
operator|.
name|f_label
expr_stmt|;
name|l_gp
operator|=
name|label_num
operator|>>
name|BC_LABEL_LOG
expr_stmt|;
name|l_off
operator|=
name|label_num
operator|%
name|BC_LABEL_GROUP
expr_stmt|;
while|while
condition|(
name|l_gp
operator|--
operator|>
literal|0
condition|)
name|gp
operator|=
name|gp
operator|->
name|l_next
expr_stmt|;
name|pc
operator|.
name|pc_addr
operator|=
name|gp
operator|->
name|l_adrs
index|[
name|l_off
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Call a function. */
comment|/* Get the function number. */
name|new_func
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_func
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|new_func
operator|=
operator|(
operator|(
name|new_func
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Check to make sure it is defined. */
if|if
condition|(
operator|!
name|functions
index|[
name|new_func
index|]
operator|.
name|f_defined
condition|)
block|{
name|rt_error
argument_list|(
literal|"Function %s not defined."
argument_list|,
name|f_names
index|[
name|new_func
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check and push parameters. */
name|process_params
argument_list|(
operator|&
name|pc
argument_list|,
name|new_func
argument_list|)
expr_stmt|;
comment|/* Push auto variables. */
for|for
control|(
name|auto_list
operator|=
name|functions
index|[
name|new_func
index|]
operator|.
name|f_autos
init|;
name|auto_list
operator|!=
name|NULL
condition|;
name|auto_list
operator|=
name|auto_list
operator|->
name|next
control|)
name|auto_var
argument_list|(
name|auto_list
operator|->
name|av_name
argument_list|)
expr_stmt|;
comment|/* Push pc and ibase. */
name|fpush
argument_list|(
name|pc
operator|.
name|pc_func
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|pc
operator|.
name|pc_addr
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|i_base
argument_list|)
expr_stmt|;
comment|/* Reset pc to start of function. */
name|pc
operator|.
name|pc_func
operator|=
name|new_func
expr_stmt|;
name|pc
operator|.
name|pc_addr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Duplicate top of stack */
name|push_copy
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* Push a constant */
comment|/* Get the input base and convert it to a bc number. */
if|if
condition|(
name|pc
operator|.
name|pc_func
operator|==
literal|0
condition|)
name|const_base
operator|=
name|i_base
expr_stmt|;
else|else
name|const_base
operator|=
name|fn_stack
operator|->
name|s_val
expr_stmt|;
if|if
condition|(
name|const_base
operator|==
literal|10
condition|)
name|push_b10_const
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
else|else
name|push_constant
argument_list|(
name|prog_char
argument_list|,
name|const_base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* load array variable */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|load_array
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* decrement array variable (Minus!) */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|decr_array
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* Write a string to the output with processing. */
while|while
condition|(
operator|(
name|ch
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
operator|)
operator|!=
literal|'"'
condition|)
if|if
condition|(
name|ch
operator|!=
literal|'\\'
condition|)
name|out_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
name|ch
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
break|break;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|out_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|out_char
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|out_char
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out_char
argument_list|(
literal|007
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|out_char
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|out_char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|interactive
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Return from function */
if|if
condition|(
name|pc
operator|.
name|pc_func
operator|!=
literal|0
condition|)
block|{
comment|/* "Pop" autos and parameters. */
name|pop_vars
argument_list|(
name|functions
index|[
name|pc
operator|.
name|pc_func
index|]
operator|.
name|f_autos
argument_list|)
expr_stmt|;
name|pop_vars
argument_list|(
name|functions
index|[
name|pc
operator|.
name|pc_func
index|]
operator|.
name|f_params
argument_list|)
expr_stmt|;
comment|/* reset the pc. */
name|fpop
argument_list|()
expr_stmt|;
name|pc
operator|.
name|pc_addr
operator|=
name|fpop
argument_list|()
expr_stmt|;
name|pc
operator|.
name|pc_func
operator|=
name|fpop
argument_list|()
expr_stmt|;
block|}
else|else
name|rt_error
argument_list|(
literal|"Return from main program."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* store array variable */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|store_array
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Test tos for zero */
name|c_code
operator|=
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Write the value on the top of the stack. */
case|case
literal|'P'
case|:
comment|/* Write the value on the top of the stack.  No newline. */
name|out_num
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|,
name|o_base
argument_list|,
name|out_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|==
literal|'W'
condition|)
name|out_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|store_var
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* Special variable "last". */
if|if
condition|(
name|interactive
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Call special function. */
name|new_func
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new_func
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Length function. */
comment|/* For the number 0.xxxx,  0 is not significant. */
if|if
condition|(
name|ex_stack
operator|->
name|s_num
operator|->
name|n_len
operator|==
literal|1
operator|&&
name|ex_stack
operator|->
name|s_num
operator|->
name|n_scale
operator|!=
literal|0
operator|&&
name|ex_stack
operator|->
name|s_num
operator|->
name|n_value
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
operator|->
name|n_scale
argument_list|)
expr_stmt|;
else|else
name|int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
operator|->
name|n_len
operator|+
name|ex_stack
operator|->
name|s_num
operator|->
name|n_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Scale function. */
name|int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
operator|->
name|n_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Square Root function. */
if|if
condition|(
operator|!
name|bc_sqrt
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|scale
argument_list|)
condition|)
name|rt_error
argument_list|(
literal|"Square root of a negative number"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Read function. */
name|push_constant
argument_list|(
name|input_char
argument_list|,
name|i_base
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* Decrement number */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|decr_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Halt the machine. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
comment|/* increment number */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|incr_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* load variable */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|load_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Negate top of stack. */
name|bc_sub
argument_list|(
name|_zero_
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Pop the execution stack. */
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* store variable */
name|var_name
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var_name
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|var_name
operator|=
operator|(
operator|(
name|var_name
operator|<<
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|+
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|store_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Write a string to the output. */
while|while
condition|(
operator|(
name|ch
operator|=
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
operator|)
operator|!=
literal|'"'
condition|)
name|out_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Exchange Top of Stack with the one under the tos. */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|bc_num
name|temp
init|=
name|ex_stack
operator|->
name|s_num
decl_stmt|;
name|ex_stack
operator|->
name|s_num
operator|=
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
expr_stmt|;
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
operator|=
name|temp
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
comment|/* Load Constant 0. */
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* Load Constant 0. */
name|push_copy
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
comment|/* Negate the boolean value on top of the stack. */
name|c_code
operator|=
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* compare greater than */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
operator|!
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|)
operator|&&
operator|!
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* compare greater than */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
operator|!
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|)
operator|||
operator|!
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
comment|/* add */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|bc_add
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|temp_num
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push_num
argument_list|(
name|temp_num
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
comment|/* subtract */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|bc_sub
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|temp_num
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push_num
argument_list|(
name|temp_num
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
comment|/* multiply */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|bc_multiply
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|temp_num
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push_num
argument_list|(
name|temp_num
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
comment|/* divide */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|bc_divide
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|temp_num
argument_list|,
name|scale
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push_num
argument_list|(
name|temp_num
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
block|}
else|else
name|rt_error
argument_list|(
literal|"Divide by zero"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
comment|/* remainder */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
condition|)
name|rt_error
argument_list|(
literal|"Modulo by zero"
argument_list|)
expr_stmt|;
else|else
block|{
name|bc_modulo
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|temp_num
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push_num
argument_list|(
name|temp_num
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'^'
case|:
comment|/* raise */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|bc_raise
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|,
operator|&
name|temp_num
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_zero
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|)
operator|&&
name|is_neg
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
condition|)
name|rt_error
argument_list|(
literal|"divide by zero"
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push_num
argument_list|(
name|temp_num
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|temp_num
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'='
case|:
comment|/* compare equal */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
name|bc_compare
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|==
literal|0
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* compare not equal */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
name|bc_compare
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'<'
case|:
comment|/* compare less than */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
name|bc_compare
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|==
operator|-
literal|1
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'{'
case|:
comment|/* compare less than or equal */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
name|bc_compare
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|<=
literal|0
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
comment|/* compare greater than */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
name|bc_compare
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|==
literal|1
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'}'
case|:
comment|/* compare greater than or equal */
if|if
condition|(
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|c_code
operator|=
name|bc_compare
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|,
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|c_code
argument_list|)
expr_stmt|;
block|}
break|break;
default|default  :
comment|/* error! */
name|rt_error
argument_list|(
literal|"bad instruction: inst=%c"
argument_list|,
name|inst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up the function stack and pop all autos/parameters. */
while|while
condition|(
name|pc
operator|.
name|pc_func
operator|!=
literal|0
condition|)
block|{
name|pop_vars
argument_list|(
name|functions
index|[
name|pc
operator|.
name|pc_func
index|]
operator|.
name|f_autos
argument_list|)
expr_stmt|;
name|pop_vars
argument_list|(
name|functions
index|[
name|pc
operator|.
name|pc_func
index|]
operator|.
name|f_params
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
name|pc
operator|.
name|pc_addr
operator|=
name|fpop
argument_list|()
expr_stmt|;
name|pc
operator|.
name|pc_func
operator|=
name|fpop
argument_list|()
expr_stmt|;
block|}
comment|/* Clean up the execution stack. */
while|while
condition|(
name|ex_stack
operator|!=
name|NULL
condition|)
name|pop
argument_list|()
expr_stmt|;
comment|/* Clean up the interrupt stuff. */
if|if
condition|(
name|interactive
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_sigint
condition|)
name|printf
argument_list|(
literal|"Interruption completed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prog_char gets another byte from the program.  It is used for    conversion of text constants in the code to numbers. */
end_comment

begin_function
name|char
name|prog_char
parameter_list|()
block|{
return|return
name|byte
argument_list|(
operator|&
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a character from the standard input.  This function is used    by the "read" function. */
end_comment

begin_function
name|char
name|input_char
parameter_list|()
block|{
name|char
name|in_ch
decl_stmt|;
comment|/* Get a character from the standard input for the read function. */
name|in_ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Check for a \ quoted newline. */
if|if
condition|(
name|in_ch
operator|==
literal|'\\'
condition|)
block|{
name|in_ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_ch
operator|==
literal|'\n'
condition|)
name|in_ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
comment|/* Classify and preprocess the input character. */
if|if
condition|(
name|isdigit
argument_list|(
name|in_ch
argument_list|)
condition|)
return|return
operator|(
name|in_ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|in_ch
operator|>=
literal|'A'
operator|&&
name|in_ch
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|in_ch
operator|+
literal|10
operator|-
literal|'A'
operator|)
return|;
if|if
condition|(
name|in_ch
operator|>=
literal|'a'
operator|&&
name|in_ch
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|in_ch
operator|+
literal|10
operator|-
literal|'a'
operator|)
return|;
if|if
condition|(
name|in_ch
operator|==
literal|'.'
operator|||
name|in_ch
operator|==
literal|'+'
operator|||
name|in_ch
operator|==
literal|'-'
condition|)
return|return
operator|(
name|in_ch
operator|)
return|;
if|if
condition|(
name|in_ch
operator|<=
literal|' '
condition|)
return|return
operator|(
literal|' '
operator|)
return|;
return|return
operator|(
literal|':'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push_constant converts a sequence of input characters as returned    by IN_CHAR into a number.  The number is pushed onto the execution    stack.  The number is converted as a number in base CONV_BASE. */
end_comment

begin_decl_stmt
name|void
name|push_constant
argument_list|(
name|in_char
argument_list|,
name|conv_base
argument_list|)
name|char
argument_list|(
operator|*
name|in_char
argument_list|)
argument_list|(
name|VOID
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|conv_base
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|digits
decl_stmt|;
name|bc_num
name|build
decl_stmt|,
name|temp
decl_stmt|,
name|result
decl_stmt|,
name|mult
decl_stmt|,
name|divisor
decl_stmt|;
name|char
name|in_ch
decl_stmt|,
name|first_ch
decl_stmt|;
name|char
name|negative
decl_stmt|;
comment|/* Initialize all bc numbers */
name|init_num
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|init_num
argument_list|(
operator|&
name|mult
argument_list|)
expr_stmt|;
name|build
operator|=
name|copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|negative
operator|=
name|FALSE
expr_stmt|;
comment|/* The conversion base. */
name|int2num
argument_list|(
operator|&
name|mult
argument_list|,
name|conv_base
argument_list|)
expr_stmt|;
comment|/* Get things ready. */
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
while|while
condition|(
name|in_ch
operator|==
literal|' '
condition|)
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_ch
operator|==
literal|'+'
condition|)
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|in_ch
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
name|TRUE
expr_stmt|;
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
block|}
comment|/* Check for the special case of a single digit. */
if|if
condition|(
name|in_ch
operator|<
literal|16
condition|)
block|{
name|first_ch
operator|=
name|in_ch
expr_stmt|;
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_ch
operator|<
literal|16
operator|&&
name|first_ch
operator|>=
name|conv_base
condition|)
name|first_ch
operator|=
name|conv_base
operator|-
literal|1
expr_stmt|;
name|int2num
argument_list|(
operator|&
name|build
argument_list|,
operator|(
name|int
operator|)
name|first_ch
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer part. */
while|while
condition|(
name|in_ch
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|in_ch
operator|<
literal|16
operator|&&
name|in_ch
operator|>=
name|conv_base
condition|)
name|in_ch
operator|=
name|conv_base
operator|-
literal|1
expr_stmt|;
name|bc_multiply
argument_list|(
name|build
argument_list|,
name|mult
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int2num
argument_list|(
operator|&
name|temp
argument_list|,
operator|(
name|int
operator|)
name|in_ch
argument_list|)
expr_stmt|;
name|bc_add
argument_list|(
name|result
argument_list|,
name|temp
argument_list|,
operator|&
name|build
argument_list|)
expr_stmt|;
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in_ch
operator|==
literal|'.'
condition|)
block|{
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_ch
operator|>=
name|conv_base
condition|)
name|in_ch
operator|=
name|conv_base
operator|-
literal|1
expr_stmt|;
name|free_num
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|free_num
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|divisor
operator|=
name|copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
name|result
operator|=
name|copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|in_ch
operator|<
literal|16
condition|)
block|{
name|bc_multiply
argument_list|(
name|result
argument_list|,
name|mult
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int2num
argument_list|(
operator|&
name|temp
argument_list|,
operator|(
name|int
operator|)
name|in_ch
argument_list|)
expr_stmt|;
name|bc_add
argument_list|(
name|result
argument_list|,
name|temp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|bc_multiply
argument_list|(
name|divisor
argument_list|,
name|mult
argument_list|,
operator|&
name|divisor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|digits
operator|++
expr_stmt|;
name|in_ch
operator|=
name|in_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_ch
operator|<
literal|16
operator|&&
name|in_ch
operator|>=
name|conv_base
condition|)
name|in_ch
operator|=
name|conv_base
operator|-
literal|1
expr_stmt|;
block|}
name|bc_divide
argument_list|(
name|result
argument_list|,
name|divisor
argument_list|,
operator|&
name|result
argument_list|,
name|digits
argument_list|)
expr_stmt|;
name|bc_add
argument_list|(
name|build
argument_list|,
name|result
argument_list|,
operator|&
name|build
argument_list|)
expr_stmt|;
block|}
comment|/* Final work.  */
if|if
condition|(
name|negative
condition|)
name|bc_sub
argument_list|(
name|_zero_
argument_list|,
name|build
argument_list|,
operator|&
name|build
argument_list|)
expr_stmt|;
name|push_num
argument_list|(
name|build
argument_list|)
expr_stmt|;
name|free_num
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|free_num
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|free_num
argument_list|(
operator|&
name|mult
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When converting base 10 constants from the program, we use this    more efficient way to convert them to numbers.  PC tells where    the constant starts and is expected to be advanced to after    the constant. */
end_comment

begin_function
name|void
name|push_b10_const
parameter_list|(
name|pc
parameter_list|)
name|program_counter
modifier|*
name|pc
decl_stmt|;
block|{
name|bc_num
name|build
decl_stmt|;
name|program_counter
name|look_pc
decl_stmt|;
name|int
name|kdigits
decl_stmt|,
name|kscale
decl_stmt|;
name|char
name|inchar
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* Count the digits and get things ready. */
name|look_pc
operator|=
operator|*
name|pc
expr_stmt|;
name|kdigits
operator|=
literal|0
expr_stmt|;
name|kscale
operator|=
literal|0
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
operator|&
name|look_pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|inchar
operator|!=
literal|'.'
operator|&&
name|inchar
operator|!=
literal|':'
condition|)
block|{
name|kdigits
operator|++
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
operator|&
name|look_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inchar
operator|==
literal|'.'
condition|)
block|{
name|inchar
operator|=
name|byte
argument_list|(
operator|&
name|look_pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|inchar
operator|!=
literal|':'
condition|)
block|{
name|kscale
operator|++
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
operator|&
name|look_pc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the first character again and move the pc. */
name|inchar
operator|=
name|byte
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Secial cases of 0, 1, and A-F single inputs. */
if|if
condition|(
name|kdigits
operator|==
literal|1
operator|&&
name|kscale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inchar
operator|==
literal|0
condition|)
block|{
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inchar
operator|==
literal|1
condition|)
block|{
name|push_copy
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inchar
operator|>
literal|9
condition|)
block|{
name|init_num
argument_list|(
operator|&
name|build
argument_list|)
expr_stmt|;
name|int2num
argument_list|(
operator|&
name|build
argument_list|,
name|inchar
argument_list|)
expr_stmt|;
name|push_num
argument_list|(
name|build
argument_list|)
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Build the new number. */
if|if
condition|(
name|kdigits
operator|==
literal|0
condition|)
block|{
name|build
operator|=
name|new_num
argument_list|(
literal|1
argument_list|,
name|kscale
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|build
operator|->
name|n_value
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|build
operator|=
name|new_num
argument_list|(
name|kdigits
argument_list|,
name|kscale
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|build
operator|->
name|n_value
expr_stmt|;
block|}
while|while
condition|(
name|inchar
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|inchar
operator|!=
literal|'.'
condition|)
if|if
condition|(
name|inchar
operator|>
literal|9
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|9
expr_stmt|;
else|else
operator|*
name|ptr
operator|++
operator|=
name|inchar
expr_stmt|;
name|inchar
operator|=
name|byte
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|push_num
argument_list|(
name|build
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the correct value on the stack for C_CODE.  Frees TOS num. */
end_comment

begin_function
name|void
name|assign
parameter_list|(
name|c_code
parameter_list|)
name|char
name|c_code
decl_stmt|;
block|{
name|free_num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_code
condition|)
name|ex_stack
operator|->
name|s_num
operator|=
name|copy_num
argument_list|(
name|_one_
argument_list|)
expr_stmt|;
else|else
name|ex_stack
operator|->
name|s_num
operator|=
name|copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

