begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sort - sort lines of text (with all kinds of options).    Copyright (C) 1988, 1991, 1992, 1993, 1994, 1995 Free Software Foundation     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written December 1988 by Mike Haertel.    The author may be reached (Email) at the address mike@gnu.ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_comment
comment|/* Get isblank from GNU libc.  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"long-options.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"xstrtod.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Undefine, to avoid warning about redefinition on some systems.  */
end_comment

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|UCHAR_LIM
value|(UCHAR_MAX + 1)
end_define

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_TMPDIR
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_TMPDIR
value|"/tmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The kind of blanks for '-b' to skip in various options. */
end_comment

begin_enum
enum|enum
name|blanktype
block|{
name|bl_start
block|,
name|bl_end
block|,
name|bl_both
block|}
enum|;
end_enum

begin_comment
comment|/* Lines are held in core as counted strings. */
end_comment

begin_struct
struct|struct
name|line
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Text of the line. */
name|int
name|length
decl_stmt|;
comment|/* Length not including final newline. */
name|char
modifier|*
name|keybeg
decl_stmt|;
comment|/* Start of first key. */
name|char
modifier|*
name|keylim
decl_stmt|;
comment|/* Limit of first key. */
block|}
struct|;
end_struct

begin_comment
comment|/* Arrays of lines. */
end_comment

begin_struct
struct|struct
name|lines
block|{
name|struct
name|line
modifier|*
name|lines
decl_stmt|;
comment|/* Dynamically allocated array of lines. */
name|int
name|used
decl_stmt|;
comment|/* Number of slots used. */
name|int
name|alloc
decl_stmt|;
comment|/* Number of slots allocated. */
name|int
name|limit
decl_stmt|;
comment|/* Max number of slots to allocate.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Input buffers. */
end_comment

begin_struct
struct|struct
name|buffer
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Dynamically allocated buffer. */
name|int
name|used
decl_stmt|;
comment|/* Number of bytes used. */
name|int
name|alloc
decl_stmt|;
comment|/* Number of bytes allocated. */
name|int
name|left
decl_stmt|;
comment|/* Number of bytes left after line parsing. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|keyfield
block|{
name|int
name|sword
decl_stmt|;
comment|/* Zero-origin 'word' to start at. */
name|int
name|schar
decl_stmt|;
comment|/* Additional characters to skip. */
name|int
name|skipsblanks
decl_stmt|;
comment|/* Skip leading white space at start. */
name|int
name|eword
decl_stmt|;
comment|/* Zero-origin first word after field. */
name|int
name|echar
decl_stmt|;
comment|/* Additional characters in field. */
name|int
name|skipeblanks
decl_stmt|;
comment|/* Skip trailing white space at finish. */
name|int
modifier|*
name|ignore
decl_stmt|;
comment|/* Boolean array of characters to ignore. */
name|char
modifier|*
name|translate
decl_stmt|;
comment|/* Translation applied to characters. */
name|int
name|numeric
decl_stmt|;
comment|/* Flag for numeric comparison.  Handle 				   strings of digits with optional decimal 				   point, but no exponential notation. */
name|int
name|general_numeric
decl_stmt|;
comment|/* Flag for general, numeric comparison. 				   Handle numbers in exponential notation. */
name|int
name|month
decl_stmt|;
comment|/* Flag for comparison by month name. */
name|int
name|reverse
decl_stmt|;
comment|/* Reverse the sense of comparison. */
name|struct
name|keyfield
modifier|*
name|next
decl_stmt|;
comment|/* Next keyfield to try. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|month
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of digits. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|digits
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of white space. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blanks
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of non-printing characters. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nonprinting
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of non-dictionary characters (not letters, digits, or blanks). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nondictionary
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table folding lower case to upper. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fold_toupper
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table mapping 3-letter month names to integers.    Alphabetic order allows binary search. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|month
specifier|const
name|monthtab
index|[]
init|=
block|{
block|{
literal|"APR"
block|,
literal|4
block|}
block|,
block|{
literal|"AUG"
block|,
literal|8
block|}
block|,
block|{
literal|"DEC"
block|,
literal|12
block|}
block|,
block|{
literal|"FEB"
block|,
literal|2
block|}
block|,
block|{
literal|"JAN"
block|,
literal|1
block|}
block|,
block|{
literal|"JUL"
block|,
literal|7
block|}
block|,
block|{
literal|"JUN"
block|,
literal|6
block|}
block|,
block|{
literal|"MAR"
block|,
literal|3
block|}
block|,
block|{
literal|"MAY"
block|,
literal|5
block|}
block|,
block|{
literal|"NOV"
block|,
literal|11
block|}
block|,
block|{
literal|"OCT"
block|,
literal|10
block|}
block|,
block|{
literal|"SEP"
block|,
literal|9
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During the merge phase, the number of files to merge at once. */
end_comment

begin_define
define|#
directive|define
name|NMERGE
value|16
end_define

begin_comment
comment|/* Initial buffer size for in core sorting.  Will not grow unless a    line longer than this is seen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sortalloc
init|=
literal|512
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial buffer size for in core merge buffers.  Bear in mind that    up to NMERGE * mergealloc bytes may be allocated for merge buffers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mergealloc
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Guess of average line length. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linelength
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of elements for the array(s) of struct line's, in bytes.  */
end_comment

begin_define
define|#
directive|define
name|LINEALLOC
value|(256 * 1024)
end_define

begin_comment
comment|/* Prefix for temporary file names. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_file_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to reverse the order of all comparisons. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for stable sort.  This turns off the last ditch bytewise    comparison of lines, and instead leaves lines in the same order    they were read if all keys compare equal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tab character separating fields.  If NUL, then fields are separated    by the empty string between a non-whitespace character and a whitespace    character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to remove consecutive duplicate lines from the output.    Only the last of a sequence of equal lines will be output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unique
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any of the input files are the standard input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_read_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lists of key field comparisons to be tried. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyfield
name|keyhead
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|decimal_point
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|COLLDIFF
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
specifier|static
name|char
name|s
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|a
operator|==
operator|(
name|unsigned
name|char
operator|)
name|b
condition|)
return|return
literal|0
return|;
name|s
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
name|s
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
return|return
name|strcoll
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collcmp
parameter_list|(
name|char
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|b
parameter_list|,
name|int
name|mini
parameter_list|)
block|{
name|char
name|sa
decl_stmt|,
name|sb
decl_stmt|;
name|int
name|r
decl_stmt|;
name|sa
operator|=
name|a
index|[
name|mini
index|]
expr_stmt|;
name|a
index|[
name|mini
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sb
operator|=
name|b
index|[
name|mini
index|]
expr_stmt|;
name|b
index|[
name|mini
index|]
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|strcoll
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|a
index|[
name|mini
index|]
operator|=
name|sa
expr_stmt|;
name|b
index|[
name|mini
index|]
operator|=
name|sb
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Usage: %s [OPTION]... [FILE]...\n\ "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Write sorted concatenation of all FILE(s) to standard output.\n\ \n\   +POS1 [-POS2]    start a key at POS1, end it before POS2\n\   -M               compare (unknown)< `JAN'< ...< `DEC', imply -b\n\   -T DIRECT        use DIRECT for temporary files, not $TMPDIR or %s\n\   -b               ignore leading blanks in sort fields or keys\n\   -c               check if given files already sorted, do not sort\n\   -d               consider only [a-zA-Z0-9 ] characters in keys\n\   -f               fold lower case to upper case characters in keys\n\   -g               compare according to general numerical value, imply -b\n\   -i               consider only [\\040-\\0176] characters in keys\n\   -k POS1[,POS2]   same as +POS1 [-POS2], but all positions counted from 1\n\   -m               merge already sorted files, do not sort\n\   -n               compare according to string numerical value, imply -b\n\   -o FILE          write result on FILE instead of standard output\n\   -r               reverse the result of comparisons\n\   -s               stabilize sort by disabling last resort comparison\n\   -t SEP           use SEParator instead of non- to whitespace transition\n\   -u               with -c, check for strict ordering\n\   -u               with -m, only output the first of an equal sequence\n\       --help       display this help and exit\n\       --version    output version information and exit\n\ \n\ POS is F[.C][OPTS], where F is the field number and C the character\n\ position in the field, both counted from zero.  OPTS is made up of one\n\ or more of Mbdfinr, this effectively disable global -Mbdfinr settings\n\ for that key.  If no key given, use the entire line as key.  With no\n\ FILE, or when FILE is -, read standard input.\n\ "
argument_list|)
argument_list|,
name|DEFAULT_TMPDIR
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The list of temporary files. */
end_comment

begin_struct
specifier|static
struct|struct
name|tempnode
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|next
decl_stmt|;
block|}
name|temphead
struct|;
end_struct

begin_comment
comment|/* Clean up any remaining temporary files. */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|temphead
operator|.
name|next
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|unlink
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate N bytes of memory dynamically, with error checking.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Change the size of an allocated block of memory P to N bytes,    with error checking.    If P is NULL, run xmalloc.    If N is 0, run free and return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
name|xmalloc
argument_list|(
name|n
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|xtmpfopen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|xfopen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|how
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
name|how
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xfclose
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
block|{
comment|/* Allow reading stdin from tty more than once. */
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|==
name|stdout
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"flushing file"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"error closing file"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xfwrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|nelem
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|nelem
argument_list|,
name|fp
argument_list|)
operator|!=
name|nelem
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"write error"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a name for a temporary file. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tempname
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|temp_file_prefix
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
literal|"sort"
argument_list|)
operator|-
literal|1
operator|+
literal|5
operator|+
literal|5
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
operator|(
expr|struct
name|tempnode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tempnode
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%ssortXXXXXX"
argument_list|,
name|temp_file_prefix
argument_list|,
operator|(
name|len
operator|&&
name|temp_file_prefix
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|?
literal|"/"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"mkstemp error"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|node
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|temphead
operator|.
name|next
expr_stmt|;
name|temphead
operator|.
name|next
operator|=
name|node
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Search through the list of temporary files for NAME;    remove it if it is found on the list. */
end_comment

begin_function
specifier|static
name|void
name|zaptemp
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|node
operator|=
operator|&
name|temphead
init|;
name|node
operator|->
name|next
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|node
operator|->
name|next
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|next
condition|)
block|{
name|temp
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|unlink
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the character class tables. */
end_comment

begin_function
specifier|static
name|void
name|inittables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UCHAR_LIM
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ISBLANK
argument_list|(
name|i
argument_list|)
condition|)
name|blanks
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|i
argument_list|)
condition|)
name|digits
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|i
argument_list|)
condition|)
name|nonprinting
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|ISBLANK
argument_list|(
name|i
argument_list|)
condition|)
name|nondictionary
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISLOWER
argument_list|(
name|i
argument_list|)
condition|)
name|fold_toupper
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|fold_toupper
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize BUF, allocating ALLOC bytes initially. */
end_comment

begin_function
specifier|static
name|void
name|initbuf
parameter_list|(
name|struct
name|buffer
modifier|*
name|buf
parameter_list|,
name|int
name|alloc
parameter_list|)
block|{
name|buf
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|buf
operator|->
name|left
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill BUF reading from FP, moving buf->left bytes from the end    of buf->buf to the beginning first.	If EOF is reached and the    file wasn't terminated by a newline, supply one.  Return a count    of bytes buffered. */
end_comment

begin_function
specifier|static
name|int
name|fillbuf
parameter_list|(
name|struct
name|buffer
modifier|*
name|buf
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|memmove
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
operator|-
name|buf
operator|->
name|left
argument_list|,
name|buf
operator|->
name|left
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|buf
operator|->
name|left
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|buf
operator|->
name|used
operator|==
literal|0
operator|||
operator|!
name|memchr
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|,
name|buf
operator|->
name|used
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|used
operator|==
name|buf
operator|->
name|alloc
condition|)
block|{
name|buf
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|fread
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
argument_list|,
literal|1
argument_list|,
name|buf
operator|->
name|alloc
operator|-
name|buf
operator|->
name|used
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"read error"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|used
operator|+=
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
name|buf
operator|->
name|used
operator|&&
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|used
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|used
operator|==
name|buf
operator|->
name|alloc
condition|)
block|{
name|buf
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|used
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
return|return
name|buf
operator|->
name|used
return|;
block|}
end_function

begin_comment
comment|/* Initialize LINES, allocating space for ALLOC lines initially.    LIMIT is the maximum possible number of lines to allocate space    for, ever.  */
end_comment

begin_function
specifier|static
name|void
name|initlines
parameter_list|(
name|struct
name|lines
modifier|*
name|lines
parameter_list|,
name|int
name|alloc
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|lines
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|lines
operator|->
name|lines
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
name|lines
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|lines
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|lines
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the first character of the field specified    by KEY in LINE. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|begfield
parameter_list|(
specifier|const
name|struct
name|line
modifier|*
name|line
parameter_list|,
specifier|const
name|struct
name|keyfield
modifier|*
name|key
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|line
operator|->
name|text
decl_stmt|,
modifier|*
name|lim
init|=
name|ptr
operator|+
name|line
operator|->
name|length
decl_stmt|;
specifier|register
name|int
name|sword
init|=
name|key
operator|->
name|sword
decl_stmt|,
name|schar
init|=
name|key
operator|->
name|schar
decl_stmt|;
if|if
condition|(
name|tab
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|sword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|sword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|schar
operator|<=
name|lim
condition|)
name|ptr
operator|+=
name|schar
expr_stmt|;
else|else
name|ptr
operator|=
name|lim
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Return the limit of (a pointer to the first character after) the field    in LINE specified by KEY. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|limfield
parameter_list|(
specifier|const
name|struct
name|line
modifier|*
name|line
parameter_list|,
specifier|const
name|struct
name|keyfield
modifier|*
name|key
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|line
operator|->
name|text
decl_stmt|,
modifier|*
name|lim
init|=
name|ptr
operator|+
name|line
operator|->
name|length
decl_stmt|;
specifier|register
name|int
name|eword
init|=
name|key
operator|->
name|eword
decl_stmt|,
name|echar
init|=
name|key
operator|->
name|echar
decl_stmt|;
comment|/* Note: from the POSIX spec:      The leading field separator itself is included in      a field when -t is not used.  FIXME: move this comment up... */
comment|/* Move PTR past EWORD fields or to one past the last byte on LINE,      whichever comes first.  If there are more than EWORD fields, leave      PTR pointing at the beginning of the field having zero-based index,      EWORD.  If a delimiter character was specified (via -t), then that      `beginning' is the first character following the delimiting TAB.      Otherwise, leave PTR pointing at the first `blank' character after      the preceding field.  */
if|if
condition|(
name|tab
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|eword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|(
name|eword
operator|||
name|echar
operator|>
literal|0
operator|)
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|eword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
comment|/* Make LIM point to the end of (one byte past) the current field.  */
if|if
condition|(
name|tab
condition|)
block|{
name|char
modifier|*
name|newlim
decl_stmt|;
name|newlim
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
name|tab
argument_list|,
name|lim
operator|-
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlim
condition|)
name|lim
operator|=
name|newlim
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|newlim
decl_stmt|;
name|newlim
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|newlim
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|newlim
argument_list|)
index|]
condition|)
operator|++
name|newlim
expr_stmt|;
while|while
condition|(
name|newlim
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|newlim
argument_list|)
index|]
condition|)
operator|++
name|newlim
expr_stmt|;
name|lim
operator|=
name|newlim
expr_stmt|;
block|}
comment|/* If we're skipping leading blanks, don't start counting characters      until after skipping past any leading blanks.  */
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
comment|/* Advance PTR by ECHAR (if possible), but no further than LIM.  */
if|if
condition|(
name|ptr
operator|+
name|echar
operator|<=
name|lim
condition|)
name|ptr
operator|+=
name|echar
expr_stmt|;
else|else
name|ptr
operator|=
name|lim
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* FIXME */
end_comment

begin_function
name|void
name|trim_trailing_blanks
parameter_list|(
specifier|const
name|char
modifier|*
name|a_start
parameter_list|,
name|char
modifier|*
modifier|*
name|a_end
parameter_list|)
block|{
while|while
condition|(
operator|*
name|a_end
operator|>
name|a_start
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
operator|(
operator|*
name|a_end
operator|-
literal|1
operator|)
argument_list|)
index|]
condition|)
operator|--
operator|(
operator|*
name|a_end
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the lines in BUF, storing pointers and lengths in LINES.    Also replace newlines in BUF with NULs. */
end_comment

begin_function
specifier|static
name|void
name|findlines
parameter_list|(
name|struct
name|buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|lines
modifier|*
name|lines
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|beg
init|=
name|buf
operator|->
name|buf
decl_stmt|,
modifier|*
name|lim
init|=
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
init|=
name|keyhead
operator|.
name|next
decl_stmt|;
name|lines
operator|->
name|used
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|beg
operator|<
name|lim
operator|&&
operator|(
name|ptr
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
literal|'\n'
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|)
operator|&&
name|lines
operator|->
name|used
operator|<
name|lines
operator|->
name|limit
condition|)
block|{
comment|/* There are various places in the code that rely on a NUL 	 being at the end of in-core lines; NULs inside the lines 	 will not cause trouble, though. */
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lines
operator|->
name|used
operator|==
name|lines
operator|->
name|alloc
condition|)
block|{
name|lines
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|lines
operator|->
name|lines
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
operator|->
name|lines
argument_list|,
name|lines
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|text
operator|=
name|beg
expr_stmt|;
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|length
operator|=
name|ptr
operator|-
name|beg
expr_stmt|;
comment|/* Precompute the position of the first key for efficiency. */
if|if
condition|(
name|key
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|eword
operator|>=
literal|0
condition|)
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
operator|=
name|limfield
argument_list|(
operator|&
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sword
operator|>=
literal|0
condition|)
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
operator|=
name|begfield
argument_list|(
operator|&
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|beg
argument_list|)
index|]
condition|)
operator|++
name|beg
expr_stmt|;
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
operator|=
name|beg
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|skipeblanks
condition|)
block|{
name|trim_trailing_blanks
argument_list|(
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
argument_list|,
operator|&
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keybeg
operator|=
literal|0
expr_stmt|;
name|lines
operator|->
name|lines
index|[
name|lines
operator|->
name|used
index|]
operator|.
name|keylim
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|lines
operator|->
name|used
expr_stmt|;
name|beg
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
name|buf
operator|->
name|left
operator|=
name|lim
operator|-
name|beg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare strings A and B containing decimal fractions< 1.  Each string    should begin with a decimal point followed immediately by the digits    of the fraction.  Strings not of this form are considered to be zero. */
end_comment

begin_function
specifier|static
name|int
name|fraccompare
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
specifier|register
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|tmpa
operator|==
name|decimal_point
operator|&&
name|tmpb
operator|==
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|tmpa
operator|==
literal|'.'
operator|&&
name|tmpb
operator|==
literal|'.'
condition|)
endif|#
directive|endif
block|{
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|digits
index|[
name|tmpa
index|]
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
operator|&&
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
name|tmpa
operator|-
name|tmpb
return|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
block|{
while|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
block|{
while|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
elseif|else
if|if
condition|(
name|tmpa
operator|==
name|decimal_point
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|tmpa
operator|==
literal|'.'
condition|)
endif|#
directive|endif
block|{
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
elseif|else
if|if
condition|(
name|tmpb
operator|==
name|decimal_point
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|tmpb
operator|==
literal|'.'
condition|)
endif|#
directive|endif
block|{
do|do
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare strings A and B as numbers without explicitly converting them to    machine numbers.  Comparatively slow for short strings, but asymptotically    hideously fast. */
end_comment

begin_function
specifier|static
name|int
name|numcompare
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
specifier|register
name|int
name|tmpa
decl_stmt|,
name|tmpb
decl_stmt|,
name|loga
decl_stmt|,
name|logb
decl_stmt|,
name|tmp
decl_stmt|;
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|tmpa
index|]
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|tmpb
index|]
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpa
operator|==
literal|'-'
condition|)
block|{
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|tmpb
operator|!=
literal|'-'
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|tmpa
operator|==
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|tmpa
operator|==
literal|'.'
condition|)
endif|#
directive|endif
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|tmpb
operator|==
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|tmpb
operator|==
literal|'.'
condition|)
endif|#
directive|endif
do|do
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
do|do
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
do|;
while|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|digits
index|[
name|tmpa
index|]
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
operator|(
name|tmpa
operator|==
name|decimal_point
operator|&&
operator|!
name|digits
index|[
name|tmpb
index|]
operator|)
operator|||
operator|(
name|tmpb
operator|==
name|decimal_point
operator|&&
operator|!
name|digits
index|[
name|tmpa
index|]
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|tmpa
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpb
index|]
operator|)
operator|||
operator|(
name|tmpb
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpa
index|]
operator|)
condition|)
endif|#
directive|endif
return|return
operator|-
name|fraccompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
for|for
control|(
name|loga
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
index|]
condition|;
operator|++
name|loga
control|)
empty_stmt|;
else|else
name|loga
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
for|for
control|(
name|logb
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
index|]
condition|;
operator|++
name|logb
control|)
empty_stmt|;
else|else
name|logb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|logb
operator|-
name|loga
operator|)
operator|!=
literal|0
condition|)
return|return
name|tmp
return|;
if|if
condition|(
operator|!
name|loga
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__FreeBSD__
return|return
name|COLLDIFF
argument_list|(
name|tmpb
argument_list|,
name|tmpa
argument_list|)
return|;
else|#
directive|else
return|return
name|tmpb
operator|-
name|tmpa
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|tmpb
operator|==
literal|'-'
condition|)
block|{
do|do
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
do|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|tmpb
operator|==
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|tmpb
operator|==
literal|'.'
condition|)
endif|#
directive|endif
do|do
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|tmpa
operator|==
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|tmpa
operator|==
literal|'.'
condition|)
endif|#
directive|endif
do|do
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
do|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|tmpa
operator|==
literal|'0'
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpb
operator|==
literal|'0'
condition|)
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|digits
index|[
name|tmpa
index|]
condition|)
name|tmpa
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
operator|,
name|tmpb
operator|=
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
operator|(
name|tmpa
operator|==
name|decimal_point
operator|&&
operator|!
name|digits
index|[
name|tmpb
index|]
operator|)
operator|||
operator|(
name|tmpb
operator|==
name|decimal_point
operator|&&
operator|!
name|digits
index|[
name|tmpa
index|]
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|tmpa
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpb
index|]
operator|)
operator|||
operator|(
name|tmpb
operator|==
literal|'.'
operator|&&
operator|!
name|digits
index|[
name|tmpa
index|]
operator|)
condition|)
endif|#
directive|endif
return|return
name|fraccompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|digits
index|[
name|tmpa
index|]
condition|)
for|for
control|(
name|loga
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|a
argument_list|)
index|]
condition|;
operator|++
name|loga
control|)
empty_stmt|;
else|else
name|loga
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|tmpb
index|]
condition|)
for|for
control|(
name|logb
operator|=
literal|1
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
operator|++
name|b
argument_list|)
index|]
condition|;
operator|++
name|logb
control|)
empty_stmt|;
else|else
name|logb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|loga
operator|-
name|logb
operator|)
operator|!=
literal|0
condition|)
return|return
name|tmp
return|;
if|if
condition|(
operator|!
name|loga
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__FreeBSD__
return|return
name|COLLDIFF
argument_list|(
name|tmpa
argument_list|,
name|tmpb
argument_list|)
return|;
else|#
directive|else
return|return
name|tmpa
operator|-
name|tmpb
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|general_numcompare
parameter_list|(
specifier|const
name|char
modifier|*
name|sa
parameter_list|,
specifier|const
name|char
modifier|*
name|sb
parameter_list|)
block|{
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
comment|/* FIXME: add option to warn about failed conversions.  */
comment|/* FIXME: maybe add option to try expensive FP conversion      only if A and B can't be compared more cheaply/accurately.  */
if|if
condition|(
name|xstrtod
argument_list|(
name|sa
argument_list|,
name|NULL
argument_list|,
operator|&
name|a
argument_list|)
condition|)
block|{
name|a
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xstrtod
argument_list|(
name|sb
argument_list|,
name|NULL
argument_list|,
operator|&
name|b
argument_list|)
condition|)
block|{
name|b
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|a
operator|==
name|b
condition|?
literal|0
else|:
name|a
operator|<
name|b
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return an integer<= 12 associated with month name S with length LEN,    0 if the name in S is not recognized. */
end_comment

begin_function
specifier|static
name|int
name|getmonth
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|month
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
literal|12
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
operator|++
name|s
operator|,
operator|--
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
name|month
index|[
name|i
index|]
operator|=
name|fold_toupper
index|[
name|UCHAR
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
name|month
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|hi
operator|-
name|lo
operator|>
literal|1
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|month
argument_list|,
name|monthtab
index|[
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
index|]
operator|.
name|name
argument_list|)
operator|<
literal|0
condition|)
name|hi
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|lo
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|month
argument_list|,
name|monthtab
index|[
name|lo
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|monthtab
index|[
name|lo
index|]
operator|.
name|val
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare two lines A and B trying every key in sequence until there    are no more keys or a difference is found. */
end_comment

begin_function
specifier|static
name|int
name|keycompare
parameter_list|(
specifier|const
name|struct
name|line
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|line
modifier|*
name|b
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|texta
decl_stmt|,
modifier|*
name|textb
decl_stmt|,
modifier|*
name|lima
decl_stmt|,
modifier|*
name|limb
decl_stmt|,
modifier|*
name|translate
decl_stmt|;
specifier|register
name|int
modifier|*
name|ignore
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
name|int
name|diff
init|=
literal|0
decl_stmt|,
name|iter
init|=
literal|0
decl_stmt|,
name|lena
decl_stmt|,
name|lenb
decl_stmt|;
for|for
control|(
name|key
operator|=
name|keyhead
operator|.
name|next
init|;
name|key
condition|;
name|key
operator|=
name|key
operator|->
name|next
operator|,
operator|++
name|iter
control|)
block|{
name|ignore
operator|=
name|key
operator|->
name|ignore
expr_stmt|;
name|translate
operator|=
name|key
operator|->
name|translate
expr_stmt|;
comment|/* Find the beginning and limit of each field. */
if|if
condition|(
name|iter
operator|||
name|a
operator|->
name|keybeg
operator|==
name|NULL
operator|||
name|b
operator|->
name|keybeg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|eword
operator|>=
literal|0
condition|)
name|lima
operator|=
name|limfield
argument_list|(
name|a
argument_list|,
name|key
argument_list|)
operator|,
name|limb
operator|=
name|limfield
argument_list|(
name|b
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|lima
operator|=
name|a
operator|->
name|text
operator|+
name|a
operator|->
name|length
operator|,
name|limb
operator|=
name|b
operator|->
name|text
operator|+
name|b
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sword
operator|>=
literal|0
condition|)
name|texta
operator|=
name|begfield
argument_list|(
name|a
argument_list|,
name|key
argument_list|)
operator|,
name|textb
operator|=
name|begfield
argument_list|(
name|b
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|texta
operator|=
name|a
operator|->
name|text
operator|,
name|textb
operator|=
name|b
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
block|{
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
condition|)
operator|++
name|texta
expr_stmt|;
while|while
condition|(
name|textb
operator|<
name|limb
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
condition|)
operator|++
name|textb
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the first iteration only, the key positions have 	     been precomputed for us. */
name|texta
operator|=
name|a
operator|->
name|keybeg
operator|,
name|lima
operator|=
name|a
operator|->
name|keylim
expr_stmt|;
name|textb
operator|=
name|b
operator|->
name|keybeg
operator|,
name|limb
operator|=
name|b
operator|->
name|keylim
expr_stmt|;
block|}
comment|/* Find the lengths. */
name|lena
operator|=
name|lima
operator|-
name|texta
operator|,
name|lenb
operator|=
name|limb
operator|-
name|textb
expr_stmt|;
if|if
condition|(
name|lena
operator|<
literal|0
condition|)
name|lena
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lenb
operator|<
literal|0
condition|)
name|lenb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|skipeblanks
condition|)
block|{
name|char
modifier|*
name|a_end
init|=
name|texta
operator|+
name|lena
decl_stmt|;
name|char
modifier|*
name|b_end
init|=
name|textb
operator|+
name|lenb
decl_stmt|;
name|trim_trailing_blanks
argument_list|(
name|texta
argument_list|,
operator|&
name|a_end
argument_list|)
expr_stmt|;
name|trim_trailing_blanks
argument_list|(
name|textb
argument_list|,
operator|&
name|b_end
argument_list|)
expr_stmt|;
name|lena
operator|=
name|a_end
operator|-
name|texta
expr_stmt|;
name|lenb
operator|=
name|b_end
operator|-
name|textb
expr_stmt|;
block|}
comment|/* Actually compare the fields. */
if|if
condition|(
name|key
operator|->
name|numeric
condition|)
block|{
if|if
condition|(
operator|*
name|lima
operator|||
operator|*
name|limb
condition|)
block|{
name|char
name|savea
init|=
operator|*
name|lima
decl_stmt|,
name|saveb
init|=
operator|*
name|limb
decl_stmt|;
operator|*
name|lima
operator|=
operator|*
name|limb
operator|=
literal|'\0'
expr_stmt|;
name|diff
operator|=
name|numcompare
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|)
expr_stmt|;
operator|*
name|lima
operator|=
name|savea
operator|,
operator|*
name|limb
operator|=
name|saveb
expr_stmt|;
block|}
else|else
name|diff
operator|=
name|numcompare
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|key
operator|->
name|general_numeric
condition|)
block|{
if|if
condition|(
operator|*
name|lima
operator|||
operator|*
name|limb
condition|)
block|{
name|char
name|savea
init|=
operator|*
name|lima
decl_stmt|,
name|saveb
init|=
operator|*
name|limb
decl_stmt|;
operator|*
name|lima
operator|=
operator|*
name|limb
operator|=
literal|'\0'
expr_stmt|;
name|diff
operator|=
name|general_numcompare
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|)
expr_stmt|;
operator|*
name|lima
operator|=
name|savea
operator|,
operator|*
name|limb
operator|=
name|saveb
expr_stmt|;
block|}
else|else
name|diff
operator|=
name|general_numcompare
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|key
operator|->
name|month
condition|)
block|{
name|diff
operator|=
name|getmonth
argument_list|(
name|texta
argument_list|,
name|lena
argument_list|)
operator|-
name|getmonth
argument_list|(
name|textb
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ignore
operator|&&
name|translate
condition|)
ifdef|#
directive|ifdef
name|__FreeBSD__
define|#
directive|define
name|CMP_FUNC
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|COLLDIFF ((A), (B))
else|#
directive|else
define|#
directive|define
name|CMP_FUNC
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(A) - (B)
endif|#
directive|endif
define|#
directive|define
name|CMP_WITH_IGNORE
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
define|\
value|do									\     {									\ 	  while (texta< lima&& textb< limb)				\ 	    {								\ 	      while (texta< lima&& ignore[UCHAR (*texta)])		\ 		++texta;						\ 	      while (textb< limb&& ignore[UCHAR (*textb)])		\ 		++textb;						\ 	      if (texta< lima&& textb< limb)				\ 		{							\ 		  if ((A) != (B))					\ 		    {							\ 		      diff = CMP_FUNC((A), (B));                        \ 		      break;						\ 		    }							\ 		  ++texta;						\ 		  ++textb;						\ 		}							\ 									\ 	      if (texta == lima&& textb< limb&& !ignore[UCHAR (*textb)]) \ 		diff = -1;						\ 	      else if (texta< lima&& textb == limb			\&& !ignore[UCHAR (*texta)])			\ 		diff = 1;						\ 	    }								\ 									\ 	  if (diff == 0)						\ 	    {								\ 	      while (texta< lima&& ignore[UCHAR (*texta)])		\ 		++texta;						\ 	      while (textb< limb&& ignore[UCHAR (*textb)])		\ 		++textb;						\ 									\ 	      if (texta == lima&& textb< limb)			\ 		diff = -1;						\ 	      else if (texta< lima&& textb == limb)			\ 		diff = 1;						\ 	    }								\
comment|/* Relative lengths are meaningless if characters were ignored.  \ 	     Handling this case here avoids what might be an invalid length  \ 	     comparison below.  */
value|\ 	  if (diff == 0&& texta == lima&& textb == limb)		\ 	    return 0;							\     }									\   while (0)
name|CMP_WITH_IGNORE
argument_list|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
argument_list|,
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ignore
condition|)
name|CMP_WITH_IGNORE
argument_list|(
operator|*
name|texta
argument_list|,
operator|*
name|textb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|translate
condition|)
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
condition|)
block|{
if|if
condition|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
operator|++
argument_list|)
index|]
operator|!=
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
operator|++
argument_list|)
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|diff
operator|=
name|COLLDIFF
argument_list|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|texta
argument_list|)
index|]
argument_list|,
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|textb
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|diff
operator|=
operator|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|texta
argument_list|)
index|]
operator|-
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
operator|--
name|textb
argument_list|)
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
else|else
ifdef|#
directive|ifdef
name|__FreeBSD__
name|diff
operator|=
name|collcmp
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|,
name|min
argument_list|(
name|lena
argument_list|,
name|lenb
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|diff
operator|=
name|memcmp
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|,
name|min
argument_list|(
name|lena
argument_list|,
name|lenb
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|diff
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
if|if
condition|(
operator|(
name|diff
operator|=
name|lena
operator|-
name|lenb
operator|)
operator|!=
literal|0
condition|)
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare two lines A and B, returning negative, zero, or positive    depending on whether A compares less than, equal to, or greater than B. */
end_comment

begin_function
specifier|static
name|int
name|compare
parameter_list|(
specifier|register
specifier|const
name|struct
name|line
modifier|*
name|a
parameter_list|,
specifier|register
specifier|const
name|struct
name|line
modifier|*
name|b
parameter_list|)
block|{
name|int
name|diff
decl_stmt|,
name|tmpa
decl_stmt|,
name|tmpb
decl_stmt|,
name|mini
decl_stmt|;
comment|/* First try to compare on the specified keys (if any).      The only two cases with no key at all are unadorned sort,      and unadorned sort -r. */
if|if
condition|(
name|keyhead
operator|.
name|next
condition|)
block|{
name|diff
operator|=
name|keycompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
if|if
condition|(
name|unique
operator|||
name|stable
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the keys all compare equal (or no keys were specified)      fall through to the default byte-by-byte comparison. */
name|tmpa
operator|=
name|a
operator|->
name|length
operator|,
name|tmpb
operator|=
name|b
operator|->
name|length
expr_stmt|;
name|mini
operator|=
name|min
argument_list|(
name|tmpa
argument_list|,
name|tmpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mini
operator|==
literal|0
condition|)
name|diff
operator|=
name|tmpa
operator|-
name|tmpb
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|ap
init|=
name|a
operator|->
name|text
decl_stmt|,
modifier|*
name|bp
init|=
name|b
operator|->
name|text
decl_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|diff
operator|=
name|UCHAR
argument_list|(
operator|*
name|ap
argument_list|)
operator|-
name|UCHAR
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
name|diff
operator|=
name|collcmp
argument_list|(
name|ap
argument_list|,
name|bp
argument_list|,
name|mini
argument_list|)
expr_stmt|;
else|#
directive|else
name|diff
operator|=
name|memcmp
argument_list|(
name|ap
argument_list|,
name|bp
argument_list|,
name|mini
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
name|diff
operator|=
name|tmpa
operator|-
name|tmpb
expr_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
block|}
endif|#
directive|endif
block|}
return|return
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Check that the lines read from the given FP come in order.  Return    1 if they do and 0 if there is a disorder.    FIXME: return number of first out-of-order line if not sorted.  */
end_comment

begin_function
specifier|static
name|int
name|checkfp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|buffer
name|buf
decl_stmt|;
comment|/* Input buffer. */
name|struct
name|lines
name|lines
decl_stmt|;
comment|/* Lines scanned from the buffer. */
name|struct
name|line
name|temp
decl_stmt|;
comment|/* Copy of previous line. */
name|int
name|cc
decl_stmt|;
comment|/* Character count. */
name|int
name|alloc
decl_stmt|,
name|sorted
init|=
literal|1
decl_stmt|;
name|initbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|mergealloc
argument_list|)
expr_stmt|;
name|initlines
argument_list|(
operator|&
name|lines
argument_list|,
name|mergealloc
operator|/
name|linelength
operator|+
literal|1
argument_list|,
name|LINEALLOC
operator|/
operator|(
operator|(
name|NMERGE
operator|+
name|NMERGE
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|linelength
expr_stmt|;
name|temp
operator|.
name|text
operator|=
name|xmalloc
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
goto|goto
name|finish
goto|;
name|findlines
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|line
modifier|*
name|prev_line
decl_stmt|;
comment|/* Pointer to previous line. */
name|int
name|cmp
decl_stmt|;
comment|/* Result of calling compare. */
name|int
name|i
decl_stmt|;
comment|/* Compare each line in the buffer with its successor. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|.
name|used
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|cmp
operator|=
name|compare
argument_list|(
operator|&
name|lines
operator|.
name|lines
index|[
name|i
index|]
argument_list|,
operator|&
name|lines
operator|.
name|lines
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unique
operator|&&
name|cmp
operator|>=
literal|0
operator|)
operator|||
operator|(
name|cmp
operator|>
literal|0
operator|)
condition|)
block|{
name|sorted
operator|=
literal|0
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
comment|/* Save the last line of the buffer and refill the buffer. */
name|prev_line
operator|=
name|lines
operator|.
name|lines
operator|+
operator|(
name|lines
operator|.
name|used
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|prev_line
operator|->
name|length
operator|>
name|alloc
condition|)
block|{
while|while
condition|(
name|prev_line
operator|->
name|length
operator|+
literal|1
operator|>
name|alloc
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
name|temp
operator|.
name|text
operator|=
name|xrealloc
argument_list|(
name|temp
operator|.
name|text
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|temp
operator|.
name|text
argument_list|,
name|prev_line
operator|->
name|text
argument_list|,
name|prev_line
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|.
name|length
operator|=
name|prev_line
operator|->
name|length
expr_stmt|;
name|temp
operator|.
name|keybeg
operator|=
name|temp
operator|.
name|text
operator|+
operator|(
name|prev_line
operator|->
name|keybeg
operator|-
name|prev_line
operator|->
name|text
operator|)
expr_stmt|;
name|temp
operator|.
name|keylim
operator|=
name|temp
operator|.
name|text
operator|+
operator|(
name|prev_line
operator|->
name|keylim
operator|-
name|prev_line
operator|->
name|text
operator|)
expr_stmt|;
name|cc
operator|=
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
break|break;
name|findlines
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
comment|/* Make sure the line saved from the old buffer contents is 	 less than or equal to the first line of the new buffer. */
name|cmp
operator|=
name|compare
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|lines
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unique
operator|&&
name|cmp
operator|>=
literal|0
operator|)
operator|||
operator|(
name|cmp
operator|>
literal|0
operator|)
condition|)
block|{
name|sorted
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|finish
label|:
name|xfclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
operator|.
name|lines
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
name|sorted
return|;
block|}
end_function

begin_comment
comment|/* Merge lines from FPS onto OFP.  NFPS cannot be greater than NMERGE.    Close FPS before returning. */
end_comment

begin_function
specifier|static
name|void
name|mergefps
parameter_list|(
name|FILE
modifier|*
modifier|*
name|fps
parameter_list|,
specifier|register
name|int
name|nfps
parameter_list|,
name|FILE
modifier|*
name|ofp
parameter_list|)
block|{
name|struct
name|buffer
name|buffer
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Input buffers for each file. */
name|struct
name|lines
name|lines
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Line tables for each buffer. */
name|struct
name|line
name|saved
decl_stmt|;
comment|/* Saved line for unique check. */
name|int
name|savedflag
init|=
literal|0
decl_stmt|;
comment|/* True if there is a saved line. */
name|int
name|savealloc
decl_stmt|;
comment|/* Size allocated for the saved line. */
name|int
name|cur
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Current line in each line table. */
name|int
name|ord
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Table representing a permutation of fps, 				   such that lines[ord[0]].lines[cur[ord[0]]] 				   is the smallest line and will be next 				   output. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
comment|/* Suppress `used before initialized' warning.  */
name|savealloc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate space for a saved line if necessary. */
if|if
condition|(
name|unique
condition|)
block|{
name|savealloc
operator|=
name|linelength
expr_stmt|;
name|saved
operator|.
name|text
operator|=
name|xmalloc
argument_list|(
name|savealloc
argument_list|)
expr_stmt|;
block|}
comment|/* Read initial lines from each input file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
block|{
name|initbuf
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|mergealloc
argument_list|)
expr_stmt|;
comment|/* If a file is empty, eliminate it from future consideration. */
while|while
condition|(
name|i
operator|<
name|nfps
operator|&&
operator|!
name|fillbuf
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|fps
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|xfclose
argument_list|(
name|fps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|--
name|nfps
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nfps
condition|;
operator|++
name|j
control|)
name|fps
index|[
name|j
index|]
operator|=
name|fps
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|nfps
condition|)
name|free
argument_list|(
name|buffer
index|[
name|i
index|]
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|initlines
argument_list|(
operator|&
name|lines
index|[
name|i
index|]
argument_list|,
name|mergealloc
operator|/
name|linelength
operator|+
literal|1
argument_list|,
name|LINEALLOC
operator|/
operator|(
operator|(
name|NMERGE
operator|+
name|NMERGE
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|findlines
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
operator|&
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cur
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set up the ord table according to comparisons among input lines.      Since this only reorders two items if one is strictly greater than      the other, it is stable. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
name|ord
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|compare
argument_list|(
operator|&
name|lines
index|[
name|ord
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
name|i
operator|-
literal|1
index|]
index|]
index|]
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
name|i
index|]
index|]
index|]
argument_list|)
operator|>
literal|0
condition|)
name|t
operator|=
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|,
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|ord
index|[
name|i
index|]
operator|,
name|ord
index|[
name|i
index|]
operator|=
name|t
operator|,
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Repeatedly output the smallest line until no input remains. */
while|while
condition|(
name|nfps
condition|)
block|{
comment|/* If uniqified output is turned on, output only the first of 	 an identical series of lines. */
if|if
condition|(
name|unique
condition|)
block|{
if|if
condition|(
name|savedflag
operator|&&
name|compare
argument_list|(
operator|&
name|saved
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
argument_list|)
condition|)
block|{
name|xfwrite
argument_list|(
name|saved
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|saved
operator|.
name|length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|savedflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|savedflag
condition|)
block|{
if|if
condition|(
name|savealloc
operator|<
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
operator|+
literal|1
condition|)
block|{
while|while
condition|(
name|savealloc
operator|<
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
operator|+
literal|1
condition|)
name|savealloc
operator|*=
literal|2
expr_stmt|;
name|saved
operator|.
name|text
operator|=
name|xrealloc
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|savealloc
argument_list|)
expr_stmt|;
block|}
name|saved
operator|.
name|length
operator|=
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
argument_list|,
name|saved
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keybeg
operator|!=
name|NULL
condition|)
block|{
name|saved
operator|.
name|keybeg
operator|=
name|saved
operator|.
name|text
operator|+
operator|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keybeg
operator|-
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keylim
operator|!=
name|NULL
condition|)
block|{
name|saved
operator|.
name|keylim
operator|=
name|saved
operator|.
name|text
operator|+
operator|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|keylim
operator|-
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
operator|)
expr_stmt|;
block|}
name|savedflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|xfwrite
argument_list|(
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
operator|.
name|length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
comment|/* Check if we need to read more lines into core. */
if|if
condition|(
operator|++
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|==
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|used
condition|)
if|if
condition|(
name|fillbuf
argument_list|(
operator|&
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
name|fps
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
condition|)
block|{
name|findlines
argument_list|(
operator|&
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We reached EOF on fps[ord[0]]. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ord
index|[
name|i
index|]
operator|>
name|ord
index|[
literal|0
index|]
condition|)
operator|--
name|ord
index|[
name|i
index|]
expr_stmt|;
operator|--
name|nfps
expr_stmt|;
name|xfclose
argument_list|(
name|fps
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ord
index|[
literal|0
index|]
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
block|{
name|fps
index|[
name|i
index|]
operator|=
name|fps
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|buffer
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|lines
index|[
name|i
index|]
operator|=
name|lines
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|cur
index|[
name|i
index|]
operator|=
name|cur
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* The new line just read in may be larger than other lines 	 already in core; push it back in the queue until we encounter 	 a line larger than it. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfps
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|=
name|compare
argument_list|(
operator|&
name|lines
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
index|]
argument_list|,
operator|&
name|lines
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|lines
index|[
name|cur
index|[
name|ord
index|[
name|i
index|]
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|ord
index|[
literal|0
index|]
operator|-
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
break|break;
block|}
name|t
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|ord
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|unique
operator|&&
name|savedflag
condition|)
block|{
name|xfwrite
argument_list|(
name|saved
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|saved
operator|.
name|length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sort the array LINES with NLINES members, using TEMP for temporary space. */
end_comment

begin_function
specifier|static
name|void
name|sortlines
parameter_list|(
name|struct
name|line
modifier|*
name|lines
parameter_list|,
name|int
name|nlines
parameter_list|,
name|struct
name|line
modifier|*
name|temp
parameter_list|)
block|{
specifier|register
name|struct
name|line
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|nlo
decl_stmt|,
name|nhi
decl_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|compare
argument_list|(
operator|&
name|lines
index|[
literal|0
index|]
argument_list|,
operator|&
name|lines
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
condition|)
operator|*
name|temp
operator|=
name|lines
index|[
literal|0
index|]
operator|,
name|lines
index|[
literal|0
index|]
operator|=
name|lines
index|[
literal|1
index|]
operator|,
name|lines
index|[
literal|1
index|]
operator|=
operator|*
name|temp
expr_stmt|;
return|return;
block|}
name|nlo
operator|=
name|nlines
operator|/
literal|2
expr_stmt|;
name|lo
operator|=
name|lines
expr_stmt|;
name|nhi
operator|=
name|nlines
operator|-
name|nlo
expr_stmt|;
name|hi
operator|=
name|lines
operator|+
name|nlo
expr_stmt|;
if|if
condition|(
name|nlo
operator|>
literal|1
condition|)
name|sortlines
argument_list|(
name|lo
argument_list|,
name|nlo
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhi
operator|>
literal|1
condition|)
name|sortlines
argument_list|(
name|hi
argument_list|,
name|nhi
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|t
operator|=
name|temp
expr_stmt|;
while|while
condition|(
name|nlo
operator|&&
name|nhi
condition|)
if|if
condition|(
name|compare
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
operator|<=
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|lo
operator|++
operator|,
operator|--
name|nlo
expr_stmt|;
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|hi
operator|++
operator|,
operator|--
name|nhi
expr_stmt|;
while|while
condition|(
name|nlo
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|lo
operator|++
expr_stmt|;
for|for
control|(
name|lo
operator|=
name|lines
operator|,
name|nlo
operator|=
name|nlines
operator|-
name|nhi
operator|,
name|t
operator|=
name|temp
init|;
name|nlo
condition|;
operator|--
name|nlo
control|)
operator|*
name|lo
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that each of the NFILES FILES is ordered.    Return a count of disordered files. */
end_comment

begin_function
specifier|static
name|int
name|check
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|disorders
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
block|{
name|fp
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkfp
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: disorder on %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|disorders
expr_stmt|;
block|}
block|}
return|return
name|disorders
return|;
block|}
end_function

begin_comment
comment|/* Merge NFILES FILES onto OFP. */
end_comment

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|FILE
modifier|*
name|ofp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|FILE
modifier|*
name|fps
index|[
name|NMERGE
index|]
decl_stmt|,
modifier|*
name|tfp
decl_stmt|;
while|while
condition|(
name|nfiles
operator|>
name|NMERGE
condition|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
operator|/
name|NMERGE
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMERGE
condition|;
operator|++
name|j
control|)
name|fps
index|[
name|j
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xtmpfopen
argument_list|(
name|temp
operator|=
name|tempname
argument_list|()
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
name|fps
argument_list|,
name|NMERGE
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMERGE
condition|;
operator|++
name|j
control|)
name|zaptemp
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|files
index|[
name|t
operator|++
index|]
operator|=
name|temp
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nfiles
operator|%
name|NMERGE
condition|;
operator|++
name|j
control|)
name|fps
index|[
name|j
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xtmpfopen
argument_list|(
name|temp
operator|=
name|tempname
argument_list|()
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
name|fps
argument_list|,
name|nfiles
operator|%
name|NMERGE
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nfiles
operator|%
name|NMERGE
condition|;
operator|++
name|j
control|)
name|zaptemp
argument_list|(
name|files
index|[
name|i
operator|*
name|NMERGE
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|files
index|[
name|t
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|nfiles
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
name|fps
index|[
name|i
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
name|fps
argument_list|,
name|i
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
name|zaptemp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort NFILES FILES onto OFP. */
end_comment

begin_function
specifier|static
name|void
name|sort
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|FILE
modifier|*
name|ofp
parameter_list|)
block|{
name|struct
name|buffer
name|buf
decl_stmt|;
name|struct
name|lines
name|lines
decl_stmt|;
name|struct
name|line
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ntmp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|tfp
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
name|int
name|n_temp_files
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempfiles
decl_stmt|;
name|initbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|sortalloc
argument_list|)
expr_stmt|;
name|initlines
argument_list|(
operator|&
name|lines
argument_list|,
name|sortalloc
operator|/
name|linelength
operator|+
literal|1
argument_list|,
name|LINEALLOC
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|lines
operator|.
name|alloc
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntmp
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfiles
operator|--
condition|)
block|{
name|fp
operator|=
name|xfopen
argument_list|(
operator|*
name|files
operator|++
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|findlines
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|.
name|used
operator|>
name|ntmp
condition|)
block|{
while|while
condition|(
name|lines
operator|.
name|used
operator|>
name|ntmp
condition|)
name|ntmp
operator|*=
literal|2
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
name|ntmp
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sortlines
argument_list|(
name|lines
operator|.
name|lines
argument_list|,
name|lines
operator|.
name|used
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|nfiles
operator|&&
operator|!
name|n_temp_files
operator|&&
operator|!
name|buf
operator|.
name|left
condition|)
name|tfp
operator|=
name|ofp
expr_stmt|;
else|else
block|{
operator|++
name|n_temp_files
expr_stmt|;
name|tfp
operator|=
name|xtmpfopen
argument_list|(
name|tempname
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|.
name|used
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|unique
operator|||
name|i
operator|==
literal|0
operator|||
name|compare
argument_list|(
operator|&
name|lines
operator|.
name|lines
index|[
name|i
index|]
argument_list|,
operator|&
name|lines
operator|.
name|lines
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|xfwrite
argument_list|(
name|lines
operator|.
name|lines
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|lines
operator|.
name|lines
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfp
operator|!=
name|ofp
condition|)
name|xfclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
name|xfclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lines
operator|.
name|lines
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_temp_files
condition|)
block|{
name|tempfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_temp_files
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|n_temp_files
expr_stmt|;
for|for
control|(
name|node
operator|=
name|temphead
operator|.
name|next
init|;
name|i
operator|>
literal|0
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|tempfiles
index|[
operator|--
name|i
index|]
operator|=
name|node
operator|->
name|name
expr_stmt|;
name|merge
argument_list|(
name|tempfiles
argument_list|,
name|n_temp_files
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tempfiles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert key KEY at the end of the list (`keyhead'). */
end_comment

begin_function
specifier|static
name|void
name|insertkey
parameter_list|(
name|struct
name|keyfield
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|keyfield
modifier|*
name|k
init|=
operator|&
name|keyhead
decl_stmt|;
while|while
condition|(
name|k
operator|->
name|next
condition|)
name|k
operator|=
name|k
operator|->
name|next
expr_stmt|;
name|k
operator|->
name|next
operator|=
name|key
expr_stmt|;
name|key
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badfieldspec
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"invalid field specification `%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle interrupts and hangups. */
end_comment

begin_function
specifier|static
name|void
name|sighandler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SA_INTERRUPT
name|struct
name|sigaction
name|sigact
decl_stmt|;
name|sigact
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|sigact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SA_INTERRUPT */
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SA_INTERRUPT */
name|cleanup
argument_list|()
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the ordering options for KEY specified in S.    Return the address of the first character in S that    is not a valid ordering option.    BLANKTYPE is the kind of blanks that 'b' should skip. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|set_ordering
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|keyfield
modifier|*
name|key
parameter_list|,
name|enum
name|blanktype
name|blanktype
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|blanktype
operator|==
name|bl_start
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipsblanks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|blanktype
operator|==
name|bl_end
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipeblanks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|key
operator|->
name|ignore
operator|=
name|nondictionary
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|key
operator|->
name|translate
operator|=
name|fold_toupper
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|key
operator|->
name|general_numeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|key
operator|->
name|ignore
operator|=
name|nonprinting
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|key
operator|->
name|month
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|key
operator|->
name|numeric
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|blanktype
operator|==
name|bl_start
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipsblanks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|blanktype
operator|==
name|bl_end
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipeblanks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|key
operator|->
name|reverse
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|keyfield
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
name|gkey
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|checkonly
init|=
literal|0
decl_stmt|,
name|mergeonly
init|=
literal|0
decl_stmt|,
name|nfiles
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|minus
init|=
literal|"-"
decl_stmt|,
modifier|*
name|outfile
init|=
name|minus
decl_stmt|,
modifier|*
modifier|*
name|files
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_INTERRUPT
name|struct
name|sigaction
name|oldact
decl_stmt|,
name|newact
decl_stmt|;
endif|#
directive|endif
comment|/* SA_INTERRUPT */
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|decimal_point
operator|=
name|localeconv
argument_list|()
operator|->
name|decimal_point
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|parse_long_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"sort"
argument_list|,
name|version_string
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|have_read_stdin
operator|=
literal|0
expr_stmt|;
name|inittables
argument_list|()
expr_stmt|;
name|temp_file_prefix
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_file_prefix
operator|==
name|NULL
condition|)
name|temp_file_prefix
operator|=
name|DEFAULT_TMPDIR
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_INTERRUPT
name|newact
operator|.
name|sa_handler
operator|=
name|sighandler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|newact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SA_INTERRUPT */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SA_INTERRUPT */
name|gkey
operator|.
name|sword
operator|=
name|gkey
operator|.
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|gkey
operator|.
name|ignore
operator|=
name|NULL
expr_stmt|;
name|gkey
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
name|gkey
operator|.
name|numeric
operator|=
name|gkey
operator|.
name|general_numeric
operator|=
name|gkey
operator|.
name|month
operator|=
name|gkey
operator|.
name|reverse
operator|=
literal|0
expr_stmt|;
name|gkey
operator|.
name|skipsblanks
operator|=
name|gkey
operator|.
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|key
condition|)
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
expr|struct
name|keyfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keyfield
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|key
operator|->
name|ignore
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|key
operator|->
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|key
operator|->
name|general_numeric
operator|=
name|key
operator|->
name|month
operator|=
name|key
operator|->
name|reverse
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
operator|||
operator|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|digits
index|[
name|UCHAR
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
index|]
operator|)
operator|)
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
literal|10
operator|*
name|t
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
literal|10
operator|*
name|t2
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t2
operator|||
name|t
condition|)
block|{
name|key
operator|->
name|sword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|schar
operator|=
name|t2
expr_stmt|;
block|}
else|else
name|key
operator|->
name|sword
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
name|s
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
operator|||
operator|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|digits
index|[
name|UCHAR
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|key
condition|)
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
name|t
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
name|t2
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
name|key
operator|->
name|eword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|echar
operator|=
name|t2
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
operator|&
name|gkey
argument_list|,
name|bl_both
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'c'
case|:
name|checkonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
operator|++
name|s
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"option `-k' requires an argument"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|key
condition|)
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
expr|struct
name|keyfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keyfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|keyfield
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|key
operator|->
name|ignore
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|key
operator|->
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|key
operator|->
name|month
operator|=
name|key
operator|->
name|reverse
operator|=
literal|0
expr_stmt|;
comment|/* Get POS1. */
if|if
condition|(
operator|!
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
literal|10
operator|*
name|t
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
comment|/* Provoke with `sort -k0' */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"the starting field number argument \ to the `-k' option must be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|--
name|t
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|digits
index|[
name|UCHAR
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
index|]
condition|)
block|{
comment|/* Provoke with `sort -k1.' */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"starting field spec has `.' but \ lacks following character offset"
argument_list|)
argument_list|)
expr_stmt|;
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
literal|10
operator|*
name|t2
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
block|{
comment|/* Provoke with `sort -k1.0' */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"starting field character offset \ argument to the `-k' option\nmust be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|--
name|t2
expr_stmt|;
block|}
if|if
condition|(
name|t2
operator|||
name|t
condition|)
block|{
name|key
operator|->
name|sword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|schar
operator|=
name|t2
expr_stmt|;
block|}
else|else
name|key
operator|->
name|sword
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|key
operator|->
name|echar
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
comment|/* Skip over comma.  */
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
comment|/* Provoke with `sort -k1,' */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"field specification has `,' but \ lacks following field spec"
argument_list|)
argument_list|)
expr_stmt|;
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Get POS2. */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t
operator|=
name|t
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
comment|/* Provoke with `sort -k1,0' */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"ending field number argument \ to the `-k' option must be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|--
name|t
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|digits
index|[
name|UCHAR
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
index|]
condition|)
block|{
comment|/* Provoke with `sort -k1,1.' */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"ending field spec has `.' \ but lacks following character offset"
argument_list|)
argument_list|)
expr_stmt|;
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
operator|++
name|s
init|;
name|digits
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|;
operator|++
name|s
control|)
name|t2
operator|=
name|t2
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
comment|/* `-k 2,3' is equivalent to `+1 -3'.  */
operator|++
name|t
expr_stmt|;
block|}
name|key
operator|->
name|eword
operator|=
name|t
expr_stmt|;
name|key
operator|->
name|echar
operator|=
name|t2
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
goto|goto
name|outer
goto|;
case|case
literal|'m'
case|:
name|mergeonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|outfile
operator|=
name|s
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"option `-o' requires an argument"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outfile
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
goto|goto
name|outer
goto|;
case|case
literal|'s'
case|:
name|stable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|tab
operator|=
operator|*
operator|++
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|tab
operator|=
operator|*
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
goto|goto
name|outer
goto|;
block|}
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"option `-t' requires an argument"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|temp_file_prefix
operator|=
operator|++
name|s
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
name|temp_file_prefix
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"option `-T' requires an argument"
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|outer
goto|;
comment|/* break; */
case|case
literal|'u'
case|:
name|unique
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Accept and ignore e.g. -y0 for compatibility with 		       Solaris 2.  */
goto|goto
name|outer
goto|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `-%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
condition|)
operator|++
name|s
expr_stmt|;
block|}
block|}
else|else
comment|/* Not an option. */
block|{
name|files
index|[
name|nfiles
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|outer
label|:
empty_stmt|;
block|}
if|if
condition|(
name|key
condition|)
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Inheritance of global options to individual keys. */
for|for
control|(
name|key
operator|=
name|keyhead
operator|.
name|next
init|;
name|key
condition|;
name|key
operator|=
name|key
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|key
operator|->
name|ignore
operator|&&
operator|!
name|key
operator|->
name|translate
operator|&&
operator|!
name|key
operator|->
name|skipsblanks
operator|&&
operator|!
name|key
operator|->
name|reverse
operator|&&
operator|!
name|key
operator|->
name|skipeblanks
operator|&&
operator|!
name|key
operator|->
name|month
operator|&&
operator|!
name|key
operator|->
name|numeric
operator|&&
operator|!
name|key
operator|->
name|general_numeric
condition|)
block|{
name|key
operator|->
name|ignore
operator|=
name|gkey
operator|.
name|ignore
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|gkey
operator|.
name|translate
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|gkey
operator|.
name|skipsblanks
expr_stmt|;
name|key
operator|->
name|skipeblanks
operator|=
name|gkey
operator|.
name|skipeblanks
expr_stmt|;
name|key
operator|->
name|month
operator|=
name|gkey
operator|.
name|month
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|gkey
operator|.
name|numeric
expr_stmt|;
name|key
operator|->
name|general_numeric
operator|=
name|gkey
operator|.
name|general_numeric
expr_stmt|;
name|key
operator|->
name|reverse
operator|=
name|gkey
operator|.
name|reverse
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keyhead
operator|.
name|next
operator|&&
operator|(
name|gkey
operator|.
name|ignore
operator|||
name|gkey
operator|.
name|translate
operator|||
name|gkey
operator|.
name|skipsblanks
operator|||
name|gkey
operator|.
name|skipeblanks
operator|||
name|gkey
operator|.
name|month
operator|||
name|gkey
operator|.
name|numeric
operator|||
name|gkey
operator|.
name|general_numeric
operator|)
condition|)
name|insertkey
argument_list|(
operator|&
name|gkey
argument_list|)
expr_stmt|;
name|reverse
operator|=
name|gkey
operator|.
name|reverse
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
block|{
name|nfiles
operator|=
literal|1
expr_stmt|;
name|files
operator|=
operator|&
name|minus
expr_stmt|;
block|}
if|if
condition|(
name|checkonly
condition|)
name|exit
argument_list|(
name|check
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|struct
name|stat
name|outstat
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|outfile
argument_list|,
operator|&
name|outstat
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The following code prevents a race condition when 	     people use the brain dead shell programming idiom: 		  cat file | sort -o file 	     This feature is provided for historical compatibility, 	     but we strongly discourage ever relying on this in 	     new shell programs. */
comment|/* Temporarily copy each input file that might be another name 	     for the output file.  When in doubt (e.g. a pipe), copy.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|outstat
operator|.
name|st_mode
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|outfile
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|struct
name|stat
name|instat
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
condition|?
name|stat
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
operator|&
name|instat
argument_list|)
else|:
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|instat
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|instat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|instat
operator|.
name|st_ino
operator|!=
name|outstat
operator|.
name|st_ino
operator|||
name|instat
operator|.
name|st_dev
operator|!=
name|outstat
operator|.
name|st_dev
operator|)
condition|)
block|{
comment|/* We know the files are distinct.  */
continue|continue;
block|}
block|}
name|fp
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tempname
argument_list|()
expr_stmt|;
name|ofp
operator|=
name|xtmpfopen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|xfwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|cc
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|xfclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|ofp
operator|=
name|xfopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|else
name|ofp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|mergeonly
condition|)
name|merge
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
else|else
name|sort
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
comment|/* If we wait for the implicit flush on exit, and the parent process      has closed stdout (e.g., exec>&- in a shell), then the output file      winds up empty.  I don't understand why.  This is under SunOS,      Solaris, Ultrix, and Irix.  This premature fflush makes the output      reappear. --karl@cs.umb.edu  */
if|if
condition|(
name|fflush
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"%s: write error"
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"%s: write error"
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

