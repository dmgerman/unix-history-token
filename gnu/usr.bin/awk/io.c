begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * io.c --- routines for dealing with input and output and records  */
end_comment

begin_comment
comment|/*   * Copyright (C) 1986, 1988, 1989, 1991, 1992, 1993 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Progamming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with GAWK; see the file COPYING.  If not, write to  * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS_POSIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ENFILE
end_ifndef

begin_define
define|#
directive|define
name|ENFILE
value|EMFILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|atarist
end_ifndef

begin_define
define|#
directive|define
name|INVALID_HANDLE
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INVALID_HANDLE
value|(__SMALLEST_VALID_HANDLE - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
end_if

begin_define
define|#
directive|define
name|PIPES_SIMULATED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|nextfile
name|P
argument_list|(
operator|(
name|int
name|skipping
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inrec
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iop_close
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|redirect
modifier|*
name|redirect
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|,
name|int
operator|*
name|errflg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_one
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|close_redir
name|P
argument_list|(
operator|(
expr|struct
name|redirect
operator|*
name|rp
operator|,
name|int
name|exitwarn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|wait_any
name|P
argument_list|(
operator|(
name|int
name|interesting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
name|P
argument_list|(
operator|(
name|char
operator|*
name|cmd
operator|,
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|iop_open
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|how
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gawk_pclose
name|P
argument_list|(
operator|(
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_pathopen
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|str2mode
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spec_setup
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
name|int
name|len
operator|,
name|int
name|allocate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|specfdopen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pidopen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|useropen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"popen.h"
end_include

begin_define
define|#
directive|define
name|popen
parameter_list|(
name|c
parameter_list|,
name|m
parameter_list|)
value|os_popen(c,m)
end_define

begin_define
define|#
directive|define
name|pclose
parameter_list|(
name|f
parameter_list|)
value|os_pclose(f)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|OS2
argument_list|)
end_elif

begin_comment
comment|/* OS/2, but not family mode */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|popen
parameter_list|(
name|c
parameter_list|,
name|m
parameter_list|)
value|_popen(c,m)
end_define

begin_define
define|#
directive|define
name|pclose
parameter_list|(
name|f
parameter_list|)
value|_pclose(f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|redirect
modifier|*
name|red_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|output_is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGC_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGV_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGIND_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ERRNO_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
modifier|*
name|fields_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|filebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for do_nextfile() */
end_comment

begin_comment
comment|/* do_nextfile --- implement gawk "next file" extension */
end_comment

begin_function
name|void
name|do_nextfile
parameter_list|()
block|{
operator|(
name|void
operator|)
name|nextfile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|filebuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|IOBUF
modifier|*
name|nextfile
parameter_list|(
name|skipping
parameter_list|)
name|int
name|skipping
decl_stmt|;
block|{
specifier|static
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|files
init|=
literal|0
decl_stmt|;
name|NODE
modifier|*
name|arg
decl_stmt|;
specifier|static
name|IOBUF
modifier|*
name|curfile
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|skipping
condition|)
block|{
if|if
condition|(
name|curfile
operator|!=
name|NULL
condition|)
name|iop_close
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|curfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curfile
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|curfile
return|;
block|}
for|for
control|(
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|ARGC_node
operator|->
name|lnode
operator|->
name|numbr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
operator|*
name|assoc_lookup
argument_list|(
name|ARGV_node
argument_list|,
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|arg
operator|->
name|stptr
index|[
name|arg
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|do_unix
condition|)
block|{
name|ARGIND_node
operator|->
name|var_value
operator|->
name|numbr
operator|=
name|i
expr_stmt|;
name|ARGIND_node
operator|->
name|var_value
operator|->
name|flags
operator|=
name|NUM
operator||
name|NUMBER
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arg_assign
argument_list|(
name|arg
operator|->
name|stptr
argument_list|)
condition|)
block|{
name|files
operator|++
expr_stmt|;
name|curfile
operator|=
name|iop_open
argument_list|(
name|arg
operator|->
name|stptr
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfile
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"cannot open file `%s' for reading (%s)"
argument_list|,
name|arg
operator|->
name|stptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
comment|/* This is a kludge.  */
name|unref
argument_list|(
name|FILENAME_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|FILENAME_node
operator|->
name|var_value
operator|=
name|dupnode
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|FNR
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|files
operator|==
literal|0
condition|)
block|{
name|files
operator|++
expr_stmt|;
comment|/* no args. -- use stdin */
comment|/* FNR is init'ed to 0 */
name|FILENAME_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|iop_alloc
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|curfile
return|;
block|}
end_function

begin_function
name|void
name|set_FNR
parameter_list|()
block|{
name|FNR
operator|=
operator|(
name|long
operator|)
name|FNR_node
operator|->
name|var_value
operator|->
name|numbr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_NR
parameter_list|()
block|{
name|NR
operator|=
operator|(
name|long
operator|)
name|NR_node
operator|->
name|var_value
operator|->
name|numbr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This reads in a record from the input file  */
end_comment

begin_function
specifier|static
name|int
name|inrec
parameter_list|(
name|iop
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
block|{
name|char
modifier|*
name|begin
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|cnt
operator|=
name|get_a_record
argument_list|(
operator|&
name|begin
argument_list|,
name|iop
argument_list|,
operator|*
name|RS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|NR
operator|+=
literal|1
expr_stmt|;
name|FNR
operator|+=
literal|1
expr_stmt|;
block|}
name|set_record
argument_list|(
name|begin
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iop_close
parameter_list|(
name|iop
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* Work around bug in UNICOS popen */
if|if
condition|(
name|iop
operator|->
name|fd
operator|<
literal|3
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* save these for re-use; don't free the storage */
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|strlen
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Don't close standard files or else crufty code elsewhere will lose */
if|if
condition|(
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|||
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stdout
argument_list|)
operator|||
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stderr
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|close
argument_list|(
name|iop
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"close of fd %d failed (%s)"
argument_list|,
name|iop
operator|->
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_NO_FREE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * be careful -- $0 may still reference the buffer even though 		 * an explicit close is being done; in the future, maybe we 		 * can do this a bit better 		 */
if|if
condition|(
name|iop
operator|->
name|buf
condition|)
block|{
if|if
condition|(
operator|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|>=
name|iop
operator|->
name|buf
operator|)
operator|&&
operator|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|<
name|iop
operator|->
name|end
operator|)
condition|)
block|{
name|NODE
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|make_string
argument_list|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
argument_list|,
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|fields_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fields_arr
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|reset_record
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iop
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|void
name|do_input
parameter_list|()
block|{
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|extern
name|int
name|exiting
decl_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|iop
operator|=
name|nextfile
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|inrec
argument_list|(
name|iop
argument_list|)
operator|==
literal|0
condition|)
while|while
condition|(
name|interpret
argument_list|(
name|expression_value
argument_list|)
operator|&&
name|inrec
argument_list|(
name|iop
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* recover any space from C based alloca */
operator|(
name|void
operator|)
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exiting
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Redirection for printf and print commands */
end_comment

begin_function
name|struct
name|redirect
modifier|*
name|redirect
parameter_list|(
name|tree
parameter_list|,
name|errflg
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
name|int
modifier|*
name|errflg
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|tflag
init|=
literal|0
decl_stmt|;
name|int
name|outflag
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|direction
init|=
literal|"to"
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_append
case|:
name|tflag
operator|=
name|RED_APPEND
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|Node_redirect_output
case|:
name|outflag
operator|=
operator|(
name|RED_FILE
operator||
name|RED_WRITE
operator|)
expr_stmt|;
name|tflag
operator||=
name|outflag
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_redirect_output
condition|)
name|what
operator|=
literal|">"
expr_stmt|;
else|else
name|what
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
name|tflag
operator|=
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
expr_stmt|;
name|what
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|tflag
operator|=
operator|(
name|RED_PIPE
operator||
name|RED_READ
operator|)
expr_stmt|;
name|what
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|tflag
operator|=
operator|(
name|RED_FILE
operator||
name|RED_READ
operator|)
expr_stmt|;
name|what
operator|=
literal|"<"
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid tree type %d in redirect()"
argument_list|,
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
operator|(
name|tmp
operator|->
name|flags
operator|&
name|STR
operator|)
condition|)
name|warning
argument_list|(
literal|"expression in `%s' redirection only has numeric value"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp
operator|->
name|stptr
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
operator|*
name|str
operator|==
literal|'\0'
condition|)
name|fatal
argument_list|(
literal|"expression for `%s' redirection has null string value"
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"0"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|||
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"1"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"filename `%s' for `%s' redirection may be result of logical expression"
argument_list|,
name|str
argument_list|,
name|what
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|tmp
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|str
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|&&
operator|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|~
operator|(
name|RED_NOBUF
operator||
name|RED_EOF
operator|)
operator|)
operator|==
name|tflag
operator|||
operator|(
name|outflag
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_FILE
operator||
name|RED_WRITE
operator|)
operator|)
operator|==
name|outflag
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|emalloc
argument_list|(
name|rp
argument_list|,
expr|struct
name|redirect
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|redirect
argument_list|)
argument_list|,
literal|"redirect"
argument_list|)
expr_stmt|;
name|emalloc
argument_list|(
name|str
argument_list|,
name|char
operator|*
argument_list|,
name|tmp
operator|->
name|stlen
operator|+
literal|1
argument_list|,
literal|"redirect"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|str
index|[
name|tmp
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|rp
operator|->
name|flag
operator|=
name|tflag
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
comment|/* unlikely that we're worried about init */
name|rp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* maintain list in most-recently-used first order */
if|if
condition|(
name|red_head
condition|)
name|red_head
operator|->
name|prev
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|red_head
expr_stmt|;
name|red_head
operator|=
name|rp
expr_stmt|;
block|}
while|while
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_EOF
condition|)
comment|/* encountered EOF on file or pipe -- must be cleared 			 * by explicit close() before reading more 			 */
return|return
name|rp
return|;
name|mode
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_output
case|:
name|mode
operator|=
literal|"w"
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_USED
condition|)
name|mode
operator|=
literal|"a"
expr_stmt|;
break|break;
case|case
name|Node_redirect_append
case|:
name|mode
operator|=
literal|"a"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
if|if
condition|(
operator|(
name|rp
operator|->
name|fp
operator|=
name|popen
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open pipe (\"%s\") for output (%s)"
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|flag
operator||=
name|RED_NOBUF
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|direction
operator|=
literal|"from"
expr_stmt|;
if|if
condition|(
name|gawk_popen
argument_list|(
name|str
argument_list|,
name|rp
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open pipe (\"%s\") for input (%s)"
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|direction
operator|=
literal|"from"
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_open
argument_list|(
name|str
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
name|devopen
argument_list|(
name|str
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stderr
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stderr
expr_stmt|;
else|else
block|{
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mode
argument_list|)
expr_stmt|;
comment|/* don't leak file descriptors */
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
operator|&&
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
name|rp
operator|->
name|flag
operator||=
name|RED_NOBUF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
comment|/* too many files open -- close one and try again */
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|close_one
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* 				 * Some other reason for failure. 				 * 				 * On redirection of input from a file, 				 * just return an error, so e.g. getline 				 * can return -1.  For output to file, 				 * complain. The shell will complain on 				 * a bad command to a pipe. 				 */
operator|*
name|errflg
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_redirect_output
operator|||
name|tree
operator|->
name|type
operator|==
name|Node_redirect_append
condition|)
name|fatal
argument_list|(
literal|"can't redirect %s `%s' (%s)"
argument_list|,
name|direction
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|rp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_one
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rplast
init|=
name|NULL
decl_stmt|;
comment|/* go to end of list first, to pick up least recently used entry */
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
name|rplast
operator|=
name|rp
expr_stmt|;
comment|/* now work back up through the list */
for|for
control|(
name|rp
operator|=
name|rplast
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|prev
control|)
if|if
condition|(
name|rp
operator|->
name|fp
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_FILE
operator|)
condition|)
block|{
name|rp
operator|->
name|flag
operator||=
name|RED_USED
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
condition|)
name|warning
argument_list|(
literal|"close of \"%s\" failed (%s)."
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
comment|/* surely this is the only reason ??? */
name|fatal
argument_list|(
literal|"too many pipes or input files open"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|do_close
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|tmp
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
condition|)
break|break;
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
comment|/* no match */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* synchronize regular output */
name|tmp
operator|=
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|close_redir
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|close_redir
parameter_list|(
name|rp
parameter_list|,
name|exitwarn
parameter_list|)
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|int
name|exitwarn
decl_stmt|;
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|stdout
operator|||
name|rp
operator|->
name|fp
operator|==
name|stderr
condition|)
return|return
literal|0
return|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
operator|)
operator|==
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
condition|)
name|status
operator|=
name|pclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|fp
condition|)
name|status
operator|=
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|iop
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
condition|)
name|status
operator|=
name|gawk_pclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|what
operator|=
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
condition|?
literal|"pipe"
else|:
literal|"file"
expr_stmt|;
if|if
condition|(
name|exitwarn
condition|)
name|warning
argument_list|(
literal|"no explicit close of %s \"%s\" provided"
argument_list|,
name|what
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* SVR4 awk checks and warns about status of close */
if|if
condition|(
name|status
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|warning
argument_list|(
literal|"failure status (%d) on %s close of \"%s\" (%s)"
argument_list|,
name|status
argument_list|,
name|what
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_unix
condition|)
block|{
comment|/* set ERRNO too so that program can get at it */
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rp
operator|->
name|next
condition|)
name|rp
operator|->
name|next
operator|->
name|prev
operator|=
name|rp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|prev
condition|)
name|rp
operator|->
name|prev
operator|->
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
else|else
name|red_head
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|flush_io
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard output (%s)."
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard error (%s)."
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
comment|/* flush both files and pipes, what the heck */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_WRITE
operator|)
operator|&&
name|rp
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%s flush of \"%s\" failed (%s)."
argument_list|,
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
condition|?
literal|"pipe"
else|:
literal|"file"
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|close_io
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|next
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
comment|/* close_redir() will print a message if needed */
comment|/* if do_lint, warn about lack of explicit close */
if|if
condition|(
name|close_redir
argument_list|(
name|rp
argument_list|,
name|do_lint
argument_list|)
condition|)
name|status
operator|++
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Some of the non-Unix os's have problems doing an fclose 	 * on stdout and stderr.  Since we don't really need to close 	 * them, we just flush them, and do that across the board. 	 */
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard output (%s)."
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard error (%s)."
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* str2mode --- convert a string mode to an integer mode */
end_comment

begin_function
specifier|static
name|int
name|str2mode
parameter_list|(
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|ret
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ret
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ret
operator|=
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* lint */
name|cant_happen
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* devopen --- handle /dev/std{in,out,err}, /dev/fd/N, regular files */
end_comment

begin_comment
comment|/*  * This separate version is still needed for output, since file and pipe  * output is done with stdio. iop_open() handles input with IOBUFs of  * more "special" files.  Those files are not handled here since it makes  * no sense to use them for output.  */
end_comment

begin_function
name|int
name|devopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|int
name|openfd
init|=
name|INVALID_HANDLE
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
specifier|extern
name|double
name|strtod
parameter_list|()
function_decl|;
name|flag
operator|=
name|str2mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_unix
condition|)
goto|goto
name|strictopen
goto|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|(
name|openfd
operator|=
name|vms_devopen
argument_list|(
name|name
argument_list|,
name|flag
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|openfd
return|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|&&
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stdin"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_RDONLY
operator|)
operator|==
name|O_RDONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stdout"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_WRONLY
operator|)
operator|==
name|O_WRONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stderr"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_WRONLY
operator|)
operator|==
name|O_WRONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|cp
argument_list|,
literal|"fd/"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|cp
operator|+=
literal|3
expr_stmt|;
name|openfd
operator|=
operator|(
name|int
operator|)
name|strtod
argument_list|(
name|cp
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|<=
name|INVALID_HANDLE
operator|||
name|ptr
operator|==
name|cp
condition|)
name|openfd
operator|=
name|INVALID_HANDLE
expr_stmt|;
block|}
block|}
name|strictopen
label|:
if|if
condition|(
name|openfd
operator|==
name|INVALID_HANDLE
condition|)
name|openfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
operator|&&
name|fstat
argument_list|(
name|openfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"file `%s' is a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|openfd
return|;
block|}
end_block

begin_comment
comment|/* spec_setup --- setup an IOBUF for a special internal file */
end_comment

begin_function
specifier|static
name|void
name|spec_setup
parameter_list|(
name|iop
parameter_list|,
name|len
parameter_list|,
name|allocate
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|allocate
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|allocate
condition|)
block|{
name|emalloc
argument_list|(
name|cp
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|2
argument_list|,
literal|"spec_setup"
argument_list|)
expr_stmt|;
name|iop
operator|->
name|buf
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|->
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* get_a_record clobbered it */
name|iop
operator|->
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|len
expr_stmt|;
name|iop
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|iop
operator|->
name|flag
operator|=
name|IOP_IS_INTERNAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* specfdopen --- open a fd special file */
end_comment

begin_function
specifier|static
name|int
name|specfdopen
parameter_list|(
name|iop
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|IOBUF
modifier|*
name|tp
decl_stmt|;
name|fd
operator|=
name|devopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|INVALID_HANDLE
return|;
name|tp
operator|=
name|iop_alloc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
name|INVALID_HANDLE
return|;
operator|*
name|iop
operator|=
operator|*
name|tp
expr_stmt|;
name|iop
operator|->
name|flag
operator||=
name|IOP_NO_FREE
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Following mess will improve in 2.16; this is written to avoid  * long lines, avoid splitting #if with backslash, and avoid #elif  * to maximize portability.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GETPGRP_NOARG
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_4
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_define
define|#
directive|define
name|GETPGRP_NOARG
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|i860
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_define
define|#
directive|define
name|GETPGRP_NOARG
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|AMIGA
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
end_if

begin_define
define|#
directive|define
name|GETPGRP_NOARG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GETPGRP_NOARG
end_ifdef

begin_define
define|#
directive|define
name|getpgrp_ARG
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|getpgrp_ARG
value|getpid()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pidopen --- "open" /dev/pid, /dev/ppid, and /dev/pgrpid */
end_comment

begin_function
specifier|static
name|int
name|pidopen
parameter_list|(
name|iop
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|6
index|]
operator|==
literal|'g'
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
name|getpgrp
argument_list|(
name|getpgrp_ARG
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|6
index|]
operator|==
literal|'i'
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|spec_setup
argument_list|(
name|iop
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* useropen --- "open" /dev/user */
end_comment

begin_comment
comment|/*  * /dev/user creates a record as follows:  *	$1 = getuid()  *	$2 = geteuid()  *	$3 = getgid()  *	$4 = getegid()  * If multiple groups are supported, the $5 through $NF are the  * supplementary group set.  */
end_comment

begin_function
specifier|static
name|int
name|useropen
parameter_list|(
name|iop
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|&&
name|NGROUPS_MAX
operator|>
literal|0
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|gid_t
name|groupset
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
else|#
directive|else
name|int
name|groupset
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|ngroups
decl_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d %d %d %d"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tbuf
operator|+
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|&&
name|NGROUPS_MAX
operator|>
literal|0
name|ngroups
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|groupset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngroups
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"could not find groups: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngroups
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|groupset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|spec_setup
argument_list|(
name|iop
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* iop_open --- handle special and regular files for input */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|iop_open
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|int
name|openfd
init|=
name|INVALID_HANDLE
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|static
struct|struct
name|internal
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|compare
decl_stmt|;
name|int
argument_list|(
argument|*fp
argument_list|)
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|IOBUF
name|iob
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
literal|"/dev/fd/"
block|,
literal|8
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stdin"
block|,
literal|10
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stdout"
block|,
literal|11
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stderr"
block|,
literal|11
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/pid"
block|,
literal|8
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/ppid"
block|,
literal|9
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/pgrpid"
block|,
literal|11
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/user"
block|,
literal|9
block|,
name|useropen
block|}
block|, 	}
struct|;
name|int
name|devcount
init|=
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|flag
operator|=
name|str2mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_unix
condition|)
goto|goto
name|strictopen
goto|;
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|&&
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|compare
argument_list|)
condition|)
block|{
name|iop
operator|=
operator|&
name|table
index|[
name|i
index|]
operator|.
name|iob
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|spec_setup
argument_list|(
name|iop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|iop
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|table
index|[
name|i
index|]
operator|.
name|fp
operator|)
operator|(
name|iop
operator|,
name|name
operator|,
name|mode
operator|)
operator|==
literal|0
condition|)
return|return
name|iop
return|;
else|else
block|{
name|warning
argument_list|(
literal|"could not open %s, mode `%s'"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
name|strictopen
label|:
if|if
condition|(
name|openfd
operator|==
name|INVALID_HANDLE
condition|)
name|openfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
operator|&&
name|fstat
argument_list|(
name|openfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
operator|(
name|buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
name|fatal
argument_list|(
literal|"file `%s' is a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|iop
operator|=
name|iop_alloc
argument_list|(
name|openfd
argument_list|)
expr_stmt|;
return|return
name|iop
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_comment
comment|/* real pipes */
end_comment

begin_function
specifier|static
name|int
name|wait_any
parameter_list|(
name|interesting
parameter_list|)
name|int
name|interesting
decl_stmt|;
comment|/* pid of interest, if any */
block|{
name|SIGTYPE
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|redirect
modifier|*
name|redp
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|NeXT
name|pid
operator|=
name|wait
argument_list|(
operator|(
expr|union
name|wait
operator|*
operator|)
operator|&
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NeXT */
if|if
condition|(
name|interesting
operator|&&
name|pid
operator|==
name|interesting
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|redp
operator|=
name|red_head
init|;
name|redp
operator|!=
name|NULL
condition|;
name|redp
operator|=
name|redp
operator|->
name|next
control|)
if|if
condition|(
name|pid
operator|==
name|redp
operator|->
name|pid
condition|)
block|{
name|redp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|redp
operator|->
name|status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|redp
operator|->
name|fp
condition|)
block|{
name|pclose
argument_list|(
name|redp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|redp
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|redp
operator|->
name|iop
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|redp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|redp
operator|->
name|iop
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
break|break;
block|}
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|cmd
parameter_list|,
name|rp
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
comment|/* used to wait for any children to synchronize input and output, 	 * but this could cause gawk to hang when it is started in a pipeline 	 * and thus has a child process feeding it input (shell dependant) 	 */
comment|/*(void) wait_any(0);*/
comment|/* wait for outstanding processes */
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot open pipe \"%s\" (%s)"
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of stdout in child failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"dup of pipe failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of stdin in child failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"cannot fork for \"%s\" (%s)"
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|rp
parameter_list|)
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
comment|/* process previously found, return stored status */
if|if
condition|(
name|rp
operator|->
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|rp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
return|;
name|rp
operator|->
name|status
operator|=
name|wait_any
argument_list|(
name|rp
operator|->
name|pid
argument_list|)
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PIPES_SIMULATED */
end_comment

begin_comment
comment|/* use temporary file rather than pipe */
end_comment

begin_comment
comment|/* except if popen() provides real pipes too */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|cmd
parameter_list|,
name|rp
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|FILE
modifier|*
name|current
decl_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|fileno
argument_list|(
name|current
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|rp
parameter_list|)
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|,
name|aval
decl_stmt|,
name|fd
init|=
name|rp
operator|->
name|iop
operator|->
name|fd
decl_stmt|;
name|FILE
modifier|*
name|kludge
init|=
name|fdopen
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"r"
argument_list|)
decl_stmt|;
comment|/* pclose needs FILE* w/ right fileno */
name|rp
operator|->
name|iop
operator|->
name|fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* kludge to allow close() + pclose() */
name|rval
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
name|aval
operator|=
name|pclose
argument_list|(
name|kludge
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|<
literal|0
condition|?
name|rval
else|:
name|aval
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS || OS2 || MSDOS */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|pipes
index|[
name|_NFILE
index|]
struct|;
end_struct

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|cmd
parameter_list|,
name|rp
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|strdup
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|int
name|current
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|cmdbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* get a name to use.  */
if|if
condition|(
operator|(
name|name
operator|=
name|tempnam
argument_list|(
literal|"."
argument_list|,
literal|"pip"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"%s> %s"
argument_list|,
name|cmd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|NULL
return|;
name|pipes
index|[
name|current
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|pipes
index|[
name|current
index|]
operator|.
name|command
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|current
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|rp
parameter_list|)
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|cur
init|=
name|rp
operator|->
name|iop
operator|->
name|fd
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
comment|/* check for an open file  */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS || OS2 || MSDOS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIPES_SIMULATED */
end_comment

begin_function
name|NODE
modifier|*
name|do_getline
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|int
name|cnt
init|=
name|EOF
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|errcode
decl_stmt|;
while|while
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|rnode
operator|==
name|NULL
condition|)
block|{
comment|/* no redirection */
name|iop
operator|=
name|nextfile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
comment|/* end of input */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|redir_error
init|=
literal|0
decl_stmt|;
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|redir_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
operator|&&
name|redir_error
condition|)
block|{
comment|/* failed redirect */
if|if
condition|(
operator|!
name|do_unix
condition|)
block|{
name|s
operator|=
name|strerror
argument_list|(
name|redir_error
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
name|iop
operator|=
name|rp
operator|->
name|iop
expr_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
comment|/* end of input */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
name|errcode
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|get_a_record
argument_list|(
operator|&
name|s
argument_list|,
name|iop
argument_list|,
operator|*
name|RS
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_unix
operator|&&
name|errcode
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
if|if
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|rp
condition|)
block|{
comment|/* 				 * Don't do iop_close() here if we are 				 * reading from a pipe; otherwise 				 * gawk_pclose will not be called. 				 */
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
name|rp
operator|->
name|flag
operator||=
name|RED_EOF
expr_stmt|;
comment|/* sticky EOF */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
else|else
continue|continue;
comment|/* try another file */
block|}
if|if
condition|(
operator|!
name|rp
condition|)
block|{
name|NR
operator|+=
literal|1
expr_stmt|;
name|FNR
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|NULL
condition|)
comment|/* no optional var. */
name|set_record
argument_list|(
name|s
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* assignment to variable */
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lhs
operator|)
operator|->
name|flags
operator||=
name|MAYBE_NUM
expr_stmt|;
comment|/* we may have to regenerate $0 here! */
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|1.0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pathopen
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|fd
init|=
name|do_pathopen
argument_list|(
name|file
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_FILETYPE
if|if
condition|(
operator|!
name|do_unix
operator|&&
name|fd
operator|<=
name|INVALID_HANDLE
condition|)
block|{
name|char
modifier|*
name|file_awk
decl_stmt|;
name|int
name|save
init|=
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|vms_save
init|=
name|vaxc$errno
decl_stmt|;
endif|#
directive|endif
comment|/* append ".awk" and try again */
name|emalloc
argument_list|(
name|file_awk
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DEFAULT_FILETYPE
argument_list|)
operator|+
literal|1
argument_list|,
literal|"pathopen"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|file_awk
argument_list|,
literal|"%s%s"
argument_list|,
name|file
argument_list|,
name|DEFAULT_FILETYPE
argument_list|)
expr_stmt|;
name|fd
operator|=
name|do_pathopen
argument_list|(
name|file_awk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_awk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
name|INVALID_HANDLE
condition|)
block|{
name|errno
operator|=
name|save
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|vaxc$errno
operator|=
name|vms_save
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/*DEFAULT_FILETYPE*/
return|return
name|fd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_pathopen
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|savepath
init|=
name|DEFPATH
decl_stmt|;
comment|/* defined in config.h */
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|awkpath
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|trypath
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|do_unix
condition|)
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|awkpath
operator|=
name|getenv
argument_list|(
literal|"AWKPATH"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|awkpath
condition|)
name|savepath
operator|=
name|awkpath
expr_stmt|;
comment|/* used for restarting */
block|}
name|awkpath
operator|=
name|savepath
expr_stmt|;
comment|/* some kind of path name, no search */
ifdef|#
directive|ifdef
name|VMS
comment|/* (strchr not equal implies either or both not NULL) */
if|if
condition|(
name|strchr
argument_list|(
name|file
argument_list|,
literal|':'
argument_list|)
operator|!=
name|strchr
argument_list|(
name|file
argument_list|,
literal|']'
argument_list|)
operator|||
name|strchr
argument_list|(
name|file
argument_list|,
literal|'>'
argument_list|)
operator|!=
name|strchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
condition|)
else|#
directive|else
comment|/*!VMS*/
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
if|if
condition|(
name|strchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|strchr
argument_list|(
name|file
argument_list|,
literal|'\\'
argument_list|)
operator|||
name|strchr
argument_list|(
name|file
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
name|strchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
endif|#
directive|endif
comment|/*MSDOS*/
endif|#
directive|endif
comment|/*VMS*/
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
name|_searchenv
argument_list|(
name|file
argument_list|,
literal|"AWKPATH"
argument_list|,
name|trypath
argument_list|)
expr_stmt|;
if|if
condition|(
name|trypath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|_searchenv
argument_list|(
name|file
argument_list|,
literal|"PATH"
argument_list|,
name|trypath
argument_list|)
expr_stmt|;
return|return
operator|(
name|trypath
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
name|devopen
argument_list|(
name|trypath
argument_list|,
literal|"r"
argument_list|)
return|;
else|#
directive|else
do|do
block|{
name|trypath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* this should take into account limits on size of trypath */
for|for
control|(
name|cp
operator|=
name|trypath
init|;
operator|*
name|awkpath
operator|&&
operator|*
name|awkpath
operator|!=
name|ENVSEP
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|awkpath
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|trypath
condition|)
block|{
comment|/* nun-null element in path */
comment|/* add directory punctuation only if needed */
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|strchr
argument_list|(
literal|":]>/"
argument_list|,
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
argument_list|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
if|if
condition|(
name|strchr
argument_list|(
literal|":\\/"
argument_list|,
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
argument_list|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
endif|#
directive|endif
endif|#
directive|endif
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* append filename */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|trypath
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|devopen
argument_list|(
name|trypath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* no luck, keep going */
if|if
condition|(
operator|*
name|awkpath
operator|==
name|ENVSEP
operator|&&
name|awkpath
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|awkpath
operator|++
expr_stmt|;
comment|/* skip colon */
block|}
do|while
condition|(
operator|*
name|awkpath
condition|)
do|;
comment|/* 	 * You might have one of the awk 	 * paths defined, WITHOUT the current working directory in it. 	 * Therefore try to open the file in the current directory. 	 */
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

end_unit

