begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * eval.c - gawk parse tree interpreter  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1986, 1988, 1989, 1991, 1992, 1993 the Free Software Foundation, Inc.  *  * This file is part of GAWK, the GNU implementation of the  * AWK Progamming Language.  *  * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with GAWK; see the file COPYING.  If not, write to  * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_decl_stmt
specifier|extern
name|double
name|pow
name|P
argument_list|(
operator|(
name|double
name|x
operator|,
name|double
name|y
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|modf
name|P
argument_list|(
operator|(
name|double
name|x
operator|,
name|double
operator|*
name|yp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|fmod
name|P
argument_list|(
operator|(
name|double
name|x
operator|,
name|double
name|y
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eval_condition
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|op_assign
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|func_call
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|name
operator|,
name|NODE
operator|*
name|arg_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|match_op
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|_t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used as a temporary in macros */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
name|double
name|_msc51bug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to get around a bug in MSC 5.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|NODE
modifier|*
name|ret_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OFSlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ORSlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OFMTidx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CONVFMTidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros and variables to save and restore function and loop bindings */
end_comment

begin_comment
comment|/*  * the val variable allows return/continue/break-out-of-context to be  * caught and diagnosed  */
end_comment

begin_define
define|#
directive|define
name|PUSH_BINDING
parameter_list|(
name|stack
parameter_list|,
name|x
parameter_list|,
name|val
parameter_list|)
value|(memcpy ((char *)(stack), (char *)(x), sizeof (jmp_buf)), val++)
end_define

begin_define
define|#
directive|define
name|RESTORE_BINDING
parameter_list|(
name|stack
parameter_list|,
name|x
parameter_list|,
name|val
parameter_list|)
value|(memcpy ((char *)(x), (char *)(stack), sizeof (jmp_buf)), val--)
end_define

begin_decl_stmt
specifier|static
name|jmp_buf
name|loop_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* always the current binding */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_tag_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero when loop_tag valid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|func_tag_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|func_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|exiting
decl_stmt|,
name|exit_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This table is used by the regexp routines to do case independant  * matching. Basically, every ascii character maps to itself, except  * uppercase letters map to lower case ones. This table has 256  * entries, which may be overkill. Note also that if the system this  * is compiled on doesn't use 7-bit ascii, casetable[] should not be  * defined to the linker, so gawk should not load.  *  * Do NOT make this array static, it is used in several spots, not  * just in this file.  */
end_comment

begin_if
if|#
directive|if
literal|'a'
operator|==
literal|97
end_if

begin_comment
comment|/* it's ascii */
end_comment

begin_decl_stmt
name|char
name|casetable
index|[]
init|=
block|{
literal|'\000'
block|,
literal|'\001'
block|,
literal|'\002'
block|,
literal|'\003'
block|,
literal|'\004'
block|,
literal|'\005'
block|,
literal|'\006'
block|,
literal|'\007'
block|,
literal|'\010'
block|,
literal|'\011'
block|,
literal|'\012'
block|,
literal|'\013'
block|,
literal|'\014'
block|,
literal|'\015'
block|,
literal|'\016'
block|,
literal|'\017'
block|,
literal|'\020'
block|,
literal|'\021'
block|,
literal|'\022'
block|,
literal|'\023'
block|,
literal|'\024'
block|,
literal|'\025'
block|,
literal|'\026'
block|,
literal|'\027'
block|,
literal|'\030'
block|,
literal|'\031'
block|,
literal|'\032'
block|,
literal|'\033'
block|,
literal|'\034'
block|,
literal|'\035'
block|,
literal|'\036'
block|,
literal|'\037'
block|,
comment|/* ' '     '!'     '"'     '#'     '$'     '%'     '&'     ''' */
literal|'\040'
block|,
literal|'\041'
block|,
literal|'\042'
block|,
literal|'\043'
block|,
literal|'\044'
block|,
literal|'\045'
block|,
literal|'\046'
block|,
literal|'\047'
block|,
comment|/* '('     ')'     '*'     '+'     ','     '-'     '.'     '/' */
literal|'\050'
block|,
literal|'\051'
block|,
literal|'\052'
block|,
literal|'\053'
block|,
literal|'\054'
block|,
literal|'\055'
block|,
literal|'\056'
block|,
literal|'\057'
block|,
comment|/* '0'     '1'     '2'     '3'     '4'     '5'     '6'     '7' */
literal|'\060'
block|,
literal|'\061'
block|,
literal|'\062'
block|,
literal|'\063'
block|,
literal|'\064'
block|,
literal|'\065'
block|,
literal|'\066'
block|,
literal|'\067'
block|,
comment|/* '8'     '9'     ':'     ';'     '<'     '='     '>'     '?' */
literal|'\070'
block|,
literal|'\071'
block|,
literal|'\072'
block|,
literal|'\073'
block|,
literal|'\074'
block|,
literal|'\075'
block|,
literal|'\076'
block|,
literal|'\077'
block|,
comment|/* '@'     'A'     'B'     'C'     'D'     'E'     'F'     'G' */
literal|'\100'
block|,
literal|'\141'
block|,
literal|'\142'
block|,
literal|'\143'
block|,
literal|'\144'
block|,
literal|'\145'
block|,
literal|'\146'
block|,
literal|'\147'
block|,
comment|/* 'H'     'I'     'J'     'K'     'L'     'M'     'N'     'O' */
literal|'\150'
block|,
literal|'\151'
block|,
literal|'\152'
block|,
literal|'\153'
block|,
literal|'\154'
block|,
literal|'\155'
block|,
literal|'\156'
block|,
literal|'\157'
block|,
comment|/* 'P'     'Q'     'R'     'S'     'T'     'U'     'V'     'W' */
literal|'\160'
block|,
literal|'\161'
block|,
literal|'\162'
block|,
literal|'\163'
block|,
literal|'\164'
block|,
literal|'\165'
block|,
literal|'\166'
block|,
literal|'\167'
block|,
comment|/* 'X'     'Y'     'Z'     '['     '\'     ']'     '^'     '_' */
literal|'\170'
block|,
literal|'\171'
block|,
literal|'\172'
block|,
literal|'\133'
block|,
literal|'\134'
block|,
literal|'\135'
block|,
literal|'\136'
block|,
literal|'\137'
block|,
comment|/* '`'     'a'     'b'     'c'     'd'     'e'     'f'     'g' */
literal|'\140'
block|,
literal|'\141'
block|,
literal|'\142'
block|,
literal|'\143'
block|,
literal|'\144'
block|,
literal|'\145'
block|,
literal|'\146'
block|,
literal|'\147'
block|,
comment|/* 'h'     'i'     'j'     'k'     'l'     'm'     'n'     'o' */
literal|'\150'
block|,
literal|'\151'
block|,
literal|'\152'
block|,
literal|'\153'
block|,
literal|'\154'
block|,
literal|'\155'
block|,
literal|'\156'
block|,
literal|'\157'
block|,
comment|/* 'p'     'q'     'r'     's'     't'     'u'     'v'     'w' */
literal|'\160'
block|,
literal|'\161'
block|,
literal|'\162'
block|,
literal|'\163'
block|,
literal|'\164'
block|,
literal|'\165'
block|,
literal|'\166'
block|,
literal|'\167'
block|,
comment|/* 'x'     'y'     'z'     '{'     '|'     '}'     '~' */
literal|'\170'
block|,
literal|'\171'
block|,
literal|'\172'
block|,
literal|'\173'
block|,
literal|'\174'
block|,
literal|'\175'
block|,
literal|'\176'
block|,
literal|'\177'
block|,
literal|'\200'
block|,
literal|'\201'
block|,
literal|'\202'
block|,
literal|'\203'
block|,
literal|'\204'
block|,
literal|'\205'
block|,
literal|'\206'
block|,
literal|'\207'
block|,
literal|'\210'
block|,
literal|'\211'
block|,
literal|'\212'
block|,
literal|'\213'
block|,
literal|'\214'
block|,
literal|'\215'
block|,
literal|'\216'
block|,
literal|'\217'
block|,
literal|'\220'
block|,
literal|'\221'
block|,
literal|'\222'
block|,
literal|'\223'
block|,
literal|'\224'
block|,
literal|'\225'
block|,
literal|'\226'
block|,
literal|'\227'
block|,
literal|'\230'
block|,
literal|'\231'
block|,
literal|'\232'
block|,
literal|'\233'
block|,
literal|'\234'
block|,
literal|'\235'
block|,
literal|'\236'
block|,
literal|'\237'
block|,
literal|'\240'
block|,
literal|'\241'
block|,
literal|'\242'
block|,
literal|'\243'
block|,
literal|'\244'
block|,
literal|'\245'
block|,
literal|'\246'
block|,
literal|'\247'
block|,
literal|'\250'
block|,
literal|'\251'
block|,
literal|'\252'
block|,
literal|'\253'
block|,
literal|'\254'
block|,
literal|'\255'
block|,
literal|'\256'
block|,
literal|'\257'
block|,
literal|'\260'
block|,
literal|'\261'
block|,
literal|'\262'
block|,
literal|'\263'
block|,
literal|'\264'
block|,
literal|'\265'
block|,
literal|'\266'
block|,
literal|'\267'
block|,
literal|'\270'
block|,
literal|'\271'
block|,
literal|'\272'
block|,
literal|'\273'
block|,
literal|'\274'
block|,
literal|'\275'
block|,
literal|'\276'
block|,
literal|'\277'
block|,
literal|'\300'
block|,
literal|'\301'
block|,
literal|'\302'
block|,
literal|'\303'
block|,
literal|'\304'
block|,
literal|'\305'
block|,
literal|'\306'
block|,
literal|'\307'
block|,
literal|'\310'
block|,
literal|'\311'
block|,
literal|'\312'
block|,
literal|'\313'
block|,
literal|'\314'
block|,
literal|'\315'
block|,
literal|'\316'
block|,
literal|'\317'
block|,
literal|'\320'
block|,
literal|'\321'
block|,
literal|'\322'
block|,
literal|'\323'
block|,
literal|'\324'
block|,
literal|'\325'
block|,
literal|'\326'
block|,
literal|'\327'
block|,
literal|'\330'
block|,
literal|'\331'
block|,
literal|'\332'
block|,
literal|'\333'
block|,
literal|'\334'
block|,
literal|'\335'
block|,
literal|'\336'
block|,
literal|'\337'
block|,
literal|'\340'
block|,
literal|'\341'
block|,
literal|'\342'
block|,
literal|'\343'
block|,
literal|'\344'
block|,
literal|'\345'
block|,
literal|'\346'
block|,
literal|'\347'
block|,
literal|'\350'
block|,
literal|'\351'
block|,
literal|'\352'
block|,
literal|'\353'
block|,
literal|'\354'
block|,
literal|'\355'
block|,
literal|'\356'
block|,
literal|'\357'
block|,
literal|'\360'
block|,
literal|'\361'
block|,
literal|'\362'
block|,
literal|'\363'
block|,
literal|'\364'
block|,
literal|'\365'
block|,
literal|'\366'
block|,
literal|'\367'
block|,
literal|'\370'
block|,
literal|'\371'
block|,
literal|'\372'
block|,
literal|'\373'
block|,
literal|'\374'
block|,
literal|'\375'
block|,
literal|'\376'
block|,
literal|'\377'
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"You lose. You will need a translation table for your character set."
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tree is a bunch of rules to run. Returns zero if it hit an exit()  * statement  */
end_comment

begin_function
name|int
name|interpret
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
specifier|volatile
name|tree
decl_stmt|;
block|{
name|jmp_buf
specifier|volatile
name|loop_tag_stack
decl_stmt|;
comment|/* shallow binding stack for loop_tag */
specifier|static
name|jmp_buf
name|rule_tag
decl_stmt|;
comment|/* tag the rule currently being run, for NEXT 				  * and EXIT statements.  It is static because 				  * there are no nested rules */
specifier|register
name|NODE
modifier|*
specifier|volatile
name|t
init|=
name|NULL
decl_stmt|;
comment|/* temporary */
name|NODE
modifier|*
modifier|*
specifier|volatile
name|lhs
decl_stmt|;
comment|/* lhs == Left Hand Side for assigns, etc */
name|NODE
modifier|*
specifier|volatile
name|stable_tree
decl_stmt|;
name|int
specifier|volatile
name|traverse
init|=
literal|1
decl_stmt|;
comment|/* True => loop thru tree (Node_rule_list) */
comment|/* avoid false source indications */
name|source
operator|=
name|NULL
expr_stmt|;
name|sourceline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|sourceline
operator|=
name|tree
operator|->
name|source_line
expr_stmt|;
name|source
operator|=
name|tree
operator|->
name|source_file
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_rule_node
case|:
name|traverse
operator|=
literal|0
expr_stmt|;
comment|/* False => one for-loop iteration only */
comment|/* FALL THROUGH */
case|case
name|Node_rule_list
case|:
for|for
control|(
name|t
operator|=
name|tree
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|rnode
control|)
block|{
if|if
condition|(
name|traverse
condition|)
name|tree
operator|=
name|t
operator|->
name|lnode
expr_stmt|;
name|sourceline
operator|=
name|tree
operator|->
name|source_line
expr_stmt|;
name|source
operator|=
name|tree
operator|->
name|source_file
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|rule_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
comment|/* test pattern, if any */
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|NULL
operator|||
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_CONTINUE
case|:
comment|/* NEXT statement */
return|return
literal|1
return|;
case|case
name|TAG_BREAK
case|:
return|return
literal|0
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|traverse
condition|)
comment|/* case Node_rule_node */
break|break;
comment|/* don't loop */
block|}
break|break;
case|case
name|Node_statement_list
case|:
for|for
control|(
name|t
operator|=
name|tree
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|rnode
control|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|t
operator|->
name|lnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_if
case|:
if|if
condition|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node_K_while
case|:
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
while|while
condition|(
name|eval_condition
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_CONTINUE
case|:
comment|/* continue statement */
break|break;
case|case
name|TAG_BREAK
case|:
comment|/* break statement */
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_do
case|:
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_CONTINUE
case|:
comment|/* continue statement */
break|break;
case|case
name|TAG_BREAK
case|:
comment|/* break statement */
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|eval_condition
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
condition|)
do|;
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_for
case|:
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|forloop
operator|->
name|init
argument_list|)
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
while|while
condition|(
name|eval_condition
argument_list|(
name|stable_tree
operator|->
name|forloop
operator|->
name|cond
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|TAG_CONTINUE
case|:
comment|/* continue statement */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|forloop
operator|->
name|incr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_BREAK
case|:
comment|/* break statement */
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_arrayfor
case|:
block|{
specifier|volatile
name|struct
name|search
name|l
decl_stmt|;
comment|/* For array_for */
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|hakvar
value|forloop->init
define|#
directive|define
name|arrvar
value|forloop->incr
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|hakvar
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree
operator|->
name|arrvar
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|t
operator|=
name|stack_ptr
index|[
name|t
operator|->
name|param_cnt
index|]
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
for|for
control|(
name|assoc_scan
argument_list|(
name|t
argument_list|,
operator|(
expr|struct
name|search
operator|*
operator|)
operator|&
name|l
argument_list|)
init|;
name|l
operator|.
name|retval
condition|;
name|assoc_next
argument_list|(
operator|(
expr|struct
name|search
operator|*
operator|)
operator|&
name|l
argument_list|)
control|)
block|{
name|unref
argument_list|(
operator|*
operator|(
operator|(
name|NODE
operator|*
operator|*
operator|)
name|lhs
operator|)
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|dupnode
argument_list|(
name|l
operator|.
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
case|case
name|TAG_CONTINUE
case|:
break|break;
case|case
name|TAG_BREAK
case|:
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Node_K_break
case|:
if|if
condition|(
name|loop_tag_valid
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"unexpected break"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|loop_tag
argument_list|,
name|TAG_BREAK
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_continue
case|:
if|if
condition|(
name|loop_tag_valid
operator|==
literal|0
condition|)
block|{
comment|/* 			 * AT&T nawk treats continue outside of loops like 			 * next.  Allow it if not posix, and complain if 			 * lint. 			 */
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|warning
argument_list|(
literal|"use of `continue' outside of loop is not portable"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_posix
condition|)
name|fatal
argument_list|(
literal|"use of `continue' outside of loop is not allowed"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
block|}
else|else
name|longjmp
argument_list|(
name|loop_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_print
case|:
name|do_print
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_printf
case|:
name|do_printf
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_delete
case|:
if|if
condition|(
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
name|do_delete
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
else|else
name|assoc_clear
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_next
case|:
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_nextfile
case|:
name|do_nextfile
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node_K_exit
case|:
comment|/* 		 * In A,K,&W, p. 49, it says that an exit statement "... 		 * causes the program to behave as if the end of input had 		 * occurred; no more input is read, and the END actions, if 		 * any are executed." This implies that the rest of the rules 		 * are not done. So we immediately break out of the main loop. 		 */
name|exiting
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|t
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|exit_val
operator|=
operator|(
name|int
operator|)
name|force_number
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_BREAK
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_return
case|:
name|t
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|ret_node
operator|=
name|dupnode
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|func_tag
argument_list|,
name|TAG_RETURN
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Appears to be an expression statement.  Throw away the 		 * value. 		 */
if|if
condition|(
name|do_lint
operator|&&
name|tree
operator|->
name|type
operator|==
name|Node_var
condition|)
name|warning
argument_list|(
literal|"statement has no effect"
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* evaluate a subtree */
end_comment

begin_function
name|NODE
modifier|*
name|r_tree_eval
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
comment|/* return value& temporary subtrees */
specifier|register
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
specifier|register
name|int
name|di
decl_stmt|;
name|AWKNUM
name|x
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|long
name|lx
decl_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
name|long
name|lx2
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|Nnull_string
return|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_val
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|)
name|tree
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
return|return
name|tree
return|;
block|}
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_var
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|)
name|tree
operator|->
name|var_value
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
return|return
name|tree
operator|->
name|var_value
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_param_list
condition|)
block|{
name|tree
operator|=
name|stack_ptr
index|[
name|tree
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|Nnull_string
return|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_var
case|:
return|return
name|tree
operator|->
name|var_value
return|;
case|case
name|Node_and
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
operator|&&
name|eval_condition
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Node_or
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
operator|||
name|eval_condition
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Node_not
case|:
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|!
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
return|;
comment|/* Builtins */
case|case
name|Node_builtin
case|:
return|return
operator|(
call|(
modifier|*
name|tree
operator|->
name|proc
call|)
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
operator|)
return|;
case|case
name|Node_K_getline
case|:
return|return
operator|(
name|do_getline
argument_list|(
name|tree
argument_list|)
operator|)
return|;
case|case
name|Node_in_array
case|:
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|in_array
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
argument_list|)
return|;
case|case
name|Node_func_call
case|:
return|return
name|func_call
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
name|tree
operator|->
name|lnode
argument_list|)
return|;
comment|/* unary operations */
case|case
name|Node_NR
case|:
case|case
name|Node_FNR
case|:
case|case
name|Node_NF
case|:
case|case
name|Node_FIELDWIDTHS
case|:
case|case
name|Node_FS
case|:
case|case
name|Node_RS
case|:
case|case
name|Node_field_spec
case|:
case|case
name|Node_subscript
case|:
case|case
name|Node_IGNORECASE
case|:
case|case
name|Node_OFS
case|:
case|case
name|Node_ORS
case|:
case|case
name|Node_OFMT
case|:
case|case
name|Node_CONVFMT
case|:
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
argument_list|,
operator|(
name|Func_ptr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|*
name|lhs
return|;
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
case|case
name|Node_unary_minus
case|:
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|x
argument_list|)
return|;
case|case
name|Node_cond_exp
case|:
if|if
condition|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
condition|)
return|return
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
return|;
return|return
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
argument_list|)
return|;
case|case
name|Node_match
case|:
case|case
name|Node_nomatch
case|:
case|case
name|Node_regex
case|:
return|return
name|match_op
argument_list|(
name|tree
argument_list|)
return|;
case|case
name|Node_func
case|:
name|fatal
argument_list|(
literal|"function `%s' called with space between name and (,\n%s"
argument_list|,
name|tree
operator|->
name|lnode
operator|->
name|param
argument_list|,
literal|"or used in other expression context"
argument_list|)
expr_stmt|;
comment|/* assignments */
case|case
name|Node_assign
case|:
block|{
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|r
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
operator|*
name|lhs
condition|)
block|{
name|NODE
modifier|*
name|save
decl_stmt|;
name|save
operator|=
operator|*
name|lhs
expr_stmt|;
operator|*
name|lhs
operator|=
name|dupnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
operator|*
name|lhs
return|;
block|}
case|case
name|Node_concat
case|:
block|{
define|#
directive|define
name|STACKSIZE
value|10
name|NODE
modifier|*
name|treelist
index|[
name|STACKSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|NODE
modifier|*
name|strlist
index|[
name|STACKSIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|NODE
modifier|*
modifier|*
name|treep
decl_stmt|;
specifier|register
name|NODE
modifier|*
modifier|*
name|strp
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* 		 * This is an efficiency hack for multiple adjacent string 		 * concatenations, to avoid recursion and string copies. 		 * 		 * Node_concat trees grow downward to the left, so 		 * descend to lowest (first) node, accumulating nodes 		 * to evaluate to strings as we go. 		 */
name|treep
operator|=
name|treelist
expr_stmt|;
while|while
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_concat
condition|)
block|{
operator|*
name|treep
operator|++
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|treep
operator|==
operator|&
name|treelist
index|[
name|STACKSIZE
index|]
condition|)
break|break;
block|}
operator|*
name|treep
operator|=
name|tree
expr_stmt|;
comment|/* 		 * Now, evaluate to strings in LIFO order, accumulating 		 * the string length, so we can do a single malloc at the 		 * end. 		 */
name|strp
operator|=
name|strlist
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|treep
operator|>=
name|treelist
condition|)
block|{
operator|*
name|strp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
operator|*
name|treep
operator|--
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|*
name|strp
operator|)
operator|->
name|stlen
expr_stmt|;
name|strp
operator|++
expr_stmt|;
block|}
operator|*
name|strp
operator|=
name|NULL
expr_stmt|;
name|emalloc
argument_list|(
name|str
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|2
argument_list|,
literal|"tree_eval"
argument_list|)
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
name|str
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* for good measure */
name|dest
operator|=
name|str
expr_stmt|;
name|strp
operator|=
name|strlist
expr_stmt|;
while|while
condition|(
operator|*
name|strp
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|(
operator|*
name|strp
operator|)
operator|->
name|stptr
argument_list|,
operator|(
operator|*
name|strp
operator|)
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|dest
operator|+=
operator|(
operator|*
name|strp
operator|)
operator|->
name|stlen
expr_stmt|;
name|free_temp
argument_list|(
operator|*
name|strp
argument_list|)
expr_stmt|;
name|strp
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|make_str_node
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|ALREADY_MALLOCED
argument_list|)
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
block|}
return|return
name|r
return|;
comment|/* other assignment types are easier because they are numeric */
case|case
name|Node_preincrement
case|:
case|case
name|Node_predecrement
case|:
case|case
name|Node_postincrement
case|:
case|case
name|Node_postdecrement
case|:
case|case
name|Node_assign_exp
case|:
case|case
name|Node_assign_times
case|:
case|case
name|Node_assign_quotient
case|:
case|case
name|Node_assign_mod
case|:
case|case
name|Node_assign_plus
case|:
case|case
name|Node_assign_minus
case|:
return|return
name|op_assign
argument_list|(
name|tree
argument_list|)
return|;
default|default:
break|break;
comment|/* handled below */
block|}
comment|/* evaluate subtrees in order to do binary operation, then keep going */
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_geq
case|:
case|case
name|Node_leq
case|:
case|case
name|Node_greater
case|:
case|case
name|Node_less
case|:
case|case
name|Node_notequal
case|:
case|case
name|Node_equal
case|:
name|di
operator|=
name|cmp_nodes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_equal
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|==
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_notequal
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|!=
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_less
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|<
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_greater
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|>
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_leq
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|<=
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_geq
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|>=
literal|0
argument_list|)
argument_list|)
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
comment|/* handled below */
block|}
name|x1
operator|=
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_exp
case|:
if|if
condition|(
operator|(
name|lx
operator|=
name|x2
operator|)
operator|==
name|x2
operator|&&
name|lx
operator|>=
literal|0
condition|)
block|{
comment|/* integer exponent */
if|if
condition|(
name|lx
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lx
operator|==
literal|1
condition|)
name|x
operator|=
name|x1
expr_stmt|;
else|else
block|{
comment|/* doing it this way should be more precise */
for|for
control|(
name|x
operator|=
name|x1
init|;
operator|--
name|lx
condition|;
control|)
name|x
operator|*=
name|x1
expr_stmt|;
block|}
block|}
else|else
name|x
operator|=
name|pow
argument_list|(
operator|(
name|double
operator|)
name|x1
argument_list|,
operator|(
name|double
operator|)
name|x2
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|x
argument_list|)
return|;
case|case
name|Node_times
case|:
return|return
name|tmp_number
argument_list|(
name|x1
operator|*
name|x2
argument_list|)
return|;
case|case
name|Node_quotient
case|:
if|if
condition|(
name|x2
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* 		 * special case for integer division, put in for Cray 		 */
name|lx2
operator|=
name|x2
expr_stmt|;
if|if
condition|(
name|lx2
operator|==
literal|0
condition|)
return|return
name|tmp_number
argument_list|(
name|x1
operator|/
name|x2
argument_list|)
return|;
name|lx
operator|=
operator|(
name|long
operator|)
name|x1
operator|/
name|lx2
expr_stmt|;
if|if
condition|(
name|lx
operator|*
name|x2
operator|==
name|x1
condition|)
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|lx
argument_list|)
return|;
else|else
endif|#
directive|endif
return|return
name|tmp_number
argument_list|(
name|x1
operator|/
name|x2
argument_list|)
return|;
case|case
name|Node_mod
case|:
if|if
condition|(
name|x2
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted in mod"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FMOD_MISSING
return|return
name|tmp_number
argument_list|(
name|fmod
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|)
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|modf
argument_list|(
name|x1
operator|/
name|x2
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|x1
operator|-
name|x
operator|*
name|x2
argument_list|)
return|;
endif|#
directive|endif
case|case
name|Node_plus
case|:
return|return
name|tmp_number
argument_list|(
name|x1
operator|+
name|x2
argument_list|)
return|;
case|case
name|Node_minus
case|:
return|return
name|tmp_number
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
return|;
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
default|default:
name|fatal
argument_list|(
literal|"illegal type (%d) in tree_eval"
argument_list|,
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Is TREE true or false?  Returns 0==false, non-zero==true */
end_comment

begin_function
specifier|static
name|int
name|eval_condition
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
comment|/* Null trees are the easiest kinds */
return|return
literal|1
return|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_line_range
condition|)
block|{
comment|/* 		 * Node_line_range is kind of like Node_match, EXCEPT: the 		 * lnode field (more properly, the condpair field) is a node 		 * of a Node_cond_pair; whether we evaluate the lnode of that 		 * node or the rnode depends on the triggered word.  More 		 * precisely:  if we are not yet triggered, we tree_eval the 		 * lnode; if that returns true, we set the triggered word. 		 * If we are triggered (not ELSE IF, note), we tree_eval the 		 * rnode, clear triggered if it succeeds, and perform our 		 * action (regardless of success or failure).  We want to be 		 * able to begin and end on a single input record, so this 		 * isn't an ELSE IF, as noted above. 		 */
if|if
condition|(
operator|!
name|tree
operator|->
name|triggered
condition|)
if|if
condition|(
operator|!
name|eval_condition
argument_list|(
name|tree
operator|->
name|condpair
operator|->
name|lnode
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|tree
operator|->
name|triggered
operator|=
literal|1
expr_stmt|;
comment|/* Else we are triggered */
if|if
condition|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|condpair
operator|->
name|rnode
argument_list|)
condition|)
name|tree
operator|->
name|triggered
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Could just be J.random expression. in which case, null and 0 are 	 * false, anything else is true 	 */
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|NUMBER
condition|)
name|ret
operator|=
name|t1
operator|->
name|numbr
operator|!=
literal|0.0
expr_stmt|;
else|else
name|ret
operator|=
name|t1
operator|->
name|stlen
operator|!=
literal|0
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * compare two nodes, returning negative, 0, positive  */
end_comment

begin_function
name|int
name|cmp_nodes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|ret
decl_stmt|;
specifier|register
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|->
name|flags
operator|&
name|NUMBER
operator|)
operator|&&
operator|(
name|t2
operator|->
name|flags
operator|&
name|NUMBER
operator|)
condition|)
block|{
if|if
condition|(
name|t1
operator|->
name|numbr
operator|==
name|t2
operator|->
name|numbr
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|t1
operator|->
name|numbr
operator|-
name|t2
operator|->
name|numbr
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|len1
operator|=
name|t1
operator|->
name|stlen
expr_stmt|;
name|len2
operator|=
name|t2
operator|->
name|stlen
expr_stmt|;
if|if
condition|(
name|len1
operator|==
literal|0
operator|||
name|len2
operator|==
literal|0
condition|)
return|return
name|len1
operator|-
name|len2
return|;
name|ret
operator|=
name|memcmp
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
name|t2
operator|->
name|stptr
argument_list|,
name|len1
operator|<=
name|len2
condition|?
name|len1
else|:
name|len2
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
literal|0
condition|?
name|len1
operator|-
name|len2
else|:
name|ret
return|;
block|}
end_block

begin_function
specifier|static
name|NODE
modifier|*
name|op_assign
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|AWKNUM
name|rval
decl_stmt|,
name|lval
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
name|AWKNUM
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|long
name|ltemp
decl_stmt|;
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|lval
operator|=
name|force_number
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
comment|/* 	 * Can't unref *lhs until we know the type; doing so 	 * too early breaks   x += x   sorts of things. 	 */
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_preincrement
case|:
case|case
name|Node_predecrement
case|:
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|+
operator|(
name|tree
operator|->
name|type
operator|==
name|Node_preincrement
condition|?
literal|1.0
else|:
operator|-
literal|1.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
operator|*
name|lhs
return|;
case|case
name|Node_postincrement
case|:
case|case
name|Node_postdecrement
case|:
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|+
operator|(
name|tree
operator|->
name|type
operator|==
name|Node_postincrement
condition|?
literal|1.0
else|:
operator|-
literal|1.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|lval
argument_list|)
return|;
default|default:
break|break;
comment|/* handled below */
block|}
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|rval
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_assign_exp
case|:
if|if
condition|(
operator|(
name|ltemp
operator|=
name|rval
operator|)
operator|==
name|rval
condition|)
block|{
comment|/* integer exponent */
if|if
condition|(
name|ltemp
operator|==
literal|0
condition|)
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltemp
operator|==
literal|1
condition|)
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* doing it this way should be more precise */
for|for
control|(
name|t1
operator|=
name|t2
operator|=
name|lval
init|;
operator|--
name|ltemp
condition|;
control|)
name|t1
operator|*=
name|t2
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
name|lval
argument_list|,
operator|(
name|double
operator|)
name|rval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_times
case|:
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|*
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_quotient
case|:
if|if
condition|(
name|rval
operator|==
operator|(
name|AWKNUM
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted in /="
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* 		 * special case for integer division, put in for Cray 		 */
name|ltemp
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|ltemp
operator|==
literal|0
condition|)
block|{
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|/
name|rval
argument_list|)
expr_stmt|;
break|break;
block|}
name|ltemp
operator|=
operator|(
name|long
operator|)
name|lval
operator|/
name|ltemp
expr_stmt|;
if|if
condition|(
name|ltemp
operator|*
name|lval
operator|==
name|rval
condition|)
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ltemp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|/
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_mod
case|:
if|if
condition|(
name|rval
operator|==
operator|(
name|AWKNUM
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted in %="
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FMOD_MISSING
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|fmod
argument_list|(
name|lval
argument_list|,
name|rval
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|modf
argument_list|(
name|lval
operator|/
name|rval
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|lval
operator|-
name|rval
operator|*
name|t1
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|Node_assign_plus
case|:
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|+
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_minus
case|:
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|-
name|rval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
operator|*
name|lhs
return|;
block|}
end_function

begin_decl_stmt
name|NODE
modifier|*
modifier|*
name|stack_ptr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|NODE
modifier|*
name|func_call
parameter_list|(
name|name
parameter_list|,
name|arg_list
parameter_list|)
name|NODE
modifier|*
name|name
decl_stmt|;
comment|/* name is a Node_val giving function name */
name|NODE
modifier|*
name|arg_list
decl_stmt|;
comment|/* Node_expression_list of calling args. */
block|{
specifier|register
name|NODE
modifier|*
name|arg
decl_stmt|,
modifier|*
name|argp
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|NODE
modifier|*
name|n
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|jmp_buf
specifier|volatile
name|func_tag_stack
decl_stmt|;
name|jmp_buf
specifier|volatile
name|loop_tag_stack
decl_stmt|;
name|int
specifier|volatile
name|save_loop_tag_valid
init|=
literal|0
decl_stmt|;
name|NODE
modifier|*
modifier|*
specifier|volatile
name|save_stack
decl_stmt|,
modifier|*
name|save_ret_node
decl_stmt|;
name|NODE
modifier|*
modifier|*
specifier|volatile
name|local_stack
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|sp
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|extern
name|NODE
modifier|*
name|ret_node
decl_stmt|;
comment|/* 	 * retrieve function definition node 	 */
name|f
operator|=
name|lookup
argument_list|(
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|||
name|f
operator|->
name|type
operator|!=
name|Node_func
condition|)
name|fatal
argument_list|(
literal|"function `%s' not defined"
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNC_TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function %s called\n"
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|f
operator|->
name|lnode
operator|->
name|param_cnt
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|emalloc
argument_list|(
name|local_stack
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"func_call"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|local_stack
expr_stmt|;
comment|/* 	 * for each calling arg. add NODE * on stack 	 */
for|for
control|(
name|argp
operator|=
name|arg_list
init|;
name|count
operator|&&
name|argp
operator|!=
name|NULL
condition|;
name|argp
operator|=
name|argp
operator|->
name|rnode
control|)
block|{
name|arg
operator|=
name|argp
operator|->
name|lnode
expr_stmt|;
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|Node_var
expr_stmt|;
comment|/* 		 * call by reference for arrays; see below also 		 */
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|arg
operator|=
name|stack_ptr
index|[
name|arg
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|Node_var_array
condition|)
operator|*
name|r
operator|=
operator|*
name|arg
expr_stmt|;
else|else
block|{
name|n
operator|=
name|tree_eval
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|->
name|lnode
operator|=
name|dupnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|r
operator|->
name|rnode
operator|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
expr_stmt|;
name|free_temp
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
operator|*
name|sp
operator|++
operator|=
name|r
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argp
operator|!=
name|NULL
condition|)
comment|/* left over calling args. */
name|warning
argument_list|(
literal|"function `%s' called with more arguments than declared"
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
comment|/* 	 * add remaining params. on stack with null value 	 */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|Node_var
expr_stmt|;
name|r
operator|->
name|lnode
operator|=
name|Nnull_string
expr_stmt|;
name|r
operator|->
name|rnode
operator|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|r
expr_stmt|;
block|}
comment|/* 	 * Execute function body, saving context, as a return statement 	 * will longjmp back here. 	 * 	 * Have to save and restore the loop_tag stuff so that a return 	 * inside a loop in a function body doesn't scrog any loops going 	 * on in the main program.  We save the necessary info in variables 	 * local to this function so that function nesting works OK. 	 * We also only bother to save the loop stuff if we're in a loop 	 * when the function is called. 	 */
if|if
condition|(
name|loop_tag_valid
condition|)
block|{
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|save_loop_tag_valid
operator|=
operator|(
specifier|volatile
name|int
operator|)
name|loop_tag_valid
expr_stmt|;
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|loop_tag_valid
operator|=
literal|0
expr_stmt|;
block|}
name|save_stack
operator|=
name|stack_ptr
expr_stmt|;
name|stack_ptr
operator|=
name|local_stack
expr_stmt|;
name|PUSH_BINDING
argument_list|(
name|func_tag_stack
argument_list|,
name|func_tag
argument_list|,
name|func_tag_valid
argument_list|)
expr_stmt|;
name|save_ret_node
operator|=
name|ret_node
expr_stmt|;
name|ret_node
operator|=
name|Nnull_string
expr_stmt|;
comment|/* default return value */
if|if
condition|(
name|setjmp
argument_list|(
name|func_tag
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|f
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|r
operator|=
name|ret_node
expr_stmt|;
name|ret_node
operator|=
operator|(
name|NODE
operator|*
operator|)
name|save_ret_node
expr_stmt|;
name|RESTORE_BINDING
argument_list|(
name|func_tag_stack
argument_list|,
name|func_tag
argument_list|,
name|func_tag_valid
argument_list|)
expr_stmt|;
name|stack_ptr
operator|=
operator|(
name|NODE
operator|*
operator|*
operator|)
name|save_stack
expr_stmt|;
comment|/* 	 * here, we pop each parameter and check whether 	 * it was an array.  If so, and if the arg. passed in was 	 * a simple variable, then the value should be copied back. 	 * This achieves "call-by-reference" for arrays. 	 */
name|sp
operator|=
name|local_stack
expr_stmt|;
name|count
operator|=
name|f
operator|->
name|lnode
operator|->
name|param_cnt
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|arg_list
init|;
name|count
operator|>
literal|0
operator|&&
name|argp
operator|!=
name|NULL
condition|;
name|argp
operator|=
name|argp
operator|->
name|rnode
control|)
block|{
name|arg
operator|=
name|argp
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|arg
operator|=
name|stack_ptr
index|[
name|arg
operator|->
name|param_cnt
index|]
expr_stmt|;
name|n
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|->
name|type
operator|==
name|Node_var
operator|||
name|arg
operator|->
name|type
operator|==
name|Node_var_array
operator|)
operator|&&
name|n
operator|->
name|type
operator|==
name|Node_var_array
condition|)
block|{
comment|/* should we free arg->var_value ? */
name|arg
operator|->
name|var_array
operator|=
name|n
operator|->
name|var_array
expr_stmt|;
name|arg
operator|->
name|type
operator|=
name|Node_var_array
expr_stmt|;
name|arg
operator|->
name|array_size
operator|=
name|n
operator|->
name|array_size
expr_stmt|;
name|arg
operator|->
name|table_size
operator|=
name|n
operator|->
name|table_size
expr_stmt|;
name|arg
operator|->
name|flags
operator|=
name|n
operator|->
name|flags
expr_stmt|;
block|}
comment|/* n->lnode overlays the array size, don't unref it if array */
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|Node_var_array
condition|)
name|unref
argument_list|(
name|n
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* if n is an (local) array, all the elements should be freed */
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_var_array
condition|)
name|assoc_clear
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|n
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_stack
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|local_stack
argument_list|)
expr_stmt|;
comment|/* Restore the loop_tag stuff if necessary. */
if|if
condition|(
name|save_loop_tag_valid
condition|)
block|{
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|loop_tag_valid
operator|=
operator|(
name|int
operator|)
name|save_loop_tag_valid
expr_stmt|;
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|junk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|flags
operator|&
name|PERM
operator|)
condition|)
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * This returns a POINTER to a node pointer. get_lhs(ptr) is the current  * value of the var, or where to store the var's new value  */
end_comment

begin_function
name|NODE
modifier|*
modifier|*
name|r_get_lhs
parameter_list|(
name|ptr
parameter_list|,
name|assign
parameter_list|)
specifier|register
name|NODE
modifier|*
name|ptr
decl_stmt|;
name|Func_ptr
modifier|*
name|assign
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
modifier|*
name|aptr
init|=
name|NULL
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|type
condition|)
block|{
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|,
name|ptr
operator|->
name|vname
argument_list|)
expr_stmt|;
case|case
name|Node_var
case|:
name|aptr
operator|=
operator|&
operator|(
name|ptr
operator|->
name|var_value
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|char
operator|)
name|ptr
operator|->
name|var_value
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|Node_FIELDWIDTHS
case|:
name|aptr
operator|=
operator|&
operator|(
name|FIELDWIDTHS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_FIELDWIDTHS
expr_stmt|;
break|break;
case|case
name|Node_RS
case|:
name|aptr
operator|=
operator|&
operator|(
name|RS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_RS
expr_stmt|;
break|break;
case|case
name|Node_FS
case|:
name|aptr
operator|=
operator|&
operator|(
name|FS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_FS
expr_stmt|;
break|break;
case|case
name|Node_FNR
case|:
name|unref
argument_list|(
name|FNR_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|FNR_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|FNR
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|FNR_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_FNR
expr_stmt|;
break|break;
case|case
name|Node_NR
case|:
name|unref
argument_list|(
name|NR_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|NR_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|NR
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|NR_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_NR
expr_stmt|;
break|break;
case|case
name|Node_NF
case|:
if|if
condition|(
name|NF
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|get_field
argument_list|(
name|HUGE
operator|-
literal|1
argument_list|,
name|assign
argument_list|)
expr_stmt|;
comment|/* parse record */
name|unref
argument_list|(
name|NF_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|NF_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|NF
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|NF_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_NF
expr_stmt|;
break|break;
case|case
name|Node_IGNORECASE
case|:
name|unref
argument_list|(
name|IGNORECASE_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|IGNORECASE_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|IGNORECASE
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|IGNORECASE_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_IGNORECASE
expr_stmt|;
break|break;
case|case
name|Node_OFMT
case|:
name|aptr
operator|=
operator|&
operator|(
name|OFMT_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_OFMT
expr_stmt|;
break|break;
case|case
name|Node_CONVFMT
case|:
name|aptr
operator|=
operator|&
operator|(
name|CONVFMT_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_CONVFMT
expr_stmt|;
break|break;
case|case
name|Node_ORS
case|:
name|aptr
operator|=
operator|&
operator|(
name|ORS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_ORS
expr_stmt|;
break|break;
case|case
name|Node_OFS
case|:
name|aptr
operator|=
operator|&
operator|(
name|OFS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|set_OFS
expr_stmt|;
break|break;
case|case
name|Node_param_list
case|:
name|aptr
operator|=
operator|&
operator|(
name|stack_ptr
index|[
name|ptr
operator|->
name|param_cnt
index|]
operator|->
name|var_value
operator|)
expr_stmt|;
break|break;
case|case
name|Node_field_spec
case|:
block|{
name|int
name|field_num
decl_stmt|;
name|n
operator|=
name|tree_eval
argument_list|(
name|ptr
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|field_num
operator|=
operator|(
name|int
operator|)
name|force_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_num
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"attempt to access field %d"
argument_list|,
name|field_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_num
operator|==
literal|0
operator|&&
name|field0_valid
condition|)
block|{
comment|/* short circuit */
name|aptr
operator|=
operator|&
name|fields_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|reset_record
expr_stmt|;
break|break;
block|}
name|aptr
operator|=
name|get_field
argument_list|(
name|field_num
argument_list|,
name|assign
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Node_subscript
case|:
name|n
operator|=
name|ptr
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|n
operator|=
name|stack_ptr
index|[
name|n
operator|->
name|param_cnt
index|]
expr_stmt|;
name|aptr
operator|=
name|assoc_lookup
argument_list|(
name|n
argument_list|,
name|concat_exp
argument_list|(
name|ptr
operator|->
name|rnode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_func
case|:
name|fatal
argument_list|(
literal|"`%s' is a function, assignment is not allowed"
argument_list|,
name|ptr
operator|->
name|lnode
operator|->
name|param
argument_list|)
expr_stmt|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
return|return
name|aptr
return|;
block|}
end_function

begin_function
specifier|static
name|NODE
modifier|*
name|match_op
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|;
specifier|register
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|match
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_nomatch
condition|)
name|match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_regex
condition|)
name|t1
operator|=
operator|*
name|get_field
argument_list|(
literal|0
argument_list|,
operator|(
name|Func_ptr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
block|}
name|rp
operator|=
name|re_update
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|i
operator|=
name|research
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
literal|0
argument_list|,
name|t1
operator|->
name|stlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|==
operator|-
literal|1
operator|)
operator|^
operator|(
name|match
operator|==
literal|1
operator|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|set_IGNORECASE
parameter_list|()
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|do_lint
operator|||
name|do_unix
operator|)
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|"IGNORECASE not supported in compatibility mode"
argument_list|)
expr_stmt|;
block|}
name|IGNORECASE
operator|=
operator|(
name|force_number
argument_list|(
name|IGNORECASE_node
operator|->
name|var_value
argument_list|)
operator|!=
literal|0.0
operator|)
expr_stmt|;
name|set_FS
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_OFS
parameter_list|()
block|{
name|OFS
operator|=
name|force_string
argument_list|(
name|OFS_node
operator|->
name|var_value
argument_list|)
operator|->
name|stptr
expr_stmt|;
name|OFSlen
operator|=
name|OFS_node
operator|->
name|var_value
operator|->
name|stlen
expr_stmt|;
name|OFS
index|[
name|OFSlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_ORS
parameter_list|()
block|{
name|ORS
operator|=
name|force_string
argument_list|(
name|ORS_node
operator|->
name|var_value
argument_list|)
operator|->
name|stptr
expr_stmt|;
name|ORSlen
operator|=
name|ORS_node
operator|->
name|var_value
operator|->
name|stlen
expr_stmt|;
name|ORS
index|[
name|ORSlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|NODE
modifier|*
modifier|*
name|fmt_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fmt_ok
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fmt_index
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fmt_ok
parameter_list|(
name|n
parameter_list|)
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
comment|/* to be done later */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fmt_index
parameter_list|(
name|n
parameter_list|)
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|ix
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|fmt_num
init|=
literal|4
decl_stmt|;
specifier|static
name|int
name|fmt_hiwater
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fmt_list
operator|==
name|NULL
condition|)
name|emalloc
argument_list|(
name|fmt_list
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|fmt_num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fmt_list
argument_list|)
argument_list|,
literal|"fmt_index"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|ix
operator|<
name|fmt_hiwater
condition|)
block|{
if|if
condition|(
name|cmp_nodes
argument_list|(
name|fmt_list
index|[
name|ix
index|]
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ix
return|;
name|ix
operator|++
expr_stmt|;
block|}
comment|/* not found */
name|n
operator|->
name|stptr
index|[
name|n
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fmt_ok
argument_list|(
name|n
argument_list|)
condition|)
name|warning
argument_list|(
literal|"bad FMT specification"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_hiwater
operator|>=
name|fmt_num
condition|)
block|{
name|fmt_num
operator|*=
literal|2
expr_stmt|;
name|emalloc
argument_list|(
name|fmt_list
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|fmt_num
argument_list|,
literal|"fmt_index"
argument_list|)
expr_stmt|;
block|}
name|fmt_list
index|[
name|fmt_hiwater
index|]
operator|=
name|dupnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|fmt_hiwater
operator|++
return|;
block|}
end_function

begin_function
name|void
name|set_OFMT
parameter_list|()
block|{
name|OFMTidx
operator|=
name|fmt_index
argument_list|(
name|OFMT_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|OFMT
operator|=
name|fmt_list
index|[
name|OFMTidx
index|]
operator|->
name|stptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_CONVFMT
parameter_list|()
block|{
name|CONVFMTidx
operator|=
name|fmt_index
argument_list|(
name|CONVFMT_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|CONVFMT
operator|=
name|fmt_list
index|[
name|CONVFMTidx
index|]
operator|->
name|stptr
expr_stmt|;
block|}
end_function

end_unit

