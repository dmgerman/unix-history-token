begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /home/ncvs/src/gnu/usr.bin/patch/inp.c,v 1.6 1997/10/23 02:44:21 ache Exp $  *  * $Log: inp.c,v $  * Revision 1.6  1997/10/23 02:44:21  ache  * Add (unsigned char) cast to ctype macros  *  * Revision 1.5  1997/03/17 01:44:40  jmg  * fix compilation warnings in patch... (with slight modification)  *  * also remove -Wall that I acidentally committed last time I was here...  *  * Submitted-by: Philippe Charnier  *  * Closes PR#2998  *  * Revision 1.4  1997/02/13 21:10:39  jmg  * Fix a problem with patch in that is will always default, even when the  * controlling terminal is closed.  Now the function ask() will return 1 when th  * input is known to come from a file or terminal, or it will return 0 when ther  * was a read error.  *  * Modified the question "Skip patch?" so that on an error from ask it will skip  * the patch instead of looping.  *  * Closes PR#777  *  * 2.2 candidate  *  * Revision 1.3  1995/05/30 05:02:31  rgrimes  * Remove trailing whitespace.  *  * Revision 1.2  1995/01/12  22:09:39  hsu  * Fix bug that created new files even when running in -C check mode.  * Reviewed by: phk  *  * Revision 1.1.1.1  1993/06/19  14:21:52  paul  * b-maked patch-2.10  *  * Revision 2.0.1.1  88/06/03  15:06:13  lwall  * patch10: made a little smarter about sccs files  *  * Revision 2.0  86/09/17  15:37:02  lwall  * Baseline for netwide release.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"pch.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"inp.h"
end_include

begin_comment
comment|/* Input-file-with-indexable-lines abstract type */
end_comment

begin_decl_stmt
specifier|static
name|long
name|i_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the input file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|i_womp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* plan a buffer for entire file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|i_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to lines in i_womp */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tifd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* plan b virtual string array */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tibuf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* plan b buffers */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|tiline
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line in each buffer */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|lines_per_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many lines per buffer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tireclen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of records in tmp file */
end_comment

begin_comment
comment|/* New patch--prepare to edit another file. */
end_comment

begin_function
name|void
name|re_input
parameter_list|()
block|{
if|if
condition|(
name|using_plan_a
condition|)
block|{
name|i_size
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|i_ptr
operator|!=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|i_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i_womp
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|i_womp
argument_list|)
expr_stmt|;
name|i_womp
operator|=
name|Nullch
expr_stmt|;
name|i_ptr
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|using_plan_a
operator|=
name|TRUE
expr_stmt|;
comment|/* maybe the next one is smaller */
name|Close
argument_list|(
name|tifd
argument_list|)
expr_stmt|;
name|tifd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|tibuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tibuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tibuf
index|[
literal|0
index|]
operator|=
name|tibuf
index|[
literal|1
index|]
operator|=
name|Nullch
expr_stmt|;
name|tiline
index|[
literal|0
index|]
operator|=
name|tiline
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|tireclen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Constuct the line index, somehow or other. */
end_comment

begin_function
name|void
name|scan_input
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|plan_a
argument_list|(
name|filename
argument_list|)
condition|)
name|plan_b
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|say3
argument_list|(
literal|"Patching file %s using Plan %s...\n"
argument_list|,
name|filename
argument_list|,
operator|(
name|using_plan_a
condition|?
literal|"A"
else|:
literal|"B"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try keeping everything in memory. */
end_comment

begin_function
name|bool
name|plan_a
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|ifd
decl_stmt|,
name|statfailed
decl_stmt|;
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
name|Reg2
name|LINENUM
name|iline
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|int
name|output_elsewhere
init|=
name|strcmp
argument_list|(
name|filename
argument_list|,
name|outname
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|check_patch
decl_stmt|;
name|statfailed
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
if|if
condition|(
name|statfailed
operator|&&
name|ok_to_create_file
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say2
argument_list|(
literal|"(Creating file %s...)\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_patch
condition|)
return|return
name|TRUE
return|;
name|makedirs
argument_list|(
name|filename
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|filename
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
name|statfailed
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statfailed
operator|&&
name|check_patch
condition|)
block|{
name|fatal2
argument_list|(
literal|"%s not found and in check_patch mode."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* For nonexistent or read-only files, look for RCS or SCCS versions.  */
if|if
condition|(
name|statfailed
operator|||
operator|(
operator|!
name|output_elsewhere
operator|&&
operator|(
comment|/* No one can write to it.  */
operator|(
name|filestat
operator|.
name|st_mode
operator|&
literal|0222
operator|)
operator|==
literal|0
comment|/* I can't write to it.  */
operator|||
operator|(
operator|(
name|filestat
operator|.
name|st_mode
operator|&
literal|0022
operator|)
operator|==
literal|0
operator|&&
name|filestat
operator|.
name|st_uid
operator|!=
name|myuid
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|stat
name|cstat
decl_stmt|;
name|char
modifier|*
name|cs
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|filebase
decl_stmt|;
name|int
name|pathlen
decl_stmt|;
name|filebase
operator|=
name|basename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|pathlen
operator|=
name|filebase
operator|-
name|filename
expr_stmt|;
comment|/* Put any leading path into `s'. 	   Leave room in lbuf for the diff command.  */
name|s
operator|=
name|lbuf
operator|+
literal|20
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|filename
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
define|#
directive|define
name|try
parameter_list|(
name|f
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
value|(Sprintf(s + pathlen, f, a1, a2), stat(s,&cstat) == 0)
if|if
condition|(
operator|(
name|try
argument_list|(
literal|"RCS/%s%s"
argument_list|,
name|filebase
argument_list|,
name|RCSSUFFIX
argument_list|)
operator|||
name|try
argument_list|(
literal|"RCS/%s%s"
argument_list|,
name|filebase
argument_list|,
literal|""
argument_list|)
operator|||
name|try
argument_list|(
literal|"%s%s"
argument_list|,
name|filebase
argument_list|,
name|RCSSUFFIX
argument_list|)
operator|)
operator|&&
comment|/* Check that RCS file is not working file. 	       Some hosts don't report file name length errors.  */
operator|(
name|statfailed
operator|||
operator|(
operator|(
name|filestat
operator|.
name|st_dev
operator|^
name|cstat
operator|.
name|st_dev
operator|)
operator||
operator|(
name|filestat
operator|.
name|st_ino
operator|^
name|cstat
operator|.
name|st_ino
operator|)
operator|)
operator|)
condition|)
block|{
name|Sprintf
argument_list|(
name|buf
argument_list|,
name|output_elsewhere
condition|?
name|CHECKOUT
else|:
name|CHECKOUT_LOCKED
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|lbuf
argument_list|,
name|RCSDIFF
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cs
operator|=
literal|"RCS"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|try
argument_list|(
literal|"SCCS/%s%s"
argument_list|,
name|SCCSPREFIX
argument_list|,
name|filebase
argument_list|)
operator|||
name|try
argument_list|(
literal|"%s%s"
argument_list|,
name|SCCSPREFIX
argument_list|,
name|filebase
argument_list|)
condition|)
block|{
name|Sprintf
argument_list|(
name|buf
argument_list|,
name|output_elsewhere
condition|?
name|GET
else|:
name|GET_LOCKED
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|lbuf
argument_list|,
name|SCCSDIFF
argument_list|,
name|s
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cs
operator|=
literal|"SCCS"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statfailed
condition|)
name|fatal2
argument_list|(
literal|"can't find %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* else we can't write to it but it's not under a version 	   control system, so just proceed.  */
if|if
condition|(
name|cs
condition|)
block|{
if|if
condition|(
operator|!
name|statfailed
condition|)
block|{
if|if
condition|(
operator|(
name|filestat
operator|.
name|st_mode
operator|&
literal|0222
operator|)
operator|!=
literal|0
condition|)
comment|/* The owner can write to it.  */
name|fatal3
argument_list|(
literal|"file %s seems to be locked by somebody else under %s\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
comment|/* It might be checked out unlocked.  See if it's safe to 		   check out the default version locked.  */
if|if
condition|(
name|verbose
condition|)
name|say3
argument_list|(
literal|"Comparing file %s to default %s version...\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|lbuf
argument_list|)
condition|)
name|fatal3
argument_list|(
literal|"can't check out file %s: differs from default %s version\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|say3
argument_list|(
literal|"Checking out file %s from %s...\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|buf
argument_list|)
operator|||
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|filestat
argument_list|)
condition|)
name|fatal3
argument_list|(
literal|"can't check out file %s from %s\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
name|filemode
operator|=
name|filestat
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|filemode
argument_list|)
condition|)
name|fatal2
argument_list|(
literal|"%s is not a normal file--can't patch\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|i_size
operator|=
name|filestat
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|set_hunkmax
argument_list|()
expr_stmt|;
comment|/* make sure dynamic arrays are allocated */
name|out_of_mem
operator|=
name|FALSE
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* force plan b because plan a bombed */
block|}
ifdef|#
directive|ifdef
name|lint
name|i_womp
operator|=
name|Nullch
expr_stmt|;
else|#
directive|else
name|i_womp
operator|=
name|malloc
argument_list|(
call|(
name|MEM
call|)
argument_list|(
name|i_size
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lint says this may alloc less than */
comment|/* i_size, but that's okay, I think. */
endif|#
directive|endif
if|if
condition|(
name|i_womp
operator|==
name|Nullch
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pfatal2
argument_list|(
literal|"can't open file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|read
argument_list|(
name|ifd
argument_list|,
name|i_womp
argument_list|,
operator|(
name|int
operator|)
name|i_size
argument_list|)
operator|!=
name|i_size
condition|)
block|{
name|Close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
comment|/* probably means i_size> 15 or 16 bits worth */
name|free
argument_list|(
name|i_womp
argument_list|)
expr_stmt|;
comment|/* at this point it doesn't matter if i_womp was */
return|return
name|FALSE
return|;
comment|/*   undersized. */
block|}
endif|#
directive|endif
name|Close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_size
operator|&&
name|i_womp
index|[
name|i_size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|i_womp
index|[
name|i_size
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|i_womp
index|[
name|i_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* count the lines in the buffer so we know how many pointers we need */
name|iline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|i_womp
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|iline
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|lint
name|i_ptr
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|i_ptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|MEM
call|)
argument_list|(
operator|(
name|iline
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i_ptr
operator|==
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
block|{
comment|/* shucks, it was a near thing */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|i_womp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* now scan the buffer and build pointer array */
name|iline
operator|=
literal|1
expr_stmt|;
name|i_ptr
index|[
name|iline
index|]
operator|=
name|i_womp
expr_stmt|;
for|for
control|(
name|s
operator|=
name|i_womp
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|i_ptr
index|[
operator|++
name|iline
index|]
operator|=
name|s
operator|+
literal|1
expr_stmt|;
comment|/* these are NOT null terminated */
block|}
name|input_lines
operator|=
name|iline
operator|-
literal|1
expr_stmt|;
comment|/* now check for revision, if any */
if|if
condition|(
name|revision
operator|!=
name|Nullch
condition|)
block|{
if|if
condition|(
operator|!
name|rev_in_string
argument_list|(
name|i_womp
argument_list|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say2
argument_list|(
literal|"Warning: this file doesn't appear to be the %s version--patching anyway.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|batch
condition|)
block|{
name|fatal2
argument_list|(
literal|"this file doesn't appear to be the %s version--aborting.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ask2
argument_list|(
literal|"This file doesn't appear to be the %s version--patch anyway? [n] "
argument_list|,
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
condition|)
name|fatal1
argument_list|(
literal|"aborted\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
name|say2
argument_list|(
literal|"Good.  This file appears to be the %s version.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
comment|/* plan a will work */
block|}
end_function

begin_comment
comment|/* Keep (virtually) nothing in memory. */
end_comment

begin_function
name|void
name|plan_b
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Reg3
name|FILE
modifier|*
name|ifp
decl_stmt|;
name|Reg1
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Reg2
name|int
name|maxlen
init|=
literal|1
decl_stmt|;
name|Reg4
name|bool
name|found_revision
init|=
operator|(
name|revision
operator|==
name|Nullch
operator|)
decl_stmt|;
name|using_plan_a
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|Nullfp
condition|)
name|pfatal2
argument_list|(
literal|"can't open file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tifd
operator|=
name|creat
argument_list|(
name|TMPINNAME
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pfatal2
argument_list|(
literal|"can't open file %s"
argument_list|,
name|TMPINNAME
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|ifp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
if|if
condition|(
name|revision
operator|!=
name|Nullch
operator|&&
operator|!
name|found_revision
operator|&&
name|rev_in_string
argument_list|(
name|buf
argument_list|)
condition|)
name|found_revision
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|i
expr_stmt|;
comment|/* find longest line */
block|}
if|if
condition|(
name|revision
operator|!=
name|Nullch
condition|)
block|{
if|if
condition|(
operator|!
name|found_revision
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say2
argument_list|(
literal|"Warning: this file doesn't appear to be the %s version--patching anyway.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|batch
condition|)
block|{
name|fatal2
argument_list|(
literal|"this file doesn't appear to be the %s version--aborting.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ask2
argument_list|(
literal|"This file doesn't appear to be the %s version--patch anyway? [n] "
argument_list|,
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
condition|)
name|fatal1
argument_list|(
literal|"aborted\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
name|say2
argument_list|(
literal|"Good.  This file appears to be the %s version.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
name|Fseek
argument_list|(
name|ifp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* rewind file */
name|lines_per_buf
operator|=
name|BUFFERSIZE
operator|/
name|maxlen
expr_stmt|;
name|tireclen
operator|=
name|maxlen
expr_stmt|;
name|tibuf
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
call|(
name|MEM
call|)
argument_list|(
name|BUFFERSIZE
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tibuf
index|[
literal|1
index|]
operator|=
name|malloc
argument_list|(
call|(
name|MEM
call|)
argument_list|(
name|BUFFERSIZE
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tibuf
index|[
literal|1
index|]
operator|==
name|Nullch
condition|)
name|fatal1
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|lines_per_buf
operator|)
condition|)
comment|/* new block */
if|if
condition|(
name|write
argument_list|(
name|tifd
argument_list|,
name|tibuf
index|[
literal|0
index|]
argument_list|,
name|BUFFERSIZE
argument_list|)
operator|<
name|BUFFERSIZE
condition|)
name|pfatal1
argument_list|(
literal|"can't write temp file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tibuf
index|[
literal|0
index|]
operator|+
name|maxlen
operator|*
operator|(
name|i
operator|%
name|lines_per_buf
operator|)
argument_list|,
name|maxlen
operator|+
literal|1
argument_list|,
name|ifp
argument_list|)
operator|==
name|Nullch
condition|)
block|{
name|input_lines
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|%
name|lines_per_buf
condition|)
if|if
condition|(
name|write
argument_list|(
name|tifd
argument_list|,
name|tibuf
index|[
literal|0
index|]
argument_list|,
name|BUFFERSIZE
argument_list|)
operator|<
name|BUFFERSIZE
condition|)
name|pfatal1
argument_list|(
literal|"can't write temp file"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|Fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|Close
argument_list|(
name|tifd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tifd
operator|=
name|open
argument_list|(
name|TMPINNAME
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|pfatal2
argument_list|(
literal|"can't reopen file %s"
argument_list|,
name|TMPINNAME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch a line from the input file, \n terminated, not necessarily \0. */
end_comment

begin_function
name|char
modifier|*
name|ifetch
parameter_list|(
name|line
parameter_list|,
name|whichbuf
parameter_list|)
name|Reg1
name|LINENUM
name|line
decl_stmt|;
name|int
name|whichbuf
decl_stmt|;
comment|/* ignored when file in memory */
block|{
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|input_lines
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|using_plan_a
condition|)
return|return
name|i_ptr
index|[
name|line
index|]
return|;
else|else
block|{
name|LINENUM
name|offline
init|=
name|line
operator|%
name|lines_per_buf
decl_stmt|;
name|LINENUM
name|baseline
init|=
name|line
operator|-
name|offline
decl_stmt|;
if|if
condition|(
name|tiline
index|[
literal|0
index|]
operator|==
name|baseline
condition|)
name|whichbuf
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tiline
index|[
literal|1
index|]
operator|==
name|baseline
condition|)
name|whichbuf
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|tiline
index|[
name|whichbuf
index|]
operator|=
name|baseline
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
comment|/* complains of long accuracy */
name|Lseek
argument_list|(
name|tifd
argument_list|,
operator|(
name|long
operator|)
name|baseline
operator|/
name|lines_per_buf
operator|*
name|BUFFERSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|read
argument_list|(
name|tifd
argument_list|,
name|tibuf
index|[
name|whichbuf
index|]
argument_list|,
name|BUFFERSIZE
argument_list|)
operator|<
literal|0
condition|)
name|pfatal2
argument_list|(
literal|"error reading tmp file %s"
argument_list|,
name|TMPINNAME
argument_list|)
expr_stmt|;
block|}
return|return
name|tibuf
index|[
name|whichbuf
index|]
operator|+
operator|(
name|tireclen
operator|*
name|offline
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* True if the string argument contains the revision number we want. */
end_comment

begin_function
name|bool
name|rev_in_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
name|Reg2
name|int
name|patlen
decl_stmt|;
if|if
condition|(
name|revision
operator|==
name|Nullch
condition|)
return|return
name|TRUE
return|;
name|patlen
operator|=
name|strlen
argument_list|(
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|string
argument_list|,
name|revision
argument_list|,
name|patlen
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|patlen
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|s
operator|=
name|string
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
operator|&&
name|strnEQ
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|revision
argument_list|,
name|patlen
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
name|patlen
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

end_unit

