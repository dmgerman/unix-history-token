begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$  *  * $Log: pch.c,v $  * Revision 2.0.2.0  90/05/01  22:17:51  davison  * patch12u: unidiff support added  *  * Revision 2.0.1.7  88/06/03  15:13:28  lwall  * patch10: Can now find patches in shar scripts.  * patch10: Hunks that swapped and then swapped back could core dump.  *  * Revision 2.0.1.6  87/06/04  16:18:13  lwall  * pch_swap didn't swap p_bfake and p_efake.  *  * Revision 2.0.1.5  87/01/30  22:47:42  lwall  * Improved responses to mangled patches.  *  * Revision 2.0.1.4  87/01/05  16:59:53  lwall  * New-style context diffs caused double call to free().  *  * Revision 2.0.1.3  86/11/14  10:08:33  lwall  * Fixed problem where a long pattern wouldn't grow the hunk.  * Also restored p_input_line when backtracking so error messages are right.  *  * Revision 2.0.1.2  86/11/03  17:49:52  lwall  * New-style delete triggers spurious assertion error.  *  * Revision 2.0.1.1  86/10/29  15:52:08  lwall  * Could falsely report new-style context diff.  *  * Revision 2.0  86/09/17  15:39:37  lwall  * Baseline for netwide release.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"pch.h"
end_include

begin_comment
comment|/* Patch (diff listing) abstract type. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|p_filesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the patch file */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_newfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number of replacement */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_ptrn_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in pattern */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_repl_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in replacement text */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_end
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line in hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowed value of p_end */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_context
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of context lines */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_input_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line # from patch file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|p_line
init|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the text of the hunk */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|p_len
init|=
name|Null
argument_list|(
name|short
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of each line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_Char
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* +, -, and ! */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hunkmax
init|=
name|INITHUNKMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of above arrays to begin with */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indent to patch */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to intuit this time */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line # of p_base */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where intuit found a patch */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_sline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the line number for it */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_hunk_beg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_efake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of faked up lines--don't free */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bfake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beg of faked up lines */
end_comment

begin_comment
comment|/* Prepare to look for the next patch in the patch file. */
end_comment

begin_function
name|void
name|re_patch
parameter_list|()
block|{
name|p_first
operator|=
name|Nulline
expr_stmt|;
name|p_newfirst
operator|=
name|Nulline
expr_stmt|;
name|p_ptrn_lines
operator|=
name|Nulline
expr_stmt|;
name|p_repl_lines
operator|=
name|Nulline
expr_stmt|;
name|p_end
operator|=
operator|(
name|LINENUM
operator|)
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
name|Nulline
expr_stmt|;
name|p_indent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open the patch file at the beginning of time. */
end_comment

begin_function
name|void
name|open_patch_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|filename
operator|==
name|Nullch
operator|||
operator|!
operator|*
name|filename
operator|||
name|strEQ
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|pfp
operator|=
name|fopen
argument_list|(
name|TMPPATNAME
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|Nullfp
condition|)
name|pfatal2
argument_list|(
literal|"can't create %s"
argument_list|,
name|TMPPATNAME
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|Nullch
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|Fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|filename
operator|=
name|TMPPATNAME
expr_stmt|;
block|}
name|pfp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|Nullfp
condition|)
name|pfatal2
argument_list|(
literal|"patch file %s not found"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|Fstat
argument_list|(
name|fileno
argument_list|(
name|pfp
argument_list|)
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
name|p_filesize
operator|=
name|filestat
operator|.
name|st_size
expr_stmt|;
name|next_intuit_at
argument_list|(
literal|0L
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|/* start at the beginning */
name|set_hunkmax
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure our dynamically realloced tables are malloced to begin with. */
end_comment

begin_function
name|void
name|set_hunkmax
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|p_line
operator|==
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
name|p_line
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|MEM
operator|)
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_len
operator|==
name|Null
argument_list|(
name|short
operator|*
argument_list|)
condition|)
name|p_len
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|MEM
operator|)
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p_Char
operator|==
name|Nullch
condition|)
name|p_Char
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|MEM
operator|)
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enlarge the arrays containing the current hunk of patch. */
end_comment

begin_function
name|void
name|grow_hunkmax
parameter_list|()
block|{
name|hunkmax
operator|*=
literal|2
expr_stmt|;
comment|/*      * Note that on most systems, only the p_line array ever gets fresh memory      * since p_len can move into p_line's old space, and p_Char can move into      * p_len's old space.  Not on PDP-11's however.  But it doesn't matter.      */
name|assert
argument_list|(
name|p_line
operator|!=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|&&
name|p_len
operator|!=
name|Null
argument_list|(
name|short
operator|*
argument_list|)
operator|&&
name|p_Char
operator|!=
name|Nullch
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|p_line
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_line
argument_list|,
operator|(
name|MEM
operator|)
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_len
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_len
argument_list|,
operator|(
name|MEM
operator|)
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|p_Char
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_Char
argument_list|,
operator|(
name|MEM
operator|)
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p_line
operator|!=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|&&
name|p_len
operator|!=
name|Null
argument_list|(
name|short
operator|*
argument_list|)
operator|&&
name|p_Char
operator|!=
name|Nullch
condition|)
return|return;
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|fatal1
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|out_of_mem
operator|=
name|TRUE
expr_stmt|;
comment|/* whatever is null will be allocated again */
comment|/* from within plan_a(), of all places */
block|}
end_function

begin_comment
comment|/* True if the remainder of the patch file contains a diff of some sort. */
end_comment

begin_function
name|bool
name|there_is_another_patch
parameter_list|()
block|{
if|if
condition|(
name|p_base
operator|!=
literal|0L
operator|&&
name|p_base
operator|>=
name|p_filesize
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say1
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|say1
argument_list|(
literal|"Hmm..."
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|intuit_diff_type
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|diff_type
condition|)
block|{
if|if
condition|(
name|p_base
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say1
argument_list|(
literal|"  Ignoring the trailing garbage.\ndone\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|say1
argument_list|(
literal|"  I can't seem to find a patch in there anywhere.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|say3
argument_list|(
literal|"  %sooks like %s to me...\n"
argument_list|,
operator|(
name|p_base
operator|==
literal|0L
condition|?
literal|"L"
else|:
literal|"The next patch l"
operator|)
argument_list|,
name|diff_type
operator|==
name|UNI_DIFF
condition|?
literal|"a unified diff"
else|:
name|diff_type
operator|==
name|CONTEXT_DIFF
condition|?
literal|"a context diff"
else|:
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
condition|?
literal|"a new-style context diff"
else|:
name|diff_type
operator|==
name|NORMAL_DIFF
condition|?
literal|"a normal diff"
else|:
literal|"an ed script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_indent
operator|&&
name|verbose
condition|)
name|say3
argument_list|(
literal|"(Patch is indented %d space%s.)\n"
argument_list|,
name|p_indent
argument_list|,
name|p_indent
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|skip_to
argument_list|(
name|p_start
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
while|while
condition|(
name|filearg
index|[
literal|0
index|]
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|force
operator|||
name|batch
operator|||
name|skip_rest_of_patch
condition|)
block|{
name|say1
argument_list|(
literal|"No file to patch.  Skipping...\n"
argument_list|)
expr_stmt|;
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|bestguess
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|ask1
argument_list|(
literal|"File to patch: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|bestguess
condition|)
name|free
argument_list|(
name|bestguess
argument_list|)
expr_stmt|;
name|bestguess
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|filearg
index|[
literal|0
index|]
operator|=
name|fetchname
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filearg
index|[
literal|0
index|]
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|ask1
argument_list|(
literal|"No file found--skip this patch? [n] "
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
name|say1
argument_list|(
literal|"Skipping patch...\n"
argument_list|)
expr_stmt|;
name|filearg
index|[
literal|0
index|]
operator|=
name|fetchname
argument_list|(
name|bestguess
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine what kind of diff is in the remaining part of the patch file. */
end_comment

begin_function
name|int
name|intuit_diff_type
parameter_list|()
block|{
name|Reg4
name|long
name|this_line
init|=
literal|0
decl_stmt|;
name|Reg5
name|long
name|previous_line
decl_stmt|;
name|Reg6
name|long
name|first_command_line
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|fcl_line
decl_stmt|;
name|Reg7
name|bool
name|last_line_was_command
init|=
name|FALSE
decl_stmt|;
name|Reg8
name|bool
name|this_is_a_command
init|=
name|FALSE
decl_stmt|;
name|Reg9
name|bool
name|stars_last_line
init|=
name|FALSE
decl_stmt|;
name|Reg10
name|bool
name|stars_this_line
init|=
name|FALSE
decl_stmt|;
name|Reg3
name|int
name|indent
decl_stmt|;
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
name|Reg2
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|indtmp
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|oldtmp
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|newtmp
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|indname
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|oldname
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|Nullch
decl_stmt|;
name|Reg11
name|int
name|retval
decl_stmt|;
name|bool
name|no_filearg
init|=
operator|(
name|filearg
index|[
literal|0
index|]
operator|==
name|Nullch
operator|)
decl_stmt|;
specifier|extern
name|int
name|index_first
decl_stmt|;
name|ok_to_create_file
operator|=
name|FALSE
expr_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|p_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|p_bline
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|previous_line
operator|=
name|this_line
expr_stmt|;
name|last_line_was_command
operator|=
name|this_is_a_command
expr_stmt|;
name|stars_last_line
operator|=
name|stars_this_line
expr_stmt|;
name|this_line
operator|=
name|ftell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|first_command_line
operator|>=
literal|0L
condition|)
block|{
comment|/* nothing but deletes!? */
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
else|else
block|{
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'X'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|indent
operator|+=
literal|8
operator|-
operator|(
name|indent
operator|%
literal|8
operator|)
expr_stmt|;
else|else
name|indent
operator|++
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|this_is_a_command
operator|=
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|first_command_line
operator|<
literal|0L
operator|&&
name|this_is_a_command
condition|)
block|{
name|first_command_line
operator|=
name|this_line
expr_stmt|;
name|fcl_line
operator|=
name|p_input_line
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
comment|/* assume this for now */
block|}
if|if
condition|(
operator|!
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
name|oldtmp
operator|=
name|savestr
argument_list|(
name|s
operator|+
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"--- "
argument_list|,
literal|4
argument_list|)
condition|)
name|newtmp
operator|=
name|savestr
argument_list|(
name|s
operator|+
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"+++ "
argument_list|,
literal|4
argument_list|)
condition|)
name|oldtmp
operator|=
name|savestr
argument_list|(
name|s
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* pretend it is the old name */
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Index:"
argument_list|,
literal|6
argument_list|)
condition|)
name|indtmp
operator|=
name|savestr
argument_list|(
name|s
operator|+
literal|6
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Prereq:"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|7
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|revision
operator|=
name|savestr
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|revision
init|;
operator|*
name|t
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|revision
condition|)
block|{
name|free
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|revision
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|ED_DIFF
operator|)
operator|&&
name|first_command_line
operator|>=
literal|0L
operator|&&
name|strEQ
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|)
condition|)
block|{
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|UNI_DIFF
operator|)
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
operator|+
literal|3
argument_list|)
condition|)
name|ok_to_create_file
operator|=
name|TRUE
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
name|UNI_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
name|stars_this_line
operator|=
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|)
operator|&&
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
operator|+
literal|4
argument_list|)
condition|)
name|ok_to_create_file
operator|=
name|TRUE
expr_stmt|;
comment|/* if this is a new context diff the character just before */
comment|/* the newline is a '*'. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'*'
condition|?
name|NEW_CONTEXT_DIFF
else|:
name|CONTEXT_DIFF
operator|)
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|NORMAL_DIFF
operator|)
operator|&&
name|last_line_was_command
operator|&&
operator|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"< "
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"> "
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|retval
operator|=
name|NORMAL_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
name|scan_exit
label|:
if|if
condition|(
name|no_filearg
condition|)
block|{
if|if
condition|(
name|indtmp
operator|!=
name|Nullch
condition|)
name|indname
operator|=
name|fetchname
argument_list|(
name|indtmp
argument_list|,
name|strippath
argument_list|,
name|ok_to_create_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtmp
operator|!=
name|Nullch
condition|)
name|oldname
operator|=
name|fetchname
argument_list|(
name|oldtmp
argument_list|,
name|strippath
argument_list|,
name|ok_to_create_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtmp
operator|!=
name|Nullch
condition|)
name|newname
operator|=
name|fetchname
argument_list|(
name|newtmp
argument_list|,
name|strippath
argument_list|,
name|ok_to_create_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_first
operator|&&
name|indname
condition|)
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|indname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldname
operator|&&
name|newname
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|<
name|strlen
argument_list|(
name|newname
argument_list|)
condition|)
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
else|else
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indname
condition|)
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|indname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldname
condition|)
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newname
condition|)
name|filearg
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bestguess
condition|)
block|{
name|free
argument_list|(
name|bestguess
argument_list|)
expr_stmt|;
name|bestguess
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|filearg
index|[
literal|0
index|]
operator|!=
name|Nullch
condition|)
name|bestguess
operator|=
name|savestr
argument_list|(
name|filearg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indtmp
operator|!=
name|Nullch
condition|)
name|bestguess
operator|=
name|fetchname
argument_list|(
name|indtmp
argument_list|,
name|strippath
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|oldtmp
operator|!=
name|Nullch
condition|)
name|oldname
operator|=
name|fetchname
argument_list|(
name|oldtmp
argument_list|,
name|strippath
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtmp
operator|!=
name|Nullch
condition|)
name|newname
operator|=
name|fetchname
argument_list|(
name|newtmp
argument_list|,
name|strippath
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldname
operator|&&
name|newname
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|<
name|strlen
argument_list|(
name|newname
argument_list|)
condition|)
name|bestguess
operator|=
name|savestr
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
else|else
name|bestguess
operator|=
name|savestr
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldname
condition|)
name|bestguess
operator|=
name|savestr
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newname
condition|)
name|bestguess
operator|=
name|savestr
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indtmp
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|indtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtmp
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|oldtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtmp
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|newtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|indname
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|indname
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldname
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Remember where this patch ends so we know where to start up again. */
end_comment

begin_function
name|void
name|next_intuit_at
parameter_list|(
name|file_pos
parameter_list|,
name|file_line
parameter_list|)
name|long
name|file_pos
decl_stmt|;
name|long
name|file_line
decl_stmt|;
block|{
name|p_base
operator|=
name|file_pos
expr_stmt|;
name|p_bline
operator|=
name|file_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basically a verbose fseek() to the actual diff listing. */
end_comment

begin_function
name|void
name|skip_to
parameter_list|(
name|file_pos
parameter_list|,
name|file_line
parameter_list|)
name|long
name|file_pos
decl_stmt|;
name|long
name|file_line
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|p_base
operator|<=
name|file_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|p_base
operator|<
name|file_pos
condition|)
block|{
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|p_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|say1
argument_list|(
literal|"The text leading up to this was:\n--------------------------\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftell
argument_list|(
name|pfp
argument_list|)
operator|<
name|file_pos
condition|)
block|{
name|ret
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Nullch
argument_list|)
expr_stmt|;
name|say2
argument_list|(
literal|"|%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|say1
argument_list|(
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|file_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|file_line
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make this a function for better debugging.  */
end_comment

begin_function
specifier|static
name|void
name|malformed
parameter_list|()
block|{
name|fatal3
argument_list|(
literal|"malformed patch at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* about as informative as "Syntax error" in C */
block|}
end_function

begin_comment
comment|/* True if there is more of the current diff listing to process. */
end_comment

begin_function
name|bool
name|another_hunk
parameter_list|()
block|{
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
name|Reg8
name|char
modifier|*
name|ret
decl_stmt|;
name|Reg2
name|int
name|context
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p_end
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
name|p_efake
condition|)
name|p_end
operator|=
name|p_bfake
expr_stmt|;
comment|/* don't free twice */
else|else
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|--
expr_stmt|;
block|}
name|assert
argument_list|(
name|p_end
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_efake
operator|=
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
comment|/* gets reduced when --- found */
if|if
condition|(
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|||
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
condition|)
block|{
name|long
name|line_beginning
init|=
name|ftell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
comment|/* file pos of the current line */
name|LINENUM
name|repl_beginning
init|=
literal|0
decl_stmt|;
comment|/* index of --- line */
name|Reg4
name|LINENUM
name|fillcnt
init|=
literal|0
decl_stmt|;
comment|/* #lines of missing ptrn or repl */
name|Reg5
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of first line to copy */
name|Reg6
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of first missing line */
name|bool
name|ptrn_spaces_eaten
init|=
name|FALSE
decl_stmt|;
comment|/* ptrn was slightly misformed */
name|Reg9
name|bool
name|repl_could_be_missing
init|=
name|TRUE
decl_stmt|;
comment|/* no + or ! lines in this hunk */
name|bool
name|repl_missing
init|=
name|FALSE
decl_stmt|;
comment|/* we are now backtracking */
name|long
name|repl_backtrack_position
init|=
literal|0
decl_stmt|;
comment|/* file pos of first repl line */
name|LINENUM
name|repl_patch_line
decl_stmt|;
comment|/* input line number for same */
name|Reg7
name|LINENUM
name|ptrn_copiable
init|=
literal|0
decl_stmt|;
comment|/* # of copiable lines in ptrn */
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
operator|||
name|strnNE
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_context
operator|=
literal|100
expr_stmt|;
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_end
operator|<
name|p_max
condition|)
block|{
name|line_beginning
operator|=
name|ftell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|p_max
operator|-
name|p_end
operator|<
literal|4
condition|)
name|Strcpy
argument_list|(
name|buf
argument_list|,
literal|"  \n"
argument_list|)
expr_stmt|;
comment|/* assume blank lines got chopped */
else|else
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal1
argument_list|(
literal|"unexpected end of file in patch\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|p_end
operator|++
expr_stmt|;
name|assert
argument_list|(
name|p_end
operator|<
name|hunkmax
argument_list|)
expr_stmt|;
name|p_Char
index|[
name|p_end
index|]
operator|=
operator|*
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|zilog
name|p_line
index|[
operator|(
name|short
operator|)
name|p_end
index|]
operator|=
name|Nullch
expr_stmt|;
else|#
directive|else
name|p_line
index|[
name|p_end
index|]
operator|=
name|Nullch
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
else|else
name|fatal2
argument_list|(
literal|"unexpected end of hunk at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_end
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal3
argument_list|(
literal|"unexpected *** at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
literal|0
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"0,0"
argument_list|,
literal|3
argument_list|)
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_ptrn_lines
operator|=
operator|(
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
operator|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_first
condition|)
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_first
operator|=
literal|1
expr_stmt|;
block|}
name|p_max
operator|=
name|p_ptrn_lines
operator|+
literal|6
expr_stmt|;
comment|/* we need this much at least */
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|||
operator|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
operator|+
operator|(
name|p_Char
index|[
name|p_end
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
literal|1
condition|)
block|{
comment|/* `old' lines were omitted - set up to fill */
comment|/* them in from 'new' context lines. */
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|fillsrc
operator|=
name|p_end
operator|+
literal|1
expr_stmt|;
name|filldst
operator|=
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_ptrn_lines
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|repl_beginning
condition|)
block|{
if|if
condition|(
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal3
argument_list|(
literal|"duplicate \"---\" at line %ld--check line numbers at line %ld\n"
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
operator|+
name|repl_beginning
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fatal4
argument_list|(
literal|"%s \"---\" at line %ld--check line numbers at line %ld\n"
argument_list|,
operator|(
name|p_end
operator|<=
name|p_ptrn_lines
condition|?
literal|"Premature"
else|:
literal|"Overdue"
operator|)
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|repl_beginning
operator|=
name|p_end
expr_stmt|;
name|repl_backtrack_position
operator|=
name|ftell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|repl_patch_line
operator|=
name|p_input_line
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_Char
index|[
name|p_end
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_repl_lines
operator|=
operator|(
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
operator|)
operator|-
name|p_newfirst
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_newfirst
condition|)
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|1
expr_stmt|;
block|}
name|p_max
operator|=
name|p_repl_lines
operator|+
name|p_end
expr_stmt|;
if|if
condition|(
name|p_max
operator|>
name|MAXHUNKSIZE
condition|)
name|fatal4
argument_list|(
literal|"hunk too large (%ld lines) at line %ld: %s"
argument_list|,
name|p_max
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_repl_lines
operator|!=
name|ptrn_copiable
operator|&&
operator|(
name|p_context
operator|!=
literal|0
operator|||
name|p_repl_lines
operator|!=
literal|1
operator|)
condition|)
name|repl_could_be_missing
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
goto|goto
name|change_line
goto|;
case|case
literal|'+'
case|:
case|case
literal|'!'
case|:
name|repl_could_be_missing
operator|=
name|FALSE
expr_stmt|;
name|change_line
label|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|canonicalize
condition|)
name|strcpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'>'
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'<'
operator|&&
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
if|if
condition|(
name|context
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|context
operator|<
name|p_context
condition|)
name|p_context
operator|=
name|context
expr_stmt|;
name|context
operator|=
operator|-
literal|1000
expr_stmt|;
block|}
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
comment|/* assume the 2 spaces got eaten */
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
operator|&&
operator|(
operator|!
name|ptrn_spaces_eaten
operator|||
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
operator|)
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
condition|)
block|{
name|ptrn_spaces_eaten
operator||=
operator|(
name|repl_beginning
operator|!=
literal|0
operator|)
expr_stmt|;
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|p_Char
index|[
name|p_end
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|malformed
argument_list|()
expr_stmt|;
block|}
comment|/* set up p_len for strncmp() so we don't have to */
comment|/* assume null termination */
if|if
condition|(
name|p_line
index|[
name|p_end
index|]
condition|)
name|p_len
index|[
name|p_end
index|]
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
else|else
name|p_len
index|[
name|p_end
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|hunk_done
label|:
if|if
condition|(
name|p_end
operator|>=
literal|0
operator|&&
operator|!
name|repl_beginning
condition|)
name|fatal2
argument_list|(
literal|"no --- found in patch at line %ld\n"
argument_list|,
name|pch_hunk_beg
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_missing
condition|)
block|{
comment|/* reset state back to just after --- */
name|p_input_line
operator|=
name|repl_patch_line
expr_stmt|;
for|for
control|(
name|p_end
operator|--
init|;
name|p_end
operator|>
name|repl_beginning
condition|;
name|p_end
operator|--
control|)
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|repl_backtrack_position
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* redundant 'new' context lines were omitted - set */
comment|/* up to fill them in from the old file context */
if|if
condition|(
operator|!
name|p_context
operator|&&
name|p_repl_lines
operator|==
literal|1
condition|)
block|{
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_max
operator|--
expr_stmt|;
block|}
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|repl_beginning
operator|+
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_repl_lines
expr_stmt|;
name|p_end
operator|=
name|p_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p_context
operator|&&
name|fillcnt
operator|==
literal|1
condition|)
block|{
comment|/* the first hunk was a null hunk with no context */
comment|/* and we were expecting one line -- fix it up. */
while|while
condition|(
name|filldst
operator|<
name|p_end
condition|)
block|{
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|p_Char
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|repl_beginning--;
comment|/* this doesn't need to be fixed */
endif|#
directive|endif
name|p_end
operator|--
expr_stmt|;
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|fillcnt
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|&&
operator|(
name|fillcnt
operator|||
operator|(
name|p_first
operator|>
literal|1
operator|&&
name|ptrn_copiable
operator|>
literal|2
operator|*
name|p_context
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say4
argument_list|(
literal|"%s\n%s\n%s\n"
argument_list|,
literal|"(Fascinating--this is really a new-style context diff but without"
argument_list|,
literal|"the telltale extra asterisks on the *** line that usually indicate"
argument_list|,
literal|"the new style...)"
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|NEW_CONTEXT_DIFF
expr_stmt|;
block|}
comment|/* if there were omitted context lines, fill them in now */
if|if
condition|(
name|fillcnt
condition|)
block|{
name|p_bfake
operator|=
name|filldst
expr_stmt|;
comment|/* remember where not to free() */
name|p_efake
operator|=
name|filldst
operator|+
name|fillcnt
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|fillcnt
operator|--
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|p_Char
index|[
name|fillsrc
index|]
operator|!=
literal|' '
condition|)
name|fillsrc
operator|++
expr_stmt|;
if|if
condition|(
name|fillsrc
operator|>
name|p_end
condition|)
name|fatal2
argument_list|(
literal|"replacement text or line numbers mangled in hunk at line %ld\n"
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|p_Char
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|fillsrc
index|]
expr_stmt|;
name|fillsrc
operator|++
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
operator|&&
name|p_Char
index|[
name|fillsrc
index|]
operator|!=
literal|' '
condition|)
name|fillsrc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|64
condition|)
name|printf
argument_list|(
literal|"fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n"
argument_list|,
name|fillsrc
argument_list|,
name|filldst
argument_list|,
name|repl_beginning
argument_list|,
name|p_end
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|fillsrc
operator|==
name|p_end
operator|+
literal|1
operator|||
name|fillsrc
operator|==
name|repl_beginning
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|filldst
operator|==
name|p_end
operator|+
literal|1
operator|||
name|filldst
operator|==
name|repl_beginning
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|diff_type
operator|==
name|UNI_DIFF
condition|)
block|{
name|long
name|line_beginning
init|=
name|ftell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
comment|/* file pos of the current line */
name|Reg4
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of old lines */
name|Reg5
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of new lines */
name|char
name|ch
decl_stmt|;
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
operator|||
name|strnNE
argument_list|(
name|buf
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'+'
operator|||
operator|!
operator|*
operator|++
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_repl_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'@'
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptrn_lines
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|p_max
operator|=
name|p_ptrn_lines
operator|+
name|p_repl_lines
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|fillsrc
operator|+
name|p_ptrn_lines
expr_stmt|;
name|p_end
operator|=
name|filldst
operator|+
name|p_repl_lines
expr_stmt|;
name|Sprintf
argument_list|(
name|buf
argument_list|,
literal|"*** %ld,%ld ****\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|Sprintf
argument_list|(
name|buf
argument_list|,
literal|"--- %ld,%ld ----\n"
argument_list|,
name|p_newfirst
argument_list|,
name|p_newfirst
operator|+
name|p_repl_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_Char
index|[
name|filldst
operator|++
index|]
operator|=
literal|'='
expr_stmt|;
name|p_context
operator|=
literal|100
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|fillsrc
operator|<=
name|p_ptrn_lines
operator|||
name|filldst
operator|<=
name|p_end
condition|)
block|{
name|line_beginning
operator|=
name|ftell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|p_max
operator|-
name|filldst
operator|<
literal|3
condition|)
name|Strcpy
argument_list|(
name|buf
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
comment|/* assume blank lines got chopped */
else|else
block|{
name|fatal1
argument_list|(
literal|"unexpected end of file in patch\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\t'
operator|||
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* assume the space got eaten */
name|s
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|*
name|buf
expr_stmt|;
name|s
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_of_mem
condition|)
block|{
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|fillsrc
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|filldst
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|p_Char
index|[
name|fillsrc
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillsrc
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillsrc
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|' '
case|:
if|if
condition|(
name|fillsrc
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|context
operator|++
expr_stmt|;
name|p_Char
index|[
name|fillsrc
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillsrc
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillsrc
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'+'
case|:
if|if
condition|(
name|filldst
operator|>
name|p_end
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|p_Char
index|[
name|filldst
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|filldst
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p_end
operator|=
name|filldst
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|' '
operator|&&
name|context
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|context
operator|<
name|p_context
condition|)
name|p_context
operator|=
name|context
expr_stmt|;
name|context
operator|=
operator|-
literal|1000
expr_stmt|;
block|}
block|}
comment|/* while */
block|}
else|else
block|{
comment|/* normal diff--fake it up */
name|char
name|hunk_type
decl_stmt|;
name|Reg3
name|int
name|i
decl_stmt|;
name|LINENUM
name|min
decl_stmt|,
name|max
decl_stmt|;
name|long
name|line_beginning
init|=
name|ftell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
name|p_context
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
operator|(
operator|*
name|s
operator|!=
literal|'a'
operator|)
expr_stmt|;
name|hunk_type
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'a'
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|min
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|max
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
else|else
name|max
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'d'
condition|)
name|min
operator|++
expr_stmt|;
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
operator|+
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p_end
operator|>
name|MAXHUNKSIZE
condition|)
name|fatal4
argument_list|(
literal|"hunk too large (%ld lines) at line %ld: %s"
argument_list|,
name|p_end
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_end
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
name|min
expr_stmt|;
name|p_repl_lines
operator|=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
name|Sprintf
argument_list|(
name|buf
argument_list|,
literal|"*** %ld,%ld\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_ptrn_lines
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
condition|)
name|fatal2
argument_list|(
literal|"unexpected end of file in patch at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'<'
condition|)
name|fatal2
argument_list|(
literal|"< expected at line %ld of patch\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p_Char
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
name|hunk_type
operator|==
literal|'c'
condition|)
block|{
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
condition|)
name|fatal2
argument_list|(
literal|"unexpected end of file in patch at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'-'
condition|)
name|fatal2
argument_list|(
literal|"--- expected at line %ld of patch\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
name|Sprintf
argument_list|(
name|buf
argument_list|,
literal|"--- %ld,%ld\n"
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Nullch
condition|)
name|fatal2
argument_list|(
literal|"unexpected end of file in patch at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'>'
condition|)
name|fatal2
argument_list|(
literal|"> expected at line %ld of patch\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p_Char
index|[
name|i
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reverse
condition|)
comment|/* backwards patch? */
if|if
condition|(
operator|!
name|pch_swap
argument_list|()
condition|)
name|say1
argument_list|(
literal|"Not enough memory to swap next hunk!\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|special
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|p_ptrn_lines
condition|)
name|special
operator|=
literal|'^'
expr_stmt|;
else|else
name|special
operator|=
literal|' '
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d %c %c %s"
argument_list|,
name|i
argument_list|,
name|p_Char
index|[
name|i
index|]
argument_list|,
name|special
argument_list|,
name|p_line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|p_end
operator|+
literal|1
operator|<
name|hunkmax
condition|)
comment|/* paranoia reigns supreme... */
name|p_Char
index|[
name|p_end
operator|+
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
comment|/* add a stopper for apply_hunk */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Input a line from the patch file, worrying about indentation. */
end_comment

begin_function
name|char
modifier|*
name|pgets
parameter_list|(
name|bf
parameter_list|,
name|sz
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|bf
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
init|=
name|fgets
argument_list|(
name|bf
argument_list|,
name|sz
argument_list|,
name|fp
argument_list|)
decl_stmt|;
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
name|Reg2
name|int
name|indent
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p_indent
operator|&&
name|ret
operator|!=
name|Nullch
condition|)
block|{
for|for
control|(
name|s
operator|=
name|buf
init|;
name|indent
operator|<
name|p_indent
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'X'
operator|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|indent
operator|+=
literal|8
operator|-
operator|(
name|indent
operator|%
literal|7
operator|)
expr_stmt|;
else|else
name|indent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
name|s
condition|)
name|Strcpy
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Reverse the old and new portions of the current hunk. */
end_comment

begin_function
name|bool
name|pch_swap
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|tp_line
decl_stmt|;
comment|/* the text of the hunk */
name|short
modifier|*
name|tp_len
decl_stmt|;
comment|/* length of each line */
name|char
modifier|*
name|tp_char
decl_stmt|;
comment|/* +, -, and ! */
name|Reg1
name|LINENUM
name|i
decl_stmt|;
name|Reg2
name|LINENUM
name|n
decl_stmt|;
name|bool
name|blankline
init|=
name|FALSE
decl_stmt|;
name|Reg3
name|char
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|p_first
expr_stmt|;
name|p_first
operator|=
name|p_newfirst
expr_stmt|;
name|p_newfirst
operator|=
name|i
expr_stmt|;
comment|/* make a scratch copy */
name|tp_line
operator|=
name|p_line
expr_stmt|;
name|tp_len
operator|=
name|p_len
expr_stmt|;
name|tp_char
operator|=
name|p_Char
expr_stmt|;
name|p_line
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
comment|/* force set_hunkmax to allocate again */
name|p_len
operator|=
name|Null
argument_list|(
name|short
operator|*
argument_list|)
expr_stmt|;
name|p_Char
operator|=
name|Nullch
expr_stmt|;
name|set_hunkmax
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_line
operator|==
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|||
name|p_len
operator|==
name|Null
argument_list|(
name|short
operator|*
argument_list|)
operator|||
name|p_Char
operator|==
name|Nullch
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|p_line
operator|==
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_line
argument_list|)
expr_stmt|;
name|p_line
operator|=
name|tp_line
expr_stmt|;
if|if
condition|(
name|p_len
operator|==
name|Null
argument_list|(
name|short
operator|*
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_len
argument_list|)
expr_stmt|;
name|p_len
operator|=
name|tp_len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p_Char
operator|==
name|Nullch
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_Char
argument_list|)
expr_stmt|;
name|p_Char
operator|=
name|tp_char
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* not enough memory to swap hunk! */
block|}
comment|/* now turn the new into the old */
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tp_char
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* account for possible blank line */
name|blankline
operator|=
name|TRUE
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_efake
operator|>=
literal|0
condition|)
block|{
comment|/* fix non-freeable ptr range */
if|if
condition|(
name|p_efake
operator|<=
name|i
condition|)
name|n
operator|=
name|p_end
operator|-
name|i
operator|+
literal|1
expr_stmt|;
else|else
name|n
operator|=
operator|-
name|i
expr_stmt|;
name|p_efake
operator|+=
name|n
expr_stmt|;
name|p_bfake
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_Char
index|[
name|n
index|]
operator|==
literal|'+'
condition|)
name|p_Char
index|[
name|n
index|]
operator|=
literal|'-'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|blankline
condition|)
block|{
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|p_Char
index|[
literal|0
index|]
operator|==
literal|'='
argument_list|)
expr_stmt|;
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|s
operator|=
literal|'*'
expr_stmt|;
comment|/* now turn the old into the new */
name|assert
argument_list|(
name|tp_char
index|[
literal|0
index|]
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|tp_char
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tp_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
operator|*
name|s
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_Char
index|[
name|n
index|]
operator|==
literal|'-'
condition|)
name|p_Char
index|[
name|n
index|]
operator|=
literal|'+'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|p_ptrn_lines
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|p_ptrn_lines
expr_stmt|;
name|p_ptrn_lines
operator|=
name|p_repl_lines
expr_stmt|;
name|p_repl_lines
operator|=
name|i
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|tp_line
operator|==
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tp_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_len
operator|==
name|Null
argument_list|(
name|short
operator|*
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tp_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp_char
operator|==
name|Nullch
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tp_char
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the specified line position in the old file of the old context. */
end_comment

begin_function
name|LINENUM
name|pch_first
parameter_list|()
block|{
return|return
name|p_first
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines of old context. */
end_comment

begin_function
name|LINENUM
name|pch_ptrn_lines
parameter_list|()
block|{
return|return
name|p_ptrn_lines
return|;
block|}
end_function

begin_comment
comment|/* Return the probable line position in the new file of the first line. */
end_comment

begin_function
name|LINENUM
name|pch_newfirst
parameter_list|()
block|{
return|return
name|p_newfirst
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines in the replacement text including context. */
end_comment

begin_function
name|LINENUM
name|pch_repl_lines
parameter_list|()
block|{
return|return
name|p_repl_lines
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines in the whole hunk. */
end_comment

begin_function
name|LINENUM
name|pch_end
parameter_list|()
block|{
return|return
name|p_end
return|;
block|}
end_function

begin_comment
comment|/* Return the number of context lines before the first changed line. */
end_comment

begin_function
name|LINENUM
name|pch_context
parameter_list|()
block|{
return|return
name|p_context
return|;
block|}
end_function

begin_comment
comment|/* Return the length of a particular patch line. */
end_comment

begin_function
name|short
name|pch_line_len
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_len
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the control character (+, -, *, !, etc) for a patch line. */
end_comment

begin_function
name|char
name|pch_char
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_Char
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a particular patch line. */
end_comment

begin_function
name|char
modifier|*
name|pfetch
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_line
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return where in the patch file this hunk began, for error messages. */
end_comment

begin_function
name|LINENUM
name|pch_hunk_beg
parameter_list|()
block|{
return|return
name|p_hunk_beg
return|;
block|}
end_function

begin_comment
comment|/* Apply an ed script by feeding ed itself. */
end_comment

begin_function
name|void
name|do_ed_script
parameter_list|()
block|{
name|Reg1
name|char
modifier|*
name|t
decl_stmt|;
name|Reg2
name|long
name|beginning_of_this_line
decl_stmt|;
name|Reg3
name|bool
name|this_line_is_command
init|=
name|FALSE
decl_stmt|;
name|Reg4
name|FILE
modifier|*
name|pipefp
decl_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
block|{
name|Unlink
argument_list|(
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|filearg
index|[
literal|0
index|]
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|Sprintf
argument_list|(
name|buf
argument_list|,
literal|"/bin/ed %s"
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
else|else
name|Sprintf
argument_list|(
name|buf
argument_list|,
literal|"/bin/ed - %s"
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|pipefp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|beginning_of_this_line
operator|=
name|ftell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
operator|==
name|Nullch
condition|)
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
name|p_input_line
operator|++
expr_stmt|;
for|for
control|(
name|t
operator|=
name|buf
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|this_line_is_command
operator|=
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this_line_is_command
condition|)
block|{
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'d'
condition|)
block|{
while|while
condition|(
name|pgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|".\n"
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|skip_rest_of_patch
condition|)
return|return;
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"w\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"q\n"
argument_list|)
expr_stmt|;
name|Fflush
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
name|Pclose
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
name|ignore_signals
argument_list|()
expr_stmt|;
if|if
condition|(
name|move_file
argument_list|(
name|TMPOUTNAME
argument_list|,
name|outname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|toutkeep
operator|=
name|TRUE
expr_stmt|;
name|chmod
argument_list|(
name|TMPOUTNAME
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
block|}
else|else
name|chmod
argument_list|(
name|outname
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
name|set_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

