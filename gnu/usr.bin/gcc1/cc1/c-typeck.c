begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)c-typeck.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_function_decl
name|int
name|mark_addressable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_for_assignment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compparms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|comp_target_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|shorten_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|binary_op_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_int_sum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_diff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_sequence
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|process_init_constructor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|digest_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|truthvalue_conversion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|invert_truthvalue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|incomplete_type_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|readonly_warning
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return the _TYPE node describing the data type    of the data which NODE represents as a C expression.    Arrays and functions are converted to pointers    just as they are when they appear as C expressions.  */
end_comment

begin_function
name|tree
name|datatype
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
name|value
return|;
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
name|error
argument_list|(
literal|"`%s' has an incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `struct %s'"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `union %s'"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `enum %s'"
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
name|errmsg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
name|error
argument_list|(
literal|"invalid use of incomplete typedef `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
name|int
name|constflag
init|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|like
argument_list|)
decl_stmt|;
name|int
name|volflag
init|=
name|TREE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|like
argument_list|)
decl_stmt|;
return|return
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constflag
argument_list|,
name|volflag
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This is the type for the result of most arithmetic operations    if the operands have the given two types.     We do not deal with enumeral types here because they have already been    converted to integer types.  */
end_comment

begin_function
name|tree
name|commontype
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|form1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form2
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|form1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|form2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|form1
operator|==
name|REAL_TYPE
operator|&&
name|form2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|form2
operator|==
name|REAL_TYPE
operator|&&
name|form1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t2
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|t1
operator|==
name|long_unsigned_type_node
operator|||
name|t2
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|t1
operator|==
name|long_integer_type_node
operator|||
name|t2
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|long_unsigned_type_node
return|;
return|return
name|long_integer_type_node
return|;
block|}
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
else|else
return|return
name|t2
return|;
case|case
name|POINTER_TYPE
case|:
if|#
directive|if
literal|0
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
block|{ 	tree target = commontype (TYPE_MAIN_VARIANT (TREE_TYPE (t1)), 				   TYPE_MAIN_VARIANT (TREE_TYPE (t2))); 	int constp 	  = TREE_READ_ONLY (TREE_TYPE (t1)) || TREE_READ_ONLY (TREE_TYPE (t2)); 	int volatilep 	  = TREE_VOLATILE (TREE_TYPE (t1)) || TREE_VOLATILE (TREE_TYPE (t2)); 	return build_pointer_type (c_build_type_variant (target, constp, volatilep));       }
endif|#
directive|endif
return|return
name|build_pointer_type
argument_list|(
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
return|return
name|build_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
comment|/* If both args specify argument types, we must merge the two 	   lists, argument by argument.  */
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|commontype
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|newargs
argument_list|)
return|;
block|}
default|default:
return|return
name|t1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  This is what ANSI C speaks of as    "being the same".  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|type1
decl_stmt|;
specifier|register
name|tree
name|t2
init|=
name|type2
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors */
if|if
condition|(
name|t1
operator|==
name|t2
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
return|return
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ARRAY_TYPE
case|:
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|{
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.  */
end_comment

begin_function
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
block|{
return|return
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two parameter type lists PARMS1 and PARMS2    are equivalent in the sense that functions with those parameter types    can have equivalent types.    If either list is empty, we win.    Otherwise, the two lists must be equivalent, element by element.  */
end_comment

begin_function
specifier|static
name|int
name|compparms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
name|compparms1
argument_list|(
name|t2
argument_list|)
return|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|compparms1
argument_list|(
name|t1
argument_list|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|compparms1
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|signed_char_type_node
operator|||
name|type
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|unsigned_char_type_node
operator|||
name|type
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|get_floating_type
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"sizeof applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"sizeof applied to a void type"
argument_list|)
expr_stmt|;
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
return|return
name|convert_units
argument_list|(
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
comment|/* Convert in case a char is more than one unit.  */
return|return
name|convert_units
argument_list|(
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|build_int
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|build_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
specifier|static
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  */
operator|&&
name|current_function_decl
operator|!=
literal|0
operator|&&
operator|!
name|pedantic
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_LITERAL
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Arrays and functions are converted to pointers;    enumeral types or short or char, to int.    In addition, manifest constants symbols are replaced by their values.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|dt
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
condition|)
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since EXP is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|ENUMERAL_TYPE
operator|||
operator|(
name|form
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|dt
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Traditionally, unsignedness is preserved in default promotions.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|dt
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
name|dt
operator|==
name|float_type_node
condition|)
return|return
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|form
operator|==
name|FUNCTION_TYPE
condition|)
block|{
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|form
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|restype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|default_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|restype
operator|=
name|c_build_type_variant
argument_list|(
name|restype
argument_list|,
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_LITERAL
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|;
block|{
specifier|register
name|tree
name|basename
init|=
name|datum
decl_stmt|;
specifier|register
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|basename
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
comment|/* First, see if there is a field or component with name COMPONENT. */
if|if
condition|(
name|form
operator|==
name|RECORD_TYPE
operator|||
name|form
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|basetype
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
name|form
operator|==
name|RECORD_TYPE
condition|?
literal|"structure has no member named `%s'"
else|:
literal|"union has no member named `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|basename
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|basename
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|basename
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|form
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a structure or union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.  */
end_comment

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|dt
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dt
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|dt
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
init|=
name|build
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"dereferencing pointer to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
name|index
operator|=
name|default_conversion
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_REGDECL
argument_list|(
name|foo
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are.  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
name|PLUS_EXPR
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.  */
end_comment

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|;
specifier|register
name|tree
name|value_type
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|actualparameterlist
parameter_list|()
function_decl|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
name|function
operator|=
name|build
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object is not a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|actualparameterlist
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|value_type
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value_type
operator|==
name|void_type_node
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the actual parameter expressions in the list VALUES    to the types in the list TYPELIST.    If parmdecls is exhausted, or when an element has NULL as its type,    perform the default conversions.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.        Return a list of expressions for the parameters as converted.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.  */
end_comment

begin_function
name|tree
name|actualparameterlist
parameter_list|(
name|typelist
parameter_list|,
name|values
parameter_list|,
name|name
parameter_list|)
name|tree
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL
decl_stmt|;
specifier|register
name|ordinal
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
init|;
name|valtail
condition|;
operator|++
name|ordinal
operator|,
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too many arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"parameter type of called function is incomplete"
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
comment|/* Rather than truncating and then reextending, 		 convert directly to int, if that's the type we will want.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
name|parmval
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
literal|"argument passing"
argument_list|,
name|ordinal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|parm
operator|=
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|parm
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|parm
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|chainon
argument_list|(
name|result
argument_list|,
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too few arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression, after performing default    conversions on the operands.  CODE is the kind of expression to build.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
return|return
name|build_binary_op_nodefault
argument_list|(
name|code
argument_list|,
name|default_conversion
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|default_conversion
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     ERROR_CODE is the code that determines what to say in error messages.    It is usually, but not always, the same as CODE.     Note that the operands will never have enumeral types    because either they have just had the default conversions performed    or they have both just been converted to some other type in which    the arithmetic is to be done.  */
end_comment

begin_function
name|tree
name|build_binary_op_nodefault
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|error_code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tree_code
name|error_code
decl_stmt|;
block|{
name|tree
name|dt0
init|=
name|datatype
argument_list|(
name|op0
argument_list|)
decl_stmt|,
name|dt1
init|=
name|datatype
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
specifier|register
name|enum
name|tree_code
name|code0
init|=
name|TREE_CODE
argument_list|(
name|dt0
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
init|=
name|TREE_CODE
argument_list|(
name|dt1
argument_list|)
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      give it this type.  Otherwise, give it type RESULT_TYPE.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
name|shorten
operator|=
literal|1
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If one operand is a constant, and the other is a short type 	 that has been converted to an int, 	 really do the work in the short type and then convert the 	 result to int.  If we are lucky, the constant will be 0 or 1 	 in the short type, making the entire operation go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|dt1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|dt0
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
comment|/* Result of these operations is always an int, 	     but that does not mean the operands should be 	     converted to ints!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|dt0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|dt0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|dt0
expr_stmt|;
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
comment|/* Result of comparison is always int, 	 but don't convert the args to int!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|tt0
init|=
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|dt1
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be the same.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt0
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If args are not valid, clear out RESULT_TYPE 	   to cause an error message later.  */
name|result_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|commontype
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|converted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|commontype
argument_list|(
name|dt0
argument_list|,
name|dt1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|arg0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|arg1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
operator|,
name|result_type
operator|=
name|xresult_type
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|error_code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_LITERAL
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_LITERAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
specifier|register
name|tree
name|result_type
init|=
name|datatype
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"pointer of type `void *' used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|warning
argument_list|(
literal|"pointer to a function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|c_sizeof
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_LITERAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_LITERAL
argument_list|(
name|size_exp
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intop
operator|=
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as a pointer      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument      with a suitable product by the object size.  */
name|intop
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|size_exp
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_LITERAL
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_LITERAL
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|tree
name|dt0
init|=
name|datatype
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"pointer of type `void *' used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"pointer to a function used in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|dt0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_LITERAL
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_LITERAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation CODE.    NOP_EXPR is used as a special case (see truthvalue_conversion).  */
end_comment

begin_function
specifier|static
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op_nodefault, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.     The arguments of this function are all pointers to local variables    of build_binary_op_nodefault: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
specifier|static
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  */
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|primop0
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
specifier|register
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_lt
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
comment|/* This is the case of (char)x>?< 0x80, which people used to use 	     expecting old C compilers to change the 0x80 into -0x80.  */
if|if
condition|(
name|val
operator|==
name|integer_zero_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|integer_one_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|integer_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  NOCONVERT nonzero suppresses    the default promotions (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary plus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary minus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
operator|&&
name|typecode
operator|!=
name|POINTER_TYPE
comment|/* This will convert to a pointer.  */
operator|&&
name|typecode
operator|!=
name|ARRAY_TYPE
operator|&&
name|typecode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|errstring
operator|=
literal|"wrong type argument to unary exclamation mark"
expr_stmt|;
break|break;
block|}
name|arg
operator|=
name|truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
break|break;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Report invalid types.  */
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"wrong type argument to increment"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"wrong type argument to decrement"
expr_stmt|;
break|break;
block|}
comment|/* Report something read-only.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"wrong type argument to %s"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Don't let this be an lvalue.  */
if|if
condition|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Address of a cast is just a cast of the address 	 of the operand of the cast.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids the address of a cast expression"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_LITERAL
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
name|argtype
operator|=
name|c_build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|offset
init|=
name|build_int_2
argument_list|(
operator|(
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
operator|=
name|argtype
expr_stmt|;
name|addr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|addr
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   function counts as a constant */
name|TREE_LITERAL
argument_list|(
name|addr
argument_list|)
operator|=
name|staticp
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_sequence
parameter_list|(
name|conversions
parameter_list|,
name|arg
parameter_list|)
name|tree
name|conversions
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|conversions
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|conversions
argument_list|)
argument_list|,
name|convert_sequence
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conversions
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|arg
return|;
block|}
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|pedantic
condition|)
return|return
literal|0
return|;
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
operator|(
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Warn about storing in something that is `const'.  */
end_comment

begin_function
name|void
name|readonly_warning
parameter_list|(
name|arg
parameter_list|,
name|string
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only member `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only variable `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, integer_zero_node),    but we optimize comparisons,&&, ||, and !  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|form
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since EXPR is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* A one-bit unsigned bit-field is already acceptable.  */
if|if
condition|(
name|form
operator|==
name|COMPONENT_REF
operator|&&
literal|1
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
literal|1
operator|==
name|DECL_SIZE_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|form
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|form
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|form
operator|==
name|TRUTH_AND_EXPR
operator|||
name|form
operator|==
name|TRUTH_OR_EXPR
operator|||
name|form
operator|==
name|TRUTH_NOT_EXPR
operator|||
name|form
operator|==
name|EQ_EXPR
operator|||
name|form
operator|==
name|NE_EXPR
operator|||
name|form
operator|==
name|LE_EXPR
operator|||
name|form
operator|==
name|GE_EXPR
operator|||
name|form
operator|==
name|LT_EXPR
operator|||
name|form
operator|==
name|GT_EXPR
operator|||
name|form
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
comment|/* Unary minus has no effect on whether its argument is nonzero.  */
if|if
condition|(
name|form
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
if|if
condition|(
name|form
operator|==
name|COND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Sign-extension and zero-extension has no effect.  */
if|if
condition|(
name|form
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|build_binary_op_nodefault
argument_list|(
name|NE_EXPR
argument_list|,
name|default_conversion
argument_list|(
name|expr
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|NOP_EXPR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG    (perhaps by altering ARG).    If it can't be simplified, return 0.  */
end_comment

begin_function
specifier|static
name|tree
name|invert_truthvalue
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|EQ_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|GE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|LT_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|GT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|LE_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|LE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|GT_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|LT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|arg
argument_list|,
name|GE_EXPR
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
case|case
name|TRUTH_AND_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is 1 if successful.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of global register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|warning
argument_list|(
literal|"address of register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* drops in */
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
specifier|register
name|tree
name|type1
decl_stmt|;
specifier|register
name|tree
name|type2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* If second operand is omitted, it is the same as the first one;      make sure it is calculated only once.  */
if|if
condition|(
name|op1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
name|ifexp
operator|=
name|op1
operator|=
name|save_expr
argument_list|(
name|ifexp
argument_list|)
expr_stmt|;
block|}
name|ifexp
operator|=
name|truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|ifexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* Produces wrong result if within sizeof.  */
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
block|if (TREE_TYPE (op1) == TREE_TYPE (op2)&& TREE_CODE (TREE_TYPE (op1)) != ARRAY_TYPE&& TREE_CODE (TREE_TYPE (op1)) != ENUMERAL_TYPE&& TREE_CODE (TREE_TYPE (op1)) != FUNCTION_TYPE)     {       if (TREE_LITERAL (ifexp)&& (TREE_CODE (ifexp) == INTEGER_CST 	      || TREE_CODE (ifexp) == ADDR_EXPR)) 	return (integer_zerop (ifexp) ? op2 : op1);        return build (COND_EXPR, TREE_TYPE (op1), ifexp, op1, op2);     }
endif|#
directive|endif
comment|/* They don't match; promote them both and then try to reconcile them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|commontype
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
name|result_type
operator|=
name|commontype
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|==
name|void_type_node
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
operator|==
name|void_type_node
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op2
argument_list|)
condition|)
name|warning
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The spec seems to say this is permitted.  */
block|if (pedantic&& TREE_CODE (type1) == FUNCTION_TYPE) 	    warning ("ANSI C forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The spec seems to say this is permitted.  */
block|if (pedantic&& TREE_CODE (type2) == FUNCTION_TYPE) 	    warning ("ANSI C forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (code1 == RECORD_TYPE || code1 == UNION_TYPE)     {       result_type = TREE_TYPE (op1);       if (TREE_LITERAL (ifexp)) 	return (integer_zerop (ifexp) ? op2 : op1);        if (TYPE_MODE (result_type) == BLKmode) 	{ 	  register tree tempvar 	    = build_decl (VAR_DECL, NULL_TREE, result_type); 	  register tree xop1 = build_modify_expr (tempvar, op1); 	  register tree xop2 = build_modify_expr (tempvar, op2); 	  register tree result = build (COND_EXPR, result_type, 					ifexp, xop1, xop2);  	  layout_decl (tempvar);
comment|/* No way to handle variable-sized objects here. 	     I fear that the entire handling of BLKmode conditional exprs 	     needs to be redone.  */
block|if (! TREE_LITERAL (DECL_SIZE (tempvar))) 	    abort (); 	  DECL_RTL (tempvar) 	    = assign_stack_local (DECL_MODE (tempvar), 				  (TREE_INT_CST_LOW (DECL_SIZE (tempvar)) 				   * DECL_SIZE_UNIT (tempvar) 				   + BITS_PER_UNIT - 1) 				  / BITS_PER_UNIT);  	  TREE_VOLATILE (result) 	    = TREE_VOLATILE (ifexp) | TREE_VOLATILE (op1) 	      | TREE_VOLATILE (op2); 	  return build (COMPOUND_EXPR, result_type, result, tempvar); 	}     }
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
operator|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
operator|)
return|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since LIST is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
name|rest
operator|=
name|build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is patched out so that sizeof (0, array) is distinguishable from      sizeof array.  */
if|#
directive|if
literal|0
block|if (! TREE_VOLATILE (TREE_VALUE (list)))     return rest;
endif|#
directive|endif
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids casting nonscalar to the same type"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|;
comment|/* Convert functions and arrays to pointers, 	 but don't convert any other types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrysome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast discards `volatile' from pointer target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast discards `const' from pointer target type"
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|expr
condition|)
block|{
comment|/* Always produce some operator for an explicit cast, 	 so we can tell (for -pedantic) that the cast is no lvalue.  */
name|tree
name|nvalue
init|=
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|TREE_LITERAL
argument_list|(
name|nvalue
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|nvalue
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle control structure constructs used as "lvalues".  */
if|if
condition|(
operator|!
name|pedantic
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	     except that the RHS goes through a save-expr 	     so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure the code to compute the rhs comes out 	     before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* Cast to void to suppress warning 			   from warn_if_unused_value.  */
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the true type of the lhs and store there;      then cast the result back to the specified type to be the value      of the assignment.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|newrhs
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Warn about storing in something that is `const'.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower than one,      we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if EXP is not a valid lvalue in this language    even though `lvalue_or_else' would accept it.  */
end_comment

begin_function
name|int
name|language_lvalue_valid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.    If NUM is positive, ERRTYPE is a printf format    that contains a %d to print NUM.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|num
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Arithmetic types all interconvert, and enum is treated like int.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
condition|)
name|warning_with_arg
argument_list|(
literal|"%s between incompatible pointer types"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
name|warning_with_arg
argument_list|(
literal|"%s of non-const * pointer from const *"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TREE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
name|warning_with_arg
argument_list|(
literal|"%s of non-volatile * pointer from volatile *"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|warning_with_arg
argument_list|(
literal|"%s between incompatible pointer types"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|warning_with_arg
argument_list|(
literal|"%s of pointer from integer lacks a cast"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|null_pointer_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|warning_with_arg
argument_list|(
literal|"%s of integer from pointer lacks a cast"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
name|error_with_arg
argument_list|(
literal|"incompatible types in %s"
argument_list|,
name|errtype
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return 1 if the value is absolute; return 2 if it is relocatable.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
specifier|static
name|int
name|initializer_constant_valid_p
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|ADDR_EXPR
case|:
return|return
literal|2
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Allow conversions between types of the same kind.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Allow (int)&foo.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
block|{
name|int
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid0
operator|==
literal|1
operator|&&
name|valid1
operator|==
literal|2
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|valid0
operator|==
literal|2
operator|&&
name|valid1
operator|==
literal|1
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
case|case
name|MINUS_EXPR
case|:
block|{
name|int
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid0
operator|==
literal|2
operator|&&
name|valid1
operator|==
literal|1
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.  */
end_comment

begin_function
name|void
name|store_init_value
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer for static variable is not constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer for static variable uses complicated arithmetic"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"aggregate initializer is not constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"aggregate initializer uses complicated arithmetic"
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     If TAIL is nonzero, it points to a variable holding a list of elements    of which INIT is the first.  We update the list stored there by    removing from the head all the elements that we use.    Normally this is only one; we use more than one element only if    TYPE is an aggregate and INIT is not a constructor.  */
end_comment

begin_function
name|tree
name|digest_init
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|tail
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|element
init|=
literal|0
decl_stmt|;
name|tree
name|old_tail_contents
decl_stmt|;
comment|/* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR      tree node which has no TREE_TYPE.  */
name|int
name|raw_constructor
init|=
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
literal|0
decl_stmt|;
comment|/* By default, assume we use one element from a list.      We correct this later in the sole case where it is not true.  */
if|if
condition|(
name|tail
condition|)
block|{
name|old_tail_contents
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|init
return|;
if|if
condition|(
name|init
operator|&&
name|raw_constructor
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|element
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Any type can be initialized from an expression of the same type,      optionally with braces.  */
if|if
condition|(
name|init
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|type
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|STRING_CST
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids initializing array from array expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|TREE_READONLY
argument_list|(
name|init
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|decl_constant_value
argument_list|(
name|init
argument_list|)
return|;
return|return
name|init
return|;
block|}
if|if
condition|(
name|element
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|==
name|type
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|code
operator|==
name|ARRAY_TYPE
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids initializing array from array expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"single-expression nonscalar initializer has braces"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|TREE_READONLY
argument_list|(
name|element
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|decl_constant_value
argument_list|(
name|element
argument_list|)
return|;
return|return
name|element
return|;
block|}
comment|/* Check for initializing a union by its first field.      Such an initializer must use braces.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"union with no members cannot be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|raw_constructor
condition|)
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
operator|*
name|tail
operator|=
name|old_tail_contents
expr_stmt|;
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|tail
argument_list|)
return|;
block|}
block|}
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|typ1
operator|==
name|char_type_node
operator|||
name|typ1
operator|==
name|signed_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_type_node
operator|||
name|typ1
operator|==
name|integer_type_node
operator|)
operator|&&
operator|(
operator|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|||
operator|(
name|element
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
block|{
name|tree
name|string
init|=
name|element
condition|?
name|element
else|:
name|init
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"int-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_LITERAL
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Subtract 1 because it's ok to ignore the terminating null char 		 that is counted in the length of the constant.  */
if|if
condition|(
name|size
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
block|}
comment|/* Handle scalar types, including conversions.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
block|{
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"initializer for scalar variable requires one element"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|init
operator|=
name|element
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|error
argument_list|(
literal|"initializer for scalar has extra braces"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|default_conversion
argument_list|(
name|init
argument_list|)
argument_list|,
literal|"initialization"
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Come here only for records and arrays.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|||
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
operator|*
name|tail
operator|=
name|old_tail_contents
expr_stmt|;
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|tail
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|flag_traditional
condition|)
comment|/* Traditionally one can say `char x[100] = 0;'.  */
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Process a constructor for a variable of type TYPE.    The constructor elements may be specified either with INIT or with ELTS,    only one of which should be non-null.     If INIT is specified, it is a CONSTRUCTOR node which is specifically    and solely for initializing this datum.     If ELTS is specified, it is the address of a variable containing    a list of expressions.  We take as many elements as we need    from the head of the list and update the list.     In the resulting constructor, TREE_LITERAL is set if all elts are    constant, and TREE_STATIC is set if, in addition, all elts are simple enough    constants that the assembler and linker can compute them.  */
end_comment

begin_function
specifier|static
name|tree
name|process_init_constructor
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|elts
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|elts
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* List of the elements of the result constructor,      in reverse order.  */
specifier|register
name|tree
name|members
init|=
name|NULL
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|allconstant
init|=
literal|1
decl_stmt|;
name|int
name|allsimple
init|=
literal|1
decl_stmt|;
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
comment|/* Make TAIL be the list of elements to use for the initialization,      no matter how the data was given to us.  */
if|if
condition|(
name|elts
condition|)
name|tail
operator|=
operator|*
name|elts
expr_stmt|;
else|else
name|tail
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Gobble as many elements as needed, and make a constructor or initial value      for each element of this aggregate.  Chain them together in result.      If there are too few, use 0 for each scalar ultimate component.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|long
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|domain
condition|)
name|len
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Take as many as there are */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|len
operator|<
literal|0
operator|||
name|i
operator|<
name|len
operator|)
operator|&&
name|tail
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|next1
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|tail1
operator|&&
name|len
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-empty initializer for array of empty elements"
argument_list|)
expr_stmt|;
comment|/* Just ignore what we were supposed to use.  */
name|tail1
operator|=
literal|0
expr_stmt|;
block|}
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|error_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
specifier|register
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|&&
name|tail
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
specifier|register
name|tree
name|next1
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|integer_zero_node
argument_list|,
name|members
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|error_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
specifier|register
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|next1
decl_stmt|;
comment|/* For a union, get the initializer for 1 fld.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|error_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
comment|/* If arguments were specified as a list, just remove the ones we used.  */
if|if
condition|(
name|elts
condition|)
operator|*
name|elts
operator|=
name|tail
expr_stmt|;
comment|/* If arguments were specified as a constructor,      complain unless we used all the elements of the constructor.  */
elseif|else
if|if
condition|(
name|tail
condition|)
name|warning
argument_list|(
literal|"excess elements in aggregate initializer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|members
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allconstant
condition|)
name|TREE_LITERAL
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allconstant
operator|&&
name|allsimple
condition|)
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* Record the contents of OUTPUTS before it is modifed.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Don't do this--it screws up operands expected to be in memory.  */
comment|/* Perform default conversions on all inputs.  */
block|for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), i++)     TREE_VALUE (tail) = default_conversion (TREE_VALUE (tail));
endif|#
directive|endif
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.  */
end_comment

begin_function
name|void
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `volatile' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn_return_type
operator|&&
name|valtype
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|convert_for_assignment
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|,
literal|"return"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a C switch statement, testing expression EXP.    Return EXP if it is valid, an error node otherwise.  */
end_comment

begin_function
name|tree
name|c_expand_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|INTEGER_TYPE
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|index
decl_stmt|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|index
operator|=
name|get_unwidened
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	 because if we did, int_fits_type_p would do the wrong thing 	 when checking case values for being in range, 	 and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|index
expr_stmt|;
block|}
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|exp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

end_unit

