begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimize by combining instructions for GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module is essentially the "combiner" phase of the U. of Arizona    Portable Optimizer, but redone to work on our list-structured    representation for RTL instead of their string representation.     The LOG_LINKS of each insn identify the most recent assignment    to each REG used in the insn.  It is a list of previous insns,    each of which contains a SET for a REG that is used in this insn    and not used or set in between.  LOG_LINKs never cross basic blocks.    They were set up by the preceding pass (lifetime analysis).     We try to combine each pair of insns joined by a logical link.    We also try to combine triples of insns A, B and C when    C has a link back to B and B has a link back to A.     LOG_LINKS does not have links for use of the CC0.  They don't    need to, because the insn that sets the CC0 is always immediately    before the insn that tests it.  So we always regard a branch    insn as having a logical link to the preceding insn.     We check (with use_crosses_set_p) to avoid combining in such a way    as to move a computation to a place where its value would be different.     Combination is done by mathematically substituting the previous    insn(s) values for the regs they set into the expressions in    the later insns that refer to these regs.  If the result is a valid insn    for our target machine, according to the machine description,    we install it, delete the earlier insns, and update the data flow    information (LOG_LINKS and REG_NOTES) for what we did.     To simplify substitution, we combine only when the earlier insn(s)    consist of only a single assignment.  To simplify updating afterward,    we never combine when a subroutine call appears in the middle.     Since we do not represent assignments to CC0 explicitly except when that    is all an insn does, there is no LOG_LINKS entry in an insn that uses    the condition code for the insn that set the condition code.    Fortunately, these two insns must be consecutive.    Therefore, every JUMP_INSN is taken to have an implicit logical link    to the preceding insn.  This is not quite right, since non-jumps can    also use the condition code; but in practice such insns would not    combine anyway.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_comment
comment|/* It is not safe to use ordinary gen_lowpart in combine.    Use gen_lowpart_for_combine instead.  See comments there.  */
end_comment

begin_define
define|#
directive|define
name|gen_lowpart
value|dont_use_gen_lowpart_you_dummy
end_define

begin_comment
comment|/* Number of attempts to combine instructions in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_attempts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|distrib_attempts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of attempts that got as far as substitution in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_merges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|distrib_merges_1
decl_stmt|,
name|distrib_merges_2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of instructions combined with added SETs in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_extras
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of instructions combined in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_successes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|distrib_successes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Totals over entire compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_attempts
decl_stmt|,
name|total_merges
decl_stmt|,
name|total_extras
decl_stmt|,
name|total_successes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_distrib_attempts
decl_stmt|,
name|total_distrib_merges_1
decl_stmt|,
name|total_distrib_merges_2
decl_stmt|,
name|total_distrib_successes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector mapping INSN_UIDs to cuids.    The cuids are like uids but increase monononically always.    Combine always uses cuids so that it can compare them.    But actually renumbering the uids, which we used to do,    proves to be a bad idea because it makes it hard to compare    the dumps produced by earlier passes with those from later passes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Record last point of death of (hard or pseudo) register n.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_death
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record last point of modification of (hard or pseudo) register n.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the cuid of the last insn that invalidated memory    (anything that writes memory, and subroutine calls).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mem_last_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the cuid of the last CALL_INSN    so we can tell whether a potential combination crosses any calls.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_call_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When `subst' is called, this is the insn that is being modified    (by combining in a previous insn).  The PATTERN of this insn    is still the old pattern partially modified and it should not be    looked at, but this may be used to examine the successors of the insn    to judge whether a simplification is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|subst_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record one modification to rtl structure    to be undone by storing old_contents into *where.    is_int is 1 if the contents are an int.  */
end_comment

begin_struct
struct|struct
name|undo
block|{
name|rtx
modifier|*
name|where
decl_stmt|;
name|rtx
name|old_contents
decl_stmt|;
name|int
name|is_int
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|undo_int
block|{
name|int
modifier|*
name|where
decl_stmt|;
name|int
name|old_contents
decl_stmt|;
name|int
name|is_int
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record a bunch of changes to be undone, up to MAX_UNDO of them.    num_undo says how many are currently recorded.    storage is nonzero if we must undo the allocation of new storage.    The value of storage is what to pass to obfree.  */
end_comment

begin_define
define|#
directive|define
name|MAX_UNDO
value|10
end_define

begin_struct
struct|struct
name|undobuf
block|{
name|int
name|num_undo
decl_stmt|;
name|char
modifier|*
name|storage
decl_stmt|;
name|struct
name|undo
name|undo
index|[
name|MAX_UNDO
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|undobuf
name|undobuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times the pseudo being substituted for    was found and replaced.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|move_deaths
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_deaths_2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|remove_death
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_dead_and_set_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|regno_dead_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|use_crosses_set_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_combine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|try_distrib
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|subst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|undo_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_substitutions
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_links
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_links
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_incs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adjacent_insns_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_asm_operands
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_and_const_int
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_lowpart_for_combine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|simplify_set_cc0_and
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Main entry point for combiner.  F is the first insn of the function.    NREGS is the first unused pseudo-reg number.  */
end_comment

begin_function
name|void
name|combine_instructions
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|links
decl_stmt|,
name|nextlinks
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|combine_attempts
operator|=
literal|0
expr_stmt|;
name|combine_merges
operator|=
literal|0
expr_stmt|;
name|combine_extras
operator|=
literal|0
expr_stmt|;
name|combine_successes
operator|=
literal|0
expr_stmt|;
name|distrib_attempts
operator|=
literal|0
expr_stmt|;
name|distrib_merges_1
operator|=
literal|0
expr_stmt|;
name|distrib_merges_2
operator|=
literal|0
expr_stmt|;
name|distrib_successes
operator|=
literal|0
expr_stmt|;
name|reg_last_death
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_last_death
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Compute maximum uid value so uid_cuid can be allocated.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|i
condition|)
name|i
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|uid_cuid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to cuids.      Cuids are numbers assigned to insns, like uids,      except that cuids increase monotonically through the code.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
comment|/* Now scan all the insns in forward order.  */
name|last_call_cuid
operator|=
literal|0
expr_stmt|;
name|mem_last_set
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|retry
label|:
comment|/* Try this insn with each insn it links back to.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|try_combine
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|retry
goto|;
comment|/* Try each sequence of three linked insns ending with this one.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOTE
condition|)
for|for
control|(
name|nextlinks
operator|=
name|LOG_LINKS
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|try_combine
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
goto|goto
name|retry
goto|;
comment|/* Try to combine a jump insn that uses CC0 	     with a preceding insn that sets CC0, and maybe with its 	     logical predecessor as well. 	     This is how we make decrement-and-branch insns. 	     We need this special code because data flow connections 	     via CC0 do not get entered in LOG_LINKS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|prev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CC0
condition|)
block|{
if|if
condition|(
name|try_combine
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|NOTE
condition|)
for|for
control|(
name|nextlinks
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|try_combine
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
comment|/* Try to apply the distributive law to this insn 	     and two insns that compute the operands of this one.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOTE
condition|)
for|for
control|(
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|rtx
name|try_from
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|try_from
operator|=
name|try_distrib
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_from
operator|!=
literal|0
condition|)
block|{
name|insn
operator|=
name|try_from
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Turned off because on 68020 it takes four insns to make    something like (a[b / 32]& (1<< (31 - (b % 32)))) != 0    that could actually be optimized, and that's an unlikely piece of code.  */
comment|/* If an insn gets or sets a bit field, try combining it 	     with two different insns whose results it uses.  */
block|if (GET_CODE (insn) == INSN&& GET_CODE (PATTERN (insn)) == SET&& (GET_CODE (SET_DEST (PATTERN (insn))) == ZERO_EXTRACT 		  || GET_CODE (SET_DEST (PATTERN (insn))) == SIGN_EXTRACT 		  || GET_CODE (SET_SRC (PATTERN (insn))) == ZERO_EXTRACT 		  || GET_CODE (SET_SRC (PATTERN (insn))) == SIGN_EXTRACT)) 	    { 	      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1)) 		if (GET_CODE (XEXP (links, 0)) != NOTE) 		  for (nextlinks = XEXP (links, 1); nextlinks; 		       nextlinks = XEXP (nextlinks, 1)) 		    if (try_combine (insn, XEXP (links, 0), XEXP (nextlinks, 0))) 		      goto retry; 	    }
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|record_dead_and_set_regs
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|prev
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|prev
operator|=
literal|0
expr_stmt|;
block|}
name|total_attempts
operator|+=
name|combine_attempts
expr_stmt|;
name|total_merges
operator|+=
name|combine_merges
expr_stmt|;
name|total_extras
operator|+=
name|combine_extras
expr_stmt|;
name|total_successes
operator|+=
name|combine_successes
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to combine the insns I1 and I2 into I3.    Here I1 appears earlier than I2, which is earlier than I3.    I1 can be zero; then we combine just I2 into I3.      Return 1 if successful; if that happens, I1 and I2 are pseudo-deleted    by turning them into NOTEs, and I3 is modified.    Return 0 if the combination does not work.  Then nothing is changed.  */
end_comment

begin_function
specifier|static
name|int
name|try_combine
parameter_list|(
name|i3
parameter_list|,
name|i2
parameter_list|,
name|i1
parameter_list|)
specifier|register
name|rtx
name|i3
decl_stmt|,
name|i2
decl_stmt|,
name|i1
decl_stmt|;
block|{
specifier|register
name|rtx
name|newpat
decl_stmt|;
name|int
name|added_sets_1
init|=
literal|0
decl_stmt|;
name|int
name|added_sets_2
init|=
literal|0
decl_stmt|;
name|int
name|total_sets
decl_stmt|;
name|int
name|i2_is_used
decl_stmt|;
specifier|register
name|rtx
name|link
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|rtx
name|i2dest
decl_stmt|,
name|i2src
decl_stmt|;
name|rtx
name|i1dest
decl_stmt|,
name|i1src
decl_stmt|;
name|int
name|maxreg
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|combine_attempts
operator|++
expr_stmt|;
comment|/* Don't combine with something already used up by combination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|NOTE
operator|||
operator|(
name|i1
operator|&&
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|NOTE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Don't combine across a CALL_INSN, because that would possibly      change whether the life span of some REGs crosses calls or not,      and it is a pain to update that information.  */
if|if
condition|(
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
operator|<
name|last_call_cuid
operator|||
operator|(
name|i1
operator|&&
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
operator|<
name|last_call_cuid
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Can combine only if previous insn is a SET of a REG, a SUBREG or CC0.      That REG must be either set or dead by the final instruction      (so that we can safely forget about setting it).      Also test use_crosses_set_p to make sure that the value      that is to be substituted for the register      does not use any registers whose values alter in between.      Do not try combining with moves from one register to another      since it is better to let them be tied by register allocation.      (There is a switch to permit such combination; except the insns      that copy a function value into another register are never combined      because moving that too far away from the function call could cause      something else to be stored in that register in the interim.)       A set of a SUBREG is considered as if it were a set from      SUBREG.  Thus, (SET (SUBREG:X (REG:Y...)) (something:X...))      is handled by substituting (SUBREG:Y (something:X...)) for (REG:Y...).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|i2dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
expr_stmt|;
name|i2src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|i2dest
operator|=
name|SUBREG_REG
argument_list|(
name|i2dest
argument_list|)
expr_stmt|;
name|i2src
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|i2dest
argument_list|)
argument_list|,
name|i2src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Don't eliminate a store in the stack pointer.  */
if|if
condition|(
name|i2dest
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|0
return|;
comment|/* Don't install a subreg involving two modes not tieable.      It can worsen register allocation, and can even make invalid reload insns,      since the reg inside may need to be copied from in the outside mode,      and that may be invalid if it is an fp reg copied in integer mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2src
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|i2src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|i2src
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|!=
name|CC0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|i2src
argument_list|)
operator|==
name|REG
comment|/* Do allow the combination of y = x; x = y; (with x dead) 		 because the result will turn into nothing.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|i2src
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|flag_combine_regs
comment|/* Don't substitute a function value reg for any other.  */
operator|||
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|i2src
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|i2src
argument_list|)
operator|==
name|CALL
comment|/* Don't substitute into an incremented register.  */
operator|||
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_INC
argument_list|,
name|i2dest
argument_list|)
operator|||
name|use_crosses_set_p
argument_list|(
name|i2src
argument_list|,
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2src
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|i2src
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't substitute for a register intended as a clobberable operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|i2dest
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i1
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|i1dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
name|i1src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|i1dest
operator|=
name|SUBREG_REG
argument_list|(
name|i1dest
argument_list|)
expr_stmt|;
name|i1src
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|i1dest
argument_list|)
argument_list|,
name|i1src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i1dest
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|i1src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|i1src
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|!=
name|CC0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|!
name|flag_combine_regs
operator|||
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|i1src
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|CALL
operator|||
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_INC
argument_list|,
name|i1dest
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|i2
argument_list|,
name|REG_INC
argument_list|,
name|i1dest
argument_list|)
operator|||
name|use_crosses_set_p
argument_list|(
name|i1src
argument_list|,
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|i1src
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't substitute for a register intended as a clobberable operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|i1dest
condition|)
return|return
literal|0
return|;
block|}
comment|/* If it is better that two different modes keep two different pseudos,      avoid combining them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|i3dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|i3dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|i3dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|i3dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|i3dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|i3dest
operator|=
name|SUBREG_REG
argument_list|(
name|i3dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|i2dest
operator|&&
name|GET_CODE
argument_list|(
name|i3dest
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|i2dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|i3dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If I2 contains anything volatile, reject, unless nothing      volatile comes between it and I3.  */
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|i2
argument_list|)
init|;
name|insn
operator|!=
name|i3
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Likewise for I1; nothing volatile can come between it and I3,      except optionally I2.  */
if|if
condition|(
name|i1
operator|&&
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|end
init|=
operator|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|?
name|i2
else|:
name|i3
operator|)
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If I1 or I2 contains an autoincrement or autodecrement,      make sure that register is not used between there and I3,      and not already used in I3 either.      Also insist that I3 not be a jump; if it were one      and the incremented register were spilled, we would lose.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|reg_used_between_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i2
argument_list|,
name|i3
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i1
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|reg_used_between_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i1
argument_list|,
name|i3
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If I3 has an inc, then give up if I1 or I2 uses the reg that is inc'd,      EXCEPT in one case: I3 has a post-inc in an output operand.  */
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
operator|)
condition|)
comment|/* It's not the exception.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|i3
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|||
operator|(
name|i1
operator|!=
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Don't combine an insn I1 or I2 that follows a CC0-setting insn.      An insn that uses CC0 must not be separated from the one that sets it.      It would be more logical to test whether CC0 occurs inside I1 or I2,      but that would be much slower, and this ought to be equivalent.  */
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
while|while
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i1
condition|)
block|{
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
while|while
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* See if the SETs in i1 or i2 need to be kept around in the merged      instruction: whenever the value set there is still needed past i3.  */
name|added_sets_2
operator|=
operator|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|!=
name|CC0
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|i3
argument_list|,
name|i2dest
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i1
condition|)
name|added_sets_1
operator|=
operator|!
operator|(
name|dead_or_set_p
argument_list|(
name|i3
argument_list|,
name|i1dest
argument_list|)
operator|||
name|dead_or_set_p
argument_list|(
name|i2
argument_list|,
name|i1dest
argument_list|)
operator|)
expr_stmt|;
name|combine_merges
operator|++
expr_stmt|;
name|undobuf
operator|.
name|num_undo
operator|=
literal|0
expr_stmt|;
name|undobuf
operator|.
name|storage
operator|=
literal|0
expr_stmt|;
comment|/* Substitute in the latest insn for the regs set by the earlier ones.  */
name|maxreg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|subst_insn
operator|=
name|i3
expr_stmt|;
name|n_occurrences
operator|=
literal|0
expr_stmt|;
comment|/* `subst' counts here */
name|newpat
operator|=
name|subst
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
name|i2dest
argument_list|,
name|i2src
argument_list|)
expr_stmt|;
comment|/* Record whether i2's body now appears within i3's body.  */
name|i2_is_used
operator|=
name|n_occurrences
expr_stmt|;
if|if
condition|(
name|i1
condition|)
block|{
name|n_occurrences
operator|=
literal|0
expr_stmt|;
name|newpat
operator|=
name|subst
argument_list|(
name|newpat
argument_list|,
name|i1dest
argument_list|,
name|i1src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|)
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|i3
argument_list|)
condition|)
name|simplify_set_cc0_and
argument_list|(
name|i3
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_reg_num
argument_list|()
operator|!=
name|maxreg
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the actions of the earler insns must be kept      in addition to substituting them into the latest one,      we must make a new PARALLEL for the latest insn      to hold additional the SETs.  */
if|if
condition|(
name|added_sets_1
operator|||
name|added_sets_2
condition|)
block|{
name|combine_extras
operator|++
expr_stmt|;
comment|/* Arrange to free later what we allocate now 	 if we don't accept this combination.  */
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtvec
name|old
init|=
name|XVEC
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|total_sets
operator|=
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|+
name|added_sets_1
operator|+
name|added_sets_2
expr_stmt|;
name|newpat
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|total_sets
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|old
operator|->
name|elem
index|[
literal|0
index|]
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|old
operator|->
name|elem
index|[
literal|0
index|]
argument_list|)
operator|*
name|old
operator|->
name|num_elem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|old
init|=
name|newpat
decl_stmt|;
name|total_sets
operator|=
literal|1
operator|+
name|added_sets_1
operator|+
name|added_sets_2
expr_stmt|;
name|newpat
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|total_sets
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
block|}
if|if
condition|(
name|added_sets_1
condition|)
block|{
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
operator|--
name|total_sets
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|added_sets_2
condition|)
block|{
comment|/* If there is no I1, use I2's body as is.  */
if|if
condition|(
name|i1
operator|==
literal|0
comment|/* If I2 was stuck into I3, then anything within it has 	     already had I1 substituted into it when that was done to I3.  */
operator|||
name|i2_is_used
condition|)
block|{
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
operator|--
name|total_sets
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
else|else
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
operator|--
name|total_sets
argument_list|)
operator|=
name|subst
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
name|i1dest
argument_list|,
name|i1src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fail if an autoincrement side-effect has been duplicated.  */
if|if
condition|(
operator|(
name|i2_is_used
operator|>
literal|1
operator|&&
name|find_reg_note
argument_list|(
name|i2
argument_list|,
name|REG_INC
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|i1
operator|!=
literal|0
operator|&&
name|n_occurrences
operator|>
literal|1
operator|&&
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_INC
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Is the result of combination a valid instruction?  */
name|insn_code_number
operator|=
name|recog
argument_list|(
name|newpat
argument_list|,
name|i3
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
comment|/* Is the result a reasonable ASM_OPERANDS?  */
operator|||
operator|(
name|check_asm_operands
argument_list|(
name|newpat
argument_list|)
operator|&&
operator|!
name|added_sets_1
operator|&&
operator|!
name|added_sets_2
operator|)
condition|)
block|{
comment|/* Yes.  Install it.  */
specifier|register
name|int
name|regno
decl_stmt|;
name|INSN_CODE
argument_list|(
name|i3
argument_list|)
operator|=
name|insn_code_number
expr_stmt|;
name|PATTERN
argument_list|(
name|i3
argument_list|)
operator|=
name|newpat
expr_stmt|;
comment|/* If anything was substituted more than once, 	 copy it to avoid invalid shared rtl structure.  */
name|copy_substitutions
argument_list|()
expr_stmt|;
comment|/* The data flowing into I2 now flows into I3. 	 But we cannot always move all of I2's LOG_LINKS into I3, 	 since they must go to a setting of a REG from the 	 first use following.  If I2 was the first use following a set, 	 I3 is now a use, but it is not the first use 	 if some instruction between I2 and I3 is also a use. 	 Here, for simplicity, we move all the links only if 	 there are no real insns between I2 and I3. 	 Otherwise, we move only links that correspond to regs 	 that used to die in I2.  They are always safe to move.  */
name|add_links
argument_list|(
name|i3
argument_list|,
name|i2
argument_list|,
name|adjacent_insns_p
argument_list|(
name|i2
argument_list|,
name|i3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Most REGs that previously died in I2 now die in I3.  */
name|move_deaths
argument_list|(
name|i2src
argument_list|,
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|,
name|i3
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If the reg formerly set in I2 died only once and that was in I3, 	     zero its use count so it won't make `reload' do any work.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|i2dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|added_sets_2
condition|)
block|{
name|reg_n_sets
index|[
name|regno
index|]
operator|--
expr_stmt|;
comment|/* Used to check&& regno_dead_p (regno, i3)  also here.  */
if|if
condition|(
name|reg_n_sets
index|[
name|regno
index|]
operator|==
literal|0
operator|&&
operator|!
operator|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|regno
operator|/
name|HOST_BITS_PER_INT
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|%
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|)
condition|)
name|reg_n_refs
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If a ref to REGNO was substituted into I3 from I2, 	     then it still dies there if it previously did. 	     Otherwise either REGNO never did die in I3 so remove_death is safe 	     or this entire life of REGNO is gone so remove its death.  */
if|if
condition|(
operator|!
name|added_sets_2
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|i2dest
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
condition|)
name|remove_death
argument_list|(
name|regno
argument_list|,
name|i3
argument_list|)
expr_stmt|;
block|}
comment|/* Any registers previously autoincremented in I2 	 are now incremented in I3.  */
name|add_incs
argument_list|(
name|i3
argument_list|,
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
condition|)
block|{
comment|/* Likewise, merge the info from I1 and get rid of it.  */
name|add_links
argument_list|(
name|i3
argument_list|,
name|i1
argument_list|,
name|adjacent_insns_p
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
operator|&&
name|adjacent_insns_p
argument_list|(
name|i2
argument_list|,
name|i3
argument_list|)
argument_list|)
expr_stmt|;
name|move_deaths
argument_list|(
name|i1src
argument_list|,
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
argument_list|,
name|i3
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|i1dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|added_sets_1
condition|)
block|{
name|reg_n_sets
index|[
name|regno
index|]
operator|--
expr_stmt|;
comment|/* Used to also check&& regno_dead_p (regno, i3) here.  */
if|if
condition|(
name|reg_n_sets
index|[
name|regno
index|]
operator|==
literal|0
operator|&&
operator|!
operator|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|regno
operator|/
name|HOST_BITS_PER_INT
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|%
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|)
condition|)
name|reg_n_refs
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If a ref to REGNO was substituted into I3 from I1, 		 then it still dies there if it previously did. 		 Else either REGNO never did die in I3 so remove_death is safe 		 or this entire life of REGNO is gone so remove its death.  */
if|if
condition|(
operator|!
name|added_sets_1
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|i1dest
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
condition|)
name|remove_death
argument_list|(
name|regno
argument_list|,
name|i3
argument_list|)
expr_stmt|;
block|}
name|add_incs
argument_list|(
name|i3
argument_list|,
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|i1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|i1
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|i1
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|i1
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get rid of I2.  */
name|LOG_LINKS
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|i2
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|i2
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|combine_successes
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Failure: change I3 back the way it was.  */
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Undo all the modifications recorded in undobuf.  */
end_comment

begin_function
specifier|static
name|void
name|undo_all
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|undobuf
operator|.
name|num_undo
operator|>
name|MAX_UNDO
condition|)
name|undobuf
operator|.
name|num_undo
operator|=
name|MAX_UNDO
expr_stmt|;
for|for
control|(
name|i
operator|=
name|undobuf
operator|.
name|num_undo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|undobuf
operator|.
name|undo
index|[
name|i
index|]
operator|.
name|where
operator|=
name|undobuf
operator|.
name|undo
index|[
name|i
index|]
operator|.
name|old_contents
expr_stmt|;
if|if
condition|(
name|undobuf
operator|.
name|storage
condition|)
name|obfree
argument_list|(
name|undobuf
operator|.
name|storage
argument_list|)
expr_stmt|;
name|undobuf
operator|.
name|num_undo
operator|=
literal|0
expr_stmt|;
name|undobuf
operator|.
name|storage
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this insn had more than one substitution,    copy all but one, so that no invalid shared substructure is introduced.  */
end_comment

begin_function
specifier|static
name|void
name|copy_substitutions
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|undobuf
operator|.
name|num_undo
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|undobuf
operator|.
name|num_undo
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|undobuf
operator|.
name|undo
index|[
name|i
index|]
operator|.
name|is_int
condition|)
operator|*
name|undobuf
operator|.
name|undo
index|[
name|i
index|]
operator|.
name|where
operator|=
name|copy_rtx
argument_list|(
operator|*
name|undobuf
operator|.
name|undo
index|[
name|i
index|]
operator|.
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Throughout X, replace FROM with TO, and return the result.    The result is TO if X is FROM;    otherwise the result is X, but its contents may have been modified.    If they were modified, a record was made in undobuf so that    undo_all will (among other things) return X to its original state.     If the number of changes necessary is too much to record to undo,    the excess changes are not made, so the result is invalid.    The changes already made can still be undone.    undobuf.num_undo is incremented for such changes, so by testing that    the caller can tell whether the result is valid.     `n_occurrences' is incremented each time FROM is replaced.  */
end_comment

begin_function
specifier|static
name|rtx
name|subst
parameter_list|(
name|x
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
name|was_replaced
index|[
literal|2
index|]
decl_stmt|;
define|#
directive|define
name|SUBST
parameter_list|(
name|INTO
parameter_list|,
name|NEWVAL
parameter_list|)
define|\
value|do { if (undobuf.num_undo< MAX_UNDO)					\ 	{								\ 	  undobuf.undo[undobuf.num_undo].where =&INTO;			\ 	  undobuf.undo[undobuf.num_undo].old_contents = INTO;		\ 	  undobuf.undo[undobuf.num_undo].is_int = 0;			\ 	  INTO = NEWVAL;						\ 	}								\       undobuf.num_undo++; } while (0)
define|#
directive|define
name|SUBST_INT
parameter_list|(
name|INTO
parameter_list|,
name|NEWVAL
parameter_list|)
define|\
value|do { if (undobuf.num_undo< MAX_UNDO)					\ 	{								\ 	  struct undo_int *u = (struct undo_int *)&undobuf.undo[undobuf.num_undo];\ 	  u->where =&INTO;						\ 	  u->old_contents = INTO;					\ 	  u->is_int = 1;						\ 	  INTO = NEWVAL;						\ 	}								\       undobuf.num_undo++; } while (0)
comment|/* FAKE_EXTEND_SAFE_P (MODE, FROM) is 1 if (subreg:MODE FROM 0) is a safe    replacement for (zero_extend:MODE FROM) or (sign_extend:MODE FROM).    If it is 0, that cannot be done.  We can now do this for any MEM    because (SUBREG (MEM...)) is guaranteed to cause the MEM to be reloaded.    If not for that, MEM's would very rarely be safe.  */
comment|/* Reject MODEs bigger than a word, because we might not be able    to reference a two-register group starting with an arbitrary register    (and currently gen_lowpart might crash for a SUBREG).  */
define|#
directive|define
name|FAKE_EXTEND_SAFE_P
parameter_list|(
name|MODE
parameter_list|,
name|FROM
parameter_list|)
define|\
value|(GET_MODE_SIZE (MODE)<= UNITS_PER_WORD			\&& (GET_CODE (FROM) == REG || GET_CODE (FROM) == SUBREG	\        || GET_CODE (FROM) == MEM))
if|if
condition|(
name|x
operator|==
name|from
condition|)
return|return
name|to
return|;
comment|/* It is possible to have a subexpression appear twice in the insn.      Suppose that FROM is a register that appears within TO.      Then, after that subexpression has been scanned once by `subst',      the second time it is scanned, TO may be found.  If we were      to scan TO here, we would find FROM within it and create a      self-referent rtl structure which is completely wrong.  */
if|if
condition|(
name|x
operator|==
name|to
condition|)
return|return
name|to
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* A little bit of algebraic simplification here.  */
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* This case has no effect except to speed things up.  */
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
return|;
block|}
name|was_replaced
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|was_replaced
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Don't replace FROM where it is being stored in rather than used.  */
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|from
condition|)
name|fmt
operator|=
literal|"ie"
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|from
condition|)
name|fmt
operator|=
literal|"ie"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
specifier|register
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|==
name|from
condition|)
name|new
operator|=
name|to
operator|,
name|n_occurrences
operator|++
expr_stmt|;
else|else
name|new
operator|=
name|subst
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
condition|)
name|SUBST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
specifier|register
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|==
name|from
condition|)
block|{
name|new
operator|=
name|to
expr_stmt|;
name|n_occurrences
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
name|was_replaced
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|new
operator|=
name|subst
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A little bit of algebraic simplification here.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* Changing mode twice with SUBREG => just change it once, 	 or not at all if changing back to starting mode.  */
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|SUBREG_WORD
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|to
argument_list|)
return|;
name|SUBST
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|to
argument_list|)
operator|!=
literal|0
condition|)
name|SUBST_INT
argument_list|(
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|to
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* (subreg (sign_extend X)) is X, if it has same mode as X.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (subreg (sign_extend X)), if it has a mode wider than X, 	     can be done with (sign_extend X).  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Extend and then truncate smaller than it was to start with: 	     no need to extend.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* (subreg:A (mem:B X) N) becomes a modified MEM. 	 If we can't do that safely, then it becomes something nonsensical 	 so that this combination won't take place. 	 This avoids producing any (subreg (mem))s except in the special 	 paradoxical case where gen_lowpart_for_combine makes them.  */
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|endian_offset
init|=
literal|0
decl_stmt|;
comment|/* Don't combine this if mode A is wider than B.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* Don't change the mode of the MEM 	     if that would change the meaning of the address.  */
if|if
condition|(
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|endian_offset
operator|+=
name|UNITS_PER_WORD
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|endian_offset
operator|-=
name|UNITS_PER_WORD
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Note if the plus_constant doesn't make a valid address 	     then this combination won't be accepted.  */
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
operator|+
name|endian_offset
operator|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|NOT
case|:
comment|/* (not (minus X 1)) can become (neg X).  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|PLUS
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MINUS
operator|&&
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Don't let substitution introduce double-negatives.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|code
condition|)
return|return
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|NEG
case|:
comment|/* (neg (minus X Y)) can become (minus Y X).  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Don't let substitution introduce double-negatives.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|code
condition|)
return|return
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
comment|/* (float_truncate:SF (float_extend:DF foo:SF)) = foo:SF.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
if|#
directive|if
literal|0
block|case COMPARE:
comment|/* -x>0 if 0>x.  */
block|if (GET_CODE (XEXP (x, 0)) == NEG&& XEXP (x, 1) == const0_rtx) 	{ 	  SUBST (XEXP (x, 1), XEXP (XEXP (x, 0), 0)); 	  SUBST (XEXP (x, 0), const0_rtx); 	}       if (GET_CODE (XEXP (x, 1)) == NEG&& XEXP (x, 0) == const0_rtx) 	{ 	  SUBST (XEXP (x, 0), XEXP (XEXP (x, 1), 0)); 	  SUBST (XEXP (x, 1), const0_rtx); 	}       break;
endif|#
directive|endif
case|case
name|PLUS
case|:
if|#
directive|if
literal|0
comment|/* Turned off for caution: turn it on after 1.36.  */
comment|/* Identify constant sums as such.  */
block|if ((was_replaced[0] || was_replaced[1])&& CONSTANT_P (XEXP (x, 0))&& CONSTANT_P (XEXP (x, 1))) 	{ 	  if (!undobuf.storage) 	    undobuf.storage = (char *) oballoc (0); 	  return gen_rtx (CONST, GET_MODE (x), x); 	}
endif|#
directive|endif
comment|/* In (plus<foo> (ashift<bar><n>)) 	 change the shift to a multiply so we can recognize 	 scaled indexed addresses.  */
if|if
condition|(
operator|(
name|was_replaced
index|[
literal|0
index|]
operator|||
name|was_replaced
index|[
literal|1
index|]
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_INT
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* (plus X (neg Y)) becomes (minus X Y).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* (plus (neg X) Y) becomes (minus Y X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* (plus (plus x c1) c2) => (plus x c1+c2) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|sum
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|sum
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we have something (putative index) being added to a sum, 	 associate it so that any constant term is outermost. 	 That's because that's the way indexed addresses are 	 now supposed to appear.  */
if|if
condition|(
operator|(
operator|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|was_replaced
index|[
literal|1
index|]
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|)
operator|||
operator|(
operator|(
name|was_replaced
index|[
literal|0
index|]
operator|||
name|was_replaced
index|[
literal|1
index|]
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
block|{
name|rtx
name|offset
init|=
literal|0
decl_stmt|,
name|base
decl_stmt|,
name|index
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|PLUS
condition|)
block|{
name|index
operator|=
name|to
expr_stmt|;
name|base
operator|=
name|was_replaced
index|[
literal|0
index|]
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|was_replaced
index|[
literal|0
index|]
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|to
expr_stmt|;
block|}
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|,
name|base
argument_list|,
name|index
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|offset
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|,
name|base
argument_list|,
name|index
argument_list|)
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
comment|/* If comparing a subreg against zero, discard the subreg.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|to
argument_list|)
operator|==
literal|0
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If comparing a ZERO_EXTRACT against zero, 	 canonicalize to a SIGN_EXTRACT, 	 since the two are equivalent here.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SIGN_EXTRACT
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|BITS_BIG_ENDIAN
comment|/* If we are putting (ASHIFT 1 x) into (EQ (AND ... y) 0), 	 arrange to return (EQ (SIGN_EXTRACT y 1 x) 0), 	 which is what jump-on-bit instructions are written with.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|to
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|to
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SIGN_EXTRACT
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|y
argument_list|,
name|const1_rtx
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not BITS_BIG_ENDIAN */
comment|/* Negation is a no-op before equality test against zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NEG
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZERO_EXTEND
case|:
comment|/* Nested zero-extends are equivalent to just one.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero extending a constant int can be replaced 	 by a zero-extended constant.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|HOST_BITS_PER_INT
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|intval
init|=
name|INTVAL
argument_list|(
name|to
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|intval
argument_list|)
return|;
block|}
comment|/* Zero-extending the result of an and with a constant can be done 	 with a wider and.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Avoid getting wrong result if the constant has high bits set 	     that are irrelevant in the narrow mode where it is being used.  */
operator|&&
literal|0
operator|==
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Change (zero_extend:M (subreg:N (zero_extract:M ...) 0)) 	 to (zero_extract:M ...) if the field extracted fits in mode N.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Change (zero_extend:M (subreg:N (and:M ...<const>) 0)) 	 to (and:M ...) if the significant bits fit in mode N.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|to
operator|&&
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Avoid getting wrong result if the constant has high bits set 	     that are irrelevant in the narrow mode where it is being used.  */
operator|&&
literal|0
operator|==
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* In (zero_extend:M (subreg:N (lshiftrt:M REG))), 	 where REG was assigned from (zero_extend:M (any:N ...)), 	 remove the outer zero extension.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|to
operator|&&
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFTRT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* See if arg of LSHIFTRT is a register whose value we can find.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
if|if
condition|(
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|==
literal|1
operator|&&
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
argument_list|)
operator|==
name|tmp
condition|)
name|tmp
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* Nested sign-extends are equivalent to just one.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sign extending a constant int can be replaced 	 by a sign-extended constant.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|HOST_BITS_PER_INT
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|intval
init|=
name|INTVAL
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|intval
operator|>
literal|0
operator|&&
operator|(
name|intval
operator|&
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|intval
operator||=
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|intval
argument_list|)
return|;
block|}
comment|/* Sign-extending the result of an and with a constant can be done 	 with a wider and, provided the high bit of the constant is 0.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
operator|-
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* hacks added by tiemann.  */
comment|/* Change (sign_extend:M (subreg:N (and:M ...<const>) 0)) 	 to (and:M ...), provided the result fits in mode N, 	 and the high bit of the constant is 0 in mode N.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|to
operator|&&
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
operator|-
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* In (sign_extend:M (subreg:N (ashiftrt:M REG))), 	 where REG was assigned from (sign_extend:M (any:N ...)), 	 remove the outer sign extension.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|to
operator|&&
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFTRT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* See if arg of LSHIFTRT is a register whose value we can find.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
if|if
condition|(
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|==
literal|1
operator|&&
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
argument_list|)
operator|==
name|tmp
condition|)
name|tmp
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SET
case|:
comment|/* In (set (zero-extract<x><n><y>) (and<foo><(2**n-1) | anything>)) 	 the `and' can be deleted.  This can happen when storing a bit 	 that came from a set-flag insn followed by masking to one bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|was_replaced
index|[
literal|1
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|==
operator|(
operator|(
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* In (set (zero-extract<x><n><y>) 		 (subreg (and<foo><(2**n-1) | anything>))) 	 the `and' can be deleted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|==
operator|(
operator|(
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SUBST
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* (set (zero_extract ...) (and/or/xor (zero_extract ...) const)), 	 if both zero_extracts have the same location, size and position, 	 can be changed to avoid the byte extracts.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|XOR
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* zero_extract can apply to a QImode even if the bits extracted 	     don't fit inside that byte.  In such a case, we may not do this 	     optimization, since the OR or AND insn really would need 	     to fit in a byte.  */
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|shiftcount
decl_stmt|;
name|int
name|newmask
decl_stmt|;
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
name|shiftcount
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|shiftcount
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newmask
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<<
name|shiftcount
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AND
condition|?
operator|(
literal|1
operator|<<
name|shiftcount
operator|)
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_INT
condition|)
name|newmask
operator|&=
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|newmask
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Can simplify (set (cc0) (compare (zero/sign_extend FOO) CONST)) 	 to (set (cc0) (compare FOO CONST)) if CONST fits in FOO's mode 	 and we are only testing equality. 	 In fact, this is valid for zero_extend if what follows is an 	 unsigned comparison, and for sign_extend with a signed comparison.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|subst_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* This is overly cautious by one bit, but saves worrying about 	     whether it is zero-extension or sign extension.  */
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tem
init|=
name|simplify_and_const_int
argument_list|(
name|x
argument_list|,
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* (ior (ior x c1) c2) => (ior x c1|c2); likewise for xor.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|c0
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|c1
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|combined
init|=
operator|(
name|code
operator|==
name|IOR
condition|?
name|c0
operator||
name|c1
else|:
name|c0
operator|^
name|c1
operator|)
decl_stmt|;
if|if
condition|(
name|combined
operator|==
literal|0
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|combined
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FLOAT
case|:
comment|/* (float (sign_extend<X>)) = (float<X>).  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
comment|/* (ZERO_EXTRACT (TRUNCATE x)...) 	 can become (ZERO_EXTRACT x ...).  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|TRUNCATE
condition|)
block|{
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* On a big-endian machine, must increment the bit-number 		 since sign bit is farther away in the pre-truncated value.  */
return|return
name|gen_rtx
argument_list|(
name|ZERO_EXTRACT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|+
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
argument_list|)
argument_list|)
return|;
block|}
else|#
directive|else
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Extracting a single bit from the result of a shift: 	 see which bit it was before the shift and extract that directly.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|shift
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|newpos
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFT
condition|)
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
endif|#
directive|endif
name|newpos
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|+
name|shift
expr_stmt|;
if|if
condition|(
name|newpos
operator|>=
literal|0
operator|&&
name|newpos
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|ZERO_EXTRACT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|newpos
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
comment|/* (lshift<X> (sign_extend<Y>)) = (lshift<X><Y>) (most machines). 	 True for all kinds of shifts and also for zero_extend.  */
if|if
condition|(
name|was_replaced
index|[
literal|1
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
comment|/* This is a perverse SUBREG, wider than its base.  */
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Two shifts in a row of same kind 	 in same direction with constant counts 	 may be combined.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
comment|/* (lshift<X> (sign_extend<Y>)) = (lshift<X><Y>) (most machines). 	 True for all kinds of shifts and also for zero_extend.  */
if|if
condition|(
name|was_replaced
index|[
literal|1
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
comment|/* This is a perverse SUBREG, wider than its base.  */
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (lshift (and (lshiftrt<foo><X>)<Y>)<X>) 	 happens copying between bit fields in similar structures. 	 It can be replaced by one and instruction. 	 It does not matter whether the shifts are logical or arithmetic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|to
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFTRT
operator|)
if|#
directive|if
literal|0
comment|/* I now believe this restriction is unnecessary.    The outer shift will discard those bits in any case, right?  */
comment|/* If inner shift is arithmetic, either it shifts left or 		 the bits it shifts the sign into are zeroed by the and.  */
expr|&& (INTVAL (XEXP (x, 1))< 0 		      || ((unsigned) INTVAL (XEXP (XEXP (x, 0), 1))< 1<< (GET_MODE_BITSIZE (GET_MODE (x)) 				  - INTVAL (XEXP (x, 0)))))
endif|#
directive|endif
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The constant in the new `and' is<Y><<<X> 	     but clear out all bits that don't belong in our mode.  */
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Two shifts in a row in same direction with constant counts 	 may be combined.  */
if|if
condition|(
name|was_replaced
index|[
literal|0
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* (ashift (ashiftrt<foo><X>)<X>) 	 (or, on some machines, (ashift (ashift<foo><-X>)<X>) instead) 	 happens if you divide by 2**N and then multiply by 2**N. 	 It can be replaced by one `and' instruction. 	 It does not matter whether the shifts are logical or arithmetic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|was_replaced
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|LSHIFT
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The constant in the new `and' is -1<<<X> 	     but clear out all bits that don't belong in our mode.  */
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* This is the AND case of the function subst.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_and_const_int
parameter_list|(
name|x
parameter_list|,
name|to
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|rtx
name|varop
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|constop
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* (and (subreg (and<foo><constant>) 0)<constant>)      results from an andsi followed by an andqi,      which happens frequently when storing bit-fields      on something whose result comes from an andsi.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|SUBREG
operator|&&
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
operator|==
name|to
operator|&&
name|subreg_lowpart_p
argument_list|(
name|varop
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* Verify that the result of the outer `and' 	 is not affected by any bits not defined in the inner `and'. 	 True if the outer mode is narrower, or if the outer constant 	 masks to zero all the bits that the inner mode doesn't have.  */
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|||
operator|(
name|constop
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|constop
comment|/* Remember that the bits outside that mode 				  are not being changed, so the effect 				  is as if they were all 1.  */
operator|&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* (and:SI (zero_extract:SI ...)<constant>)      results from an andsi following a byte-fetch on risc machines.      When the constant includes all bits extracted, eliminate the `and'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* The `and' must not clear any bits that the extract can give.  */
operator|&&
operator|(
operator|~
name|constop
operator|&
operator|(
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|varop
return|;
comment|/* (and (zero_extend<foo>)<constant>)      often results from storing in a bit-field something      that was calculated as a short.  Replace with a single `and'      in whose constant all bits not in<foo>'s mode are zero.  */
if|if
condition|(
name|varop
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
comment|/* This is a perverse SUBREG, wider than its base.  */
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|constop
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* (and (sign_extend<foo>)<constant>)      can be replaced with (and (subreg<foo>)<constant>)      if<constant> is narrower than<foo>'s mode,      or with (zero_extend<foo>) if<constant> is a mask for that mode.  */
if|if
condition|(
name|varop
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|constop
operator|<=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|constop
operator|==
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
comment|/* This is a perverse SUBREG, wider than its base.  */
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (and (and<foo><constant>)<constant>)      comes from two and instructions in a row.  */
if|if
condition|(
name|varop
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|constop
operator|&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* (and (ashiftrt (ashift FOO N) N) CONST)      may be simplified to (and FOO CONST) if CONST masks off the bits      changed by the two shifts.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|constop
operator|>>
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If CONST is a mask for the low byte, 	 change this into a zero-extend instruction 	 from just the low byte of FOO.  */
if|if
condition|(
name|constop
operator|==
name|GET_MODE_MASK
argument_list|(
name|QImode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_lowpart_for_combine
argument_list|(
name|QImode
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
name|gen_rtx
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (and (ashiftrt (zero_extend FOO) N) CONST)      may be simplified to (and (ashiftrt (subreg FOO) N) CONST)      if CONST masks off the bits changed by extension.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|LSHIFTRT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
operator|==
name|to
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
comment|/* Verify the and discards all the extended bits.  */
operator|&&
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|constop
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|>>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|FAKE_EXTEND_SAFE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* (and x const) may be converted to (zero_extend (subreg x 0)).  */
if|if
condition|(
name|constop
operator|==
name|GET_MODE_MASK
argument_list|(
name|QImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|QImode
argument_list|,
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|constop
operator|==
name|GET_MODE_MASK
argument_list|(
name|HImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|HImode
argument_list|,
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* No simplification applies.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like gen_lowpart but for use by combine.  In combine it is not possible    to create any new pseudoregs.  However, it is safe to create    invalid memory addresses, because combine will try to recognize    them and all they will do is make the combine attempt fail.     If for some reason this cannot do its job, an rtx    (clobber (const_int 0)) is returned.    An insn containing that will not be recognized.  */
end_comment

begin_undef
undef|#
directive|undef
name|gen_lowpart
end_undef

begin_function
specifier|static
name|rtx
name|gen_lowpart_for_combine
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
condition|)
return|return
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Refuse to work on a volatile memory ref.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* If we want to refer to something bigger than the original memref, 	 generate a perverse subreg instead.  That will force a reload 	 of the original memref X.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
ifdef|#
directive|ifdef
name|WORDS_BIG_ENDIAN
name|offset
operator|=
operator|(
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Adjust the address so that the address-after-the-data 	 is unchanged.  */
name|offset
operator|-=
operator|(
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* After substitution, if the resulting pattern looks like    (set (cc0) (and ...)) or (set (cc0) (lshiftrt ...)),    this function is called to simplify the    pattern into a bit-field operation if possible.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_set_cc0_and
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|value
init|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|var
init|=
literal|0
decl_stmt|;
name|rtx
name|bitnum
init|=
literal|0
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|AND
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|LSHIFTRT
condition|)
block|{
comment|/* If there is no AND, but there is a shift that discards 	 all but the sign bit, we can pretend that the shift result 	 is ANDed with 1.  Otherwise we cannot handle just a shift.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|op0
operator|=
name|value
expr_stmt|;
name|op1
operator|=
name|const1_rtx
expr_stmt|;
block|}
else|else
return|return;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for a constant power of 2 or a shifted 1      on either side of the AND.  Set VAR to the other side.      Set BITNUM to the shift count of the 1 (as an rtx).      Or, if bit number is constant, set OFFSET to the bit number.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|temp
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return;
name|offset
operator|=
name|temp
expr_stmt|;
name|var
operator|=
name|op1
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
case|case
name|LSHIFT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|bitnum
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|var
operator|=
name|op1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|var
operator|==
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|temp
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return;
name|offset
operator|=
name|temp
expr_stmt|;
name|var
operator|=
name|op0
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
case|case
name|LSHIFT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|bitnum
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|var
operator|=
name|op0
expr_stmt|;
block|}
block|}
comment|/* If VAR is 0, we didn't find something recognizable.  */
if|if
condition|(
name|var
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|undobuf
operator|.
name|storage
condition|)
name|undobuf
operator|.
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If the bit position is currently exactly 0,      extract a right-shift from the variable portion.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|LSHIFTRT
operator|)
condition|)
block|{
name|bitnum
operator|=
name|XEXP
argument_list|(
name|var
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|var
operator|=
name|XEXP
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|var
argument_list|)
operator|==
literal|0
condition|)
name|var
operator|=
name|SUBREG_REG
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Note that BITNUM and OFFSET are always little-endian thru here      even on a big-endian machine.  */
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bitnum
operator|!=
literal|0
condition|)
name|bitnum
operator|=
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|unit
argument_list|)
argument_list|,
name|bitnum
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|unit
operator|-
name|offset
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitnum
operator|==
literal|0
condition|)
name|bitnum
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|ZERO_EXTRACT
argument_list|,
name|VOIDmode
argument_list|,
name|var
argument_list|,
name|const1_rtx
argument_list|,
name|bitnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|newpat
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|undobuf
operator|.
name|num_undo
operator|<
name|MAX_UNDO
condition|)
block|{
name|undobuf
operator|.
name|undo
index|[
name|undobuf
operator|.
name|num_undo
index|]
operator|.
name|where
operator|=
operator|&
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|undobuf
operator|.
name|undo
index|[
name|undobuf
operator|.
name|num_undo
index|]
operator|.
name|old_contents
operator|=
name|value
expr_stmt|;
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|undobuf
operator|.
name|num_undo
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the records of when each REG was most recently set or killed    for the things done by INSN.  This is the last thing done in processing    INSN in the combiner loop.     We update reg_last_set, reg_last_death, and also the similar information    mem_last_set (which insn most recently modified memory)    and last_call_cuid (which insn was the most recent subroutine call).  */
end_comment

begin_function
specifier|static
name|void
name|record_dead_and_set_regs
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|reg_last_death
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|last_call_cuid
operator|=
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if expression X refers to a REG or to memory    that is set in an instruction more recent than FROM_CUID.  */
end_comment

begin_function
specifier|static
name|int
name|use_crosses_set_p
parameter_list|(
name|x
parameter_list|,
name|from_cuid
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|from_cuid
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Don't allow uses of the stack pointer to be moved, 	 because we don't know whether the move crosses a push insn.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
operator|(
name|reg_last_set
index|[
name|regno
index|]
operator|&&
name|INSN_CUID
argument_list|(
name|reg_last_set
index|[
name|regno
index|]
argument_list|)
operator|>
name|from_cuid
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|mem_last_set
operator|>
name|from_cuid
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|use_crosses_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from_cuid
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|use_crosses_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from_cuid
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if reg REGNO is marked as dying in INSN.  */
end_comment

begin_function
name|int
name|regno_dead_p
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if J is the first insn following I,    not counting labels, line numbers, etc.    We assume that J follows I.  */
end_comment

begin_function
specifier|static
name|int
name|adjacent_insns_p
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|rtx
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|i
argument_list|)
init|;
name|insn
operator|!=
name|j
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check that X is an insn-body for an `asm' with operands    and that the operands mentioned in it are legitimate.  */
end_comment

begin_function
specifier|static
name|int
name|check_asm_operands
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|noperands
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|operands
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|decode_asm_operands
argument_list|(
name|x
argument_list|,
name|operands
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Concatenate the list of logical links of OINSN    into INSN's list of logical links.    Modifies OINSN destructively.     If ALL_LINKS is nonzero, move all the links that OINSN has.    Otherwise, move only those that point to insns that set regs    that die in the insn OINSN.    Other links are clobbered so that they are no longer effective.  */
end_comment

begin_function
specifier|static
name|void
name|add_links
parameter_list|(
name|insn
parameter_list|,
name|oinsn
parameter_list|,
name|all_links
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|oinsn
decl_stmt|;
name|int
name|all_links
decl_stmt|;
block|{
specifier|register
name|rtx
name|links
init|=
name|LOG_LINKS
argument_list|(
name|oinsn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|all_links
condition|)
block|{
name|rtx
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|links
init|;
name|tail
condition|;
name|tail
operator|=
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|target
init|=
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|dead_or_set_p
argument_list|(
name|oinsn
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* OINSN is going to become a NOTE  	       so a link pointing there will have no effect.  */
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|0
argument_list|)
operator|=
name|oinsn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|links
expr_stmt|;
else|else
block|{
specifier|register
name|rtx
name|next
decl_stmt|,
name|prev
init|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|=
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
condition|)
name|prev
operator|=
name|next
expr_stmt|;
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|links
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete any LOG_LINKS of INSN which point at OINSN.  */
end_comment

begin_function
specifier|static
name|void
name|remove_links
parameter_list|(
name|insn
parameter_list|,
name|oinsn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|oinsn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|prev
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
operator|==
name|oinsn
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Concatenate the any elements of the list of reg-notes INCS    which are of type REG_INC    into INSN's list of reg-notes.  */
end_comment

begin_function
specifier|static
name|void
name|add_incs
parameter_list|(
name|insn
parameter_list|,
name|incs
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|incs
decl_stmt|;
block|{
specifier|register
name|rtx
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|incs
init|;
name|tail
condition|;
name|tail
operator|=
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|tail
argument_list|)
operator|==
name|REG_INC
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_INC
argument_list|,
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove register number REGNO from the dead registers list of INSN.  */
end_comment

begin_function
name|void
name|remove_death
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
while|while
condition|(
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|next
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|link
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each register (hardware or pseudo) used within expression X,    if its death is in an instruction with cuid    between FROM_CUID (inclusive) and TO_INSN (exclusive),    mark it as dead in TO_INSN instead.     This is done when X is being merged by combination into TO_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|move_deaths
parameter_list|(
name|x
parameter_list|,
name|from_cuid
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|from_cuid
decl_stmt|;
name|rtx
name|to_insn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|where_dead
init|=
name|reg_last_death
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|where_dead
operator|&&
name|INSN_CUID
argument_list|(
name|where_dead
argument_list|)
operator|>=
name|from_cuid
operator|&&
name|INSN_CUID
argument_list|(
name|where_dead
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|to_insn
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_last_death
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dead_or_set_p
argument_list|(
name|to_insn
argument_list|,
name|x
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|to_insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|to_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|move_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|move_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like move_deaths, but deaths are moving both forward    (from FROM_CUID to TO_INSN), and backwards    (from FROM_INSN to TO_INSN).  This is what happens    when an insn is removed after applying the distributive law.  */
end_comment

begin_function
specifier|static
name|void
name|move_deaths_2
parameter_list|(
name|x
parameter_list|,
name|from_cuid
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|from_cuid
decl_stmt|;
name|rtx
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|where_dead
init|=
name|reg_last_death
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|where_dead
operator|&&
name|INSN_CUID
argument_list|(
name|where_dead
argument_list|)
operator|>=
name|from_cuid
operator|&&
name|INSN_CUID
argument_list|(
name|where_dead
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|to_insn
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_last_death
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dead_or_set_p
argument_list|(
name|to_insn
argument_list|,
name|x
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|to_insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|to_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Can't use where_dead for from_insn because it has 	 not been computed yet.  */
elseif|else
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|from_insn
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|from_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dead_or_set_p
argument_list|(
name|to_insn
argument_list|,
name|x
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|to_insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|to_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|move_deaths_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from_cuid
argument_list|,
name|from_insn
argument_list|,
name|to_insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|move_deaths_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from_cuid
argument_list|,
name|from_insn
argument_list|,
name|to_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The distrib combiner rewrites groups of insns so that optimizations    can be more easily recognized.  The front-end does not know how to    group certain kinds of operations for efficient execution, and the    resulting code can be quite poor.  For example, on a machine without    bitfield instructions, bitfield references look like  	(and (lshiftrt ... n) m)     When combining two bitfield operations, such as with ||, this can    yield code like  	(set z 	     (or (and (lshiftrt x n) 1) 		 (and (lshiftrt y n) 1)))     which can be more efficiently executed as  	(set z 	     (lshiftrt (and (or x y) 			    (1<< m)) n))     From there, the combiner attempts to rewrite the insns,    keeping flow information accurate for later passes,    and reducing the total number of insns executed.     This function returns the point at which we should try    looking for more simplifications.  This will be before    INSN if the call succeeds.  We do not need to fear    infinite loops, since this function is guaranteed to    eliminate at least one (non-note) instruction if it returns    successfully.  */
end_comment

begin_function
specifier|static
name|rtx
name|try_distrib
parameter_list|(
name|insn
parameter_list|,
name|xprev1
parameter_list|,
name|xprev2
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|xprev1
decl_stmt|,
name|xprev2
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev1
decl_stmt|,
name|prev2
decl_stmt|,
name|pat1
decl_stmt|,
name|pat2
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|;
name|rtx
name|to_prev
decl_stmt|,
name|to_insn
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|,
name|prev_code_number
decl_stmt|,
name|regno
decl_stmt|;
name|rtx
name|new_insn_pat
decl_stmt|,
name|new_prev_pat
decl_stmt|;
name|distrib_attempts
operator|++
expr_stmt|;
comment|/* ??? Need to implement a test that PREV2 and PREV1      are completely independent.  Right now their      recognition ability is sufficiently limited that      it should not be necessary, but better safe than sorry.  */
comment|/* Let PREV1 be the later of the two insns, and PREV2 the earlier.  */
if|if
condition|(
name|INSN_CUID
argument_list|(
name|xprev1
argument_list|)
operator|>
name|INSN_CUID
argument_list|(
name|xprev2
argument_list|)
condition|)
block|{
name|prev1
operator|=
name|xprev1
expr_stmt|;
name|prev2
operator|=
name|xprev2
expr_stmt|;
block|}
else|else
block|{
name|prev1
operator|=
name|xprev2
expr_stmt|;
name|prev2
operator|=
name|xprev1
expr_stmt|;
block|}
name|pat1
operator|=
name|PATTERN
argument_list|(
name|prev1
argument_list|)
expr_stmt|;
name|pat2
operator|=
name|PATTERN
argument_list|(
name|prev2
argument_list|)
expr_stmt|;
comment|/* First, see if INSN, PREV1, and PREV2 have patterns we can expect      to simplify.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat1
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat2
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|src1
operator|=
name|SET_SRC
argument_list|(
name|pat1
argument_list|)
expr_stmt|;
name|src2
operator|=
name|SET_SRC
argument_list|(
name|pat2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat2
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|PLUS
case|:
empty_stmt|;
block|}
comment|/* Insns PREV1 and PREV2 must provide the two operands of the arithmetic      that is done in INSN.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|pat2
argument_list|)
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|pat2
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* They must not be used in any other way in INSN.      In particular, they must not be used in a result memory address.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Give up if the two operands' modes don't match.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|src1
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|src2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* PREV1 and PREV2 must compute the same operation.      Actually, there are other cases that could be handled,      but are not implemented.  For example:       (set (reg:SI 94) 	  (and:SI (reg:SI 73) 		  (const_int 223)))       (set (reg:SI 95) 	  (zero_extend:SI (subreg:QI (reg:SI 91) 0)))       (set (reg:SI 96) 	  (ior:SI (reg:SI 94) 		  (reg:SI 95)))       In this case, we know that because (reg:SI 94) has      been anded with 223, there is no need to zero_extend      (reg:SI 91), and we could eliminate (reg:SI 95).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|src2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The SETs in PREV1 and PREV2 do not need to be kept around.  */
name|undobuf
operator|.
name|num_undo
operator|=
literal|0
expr_stmt|;
name|undobuf
operator|.
name|storage
operator|=
literal|0
expr_stmt|;
comment|/* Substitute in the latest insn for the regs set by the earlier ones.  */
name|subst_insn
operator|=
name|insn
expr_stmt|;
name|n_occurrences
operator|=
literal|0
expr_stmt|;
comment|/* `subst' counts here */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
condition|)
block|{
comment|/* case XOR:  Does not distribute through anything!  */
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
comment|/* Right-shift can't distribute through addition 	 since the round-off would happen differently.  */
case|case
name|AND
case|:
case|case
name|IOR
case|:
comment|/* Boolean ops don't distribute through addition.  */
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
return|return
literal|0
return|;
goto|goto
name|do_distrib
goto|;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
comment|/* Left shifts are multiplication; they distribute through 	 addition.  Also, since they work bitwise, they 	 distribute through boolean operations.  */
ifdef|#
directive|ifdef
name|NEGATIVE_SHIFT_COUNTS
comment|/* Negative count is really a right-shift.  */
if|if
condition|(
name|NEGATIVE_SHIFT_COUNTS
operator|&&
name|code
operator|==
name|PLUS
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
goto|goto
name|do_distrib
goto|;
case|case
name|MULT
case|:
comment|/* Multiplication distributes through addition only.  */
if|if
condition|(
name|code
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
name|do_distrib
label|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Give up if we would move a use of a reg across an alteration. 	 Note this is unnecessarily conservative, since a problem really 	 happens only if this reg is set *between* PREV2 and PREV1 	 But this test is easier.  */
if|if
condition|(
name|use_crosses_set_p
argument_list|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|prev2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Try changing (+ (* x c) (* y c)) to (* (+ x y) c).  */
name|to_prev
operator|=
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|src1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|to_insn
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src1
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* Extension can't distribute through addition; 	 the carries could be changed.  */
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
return|return
literal|0
return|;
block|{
name|rtx
name|inner1
init|=
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|inner2
init|=
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|subreg_needed
init|=
literal|0
decl_stmt|;
comment|/* Try changing (& (extend x) (extend y)) to (extend (& x y)).  */
comment|/* But keep extend insns together with their subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner1
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|inner1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|subreg_needed
operator|=
literal|1
expr_stmt|;
name|inner1
operator|=
name|SUBREG_REG
argument_list|(
name|inner1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner2
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|inner2
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|subreg_needed
operator|=
literal|1
expr_stmt|;
name|inner2
operator|=
name|SUBREG_REG
argument_list|(
name|inner2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Give up if we would move a use of a reg across an alteration. 	   Note this is unnecessarily conservative, since a problem really 	   happens only if this reg is set *between* PREV2 and PREV1 	   But this test is easier.  */
if|if
condition|(
name|use_crosses_set_p
argument_list|(
name|inner2
argument_list|,
name|INSN_CUID
argument_list|(
name|prev2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|to_prev
operator|=
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|src1
argument_list|)
argument_list|,
name|inner1
argument_list|,
name|inner2
argument_list|)
expr_stmt|;
name|to_insn
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src1
argument_list|)
argument_list|,
name|subreg_needed
condition|?
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
argument_list|,
literal|0
argument_list|)
else|:
name|SET_DEST
argument_list|(
name|pat1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Are the results of this "substitution" a valid instruction?  */
name|new_insn_pat
operator|=
name|subst
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|to_insn
argument_list|)
expr_stmt|;
name|distrib_merges_1
operator|++
expr_stmt|;
name|insn_code_number
operator|=
name|recog
argument_list|(
name|new_insn_pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|<
literal|0
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|subst_insn
operator|=
name|prev1
expr_stmt|;
name|new_prev_pat
operator|=
name|subst
argument_list|(
name|pat1
argument_list|,
name|src1
argument_list|,
name|to_prev
argument_list|)
expr_stmt|;
name|distrib_merges_2
operator|++
expr_stmt|;
name|prev_code_number
operator|=
name|recog
argument_list|(
name|new_prev_pat
argument_list|,
name|prev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_code_number
operator|<
literal|0
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Everything worked; install the new patterns.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn_code_number
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_insn_pat
expr_stmt|;
name|INSN_CODE
argument_list|(
name|prev1
argument_list|)
operator|=
name|prev_code_number
expr_stmt|;
name|PATTERN
argument_list|(
name|prev1
argument_list|)
operator|=
name|new_prev_pat
expr_stmt|;
comment|/* Need to change LOG_LINKS around...PREV1 now gets      whatever flowed into PREV2.  PREV2 is going to      become a NOTE, so we clear out its LOG_LINKS.  */
name|remove_links
argument_list|(
name|insn
argument_list|,
name|prev2
argument_list|)
expr_stmt|;
name|add_links
argument_list|(
name|prev1
argument_list|,
name|prev2
argument_list|,
name|adjacent_insns_p
argument_list|(
name|prev2
argument_list|,
name|prev1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Registers which died in PREV2 now die in PREV1.      Also, registers born in PREV2 dying in INSN now die in PREV1.  */
name|move_deaths_2
argument_list|(
name|src2
argument_list|,
name|INSN_CUID
argument_list|(
name|prev2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|prev1
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat2
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_sets
index|[
name|regno
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|reg_n_sets
index|[
name|regno
index|]
operator|==
literal|0
operator|&&
operator|!
operator|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|regno
operator|/
name|HOST_BITS_PER_INT
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|%
name|HOST_BITS_PER_INT
operator|)
operator|)
operator|)
condition|)
name|reg_n_refs
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|remove_death
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|prev2
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev2
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|distrib_successes
operator|++
expr_stmt|;
return|return
name|prev1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_combine_stats
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Combiner statistics: %d attempts, %d substitutions (%d requiring new space),\n;; %d successes.\n\n"
argument_list|,
name|combine_attempts
argument_list|,
name|combine_merges
argument_list|,
name|combine_extras
argument_list|,
name|combine_successes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Distributer statistics: %d attempts, %d:%d substitutions,\n;; %d successes.\n\n"
argument_list|,
name|distrib_attempts
argument_list|,
name|distrib_merges_1
argument_list|,
name|distrib_merges_2
argument_list|,
name|distrib_successes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_combine_total_stats
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n;; Combiner totals: %d attempts, %d substitutions (%d requiring new space),\n;; %d successes.\n"
argument_list|,
name|total_attempts
argument_list|,
name|total_merges
argument_list|,
name|total_extras
argument_list|,
name|total_successes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n;; Distributer totals: %d attempts, %d:%d substitutions,\n;; %d successes.\n"
argument_list|,
name|total_distrib_attempts
argument_list|,
name|total_distrib_merges_1
argument_list|,
name|total_distrib_merges_2
argument_list|,
name|total_distrib_successes
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

