begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimize jump instructions, for GNU compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is the jump-optimization pass of the compiler.    It is run two or three times: once before cse, sometimes once after cse,    and once after reload (before final).     jump_optimize deletes unreachable code and labels that are not used.    It also deletes jumps that jump to the following insn,    and simplifies jumps around unconditional jumps and jumps    to unconditional jumps.     Each CODE_LABEL has a count of the times it is used    stored in the LABEL_NUSES internal field, and each JUMP_INSN    has one label that it refers to stored in the    JUMP_LABEL internal field.  With this we can detect labels that    become unused because of the deletion of all the jumps that    formerly used them.  The JUMP_LABEL info is sometimes looked    at by later passes.     Optionally, cross-jumping can be done.  Currently it is done    only the last time (when after reload and before final).    In fact, the code for cross-jumping now assumes that register    allocation has been done, since it uses `rtx_renumbered_equal_p'.     Jump optimization is done after cse when cse's constant-propagation    causes jumps to become unconditional or to be deleted.     Unreachable loops are not detected here, because the labels    have references and the insns appear reachable from the labels.    find_basic_blocks in flow.c finds and deletes such loops.     The subroutines delete_insn, redirect_jump, invert_jump, next_real_insn    and prev_real_insn are used from other passes as well.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_comment
comment|/* ??? Eventually must record somehow the labels used by jumps    from nested functions.  */
end_comment

begin_comment
comment|/* Pre-record the next or previous real insn for each label?    No, this pass is very fast anyway.  */
end_comment

begin_comment
comment|/* Condense consecutive labels?    This would make life analysis faster, maybe.  */
end_comment

begin_comment
comment|/* Optimize jump y; x: ... y: jumpif... x?    Don't know if it is worth bothering with.  */
end_comment

begin_comment
comment|/* Optimize two cases of conditional jump to conditional jump?    This can never delete any instruction or make anything dead,    or even change what is live at any point.    So perhaps let combiner do it.  */
end_comment

begin_comment
comment|/* Vector indexed by uid.    For each CODE_LABEL, index by its uid to get first unconditional jump    that jumps to the label.    For each JUMP_INSN, index by its uid to get the next unconditional jump    that jumps to the same label.    Element 0 is the start of a chain of all return insns.    (It is safe to use element 0 because insn uid 0 is not used.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|jump_chain
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
name|delete_insn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|redirect_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|invert_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|next_real_insn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|prev_real_insn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|next_label
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_jump_label
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|squeeze_block_notes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|invert_exp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|redirect_exp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|follow_jumps
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tension_vector_labels
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_cross_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_cross_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rtx_code
name|reverse_condition
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jump_back_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|condjump_p
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Delete no-op jumps and optimize jumps to jumps    and jumps around jumps.    Delete unused labels and unreachable code.    If CROSS_JUMP is nonzero, detect matching code    before a jump and its destination and unify them.    If NOOP_MOVES is nonzero, also delete no-op move insns.     If `optimize' is zero, don't change any code,    just determine whether control drops off the end of the function.    This case occurs when we have -W and not -O.    It works because `delete_insn' checks the value of `optimize'    and refrains from actually deleting when that is 0.  */
end_comment

begin_function
name|void
name|jump_optimize
parameter_list|(
name|f
parameter_list|,
name|cross_jump
parameter_list|,
name|noop_moves
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
comment|/* Initialize LABEL_NUSES and JUMP_LABEL fields.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|max_uid
operator|++
expr_stmt|;
name|jump_chain
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|jump_chain
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete insns following barriers, up to next label.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* INSN is now the code_label.  */
block|}
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the label each jump jumps to.      Combine consecutive labels, and count uses of labels.       For each label, make a chain (using `jump_chain')      of all the *unconditional* jumps that jump to it;      also make a chain of all returns.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
literal|0
index|]
expr_stmt|;
name|jump_chain
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Delete all labels already not referenced.      Also find the last insn.  */
name|last_insn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|insn
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|last_insn
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
comment|/* See if there is still a NOTE_INSN_FUNCTION_END in this function. 	 If so record that this function can drop off the end.  */
name|insn
operator|=
name|last_insn
expr_stmt|;
block|{
name|int
name|n_labels
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|insn
comment|/* One label can follow the end-note: the return label.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|n_labels
operator|--
operator|>
literal|0
operator|)
comment|/* Ordinary insns can follow it if returning a structure.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
comment|/* If machine uses explicit RETURN insns, no epilogue, 		      then one of them follows the note.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
comment|/* Other kinds of notes can follow also.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|current_function_returns_null
decl_stmt|;
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Zero the "deleted" flag of all the "deleted" insns.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|noop_moves
condition|)
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
control|)
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Keep these insns, since they are used for conditional branch 	 scheduling peepholes on the sparc.  */
endif|#
directive|endif
comment|/* Delete insns that existed just to advise flow-analysis.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
comment|/* Detect and delete no-op move instructions 	       resulting from not allocating a parameter in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Detect and ignore no-op move instructions 	       resulting from smart or fortuitous register allocation.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|int
name|sreg
init|=
name|true_regnum
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dreg
init|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sreg
operator|==
name|dreg
operator|&&
name|sreg
operator|>=
literal|0
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sreg
operator|>=
literal|0
operator|&&
name|dreg
operator|>=
literal|0
condition|)
block|{
name|rtx
name|tem
init|=
name|find_equiv_reg
argument_list|(
literal|0
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|,
name|dreg
argument_list|,
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
comment|/* Deleting insn could lose a death-note for SREG or DREG 		       so don't do it if final needs accurate death-notes.  */
if|if
condition|(
operator|!
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|sreg
argument_list|)
operator|&&
operator|!
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|dreg
argument_list|)
condition|)
endif|#
directive|endif
if|if
condition|(
name|tem
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|tem
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
comment|/* Now iterate optimizing jumps until nothing changes over one pass.  */
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
specifier|register
name|rtx
name|next
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
if|#
directive|if
literal|0
comment|/* If NOT the first iteration, if this is the last jump pass 	     (just before final), do the special peephole optimizations. 	     Avoiding the first iteration gives ordinary jump opts 	     a chance to work before peephole opts.  */
block|if (noop_moves&& !first&& !flag_no_peephole) 	    if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN) 	      peephole (insn);
endif|#
directive|endif
comment|/* That could have deleted some insns after INSN, so check now 	     what the following insn is.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Tension the labels in dispatch tables.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|changed
operator||=
name|tension_vector_labels
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|noop_moves
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|changed
operator||=
name|tension_vector_labels
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|,
name|noop_moves
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow dropping through into a dispatch table. 	     That means the dispatch insn itself was deleted, 	     so delete the table too.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Note: the corresponding job for ADDR_VEC is done 		 in delete_insn.  */
comment|/* A vector of offsets is unused if its label 		 is used only once (i.e., from the vector).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|&&
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* So delete both label and vector.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
specifier|register
name|rtx
name|reallabelprev
init|=
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Detect jump to following insn.  */
if|if
condition|(
name|reallabelprev
operator|==
name|insn
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Detect worthless conditional jump.  */
elseif|else
if|if
condition|(
operator|(
name|temp
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|temp
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* A jump to a return becomes a return.  */
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|temp
operator|=
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Re-recognize this insn.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Detect jumping over an unconditional jump.  */
elseif|else
if|if
condition|(
name|reallabelprev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reallabelprev
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|prev_real_insn
argument_list|(
name|reallabelprev
argument_list|)
operator|==
name|insn
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|reallabelprev
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|reallabelprev
argument_list|)
comment|/* Ignore this if INSN is a hairy kind of jump, 			  since they may not be invertible. 			  This is conservative; could instead construct 			  the inverted insn and try recognizing it.  */
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Delete the original unconditional jump (and barrier).  */
comment|/* But don't let its destination go with it.  */
operator|++
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|reallabelprev
argument_list|)
expr_stmt|;
comment|/* Now change the condition, and make it go to the 		     place the deleted jump went to. 		     This may cause the label after the deletion to go away. 		     But now that the unconditional jump and its barrier 		     are gone, that is ok.  */
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Detect a jump to a jump.  */
block|{
specifier|register
name|rtx
name|nlabel
init|=
name|follow_jumps
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
name|noop_moves
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlabel
operator|!=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Look for   if (foo) bar; else break;  */
comment|/* The insns look like this: 		     insn = condjump label1; 		        ...range1 (some insns)... 			jump label2; 		     label1: 		        ...range2 (some insns)... 			jump somewhere unconditionally 		     label2:  */
block|{
name|rtx
name|label1
init|=
name|next_label
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|range1end
init|=
name|label1
condition|?
name|prev_real_insn
argument_list|(
name|label1
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Don't do this optimization on the first round, so that 		       jump-around-a-jump gets simplified before we ask here 		       whether a jump is unconditional.  */
if|if
condition|(
operator|!
name|first
comment|/* Make sure INSN is something we can invert.  */
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label1
operator|&&
name|LABEL_NUSES
argument_list|(
name|label1
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|range1end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|range1end
argument_list|)
condition|)
block|{
name|rtx
name|label2
init|=
name|next_label
argument_list|(
name|label1
argument_list|)
decl_stmt|;
name|rtx
name|range2end
init|=
name|label2
condition|?
name|prev_real_insn
argument_list|(
name|label2
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|range1end
operator|!=
name|range2end
operator|&&
name|JUMP_LABEL
argument_list|(
name|range1end
argument_list|)
operator|==
name|label2
operator|&&
name|GET_CODE
argument_list|(
name|range2end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|range2end
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|range1beg
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|range2beg
init|=
name|next_real_insn
argument_list|(
name|label1
argument_list|)
decl_stmt|;
name|rtx
name|range1after
decl_stmt|,
name|range2after
decl_stmt|;
name|rtx
name|range1before
decl_stmt|,
name|range2before
decl_stmt|;
comment|/* Don't move NOTEs for blocks; shift them 			       outside the ranges, where they'll stay put.  */
name|squeeze_block_notes
argument_list|(
name|range1beg
argument_list|,
name|range1end
argument_list|)
expr_stmt|;
name|squeeze_block_notes
argument_list|(
name|range2beg
argument_list|,
name|range2end
argument_list|)
expr_stmt|;
comment|/* Get current surrounds of the 2 ranges.  */
name|range1before
operator|=
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
expr_stmt|;
name|range2before
operator|=
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
expr_stmt|;
name|range1after
operator|=
name|NEXT_INSN
argument_list|(
name|range1end
argument_list|)
expr_stmt|;
name|range2after
operator|=
name|NEXT_INSN
argument_list|(
name|range2end
argument_list|)
expr_stmt|;
comment|/* Splice range2 where range1 was.  */
name|NEXT_INSN
argument_list|(
name|range1before
argument_list|)
operator|=
name|range2beg
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
operator|=
name|range1before
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|range2end
argument_list|)
operator|=
name|range1after
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range1after
argument_list|)
operator|=
name|range2end
expr_stmt|;
comment|/* Splice range1 where range2 was.  */
name|NEXT_INSN
argument_list|(
name|range2before
argument_list|)
operator|=
name|range1beg
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
operator|=
name|range2before
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|range1end
argument_list|)
operator|=
name|range2after
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range2after
argument_list|)
operator|=
name|range1end
expr_stmt|;
comment|/* Invert the jump condition, so we 			       still execute the same insns in each case.  */
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Now that the jump has been tensioned, 		     try cross jumping: check for identical code 		     before the jump and before its target label. */
comment|/* First, cross jumping of conditional jumps:  */
if|if
condition|(
name|cross_jump
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|;
name|rtx
name|x
init|=
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A conditional jump may be crossjumped 			 only if the place it jumps to follows 			 an opposing jump that comes back here.  */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
operator|!
name|jump_back_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
comment|/* We have no opposing jump; 			   cannot cross jump this insn.  */
name|x
operator|=
literal|0
expr_stmt|;
name|newjpos
operator|=
literal|0
expr_stmt|;
comment|/* TARGET is nonzero if it is ok to cross jump 			 to code before TARGET.  If so, see if matches.  */
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|x
argument_list|,
literal|2
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|newjpos
operator|!=
literal|0
condition|)
block|{
name|do_cross_jump
argument_list|(
name|insn
argument_list|,
name|newjpos
argument_list|,
name|newlpos
argument_list|)
expr_stmt|;
comment|/* Make the old conditional jump 			     into an unconditional one.  */
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Cross jumping of unconditional jumps: 		     a few differences.  */
if|if
condition|(
name|cross_jump
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|newjpos
operator|=
literal|0
expr_stmt|;
comment|/* TARGET is nonzero if it is ok to cross jump 			 to code before TARGET.  If so, see if matches.  */
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
comment|/* If cannot cross jump to code before the label, 			 see if we can cross jump to another jump to 			 the same label.  */
comment|/* Try each other jump to this label.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
name|max_uid
condition|)
for|for
control|(
name|target
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
init|;
name|target
operator|!=
literal|0
operator|&&
name|newjpos
operator|==
literal|0
condition|;
name|target
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
control|)
if|if
condition|(
name|target
operator|!=
name|insn
operator|&&
name|JUMP_LABEL
argument_list|(
name|target
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
comment|/* Ignore TARGET if it's deleted.  */
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|target
argument_list|)
condition|)
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|target
argument_list|,
literal|2
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|newjpos
operator|!=
literal|0
condition|)
block|{
name|do_cross_jump
argument_list|(
name|insn
argument_list|,
name|newjpos
argument_list|,
name|newlpos
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
comment|/* Return insns all "jump to the same place" 		 so we can cross-jump between any two of them.  */
if|if
condition|(
name|cross_jump
condition|)
block|{
name|rtx
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|,
name|target
decl_stmt|;
name|newjpos
operator|=
literal|0
expr_stmt|;
comment|/* If cannot cross jump to code before the label, 		     see if we can cross jump to another jump to 		     the same label.  */
comment|/* Try each other jump to this label.  */
for|for
control|(
name|target
operator|=
name|jump_chain
index|[
literal|0
index|]
init|;
name|target
operator|!=
literal|0
operator|&&
name|newjpos
operator|==
literal|0
condition|;
name|target
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
control|)
if|if
condition|(
name|target
operator|!=
name|insn
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|target
argument_list|,
literal|2
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|newjpos
operator|!=
literal|0
condition|)
block|{
name|do_cross_jump
argument_list|(
name|insn
argument_list|,
name|newjpos
argument_list|,
name|newlpos
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if there is still a NOTE_INSN_FUNCTION_END in this function.      If so, delete it, and record that this function can drop off the end.  */
name|insn
operator|=
name|last_insn
expr_stmt|;
block|{
name|int
name|n_labels
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|insn
comment|/* One label can follow the end-note: the return label.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|n_labels
operator|--
operator|>
literal|0
operator|)
comment|/* Ordinary insns can follow it if returning a structure.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
comment|/* If machine uses explicit RETURN insns, no epilogue, 		  then one of them follows the note.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
comment|/* Other kinds of notes can follow also.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
condition|)
block|{
specifier|extern
name|int
name|current_function_returns_null
decl_stmt|;
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the instructions before insn E1 with those before E2.    Assume E1 is a jump that jumps to label E2    (that is not always true but it might as well be).    Find the longest possible equivalent sequences    and store the first insns of those sequences into *F1 and *F2.    Store zero there if no equivalent preceding instructions are found.     We give up if we find a label in stream 1.    Actually we could transfer that label into stream 2.  */
end_comment

begin_function
specifier|static
name|void
name|find_cross_jump
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|,
name|minimum
parameter_list|,
name|f1
parameter_list|,
name|f2
parameter_list|)
name|rtx
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|minimum
decl_stmt|;
name|rtx
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rtx
name|i1
init|=
name|e1
decl_stmt|,
name|i2
init|=
name|e2
decl_stmt|;
specifier|register
name|rtx
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|rtx
name|last1
init|=
literal|0
decl_stmt|,
name|last2
init|=
literal|0
decl_stmt|;
name|rtx
name|afterlast1
init|=
literal|0
decl_stmt|,
name|afterlast2
init|=
literal|0
decl_stmt|;
operator|*
name|f1
operator|=
literal|0
expr_stmt|;
operator|*
name|f2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
while|while
condition|(
name|i1
operator|&&
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|NOTE
condition|)
name|i1
operator|=
name|PREV_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
while|while
condition|(
name|i2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|0
condition|)
break|break;
comment|/* Don't allow the range of insns preceding E1 or E2 	 to include the other (E2 or E1).  */
if|if
condition|(
name|i2
operator|==
name|e1
operator|||
name|i1
operator|==
name|e2
condition|)
break|break;
comment|/* If we will get to this code by jumping, those jumps will be 	 tensioned to go directly to the new label (before I2), 	 so this cross-jumping won't cost extra.  So reduce the minimum.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
operator|--
name|minimum
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i2
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|i2
argument_list|)
condition|)
break|break;
name|p1
operator|=
name|PATTERN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|p2
argument_list|)
operator|||
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
comment|/* Insns fail to match; cross jumping is limited to the following 	     insns.  */
comment|/* Don't allow the insn after a compare to be shared by cross-jumping 	     unless the compare is also shared. 	     Here, if either of these non-matching insns is a compare, 	     exclude the following insn from possible cross-jumping.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|p1
argument_list|)
operator|||
name|sets_cc0_p
argument_list|(
name|p2
argument_list|)
condition|)
name|last1
operator|=
name|afterlast1
operator|,
name|last2
operator|=
name|afterlast2
operator|,
operator|++
name|minimum
expr_stmt|;
comment|/* If cross-jumping here will feed a jump-around-jump optimization, 	     this jump won't cost extra, so reduce the minimum.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|i1
argument_list|)
operator|&&
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
name|e1
condition|)
operator|--
name|minimum
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
comment|/* Ok, this insn is potentially includable in a cross-jump here.  */
name|afterlast1
operator|=
name|last1
operator|,
name|afterlast2
operator|=
name|last2
expr_stmt|;
name|last1
operator|=
name|i1
operator|,
name|last2
operator|=
name|i2
operator|,
operator|--
name|minimum
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minimum
operator|<=
literal|0
operator|&&
name|last1
operator|!=
literal|0
condition|)
operator|*
name|f1
operator|=
name|last1
operator|,
operator|*
name|f2
operator|=
name|last2
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|do_cross_jump
parameter_list|(
name|insn
parameter_list|,
name|newjpos
parameter_list|,
name|newlpos
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|;
block|{
specifier|register
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|PREV_INSN
argument_list|(
name|newlpos
argument_list|)
expr_stmt|;
while|while
condition|(
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|NOTE
condition|)
name|label
operator|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|PREV_INSN
argument_list|(
name|newlpos
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make the same jump insn jump to the new point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
specifier|extern
name|rtx
name|gen_jump
parameter_list|()
function_decl|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Delete the matching insns before the jump.  */
name|newjpos
operator|=
name|PREV_INSN
argument_list|(
name|newjpos
argument_list|)
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|newjpos
argument_list|)
operator|!=
name|insn
condition|)
comment|/* Don't delete line numbers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|newjpos
argument_list|)
argument_list|)
operator|!=
name|NOTE
condition|)
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|newjpos
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|newjpos
operator|=
name|NEXT_INSN
argument_list|(
name|newjpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move all block-beg and block-end notes between START and END    out before START.  Assume neither START nor END is such a note.  */
end_comment

begin_function
specifier|static
name|void
name|squeeze_block_notes
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|start
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if INSN is a jump that jumps to right after TARGET    only on the condition that TARGET itself would drop through.    Assumes that TARGET is a conditional jump.  */
end_comment

begin_function
specifier|static
name|int
name|jump_back_p
parameter_list|(
name|insn
parameter_list|,
name|target
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|target
decl_stmt|;
block|{
name|rtx
name|cinsn
decl_stmt|,
name|ctarget
decl_stmt|,
name|prev
decl_stmt|;
name|enum
name|rtx_code
name|codei
decl_stmt|,
name|codet
decl_stmt|;
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|target
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target
operator|!=
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Verify that the condition code was based on a fixed-point computation.      Using reverse_condition is invalid for IEEE floating point with nans.  */
name|prev
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|cinsn
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctarget
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|codei
operator|=
name|GET_CODE
argument_list|(
name|cinsn
argument_list|)
expr_stmt|;
name|codet
operator|=
name|GET_CODE
argument_list|(
name|ctarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
name|codei
operator|=
name|reverse_condition
argument_list|(
name|codei
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
condition|)
name|codet
operator|=
name|reverse_condition
argument_list|(
name|codet
argument_list|)
expr_stmt|;
return|return
operator|(
name|codei
operator|==
name|codet
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cinsn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ctarget
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cinsn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ctarget
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx-code for a comparison, return the code    for the negated comparison.    WATCH OUT!  reverse_condition is not safe to use on a jump    that might be acting on the results of an IEEE floating point comparison,    because of the special treatment of non-signaling nans in comparisons.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|reverse_condition
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|GT
case|:
return|return
name|LE
return|;
case|case
name|GE
case|:
return|return
name|LT
return|;
case|case
name|LT
case|:
return|return
name|GE
return|;
case|case
name|LE
case|:
return|return
name|GT
return|;
case|case
name|GTU
case|:
return|return
name|LEU
return|;
case|case
name|GEU
case|:
return|return
name|LTU
return|;
case|case
name|LTU
case|:
return|return
name|GEU
return|;
case|case
name|LEU
case|:
return|return
name|GTU
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|UNKNOWN
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN is an unconditional jump and nothing else.  */
end_comment

begin_function
name|int
name|simplejump_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump    and nothing more.  */
end_comment

begin_function
name|int
name|condjump_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an RTX that does nothing but set the condition codes    and CLOBBER or USE registers.    Return -1 if X does explicitly set the condition codes,    but also does other things.  */
end_comment

begin_function
name|int
name|sets_cc0_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|sets_cc0
init|=
literal|0
decl_stmt|;
name|int
name|other_things
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
name|sets_cc0
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|other_things
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|!
name|sets_cc0
condition|?
literal|0
else|:
name|other_things
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if in between BEG and END there is no CODE_LABEL insn.  */
end_comment

begin_function
name|int
name|no_labels_between_p
parameter_list|(
name|beg
parameter_list|,
name|end
parameter_list|)
name|rtx
name|beg
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|beg
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last INSN, CALL_INSN or JUMP_INSN before LABEL;    or 0, if there is none.  */
end_comment

begin_function
name|rtx
name|prev_real_insn
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next INSN, CALL_INSN or JUMP_INSN after LABEL;    or 0, if there is none.  */
end_comment

begin_function
name|rtx
name|next_real_insn
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
name|insn
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */
end_comment

begin_function
name|rtx
name|next_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
do|do
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
do|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Follow any unconditional jump at LABEL;    return the ultimate label reached by any such chain of jumps.    If LABEL is not followed by a jump, return LABEL.    If IGNORE_LOOPS is 0, we do not chain across a NOTE_INSN_LOOP_BEG.  */
end_comment

begin_function
specifier|static
name|rtx
name|follow_jumps
parameter_list|(
name|label
parameter_list|,
name|ignore_loops
parameter_list|)
name|rtx
name|label
decl_stmt|;
name|int
name|ignore_loops
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|rtx
name|next
decl_stmt|;
specifier|register
name|rtx
name|value
init|=
name|label
decl_stmt|;
specifier|register
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
operator|(
name|depth
operator|<
literal|10
operator|&&
operator|(
name|insn
operator|=
name|next_real_insn
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
operator|)
condition|;
name|depth
operator|++
control|)
block|{
comment|/* Don't chain through the insn that jumps into a loop 	 from outside the loop, 	 since that would create multiple loop entry jumps 	 and prevent loop optimization.  */
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_loops
condition|)
for|for
control|(
name|tem
operator|=
name|value
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
return|return
name|value
return|;
comment|/* If we have found a cycle, make the insn jump to itself.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label
condition|)
break|break;
name|value
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Assuming that field IDX of X is a vector of label_refs,    replace each of them by the ultimate label reached by it.    Return nonzero if a change is made.    If IGNORE_LOOPS is 0, we do not chain across a NOTE_INSN_LOOP_BEG.  */
end_comment

begin_function
specifier|static
name|int
name|tension_vector_labels
parameter_list|(
name|x
parameter_list|,
name|idx
parameter_list|,
name|ignore_loops
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
name|int
name|ignore_loops
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|idx
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|olabel
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|nlabel
init|=
name|follow_jumps
argument_list|(
name|olabel
argument_list|,
name|ignore_loops
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlabel
operator|!=
name|olabel
condition|)
block|{
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all CODE_LABELs referred to in X,    and increment their use counts.    Also store one of them in JUMP_LABEL (INSN) if INSN is nonzero.    Also, when there are consecutive labels,    canonicalize on the last of them.     Note that two labels separated by a loop-beginning note    must be kept distinct if we have not yet done loop-optimization,    because the gap between them is where loop-optimize    will want to move invariant code to.  CROSS_JUMP tells us    that loop-optimization is done with.  */
end_comment

begin_function
specifier|static
name|void
name|mark_jump_label
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|cross_jump
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|cross_jump
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
return|return;
comment|/* If there are other labels following this one, 	 replace it with the last of the consecutive labels.  */
for|for
control|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
init|;
name|next
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
condition|)
break|break;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|label
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|label
expr_stmt|;
return|return;
block|}
comment|/* Do walk the labels in a vector,      but don't set its JUMP_LABEL.  */
if|if
condition|(
name|code
operator|==
name|ADDR_VEC
operator|||
name|code
operator|==
name|ADDR_DIFF_VEC
condition|)
name|insn
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_jump_label
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If all INSN does is set the pc, delete it,    and delete the insn that set the condition codes for it    if that's what the previous thing was.  */
end_comment

begin_function
specifier|static
name|void
name|delete_jump
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|prev
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We assume that at this stage 	 CC's are always set explicitly 	 and always immediately before the jump that 	 will use them.  So if the previous insn 	 exists to set the CC's, delete it 	 (unless it performs auto-increments, etc.).  */
while|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|prev
argument_list|,
name|REG_INC
argument_list|,
literal|0
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete insn INSN from the chain of insns and update label ref counts.    May delete some following insns as a consequence; may even delete    a label elsewhere and insns that follow it.     Returns the first insn after INSN that was not deleted.  */
end_comment

begin_function
name|rtx
name|delete_insn
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* This insn is already deleted => return first following nondeleted.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|next
return|;
comment|/* Mark this insn as deleted.  */
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If instruction is followed by a barrier,      delete the barrier too.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Patch out INSN (and the barrier if any) */
if|if
condition|(
name|optimize
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
condition|)
name|set_last_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* If deleting a jump, decrement the count of the label,      and delete the label if it is now unused.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This can delete NEXT or PREV, 	   either directly if NEXT is JUMP_LABEL (INSN), 	   or indirectly through more levels of jumps.  */
name|delete_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I feel a little doubtful about this loop, 	   but I see no clean and sure alternative way 	   to find the first insn after INSN that is not now deleted. 	   I hope this works.  */
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
while|while
condition|(
name|prev
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
operator|)
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* If INSN was a label and a dispatch table follows it,      delete the dispatch table.  The tablejump must have gone already.      It isn't useful to fall through into a table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|next
operator|=
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If INSN was a label, delete insns following it if now unreachable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|)
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|NOTE
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
comment|/* Note: if this deletes a jump, it can cause more 	       deletion of unreachable code, after a different label. 	       As long as the value from this recursive call is correct, 	       this invocation functions correctly.  */
name|next
operator|=
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Advance from INSN till reaching something not deleted    then return that.  May return INSN itself.  */
end_comment

begin_function
name|rtx
name|next_nondeleted_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a range of insns from FROM to TO, inclusive.    This is for the sake of peephole optimization, so assume    that whatever these insns do will still be done by a new    peephole insn that will replace them.  */
end_comment

begin_function
name|void
name|delete_for_peephole
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|from
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Patch this insn out of the chain.  */
comment|/* We don't do this all at once, because we 	     must preserve all NOTEs.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|to
condition|)
break|break;
name|insn
operator|=
name|next
expr_stmt|;
block|}
comment|/* Note that if TO is an unconditional jump      we *do not* delete the BARRIER that follows,      since the peephole that replaces this sequence      is also an unconditional jump in that case.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Invert the condition of the jump JUMP, and make it jump    to label NLABEL instead of where it jumps now.  */
end_comment

begin_function
name|void
name|invert_jump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
specifier|register
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
name|invert_exp
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|nlabel
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|jump
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert the jump condition of rtx X,    and replace OLABEL with NLABEL throughout.    This is used in do_jump as well as in this file.  */
end_comment

begin_function
name|void
name|invert_exp
parameter_list|(
name|x
parameter_list|,
name|olabel
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|olabel
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
comment|/* Inverting the jump condition of an IF_THEN_ELSE 	 means exchanging the THEN-part with the ELSE-part.  */
specifier|register
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|invert_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|invert_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make jump JUMP jump to label NLABEL instead of where it jumps now.    If the old jump target label is unused as a result,    it and the code following it may be deleted.  */
end_comment

begin_function
name|void
name|redirect_jump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
specifier|register
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlabel
operator|==
name|olabel
condition|)
return|return;
name|redirect_exp
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|nlabel
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|jump
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Throughout the rtx X,    alter (LABEL_REF OLABEL) to (LABEL_REF NLABEL).  */
end_comment

begin_function
specifier|static
name|void
name|redirect_exp
parameter_list|(
name|x
parameter_list|,
name|olabel
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|olabel
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|redirect_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|redirect_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p except that it considers two REGs as equal    if they renumber to the same value.  */
end_comment

begin_function
name|int
name|rtx_renumbered_equal_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|i
operator|=
name|reg_renumber
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|i
operator|=
name|reg_renumber
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|j
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|j
operator|=
name|reg_renumber
index|[
name|j
index|]
expr_stmt|;
name|j
operator|+=
name|SUBREG_WORD
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|j
operator|=
name|reg_renumber
index|[
name|j
index|]
expr_stmt|;
block|}
return|return
name|i
operator|==
name|j
return|;
block|}
comment|/* Now we have disposed of all the cases       in which different rtx codes can match.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
return|return
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XINT
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
comment|/* Two label-refs are equivalent if they point at labels 	 in the same position in the instruction stream.  */
return|return
operator|(
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'0'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a hard register or equivalent to one or a subregister of one,    return the hard register number.  Otherwise, return -1.    Any rtx is valid for X.  */
end_comment

begin_function
name|int
name|true_regnum
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|int
name|base
init|=
name|true_regnum
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
operator|&&
name|base
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|+
name|base
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

