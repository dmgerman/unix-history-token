begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *  * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *  * Polk's hash list manager.  So cool.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$CVSid: @(#)hash.c 1.19 94/09/23 $"
decl_stmt|;
end_decl_stmt

begin_macro
name|USE
argument_list|(
argument|rcsid
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* global caches */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|listcache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Node
modifier|*
name|nodecache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freenode_mem
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash function */
end_comment

begin_function
specifier|static
name|int
name|hashp
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|g
decl_stmt|;
while|while
condition|(
operator|*
name|key
operator|!=
literal|0
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|key
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0
condition|)
name|h
operator|=
operator|(
name|h
operator|^
operator|(
name|g
operator|>>
literal|24
operator|)
operator|)
operator|^
name|g
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|%
name|HASHSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a new list (or get an old one from the cache)  */
end_comment

begin_function
name|List
modifier|*
name|getlist
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|listcache
operator|!=
name|NULL
condition|)
block|{
comment|/* get a list from the cache and clear it */
name|list
operator|=
name|listcache
expr_stmt|;
name|listcache
operator|=
name|listcache
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
name|list
operator|->
name|hasharray
index|[
name|i
index|]
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* make a new list from scratch */
name|list
operator|=
operator|(
name|List
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|list
operator|->
name|list
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|HEADER
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|node
operator|->
name|prev
operator|=
name|node
expr_stmt|;
block|}
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free up a list  */
end_comment

begin_function
name|void
name|dellist
parameter_list|(
name|listp
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
return|return;
name|p
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|list
expr_stmt|;
comment|/* free each node in the list (except header) */
while|while
condition|(
name|p
operator|->
name|next
operator|!=
name|p
condition|)
name|delnode
argument_list|(
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* free any list-private data, without freeing the actual header */
name|freenode_mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* free up the header nodes for hash lists (if any) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|hasharray
index|[
name|i
index|]
operator|)
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* put the nodes into the cache */
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* put it on the cache */
operator|(
operator|*
name|listp
operator|)
operator|->
name|next
operator|=
name|listcache
expr_stmt|;
name|listcache
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new list node  */
end_comment

begin_function
name|Node
modifier|*
name|getnode
parameter_list|()
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nodecache
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* get one from the cache */
name|p
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* make a new one */
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* always make it clean */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * remove a node from it's list (maybe hash list too) and free it  */
end_comment

begin_function
name|void
name|delnode
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* take it out of the list */
name|p
operator|->
name|next
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* if it was hashed, remove it from there too */
if|if
condition|(
name|p
operator|->
name|hashnext
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|->
name|hashnext
operator|->
name|hashprev
operator|=
name|p
operator|->
name|hashprev
expr_stmt|;
name|p
operator|->
name|hashprev
operator|->
name|hashnext
operator|=
name|p
operator|->
name|hashnext
expr_stmt|;
block|}
comment|/* free up the storage */
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up the storage associated with a node  */
end_comment

begin_function
specifier|static
name|void
name|freenode_mem
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|delproc
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
condition|)
name|p
operator|->
name|delproc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* call the specified delproc */
else|else
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
comment|/* otherwise free() it if necessary */
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|key
operator|!=
name|NULL
condition|)
comment|/* free the key if necessary */
name|free
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* to be safe, re-initialize these */
name|p
operator|->
name|key
operator|=
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up the storage associated with a node and recycle it  */
end_comment

begin_function
name|void
name|freenode
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* first free the memory */
name|freenode_mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* then put it in the cache */
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * insert item p at end of list "list" (maybe hash it too) if hashing and it  * already exists, return -1 and don't actually put it in the list  *  * return 0 on success  */
end_comment

begin_function
name|int
name|addnode
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|hashval
decl_stmt|;
name|Node
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|key
operator|!=
name|NULL
condition|)
comment|/* hash it too? */
block|{
name|hashval
operator|=
name|hashp
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|==
name|NULL
condition|)
comment|/* make a header for list? */
block|{
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|HEADER
expr_stmt|;
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|=
name|q
operator|->
name|hashnext
operator|=
name|q
operator|->
name|hashprev
operator|=
name|q
expr_stmt|;
block|}
comment|/* put it into the hash list if it's not already there */
for|for
control|(
name|q
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|->
name|hashnext
init|;
name|q
operator|!=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
condition|;
name|q
operator|=
name|q
operator|->
name|hashnext
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|q
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
expr_stmt|;
name|p
operator|->
name|hashprev
operator|=
name|q
operator|->
name|hashprev
expr_stmt|;
name|p
operator|->
name|hashnext
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|hashprev
operator|->
name|hashnext
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|hashprev
operator|=
name|p
expr_stmt|;
block|}
comment|/* put it into the regular list */
name|p
operator|->
name|prev
operator|=
name|list
operator|->
name|list
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|list
operator|->
name|list
expr_stmt|;
name|list
operator|->
name|list
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|list
operator|->
name|list
operator|->
name|prev
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * look up an entry in hash list table and return a pointer to the  * node.  Return NULL on error or not found.  */
end_comment

begin_function
name|Node
modifier|*
name|findnode
parameter_list|(
name|list
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|list
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
name|head
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashp
argument_list|(
name|key
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|hashnext
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|hashnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * walk a list with a specific proc  */
end_comment

begin_decl_stmt
name|int
name|walklist
argument_list|(
name|list
argument_list|,
name|proc
argument_list|,
name|closure
argument_list|)
name|List
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|closure
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|head
operator|=
name|list
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|err
operator|+=
name|proc
argument_list|(
name|p
argument_list|,
name|closure
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * sort the elements of a list (in place)  */
end_comment

begin_decl_stmt
name|void
name|sortlist
argument_list|(
name|list
argument_list|,
name|comp
argument_list|)
name|List
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|comp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|remain
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* save the old first element of the list */
name|head
operator|=
name|list
operator|->
name|list
expr_stmt|;
name|remain
operator|=
name|head
operator|->
name|next
expr_stmt|;
comment|/* make the header node into a null list of it's own */
name|head
operator|->
name|next
operator|=
name|head
operator|->
name|prev
operator|=
name|head
expr_stmt|;
comment|/* while there are nodes remaining, do insert sort */
while|while
condition|(
name|remain
operator|!=
name|head
condition|)
block|{
comment|/* take one from the list */
name|p
operator|=
name|remain
expr_stmt|;
name|remain
operator|=
name|remain
operator|->
name|next
expr_stmt|;
comment|/* traverse the sorted list looking for the place to insert it */
for|for
control|(
name|q
operator|=
name|head
operator|->
name|next
init|;
name|q
operator|!=
name|head
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|comp
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* p comes before q */
name|p
operator|->
name|next
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|q
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|prev
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|q
operator|==
name|head
condition|)
block|{
comment|/* it belongs at the end of the list */
name|p
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|head
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Debugging functions.  Quite useful to call from within gdb. */
end_comment

begin_function
name|char
modifier|*
name|nodetypestring
parameter_list|(
name|type
parameter_list|)
name|Ntype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UNKNOWN
case|:
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
case|case
name|HEADER
case|:
return|return
operator|(
literal|"HEADER"
operator|)
return|;
case|case
name|ENTRIES
case|:
return|return
operator|(
literal|"ENTRIES"
operator|)
return|;
case|case
name|FILES
case|:
return|return
operator|(
literal|"FILES"
operator|)
return|;
case|case
name|LIST
case|:
return|return
operator|(
literal|"LIST"
operator|)
return|;
case|case
name|RCSNODE
case|:
return|return
operator|(
literal|"RCSNODE"
operator|)
return|;
case|case
name|RCSVERS
case|:
return|return
operator|(
literal|"RCSVERS"
operator|)
return|;
case|case
name|DIRS
case|:
return|return
operator|(
literal|"DIRS"
operator|)
return|;
case|case
name|UPDATE
case|:
return|return
operator|(
literal|"UPDATE"
operator|)
return|;
case|case
name|LOCK
case|:
return|return
operator|(
literal|"LOCK"
operator|)
return|;
case|case
name|NDBMNODE
case|:
return|return
operator|(
literal|"NDBMNODE"
operator|)
return|;
block|}
return|return
operator|(
literal|"<trash>"
operator|)
return|;
block|}
end_function

begin_function
name|int
name|printnode
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL node.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Node at 0x%p: type = %s, key = 0x%p = \"%s\", data = 0x%p, next = 0x%p, prev = 0x%p\n"
argument_list|,
name|node
argument_list|,
name|nodetypestring
argument_list|(
name|node
operator|->
name|type
argument_list|)
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|node
operator|->
name|data
argument_list|,
name|node
operator|->
name|next
argument_list|,
name|node
operator|->
name|prev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|printlist
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"List at 0x%p: list = 0x%p, HASHSIZE = %d, next = 0x%p\n"
argument_list|,
name|list
argument_list|,
name|list
operator|->
name|list
argument_list|,
name|HASHSIZE
argument_list|,
name|list
operator|->
name|next
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|list
argument_list|,
name|printnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

