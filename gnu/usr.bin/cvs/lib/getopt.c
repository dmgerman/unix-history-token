begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Getopt for GNU.    Copyright (C) 1987-1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|__STDC__
end_if

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This version of `getopt' appears to the caller like standard Unix `getopt'    but it behaves differently for the user, since it allows the user    to intersperse the options with the other arguments.     As `getopt' works, it permutes the elements of `argv' so that,    when it is done, all the options precede everything else.  Thus    all application programs are extended to handle flexible argument order.     Setting the environment variable _POSIX_OPTION_ORDER disables permutation.    Then the behavior is completely standard.     GNU application programs can use a third alternative mode in which    they can distinguish the relative order of options and other arguments.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)getopt.c 1.7 92/03/31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* STDC_HEADERS or __GNU_LIBRARY__ */
end_comment

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC_HEADERS or __GNU_LIBRARY__ */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|bsdi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sparc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|bcopy
end_ifndef

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy ((d), (s), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USG or STDC_HEADERS or __GNU_LIBRARY__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* Declaring bcopy causes errors on systems whose declarations are different.    If the declaration is omitted, everything works fine.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG or STDC_HEADERS or __GNU_LIBRARY__ */
end_comment

begin_comment
comment|/* For communication from `getopt' to the caller.    When `getopt' finds an option that takes an argument,    the argument value is returned here.    Also, when `ordering' is RETURN_IN_ORDER,    each non-option ARGV-element is returned here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|optarg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in ARGV of the next element to be scanned.    This is used for communication to and from the caller    and for communication between successive calls to `getopt'.     On entry to `getopt', zero means this is the first call; initialize.     When `getopt' returns EOF, this is the index of the first of the    non-option elements that the caller should itself scan.     Otherwise, `optind' communicates from one call to the next    how much of ARGV has been scanned so far.  */
end_comment

begin_decl_stmt
name|int
name|optind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next char to be scanned in the option-element    in which the last option character we returned was found.    This allows us to pick up the scan where we left off.     If this is zero, or a null string, it means resume the scan    by advancing to the next ARGV-element.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callers store zero here to inhibit the error message    for unrecognized options.  */
end_comment

begin_decl_stmt
name|int
name|opterr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe how to deal with options that follow non-option ARGV-elements.     If the caller did not specify anything,    the default is REQUIRE_ORDER if the environment variable    _POSIX_OPTION_ORDER is defined, PERMUTE otherwise.     REQUIRE_ORDER means don't recognize them as options;    stop option processing when the first non-option is seen.    This is what Unix does.    This mode of operation is selected by either setting the environment    variable POSIX_ME_HARDER, or using `+' as the first character    of the list of option characters.     PERMUTE is the default.  We permute the contents of ARGV as we scan,    so that eventually all the non-options are at the end.  This allows options    to be given in any order, even with programs that were not written to    expect this.     RETURN_IN_ORDER is an option available to programs that were written    to expect options and other ARGV-elements in any order and that care about    the ordering of the two.  We describe each non-option ARGV-element    as if it were the argument of an option with character code 1.    Using `-' as the first character of the list of option characters    selects this mode of operation.     The special argument `--' forces an end of option-scanning regardless    of the value of `ordering'.  In the case of RETURN_IN_ORDER, only    `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|REQUIRE_ORDER
block|,
name|PERMUTE
block|,
name|RETURN_IN_ORDER
block|}
name|ordering
enum|;
end_enum

begin_comment
comment|/* Describe the long-named options requested by the application.    _GETOPT_LONG_OPTIONS is a vector of `struct option' terminated by an    element containing a name which is zero.    The field `has_arg' is 1 if the option takes an argument,    2 if it takes an optional argument.  */
end_comment

begin_struct
struct|struct
name|option
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|has_arg
decl_stmt|;
name|int
modifier|*
name|flag
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|option
modifier|*
name|_getopt_long_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_getopt_long_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in _GETOPT_LONG_OPTIONS of the long-named option actually found.    Only valid when a long-named option was found. */
end_comment

begin_decl_stmt
name|int
name|option_index
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Handle permutation of arguments.  */
end_comment

begin_comment
comment|/* Describe the part of ARGV that contains non-options that have    been skipped.  `first_nonopt' is the index in ARGV of the first of them;    `last_nonopt' is the index after the last of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_nonopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_nonopt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exchange two adjacent subsequences of ARGV.    One subsequence is elements [first_nonopt,last_nonopt)     which contains all the non-options that have been skipped so far.    The other is elements [last_nonopt,optind), which contains all     the options processed since those non-options were skipped.     `first_nonopt' and `last_nonopt' are relocated so that they describe     the new indices of the non-options in ARGV after they are moved.  */
end_comment

begin_function
specifier|static
name|void
name|exchange
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|nonopts_size
init|=
operator|(
name|last_nonopt
operator|-
name|first_nonopt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nonopts_size
argument_list|)
decl_stmt|;
comment|/* Interchange the two blocks of data in ARGV.  */
name|bcopy
argument_list|(
operator|&
name|argv
index|[
name|first_nonopt
index|]
argument_list|,
name|temp
argument_list|,
name|nonopts_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|argv
index|[
name|last_nonopt
index|]
argument_list|,
operator|&
name|argv
index|[
name|first_nonopt
index|]
argument_list|,
operator|(
name|optind
operator|-
name|last_nonopt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
operator|&
name|argv
index|[
name|first_nonopt
operator|+
name|optind
operator|-
name|last_nonopt
index|]
argument_list|,
name|nonopts_size
argument_list|)
expr_stmt|;
comment|/* Update records for the slots the non-options now occupy.  */
name|first_nonopt
operator|+=
operator|(
name|optind
operator|-
name|last_nonopt
operator|)
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan elements of ARGV (whose length is ARGC) for option characters    given in OPTSTRING.     If an element of ARGV starts with '-', and is not exactly "-" or "--",    then it is an option element.  The characters of this element    (aside from the initial '-') are option characters.  If `getopt'    is called repeatedly, it returns successively each of the option characters    from each of the option elements.     If `getopt' finds another option character, it returns that character,    updating `optind' and `nextchar' so that the next call to `getopt' can    resume the scan with the following option character or ARGV-element.     If there are no more option characters, `getopt' returns `EOF'.    Then `optind' is the index in ARGV of the first ARGV-element    that is not an option.  (The ARGV-elements have been permuted    so that those that are not options now come last.)     OPTSTRING is a string containing the legitimate option characters.    If an option character is seen that is not listed in OPTSTRING,    return '?' after printing an error message.  If you set `opterr' to    zero, the error message is suppressed but we still return '?'.     If a char in OPTSTRING is followed by a colon, that means it wants an arg,    so the following text in the same ARGV-element, or the text of the following    ARGV-element, is returned in `optarg'.  Two colons mean an option that    wants an optional arg; if there is text in the current ARGV-element,    it is returned in `optarg', otherwise `optarg' is set to zero.     If OPTSTRING starts with `-' or `+', it requests different methods of    handling the non-option ARGV-elements.    See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.     Long-named options begin with `+' instead of `-'.    Their names may be abbreviated as long as the abbreviation is unique    or is an exact match for some defined option.  If they have an    argument, it follows the option name in the same ARGV-element, separated    from the option name by a `=', or else the in next ARGV-element.    When `getopt' finds a long-named option, it returns 0 if that option's    `flag' field is nonzero, the value of the option's `val' field    otherwise.  */
end_comment

begin_function
name|int
name|gnu_getopt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstring
decl_stmt|;
block|{
name|optarg
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the internal data when the first call is made.      Start processing options with ARGV-element 1 (since ARGV-element 0      is the program name); the sequence of previously skipped      non-option ARGV-elements is empty.  */
if|if
condition|(
name|optind
operator|==
literal|0
condition|)
block|{
name|first_nonopt
operator|=
name|last_nonopt
operator|=
name|optind
operator|=
literal|1
expr_stmt|;
name|nextchar
operator|=
literal|0
expr_stmt|;
comment|/* Determine how to handle the ordering of options and nonoptions.  */
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|ordering
operator|=
name|RETURN_IN_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"POSIX_ME_HARDER"
argument_list|)
operator|!=
literal|0
condition|)
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
else|else
name|ordering
operator|=
name|PERMUTE
expr_stmt|;
block|}
if|if
condition|(
name|nextchar
operator|==
literal|0
operator|||
operator|*
name|nextchar
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|PERMUTE
condition|)
block|{
comment|/* If we have just processed some options following some non-options, 	     exchange them so that the options come first.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_nonopt
operator|!=
name|optind
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
comment|/* Now skip any additional non-options 	     and extend the range of non-options previously skipped.  */
while|while
condition|(
name|optind
operator|<
name|argc
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|_getopt_long_options
operator|==
literal|0
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|optind
operator|++
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
comment|/* Special ARGV-element `--' means premature end of options. 	 Skip it like a null option, 	 then exchange with previous non-options as if it were an option, 	 then skip everything else like a non-option.  */
if|if
condition|(
name|optind
operator|!=
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_nonopt
operator|==
name|last_nonopt
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
name|last_nonopt
operator|=
name|argc
expr_stmt|;
name|optind
operator|=
name|argc
expr_stmt|;
block|}
comment|/* If we have done all the ARGV-elements, stop the scan 	 and back over any non-options that we skipped and permuted.  */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Set the next-arg-index to point at the non-options 	     that we previously skipped, so the caller will digest them.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
condition|)
name|optind
operator|=
name|first_nonopt
expr_stmt|;
return|return
name|EOF
return|;
block|}
comment|/* If we have come to a non-option and did not permute it, 	 either stop the scan or describe it to the caller and pass it by.  */
if|if
condition|(
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|_getopt_long_options
operator|==
literal|0
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|REQUIRE_ORDER
condition|)
return|return
name|EOF
return|;
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We have found another option-ARGV-element. 	 Start decoding its characters.  */
name|nextchar
operator|=
name|argv
index|[
name|optind
index|]
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|_getopt_long_options
operator|!=
literal|0
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
operator|(
name|_getopt_long_only
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|)
condition|)
block|{
specifier|const
name|struct
name|option
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|nextchar
decl_stmt|;
name|int
name|exact
init|=
literal|0
decl_stmt|;
name|int
name|ambig
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|pfound
init|=
literal|0
decl_stmt|;
name|int
name|indfound
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Test all options for either exact match or abbreviated matches.  */
for|for
control|(
name|p
operator|=
name|_getopt_long_options
operator|,
name|option_index
operator|=
literal|0
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
operator|,
name|option_index
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|nextchar
argument_list|,
name|s
operator|-
name|nextchar
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|-
name|nextchar
operator|==
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Exact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
name|exact
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfound
operator|==
literal|0
condition|)
block|{
comment|/* First nonexact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
block|}
else|else
comment|/* Second nonexact match found.  */
name|ambig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ambig
operator|&&
operator|!
name|exact
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `%s' is ambiguous\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|pfound
operator|!=
literal|0
condition|)
block|{
name|option_index
operator|=
name|indfound
expr_stmt|;
name|optind
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|>
literal|0
condition|)
name|optarg
operator|=
name|s
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `%c%s' doesn't allow an argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `%s' requires an argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfound
operator|->
name|flag
condition|)
block|{
operator|*
operator|(
name|pfound
operator|->
name|flag
operator|)
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pfound
operator|->
name|val
return|;
block|}
comment|/* Can't find it as a long option.  If this is getopt_long_only, 	 and the option starts with '-' and is a valid short 	 option, then interpret it as a short option.  Otherwise it's 	 an error.  */
if|if
condition|(
name|_getopt_long_only
operator|==
literal|0
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|index
argument_list|(
name|optstring
argument_list|,
operator|*
name|nextchar
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opterr
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option `%c%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
argument_list|,
name|nextchar
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
comment|/* Look at and handle the next option-character.  */
block|{
name|char
name|c
init|=
operator|*
name|nextchar
operator|++
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|index
argument_list|(
name|optstring
argument_list|,
name|c
argument_list|)
decl_stmt|;
comment|/* Increment `optind' when we start to process its last character.  */
if|if
condition|(
operator|*
name|nextchar
operator|==
literal|0
condition|)
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|opterr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|||
name|c
operator|>=
literal|0177
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option, character code 0%o\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option `-%c'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|temp
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* This is an option that accepts an argument optionally.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|0
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
else|else
name|optarg
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|0
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 		   we must advance to the next element now.  */
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|opterr
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `-%c' requires an argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
comment|/* We already incremented `optind' once; 		 increment it again when taking next ARGV-elt as argument.  */
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|nextchar
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Compile with -DTEST to make an executable for use in testing    the above definition of `getopt'.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|digit_optind
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|this_option_optind
init|=
name|optind
condition|?
name|optind
else|:
literal|1
decl_stmt|;
name|c
operator|=
name|gnu_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abc:d:0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|digit_optind
operator|!=
literal|0
operator|&&
name|digit_optind
operator|!=
name|this_option_optind
condition|)
name|printf
argument_list|(
literal|"digits occur in two different argv-elements.\n"
argument_list|)
expr_stmt|;
name|digit_optind
operator|=
name|this_option_optind
expr_stmt|;
name|printf
argument_list|(
literal|"option %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"option a\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|printf
argument_list|(
literal|"option b\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printf
argument_list|(
literal|"option c with value `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"?? getopt returned character code 0%o ??\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|printf
argument_list|(
literal|"non-option ARGV-elements: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

