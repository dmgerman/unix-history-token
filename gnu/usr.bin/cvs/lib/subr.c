begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * Various useful functions for the CVS support code.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MINIX
end_ifdef

begin_undef
undef|#
directive|undef
name|POSIX
end_undef

begin_comment
comment|/* Minix 1.6 doesn't support POSIX.1 sigaction yet */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VPRINTF_MISSING
end_ifndef

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args, lastarg)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|va_alist
value|a1, a2, a3, a4, a5, a6, a7, a8
end_define

begin_define
define|#
directive|define
name|va_dcl
value|char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)subr.c 1.52 92/03/31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|void
name|run_add_arg
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_init_prog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|run_add_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_init_prog
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Copies "from" to "to". mallocs a buffer large enough to hold the entire  * file and does one read/one write to do the copy.  This is reasonable,  * since source files are typically not too large.  */
end_comment

begin_function
name|void
name|copy_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|utimbuf
name|t
decl_stmt|;
name|int
name|fdin
decl_stmt|,
name|fdout
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> copy(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
operator|(
name|fdin
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fdin
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdout
operator|=
name|creat
argument_list|(
name|to
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fdin
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
ifndef|#
directive|ifndef
name|FSYNC_MISSING
operator|||
name|fsync
argument_list|(
name|fdout
argument_list|)
operator|==
operator|-
literal|1
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write file %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fdout
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* now, set the times for the copied file to match those of the original */
name|t
operator|.
name|actime
operator|=
name|sb
operator|.
name|st_atime
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|to
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is a directory, or is a symbolic  * link which points to a directory.  */
end_comment

begin_function
name|int
name|isdir
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is a symbolic link.  */
end_comment

begin_function
name|int
name|islink
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_ISLNK
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file exists.  */
end_comment

begin_function
name|int
name|isfile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is readable.  * XXX - must be careful if "cvs" is ever made setuid!  */
end_comment

begin_function
name|int
name|isreadable
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
operator|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is writable  * XXX - muct be careful if "cvs" is ever made setuid!  */
end_comment

begin_function
name|int
name|iswritable
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
operator|(
name|access
argument_list|(
name|file
argument_list|,
name|W_OK
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a file and die if it fails  */
end_comment

begin_function
name|FILE
modifier|*
name|open_file
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a file if allowed and return.  */
end_comment

begin_function
name|FILE
modifier|*
name|Fopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> fopen(%s,%s)\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a directory and die if it fails  */
end_comment

begin_function
name|void
name|make_directory
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
operator|(
name|R_OK
operator||
name|W_OK
operator||
name|X_OK
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Directory %s already exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Directory %s already exists but is protected from you"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s already exists but is not a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noexec
operator|&&
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a path to the argument directory, printing a message if something  * goes wrong.  */
end_comment

begin_function
name|void
name|make_directories
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EEXIST
condition|)
return|return;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make path to %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|make_directories
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * malloc some data and die if it fails  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad malloc size %d"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * realloc data and die if it fails [I've always wanted to have "realloc" do  * a "malloc" if the argument is NULL, but you can't depend on it.  Here, I  * can *force* it.  */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
operator|(
name|xmalloc
argument_list|(
name|bytes
argument_list|)
operator|)
return|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad realloc size %d"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
operator|(
name|unsigned
operator|)
name|bytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"realloc failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate a string, calling xmalloc to allocate some dynamic space  */
end_comment

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|s
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change the mode of a file, either adding write permissions, or removing  * all write permissions.  Adding write permissions honors the current umask  * setting.  */
end_comment

begin_function
name|void
name|xchmod
parameter_list|(
name|fname
parameter_list|,
name|writable
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|writable
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|oumask
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|writable
condition|)
block|{
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator||
operator|(
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&
operator|~
name|oumask
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> chmod(%s,%o)\n"
argument_list|,
name|fname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|chmod
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename a file and die if it fails  */
end_comment

begin_function
name|void
name|rename_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> rename(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot rename file %s to %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * link a file, if possible.  */
end_comment

begin_function
name|int
name|link_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> link(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * unlink a file, if possible.  */
end_comment

begin_function
name|int
name|unlink_file
parameter_list|(
name|f
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> unlink(%s)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|unlink
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare "file1" to "file2". Return non-zero if they don't compare exactly.  *   * mallocs a buffer large enough to hold the entire file and does two reads to  * load the buffer and calls bcmp to do the cmp. This is reasonable, since  * source files are typically not too large.  */
end_comment

begin_function
name|int
name|xcmp
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|char
modifier|*
name|file1
decl_stmt|;
name|char
modifier|*
name|file2
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|file2
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd1
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd2
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|sb
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|buf1
operator|=
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd1
argument_list|,
name|buf1
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s cor comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd2
argument_list|,
name|buf2
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|bcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recover the space allocated by Find_Names() and line2argv()  */
end_comment

begin_function
name|void
name|free_names
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
name|i
operator|++
control|)
block|{
comment|/* only do through *pargc */
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|pargc
operator|=
literal|0
expr_stmt|;
comment|/* and set it to zero when done */
block|}
end_function

begin_comment
comment|/*  * Convert a line into argc/argv components and return the result in the  * arguments as passed.  Use free_names() to return the memory allocated here  * back to the free pool.  */
end_comment

begin_function
name|void
name|line2argv
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|,
name|line
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
operator|*
name|pargc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
name|argv
index|[
operator|*
name|pargc
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pargc
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the number of dots ('.') found in an RCS revision number  */
end_comment

begin_function
name|int
name|numdots
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|dots
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
name|dots
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|dots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the caller's login from his uid. If the real uid is "root" try LOGNAME  * USER or getlogin(). If getlogin() and getpwuid() both fail, return  * the uid as a string.  */
end_comment

begin_function
name|char
modifier|*
name|getcaller
parameter_list|()
block|{
specifier|static
name|char
name|uidname
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
block|{
comment|/* super-user; try getlogin() to distinguish */
if|if
condition|(
operator|(
operator|(
name|name
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|||
operator|(
name|name
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|||
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
operator|)
operator|&&
operator|*
name|name
condition|)
return|return
operator|(
name|name
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|uidname
argument_list|,
literal|"uid%d"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|uidname
operator|)
return|;
block|}
return|return
operator|(
name|pw
operator|->
name|pw_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * To exec a program under CVS, first call run_setup() to setup any initial  * arguments.  The options to run_setup are essentially like printf(). The  * arguments will be parsed into whitespace separated words and added to the  * global run_argv list.  *   * Then, optionally call run_arg() for each additional argument that you'd like  * to pass to the executed program.  *   * Finally, call run_exec() to execute the program with the specified arguments.  * The execvp() syscall will be used, so that the PATH is searched correctly.  * File redirections can be performed in the call to run_exec().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|run_prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|run_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_argc_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VARARGS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VPRINTF_MISSING
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function
name|void
name|run_setup
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|void  run_setup
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|VPRINTF_MISSING
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|run_init_prog
argument_list|()
expr_stmt|;
comment|/* clean out any malloc'ed values from run_argv */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|run_argv
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|run_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|run_argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|run_argc
operator|=
literal|0
expr_stmt|;
comment|/* process the varargs into run_prog */
ifndef|#
directive|ifndef
name|VPRINTF_MISSING
name|VA_START
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|run_prog
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|run_prog
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* put each word into run_argv, allocating it as we go */
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|run_prog
argument_list|,
literal|" \t"
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
name|run_add_arg
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|run_arg
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|run_add_arg
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VPRINTF_MISSING
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function
name|void
name|run_args
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|void  run_args
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|VPRINTF_MISSING
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
name|run_init_prog
argument_list|()
expr_stmt|;
comment|/* process the varargs into run_prog */
ifndef|#
directive|ifndef
name|VPRINTF_MISSING
name|VA_START
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|run_prog
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|run_prog
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* and add the (single) argument to the run_argv list */
name|run_add_arg
argument_list|(
name|run_prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_add_arg
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* allocate more argv entries if we've run out */
if|if
condition|(
name|run_argc
operator|>=
name|run_argc_allocated
condition|)
block|{
name|run_argc_allocated
operator|+=
literal|50
expr_stmt|;
name|run_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|run_argv
argument_list|,
name|run_argc_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
name|run_argv
index|[
name|run_argc
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|run_argv
index|[
name|run_argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* not post-incremented on purpose! */
block|}
end_function

begin_function
specifier|static
name|void
name|run_init_prog
parameter_list|()
block|{
comment|/* make sure that run_prog is allocated once */
if|if
condition|(
name|run_prog
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|run_prog
operator|=
name|xmalloc
argument_list|(
literal|10
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* 10K of args for _setup and _arg */
block|}
end_function

begin_function
name|int
name|run_exec
parameter_list|(
name|stin
parameter_list|,
name|stout
parameter_list|,
name|sterr
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|stin
decl_stmt|;
name|char
modifier|*
name|stout
decl_stmt|;
name|char
modifier|*
name|sterr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|shin
decl_stmt|,
name|shout
decl_stmt|,
name|sherr
decl_stmt|;
name|int
name|mode_out
decl_stmt|,
name|mode_err
decl_stmt|;
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rerrno
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|w
decl_stmt|;
ifdef|#
directive|ifdef
name|POSIX
name|sigset_t
name|sigset_mask
decl_stmt|,
name|sigset_omask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|,
name|iact
decl_stmt|,
name|qact
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
name|int
name|mask
decl_stmt|;
name|struct
name|sigvec
name|vec
decl_stmt|,
name|ivec
decl_stmt|,
name|qvec
decl_stmt|;
else|#
directive|else
name|SIGTYPE
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> system("
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noexec
operator|&&
operator|(
name|flags
operator|&
name|RUN_REALLY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make sure that we are null terminated, since we didn't calloc */
name|run_add_arg
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* setup default file descriptor numbers */
name|shin
operator|=
literal|0
expr_stmt|;
name|shout
operator|=
literal|1
expr_stmt|;
name|sherr
operator|=
literal|2
expr_stmt|;
comment|/* set the file modes for stdout and stderr */
name|mode_out
operator|=
name|mode_err
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
name|mode_out
operator||=
operator|(
operator|(
name|flags
operator|&
name|RUN_STDOUT_APPEND
operator|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
name|mode_err
operator||=
operator|(
operator|(
name|flags
operator|&
name|RUN_STDERR_APPEND
operator|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
if|if
condition|(
name|stin
operator|&&
operator|(
name|shin
operator|=
name|open
argument_list|(
name|stin
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading (prog %s)"
argument_list|,
name|stin
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out0
goto|;
block|}
if|if
condition|(
name|stout
operator|&&
operator|(
name|shout
operator|=
name|open
argument_list|(
name|stout
argument_list|,
name|mode_out
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing (prog %s)"
argument_list|,
name|stout
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|sterr
operator|&&
operator|(
name|flags
operator|&
name|RUN_COMBINED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sherr
operator|=
name|open
argument_list|(
name|sterr
argument_list|,
name|mode_err
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing (prog %s)"
argument_list|,
name|sterr
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
comment|/* The output files, if any, are now created.  Do the fork and dups */
ifdef|#
directive|ifdef
name|VFORK_MISSING
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shin
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|shin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|shin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shout
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|shout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|shout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RUN_COMBINED
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sherr
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sherr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sherr
argument_list|)
expr_stmt|;
block|}
comment|/* dup'ing is done.  try to run it now */
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|run_argv
index|[
literal|0
index|]
argument_list|,
name|run_argv
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* the parent.  Ignore some signals for now */
ifdef|#
directive|ifdef
name|POSIX
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|iact
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|qact
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|sigset_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sigset_mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sigset_mask
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset_mask
argument_list|,
operator|&
name|sigset_omask
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|vec
argument_list|,
sizeof|sizeof
argument_list|(
name|vec
argument_list|)
argument_list|)
expr_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|ivec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|qvec
argument_list|)
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* wait for our process to die and munge return status */
ifdef|#
directive|ifdef
name|POSIX
while|while
condition|(
operator|(
name|w
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|w
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|rerrno
operator|=
name|errno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGPIPE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"broken pipe"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|status
operator|=
literal|1
expr_stmt|;
comment|/* restore the signals */
ifdef|#
directive|ifdef
name|POSIX
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|iact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset_omask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|ivec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qvec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* cleanup the open file descriptors */
name|out
label|:
if|if
condition|(
name|sterr
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sherr
argument_list|)
expr_stmt|;
name|out2
label|:
if|if
condition|(
name|stout
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|shout
argument_list|)
expr_stmt|;
name|out1
label|:
if|if
condition|(
name|stin
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|shin
argument_list|)
expr_stmt|;
name|out0
label|:
if|if
condition|(
name|rerrno
condition|)
name|errno
operator|=
name|rerrno
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|run_print
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_argc
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|run_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|run_argc
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|FILE
modifier|*
name|Popen
parameter_list|(
name|cmd
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> Popen(%s,%s)\n"
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|popen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|time_t
name|get_date
parameter_list|(
name|date
parameter_list|,
name|now
parameter_list|)
name|char
modifier|*
name|date
decl_stmt|;
name|struct
name|timeb
modifier|*
name|now
decl_stmt|;
block|{
name|time_t
name|foo
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|foo
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

