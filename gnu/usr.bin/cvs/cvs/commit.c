begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * Commit Files  *   * "commit" commits the present version to the RCS repository, AFTER  * having done a test on conflicts.  *  * The call is: cvs commit [options] files...  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$CVSid: @(#)commit.c 1.101 94/10/07 $"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|USE
argument_list|(
name|rcsid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Dtype
name|check_direntproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_fileproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|update_dir
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|,
name|List
operator|*
name|srcfiles
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|int
name|err
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkaddfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|options
operator|,
name|List
operator|*
name|srcfiles
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|commit_direntproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_dirleaveproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_fileproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|update_dir
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|,
name|List
operator|*
name|srcfiles
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finaladd
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|revision
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|options
operator|,
name|char
operator|*
name|update_dir
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findmaxrev
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fsortcmp
name|PROTO
argument_list|(
operator|(
specifier|const
name|Node
operator|*
name|p
operator|,
specifier|const
name|Node
operator|*
name|q
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lock_RCS
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|user
operator|,
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|rev
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lock_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lockrcsfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|rev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|precommit_list_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|precommit_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remove_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|message
operator|,
name|List
operator|*
name|entries
operator|,
name|List
operator|*
name|srcfiles
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_rcs_modes
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixaddfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixbranch
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|branch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unlockrcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ci_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|masterlist_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|locate_rcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|commit_info
block|{
name|Ctype
name|status
decl_stmt|;
comment|/* as returned from Classify_File() */
name|char
modifier|*
name|rev
decl_stmt|;
comment|/* a numeric rev, if we know it */
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* any sticky tag, or -r option */
name|char
modifier|*
name|options
decl_stmt|;
comment|/* Any sticky -k option */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|master_lists
block|{
name|List
modifier|*
name|ulist
decl_stmt|;
comment|/* list for Update_Logfile */
name|List
modifier|*
name|cilist
decl_stmt|;
comment|/* list with commit_info structs */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|force_ci
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|write_dirtag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|mulist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|locklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|commit_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-nRlf] [-m msg | -F logfile] [-r rev] files...\n"
block|,
literal|"\t-n\tDo not run the module program (if any).\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-l\tLocal directory only (not recursive).\n"
block|,
literal|"\t-f\tForce the file to be committed; disables recursion.\n"
block|,
literal|"\t-F file\tRead the log message from file.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
literal|"\t-r rev\tCommit to this branch or trunk revision.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|commit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVS_BADROOT
comment|/*      * For log purposes, do not allow "root" to commit files.  If you look      * like root, but are really logged in as a non-root user, it's OK.      */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|getcaller
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"you are unknown to this system"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot commit files as 'root'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CVS_BADROOT */
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"nlRm:fF:r:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|message
condition|)
block|{
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|=
name|NULL
expr_stmt|;
block|}
name|message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tag
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_ci
operator|=
literal|1
expr_stmt|;
name|local
operator|=
literal|1
expr_stmt|;
comment|/* also disable recursion */
break|break;
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|logfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* numeric specified revision means we ignore sticky tags... */
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
name|aflag
operator|=
literal|1
expr_stmt|;
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* some checks related to the "-F logfile" option */
if|if
condition|(
name|logfile
condition|)
block|{
name|int
name|n
decl_stmt|,
name|logfd
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|message
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot specify both a message and a log file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|logfd
operator|=
name|open
argument_list|(
name|logfile
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open log file %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|logfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot find size of log file %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
name|message
operator|=
name|xmalloc
argument_list|(
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|logfd
argument_list|,
name|message
argument_list|,
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read log message from %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|logfd
argument_list|)
expr_stmt|;
name|message
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
comment|/* 	 * Do this now; don't ask for a log message if we can't talk to the 	 * server.  But if there is a syntax error in the options, give 	 * an error message without connecting. 	 */
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
comment|/* 	 * We do this once, not once for each directory as in normal CVS. 	 * The protocol is designed this way.  This is a feature. 	 * 	 * We could provide the lists of changed, modified, etc. files, 	 * however.  Our failure to do so is just laziness, not design. 	 */
if|if
condition|(
name|use_editor
condition|)
name|do_editor
argument_list|(
literal|"."
argument_list|,
operator|&
name|message
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* We always send some sort of message, even if empty.  */
name|option_with_arg
argument_list|(
literal|"-m"
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_ci
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|run_module_prog
condition|)
name|send_arg
argument_list|(
literal|"-n"
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|to_server
argument_list|,
literal|"ci\n"
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing to server"
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* XXX - this is not the perfect check for this */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|write_dirtag
operator|=
name|tag
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
comment|/*      * Run the recursion processor to find all the dirs to lock and lock all      * the dirs      */
name|locklist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
operator|(
name|FILEPROC
operator|)
name|NULL
argument_list|,
name|lock_filesdoneproc
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sortlist
argument_list|(
name|locklist
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Writer_Lock
argument_list|(
name|locklist
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"lock failed - giving up"
argument_list|)
expr_stmt|;
comment|/*      * Set up the master update list      */
name|mulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * Run the recursion processor to verify the files are all up-to-date      */
name|err
operator|=
name|start_recursion
argument_list|(
name|check_fileproc
argument_list|,
name|check_filesdoneproc
argument_list|,
name|check_direntproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct above errors first!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Run the recursion processor to commit the files      */
if|if
condition|(
name|noexec
operator|==
literal|0
condition|)
name|err
operator|=
name|start_recursion
argument_list|(
name|commit_fileproc
argument_list|,
name|commit_filesdoneproc
argument_list|,
name|commit_direntproc
argument_list|,
name|commit_dirleaveproc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Unlock all the dirs and clean up      */
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|mulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|locklist
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two lock list nodes (for sort)  */
end_comment

begin_function
specifier|static
name|int
name|fsortcmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
specifier|const
name|Node
modifier|*
name|p
decl_stmt|;
specifier|const
name|Node
modifier|*
name|q
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a list of repositories to lock  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|lock_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|LOCK
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* FIXME-KRP: this error condition should not simply be passed by. */
if|if
condition|(
name|p
operator|->
name|key
operator|==
name|NULL
operator|||
name|addnode
argument_list|(
name|locklist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a file is ok to commit and make sure all files are  * up-to-date  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|int
name|save_noexec
decl_stmt|,
name|save_quiet
decl_stmt|,
name|save_really_quiet
decl_stmt|;
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|save_quiet
operator|=
name|quiet
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|noexec
operator|=
name|quiet
operator|=
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* handle specified numeric revision specially */
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
comment|/* If the tag is for the trunk, make sure we're at the head */
if|if
condition|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|<
literal|2
condition|)
block|{
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|,
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_MODIFIED
operator|||
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|Ctype
name|xstatus
decl_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|xstatus
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|,
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xstatus
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|xstatus
operator|==
name|T_CONFLICT
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
else|else
name|status
operator|=
name|xstatus
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|xtag
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* 	     * The revision is off the main trunk; make sure we're 	     * up-to-date with the head of the specified branch. 	     */
name|xtag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|xtag
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|,
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|T_REMOVE_ENTRY
operator|||
name|status
operator|==
name|T_CONFLICT
operator|)
operator|&&
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* pluck one more dot off the revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|,
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
block|}
comment|/* now, muck with vers to make the tag correct */
name|free
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|vers
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|,
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
name|quiet
operator|=
name|save_quiet
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
comment|/*      * If the force-commit option is enabled, and the file in question      * appears to be up-to-date, just make it look modified so that      * it will be committed.      */
if|if
condition|(
name|force_ci
operator|&&
name|status
operator|==
name|T_UPTODATE
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_CHECKOUT
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
endif|#
directive|endif
case|case
name|T_NEEDS_MERGE
case|:
case|case
name|T_CONFLICT
case|:
case|case
name|T_REMOVE_ENTRY
case|:
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Up-to-date check failed for `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Up-to-date check failed for `%s/%s'"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MODIFIED
case|:
case|case
name|T_ADDED
case|:
case|case
name|T_REMOVED
case|:
comment|/* 	     * some quick sanity checks; if no numeric -r option specified: 	     *	- can't have a sticky date 	     *	- can't have a sticky tag that is not a branch 	     * Also, 	     *	- if status is T_REMOVED, can't have a numeric tag 	     *	- if status is T_ADDED, rcs file must not exist 	     *	- if status is T_ADDED, can't have a non-trunk numeric rev 	     *	- if status is T_MODIFIED and a Conflict marker exists, don't 	     *    allow the commit if timestamp is identical or if we find 	     *    an RCS_MERGE_PAT in the file. 	     */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|date
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot commit with sticky date for file `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot commit with sticky date for file `%s/%s'"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|vers
operator|->
name|tag
operator|&&
operator|!
name|RCS_isbranch
argument_list|(
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|srcfiles
argument_list|)
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sticky tag `%s' for file `%s' is not a branch"
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sticky tag `%s' for file `%s/%s' is not a branch"
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
operator|!
name|force_ci
operator|&&
name|vers
operator|->
name|ts_conflict
condition|)
block|{
name|char
modifier|*
name|filestamp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/* 		 * We found a "conflict" marker. 		 * 		 * If the timestamp on the file is the same as the 		 * timestamp stored in the Entries file, we block the commit. 		 */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|retcode
operator|=
name|vers
operator|->
name|ts_conflict
index|[
literal|0
index|]
operator|!=
literal|'='
expr_stmt|;
else|else
block|{
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s' had a conflict and has not been modified"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s/%s' had a conflict and has not been modified"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * If the timestamps differ, look for Conflict indicators 		 * in the file to see if we should block the commit anyway 		 */
name|run_setup
argument_list|(
literal|"%s"
argument_list|,
name|GREP
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|RCS_MERGE_PAT
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|DEVNULL
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_REALLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining conflict in `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining conflict in `%s/%s'"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s' still contains conflict indicators"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s/%s' still contains conflict indicators"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_REMOVED
operator|&&
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot remove file `%s' which has a numeric sticky tag of `%s'"
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot remove file `%s/%s' which has a numeric sticky tag of `%s'"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
comment|/* Don't look in the attic; if it exists there we will 		   move it back out in checkaddfile.  */
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
else|#
directive|else
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' when RCS file `%s' already exists"
argument_list|,
name|file
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s/%s' when RCS file `%s' already exists"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
operator|&&
name|numdots
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' with revision `%s'; must be on trunk"
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s/%s' with revision `%s'; must be on trunk"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* done with consistency checks; now, to get on with the commit */
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xdir
operator|=
literal|"."
expr_stmt|;
else|else
name|xdir
operator|=
name|update_dir
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|xdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
block|}
else|else
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|cilist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|xdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|master_lists
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ulist
operator|=
name|ulist
expr_stmt|;
name|ml
operator|->
name|cilist
operator|=
name|cilist
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ml
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|masterlist_delproc
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|mulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* first do ulist, then cilist */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|status
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|ci_delproc
expr_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_info
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|tag
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
name|ci
operator|->
name|rev
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|file
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|ci
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ci
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|options
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ci
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|cilist
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UNKNOWN
case|:
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s/%s'"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_UPTODATE
case|:
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS internal error: unknown status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print warm fuzzies while examining the dirs  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|check_direntproc
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Examining %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walklist proc to run pre-commit checks  */
end_comment

begin_function
specifier|static
name|int
name|precommit_list_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_ADDED
operator|||
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_MODIFIED
operator|||
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_REMOVED
condition|)
block|{
name|run_arg
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback proc for pre-commit checking  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ulist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|precommit_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
comment|/* see if the filter is there, only if it's a full path */
if|if
condition|(
name|isabsolute
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|s
operator|=
name|xstrdup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot find pre-commit filter `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* so it fails! */
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|filter
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|ulist
argument_list|,
name|precommit_list_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the pre-commit checks for the dir  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the checks if there's nothing to do */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* run any pre-commit checks */
if|if
condition|(
operator|(
name|n
operator|=
name|Parse_Info
argument_list|(
name|CVSROOTADM_COMMITINFO
argument_list|,
name|repos
argument_list|,
name|precommit_proc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pre-commit check failed"
argument_list|)
expr_stmt|;
name|err
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the work of committing a file  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sbranch
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_fileproc
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/*      * if p is null, there were file type command line args which were      * all up-to-date so nothing really needs to be done      */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
comment|/*      * At this point, we should have the commit message unless we were called      * with files as args from the command line.  In that latter case, we      * need to get the commit message ourselves      */
if|if
condition|(
name|use_editor
operator|&&
operator|!
name|got_message
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
name|do_editor
argument_list|(
name|update_dir
argument_list|,
operator|&
name|message
argument_list|,
name|repository
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|cilist
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
if|if
condition|(
name|lockrcsfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|ci
operator|->
name|rev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
if|if
condition|(
name|checkaddfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|srcfiles
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fixaddfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
comment|/* adding files with a tag, now means adding them on a branch. 	   Since the branch test was done in check_fileproc for 	   modified files, we need to stub it in again here. */
if|if
condition|(
name|ci
operator|->
name|tag
condition|)
block|{
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|file
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
name|err
operator|=
name|Checkin
argument_list|(
literal|'A'
argument_list|,
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|message
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
name|ci
operator|->
name|status
operator|=
name|T_UPTODATE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEATH_SUPPORT */
block|}
comment|/*      * Add the file for real      */
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
modifier|*
name|xrev
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
operator|==
name|NULL
condition|)
block|{
comment|/* find the max major rev number in this directory */
name|maxrev
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|entries
argument_list|,
name|findmaxrev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxrev
operator|==
literal|0
condition|)
name|maxrev
operator|=
literal|1
expr_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%d"
argument_list|,
name|maxrev
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - an added file with symbolic -r should add tag as well */
name|err
operator|=
name|finaladd
argument_list|(
name|file
argument_list|,
name|ci
operator|->
name|rev
condition|?
name|ci
operator|->
name|rev
else|:
name|xrev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrev
condition|)
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|=
name|Checkin
argument_list|(
literal|'M'
argument_list|,
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|message
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_REMOVED
condition|)
block|{
name|err
operator|=
name|remove_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|message
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
name|server_updated
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
comment|/* Doesn't matter, it won't get checked.  */
name|SERVER_UPDATED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|out
label|:
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* on failure, remove the file from ulist */
name|p
operator|=
name|findnode
argument_list|(
name|ulist
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log the commit and clean up the update list  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
modifier|*
name|xtag
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|got_message
operator|=
literal|0
expr_stmt|;
comment|/* see if we need to specify a per-directory or -r option tag */
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
name|ParseTag
argument_list|(
operator|&
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|message
argument_list|,
name|tag
condition|?
name|tag
else|:
name|xtag
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtag
condition|)
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|run_module_prog
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|>
literal|0
condition|)
block|{
comment|/* Remove any trailing newline.  */
if|if
condition|(
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|line
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s: Executing '"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: error reading %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot open %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the log message for a dir and print a warm fuzzy  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|commit_direntproc
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|char
modifier|*
name|real_repos
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the files as an optimization */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|R_SKIP_FILES
operator|)
return|;
comment|/* print the warm fuzzy */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Committing %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* get commit message */
if|if
condition|(
name|use_editor
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
name|real_repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|do_editor
argument_list|(
name|update_dir
argument_list|,
operator|&
name|message
argument_list|,
name|real_repos
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_repos
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the post-commit proc if necessary  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_dirleaveproc
parameter_list|(
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
comment|/* update the per-directory tag info */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|write_dirtag
operator|!=
name|NULL
condition|)
block|{
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|write_dirtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_set_sticky
argument_list|(
name|update_dir
argument_list|,
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
argument_list|,
name|write_dirtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find the maximum major rev number in an entries file  */
end_comment

begin_function
specifier|static
name|int
name|findmaxrev
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|thisrev
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|entdata
operator|->
name|version
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|thisrev
operator|=
name|atoi
argument_list|(
name|entdata
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|thisrev
operator|>
name|maxrev
condition|)
name|maxrev
operator|=
name|thisrev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually remove a file by moving it to the attic  * XXX - if removing a ,v file that is a relative symbolic link to  * another ,v file, we probably should add a ".." component to the  * link to keep it relative after we move it into the attic.  */
end_comment

begin_function
specifier|static
name|int
name|remove_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|message
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|mode_t
name|omask
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
name|int
name|branch
decl_stmt|;
name|char
modifier|*
name|lockflag
decl_stmt|;
name|char
modifier|*
name|corev
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|prev_rev
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|corev
operator|=
name|NULL
expr_stmt|;
name|rev
operator|=
name|NULL
expr_stmt|;
name|prev_rev
operator|=
name|NULL
expr_stmt|;
name|lockflag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* DEATH_SUPPORT */
name|retcode
operator|=
literal|0
expr_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
name|branch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
operator|!
operator|(
name|branch
operator|=
name|RCS_isbranch
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
name|srcfiles
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|tag
condition|)
endif|#
directive|endif
block|{
comment|/* a symbolic tag is specified; just remove the tag from the file */
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_deltag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag `%s' from `%s'"
argument_list|,
name|tag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|Scratch_Entry
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
comment|/* we are removing the file from either the head or a branch */
comment|/* commit a new, dead revision. */
comment|/* Print message indicating that file is going to be removed. */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Removing %s;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|rev
operator|=
name|NULL
expr_stmt|;
name|lockflag
operator|=
literal|"-l"
expr_stmt|;
if|if
condition|(
name|branch
condition|)
block|{
name|char
modifier|*
name|branchname
decl_stmt|;
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find branch \"%s\"."
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|srcfiles
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"boy, I'm confused."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rcsfile
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|branchname
operator|=
name|RCS_getbranch
argument_list|(
name|rcsfile
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchname
operator|==
name|NULL
condition|)
block|{
comment|/* no revision exists on this branch.  use the previous 	       revision but do not lock. */
name|corev
operator|=
name|RCS_gettag
argument_list|(
name|rcsfile
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev_rev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|lockflag
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|corev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|prev_rev
operator|=
name|xstrdup
argument_list|(
name|branchname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branchname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Not a branch */
block|{
comment|/* Get current head revision of file. */
name|p
operator|=
name|findnode
argument_list|(
name|srcfiles
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not find parsed rcsfile %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rcsfile
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|prev_rev
operator|=
name|RCS_head
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
block|}
comment|/* if removing without a tag or a branch, then make sure the default        branch is the trunk. */
if|if
condition|(
operator|!
name|tag
operator|&&
operator|!
name|branch
condition|)
block|{
if|if
condition|(
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot change branch to default for %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* If this is the server, there will be a file sitting in the 	   temp directory which is the kludgy way in which server.c 	   tells time_stamp that the file is no longer around.  Remove 	   it so we can create temp files with that name (ignore errors).  */
name|unlink_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* check something out.  Generally this is the head.  If we have a        particular rev, then name it.  except when creating a branch,        lock the rev we're checking out.  */
name|run_setup
argument_list|(
literal|"%s%s %s %s%s %s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CO
argument_list|,
name|lockflag
argument_list|,
name|rev
condition|?
literal|"-r"
else|:
literal|""
argument_list|,
name|rev
condition|?
name|corev
else|:
literal|""
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|DEVNULL
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to check out `%s'"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|corev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|corev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEATH_STATE
name|run_setup
argument_list|(
literal|"%s%s -f -sdead %s%s"
argument_list|,
argument|Rcsbin
argument_list|,
argument|RCS_CI
argument_list|,
argument|rev ?
literal|"-r"
argument|:
literal|""
argument_list|,
else|#
directive|else
argument|run_setup (
literal|"%s%s -K %s%s"
argument|, Rcsbin, RCS_CI, rev ?
literal|"-r"
argument|:
literal|""
argument|,
endif|#
directive|endif
argument|rev ? rev :
literal|""
argument|);      run_args (
literal|"-m%s"
argument|, make_message_rcslegal (message));     run_arg (rcs);     if ((retcode = run_exec (RUN_TTY, RUN_TTY, DEVNULL, RUN_NORMAL)) 	!=
literal|0
argument|) { 	if (!quiet) 	    error (
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"failed to commit dead revision for `%s'"
argument|, rcs); 	return (
literal|1
argument|);     }      if (rev != NULL) 	free (rev);      if (!branch)
else|#
directive|else
comment|/* No DEATH_SUPPORT */
argument|else
endif|#
directive|endif
comment|/* No DEATH_SUPPORT */
argument|{
comment|/* this was the head; really move it into the Attic */
argument|tmp = xmalloc(strlen(repository) +  		      sizeof(
literal|'/'
argument|) + 		      sizeof(CVSATTIC) + 		      sizeof(
literal|'/'
argument|) + 		      strlen(file) + 		      sizeof(RCSEXT) +
literal|1
argument|); 	(void) sprintf (tmp,
literal|"%s/%s"
argument|, repository, CVSATTIC); 	omask = umask (cvsumask); 	(void) CVS_MKDIR (tmp,
literal|0777
argument|); 	(void) umask (omask); 	(void) sprintf (tmp,
literal|"%s/%s/%s%s"
argument|, repository, CVSATTIC, file, RCSEXT);
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
argument|if (strcmp (rcs, tmp) !=
literal|0
argument|&& rename (rcs, tmp) == -
literal|1
argument|&& (isreadable (rcs) || !isreadable (tmp))) 	{ 	    free(tmp); 	    return (
literal|1
argument|); 	} 	free(tmp);     }
comment|/* Print message that file was removed. */
argument|(void) printf (
literal|"%s<--  %s\n"
argument|, rcs, file);     (void) printf (
literal|"new revision: delete; "
argument|);     (void) printf (
literal|"previous revision: %s\n"
argument|, prev_rev);     (void) printf (
literal|"done\n"
argument|);     free(prev_rev);      Scratch_Entry (entries, file);     return (
literal|0
argument|);
else|#
directive|else
comment|/* No DEATH_SUPPORT */
argument|if ((strcmp (rcs, tmp) ==
literal|0
argument||| rename (rcs, tmp) != -
literal|1
argument|) || 	    (!isreadable (rcs)&& isreadable (tmp)))  	{ 	    Scratch_Entry (entries, file);
comment|/* FIXME: should free tmp.  */
argument|return (
literal|0
argument|); 	}
comment|/* FIXME: should free tmp.  */
argument|}     return (
literal|1
argument|);
endif|#
directive|endif
comment|/* No DEATH_SUPPORT */
argument|}
comment|/*  * Do the actual checkin for added files  */
argument|static int finaladd (file, rev, tag, options, update_dir, repository, entries)     char *file;     char *rev;     char *tag;     char *options;     char *update_dir;     char *repository;     List *entries; {     int ret;     char tmp[PATH_MAX];     char rcs[PATH_MAX];      locate_rcs (file, repository, rcs);     ret = Checkin (
literal|'A'
argument|, file, update_dir, repository, rcs, rev, tag, options, 		   message, entries);     if (ret ==
literal|0
argument|)     { 	(void) sprintf (tmp,
literal|"%s/%s%s"
argument|, CVSADM, file, CVSEXT_LOG); 	(void) unlink_file (tmp);     }     else 	fixaddfile (file, repository);     return (ret); }
comment|/*  * Unlock an rcs file  */
argument|static void unlockrcs (file, repository)     char *file;     char *repository; {     char rcs[PATH_MAX];     int retcode =
literal|0
argument|;      locate_rcs (file, repository, rcs);      if ((retcode = RCS_unlock (rcs, NULL,
literal|0
argument|)) !=
literal|0
argument|) 	error (retcode == -
literal|1
argument|?
literal|1
argument|:
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"could not unlock %s"
argument|, rcs); }
comment|/*  * remove a partially added file.  if we can parse it, leave it alone.  */
argument|static void fixaddfile (file, repository)     char *file;     char *repository; {     RCSNode *rcsfile;     char rcs[PATH_MAX];     int save_really_quiet;      locate_rcs (file, repository, rcs);     save_really_quiet = really_quiet;     really_quiet =
literal|1
argument|;     if ((rcsfile = RCS_parsercsfile (rcs)) == NULL) 	(void) unlink_file (rcs);     else 	freercsnode (&rcsfile);     really_quiet = save_really_quiet; }
comment|/*  * put the branch back on an rcs file  */
argument|static void fixbranch (file, repository, branch)     char *file;     char *repository;     char *branch; {     char rcs[PATH_MAX];     int retcode =
literal|0
argument|;      if (branch != NULL&& branch[
literal|0
argument|] !=
literal|'\0'
argument|)     { 	locate_rcs (file, repository, rcs); 	if ((retcode = RCS_setbranch (rcs, branch)) !=
literal|0
argument|) 	    error (retcode == -
literal|1
argument|?
literal|1
argument|:
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"cannot restore branch to %s for %s"
argument|, branch, rcs);     } }
comment|/*  * do the initial part of a file add for the named file.  if adding  * with a tag, put the file in the Attic and point the symbolic tag  * at the committed revision.  */
argument|static int checkaddfile (file, repository, tag, options, srcfiles)     char *file;     char *repository;     char *tag;     char *options;     List *srcfiles; {     char rcs[PATH_MAX];     char fname[PATH_MAX];     mode_t omask;     int retcode =
literal|0
argument|;
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
argument|int newfile =
literal|0
argument|;
endif|#
directive|endif
argument|if (tag)     { 	(void) sprintf(rcs,
literal|"%s/%s"
argument|, repository, CVSATTIC); 	omask = umask (cvsumask); 	if (CVS_MKDIR (rcs,
literal|0777
argument|) !=
literal|0
argument|&& errno != EEXIST) 	    error (
literal|1
argument|, errno,
literal|"cannot make directory `%s'"
argument|, rcs);; 	(void) umask (omask); 	(void) sprintf (rcs,
literal|"%s/%s/%s%s"
argument|, repository, CVSATTIC, file, RCSEXT);     }     else 	locate_rcs (file, repository, rcs);
ifdef|#
directive|ifdef
name|DEATH_SUPPORT
argument|if (isreadable(rcs))     {
comment|/* file has existed in the past.  Prepare to resurrect. */
argument|char oldfile[PATH_MAX]; 	char *rev; 	Node *p; 	RCSNode *rcsfile;  	if (tag == NULL) 	{
comment|/* we are adding on the trunk, so move the file out of the 	       Attic. */
argument|strcpy (oldfile, rcs); 	    sprintf (rcs,
literal|"%s/%s%s"
argument|, repository, file, RCSEXT); 	     	    if (strcmp (oldfile, rcs) ==
literal|0
argument||| rename (oldfile, rcs) !=
literal|0
argument||| isreadable (oldfile) 		|| !isreadable (rcs)) 	    { 		error (
literal|0
argument|,
literal|0
argument|,
literal|"failed to move `%s' out of the attic."
argument|, 		       file); 		return (
literal|1
argument|); 	    } 	}  	p = findnode (srcfiles, file); 	if (p == NULL) 	{ 	    error (
literal|0
argument|,
literal|0
argument|,
literal|"could not find parsed rcsfile %s"
argument|, file); 	    return (
literal|1
argument|); 	}  	rcsfile = (RCSNode *) p->data; 	rev = RCS_getversion (rcsfile, tag, NULL,
literal|1
argument|,
literal|0
argument|);
comment|/* and lock it */
argument|if (lock_RCS (file, rcs, rev, repository)) { 	    error (
literal|0
argument|,
literal|0
argument|,
literal|"cannot lock `%s'."
argument|, rcs); 	    free (rev); 	    return (
literal|1
argument|); 	}  	free (rev);     } else {
comment|/* this is the first time we have ever seen this file; create 	   an rcs file.  */
argument|run_setup (
literal|"%s%s -i"
argument|, Rcsbin, RCS);  	(void) sprintf (fname,
literal|"%s/%s%s"
argument|, CVSADM, file, CVSEXT_LOG);
comment|/* If the file does not exist, no big deal.  In particular, the 	   server does not (yet at least) create CVSEXT_LOG files.  */
argument|if (isfile (fname)) 	    run_args (
literal|"-t%s/%s%s"
argument|, CVSADM, file, CVSEXT_LOG);
comment|/* Set RCS keyword expansion options.  */
argument|if (options&& options[
literal|0
argument|] ==
literal|'-'
argument|&& options[
literal|1
argument|] ==
literal|'k'
argument|) 	    run_arg (options); 	run_arg (rcs); 	if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) !=
literal|0
argument|) 	{ 	    error (retcode == -
literal|1
argument|?
literal|1
argument|:
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"could not create %s"
argument|, rcs); 	    return (
literal|1
argument|); 	} 	newfile =
literal|1
argument|;     }
comment|/* when adding a file for the first time, and using a tag, we need        to create a dead revision on the trunk.  */
argument|if (tag&& newfile)     { 	char tmp[PATH_MAX];
comment|/* move the new file out of the way. */
argument|(void) sprintf (fname,
literal|"%s/%s%s"
argument|, CVSADM, CVSPREFIX, file); 	rename_file (file, fname); 	copy_file (DEVNULL, file);
comment|/* commit a dead revision. */
argument|(void) sprintf (tmp,
literal|"-mfile %s was initially added on branch %s."
argument|, file, tag);
ifdef|#
directive|ifdef
name|DEATH_STATE
argument|run_setup (
literal|"%s%s -q -f -sdead"
argument|, Rcsbin, RCS_CI);
else|#
directive|else
argument|run_setup (
literal|"%s%s -q -K"
argument|, Rcsbin, RCS_CI);
endif|#
directive|endif
argument|run_arg (tmp); 	run_arg (rcs); 	if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) !=
literal|0
argument|) 	{ 	    error (retcode == -
literal|1
argument|?
literal|1
argument|:
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"could not create initial dead revision %s"
argument|, rcs); 	    return (
literal|1
argument|); 	}
comment|/* put the new file back where it was */
argument|rename_file (fname, file);
comment|/* and lock it once again. */
argument|if (lock_RCS (file, rcs, NULL, repository)) { 	    error (
literal|0
argument|,
literal|0
argument|,
literal|"cannot lock `%s'."
argument|, rcs); 	    return (
literal|1
argument|); 	}     }      if (tag != NULL)     {
comment|/* when adding with a tag, we need to stub a branch, if it 	   doesn't already exist.  */
argument|Node *p; 	RCSNode *rcsfile;  	rcsfile = RCS_parse (file, repository); 	if (rcsfile == NULL) 	{ 	    error (
literal|0
argument|,
literal|0
argument|,
literal|"could not read %s"
argument|, rcs); 	    return (
literal|1
argument|); 	} 	 	if (!RCS_nodeisbranch (tag, rcsfile)) {
comment|/* branch does not exist.  Stub it.  */
argument|char *head; 	    char *magicrev; 	     	    head = RCS_getversion (rcsfile, NULL, NULL,
literal|0
argument|,
literal|0
argument|); 	    magicrev = RCS_magicrev (rcsfile, head); 	    if ((retcode = RCS_settag(rcs, tag, magicrev)) !=
literal|0
argument|) 	    { 		error (retcode == -
literal|1
argument|?
literal|1
argument|:
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"could not stub branch %s for %s"
argument|, tag, rcs); 		return (
literal|1
argument|); 	    } 	     	    freercsnode (&rcsfile);
comment|/* reparse the file, then add it to our list. */
argument|rcsfile = RCS_parse (file, repository); 	    if (rcsfile == NULL) 	    { 		error (
literal|0
argument|,
literal|0
argument|,
literal|"could not reparse %s"
argument|, rcs); 		return (
literal|1
argument|); 	    }  	    free (head); 	    free (magicrev); 	} 	else 	{
comment|/* lock the branch. (stubbed branches need not be locked.)  */
argument|if (lock_RCS (file, rcs, NULL, repository)) { 		error (
literal|0
argument|,
literal|0
argument|,
literal|"cannot lock `%s'."
argument|, rcs); 		return (
literal|1
argument|); 	    } 	}
comment|/* add (replace) this rcs file to our list */
argument|p = findnode (srcfiles, file);  	if (p != NULL) 	  freercsnode((RCSNode **)&p->data);  	delnode(p);  	RCS_addnode (file, rcsfile, srcfiles);     }
else|#
directive|else
comment|/* No DEATH_SUPPORT */
argument|run_setup (
literal|"%s%s -i"
argument|, Rcsbin, RCS);     run_args (
literal|"-t%s/%s%s"
argument|, CVSADM, file, CVSEXT_LOG);
comment|/* Set RCS keyword expansion options.  */
argument|if (options&& options[
literal|0
argument|] ==
literal|'-'
argument|&& options[
literal|1
argument|] ==
literal|'k'
argument|) 	run_arg (options);     run_arg (rcs);     if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) !=
literal|0
argument|)     { 	error (retcode == -
literal|1
argument|?
literal|1
argument|:
literal|0
argument|, retcode == -
literal|1
argument|? errno :
literal|0
argument|,
literal|"could not create %s"
argument|, rcs); 	return (
literal|1
argument|);     }
endif|#
directive|endif
comment|/* No DEATH_SUPPORT */
argument|fix_rcs_modes (rcs, file);     return (
literal|0
argument|); }
comment|/*  * Lock the rcs file ``file''  */
argument|static int lockrcsfile (file, repository, rev)     char *file;     char *repository;     char *rev; {     char rcs[PATH_MAX];      locate_rcs (file, repository, rcs);     if (lock_RCS (file, rcs, rev, repository) !=
literal|0
argument|) 	return (
literal|1
argument|);     else 	return (
literal|0
argument|); }
comment|/*  * Attempt to place a lock on the RCS file; returns 0 if it could and 1 if it  * couldn't.  If the RCS file currently has a branch as the head, we must  * move the head back to the trunk before locking the file, and be sure to  * put the branch back as the head if there are any errors.  */
argument|static int lock_RCS (user, rcs, rev, repository)     char *user;     char *rcs;     char *rev;     char *repository; {     RCSNode *rcsfile;     char *branch = NULL;     int err =
literal|0
argument|;
comment|/*      * For a specified, numeric revision of the form "1" or "1.1", (or when      * no revision is specified ""), definitely move the branch to the trunk      * before locking the RCS file.      *       * The assumption is that if there is more than one revision on the trunk,      * the head points to the trunk, not a branch... and as such, it's not      * necessary to move the head in this case.      */
argument|if (rev == NULL || (rev&& isdigit (*rev)&& numdots (rev)<
literal|2
argument|))     { 	if ((rcsfile = RCS_parsercsfile (rcs)) == NULL) 	{
comment|/* invalid rcs file? */
argument|err =
literal|1
argument|; 	} 	else 	{
comment|/* rcsfile is valid */
argument|branch = xstrdup (rcsfile->branch); 	    freercsnode (&rcsfile); 	    if (branch != NULL) 	    { 		if (RCS_setbranch (rcs, NULL) !=
literal|0
argument|) 		{ 		    error (
literal|0
argument|,
literal|0
argument|,
literal|"cannot change branch to default for %s"
argument|, 			   rcs); 		    if (branch) 			free (branch); 		    return (
literal|1
argument|); 		} 	    } 	    err = RCS_lock(rcs, NULL,
literal|0
argument|); 	}     }     else     { 	(void) RCS_lock(rcs, rev,
literal|1
argument|);     }      if (err ==
literal|0
argument|)     { 	if (branch) 	{ 	    (void) strcpy (sbranch, branch); 	    free (branch); 	} 	else 	    sbranch[
literal|0
argument|] =
literal|'\0'
argument|; 	return (
literal|0
argument|);     }
comment|/* try to restore the branch if we can on error */
argument|if (branch != NULL) 	fixbranch (user, repository, branch);      if (branch) 	free (branch);     return (
literal|1
argument|); }
comment|/*  * Called when "add"ing files to the RCS respository, as it is necessary to  * preserve the file modes in the same fashion that RCS does.  This would be  * automatic except that we are placing the RCS ,v file very far away from  * the user file, and I can't seem to convince RCS of the location of the  * user file.  So we munge it here, after the ,v file has been successfully  * initialized with "rcs -i".  */
argument|static void fix_rcs_modes (rcs, user)     char *rcs;     char *user; {     struct stat sb;      if (stat (user,&sb) != -
literal|1
argument|) 	(void) chmod (rcs, (int) sb.st_mode& ~
literal|0222
argument|); }
comment|/*  * free an UPDATE node's data (really nothing to do)  */
argument|void update_delproc (p)     Node *p; {     p->data = (char *) NULL; }
comment|/*  * Free the commit_info structure in p.  */
argument|static void ci_delproc (p)     Node *p; {     struct commit_info *ci;      ci = (struct commit_info *) p->data;     if (ci->rev) 	free (ci->rev);     if (ci->tag) 	free (ci->tag);     if (ci->options) 	free (ci->options);     free (ci); }
comment|/*  * Free the commit_info structure in p.  */
argument|static void masterlist_delproc (p)     Node *p; {     struct master_lists *ml;      ml = (struct master_lists *) p->data;     dellist (&ml->ulist);     dellist (&ml->cilist);     free (ml); }
comment|/*  * Find an RCS file in the repository.  */
argument|static void locate_rcs (file, repository, rcs)     char *file;     char *repository;     char *rcs; {     (void) sprintf (rcs,
literal|"%s/%s%s"
argument|, repository, file, RCSEXT);     if (!isreadable (rcs))     { 	(void) sprintf (rcs,
literal|"%s/%s/%s%s"
argument|, repository, CVSATTIC, file, RCSEXT); 	if (!isreadable (rcs)) 	    (void) sprintf (rcs,
literal|"%s/%s%s"
argument|, repository, file, RCSEXT);     } }
end_function

end_unit

