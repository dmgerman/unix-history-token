begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * "update" updates the version in the present directory with respect to the RCS  * repository.  The present version must have been created by "checkout". The  * user can keep up-to-date by calling "update" whenever he feels like it.  *   * The present version can be committed by "commit", but this keeps the version  * in tact.  *   * Arguments following the options are taken to be file names to be updated,  * rather than updating the entire directory.  *   * Modified or non-existent RCS files are checked out and reported as U  *<user_file>  *   * Modified user files are reported as M<user_file>.  If both the RCS file and  * the user file have been modified, the user file is replaced by the result  * of rcsmerge, and a backup file is written for the user in .#file.version.  * If this throws up irreconcilable differences, the file is reported as C  *<user_file>, and as M<user_file> otherwise.  *   * Files added but not yet committed are reported as A<user_file>. Files  * removed but not yet committed are reported as R<user_file>.  *   * If the current directory contains subdirectories that hold concurrent  * versions, these are updated too.  If the -d option was specified, new  * directories added to the repository are automatically created and updated  * as well.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$CVSid: @(#)update.c 1.95 94/10/22 $"
decl_stmt|;
end_decl_stmt

begin_macro
name|USE
argument_list|(
argument|rcsid
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|checkout_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|,
name|List
operator|*
name|srcfiles
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isemptydir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|merge_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|,
name|Vers_TS
operator|*
name|vers
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scratch_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|update_dirent_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_dirleave_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_file_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|update_dir
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|,
name|List
operator|*
name|srcfiles
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_filesdone_proc
name|PROTO
argument_list|(
operator|(
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_letter
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|int
name|letter
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_files
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|ilist
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|join_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|List
operator|*
name|srcfiles
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev1
decl_stmt|,
modifier|*
name|date_rev1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev2
decl_stmt|,
modifier|*
name|date_rev2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_build_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_prune_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ignlist
init|=
operator|(
name|List
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_register_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|update_usage
index|[]
init|=
block|{
literal|"Usage:\n %s %s [-APQdflRpq] [-k kopt] [-r rev|-D date] [-j rev] [-I ign] [files...]\n"
block|,
literal|"\t-A\tReset any sticky tags/date/kopts.\n"
block|,
literal|"\t-P\tPrune empty directories.\n"
block|,
literal|"\t-Q\tReally quiet.\n"
block|,
literal|"\t-d\tBuild directories, like checkout does.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-p\tSend updates to standard output.\n"
block|,
literal|"\t-q\tSomewhat quiet.\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"\t-r rev\tUpdate using specified revision/tag.\n"
block|,
literal|"\t-D date\tSet date to update from.\n"
block|,
literal|"\t-j rev\tMerge in changes made between current revision and rev.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * update is the argv,argc based front end for arg parsing  */
end_comment

begin_function
name|int
name|update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
comment|/* recursive by default */
name|int
name|which
decl_stmt|;
comment|/* where to look for files and dirs */
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
comment|/* parse the args */
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ApPflRQqdk:r:D:j:I:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|update_build_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|update_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pipeout
operator|=
literal|1
expr_stmt|;
name|noexec
operator|=
literal|1
expr_stmt|;
comment|/* so no locks will be created */
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|join_rev2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only two -j options can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|join_rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|join_rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/*      * If we are updating the entire directory (for real) and building dirs      * as we go, we make sure there is no static entries file and write the      * tag file as appropriate      */
if|if
condition|(
name|argc
operator|<=
literal|0
operator|&&
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/* look for files/dirs locally and in the repository */
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
expr_stmt|;
comment|/* look in the attic too if a tag or date is specified */
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
condition|)
name|which
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* call the command line interface */
name|err
operator|=
name|do_update
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|local
argument_list|,
name|update_build_dirs
argument_list|,
name|aflag
argument_list|,
name|update_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* free the space Make_Date allocated if necessary */
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command line interface to update (used by checkout)  */
end_comment

begin_function
name|int
name|do_update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xoptions
parameter_list|,
name|xtag
parameter_list|,
name|xdate
parameter_list|,
name|xforce
parameter_list|,
name|local
parameter_list|,
name|xbuild
parameter_list|,
name|xaflag
parameter_list|,
name|xprune
parameter_list|,
name|xpipeout
parameter_list|,
name|which
parameter_list|,
name|xjoin_rev1
parameter_list|,
name|xjoin_rev2
parameter_list|,
name|preload_update_dir
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
name|xoptions
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|xdate
decl_stmt|;
name|int
name|xforce
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|xbuild
decl_stmt|;
name|int
name|xaflag
decl_stmt|;
name|int
name|xprune
decl_stmt|;
name|int
name|xpipeout
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|xjoin_rev1
decl_stmt|;
name|char
modifier|*
name|xjoin_rev2
decl_stmt|;
name|char
modifier|*
name|preload_update_dir
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* fill in the statics */
name|options
operator|=
name|xoptions
expr_stmt|;
name|tag
operator|=
name|xtag
expr_stmt|;
name|date
operator|=
name|xdate
expr_stmt|;
name|force_tag_match
operator|=
name|xforce
expr_stmt|;
name|update_build_dirs
operator|=
name|xbuild
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|update_prune_dirs
operator|=
name|xprune
expr_stmt|;
name|pipeout
operator|=
name|xpipeout
expr_stmt|;
comment|/* setup the join support */
name|join_rev1
operator|=
name|xjoin_rev1
expr_stmt|;
name|join_rev2
operator|=
name|xjoin_rev2
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|join_rev1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev1
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev1
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|join_rev2
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev2
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev2
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* call the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|update_file_proc
argument_list|,
name|update_filesdone_proc
argument_list|,
name|update_dirent_proc
argument_list|,
name|update_dirleave_proc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|preload_update_dir
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* see if we need to sleep before returning */
if|if
condition|(
name|last_register_time
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|last_register_time
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* to avoid time-stamp races */
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the callback proc for update.  It is called for each file in each  * directory by the recursion code.  The current directory is the local  * instantiation.  file is the file name we are to operate on. update_dir is  * set to the path relative to where we started (for pretty printing).  * repository is the repository. entries and srcfiles are the pre-parsed  * entries and source control files.  *   * This routine decides what needs to be done for each file and does the  * appropriate magic for checkout  */
end_comment

begin_function
specifier|static
name|int
name|update_file_proc
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|Ctype
name|status
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|options
argument_list|,
name|force_tag_match
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|,
name|update_dir
argument_list|,
name|pipeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipeout
condition|)
block|{
comment|/* 	 * We just return success without doing anything if any of the really 	 * funky cases occur 	 *  	 * If there is still a valid RCS file, do a regular checkout type 	 * operation 	 */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
name|retval
operator|=
name|checkout_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'C'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
name|retval
operator|=
name|merge_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_conflict
condition|)
block|{
name|char
modifier|*
name|filestamp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/* 		     * If the timestamp has changed and no conflict indicators 		     * are found, it isn't a 'C' any more. 		     */
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
comment|/* 			 * If the timestamps differ, look for Conflict 			 * indicators to see if 'C' anyway. 			 */
name|run_setup
argument_list|(
literal|"%s -s"
argument_list|,
name|GREP
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|RCS_MERGE_PAT
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining conflict in `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining conflict in `%s/%s'"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|retcode
condition|)
block|{
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'C'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Reregister to clear conflict flag. */
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|retval
operator|=
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'M'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
name|retval
operator|=
name|checkout_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'A'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
name|retval
operator|=
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'R'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
name|retval
operator|=
name|scratch_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* only try to join if things have gone well thus far */
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|join_rev1
condition|)
name|join_file
argument_list|(
name|file
argument_list|,
name|srcfiles
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|,
name|entries
argument_list|)
expr_stmt|;
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|ignlist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_filesdone_proc () is used  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_filesdone_proc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|ignore_files
argument_list|(
name|ignlist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up CVS admin dirs if we are export */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s -fr"
argument_list|,
name|RM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CVSADM_ROOT
else|else
block|{
comment|/* If there is no CVS/Root file, add one */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM_ROOT
argument_list|)
condition|)
name|Create_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CVSADM_ROOT */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirent_proc () is called back by the recursion processor before a  * sub-directory is processed for update.  In this case, update_dirent proc  * will probably create the directory unless -d isn't specified and this is a  * new directory.  A return code of 0 indicates the directory should be  * processed by the recursion code.  A return of non-zero indicates the  * recursion code should skip this directory.  */
end_comment

begin_function
specifier|static
name|Dtype
name|update_dirent_proc
parameter_list|(
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
name|ignore_directory
argument_list|(
name|update_dir
argument_list|)
condition|)
block|{
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Ignoring %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
name|R_SKIP_ALL
return|;
block|}
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* if we aren't building dirs, blow it off */
if|if
condition|(
operator|!
name|update_build_dirs
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
if|if
condition|(
name|noexec
condition|)
block|{
comment|/* ignore the missing dir if -n is specified */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"New directory `%s' -- ignored"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
block|}
else|else
block|{
comment|/* otherwise, create the dir and appropriate adm files */
name|make_directory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|dir
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If we are building dirs and not going to stdout, we make sure there is      * no static entries file and write the tag file as appropriate      */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
name|WriteTag
argument_list|(
name|dir
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
comment|/* initialize the ignore list for this directory */
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Updating %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirleave_proc () is called back by the recursion code upon leaving  * a directory.  It will prune empty directories if needed and will execute  * any appropriate update programs.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_dirleave_proc
parameter_list|(
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* run the update_prog if there is one */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|pipeout
operator|&&
operator|!
name|noexec
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|line
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s: Executing '"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up CVS admin dirs if we are export */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s -fr"
argument_list|,
name|RM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CVSADM_ROOT
else|else
block|{
comment|/* If there is no CVS/Root file, add one */
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|CVSADM_ROOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|isfile
argument_list|(
name|CVSADM_ROOT
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad permissions %s/%s deleteing it"
argument_list|,
name|update_dir
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ROOT
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"delete failed for %s/%s"
argument_list|,
name|update_dir
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
block|}
name|Create_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|root
init|=
name|Name_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
name|Create_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* all is well, release the storage */
block|}
block|}
endif|#
directive|endif
comment|/* CVSADM_ROOT */
comment|/* Prune empty dirs on the way out - if necessary */
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prune_dirs
operator|&&
name|isemptydir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s -fr"
argument_list|,
name|RM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the argument directory is completely empty, other than the  * existence of the CVS directory entry.  Zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|isemptydir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot open directory %s for empty check"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|OCVSADM
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * scratch the Entries file entry associated with a file  */
end_comment

begin_function
specifier|static
name|int
name|scratch_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|history_write
argument_list|(
literal|'W'
argument_list|,
name|update_dir
argument_list|,
literal|""
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check out a file - essentially returns the result of the fork on "co".  */
end_comment

begin_function
specifier|static
name|int
name|checkout_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|,
name|vers_ts
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|set_time
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* don't screw with backup files if we're going to stdout */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
name|rename_file
argument_list|(
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
literal|"%s%s -q -r%s %s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CO
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|)
expr_stmt|;
comment|/*      * if we are checking out to stdout, print a nice message to stderr, and      * add the -p flag to the command      */
if|if
condition|(
name|pipeout
condition|)
block|{
name|run_arg
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"===================================================================\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking out %s/%s\n"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking out %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RCS:  %s\n"
argument_list|,
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"VERS: %s\n"
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***************\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* tack on the rcs and maybe the user file */
name|run_arg
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipeout
condition|)
name|run_arg
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|pipeout
condition|?
operator|(
name|RUN_NORMAL
operator||
name|RUN_REALLY
operator|)
else|:
name|RUN_NORMAL
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers_ts
decl_stmt|;
if|if
condition|(
name|cvswrite
operator|==
name|TRUE
condition|)
name|xchmod
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set the time from the RCS file iff it was unknown before */
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|vers_ts
operator|->
name|ts_rcs
argument_list|,
literal|"Initial"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_time
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|set_time
operator|=
literal|0
expr_stmt|;
name|xvers_ts
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|file
argument_list|,
name|force_tag_match
argument_list|,
name|set_time
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xvers_ts
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|xvers_ts
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|xvers_ts
operator|->
name|ts_user
argument_list|,
name|xvers_ts
operator|->
name|options
argument_list|,
name|xvers_ts
operator|->
name|tag
argument_list|,
name|xvers_ts
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear conflict flag on fresh checkout */
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_ts
operator|->
name|vn_rcs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_rcs
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
comment|/* If this is really Update and not Checkout, recode history */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
name|history_write
argument_list|(
literal|'U'
argument_list|,
name|update_dir
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers_ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"U %s/%s\n"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"U %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
comment|/* save errno value over the rename */
if|if
condition|(
operator|!
name|pipeout
operator|&&
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not check out %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
name|retcode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pipeout
condition|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Several of the types we process only print a bit of information consisting  * of a single letter and the name.  */
end_comment

begin_function
specifier|static
name|int
name|write_letter
parameter_list|(
name|file
parameter_list|,
name|letter
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|letter
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s/%s\n"
argument_list|,
name|letter
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s\n"
argument_list|,
name|letter
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be merged  */
end_comment

begin_function
specifier|static
name|int
name|merge_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|vers
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
name|user
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|user
argument_list|,
literal|"%s/%s"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX - Do merge by hand instead of using rcsmerge, due to -k handling */
name|run_setup
argument_list|(
literal|"%s%s %s -r%s -r%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_RCSMERGE
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|&&
name|status
operator|!=
literal|1
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|user
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|vers
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|status
condition|)
name|cp
operator|=
name|time_stamp
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|vers
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xcmp
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s already contains the differences between %s and %s\n"
argument_list|,
name|user
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* possibly run GREP to see if there appear to be conflicts in the file */
name|run_setup
argument_list|(
literal|"%s -s"
argument_list|,
name|GREP
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|RCS_MERGE_PAT
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
operator|||
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"conflicts found in %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"C %s\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'C'
argument_list|,
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining update of %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"M %s\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be joined  * (-j option)  */
end_comment

begin_function
specifier|static
name|void
name|join_file
parameter_list|(
name|file
parameter_list|,
name|srcfiles
parameter_list|,
name|vers
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|char
name|user
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
name|char
modifier|*
name|jrev1
decl_stmt|;
name|char
modifier|*
name|jrev2
decl_stmt|;
name|char
modifier|*
name|jdate1
decl_stmt|;
name|char
modifier|*
name|jdate2
decl_stmt|;
name|jrev1
operator|=
name|join_rev1
expr_stmt|;
name|jrev2
operator|=
name|join_rev2
expr_stmt|;
name|jdate1
operator|=
name|date_rev1
expr_stmt|;
name|jdate2
operator|=
name|date_rev2
expr_stmt|;
comment|/* determine if we need to do anything at all */
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* in all cases, use two revs. */
comment|/* if only one rev is specified, it becomes the second rev */
if|if
condition|(
name|jrev2
operator|==
name|NULL
condition|)
block|{
name|jrev2
operator|=
name|jrev1
expr_stmt|;
name|jrev1
operator|=
name|NULL
expr_stmt|;
name|jdate2
operator|=
name|jdate1
expr_stmt|;
name|jdate1
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* convert the second rev spec, walking branches and dates. */
name|rev2
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision %s as of %s in file %s"
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision %s in file %s"
argument_list|,
name|jrev2
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* skip joining identical revs */
if|if
condition|(
name|strcmp
argument_list|(
name|rev2
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|==
literal|0
condition|)
comment|/* no merge necessary */
block|{
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|jrev1
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|tst
decl_stmt|;
comment|/* if the first rev is missing, then it is implied to be the 	   greatest common ancestor of both the join rev, and the 	   checked out rev. */
name|tst
operator|=
name|vers
operator|->
name|vn_user
expr_stmt|;
if|if
condition|(
operator|*
name|tst
operator|==
literal|'!'
condition|)
block|{
comment|/* file was dead.  merge anyway and pretend it's been 	       added. */
operator|++
name|tst
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
literal|"0"
argument_list|,
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|rev1
operator|=
name|gca
argument_list|(
name|tst
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|==
name|NULL
condition|)
block|{
comment|/* this should not be possible */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad gca"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|tst
operator|=
name|RCS_gettag
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tst
operator|==
name|NULL
condition|)
block|{
comment|/* this should not be possible. */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find gca"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|tst
argument_list|)
expr_stmt|;
comment|/* these two cases are noops */
if|if
condition|(
name|strcmp
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* otherwise, convert the first rev spec, walking branches and 	   dates.  */
name|rev1
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|jrev1
argument_list|,
name|jdate1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|&&
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|jdate1
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision %s as of %s in file %s"
argument_list|,
name|jrev1
argument_list|,
name|jdate1
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision %s in file %s"
argument_list|,
name|jrev1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* do the join */
if|#
directive|if
literal|0
block|dome {
comment|/* special handling when two revisions are specified */
block|if (join_rev1&& join_rev2) 	{ 	    rev = RCS_getversion (vers->srcfile, join_rev2, date_rev2, 1); 	    if (rev == NULL) 	    { 		if (!quiet&& date_rev2 == NULL) 		    error (0, 0, 			   "cannot find revision %s in file %s", join_rev2, file); 		return; 	    } 	     	    baserev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1); 	    if (baserev == NULL) 	    { 		if (!quiet&& date_rev1 == NULL) 		    error (0, 0, 			   "cannot find revision %s in file %s", join_rev1, file); 		free (rev); 		return; 	    }
comment|/* 	     * nothing to do if: 	     *	second revision matches our BASE revision (vn_user)&& 	     *	both revisions are on the same branch 	     */
block|if (strcmp (vers->vn_user, rev) == 0&& 		numdots (baserev) == numdots (rev)) 	    {
comment|/* might be the same branch.  take a real look */
block|char *dot = strrchr (baserev, '.'); 		int len = (dot - baserev) + 1; 		 		if (strncmp (baserev, rev, len) == 0) 		    return; 	    } 	} 	else 	{ 	    rev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1); 	    if (rev == NULL) 		return; 	    if (strcmp (rev, vers->vn_user) == 0)
comment|/* no merge necessary */
block|{ 		free (rev); 		return; 	    } 	     	    baserev = RCS_whatbranch (file, join_rev1, srcfiles); 	    if (baserev) 	    { 		char *cp;
comment|/* we get a branch -- turn it into a revision, or NULL if trunk */
block|if ((cp = strrchr (baserev, '.')) == NULL) 		{ 		    free (baserev); 		    baserev = (char *) NULL; 		} 		else 		    *cp = '\0'; 	    } 	} 	if (baserev&& strcmp (baserev, rev) == 0) 	{
comment|/* they match -> nothing to do */
block|free (rev); 	    free (baserev); 	    return; 	}     }
endif|#
directive|endif
comment|/* OK, so we have two revisions; continue on */
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|user
argument_list|,
literal|"%s/%s"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|options
operator|=
name|vers
operator|->
name|options
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
if|#
directive|if
literal|0
block|if (*options == '\0') 	options = "-kk";
comment|/* to ignore keyword expansions */
endif|#
directive|endif
endif|#
directive|endif
comment|/* XXX - Do merge by hand instead of using rcsmerge, due to -k handling */
name|run_setup
argument_list|(
literal|"%s%s %s -r%s -r%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_RCSMERGE
argument_list|,
name|options
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|&&
name|status
operator|!=
literal|1
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|rev2
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|user
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|status
condition|)
name|cp
operator|=
name|time_stamp
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  * Process the current directory, looking for files not in ILIST and not on  * the global ignore list for this directory.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_files
parameter_list|(
name|ilist
parameter_list|,
name|update_dir
parameter_list|)
name|List
modifier|*
name|ilist
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
comment|/* we get called with update_dir set to "." sometimes... strip it */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|xdir
operator|=
literal|""
expr_stmt|;
else|else
name|xdir
operator|=
name|update_dir
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
return|return;
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|file
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|findnode
argument_list|(
name|ilist
argument_list|,
name|file
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
operator|||
endif|#
directive|endif
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|==
name|DT_DIR
operator|||
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
endif|#
directive|endif
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
name|temp
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s"
argument_list|,
name|file
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|temp
argument_list|)
condition|)
continue|continue;
block|}
ifdef|#
directive|ifdef
name|S_ISLNK
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
operator|||
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
endif|#
directive|endif
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|ign_name
argument_list|(
name|file
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'?'
argument_list|,
name|xdir
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|joining
parameter_list|()
block|{
return|return
operator|(
name|join_rev1
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

end_unit

