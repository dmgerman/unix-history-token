begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * "update" updates the version in the present directory with respect to the RCS  * repository.  The present version must have been created by "checkout". The  * user can keep up-to-date by calling "update" whenever he feels like it.  *   * The present version can be committed by "commit", but this keeps the version  * in tact.  *   * Arguments following the options are taken to be file names to be updated,  * rather than updating the entire directory.  *   * Modified or non-existent RCS files are checked out and reported as U  *<user_file>  *   * Modified user files are reported as M<user_file>.  If both the RCS file and  * the user file have been modified, the user file is replaced by the result  * of rcsmerge, and a backup file is written for the user in .#file.version.  * If this throws up irreconcilable differences, the file is reported as C  *<user_file>, and as M<user_file> otherwise.  *   * Files added but not yet committed are reported as A<user_file>. Files  * removed but not yet committed are reported as R<user_file>.  *   * If the current directory contains subdirectories that hold concurrent  * versions, these are updated too.  If the -d option was specified, new  * directories added to the repository are automatically created and updated  * as well.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)update.c 1.83 92/04/10"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|int
name|checkout_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|,
name|List
modifier|*
name|srcfiles
parameter_list|,
name|Vers_TS
modifier|*
name|vers_ts
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isemptydir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|merge_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|,
name|Vers_TS
modifier|*
name|vers
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scratch_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Dtype
name|update_dirent_proc
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_dirleave_proc
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_file_proc
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|List
modifier|*
name|entries
parameter_list|,
name|List
modifier|*
name|srcfiles
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_filesdone_proc
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|repository
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_letter
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|letter
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignore_files
parameter_list|(
name|List
modifier|*
name|ilist
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|join_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|List
modifier|*
name|srcfiles
parameter_list|,
name|Vers_TS
modifier|*
name|vers_ts
parameter_list|,
name|char
modifier|*
name|update_dir
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|update_file_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_filesdone_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Dtype
name|update_dirent_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_dirleave_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isemptydir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scratch_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkout_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_letter
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|merge_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignore_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|join_file
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev1
decl_stmt|,
modifier|*
name|date_rev1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev2
decl_stmt|,
modifier|*
name|date_rev2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_build_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_prune_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ignlist
init|=
operator|(
name|List
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|update_usage
index|[]
init|=
block|{
literal|"Usage:\n %s %s [-APQdflRpq] [-k kopt] [-r rev|-D date] [-j rev] [-I ign] [files...]\n"
block|,
literal|"\t-A\tReset any sticky tags/date/kopts.\n"
block|,
literal|"\t-P\tPrune empty directories.\n"
block|,
literal|"\t-Q\tReally quiet.\n"
block|,
literal|"\t-d\tBuild directories, like checkout does.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-p\tSend updates to standard output.\n"
block|,
literal|"\t-q\tSomewhat quiet.\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"\t-r rev\tUpdate using specified revision/tag.\n"
block|,
literal|"\t-D date\tSet date to update from.\n"
block|,
literal|"\t-j rev\tMerge in changes made between current revision and rev.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * update is the argv,argc based front end for arg parsing  */
end_comment

begin_function
name|int
name|update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
comment|/* recursive by default */
name|int
name|which
decl_stmt|;
comment|/* where to look for files and dirs */
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
comment|/* parse the args */
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gnu_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ApPflRQqdk:r:D:j:I:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|update_build_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|update_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pipeout
operator|=
literal|1
expr_stmt|;
name|noexec
operator|=
literal|1
expr_stmt|;
comment|/* so no locks will be created */
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|join_rev2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only two -j options can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|join_rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|join_rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/*      * If we are updating the entire directory (for real) and building dirs      * as we go, we make sure there is no static entries file and write the      * tag file as appropriate      */
if|if
condition|(
name|argc
operator|<=
literal|0
operator|&&
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/* look for files/dirs locally and in the repository */
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
expr_stmt|;
comment|/* look in the attic too if a tag or date is specified */
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
condition|)
name|which
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* call the command line interface */
name|err
operator|=
name|do_update
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|local
argument_list|,
name|update_build_dirs
argument_list|,
name|aflag
argument_list|,
name|update_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* free the space Make_Date allocated if necessary */
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command line interface to update (used by checkout)  */
end_comment

begin_function
name|int
name|do_update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xoptions
parameter_list|,
name|xtag
parameter_list|,
name|xdate
parameter_list|,
name|xforce
parameter_list|,
name|local
parameter_list|,
name|xbuild
parameter_list|,
name|xaflag
parameter_list|,
name|xprune
parameter_list|,
name|xpipeout
parameter_list|,
name|which
parameter_list|,
name|xjoin_rev1
parameter_list|,
name|xjoin_rev2
parameter_list|,
name|preload_update_dir
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
name|xoptions
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|xdate
decl_stmt|;
name|int
name|xforce
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|xbuild
decl_stmt|;
name|int
name|xaflag
decl_stmt|;
name|int
name|xprune
decl_stmt|;
name|int
name|xpipeout
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|xjoin_rev1
decl_stmt|;
name|char
modifier|*
name|xjoin_rev2
decl_stmt|;
name|char
modifier|*
name|preload_update_dir
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* fill in the statics */
name|options
operator|=
name|xoptions
expr_stmt|;
name|tag
operator|=
name|xtag
expr_stmt|;
name|date
operator|=
name|xdate
expr_stmt|;
name|force_tag_match
operator|=
name|xforce
expr_stmt|;
name|update_build_dirs
operator|=
name|xbuild
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|update_prune_dirs
operator|=
name|xprune
expr_stmt|;
name|pipeout
operator|=
name|xpipeout
expr_stmt|;
comment|/* setup the join support */
name|join_rev1
operator|=
name|xjoin_rev1
expr_stmt|;
name|join_rev2
operator|=
name|xjoin_rev2
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|&&
operator|(
name|cp
operator|=
name|index
argument_list|(
name|join_rev1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev1
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev1
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|&&
operator|(
name|cp
operator|=
name|index
argument_list|(
name|join_rev2
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev2
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev2
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* call the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|update_file_proc
argument_list|,
name|update_filesdone_proc
argument_list|,
name|update_dirent_proc
argument_list|,
name|update_dirleave_proc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|preload_update_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the callback proc for update.  It is called for each file in each  * directory by the recursion code.  The current directory is the local  * instantiation.  file is the file name we are to operate on. update_dir is  * set to the path relative to where we started (for pretty printing).  * repository is the repository. entries and srcfiles are the pre-parsed  * entries and source control files.  *   * This routine decides what needs to be done for each file and does the  * appropriate magic for checkout  */
end_comment

begin_function
specifier|static
name|int
name|update_file_proc
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|Ctype
name|status
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|file
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|options
argument_list|,
name|force_tag_match
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipeout
condition|)
block|{
comment|/* 	 * We just return success without doing anything if any of the really 	 * funky cases occur 	 *  	 * If there is still a valid RCS file, do a regular checkout type 	 * operation 	 */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
name|retval
operator|=
name|checkout_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
name|retval
operator|=
name|merge_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
name|retval
operator|=
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'M'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
name|retval
operator|=
name|checkout_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'A'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
name|retval
operator|=
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'R'
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
name|retval
operator|=
name|scratch_file
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* only try to join if things have gone well thus far */
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|join_rev1
condition|)
name|join_file
argument_list|(
name|file
argument_list|,
name|srcfiles
argument_list|,
name|vers
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ignlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_filesdone_proc () is used  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_filesdone_proc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|ignore_files
argument_list|(
name|ignlist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up CVS admin dirs if we are export */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s -fr"
argument_list|,
name|RM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DO_LINKS
block|{
name|char
name|lnfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|links
decl_stmt|;
name|sprintf
argument_list|(
name|lnfile
argument_list|,
literal|"%s/SymLinks"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|links
operator|=
name|fopen
argument_list|(
name|lnfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|links
condition|)
block|{
name|char
name|from
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|to
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* Read all the link pairs from the symlinks file */
while|while
condition|(
name|fgets
argument_list|(
name|to
argument_list|,
name|PATH_MAX
argument_list|,
name|links
argument_list|)
condition|)
block|{
name|fgets
argument_list|(
name|from
argument_list|,
name|PATH_MAX
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* Strip off the newlines */
name|to
index|[
name|strlen
argument_list|(
name|to
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
index|[
name|strlen
argument_list|(
name|from
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Do it */
if|if
condition|(
name|symlink
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to create symlink `%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Creating symlink %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|links
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirent_proc () is called back by the recursion processor before a  * sub-directory is processed for update.  In this case, update_dirent proc  * will probably create the directory unless -d isn't specified and this is a  * new directory.  A return code of 0 indicates the directory should be  * processed by the recursion code.  A return of non-zero indicates the  * recursion code should skip this directory.  */
end_comment

begin_function
specifier|static
name|Dtype
name|update_dirent_proc
parameter_list|(
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* if we aren't building dirs, blow it off */
if|if
condition|(
operator|!
name|update_build_dirs
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
if|if
condition|(
name|noexec
condition|)
block|{
comment|/* ignore the missing dir if -n is specified */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"New directory `%s' -- ignored"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
block|}
else|else
block|{
comment|/* otherwise, create the dir and appropriate adm files */
name|make_directory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|dir
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If we are building dirs and not going to stdout, we make sure there is      * no static entries file and write the tag file as appropriate      */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
name|WriteTag
argument_list|(
name|dir
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
comment|/* initialize the ignore list for this directory */
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Updating %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirleave_proc () is called back by the recursion code upon leaving  * a directory.  It will prune empty directories if needed and will execute  * any appropriate update programs.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_dirleave_proc
parameter_list|(
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* run the update_prog if there is one */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|pipeout
operator|&&
operator|!
name|noexec
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|line
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s: Executing '"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up CVS admin dirs if we are export */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s -fr"
argument_list|,
name|RM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Prune empty dirs on the way out - if necessary */
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prune_dirs
operator|&&
name|isemptydir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s -fr"
argument_list|,
name|RM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the argument directory is completely empty, other than the  * existence of the CVS directory entry.  Zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|isemptydir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot open directory %s for empty check"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|OCVSADM
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * scratch the Entries file entry associated with a file  */
end_comment

begin_function
specifier|static
name|int
name|scratch_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|history_write
argument_list|(
literal|'W'
argument_list|,
name|update_dir
argument_list|,
literal|""
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check out a file - essentially returns the result of the fork on "co".  */
end_comment

begin_function
specifier|static
name|int
name|checkout_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|srcfiles
parameter_list|,
name|vers_ts
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|set_time
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* don't screw with backup files if we're going to stdout */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
name|rename_file
argument_list|(
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
literal|"%s%s -q -r%s %s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CO
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|)
expr_stmt|;
comment|/*      * if we are checking out to stdout, print a nice message to stderr, and      * add the -p flag to the command      */
if|if
condition|(
name|pipeout
condition|)
block|{
name|run_arg
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"===================================================================\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking out %s/%s\n"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking out %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RCS:  %s\n"
argument_list|,
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"VERS: %s\n"
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***************\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* tack on the rcs and maybe the user file */
name|run_arg
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipeout
condition|)
name|run_arg
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|pipeout
condition|?
operator|(
name|RUN_NORMAL
operator||
name|RUN_REALLY
operator|)
else|:
name|RUN_NORMAL
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers_ts
decl_stmt|;
if|if
condition|(
name|cvswrite
operator|==
name|TRUE
condition|)
name|xchmod
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set the time from the RCS file iff it was unknown before */
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|vers_ts
operator|->
name|ts_rcs
argument_list|,
literal|"Initial"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_time
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|set_time
operator|=
literal|0
expr_stmt|;
name|xvers_ts
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|file
argument_list|,
name|force_tag_match
argument_list|,
name|set_time
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xvers_ts
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|xvers_ts
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|xvers_ts
operator|->
name|ts_user
argument_list|,
name|xvers_ts
operator|->
name|options
argument_list|,
name|xvers_ts
operator|->
name|tag
argument_list|,
name|xvers_ts
operator|->
name|date
argument_list|)
expr_stmt|;
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_ts
operator|->
name|vn_rcs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_rcs
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
comment|/* If this is really Update and not Checkout, recode history */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
name|history_write
argument_list|(
literal|'U'
argument_list|,
name|update_dir
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers_ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"U %s/%s\n"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"U %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
comment|/* save errno value over the rename */
if|if
condition|(
operator|!
name|pipeout
operator|&&
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not check out %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
name|retcode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pipeout
condition|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Several of the types we process only print a bit of information consisting  * of a single letter and the name.  */
end_comment

begin_function
specifier|static
name|int
name|write_letter
parameter_list|(
name|file
parameter_list|,
name|letter
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
name|letter
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s/%s\n"
argument_list|,
name|letter
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s\n"
argument_list|,
name|letter
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be merged  */
end_comment

begin_function
specifier|static
name|int
name|merge_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|,
name|vers
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
name|user
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|user
argument_list|,
literal|"%s/%s"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX - Do merge by hand instead of using rcsmerge, due to -k handling */
name|run_setup
argument_list|(
literal|"%s%s %s -r%s -r%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_RCSMERGE
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|&&
name|status
operator|!=
literal|1
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|user
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* XXX - Might want to make sure that rcsmerge changed the file */
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|vers
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|)
expr_stmt|;
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|vers
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
comment|/* possibly run GREP to see if there appear to be conflicts in the file */
name|run_setup
argument_list|(
literal|"%s -s"
argument_list|,
name|GREP
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|RCS_MERGE_PAT
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
operator|||
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"conflicts found in %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"C %s\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'C'
argument_list|,
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining update of %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"M %s\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be joined  * (-j option)  */
end_comment

begin_function
specifier|static
name|void
name|join_file
parameter_list|(
name|file
parameter_list|,
name|srcfiles
parameter_list|,
name|vers
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
name|user
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|baserev
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* determine if we need to do anything at all */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* special handling when two revisions are specified */
if|if
condition|(
name|join_rev1
operator|&&
name|join_rev2
condition|)
block|{
name|rev
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|join_rev2
argument_list|,
name|date_rev2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|date_rev2
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision %s in file %s"
argument_list|,
name|join_rev2
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|baserev
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|join_rev1
argument_list|,
name|date_rev1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|baserev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|date_rev1
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision %s in file %s"
argument_list|,
name|join_rev1
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * nothing to do if: 	 *	second revision matches our BASE revision (vn_user)&& 	 *	both revisions are on the same branch 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
name|rev
argument_list|)
operator|==
literal|0
operator|&&
name|numdots
argument_list|(
name|baserev
argument_list|)
operator|==
name|numdots
argument_list|(
name|rev
argument_list|)
condition|)
block|{
comment|/* might be the same branch.  take a real look */
name|char
modifier|*
name|dot
init|=
name|rindex
argument_list|(
name|baserev
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|dot
operator|-
name|baserev
operator|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|baserev
argument_list|,
name|rev
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
block|}
else|else
block|{
name|rev
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|join_rev1
argument_list|,
name|date_rev1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|rev
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|==
literal|0
condition|)
comment|/* no merge necessary */
block|{
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return;
block|}
name|baserev
operator|=
name|RCS_whatbranch
argument_list|(
name|file
argument_list|,
name|join_rev1
argument_list|,
name|srcfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|baserev
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* we get a branch -- turn it into a revision, or NULL if trunk */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|baserev
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|baserev
argument_list|)
expr_stmt|;
name|baserev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baserev
operator|&&
name|strcmp
argument_list|(
name|baserev
argument_list|,
name|rev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* they match -> nothing to do */
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|baserev
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* OK, so we have a revision and possibly a base revision; continue on */
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|user
argument_list|,
literal|"%s/%s"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|options
operator|=
name|vers
operator|->
name|options
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
if|if
condition|(
operator|*
name|options
operator|==
literal|'\0'
condition|)
name|options
operator|=
literal|"-kk"
expr_stmt|;
comment|/* to ignore keyword expansions */
endif|#
directive|endif
comment|/* XXX - Do merge by hand instead of using rcsmerge, due to -k handling */
name|run_setup
argument_list|(
literal|"%s%s %s %s%s -r%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_RCSMERGE
argument_list|,
name|options
argument_list|,
name|baserev
condition|?
literal|"-r"
else|:
literal|""
argument_list|,
name|baserev
condition|?
name|baserev
else|:
literal|""
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|&&
name|status
operator|!=
literal|1
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|rev
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|user
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|baserev
condition|)
name|free
argument_list|(
name|baserev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process the current directory, looking for files not in ILIST and not on  * the global ignore list for this directory.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_files
parameter_list|(
name|ilist
parameter_list|,
name|update_dir
parameter_list|)
name|List
modifier|*
name|ilist
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
comment|/* we get called with update_dir set to "." sometimes... strip it */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|xdir
operator|=
literal|""
expr_stmt|;
else|else
name|xdir
operator|=
name|update_dir
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
return|return;
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|file
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|findnode
argument_list|(
name|ilist
argument_list|,
name|file
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
block|}
if|if
condition|(
name|ign_name
argument_list|(
name|file
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'?'
argument_list|,
name|xdir
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

