begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * Create Version  *   * "checkout" creates a "version" of an RCS repository.  This version is owned  * totally by the user and is actually an independent copy, to be dealt with  * as seen fit.  Once "checkout" has been called in a given directory, it  * never needs to be called again.  The user can keep up-to-date by calling  * "update" when he feels like it; this will supply him with a merge of his  * own modifications and the changes made in the RCS original.  See "update"  * for details.  *   * "checkout" can be given a list of directories or files to be updated and in  * the case of a directory, will recursivley create any sub-directories that  * exist in the repository.  *   * When the user is satisfied with his own modifications, the present version  * can be committed by "commit"; this keeps the present version in tact,  * usually.  *   * The call is cvs checkout [options]<module-name>...  *   * "checkout" creates a directory ./CVS, in which it keeps its administration,  * in two files, Repository and Entries. The first contains the name of the  * repository.  The second contains one line for each registered file,  * consisting of the version number it derives from, its time stamp at  * derivation time and its name.  Both files are normal files and can be  * edited by the user, if necessary (when the repository is moved, e.g.)  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)checkout.c 1.67 92/04/10"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|findslash
parameter_list|(
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_dirs_and_chdir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|prepath
parameter_list|,
name|char
modifier|*
name|realdir
parameter_list|,
name|int
name|sticky
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkout_proc
parameter_list|(
name|int
modifier|*
name|pargc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|where
parameter_list|,
name|char
modifier|*
name|mwhere
parameter_list|,
name|char
modifier|*
name|mfile
parameter_list|,
name|int
name|shorten
parameter_list|,
name|int
name|local_specified
parameter_list|,
name|char
modifier|*
name|omodule
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|checkout_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|findslash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_dirs_and_chdir
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|checkout_usage
index|[]
init|=
block|{
literal|"Usage:\n  %s %s [-ANPQcflnpqs] [-r rev | -D date] [-d dir] [-k kopt] modules...\n"
block|,
literal|"\t-A\tReset any sticky tags/date/kopts.\n"
block|,
literal|"\t-N\tDon't shorten module paths if -d specified.\n"
block|,
literal|"\t-P\tPrune empty directories.\n"
block|,
literal|"\t-Q\tReally quiet.\n"
block|,
literal|"\t-c\t\"cat\" the module database.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive\n"
block|,
literal|"\t-n\tDo not run module program (if any).\n"
block|,
literal|"\t-p\tCheck out files to standard output.\n"
block|,
literal|"\t-q\tSomewhat quiet.\n"
block|,
literal|"\t-s\tLike -c, but include module status.\n"
block|,
literal|"\t-r rev\tCheck out revision or tag. (implies -P)\n"
block|,
literal|"\t-D date\tCheck out revisions as of date. (implies -P)\n"
block|,
literal|"\t-d dir\tCheck out into dir instead of module name.\n"
block|,
literal|"\t-K key\tUse RCS key -K option on checkout.\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"\t-j rev\tMerge in changes made between current revision and rev.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|export_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-NPQflnq] [-r rev | -D date] [-d dir] module...\n"
block|,
literal|"\t-N\tDon't shorten module paths if -d specified.\n"
block|,
literal|"\t-Q\tReally quiet.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive\n"
block|,
literal|"\t-n\tDo not run module program (if any).\n"
block|,
literal|"\t-q\tSomewhat quiet.\n"
block|,
literal|"\t-r rev\tCheck out revision or tag. (implies -P)\n"
block|,
literal|"\t-D date\tCheck out revisions as of date. (implies -P)\n"
block|,
literal|"\t-d dir\tCheck out into dir instead of module name.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkout_prune_dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|preload_update_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|K_flag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|checkout
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|int
name|cat
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|shorten
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|where
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|valid_options
decl_stmt|,
modifier|*
modifier|*
name|valid_usage
decl_stmt|;
comment|/*      * A smaller subset of options are allowed for the export command, which      * is essentially like checkout, except that it hard-codes certain      * options to be on (like -kv) and takes care to remove the CVS directory      * when it has done its duty      */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|valid_options
operator|=
literal|"Nnd:flRQqr:D:"
expr_stmt|;
name|valid_usage
operator|=
name|export_usage
expr_stmt|;
block|}
else|else
block|{
name|valid_options
operator|=
literal|"ANnk:d:flRpQqcsr:D:j:PK:"
expr_stmt|;
name|valid_usage
operator|=
name|checkout_usage
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|valid_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gnu_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|valid_options
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|shorten
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|checkout_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pipeout
operator|=
literal|1
expr_stmt|;
name|run_module_prog
operator|=
literal|0
expr_stmt|;
comment|/* don't run module prog when piping */
name|noexec
operator|=
literal|1
expr_stmt|;
comment|/* so no locks will be created */
break|break;
case|case
literal|'c'
case|:
name|cat
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|where
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|status
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
name|checkout_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|checkout_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|join_rev2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only two -j options can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|join_rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|join_rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|K_flag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|valid_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_DEVELOPER
if|if
condition|(
operator|!
name|K_flag
operator|&&
name|freebsd
condition|)
name|K_flag
operator|=
literal|"-KeAuthor,Date,Header,Id,Locker,Log,RCSfile,Revision,Source,State -KiFreeBSD"
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_DEVELOPER */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|shorten
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|cat
operator|+
name|status
operator|)
operator|&&
name|argc
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|cat
operator|+
name|status
operator|)
operator|&&
name|argc
operator|!=
literal|0
operator|)
operator|||
operator|(
name|tag
operator|&&
name|date
operator|)
condition|)
name|usage
argument_list|(
name|valid_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|&&
name|pipeout
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-d and -p are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tag
operator|&&
operator|!
name|date
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"must specify a tag or date"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|valid_usage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must be a symbolic tag"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
literal|"v"
argument_list|)
expr_stmt|;
comment|/* -kv must be on */
block|}
if|if
condition|(
name|cat
operator|||
name|status
condition|)
block|{
name|cat_module
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
comment|/*      * if we have more than one argument and where was specified, we make the      * where, cd into it, and try to shorten names as much as possible.      * Otherwise, we pass the where as a single argument to do_module.      */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|where
operator|!=
name|NULL
condition|)
block|{
name|char
name|repository
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|where
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|where
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|xstrdup
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM
argument_list|)
operator|&&
operator|!
name|isfile
argument_list|(
name|OCVSADM
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|CVSNULLREPOS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|repository
argument_list|)
condition|)
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|repository
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * if where was specified (-d) and we have not taken care of it already      * with the multiple arg stuff, and it was not a simple directory name      * but rather a path, we strip off everything but the last component and      * attempt to cd to the indicated place.  where then becomes simply the      * last component      */
if|if
condition|(
name|where
operator|!=
name|NULL
operator|&&
name|index
argument_list|(
name|where
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|rindex
argument_list|(
name|where
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|where
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|xstrdup
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|where
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|where
operator|==
literal|'\0'
condition|)
name|where
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|CHECKOUT
argument_list|,
literal|"Updating"
argument_list|,
name|checkout_proc
argument_list|,
name|where
argument_list|,
name|shorten
argument_list|,
name|local
argument_list|,
name|run_module_prog
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process_module calls us back here so we do the actual checkout stuff  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|checkout_proc
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|,
name|where
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|omodule
parameter_list|,
name|msg
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|omodule
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|char
name|repository
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|xwhere
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|oldupdate
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|prepath
decl_stmt|;
name|char
modifier|*
name|realdirs
decl_stmt|;
comment|/*      * OK, so we're doing the checkout! Our args are as follows:       *  argc,argv contain either dir or dir followed by a list of files       *  where contains where to put it (if supplied by checkout)       *  mwhere contains the module name or -d from module file       *  mfile says do only that part of the module      *  shorten = TRUE says shorten as much as possible       *  omodule is the original arg to do_module()      */
comment|/* set up the repository (maybe) for the bottom directory */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* save the original value of preload_update_dir */
if|if
condition|(
name|preload_update_dir
operator|!=
name|NULL
condition|)
name|oldupdate
operator|=
name|xstrdup
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
comment|/* fix up argv[] for the case of partial modules */
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* if mfile is really a path, straighten it out first */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|mfile
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
comment|/* 	     * Now we need to fill in the where correctly. if !shorten, tack 	     * the rest of the path onto where if where is filled in 	     * otherwise tack the rest of the path onto mwhere and make that 	     * the where 	     *  	     * If shorten is enabled, we might use mwhere to set where if  	     * nobody set it yet, so we'll need to setup mwhere as the last 	     * component of the path we are tacking onto repository 	     */
if|if
condition|(
operator|!
name|shorten
condition|)
block|{
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xwhere
argument_list|,
literal|"%s/%s"
argument_list|,
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xwhere
argument_list|,
literal|"%s/%s"
argument_list|,
name|mwhere
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
name|where
operator|=
name|xwhere
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
operator|(
name|slash
operator|=
name|rindex
argument_list|(
name|mfile
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|mwhere
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
else|else
name|mwhere
operator|=
name|mfile
expr_stmt|;
block|}
name|mfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* 	     * The portion of a module was a directory, so kludge up where to 	     * be the subdir, and fix up repository 	     */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 	     * At this point, if shorten is not enabled, we make where either 	     * where with mfile concatenated, or if where hadn't been set we 	     * set it to mwhere with mfile concatenated. 	     *  	     * If shorten is enabled and where hasn't been set yet, then where 	     * becomes mfile 	     */
if|if
condition|(
operator|!
name|shorten
condition|)
block|{
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xwhere
argument_list|,
literal|"%s/%s"
argument_list|,
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xwhere
argument_list|,
literal|"%s/%s"
argument_list|,
name|mwhere
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
name|where
operator|=
name|xwhere
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|==
name|NULL
condition|)
name|where
operator|=
name|mfile
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* 	     * The portion of a module was a file, so kludge up argv to be 	     * correct 	     */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
name|i
operator|++
control|)
comment|/* free the old ones */
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|xstrdup
argument_list|(
name|mfile
argument_list|)
expr_stmt|;
comment|/* set up the new one */
operator|*
name|pargc
operator|=
literal|2
expr_stmt|;
comment|/* where gets mwhere if where isn't set */
if|if
condition|(
name|where
operator|==
name|NULL
condition|)
name|where
operator|=
name|mwhere
expr_stmt|;
block|}
block|}
comment|/*      * if shorten is enabled and where isn't specified yet, we pluck the last      * directory component of argv[0] and make it the where      */
if|if
condition|(
name|shorten
operator|&&
name|where
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xwhere
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|where
operator|=
name|xwhere
expr_stmt|;
block|}
block|}
comment|/* if where is still NULL, use mwhere if set or the argv[0] dir */
if|if
condition|(
name|where
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mwhere
condition|)
name|where
operator|=
name|mwhere
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xwhere
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|where
operator|=
name|xwhere
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preload_update_dir
operator|!=
name|NULL
condition|)
block|{
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|preload_update_dir
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|xstrdup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|preload_update_dir
operator|=
name|xstrdup
argument_list|(
name|where
argument_list|)
expr_stmt|;
comment|/*      * At this point, where is the directory we want to build, repository is      * the repository for the lowest level of the path.      */
comment|/*      * If we are sending everything to stdout, we can skip a whole bunch of      * work from here      */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
comment|/* 	 * We need to tell build_dirs not only the path we want it to build, 	 * but also the repositories we want it to populate the path with. To 	 * accomplish this, we pass build_dirs a ``real path'' with valid 	 * repositories and a string to pre-pend based on how many path 	 * elements exist in where. Big Black Magic 	 */
name|prepath
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|where
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|rindex
argument_list|(
name|prepath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|findslash
argument_list|(
name|where
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|findslash
argument_list|(
name|prepath
argument_list|,
name|cp2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|realdirs
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
comment|/* 	 * build dirs on the path if necessary and leave us in the bottom 	 * directory (where if where was specified) doesn't contain a CVS 	 * subdir yet, but all the others contain CVS and Entries.Static 	 * files 	 */
if|if
condition|(
name|build_dirs_and_chdir
argument_list|(
name|where
argument_list|,
name|prepath
argument_list|,
name|realdirs
argument_list|,
operator|*
name|pargc
operator|<=
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring module %s"
argument_list|,
name|omodule
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prepath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|oldupdate
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* clean up */
name|free
argument_list|(
name|prepath
argument_list|)
expr_stmt|;
comment|/* set up the repository (or make sure the old one matches) */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM
argument_list|)
operator|&&
operator|!
name|isfile
argument_list|(
name|OCVSADM
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|noexec
operator|&&
operator|*
name|pargc
operator|>
literal|1
condition|)
block|{
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
else|else
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|repos
decl_stmt|;
comment|/* get the contents of the previously existing repository */
name|repos
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|preload_update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|repository
argument_list|,
name|repos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"existing repository %s does not match %s"
argument_list|,
name|repos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring module %s"
argument_list|,
name|omodule
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|oldupdate
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If we are going to be updating to stdout, we need to cd to the      * repository directory so the recursion processor can use the current      * directory as the place to find repository information      */
if|if
condition|(
name|pipeout
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|oldupdate
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|which
operator|=
name|W_REPOS
expr_stmt|;
block|}
else|else
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
condition|)
name|which
operator||=
name|W_ATTIC
expr_stmt|;
comment|/*      * if we are going to be recursive (building dirs), go ahead and call the      * update recursion processor.  We will be recursive unless either local      * only was specified, or we were passed arguments      */
if|if
condition|(
operator|!
operator|(
name|local_specified
operator|||
operator|*
name|pargc
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|pipeout
condition|)
name|history_write
argument_list|(
literal|'O'
argument_list|,
name|preload_update_dir
argument_list|,
name|tag
condition|?
name|tag
else|:
name|date
argument_list|,
name|where
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_update
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
literal|0
comment|/* !local */
argument_list|,
literal|1
comment|/* update -d */
argument_list|,
name|aflag
argument_list|,
name|checkout_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
name|K_flag
argument_list|,
name|preload_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|oldupdate
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|int
name|i
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
comment|/* we are only doing files, so register them */
name|entries
operator|=
name|ParseEntries
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
name|i
operator|++
control|)
block|{
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|user
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|user
argument_list|,
name|force_tag_match
argument_list|,
literal|0
argument_list|,
name|entries
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"Initial %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|line
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* Don't log "export", just regular "checkouts" */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|pipeout
condition|)
name|history_write
argument_list|(
literal|'O'
argument_list|,
name|preload_update_dir
argument_list|,
operator|(
name|tag
condition|?
name|tag
else|:
name|date
operator|)
argument_list|,
name|where
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* go ahead and call update now that everything is set */
name|err
operator|+=
name|do_update
argument_list|(
operator|*
name|pargc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|local_specified
argument_list|,
literal|1
comment|/* update -d */
argument_list|,
name|aflag
argument_list|,
name|checkout_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
name|K_flag
argument_list|,
name|preload_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|oldupdate
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|findslash
parameter_list|(
name|start
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|int
operator|)
name|p
operator|>=
operator|(
name|int
operator|)
name|start
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|p
operator|<
operator|(
name|int
operator|)
name|start
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * build all the dirs along the path to dir with CVS subdirs with appropriate  * repositories and Entries.Static files  */
end_comment

begin_function
specifier|static
name|int
name|build_dirs_and_chdir
parameter_list|(
name|dir
parameter_list|,
name|prepath
parameter_list|,
name|realdir
parameter_list|,
name|sticky
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|prepath
decl_stmt|;
name|char
modifier|*
name|realdir
decl_stmt|;
name|int
name|sticky
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|repository
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|path2
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|char
modifier|*
name|slash2
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|path
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|path2
argument_list|,
name|realdir
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|path
operator|,
name|cp2
operator|=
name|path2
init|;
operator|(
name|slash
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|slash2
operator|=
name|index
argument_list|(
name|cp2
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|slash
operator|+
literal|1
operator|,
name|cp2
operator|=
name|slash2
operator|+
literal|1
control|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|slash2
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|cp
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|cp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM
argument_list|)
operator|&&
operator|!
name|isfile
argument_list|(
name|OCVSADM
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|prepath
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|repository
argument_list|,
name|sticky
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|tag
argument_list|,
name|sticky
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
operator|*
name|slash2
operator|=
literal|'/'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|cp
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|cp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

