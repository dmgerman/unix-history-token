begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *    Copyright (c) 1992, Brian Berliner and Jeff Polk  *    Copyright (c) 1989-1992, Brian Berliner  *  *    You may distribute under the terms of the GNU General Public License  *    as specified in the README file that comes with the CVS 1.3 kit.  *  * This is the main C driver for the CVS system.  *  * Credit to Dick Grune, Vrije Universiteit, Amsterdam, for writing  * the shell-script CVS system that this is based on.  *  * Usage:  *	cvs [options] command [options] [files/modules...]  *  * Where "command" is composed of:  *		admin		RCS command  *		checkout	Check out a module/dir/file  *		export		Like checkout, but used for exporting sources  *		update		Brings work tree in sync with repository  *		commit		Checks files into the repository  *		diff		Runs diffs between revisions  *		log		Prints "rlog" information for files  *		add		Adds an entry to the repository  *		remove		Removes an entry from the repository  *		status		Status info on the revisions  *		rdiff		"patch" format diff listing between releases  *		tag		Add/delete a symbolic tag to the RCS file  *		rtag		Add/delete a symbolic tag to the RCS file  *		import		Import sources into CVS, using vendor branches  *		release		Indicate that Module is no longer in use.  *		history		Display history of Users and Modules.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_decl_stmt
name|char
name|rcsid
index|[]
init|=
literal|"@(#)main.c 1.64 92/03/31\n"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|command_name
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_editor
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvswrite
init|=
operator|!
name|CVSREAD_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|really_quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noexec
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logoff
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CurDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defaults, for the environment variables that are not set  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Rcsbin
init|=
name|RCSBIN_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Editor
init|=
name|EDITOR_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CVSroot
init|=
name|CVSROOT_DFLT
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
name|int
name|add
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|admin
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|checkout
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|commit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|diff
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|history
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|import
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cvslog
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|patch
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|release
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cvsremove
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rtag
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|status
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tag
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|update
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|add
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|admin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|checkout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|commit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|diff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|history
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|import
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cvslog
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|patch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|release
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cvsremove
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rtag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|status
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|update
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_DEVELOPER
end_ifdef

begin_decl_stmt
name|int
name|freebsd
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use the FreeBSD -K flags!! */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|cmd
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Full name of the function (e.g. "commit") */
name|char
modifier|*
name|nick1
decl_stmt|;
comment|/* alternate name (e.g. "ci") */
name|char
modifier|*
name|nick2
decl_stmt|;
comment|/* another alternate names (e.g. "ci") */
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function takes (argc, argv) arguments. */
block|}
name|cmds
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"ad"
block|,
literal|"new"
block|,
name|add
block|}
block|,
block|{
literal|"admin"
block|,
literal|"adm"
block|,
literal|"rcs"
block|,
name|admin
block|}
block|,
block|{
literal|"checkout"
block|,
literal|"co"
block|,
literal|"get"
block|,
name|checkout
block|}
block|,
block|{
literal|"commit"
block|,
literal|"ci"
block|,
literal|"com"
block|,
name|commit
block|}
block|,
block|{
literal|"diff"
block|,
literal|"di"
block|,
literal|"dif"
block|,
name|diff
block|}
block|,
block|{
literal|"export"
block|,
literal|"exp"
block|,
literal|"ex"
block|,
name|checkout
block|}
block|,
block|{
literal|"history"
block|,
literal|"hi"
block|,
literal|"his"
block|,
name|history
block|}
block|,
block|{
literal|"import"
block|,
literal|"im"
block|,
literal|"imp"
block|,
name|import
block|}
block|,
block|{
literal|"log"
block|,
literal|"lo"
block|,
literal|"rlog"
block|,
name|cvslog
block|}
block|,
block|{
literal|"rdiff"
block|,
literal|"patch"
block|,
literal|"pa"
block|,
name|patch
block|}
block|,
block|{
literal|"release"
block|,
literal|"re"
block|,
literal|"rel"
block|,
name|release
block|}
block|,
block|{
literal|"remove"
block|,
literal|"rm"
block|,
literal|"delete"
block|,
name|cvsremove
block|}
block|,
block|{
literal|"status"
block|,
literal|"st"
block|,
literal|"stat"
block|,
name|status
block|}
block|,
block|{
literal|"rtag"
block|,
literal|"rt"
block|,
literal|"rfreeze"
block|,
name|rtag
block|}
block|,
block|{
literal|"tag"
block|,
literal|"ta"
block|,
literal|"freeze"
block|,
name|tag
block|}
block|,
block|{
literal|"update"
block|,
literal|"up"
block|,
literal|"upd"
block|,
name|update
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|usg
index|[]
init|=
block|{
literal|"Usage: %s [cvs-options] command [command-options] [files...]\n"
block|,
literal|"    Where 'cvs-options' are:\n"
block|,
literal|"        -H           Displays Usage information for command\n"
block|,
literal|"        -Q           Cause CVS to be really quiet.\n"
block|,
literal|"        -q           Cause CVS to be somewhat quiet.\n"
block|,
literal|"        -r           Make checked-out files read-only\n"
block|,
literal|"        -w           Make checked-out files read-write (default)\n"
block|,
literal|"        -l           Turn History logging off\n"
block|,
literal|"        -n           Do not execute anything that will change the disk\n"
block|,
literal|"        -t           Show trace of program execution -- Try with -n\n"
block|,
literal|"        -v           CVS version and copyright\n"
block|,
literal|"        -b bindir    Find RCS programs in 'bindir'\n"
block|,
literal|"        -e editor    Use 'editor' for editing log information\n"
block|,
literal|"        -d CVS_root  Overrides $CVSROOT as the root of the CVS tree\n"
block|,
ifdef|#
directive|ifdef
name|FREEBSD_DEVELOPER
literal|"        -x           Do NOT use the FreeBSD -K default flags\n"
block|,
endif|#
directive|endif
literal|"\n"
block|,
literal|"    and where 'command' is:\n"
block|,
literal|"        add          Adds a new file/directory to the repository\n"
block|,
literal|"        admin        Administration front end for rcs\n"
block|,
literal|"        checkout     Checkout sources for editing\n"
block|,
literal|"        commit       Checks files into the repository\n"
block|,
literal|"        diff         Runs diffs between revisions\n"
block|,
literal|"        history      Shows status of files and users\n"
block|,
literal|"        import       Import sources into CVS, using vendor branches\n"
block|,
literal|"        export       Export sources from CVS, similar to checkout\n"
block|,
literal|"        log          Prints out 'rlog' information for files\n"
block|,
literal|"        rdiff        'patch' format diffs between releases\n"
block|,
literal|"        release      Indicate that a Module is no longer in use\n"
block|,
literal|"        remove       Removes an entry from the repository\n"
block|,
literal|"        status       Status info on the revisions\n"
block|,
literal|"        tag          Add a symbolic tag to checked out version of RCS file\n"
block|,
literal|"        rtag         Add a symbolic tag to the RCS file\n"
block|,
literal|"        update       Brings work tree in sync with repository\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|SIGTYPE
name|main_cleanup
parameter_list|()
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cm
decl_stmt|;
name|int
name|c
decl_stmt|,
name|help
init|=
name|FALSE
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|rcsbin_update_env
decl_stmt|,
name|cvs_update_env
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/*      * Just save the last component of the path for error messages      */
if|if
condition|(
operator|(
name|program_name
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|program_name
operator|++
expr_stmt|;
name|CurDir
operator|=
name|xmalloc
argument_list|(
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|CurDir
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot get working directory: %s"
argument_list|,
name|CurDir
argument_list|)
expr_stmt|;
comment|/*      * Query the environment variables up-front, so that      * they can be overridden by command line arguments      */
name|rcsbin_update_env
operator|=
operator|*
name|Rcsbin
expr_stmt|;
comment|/* RCSBIN_DFLT must be set */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|RCSBIN_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Rcsbin
operator|=
name|cp
expr_stmt|;
name|rcsbin_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CVSroot
operator|=
name|cp
expr_stmt|;
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
name|getenv
argument_list|(
name|CVSREAD_ENV
argument_list|)
operator|!=
name|NULL
condition|)
name|cvswrite
operator|=
name|FALSE
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_DEVELOPER
while|while
condition|(
operator|(
name|c
operator|=
name|gnu_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Qqrwtnlvb:e:d:Hx"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|gnu_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Qqrwtnlvb:e:d:H"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/* FREEBSD_DEVELOPER */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|cvswrite
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noexec
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'l'
case|:
comment|/* Fall through */
name|logoff
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|rcsid
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|version_string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"Patch Level: %d\n"
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|tmp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\nCopyright (c) 1992, Brian Berliner and Jeff Polk\nCopyright (c) 1989-1992, Brian Berliner\n\nCVS may be copied only under the terms of the GNU General Public License,\na copy of which can be found with the CVS 1.3 distribution kit.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|Rcsbin
operator|=
name|optarg
expr_stmt|;
name|rcsbin_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'e'
case|:
name|Editor
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|CVSroot
operator|=
name|optarg
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'H'
case|:
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FREEBSD_DEVELOPER
case|case
literal|'x'
case|:
name|freebsd
operator|=
name|FALSE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FREEBSD_DEVELOPER */
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
comment|/*      * XXX - Compatibility.  This can be removed in the release after CVS 1.3.      * Try to rename the CVSROOT.adm file to CVSROOT, unless there already is      * a CVSROOT directory.      */
if|if
condition|(
name|CVSroot
operator|!=
name|NULL
condition|)
block|{
name|char
name|rootadm
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|orootadm
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rootadm
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|rootadm
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|orootadm
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|OCVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|orootadm
argument_list|)
condition|)
operator|(
name|void
operator|)
name|rename
argument_list|(
name|orootadm
argument_list|,
name|rootadm
argument_list|)
expr_stmt|;
block|}
name|strip_path
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
block|}
comment|/*      * Specifying just the '-H' flag to the sub-command causes a Usage      * message to be displayed.      */
name|command_name
operator|=
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|help
operator|==
name|TRUE
operator|||
operator|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-H"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|argc
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
comment|/* 	 * Check to see if we can write into the history file.  If not, 	 * we assume that we can't work in the repository. 	 * BUT, only if the history file exists. 	 */
block|{
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
operator|!
name|CVSroot
operator|||
operator|!
operator|*
name|CVSroot
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"You don't have a %s environment variable"
argument_list|,
name|CVSROOT_ENV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Sorry, you don't have sufficient access to %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|path
argument_list|)
operator|&&
name|access
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
operator|(
name|logoff
condition|?
literal|0
else|:
name|W_OK
operator|)
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Sorry, you don't have read/write access to the history file"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|PUTENV_MISSING
comment|/* Now, see if we should update the environment with the Rcsbin value */
if|if
condition|(
name|cvs_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
if|if
condition|(
name|rcsbin_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|RCSBIN_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|RCSBIN_ENV
argument_list|,
name|Rcsbin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
endif|#
directive|endif
comment|/*      * If Rcsbin is set to something, make sure it is terminated with      * a slash character.  If not, add one.      */
if|if
condition|(
operator|*
name|Rcsbin
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
decl_stmt|;
name|char
modifier|*
name|rcsbin
decl_stmt|;
if|if
condition|(
name|Rcsbin
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|rcsbin
operator|=
name|Rcsbin
expr_stmt|;
name|Rcsbin
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* one for '/', one for NULL */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Rcsbin
argument_list|,
name|rcsbin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|Rcsbin
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cm
operator|=
name|cmds
init|;
name|cm
operator|->
name|fullname
condition|;
name|cm
operator|++
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|nick1
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|cm
operator|->
name|nick1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cm
operator|->
name|nick2
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|cm
operator|->
name|nick2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|cm
operator|->
name|fullname
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cm
operator|->
name|fullname
condition|)
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
comment|/* no match */
else|else
block|{
name|command_name
operator|=
name|cm
operator|->
name|fullname
expr_stmt|;
comment|/* Global pointer for later use */
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SETVBUF_MISSING
comment|/* 	 * Make stdout line buffered, so 'tail -f' can monitor progress. 	 * Patch creates too much output to monitor and it runs slowly. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|cm
operator|->
name|fullname
argument_list|,
literal|"patch"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
block|}
comment|/*      * If the command's error count is modulo 256, we need to change it      * so that we don't overflow the 8-bits we get to report exit status      */
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|%
literal|256
operator|)
operator|==
literal|0
condition|)
name|err
operator|=
literal|1
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Make_Date
parameter_list|(
name|rawdate
parameter_list|)
name|char
modifier|*
name|rawdate
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|unixtime
decl_stmt|;
name|char
name|date
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX bigger than we'll ever need? */
name|char
modifier|*
name|ret
decl_stmt|;
name|unixtime
operator|=
name|get_date
argument_list|(
name|rawdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unixtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Can't parse date/time: %s"
argument_list|,
name|rawdate
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|cpp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
operator|++
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

