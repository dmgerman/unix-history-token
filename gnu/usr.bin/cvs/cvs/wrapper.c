begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_comment
comment|/*   Original Author:  athan@morgan.com<Andrew C. Athan> 2/1/94   Modified By:      vdemarco@bou.shl.com    This package was written to support the NEXTSTEP concept of   "wrappers."  These are essentially directories that are to be   treated as "files."  This package allows such wrappers to be   "processed" on the way in and out of CVS.  The intended use is to   wrap up a wrapper into a single tar, such that that tar can be   treated as a single binary file in CVS.  To solve the problem   effectively, it was also necessary to be able to prevent rcsmerge   application at appropriate times.    ------------------   Format of wrapper file ($CVSROOT/CVSROOT/cvswrappers or .cvswrappers)    wildcard	[option value][option value]...    where option is one of   -f		from cvs filter		value: path to filter   -t		to cvs filter		value: path to filter   -m		update methodology	value: MERGE or COPY    and value is a single-quote delimited value.    E.g:   *.nib		-f 'gunzipuntar' -t 'targzip' -m 'COPY' */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|wildCard
decl_stmt|;
name|char
modifier|*
name|tocvsFilter
decl_stmt|;
name|char
modifier|*
name|fromcvsFilter
decl_stmt|;
name|char
modifier|*
name|conflictHook
decl_stmt|;
name|WrapMergeMethod
name|mergeMethod
decl_stmt|;
block|}
name|WrapperEntry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|WrapperEntry
modifier|*
modifier|*
name|wrap_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WrapperEntry
modifier|*
modifier|*
name|wrap_saved_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_tempcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_saved_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_saved_tempcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRAPPER_GROW
value|8
end_define

begin_decl_stmt
name|void
name|wrap_add_entry
name|PROTO
argument_list|(
operator|(
name|WrapperEntry
operator|*
name|e
operator|,
name|int
name|temp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_kill
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_kill_temp
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_free_entry
name|PROTO
argument_list|(
operator|(
name|WrapperEntry
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_free_entry_internal
name|PROTO
argument_list|(
operator|(
name|WrapperEntry
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_restore_saved
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|wrap_setup
parameter_list|()
block|{
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* Then add entries found in repository, if it exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_WRAPPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|wrap_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Then add entries found in home dir, (if user has one) and file exists */
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_dir
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|CVSDOTWRAPPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|wrap_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Then add entries found in CVSWRAPPERS environment variable. */
name|wrap_add
argument_list|(
name|getenv
argument_list|(
name|WRAPPER_ENV
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a file and read lines, feeding each line to a line parser. Arrange  * for keeping a temporary list of wrappers at the end, if the "temp"  * argument is set.  */
end_comment

begin_function
name|void
name|wrap_add_file
parameter_list|(
name|file
parameter_list|,
name|temp
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|temp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
name|wrap_restore_saved
argument_list|()
expr_stmt|;
name|wrap_kill_temp
argument_list|()
expr_stmt|;
comment|/* load the file */
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
name|wrap_add
argument_list|(
name|line
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_kill
parameter_list|()
block|{
name|wrap_kill_temp
argument_list|()
expr_stmt|;
while|while
condition|(
name|wrap_count
condition|)
name|wrap_free_entry
argument_list|(
name|wrap_list
index|[
operator|--
name|wrap_count
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_kill_temp
parameter_list|()
block|{
name|WrapperEntry
modifier|*
modifier|*
name|temps
init|=
name|wrap_list
operator|+
name|wrap_count
decl_stmt|;
while|while
condition|(
name|wrap_tempcount
condition|)
name|wrap_free_entry
argument_list|(
name|temps
index|[
operator|--
name|wrap_tempcount
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_free_entry
parameter_list|(
name|e
parameter_list|)
name|WrapperEntry
modifier|*
name|e
decl_stmt|;
block|{
name|wrap_free_entry_internal
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_free_entry_internal
parameter_list|(
name|e
parameter_list|)
name|WrapperEntry
modifier|*
name|e
decl_stmt|;
block|{
name|free
argument_list|(
name|e
operator|->
name|wildCard
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tocvsFilter
condition|)
name|free
argument_list|(
name|e
operator|->
name|tocvsFilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|fromcvsFilter
condition|)
name|free
argument_list|(
name|e
operator|->
name|fromcvsFilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|conflictHook
condition|)
name|free
argument_list|(
name|e
operator|->
name|conflictHook
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_restore_saved
parameter_list|()
block|{
if|if
condition|(
operator|!
name|wrap_saved_list
condition|)
return|return;
name|wrap_kill
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wrap_list
argument_list|)
expr_stmt|;
name|wrap_list
operator|=
name|wrap_saved_list
expr_stmt|;
name|wrap_count
operator|=
name|wrap_saved_count
expr_stmt|;
name|wrap_tempcount
operator|=
name|wrap_saved_tempcount
expr_stmt|;
name|wrap_saved_list
operator|=
name|NULL
expr_stmt|;
name|wrap_saved_count
operator|=
literal|0
expr_stmt|;
name|wrap_saved_tempcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_add
parameter_list|(
name|line
parameter_list|,
name|isTemp
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|isTemp
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|char
name|ctemp
decl_stmt|;
name|WrapperEntry
name|e
decl_stmt|;
name|char
name|opt
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search for the wild card */
while|while
condition|(
operator|*
name|line
operator|&&
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
operator|++
name|line
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|line
init|;
operator|*
name|line
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|;
operator|++
name|line
control|)
empty_stmt|;
if|if
condition|(
name|temp
operator|==
name|line
condition|)
return|return;
name|ctemp
operator|=
operator|*
name|line
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|.
name|wildCard
operator|=
name|xstrdup
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
name|ctemp
expr_stmt|;
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* Search for the option */
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'-'
condition|)
operator|++
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
operator|++
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
name|opt
operator|=
operator|*
name|line
expr_stmt|;
comment|/* Search for the filter commandline */
for|for
control|(
operator|++
name|line
init|;
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'\''
condition|;
operator|++
name|line
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
for|for
control|(
name|temp
operator|=
operator|++
name|line
init|;
operator|*
name|line
operator|&&
operator|(
operator|*
name|line
operator|!=
literal|'\''
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|;
operator|++
name|line
control|)
empty_stmt|;
if|if
condition|(
name|line
operator|==
name|temp
operator|+
literal|1
condition|)
break|break;
name|ctemp
operator|=
operator|*
name|line
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|e
operator|.
name|fromcvsFilter
condition|)
name|free
argument_list|(
name|e
operator|.
name|fromcvsFilter
argument_list|)
expr_stmt|;
name|e
operator|.
name|fromcvsFilter
operator|=
name|expand_path
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|fromcvsFilter
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid environmental variable string '%s'"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|e
operator|.
name|tocvsFilter
condition|)
name|free
argument_list|(
name|e
operator|.
name|tocvsFilter
argument_list|)
expr_stmt|;
name|e
operator|.
name|tocvsFilter
operator|=
name|expand_path
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|tocvsFilter
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid environmental variable string '%s'"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|e
operator|.
name|conflictHook
condition|)
name|free
argument_list|(
name|e
operator|.
name|conflictHook
argument_list|)
expr_stmt|;
name|e
operator|.
name|conflictHook
operator|=
name|expand_path
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|conflictHook
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid environmental variable string '%s'"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|*
name|temp
operator|==
literal|'C'
operator|||
operator|*
name|temp
operator|==
literal|'c'
condition|)
name|e
operator|.
name|mergeMethod
operator|=
name|WRAP_COPY
expr_stmt|;
else|else
name|e
operator|.
name|mergeMethod
operator|=
name|WRAP_MERGE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|line
operator|=
name|ctemp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
operator|++
name|line
expr_stmt|;
block|}
name|wrap_add_entry
argument_list|(
operator|&
name|e
argument_list|,
name|isTemp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_add_entry
parameter_list|(
name|e
parameter_list|,
name|temp
parameter_list|)
name|WrapperEntry
modifier|*
name|e
decl_stmt|;
name|int
name|temp
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|wrap_count
operator|+
name|wrap_tempcount
operator|>=
name|wrap_size
condition|)
block|{
name|wrap_size
operator|+=
name|WRAPPER_GROW
expr_stmt|;
name|wrap_list
operator|=
operator|(
name|WrapperEntry
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wrap_list
argument_list|,
name|wrap_size
operator|*
sizeof|sizeof
argument_list|(
name|WrapperEntry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|temp
operator|&&
name|wrap_tempcount
condition|)
block|{
for|for
control|(
name|x
operator|=
name|wrap_count
operator|+
name|wrap_tempcount
operator|-
literal|1
init|;
name|x
operator|>=
name|wrap_count
condition|;
operator|--
name|x
control|)
name|wrap_list
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|wrap_list
index|[
name|x
index|]
expr_stmt|;
block|}
name|x
operator|=
operator|(
name|temp
condition|?
name|wrap_count
operator|+
operator|(
name|wrap_tempcount
operator|++
operator|)
else|:
operator|(
name|wrap_count
operator|++
operator|)
operator|)
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|=
operator|(
name|WrapperEntry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WrapperEntry
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|wildCard
operator|=
name|e
operator|->
name|wildCard
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|fromcvsFilter
operator|=
name|e
operator|->
name|fromcvsFilter
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|tocvsFilter
operator|=
name|e
operator|->
name|tocvsFilter
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|conflictHook
operator|=
name|e
operator|->
name|conflictHook
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|mergeMethod
operator|=
name|e
operator|->
name|mergeMethod
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the given filename is a wrapper filename */
end_comment

begin_function
name|int
name|wrap_name_has
parameter_list|(
name|name
parameter_list|,
name|has
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|WrapMergeHas
name|has
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|count
init|=
name|wrap_count
operator|+
name|wrap_saved_count
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|fnmatch
argument_list|(
name|wrap_list
index|[
name|x
index|]
operator|->
name|wildCard
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|has
condition|)
block|{
case|case
name|WRAP_TOCVS
case|:
name|temp
operator|=
name|wrap_list
index|[
name|x
index|]
operator|->
name|tocvsFilter
expr_stmt|;
break|break;
case|case
name|WRAP_FROMCVS
case|:
name|temp
operator|=
name|wrap_list
index|[
name|x
index|]
operator|->
name|fromcvsFilter
expr_stmt|;
break|break;
case|case
name|WRAP_CONFLICT
case|:
name|temp
operator|=
name|wrap_list
index|[
name|x
index|]
operator|->
name|conflictHook
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|WrapperEntry
modifier|*
name|wrap_matching_entry
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|count
init|=
name|wrap_count
operator|+
name|wrap_saved_count
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|fnmatch
argument_list|(
name|wrap_list
index|[
name|x
index|]
operator|->
name|wildCard
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|wrap_list
index|[
name|x
index|]
return|;
return|return
operator|(
name|WrapperEntry
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|wrap_tocvs_process_file
parameter_list|(
name|fileName
parameter_list|)
specifier|const
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|L_tmpnam
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|tocvsFilter
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tmpnam
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
name|e
operator|->
name|tocvsFilter
argument_list|,
name|fileName
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|wrap_merge_is_copy
parameter_list|(
name|fileName
parameter_list|)
specifier|const
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|mergeMethod
operator|==
name|WRAP_MERGE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|wrap_fromcvs_process_file
parameter_list|(
name|fileName
parameter_list|)
specifier|const
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|fromcvsFilter
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|run_setup
argument_list|(
name|e
operator|->
name|fromcvsFilter
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

